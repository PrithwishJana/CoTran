import math NEW_LINE class PrimeNumberGenerator : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = 2000000 NEW_LINE self . isPrime = [ True ] * ( self . N + 1 ) NEW_LINE self . isPrime [ 0 ] = False NEW_LINE self . isPrime [ 1 ] = False NEW_LINE limit = int ( math . sqrt ( self . N ) ) NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if not self . isPrime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i * 2 , self . N + 1 , i ) : NEW_LINE INDENT self . isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . isPrime [ index ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT pg = PrimeNumberGenerator ( ) NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if pg . is_prime ( n ) : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT begin = - 1 NEW_LINE end = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if pg . is_prime ( i ) : NEW_LINE INDENT begin = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n + 1 , 2000000 ) : NEW_LINE INDENT if pg . is_prime ( i ) : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( end - begin ) NEW_LINE DEDENT DEDENT
MAX_CHAR = 26 NEW_LINE def countFreq ( str , freq , len ) : NEW_LINE INDENT for i in range ( len ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT def canMakePalindrome ( freq , len ) : NEW_LINE INDENT count_odd = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if freq [ i ] % 2 != 0 : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT if len % 2 == 0 : NEW_LINE INDENT if count_odd > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if count_odd != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def findOddAndRemoveItsFreq ( freq ) : NEW_LINE INDENT odd_str = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if freq [ i ] % 2 != 0 : NEW_LINE INDENT freq [ i ] -= 1 NEW_LINE odd_str = odd_str + chr ( i + ord ( ' a ' ) ) NEW_LINE return odd_str NEW_LINE DEDENT DEDENT return odd_str NEW_LINE DEDENT def findPalindromicString ( str ) : NEW_LINE INDENT len_str = len ( str ) NEW_LINE freq = [ 0 ] * MAX_CHAR NEW_LINE countFreq ( str , freq , len_str ) NEW_LINE if not canMakePalindrome ( freq , len_str ) : NEW_LINE INDENT return " No ▁ Palindromic ▁ String " NEW_LINE DEDENT odd_str = findOddAndRemoveItsFreq ( freq ) NEW_LINE front_str = " " NEW_LINE rear_str = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT temp = " " NEW_LINE if freq [ i ] != 0 : NEW_LINE INDENT ch = chr ( i + ord ( ' a ' ) ) NEW_LINE for j in range ( 1 , freq [ i ] // 2 + 1 ) : NEW_LINE INDENT temp = temp + ch NEW_LINE DEDENT front_str = front_str + temp NEW_LINE rear_str = temp + rear_str NEW_LINE DEDENT DEDENT return front_str + odd_str + rear_str NEW_LINE DEDENT str = " malayalam " NEW_LINE print ( findPalindromicString ( str ) ) NEW_LINE
from math import sqrt NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . inp = input ( ) NEW_LINE self . q = int ( self . inp ) NEW_LINE for i in range ( self . q ) : NEW_LINE INDENT self . doIt ( ) NEW_LINE DEDENT DEDENT class CGL_2B : NEW_LINE INDENT def segSegDist ( self , l1 , l2 ) : NEW_LINE INDENT if l1 . intersects ( l2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return min ( min ( l1 . ptSegDist ( l2 . getP1 ( ) ) , l1 . ptSegDist ( l2 . getP2 ( ) ) ) , min ( l2 . ptSegDist ( l1 . getP1 ( ) ) , l2 . ptSegDist ( l1 . getP2 ( ) ) ) ) NEW_LINE DEDENT DEDENT def doIt ( self ) : NEW_LINE INDENT l1 = Line2D ( ( float ( input ( ) ) , float ( input ( ) ) ) , ( float ( input ( ) ) , float ( input ( ) ) ) ) NEW_LINE l2 = Line2D ( ( float ( input ( ) ) , float ( input ( ) ) ) , ( float ( input ( ) ) , float ( input ( ) ) ) ) NEW_LINE print ( " { : . 10f } " . format ( self . segSegDist ( l1 , l2 ) ) ) NEW_LINE DEDENT DEDENT DEDENT
class GFG : NEW_LINE INDENT def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 ] * 9 NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_sum = 0 NEW_LINE continuous_zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if int ( number [ i ] ) == 0 : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += int ( number [ i ] ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE DEDENT return result NEW_LINE DEDENT print ( count9s ( "01809" ) ) NEW_LINE print ( count9s ( "1809" ) ) NEW_LINE print ( count9s ( "4189" ) ) NEW_LINE DEDENT
import math NEW_LINE def fastPow ( N , K ) : NEW_LINE INDENT if K == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = fastPow ( N , K // 2 ) NEW_LINE if K % 2 == 0 : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return N * temp * temp NEW_LINE DEDENT DEDENT def countWays ( N , K ) : NEW_LINE INDENT return K * fastPow ( K - 1 , N - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE K = 3 NEW_LINE print ( countWays ( N , K ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT s = [ [ 0 , 1 , 1 , 1 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 0 , 1 , 1 , 0 ] , [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 0 , 0 , 1 , 1 , 0 ] , [ 1 , 1 , 0 , 1 , 1 , 0 , 1 ] , [ 1 , 1 , 1 , 1 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 0 , 1 , 1 , 1 , 1 ] ] NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE if n == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT while n > 0 : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT print ( a [ i ] ^ s [ m ] [ i ] , end = " \n " if i == 6 else " " ) NEW_LINE DEDENT a = s [ m ] [ : ] NEW_LINE n -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while product < n : NEW_LINE INDENT product *= arr [ i ] NEW_LINE if product + 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if isEuclid ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = 42 NEW_LINE if isEuclid ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import math NEW_LINE MAX = 1000000 NEW_LINE arr = [ ] NEW_LINE prime = [ True ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if not prime [ n ] : NEW_LINE INDENT return False NEW_LINE DEDENT product = 1 NEW_LINE i = 0 NEW_LINE while product < n : NEW_LINE INDENT product *= arr [ i ] NEW_LINE if product + 1 == n or product - 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if isPrimorialPrime ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def mul_table ( N , i ) : NEW_LINE INDENT if i > 10 : NEW_LINE INDENT return NEW_LINE DEDENT print ( N , " * " , i , " = " , N * i ) NEW_LINE mul_table ( N , i + 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = 8 NEW_LINE mul_table ( N , 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def closestNumber ( n , m ) : NEW_LINE INDENT q = n // m NEW_LINE n1 = m * q NEW_LINE n2 = ( m * ( q + 1 ) ) if ( n * m ) > 0 else ( m * ( q - 1 ) ) NEW_LINE if abs ( n - n1 ) < abs ( n - n2 ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT print ( closestNumber ( 13 , 4 ) ) NEW_LINE print ( closestNumber ( - 15 , 6 ) ) NEW_LINE print ( closestNumber ( 0 , 8 ) ) NEW_LINE print ( closestNumber ( 18 , - 7 ) ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def solve ( ang , n ) : NEW_LINE INDENT if ( ang * n ) > ( 180 * ( n - 2 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ang * n ) % 180 != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) // 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( GFG . solve ( ang , n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def compute_lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 ] * n NEW_LINE length = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == s [ length ] : NEW_LINE INDENT length += 1 NEW_LINE lps [ i ] = length NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if length != 0 : NEW_LINE INDENT length = lps [ length - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT @ staticmethod NEW_LINE def longest_substring ( s ) : NEW_LINE INDENT lps = GFG . compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if lps [ n - 1 ] == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if lps [ i ] == lps [ n - 1 ] : NEW_LINE INDENT print ( s [ : lps [ i ] ] ) NEW_LINE return NEW_LINE DEDENT DEDENT if lps [ lps [ n - 1 ] - 1 ] == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ : lps [ lps [ n - 1 ] - 1 ] ] ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT s = " fixprefixsuffix " NEW_LINE GFG . longest_substring ( s ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = float ( ' inf ' ) NEW_LINE maxEle = float ( ' - inf ' ) NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < minEle : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = True NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag1 = False NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = True NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag2 = False NEW_LINE break NEW_LINE DEDENT DEDENT if minIndex == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT if flag1 and flag2 and ( arr [ n - 1 ] < arr [ minIndex - 1 ] ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class IS : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT self . runapp ( ) NEW_LINE DEDENT def runapp ( self ) : NEW_LINE INDENT scan = input ( ) NEW_LINE n , d = map ( int , scan . split ( ) ) NEW_LINE sequence = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE step = 0 NEW_LINE store = 0 NEW_LINE for y in range ( n - 1 ) : NEW_LINE INDENT while sequence [ y + 1 ] <= sequence [ y ] : NEW_LINE INDENT diff = sequence [ y + 1 ] - sequence [ y ] NEW_LINE if sequence [ y + 1 ] == sequence [ y ] : NEW_LINE INDENT sequence [ y + 1 ] += d NEW_LINE step += 1 NEW_LINE DEDENT else : NEW_LINE INDENT diff = - diff NEW_LINE store = ( diff // d ) + 1 NEW_LINE step += store NEW_LINE sequence [ y + 1 ] += ( d * store ) NEW_LINE DEDENT DEDENT DEDENT print ( step ) NEW_LINE DEDENT DEDENT IS ( ) . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def checkIfPowerIsolated ( num ) : NEW_LINE INDENT input = num NEW_LINE count = 0 NEW_LINE factor = [ 0 ] * ( num + 1 ) NEW_LINE if num % 2 == 0 : NEW_LINE INDENT while num % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE num //= 2 NEW_LINE DEDENT factor [ 2 ] = count NEW_LINE DEDENT i = 3 NEW_LINE while i * i <= num : NEW_LINE INDENT count = 0 NEW_LINE while num % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE num //= i NEW_LINE DEDENT if count > 0 : NEW_LINE INDENT factor [ i ] = count NEW_LINE DEDENT i += 2 NEW_LINE DEDENT if num > 1 : NEW_LINE INDENT factor [ num ] = 1 NEW_LINE DEDENT product = 1 NEW_LINE for i in range ( num + 1 ) : NEW_LINE INDENT if factor [ i ] > 0 : NEW_LINE INDENT product = product * factor [ i ] * i NEW_LINE DEDENT DEDENT if product == input : NEW_LINE INDENT print ( " Power - isolated ▁ Integer " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Power - isolated ▁ Integer " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT checkIfPowerIsolated ( 12 ) NEW_LINE checkIfPowerIsolated ( 18 ) NEW_LINE checkIfPowerIsolated ( 35 ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE s = input ( ) NEW_LINE len = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if len % 2 == 0 and s [ i ] == ' A ' or len % 2 == 1 and s [ i ] == ' Z ' : NEW_LINE INDENT len += 1 NEW_LINE DEDENT DEDENT len //= 2 NEW_LINE if len == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT sb = " " NEW_LINE for i in range ( len ) : NEW_LINE INDENT sb += " AZ " NEW_LINE DEDENT print ( sb ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def solve ( arr ) : NEW_LINE INDENT max_val = - 1 NEW_LINE prev_map = { } NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] in prev_map : NEW_LINE INDENT prev = prev_map [ arr [ i ] ] . prev NEW_LINE count = prev + len ( arr ) - i NEW_LINE if count > max_val : NEW_LINE INDENT max_val = count NEW_LINE DEDENT prev_map [ arr [ i ] ] . prev = i NEW_LINE DEDENT else : NEW_LINE INDENT class Diff : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . prev = i NEW_LINE DEDENT DEDENT diff = Diff ( ) NEW_LINE prev_map [ arr [ i ] ] = diff NEW_LINE DEDENT DEDENT print ( max_val ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE solve ( arr ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if len1 == 0 or len2 == 0 : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 ] * ( len1 + len2 ) NEW_LINE i_n1 = 0 NEW_LINE i_n2 = 0 NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = int ( num1 [ i ] ) NEW_LINE i_n2 = 0 NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = int ( num2 [ j ] ) NEW_LINE sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry NEW_LINE carry = sum // 10 NEW_LINE result [ i_n1 + i_n2 ] = sum % 10 NEW_LINE i_n2 += 1 NEW_LINE DEDENT if carry > 0 : NEW_LINE INDENT result [ i_n1 + i_n2 ] += carry NEW_LINE DEDENT i_n1 += 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while i >= 0 and result [ i ] == 0 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if i == - 1 : NEW_LINE INDENT return "0" NEW_LINE DEDENT s = " " NEW_LINE while i >= 0 : NEW_LINE INDENT s += str ( result [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = "1235421415454545454545454544" NEW_LINE str2 = "1714546546546545454544548544544545" NEW_LINE if ( str1 [ 0 ] == ' - ' or str2 [ 0 ] == ' - ' ) and ( str1 [ 0 ] != ' - ' or str2 [ 0 ] != ' - ' ) : NEW_LINE INDENT print ( " - " ) NEW_LINE DEDENT if str1 [ 0 ] == ' - ' and str2 [ 0 ] != ' - ' : NEW_LINE INDENT str1 = str1 [ 1 : ] NEW_LINE DEDENT elif str1 [ 0 ] != ' - ' and str2 [ 0 ] == ' - ' : NEW_LINE INDENT str2 = str2 [ 1 : ] NEW_LINE DEDENT elif str1 [ 0 ] == ' - ' and str2 [ 0 ] == ' - ' : NEW_LINE INDENT str1 = str1 [ 1 : ] NEW_LINE str2 = str2 [ 1 : ] NEW_LINE DEDENT print ( multiply ( str1 , str2 ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum = 0 NEW_LINE arr1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum1 += arr1 [ i ] NEW_LINE DEDENT if sum >= sum1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = input ( ) NEW_LINE if k > n // 2 : NEW_LINE INDENT while k < n : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE k += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while k > 1 : NEW_LINE INDENT print ( " LEFT " ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT if k == 1 : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT print ( " PRINT " , a [ i ] ) NEW_LINE if i + 1 < len ( a ) : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( " PRINT " , a [ i ] ) NEW_LINE if i - 1 >= 0 : NEW_LINE INDENT print ( " LEFT " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
import java NEW_LINE def printDistSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT dp = [ [ False for i in range ( sum + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if dp [ i - 1 ] [ j ] == True : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( sum + 1 ) : NEW_LINE INDENT if dp [ n ] [ j ] == True : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printDistSum ( arr , n ) NEW_LINE DEDENT
def Subtract ( a , b ) : NEW_LINE INDENT c = a + ( ~ b + 1 ) NEW_LINE return c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE print ( Subtract ( a , b ) ) NEW_LINE a = 9 NEW_LINE b = 7 NEW_LINE print ( Subtract ( a , b ) ) NEW_LINE DEDENT
import sys NEW_LINE n1 = int ( input ( ) ) NEW_LINE n = int ( ( ( 1 + 8 * n1 ) ** 0.5 - 1 ) / 2 ) NEW_LINE ans = n1 - ( ( n + 1 ) * n ) // 2 NEW_LINE print ( ans if ans != 0 else n ) NEW_LINE
` ` ` python NEW_LINE class Codeforces : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] -= 1 NEW_LINE DEDENT lt = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == arr [ arr [ arr [ i ] ] ] : NEW_LINE INDENT lt = True NEW_LINE break NEW_LINE DEDENT DEDENT if lt : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT cf = Codeforces ( ) NEW_LINE cf . main ( ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def nextZero ( i , occurrences ) : NEW_LINE INDENT while i < len ( occurrences ) : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def getModifiedString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if n > 26 : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT ch = list ( str ) NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = GFG . nextZero ( 0 , occurrences ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE ch [ i ] = chr ( ord ( ' a ' ) + index ) NEW_LINE occurrences [ index ] = 1 NEW_LINE index = GFG . nextZero ( index + 1 , occurrences ) NEW_LINE DEDENT DEDENT return ' ' . join ( ch ) NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE print ( GFG . getModifiedString ( str ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class planet : NEW_LINE INDENT FLIP = [ 0 , 1 , 5 , - 1 , - 1 , 2 , - 1 , - 1 , 8 , - 1 ] NEW_LINE def main ( self , args ) : NEW_LINE INDENT nC = int ( input ( ) ) NEW_LINE for loop in range ( nC ) : NEW_LINE INDENT hr = int ( input ( ) ) NEW_LINE min = int ( input ( ) ) NEW_LINE tok = input ( ) . split ( " : " ) NEW_LINE sHr = int ( tok [ 0 ] ) NEW_LINE sMin = int ( tok [ 1 ] ) NEW_LINE res = None NEW_LINE for i in range ( sHr * min + sMin , hr * min ) : NEW_LINE INDENT res = self . flip ( i , hr , min ) NEW_LINE if res is not None : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if res is None : NEW_LINE INDENT res = [ 0 , 0 , 0 , 0 ] NEW_LINE DEDENT print ( " % d % d : % d % d " % ( res [ 0 ] , res [ 1 ] , res [ 2 ] , res [ 3 ] ) ) NEW_LINE DEDENT DEDENT def flip ( self , val , hr , min ) : NEW_LINE INDENT thisHr = val // min NEW_LINE thisMin = val % min NEW_LINE disp = [ thisMin % 10 , thisMin // 10 , thisHr % 10 , thisHr // 10 ] NEW_LINE for i in range ( len ( disp ) ) : NEW_LINE INDENT if self . FLIP [ disp [ i ] ] == - 1 : NEW_LINE INDENT return None NEW_LINE DEDENT disp [ i ] = self . FLIP [ disp [ i ] ] NEW_LINE DEDENT newHr = 10 * disp [ 0 ] + disp [ 1 ] NEW_LINE newMin = 10 * disp [ 2 ] + disp [ 3 ] NEW_LINE if newHr >= hr or newMin >= min : NEW_LINE INDENT return None NEW_LINE DEDENT return [ thisHr // 10 , thisHr % 10 , thisMin // 10 , thisMin % 10 ] NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE import math NEW_LINE class A : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = self . FastReader ( ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = self . sc . nextInt ( ) NEW_LINE nax = 105 NEW_LINE a = self . sc . readArray ( n ) NEW_LINE cnts = [ 0 ] * nax NEW_LINE for e in a : NEW_LINE INDENT cnts [ e + 1 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE pre = [ 0 ] * nax NEW_LINE for i in range ( 1 , nax ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + cnts [ i ] NEW_LINE val = ( pre [ i ] + i - 1 ) // i NEW_LINE ans = max ( ans , val ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT def ruffleSort ( self , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return a NEW_LINE DEDENT class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin . readline ( ) NEW_LINE self . pointer = 0 NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . pointer == len ( self . input ) or self . input [ self . pointer ] == ' ▁ ' or self . input [ self . pointer ] == ' \n ' : NEW_LINE INDENT if self . pointer == len ( self . input ) : NEW_LINE INDENT self . input = sys . stdin . readline ( ) NEW_LINE self . pointer = 0 NEW_LINE DEDENT else : NEW_LINE INDENT self . pointer += 1 NEW_LINE DEDENT DEDENT start = self . pointer NEW_LINE while self . pointer < len ( self . input ) and self . input [ self . pointer ] != ' ▁ ' and self . input [ self . pointer ] != ' \n ' : NEW_LINE INDENT self . pointer += 1 NEW_LINE DEDENT return self . input [ start : self . pointer ] NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def readArray ( self , n ) : NEW_LINE INDENT a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a . append ( self . nextInt ( ) ) NEW_LINE DEDENT return a NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT obj = A ( ) NEW_LINE obj . main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT binary_str = bin ( n ) [ 2 : ] NEW_LINE binary_str = '0' * ( len ( binary_str ) - 1 ) + '1' NEW_LINE val = int ( binary_str , 2 ) NEW_LINE print ( val ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = [ False ] * ( n + 3 ) NEW_LINE arr [ 0 ] = True NEW_LINE arr [ 1 ] = True NEW_LINE count = 0 NEW_LINE for i in range ( 2 , len ( arr ) ) : NEW_LINE INDENT if not arr [ i ] : NEW_LINE INDENT for j in range ( 2 , ( len ( arr ) // i ) ) : NEW_LINE INDENT arr [ i * j ] = True NEW_LINE DEDENT if not arr [ i ] and not arr [ i - 2 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count * 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class League : NEW_LINE INDENT def solve ( self , in_stream , out_stream ) : NEW_LINE INDENT n = int ( in_stream . readline ( ) ) NEW_LINE num = 0 NEW_LINE a = [ 0 ] * 1000001 NEW_LINE start = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num += int ( in_stream . readline ( ) ) NEW_LINE for j in range ( start , num ) : NEW_LINE INDENT a [ j ] = i NEW_LINE DEDENT start = num NEW_LINE DEDENT m = int ( in_stream . readline ( ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT out_stream . write ( str ( a [ int ( in_stream . readline ( ) ) - 1 ] ) + " \n " ) NEW_LINE DEDENT DEDENT def run ( self ) : NEW_LINE INDENT self . solve ( sys . stdin , sys . stdout ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT League ( ) . run ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE pre = [ 0 ] * ( n + 1 ) NEW_LINE prevSum = dp [ 1 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i != 1 : NEW_LINE INDENT pre [ i ] = ( pre [ i - 1 ] + pre [ i ] ) % m NEW_LINE dp [ i ] = ( prevSum + pre [ i ] ) % m NEW_LINE prevSum = ( prevSum + dp [ i ] ) % m NEW_LINE DEDENT p = 2 NEW_LINE j = 2 * i NEW_LINE while j <= n : NEW_LINE INDENT r = j + p NEW_LINE pre [ j ] = ( pre [ j ] + dp [ i ] ) % m NEW_LINE if r <= n : NEW_LINE INDENT pre [ r ] = ( ( pre [ r ] - dp [ i ] ) % m + m ) % m NEW_LINE DEDENT p += 1 NEW_LINE j = p * i NEW_LINE DEDENT DEDENT print ( dp [ n ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from collections import deque NEW_LINE def printMax ( arr , n , k ) : NEW_LINE INDENT Qi = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT while Qi and arr [ i ] >= arr [ Qi [ - 1 ] ] : NEW_LINE INDENT Qi . pop ( ) NEW_LINE DEDENT Qi . append ( i ) NEW_LINE DEDENT for i in range ( i , n ) : NEW_LINE INDENT print ( arr [ Qi [ 0 ] ] , end = " ▁ " ) NEW_LINE while Qi and Qi [ 0 ] <= i - k : NEW_LINE INDENT Qi . popleft ( ) NEW_LINE DEDENT while Qi and arr [ i ] >= arr [ Qi [ - 1 ] ] : NEW_LINE INDENT Qi . pop ( ) NEW_LINE DEDENT Qi . append ( i ) NEW_LINE DEDENT print ( arr [ Qi [ 0 ] ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 12 , 1 , 78 , 90 , 57 , 89 , 56 ] NEW_LINE k = 3 NEW_LINE printMax ( arr , len ( arr ) , k ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while b > 0 : NEW_LINE INDENT if b & 1 != 0 : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( russianPeasant ( 18 , 1 ) ) NEW_LINE print ( russianPeasant ( 20 , 12 ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
def is_valid ( str , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if str [ i ] == str [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "0110" NEW_LINE length = len ( str ) NEW_LINE if is_valid ( str , length ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT DEDENT
import random NEW_LINE def lehmann ( n , t ) : NEW_LINE INDENT a = random . randint ( 2 , n - 3 ) NEW_LINE e = ( n - 1 ) / 2 NEW_LINE while t > 0 : NEW_LINE INDENT result = pow ( a , e , n ) NEW_LINE if result % n == 1 or result % n == n - 1 : NEW_LINE INDENT a = random . randint ( 2 , n - 3 ) NEW_LINE t -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 13 NEW_LINE t = 10 NEW_LINE if n == 2 : NEW_LINE INDENT print ( "2 ▁ is ▁ Prime . " ) NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT print ( str ( n ) + " ▁ is ▁ Composite " ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = lehmann ( n , t ) NEW_LINE if flag == 1 : NEW_LINE INDENT print ( str ( n ) + " ▁ may ▁ be ▁ Prime . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str ( n ) + " ▁ is ▁ Composite . " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE for _ in range ( num ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE res = 0 NEW_LINE while a != 0 and b != 0 : NEW_LINE INDENT if a >= b : NEW_LINE INDENT res += a // b NEW_LINE a %= b NEW_LINE DEDENT else : NEW_LINE INDENT res += b // a NEW_LINE b %= a NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE from collections import defaultdict NEW_LINE class CP : NEW_LINE INDENT class Scanner : NEW_LINE INDENT def __init__ ( self , s ) : NEW_LINE INDENT self . br = s NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return next ( self . br ) . strip ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return CP . gcd ( b , a % b ) NEW_LINE DEDENT @ staticmethod NEW_LINE def printArrayList ( al ) : NEW_LINE INDENT print ( * al ) NEW_LINE DEDENT @ staticmethod NEW_LINE def digitSum ( n ) : NEW_LINE INDENT return sum ( int ( digit ) for digit in str ( n ) ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT s = CP . Scanner ( sys . stdin ) NEW_LINE sb = [ ] NEW_LINE st = s . next ( ) NEW_LINE k = s . nextInt ( ) NEW_LINE hs = set ( st ) NEW_LINE if len ( st ) < k : NEW_LINE INDENT sb . append ( " impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT if k <= len ( hs ) : NEW_LINE INDENT sb . append ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT sb . append ( str ( k - len ( hs ) ) ) NEW_LINE DEDENT DEDENT print ( " ▁ " . join ( sb ) ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT CP . main ( sys . argv ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT N = 3 NEW_LINE @ staticmethod NEW_LINE def MaxTraceSub ( mat ) : NEW_LINE INDENT max_trace = 0 NEW_LINE for i in range ( GFG . N ) : NEW_LINE INDENT for j in range ( GFG . N ) : NEW_LINE INDENT r , s , trace = i , j , 0 NEW_LINE while r < GFG . N and s < GFG . N : NEW_LINE INDENT trace += mat [ r ] [ s ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE max_trace = max ( trace , max_trace ) NEW_LINE DEDENT DEDENT DEDENT return max_trace NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT mat = [ [ 10 , 2 , 5 ] , [ 6 , 10 , 4 ] , [ 2 , 7 , - 10 ] ] NEW_LINE print ( GFG . MaxTraceSub ( mat ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT xa1 , ya1 , xa2 , ya2 , xb1 , yb1 , xb2 , yb2 = map ( float , line . split ( ) ) NEW_LINE xaMin , xaMax = min ( xa1 , xa2 ) , max ( xa1 , xa2 ) NEW_LINE xbMin , xbMax = min ( xb1 , xb2 ) , max ( xb1 , xb2 ) NEW_LINE yaMin , yaMax = min ( ya1 , ya2 ) , max ( ya1 , ya2 ) NEW_LINE ybMin , ybMax = min ( yb1 , yb2 ) , max ( yb1 , yb2 ) NEW_LINE if xaMax < xbMin or xbMax < xaMin or yaMax < ybMin or ybMax < yaMin : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE t = int ( input ( ) ) NEW_LINE for tt in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE bit = [ 0 ] * 32 NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE INDENT temp = ( 1 << j ) NEW_LINE bitwiseAnd = arr [ i ] & temp NEW_LINE if bitwiseAnd > 0 : NEW_LINE INDENT bit [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT possible = True NEW_LINE for j in range ( 32 ) : NEW_LINE INDENT if bit [ j ] % i != 0 : NEW_LINE INDENT possible = False NEW_LINE break NEW_LINE DEDENT DEDENT if possible : NEW_LINE INDENT sys . stdout . write ( str ( i ) + " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
import math NEW_LINE def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if divCount % 2 != 0 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_val = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = int ( arr [ i ] / m ) NEW_LINE if x >= max_val : NEW_LINE INDENT max_val = x NEW_LINE ans = i NEW_LINE DEDENT DEDENT print ( ans + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def replacedArray ( N , arr ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE if arr [ i ] > 0 : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ i ] NEW_LINE DEDENT arr [ i ] = abs ( diff ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 ] NEW_LINE GFG . replacedArray ( N , arr ) NEW_LINE GFG . printArray ( N , arr ) NEW_LINE N = 6 NEW_LINE arr1 = [ - 3 , - 4 , - 2 , 5 , 1 , - 2 ] NEW_LINE GFG . replacedArray ( N , arr1 ) NEW_LINE GFG . printArray ( N , arr1 ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def replacedArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT if arr [ j ] > 0 : NEW_LINE INDENT pos_sum += arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ j ] NEW_LINE DEDENT DEDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE arr [ i ] = abs ( diff ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 ] NEW_LINE replacedArray ( N , arr ) NEW_LINE printArray ( N , arr ) NEW_LINE N = 6 NEW_LINE arr1 = [ - 3 , - 4 , - 2 , 5 , 1 , - 2 ] NEW_LINE replacedArray ( N , arr1 ) NEW_LINE printArray ( N , arr1 ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countDivisbleby4 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT h = int ( s [ i ] ) * 10 + int ( s [ i + 1 ] ) NEW_LINE if h % 4 == 0 : NEW_LINE INDENT count += i + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "124" NEW_LINE print ( countDivisbleby4 ( s ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if max ( a [ 0 ] , a [ 1 ] ) > min ( a [ 2 ] , a [ 3 ] ) and max ( a [ 2 ] , a [ 3 ] ) > min ( a [ 0 ] , a [ 1 ] ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE number = int ( input ( ) ) NEW_LINE ans = - 1 NEW_LINE value = 0 NEW_LINE mask = 2 NEW_LINE while value < number : NEW_LINE INDENT s = bin ( mask ) [ 2 : ] NEW_LINE zeros = s . count ( '0' ) NEW_LINE if zeros != len ( s ) - zeros : NEW_LINE INDENT mask += 1 NEW_LINE continue NEW_LINE DEDENT s = s . replace ( '0' , '4' ) NEW_LINE s = s . replace ( '1' , '7' ) NEW_LINE value = int ( s , 2 ) NEW_LINE mask += 1 NEW_LINE DEDENT print ( value ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT cases = int ( input ( ) ) NEW_LINE for _ in range ( cases ) : NEW_LINE INDENT n , target = map ( int , input ( ) . split ( ) ) NEW_LINE nums = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE helper ( nums , target ) NEW_LINE DEDENT DEDENT def helper ( nums , target ) : NEW_LINE INDENT isTargetFound = False NEW_LINE canPrintYes = False NEW_LINE score = 0 NEW_LINE prev = - 1 NEW_LINE for num in nums : NEW_LINE INDENT if num == target : NEW_LINE INDENT isTargetFound = True NEW_LINE DEDENT if num < target : NEW_LINE INDENT score -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT score += 1 NEW_LINE DEDENT if score > 0 and prev > - 1 : NEW_LINE INDENT canPrintYes = True NEW_LINE DEDENT prev = score NEW_LINE score = max ( score , 0 ) NEW_LINE DEDENT if ( len ( nums ) == 1 or canPrintYes ) and isTargetFound : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java . util . * ; NEW_LINE class Smooth : NEW_LINE INDENT sc = Scanner ( System . in ) NEW_LINE memo = [ [ - 1 for i in range ( 257 ) ] for j in range ( 100 ) ] NEW_LINE def main ( args ) : NEW_LINE INDENT T = sc . nextInt ( ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT System . out . print ( " Case ▁ # " + str ( i ) + " : ▁ " ) NEW_LINE solveCase ( ) NEW_LINE DEDENT DEDENT SPC = 256 NEW_LINE def solveCase ( ) : NEW_LINE INDENT del = sc . nextInt ( ) NEW_LINE ins = sc . nextInt ( ) NEW_LINE maxDist = sc . nextInt ( ) NEW_LINE n = sc . nextInt ( ) NEW_LINE arr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = sc . nextInt ( ) NEW_LINE DEDENT for arr in memo : NEW_LINE INDENT Arrays . fill ( arr , - 1 ) NEW_LINE DEDENT System . out . println ( solve ( 0 , SPC ) ) NEW_LINE DEDENT def solve ( index , prev ) : NEW_LINE INDENT if index >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if memo [ index ] [ prev ] == - 1 : NEW_LINE INDENT res = del + solve ( index + 1 , prev ) NEW_LINE for val in range ( SPC ) : NEW_LINE INDENT res = Math . min ( res , abs ( arr [ index ] - val ) + insCost ( val , prev ) + solve ( index + 1 , val ) ) NEW_LINE DEDENT memo [ index ] [ prev ] = res NEW_LINE DEDENT return memo [ index ] [ prev ] NEW_LINE DEDENT def insCost ( cur , prev ) : NEW_LINE INDENT if prev == SPC or cur == prev : NEW_LINE INDENT return 0 NEW_LINE DEDENT if maxDist == 0 : NEW_LINE INDENT return 100000000 NEW_LINE DEDENT return ins * ( ( abs ( cur - prev ) + maxDist - 1 ) / maxDist - 1 ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = 12 NEW_LINE self . ofs = [ [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] , [ 0 , 1 ] ] NEW_LINE DEDENT def del_func ( self , map , y , x ) : NEW_LINE INDENT map [ y ] [ x ] = False NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT nx = x + self . ofs [ i ] [ 0 ] NEW_LINE ny = y + self . ofs [ i ] [ 1 ] NEW_LINE if 0 <= ny < self . N and 0 <= nx < self . N : NEW_LINE INDENT if map [ ny ] [ nx ] : NEW_LINE INDENT self . del_func ( map , ny , nx ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def solve ( self , map ) : NEW_LINE INDENT c = 0 NEW_LINE for y in range ( self . N ) : NEW_LINE INDENT for x in range ( self . N ) : NEW_LINE INDENT if map [ y ] [ x ] : NEW_LINE INDENT c += 1 NEW_LINE self . del_func ( map , y , x ) NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT def io ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT str_map = [ input ( ) for _ in range ( self . N ) ] NEW_LINE map = [ [ False ] * self . N for _ in range ( self . N ) ] NEW_LINE for y in range ( self . N ) : NEW_LINE INDENT for x in range ( self . N ) : NEW_LINE INDENT map [ y ] [ x ] = str_map [ y ] [ x ] == '1' NEW_LINE DEDENT DEDENT print ( self . solve ( map ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . io ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i - 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE n = len ( arr ) NEW_LINE if GFG . arraySortedOrNot ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x . sort ( ) NEW_LINE s = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT s += abs ( x [ i ] - x [ 0 ] ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def printKDistinct ( arr , n , k ) : NEW_LINE INDENT h = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT h [ arr [ i ] ] += 1 NEW_LINE DEDENT if len ( h ) < k : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if h [ arr [ i ] ] == 1 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if dist_count == k : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE print ( printKDistinct ( ar , n , 2 ) ) NEW_LINE DEDENT
0ERROR
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT str = input ( ) NEW_LINE num_1 = int ( str ) NEW_LINE str = input ( ) NEW_LINE num_2 = int ( str ) NEW_LINE str = input ( ) NEW_LINE num_3 = int ( str ) NEW_LINE if num_1 == 7 : NEW_LINE INDENT if num_2 == 5 and num_3 == 5 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT elif num_2 == 7 : NEW_LINE INDENT if num_1 == 5 and num_3 == 5 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT elif num_3 == 7 : NEW_LINE INDENT if num_2 == 5 and num_1 == 5 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE n , z , w = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( abs ( w - a [ 0 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans1 = abs ( a [ n - 2 ] - a [ n - 1 ] ) NEW_LINE ans2 = abs ( w - a [ n - 1 ] ) NEW_LINE print ( max ( ans1 , ans2 ) ) NEW_LINE DEDENT
import numpy as np NEW_LINE def countEleLessThanOrEqual ( arr1 , arr2 , m , n ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr2 [ j ] <= arr1 [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT return m NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr1 = np . array ( [ 1 , 2 , 3 , 4 , 7 , 9 ] ) NEW_LINE arr2 = np . array ( [ 0 , 1 , 2 , 1 , 1 , 4 ] ) NEW_LINE countEleLessThanOrEqual ( arr1 , arr2 , len ( arr1 ) , len ( arr2 ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def solve ( n , a , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return min ( a ) NEW_LINE DEDENT if k == 2 : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT dq = [ ] NEW_LINE lMin = float ( ' inf ' ) NEW_LINE rMin = float ( ' inf ' ) NEW_LINE ans = a [ 0 ] NEW_LINE for x in a : NEW_LINE INDENT dq . append ( x ) NEW_LINE DEDENT while dq : NEW_LINE INDENT lMin = min ( dq . pop ( 0 ) , lMin ) NEW_LINE if rMin == float ( ' inf ' ) and not dq : NEW_LINE INDENT rMin = float ( ' - inf ' ) NEW_LINE break NEW_LINE DEDENT if not dq : NEW_LINE INDENT break NEW_LINE DEDENT rMin = min ( dq [ - 1 ] , rMin ) NEW_LINE ans = max ( ans , max ( rMin , lMin ) ) NEW_LINE DEDENT ans = max ( ans , max ( rMin , lMin ) ) NEW_LINE return ans NEW_LINE DEDENT ans = float ( ' - inf ' ) NEW_LINE for x in a : NEW_LINE INDENT ans = max ( ans , x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = sys . stdin . readline NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( solve ( n , a , k ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE name1 , name2 = input ( ) . split ( ) NEW_LINE print ( name1 , name2 ) NEW_LINE n = int ( input ( ) ) NEW_LINE while True : NEW_LINE INDENT s1 , s2 = input ( ) . split ( ) NEW_LINE if s1 == name1 : NEW_LINE INDENT name1 = s2 NEW_LINE DEDENT if s1 == name2 : NEW_LINE INDENT name2 = s2 NEW_LINE DEDENT print ( name1 , name2 ) NEW_LINE n -= 1 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE import math NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT inputStream = sys . stdin NEW_LINE outputStream = sys . stdout NEW_LINE in_ = InputReader ( inputStream ) NEW_LINE out = PrintWriter ( outputStream ) NEW_LINE solver = TaskA ( ) NEW_LINE solver . solve ( 1 , in_ , out ) NEW_LINE out . close ( ) NEW_LINE DEDENT DEDENT class TaskA : NEW_LINE INDENT def solve ( self , testNumber , in_ , out ) : NEW_LINE INDENT n = in_ . nextInt ( ) NEW_LINE s = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ i ] = in_ . nextInt ( ) NEW_LINE DEDENT s . sort ( ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT out . println ( s [ n // 2 - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT out . println ( s [ ( n + 1 ) // 2 - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT class InputReader : NEW_LINE INDENT def __init__ ( self , stream ) : NEW_LINE INDENT self . reader = stream NEW_LINE self . tokenizer = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . tokenizer is None or not self . tokenizer . hasMoreTokens ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . tokenizer = StringTokenizer ( self . reader . readLine ( ) ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT raise RuntimeError ( e ) NEW_LINE DEDENT DEDENT return self . tokenizer . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . main ( ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE class TaskA : NEW_LINE INDENT def solve ( self , in_data ) : NEW_LINE INDENT k , p = map ( int , in_data . readline ( ) . split ( ) ) NEW_LINE total_sum = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT a = i NEW_LINE b = i NEW_LINE while a != 0 : NEW_LINE INDENT b = b * 10 + a % 10 NEW_LINE a //= 10 NEW_LINE DEDENT b = b % p NEW_LINE total_sum = ( total_sum + b ) % p NEW_LINE DEDENT return str ( total_sum ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT in_data = sys . stdin NEW_LINE out_data = sys . stdout NEW_LINE solver = TaskA ( ) NEW_LINE result = solver . solve ( in_data ) NEW_LINE out_data . write ( result ) NEW_LINE DEDENT
` ` ` python NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] -= 1 NEW_LINE p [ a [ i ] ] = i NEW_LINE DEDENT x = set ( ) NEW_LINE l = [ 0 ] * n NEW_LINE r = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT x . add ( p [ i ] ) NEW_LINE if min ( x ) == p [ i ] : NEW_LINE INDENT l [ i ] = p [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT lower = max ( num for num in x if num < p [ i ] ) NEW_LINE l [ i ] = p [ i ] - lower NEW_LINE DEDENT if max ( x ) == p [ i ] : NEW_LINE INDENT r [ i ] = n - p [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT high = min ( num for num in x if num > p [ i ] ) NEW_LINE r [ i ] = high - p [ i ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += l [ i ] * r [ i ] * ( i + 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE ` ` ` NEW_LINE
class LPS : NEW_LINE INDENT @ staticmethod NEW_LINE def max ( x , y ) : NEW_LINE INDENT return x if x > y else y NEW_LINE DEDENT @ staticmethod NEW_LINE def lps ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if seq [ i ] == seq [ j ] and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif seq [ i ] == seq [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = LPS . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is " , LPS . lps ( seq ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , end = ' ▁ ' ) NEW_LINE first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( " ▁ + ▁ " , x , end = ' ' ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( 0 , last ) : NEW_LINE INDENT if 2 * N == ( last - first ) * ( last + first + 1 ) : NEW_LINE INDENT print ( N , " ▁ = ▁ " , end = ' ' ) NEW_LINE GFG . printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT even , odd = map ( int , input ( ) . split ( ) ) NEW_LINE if even == 0 and odd == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT sub = abs ( even - odd ) NEW_LINE if sub <= 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def __gcd ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = __gcd ( x , y ) NEW_LINE ans = ( x * y ) // ( s * s ) NEW_LINE return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT m = 385 NEW_LINE n = 60 NEW_LINE print ( NumberOfSquares ( m , n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = list ( s ) NEW_LINE c . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if c [ i ] != s [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = " aabbbcc " NEW_LINE if isAlphabaticOrder ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def printKMax ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE for j in range ( 1 , k ) : NEW_LINE INDENT if arr [ i + j ] > max_val : NEW_LINE INDENT max_val = arr [ i + j ] NEW_LINE DEDENT DEDENT print ( max_val , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE k = 3 NEW_LINE GFG . printKMax ( arr , len ( arr ) , k ) NEW_LINE DEDENT DEDENT
from collections import defaultdict NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = defaultdict ( list ) NEW_LINE self . visited = [ ] NEW_LINE self . color = [ ] NEW_LINE self . one = 0 NEW_LINE self . bipartite = 0 NEW_LINE self . count = 0 NEW_LINE self . mujun = False NEW_LINE DEDENT def dfs ( self , a , c ) : NEW_LINE INDENT if self . visited [ a ] : NEW_LINE INDENT if self . color [ a ] >= 0 and self . color [ a ] != c : NEW_LINE INDENT self . mujun = True NEW_LINE DEDENT return 0 NEW_LINE DEDENT self . visited [ a ] = True NEW_LINE self . color [ a ] = c NEW_LINE total = 1 NEW_LINE for b in self . graph [ a ] : NEW_LINE INDENT total += self . dfs ( b , 1 - c ) NEW_LINE DEDENT return total NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT u , v = map ( int , input ( ) . split ( ) ) NEW_LINE self . graph [ u - 1 ] . append ( v - 1 ) NEW_LINE self . graph [ v - 1 ] . append ( u - 1 ) NEW_LINE DEDENT self . visited = [ False ] * n NEW_LINE self . color = [ - 1 ] * n NEW_LINE self . one = 0 NEW_LINE self . bipartite = 0 NEW_LINE self . count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if self . visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT self . count += 1 NEW_LINE self . mujun = False NEW_LINE kind = self . dfs ( i , 0 ) NEW_LINE if kind == 1 : NEW_LINE INDENT self . one += 1 NEW_LINE DEDENT elif not self . mujun : NEW_LINE INDENT self . bipartite += 1 NEW_LINE DEDENT DEDENT total = self . one * ( 2 * n - self . one ) NEW_LINE total += ( self . count - self . one ) * ( self . count - self . one ) NEW_LINE total += self . bipartite * self . bipartite NEW_LINE print ( total ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . run ( ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT inputStream = sys . stdin NEW_LINE outputStream = sys . stdout NEW_LINE in_ = InputReader ( inputStream ) NEW_LINE out = PrintWriter ( outputStream ) NEW_LINE solver = TaskA ( ) NEW_LINE solver . solve ( 1 , in_ , out ) NEW_LINE out . close ( ) NEW_LINE DEDENT DEDENT class TaskA : NEW_LINE INDENT def solve ( self , testNumber , in_ , out ) : NEW_LINE INDENT n = in_ . nextInt ( ) NEW_LINE m = in_ . nextInt ( ) NEW_LINE k = in_ . nextInt ( ) NEW_LINE c = 1 NEW_LINE s = m - n NEW_LINE l = k NEW_LINE r = k NEW_LINE while s >= r - l + 1 : NEW_LINE INDENT s -= r - l + 1 NEW_LINE c += 1 NEW_LINE if l > 1 : NEW_LINE INDENT l -= 1 NEW_LINE DEDENT if r < n : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT DEDENT class InputReader : NEW_LINE INDENT def __init__ ( self , stream ) : NEW_LINE INDENT self . reader = stream NEW_LINE self . tokenizer = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . tokenizer is None or not self . tokenizer . hasMoreTokens ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . tokenizer = self . reader . readline ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT raise RuntimeError ( e ) NEW_LINE DEDENT DEDENT return self . tokenizer . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT main = Main ( ) NEW_LINE main . run ( ) NEW_LINE DEDENT class P : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return self . x < other . x NEW_LINE DEDENT DEDENT def run ( self ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE points = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE points . append ( ( x , y ) ) NEW_LINE DEDENT ans = float ( ' inf ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT x1 , y1 = points [ i ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT x2 , y2 = points [ j ] NEW_LINE if x1 >= x2 : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( N ) : NEW_LINE INDENT y1 = points [ k ] [ 1 ] NEW_LINE for l in range ( N ) : NEW_LINE INDENT y2 = points [ l ] [ 1 ] NEW_LINE if y1 >= y2 : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE for m in range ( N ) : NEW_LINE INDENT if x1 <= points [ m ] [ 0 ] <= x2 and y1 <= points [ m ] [ 1 ] <= y2 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt == K : NEW_LINE INDENT ans = min ( ans , ( x2 - x1 ) * ( y2 - y1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . run ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
from collections import defaultdict NEW_LINE class Main : NEW_LINE INDENT def compare ( a , b ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] < b [ i ] : NEW_LINE INDENT return - 1 + ( i % 2 ) * 2 NEW_LINE DEDENT elif a [ i ] > b [ i ] : NEW_LINE INDENT return 1 - ( i % 2 ) * 2 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE ids = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT word = input ( ) NEW_LINE a . append ( word ) NEW_LINE ids [ word ] = i + 1 NEW_LINE DEDENT a . sort ( key = lambda x : Main . compare ( x , x ) ) NEW_LINE for x in a : NEW_LINE INDENT print ( ids [ x ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main . main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def pre_process ( substrings , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dup = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT dup += s [ j ] NEW_LINE substrings [ count ] = dup NEW_LINE count += 1 NEW_LINE DEDENT DEDENT size = len ( substrings ) NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( substrings ) ) : NEW_LINE INDENT if substrings [ i ] > substrings [ j ] : NEW_LINE INDENT temp = substrings [ i ] NEW_LINE substrings [ i ] = substrings [ j ] NEW_LINE substrings [ j ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT s = " geek " NEW_LINE substrings = [ " " ] * 10 NEW_LINE GFG . pre_process ( substrings , s ) NEW_LINE queries = [ 1 , 5 , 10 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( substrings [ queries [ i ] - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE while True : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if w == 0 and h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = " " NEW_LINE t = 0 NEW_LINE d = 0 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE c = " " NEW_LINE while True : NEW_LINE INDENT s = input ( ) NEW_LINE c = s [ 0 ] NEW_LINE if c == ' S ' : NEW_LINE INDENT print ( x + 1 , y + 1 ) NEW_LINE break NEW_LINE DEDENT elif c == ' R ' : NEW_LINE INDENT d += 1 NEW_LINE if d == 4 : NEW_LINE INDENT d = 0 NEW_LINE DEDENT DEDENT elif c == ' L ' : NEW_LINE INDENT d -= 1 NEW_LINE if d == - 1 : NEW_LINE INDENT d = 3 NEW_LINE DEDENT DEDENT elif ( c == ' F ' and d == 0 ) or ( c == ' B ' and d == 2 ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE y += t NEW_LINE if y > h - 1 : NEW_LINE INDENT y = h - 1 NEW_LINE DEDENT DEDENT elif ( c == ' F ' and d == 1 ) or ( c == ' B ' and d == 3 ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE x += t NEW_LINE if x > w - 1 : NEW_LINE INDENT x = w - 1 NEW_LINE DEDENT DEDENT elif ( c == ' F ' and d == 2 ) or ( c == ' B ' and d == 0 ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE y -= t NEW_LINE if y < 0 : NEW_LINE INDENT y = 0 NEW_LINE DEDENT DEDENT elif ( c == ' F ' and d == 3 ) or ( c == ' B ' and d == 1 ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE x -= t NEW_LINE if x < 0 : NEW_LINE INDENT x = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT
` ` ` python NEW_LINE class FileName : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE str = input ( ) NEW_LINE count = 0 NEW_LINE total = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] == ' x ' : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT if count >= 3 : NEW_LINE INDENT total += count - 2 NEW_LINE count = 0 NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT if count >= 3 : NEW_LINE INDENT total += count - 2 NEW_LINE count = 0 NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT DEDENT file_name = FileName ( ) NEW_LINE file_name . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE while True : NEW_LINE INDENT a = input ( ) NEW_LINE num = list ( a ) NEW_LINE if num [ 0 ] == '0' : NEW_LINE INDENT break NEW_LINE DEDENT A = 0 NEW_LINE B = 0 NEW_LINE for i in range ( 1 , len ( num ) ) : NEW_LINE INDENT if num [ i ] == ' A ' : NEW_LINE INDENT A += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT DEDENT if A > B : NEW_LINE INDENT A += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT print ( A , B ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def fact ( N ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT return product NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( N * N ) * fact ( N ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if isZeroPresent : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT k , x = map ( int , input ( ) . split ( ) ) NEW_LINE f = k * 9 NEW_LINE for y in range ( x , 9 ) : NEW_LINE INDENT f -= 1 NEW_LINE DEDENT print ( f ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE DEDENT L = 8 NEW_LINE B = 8 NEW_LINE X = 0 NEW_LINE Y = 0 NEW_LINE maximumArea ( L , B , X , Y ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT NO_OF_CHARS = 256 NEW_LINE @ staticmethod NEW_LINE def max_distinct_char ( str , n ) : NEW_LINE INDENT count = [ 0 ] * GFG . NO_OF_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT max_distinct = 0 NEW_LINE for i in range ( GFG . NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] != 0 : NEW_LINE INDENT max_distinct += 1 NEW_LINE DEDENT DEDENT return max_distinct NEW_LINE DEDENT @ staticmethod NEW_LINE def smallesteSubstr_maxDistictChar ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE max_distinct = GFG . max_distinct_char ( str , n ) NEW_LINE minl = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i < j : NEW_LINE INDENT subs = str [ i : j ] NEW_LINE DEDENT else : NEW_LINE INDENT subs = str [ j : i ] NEW_LINE DEDENT subs_length = len ( subs ) NEW_LINE sub_distinct_char = GFG . max_distinct_char ( subs , subs_length ) NEW_LINE if subs_length < minl and max_distinct == sub_distinct_char : NEW_LINE INDENT minl = subs_length NEW_LINE DEDENT DEDENT DEDENT return minl NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT str = " AABBBCBB " NEW_LINE len = GFG . smallesteSubstr_maxDistictChar ( str ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ smallest ▁ substring ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ characters ▁ : ▁ " + str ( len ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
` ` ` python NEW_LINE def aver ( arr ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT return sum / len ( arr ) NEW_LINE DEDENT def fac ( x ) : NEW_LINE INDENT sum = 1 NEW_LINE while x > 0 : NEW_LINE INDENT sum = sum * x NEW_LINE x = x - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT def comb ( x , y ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = fac ( x ) NEW_LINE temp = ( fac ( y ) * fac ( x - y ) ) NEW_LINE return sum / temp NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE while n > 0 : NEW_LINE INDENT input ( ) NEW_LINE input ( ) NEW_LINE f = list ( input ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE flag = True NEW_LINE for i in range ( len ( f ) ) : NEW_LINE INDENT if f [ i ] == " R " : NEW_LINE INDENT if s [ i ] == " B " or s [ i ] == " G " : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if s [ i ] == " R " : NEW_LINE INDENT if f [ i ] == " B " or f [ i ] == " G " : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT DEDENT if flag : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = n - 1 NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def findNumberOfEvenCells ( n , q , size ) : NEW_LINE INDENT row = [ 0 ] * n NEW_LINE col = [ 0 ] * n NEW_LINE for i in range ( size ) : NEW_LINE INDENT x = q [ i ] [ 0 ] NEW_LINE y = q [ i ] [ 1 ] NEW_LINE row [ x - 1 ] += 1 NEW_LINE col [ y - 1 ] += 1 NEW_LINE DEDENT r1 , r2 , c1 , c2 = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if row [ i ] % 2 == 0 : NEW_LINE INDENT r1 += 1 NEW_LINE DEDENT if row [ i ] % 2 == 1 : NEW_LINE INDENT r2 += 1 NEW_LINE DEDENT if col [ i ] % 2 == 0 : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if col [ i ] % 2 == 1 : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT count = r1 * c1 + r2 * c2 NEW_LINE return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 2 NEW_LINE q = [ [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , 1 ] ] NEW_LINE size = len ( q ) NEW_LINE print ( findNumberOfEvenCells ( n , q , size ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def checkType ( arr , n ) : NEW_LINE INDENT if arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] <= arr [ n - 1 ] : NEW_LINE INDENT print ( " Increasing " ) NEW_LINE DEDENT elif arr [ 0 ] >= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] : NEW_LINE INDENT print ( " Decreasing " ) NEW_LINE DEDENT elif arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] : NEW_LINE INDENT print ( " Increasing ▁ then ▁ decreasing " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Decreasing ▁ then ▁ increasing " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE checkType ( arr , n ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( input ( ) ) NEW_LINE arr2 = [ '0' if i % 2 == 0 else '1' for i in range ( n ) ] NEW_LINE cur = 0 NEW_LINE j = 0 NEW_LINE while j < n : NEW_LINE INDENT if arr [ j ] == arr2 [ j ] : NEW_LINE INDENT j += 1 NEW_LINE continue NEW_LINE DEDENT k = j NEW_LINE while k < n and arr [ k ] != arr2 [ k ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT cur += 1 NEW_LINE j = k NEW_LINE DEDENT ans = float ( ' inf ' ) NEW_LINE ans = min ( ans , cur ) NEW_LINE arr2 = [ '0' if i % 2 == 1 else '1' for i in range ( n ) ] NEW_LINE cur = 0 NEW_LINE j = 0 NEW_LINE while j < n : NEW_LINE INDENT if arr [ j ] == arr2 [ j ] : NEW_LINE INDENT j += 1 NEW_LINE continue NEW_LINE DEDENT k = j NEW_LINE while k < n and arr [ k ] != arr2 [ k ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT cur += 1 NEW_LINE j = k NEW_LINE DEDENT ans = min ( ans , cur ) NEW_LINE print ( ans ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE import math NEW_LINE class CodeForces : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if a * d >= b * c : NEW_LINE INDENT p = a * d - b * c NEW_LINE q = a * d NEW_LINE DEDENT else : NEW_LINE INDENT p = b * c - a * d NEW_LINE q = b * c NEW_LINE DEDENT k = self . gcd ( p , q ) NEW_LINE p //= k NEW_LINE q //= k NEW_LINE print ( str ( p ) + " / " + str ( q ) ) NEW_LINE DEDENT def gcd ( self , a , b ) : NEW_LINE INDENT return a if b == 0 else self . gcd ( b , a % b ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT cf = CodeForces ( ) NEW_LINE cf . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def numberOfWays ( x ) : NEW_LINE INDENT dp = [ 0 ] * ( x + 1 ) NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT return dp [ x ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT x = 3 NEW_LINE print ( GFG . numberOfWays ( x ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import array NEW_LINE def rearrange ( arr , n ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT if i != j : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( arr ) NEW_LINE DEDENT
import math NEW_LINE def centered_square_num ( n ) : NEW_LINE INDENT return n * n + ( ( n - 1 ) * ( n - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE print ( str ( n ) + " th ▁ Centered " + " ▁ square ▁ number : ▁ " + str ( centered_square_num ( n ) ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class teest : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . out = sys . stdout NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a = sys . stdin NEW_LINE t = int ( a . readline ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n , k = map ( int , a . readline ( ) . split ( ) ) NEW_LINE if n % 2 != k % 2 or n // k < k : NEW_LINE INDENT self . out . write ( " NO \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT self . out . write ( " YES \n " ) NEW_LINE DEDENT t -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT o = teest ( ) NEW_LINE o . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE n = int ( input ( ) ) NEW_LINE nums = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE nums . sort ( ) NEW_LINE firstHalf = sum ( nums [ : n // 2 ] ) NEW_LINE secondHalf = sum ( nums [ n // 2 : ] ) NEW_LINE result = ( firstHalf * firstHalf ) + ( secondHalf * secondHalf ) NEW_LINE print ( result ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def maxSubArraySum ( arr , size ) : NEW_LINE INDENT max_so_far = arr [ 0 ] NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( arr [ i ] , curr_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def lenOfLongSubarrWithGivenSum ( arr , n , k ) : NEW_LINE INDENT um = { } NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if sum == k : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT if sum in um : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if sum - k in um : NEW_LINE INDENT if maxLen < ( i - um [ sum - k ] ) : NEW_LINE INDENT maxLen = i - um [ sum - k ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT def lenLongSubarrWithMaxSum ( arr , n ) : NEW_LINE INDENT maxSum = GFG . maxSubArraySum ( arr , n ) NEW_LINE return GFG . lenOfLongSubarrWithGivenSum ( arr , n , maxSum ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 5 , - 2 , - 1 , 3 , - 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ longest ▁ subarray ▁ having ▁ maximum ▁ sum ▁ = ▁ " + str ( GFG . lenLongSubarrWithMaxSum ( arr , n ) ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT s = str ( a [ i ] * a [ j ] ) NEW_LINE f = True NEW_LINE for k in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ord ( s [ k ] ) + 1 != ord ( s [ k + 1 ] ) : NEW_LINE INDENT f = False NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT ans = max ( ans , a [ i ] * a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def find ( dividend , divisor , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return [ 0 , dividend ] NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE n = dividend - divisor * mid NEW_LINE if n > divisor : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT elif n < 0 : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if n == divisor : NEW_LINE INDENT mid += 1 NEW_LINE n = 0 NEW_LINE DEDENT return [ mid , n ] NEW_LINE DEDENT return GFG . find ( dividend , divisor , start , end ) NEW_LINE DEDENT def divide ( dividend , divisor ) : NEW_LINE INDENT return GFG . find ( dividend , divisor , 1 , dividend ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT dividend = 10 NEW_LINE divisor = 3 NEW_LINE ans = GFG . divide ( dividend , divisor ) NEW_LINE print ( ans [ 0 ] , end = " , ▁ " ) NEW_LINE print ( ans [ 1 ] ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def main ( ) : NEW_LINE INDENT size = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT min_diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE max_diff = abs ( arr [ i ] - arr [ size - 1 ] ) NEW_LINE DEDENT elif i == size - 1 : NEW_LINE INDENT min_diff = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE max_diff = abs ( arr [ i ] - arr [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT min_diff = min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) NEW_LINE max_diff = max ( abs ( arr [ i ] - arr [ size - 1 ] ) , abs ( arr [ i ] - arr [ 0 ] ) ) NEW_LINE DEDENT print ( min_diff , max_diff ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE n , diskSize = map ( int , input ( ) . split ( ) ) NEW_LINE sounds = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sounds . sort ( ) NEW_LINE distinctVals = [ ] NEW_LINE distinctAmt = [ ] NEW_LINE k = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == 0 or sounds [ i ] > sounds [ i - 1 ] : NEW_LINE INDENT distinctVals . append ( sounds [ i ] ) NEW_LINE distinctAmt . append ( 1 ) NEW_LINE k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT distinctAmt [ k ] += 1 NEW_LINE DEDENT DEDENT answer = n NEW_LINE currAmt = distinctAmt [ 0 ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < k : NEW_LINE INDENT currAmt -= distinctAmt [ i ] NEW_LINE i += 1 NEW_LINE while j < i or ( j < k - 1 and n * math . log2 ( j + 1 - i + 1 ) <= diskSize ) : NEW_LINE INDENT j += 1 NEW_LINE currAmt += distinctAmt [ j ] NEW_LINE DEDENT answer = min ( answer , n - currAmt ) NEW_LINE DEDENT print ( answer ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def towerOfHanoi ( n , from_rod , to_rod , aux_rod1 , aux_rod2 ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE return NEW_LINE DEDENT towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) NEW_LINE print ( " Move ▁ disk " , ( n - 1 ) , " from ▁ rod " , from_rod , " to ▁ rod " , aux_rod2 ) NEW_LINE print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE print ( " Move ▁ disk " , ( n - 1 ) , " from ▁ rod " , aux_rod2 , " to ▁ rod " , to_rod ) NEW_LINE towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 4 NEW_LINE towerOfHanoi ( n , ' A ' , ' D ' , ' B ' , ' C ' ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE n = sys . stdin . readline ( ) . strip ( ) NEW_LINE res = " " NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if n [ i ] == ' > ' : NEW_LINE INDENT res += "1000" NEW_LINE DEDENT elif n [ i ] == ' < ' : NEW_LINE INDENT res += "1001" NEW_LINE DEDENT elif n [ i ] == ' + ' : NEW_LINE INDENT res += "1010" NEW_LINE DEDENT elif n [ i ] == ' - ' : NEW_LINE INDENT res += "1011" NEW_LINE DEDENT elif n [ i ] == ' . ' : NEW_LINE INDENT res += "1100" NEW_LINE DEDENT elif n [ i ] == ' , ' : NEW_LINE INDENT res += "1101" NEW_LINE DEDENT elif n [ i ] == ' [ ' : NEW_LINE INDENT res += "1110" NEW_LINE DEDENT elif n [ i ] == ' ] ' : NEW_LINE INDENT res += "1111" NEW_LINE DEDENT DEDENT k = 0 NEW_LINE m = 0 NEW_LINE for i in range ( len ( res ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT y = int ( res [ i ] ) NEW_LINE m += ( 2 ** k % 1000003 ) * y % 1000003 NEW_LINE k += 1 NEW_LINE DEDENT print ( m % 1000003 ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE dic = { } NEW_LINE count = int ( input ( ) ) NEW_LINE for i in range ( count ) : NEW_LINE INDENT command = int ( input ( ) ) NEW_LINE if command == 0 : NEW_LINE INDENT key = input ( ) NEW_LINE value = int ( input ( ) ) NEW_LINE dic [ key ] = value NEW_LINE DEDENT elif command == 1 : NEW_LINE INDENT key = input ( ) NEW_LINE if key in dic : NEW_LINE INDENT print ( dic [ key ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT elif command == 2 : NEW_LINE INDENT key = input ( ) NEW_LINE if key in dic : NEW_LINE INDENT del dic [ key ] NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def minSum ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] <= prev : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum = sum + prev NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE prev = arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 2 , 2 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . minSum ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def findN ( k ) : NEW_LINE INDENT ans = 0 NEW_LINE if k == 0 : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT if k == 1 : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif k % 4 == 0 : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif k % 4 == 3 : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT k = 7 NEW_LINE res = GFG . findN ( k ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max_ele : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << int ( math . log ( max_ele ) / math . log ( 2 ) + 1 ) ) - 1 NEW_LINE dp = [ [ [ 0 for _ in range ( n + 1 ) ] for _ in range ( m + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if k != 0 : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE D , G = map ( int , input ( ) . split ( ) ) NEW_LINE p = [ 0 ] * D NEW_LINE c = [ 0 ] * D NEW_LINE for i in range ( D ) : NEW_LINE INDENT p [ i ] , c [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT min_score = 1001 NEW_LINE for i in range ( 2 ** D ) : NEW_LINE INDENT bit = format ( i , '0' + str ( D ) + ' b ' ) NEW_LINE count = 0 NEW_LINE ans = 0 NEW_LINE for j in range ( len ( bit ) ) : NEW_LINE INDENT if bit [ j ] == '1' : NEW_LINE INDENT count += p [ j ] * ( j + 1 ) * 100 + c [ j ] NEW_LINE ans += p [ j ] NEW_LINE DEDENT DEDENT if count < G : NEW_LINE INDENT for j in range ( len ( bit ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if bit [ j ] == '0' : NEW_LINE INDENT l = p [ j ] NEW_LINE while count < G and l > 0 : NEW_LINE INDENT count += ( j + 1 ) * 100 NEW_LINE ans += 1 NEW_LINE l -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if count >= G : NEW_LINE INDENT min_score = min ( ans , min_score ) NEW_LINE DEDENT DEDENT print ( min_score ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = 0 NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( a ) : NEW_LINE INDENT k += int ( input ( ) ) NEW_LINE DEDENT if b == k : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def main ( ) : NEW_LINE INDENT size = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 1 , size - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ 0 ] and arr [ i ] < arr [ size - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = 2 ** int ( math . log ( n ) / math . log ( 2 ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if arr1 [ i ] == arr2 [ j ] : NEW_LINE INDENT if current + 1 > table [ j ] : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT if arr1 [ i ] > arr2 [ j ] : NEW_LINE INDENT if table [ j ] > current : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if table [ i ] > result : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr1 = [ 3 , 4 , 9 , 1 ] NEW_LINE arr2 = [ 5 , 3 , 8 , 9 , 10 , 2 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( " Length ▁ of ▁ LCIS ▁ is " , GFG . LCIS ( arr1 , n , arr2 , m ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countSetBits ( n ) : NEW_LINE INDENT bitCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bitCount += GFG . countSetBitsUtil ( i ) NEW_LINE DEDENT return bitCount NEW_LINE DEDENT def countSetBitsUtil ( x ) : NEW_LINE INDENT if x <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 0 if x % 2 == 0 else 1 ) + GFG . countSetBitsUtil ( x // 2 ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 4 NEW_LINE print ( " Total ▁ set ▁ bit ▁ count ▁ is " , GFG . countSetBits ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ low ] NEW_LINE i = low - 1 NEW_LINE j = high + 1 NEW_LINE while True : NEW_LINE INDENT i += 1 NEW_LINE while arr [ i ] < pivot : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j -= 1 NEW_LINE while arr [ j ] > pivot : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if i >= j : NEW_LINE INDENT return j NEW_LINE DEDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT def quickSort ( arr , low , high ) : NEW_LINE INDENT if low < high : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE quickSort ( arr , low , pi ) NEW_LINE quickSort ( arr , pi + 1 , high ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sys . stdout . write ( str ( arr [ i ] ) + " ▁ " ) NEW_LINE DEDENT sys . stdout . write ( " \n " ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE quickSort ( arr , 0 , n - 1 ) NEW_LINE sys . stdout . write ( " Sorted ▁ array : \n " ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def swap ( self , array , position1 , position2 ) : NEW_LINE INDENT temp = array [ position1 ] NEW_LINE array [ position1 ] = array [ position2 ] NEW_LINE array [ position2 ] = temp NEW_LINE DEDENT def partition ( self , arr , low , high ) : NEW_LINE INDENT pivot = arr [ high ] NEW_LINE i = ( low - 1 ) NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT if arr [ j ] <= pivot : NEW_LINE INDENT i += 1 NEW_LINE self . swap ( arr , i , j ) NEW_LINE DEDENT DEDENT self . swap ( arr , i + 1 , high ) NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( self , arr , low , high ) : NEW_LINE INDENT if low < high : NEW_LINE INDENT pi = self . partition ( arr , low , high ) NEW_LINE self . quickSort ( arr , low , pi - 1 ) NEW_LINE self . quickSort ( arr , pi + 1 , high ) NEW_LINE DEDENT DEDENT def printArray ( self , arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE self . quickSort ( arr , 0 , n - 1 ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE self . printArray ( arr , n ) NEW_LINE DEDENT DEDENT gfg = GFG ( ) NEW_LINE gfg . main ( ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = float ( ' - inf ' ) NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT def minPossibleSum ( a , n , x ) : NEW_LINE INDENT mxSum = GFG . maxSubArraySum ( a , n ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum = sum - mxSum + mxSum / x NEW_LINE print ( sum ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = 3 NEW_LINE X = 2 NEW_LINE A = [ 1 , - 2 , 3 ] NEW_LINE GFG . minPossibleSum ( A , N , X ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
import sys NEW_LINE class FastScanner : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin NEW_LINE self . tokens = [ ] NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . tokens : NEW_LINE INDENT self . tokens = self . input . readline ( ) . split ( ) NEW_LINE DEDENT return self . tokens . pop ( 0 ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT sc = FastScanner ( ) NEW_LINE out = sys . stdout NEW_LINE t = int ( sc . nextInt ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( sc . nextInt ( ) ) NEW_LINE arr = [ 0 ] * ( n + 1 ) NEW_LINE indexOf = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = int ( sc . nextInt ( ) ) NEW_LINE indexOf [ arr [ i ] ] = i NEW_LINE DEDENT least = n + 1 NEW_LINE ans = [ ] NEW_LINE for e in range ( n , 0 , - 1 ) : NEW_LINE INDENT ind = indexOf [ e ] NEW_LINE if ind >= least : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( ind , least ) : NEW_LINE INDENT ans . append ( arr [ j ] ) NEW_LINE DEDENT least = ind NEW_LINE DEDENT for e in ans : NEW_LINE INDENT out . write ( str ( e ) + " ▁ " ) NEW_LINE DEDENT out . write ( " \n " ) NEW_LINE t -= 1 NEW_LINE DEDENT out . close ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def printArray ( N , SUM , K ) : NEW_LINE INDENT minSum = ( N * ( N + 1 ) ) // 2 NEW_LINE maxSum = ( N * K ) - ( N * ( N - 1 ) ) // 2 NEW_LINE if minSum > SUM or maxSum < SUM : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT arr = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr [ i ] = i NEW_LINE DEDENT sum = minSum NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT x = sum + ( K - i ) NEW_LINE if x < SUM : NEW_LINE INDENT sum = sum + ( K - i ) NEW_LINE arr [ i ] = K NEW_LINE K -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( SUM - sum ) NEW_LINE sum = SUM NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , SUM , K = 3 , 15 , 8 NEW_LINE printArray ( N , SUM , K ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT COST = 3 NEW_LINE @ staticmethod NEW_LINE def maxItems ( x , y , z ) : NEW_LINE INDENT type1 = x // GFG . COST NEW_LINE x %= GFG . COST NEW_LINE type2 = y // GFG . COST NEW_LINE y %= GFG . COST NEW_LINE type3 = z // GFG . COST NEW_LINE z %= GFG . COST NEW_LINE type4 = min ( x , min ( y , z ) ) NEW_LINE maxItems = type1 + type2 + type3 + type4 NEW_LINE return maxItems NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT x , y , z = 4 , 5 , 6 NEW_LINE print ( self . maxItems ( x , y , z ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
from collections import deque NEW_LINE def run_tasks ( A , B ) : NEW_LINE INDENT total_time = 0 NEW_LINE while A : NEW_LINE INDENT x = A [ 0 ] NEW_LINE y = B [ 0 ] NEW_LINE if x == y : NEW_LINE INDENT A . popleft ( ) NEW_LINE B . popleft ( ) NEW_LINE total_time += 1 NEW_LINE DEDENT else : NEW_LINE INDENT A . popleft ( ) NEW_LINE A . append ( x ) NEW_LINE total_time += 2 NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT A = deque ( [ 3 , 2 , 1 , 4 ] ) NEW_LINE B = deque ( [ 4 , 1 , 3 , 2 ] ) NEW_LINE print ( run_tasks ( A , B ) ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def line ( x0 , y0 ) : NEW_LINE INDENT c = int ( 2 * y0 * x0 ) NEW_LINE print ( " { : . 1f } x ▁ + ▁ { : . 1f } y ▁ = ▁ { : . 1f } " . format ( y0 , x0 , c ) ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT x0 = 4 NEW_LINE y0 = 3 NEW_LINE self . line ( x0 , y0 ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT word = input ( ) NEW_LINE s . add ( ' ' . join ( sorted ( set ( word ) ) ) ) NEW_LINE DEDENT print ( len ( s ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
from math import sqrt NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . inp = input ( ) NEW_LINE self . q = int ( self . inp ) NEW_LINE for i in range ( self . q ) : NEW_LINE INDENT self . doIt ( ) NEW_LINE DEDENT DEDENT def doIt ( self ) : NEW_LINE INDENT l1 = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE l2 = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE if self . intersectsLine ( l1 , l2 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT DEDENT def intersectsLine ( self , l1 , l2 ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = l1 NEW_LINE x3 , y3 , x4 , y4 = l2 NEW_LINE den = ( x1 - x2 ) * ( y3 - y4 ) - ( y1 - y2 ) * ( x3 - x4 ) NEW_LINE if den == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT t = ( ( x1 - x3 ) * ( y3 - y4 ) - ( y1 - y3 ) * ( x3 - x4 ) ) / den NEW_LINE u = - ( ( x1 - x2 ) * ( y1 - y3 ) - ( y1 - y2 ) * ( x1 - x3 ) ) / den NEW_LINE return 0 <= t <= 1 and 0 <= u <= 1 NEW_LINE DEDENT DEDENT Main ( ) NEW_LINE
` ` ` python NEW_LINE def isAnyNotPalindrome ( s ) : NEW_LINE INDENT unique = set ( s ) NEW_LINE if len ( unique ) > 1 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = " aaaaab " NEW_LINE if isAnyNotPalindrome ( s ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT ` ` ` NEW_LINE
def findMajority ( arr , n ) : NEW_LINE INDENT return arr [ n // 2 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMajority ( arr , n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT count = int ( input ( ) ) NEW_LINE pos = 0 NEW_LINE for i in range ( count ) : NEW_LINE INDENT s = input ( ) . split ( " ▁ " ) NEW_LINE no = int ( s [ 0 ] ) NEW_LINE if s [ 1 ] == " South " : NEW_LINE INDENT pos += no NEW_LINE if pos > 20000 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif s [ 1 ] == " North " : NEW_LINE INDENT pos -= no NEW_LINE if pos < 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if pos == 0 or pos == 20000 : NEW_LINE INDENT pos = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if pos == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT @ staticmethod NEW_LINE def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if bitwise_or >= K : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( Solution . countSubArrays ( arr , n , k ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import numpy as np NEW_LINE def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr = np . array ( [ a , b , c ] ) NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] NEW_LINE k = k - diff NEW_LINE if k < 0 or k % 3 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a1 , b1 , c1 , k1 = 6 , 3 , 2 , 7 NEW_LINE if canBeEqual ( a1 , b1 , c1 , k1 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import collections NEW_LINE adjacency = collections . defaultdict ( list ) NEW_LINE def insert ( x , y ) : NEW_LINE INDENT adjacency [ x ] . append ( y ) NEW_LINE DEDENT def dfs ( node , leaf , vis ) : NEW_LINE INDENT leaf [ node ] = 0 NEW_LINE vis [ node ] = 1 NEW_LINE for it in adjacency [ node ] : NEW_LINE INDENT if vis [ it ] == 0 : NEW_LINE INDENT dfs ( it , leaf , vis ) NEW_LINE leaf [ node ] += leaf [ it ] NEW_LINE DEDENT DEDENT if len ( adjacency [ node ] ) == 0 : NEW_LINE INDENT leaf [ node ] = 1 NEW_LINE DEDENT DEDENT def printLeaf ( n , leaf ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " The ▁ node ▁ " + str ( i ) + " ▁ has ▁ " + str ( leaf [ i ] ) + " ▁ leaf ▁ nodes " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 6 NEW_LINE leaf = [ 0 ] * ( N + 1 ) NEW_LINE vis = [ 0 ] * ( N + 1 ) NEW_LINE insert ( 1 , 2 ) NEW_LINE insert ( 1 , 3 ) NEW_LINE insert ( 3 , 4 ) NEW_LINE insert ( 3 , 5 ) NEW_LINE insert ( 3 , 6 ) NEW_LINE dfs ( 1 , leaf , vis ) NEW_LINE printLeaf ( N , leaf ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ,   $ ) : NEW_LINE INDENT s = input ( ) NEW_LINE v , n = s . split ( ) NEW_LINE n = int ( n ) NEW_LINE for i in range ( min ( len ( v ) , n ) ) : NEW_LINE INDENT if v [ i ] != '1' : NEW_LINE INDENT print ( v [ i ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( '1' ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Garland : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE if not self . isValid ( s1 , s2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT m1 = { } NEW_LINE m2 = { } NEW_LINE for c in s1 : NEW_LINE INDENT m1 [ c ] = m1 . get ( c , 0 ) + 1 NEW_LINE DEDENT for c in s2 : NEW_LINE INDENT m2 [ c ] = m2 . get ( c , 0 ) + 1 NEW_LINE DEDENT ans = 0 NEW_LINE hs = set ( ) NEW_LINE for c in s2 : NEW_LINE INDENT if c not in hs : NEW_LINE INDENT hs . add ( c ) NEW_LINE x1 = m1 . get ( c , 0 ) NEW_LINE x2 = m2 . get ( c , 0 ) NEW_LINE x1 = min ( x1 , x2 ) NEW_LINE ans += x1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT def isValid ( self , s1 , s2 ) : NEW_LINE INDENT map = { } NEW_LINE for c in s1 : NEW_LINE INDENT map [ c ] = True NEW_LINE DEDENT for c in s2 : NEW_LINE INDENT if c not in map : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class LCS_3Strings : NEW_LINE INDENT def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for _ in range ( o + 1 ) ] for _ in range ( n + 1 ) ] for _ in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 or k == 0 : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT X = " AGGT12" NEW_LINE Y = "12TXAYB " NEW_LINE Z = "12XBA " NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( " Length ▁ of ▁ LCS ▁ is " , lcsOf3 ( X , Y , Z , m , n , o ) ) NEW_LINE DEDENT DEDENT LCS_3Strings . main ( ) NEW_LINE
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE answer = abs ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT answer += abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT print ( answer ) NEW_LINE
class GFG : NEW_LINE INDENT def isSpiltPossible ( n , a ) : NEW_LINE INDENT sum = 0 NEW_LINE c1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE if a [ i ] == 1 : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if sum % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( sum // 2 ) % 2 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if c1 > 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT n = 3 NEW_LINE a = [ 1 , 1 , 2 ] NEW_LINE if GFG . isSpiltPossible ( n , a ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp = [ 0 , 0 , 0 , 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 1 ] += 1 if arr [ i ] == 1 else 0 NEW_LINE dp [ 2 ] = max ( dp [ 1 ] , dp [ 2 ] + ( 1 if arr [ i ] == 2 else 0 ) ) NEW_LINE dp [ 3 ] = max ( dp [ 2 ] , dp [ 3 ] + ( 1 if arr [ i ] == 1 else 0 ) ) NEW_LINE dp [ 4 ] = max ( dp [ 3 ] , dp [ 4 ] + ( 1 if arr [ i ] == 2 else 0 ) ) NEW_LINE DEDENT print ( dp [ 4 ] ) NEW_LINE
import numpy as np NEW_LINE def count_even_odd ( min , max , steps ) : NEW_LINE INDENT a , b , even , odd = 0 , 0 , 0 , 0 NEW_LINE beven , aeven = True , False NEW_LINE n = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = steps [ i ] [ 0 ] NEW_LINE b = steps [ i ] [ 1 ] NEW_LINE if not ( aeven or ( a & 1 ) > 0 ) : NEW_LINE INDENT aeven = True NEW_LINE DEDENT if beven : NEW_LINE INDENT if ( b & 1 ) > 0 : NEW_LINE INDENT beven = False NEW_LINE DEDENT DEDENT elif not ( ( a & 1 ) > 0 ) : NEW_LINE INDENT if not ( ( b & 1 ) > 0 ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) > 0 : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT DEDENT if beven : NEW_LINE INDENT even = int ( max / 2 ) - int ( ( min - 1 ) / 2 ) NEW_LINE odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT even = int ( max / 2 ) - int ( ( min - 1 ) / 2 ) NEW_LINE odd = 0 NEW_LINE DEDENT if not ( beven ^ aeven ) : NEW_LINE INDENT even += max - min + 1 - int ( max / 2 ) + int ( ( min - 1 ) / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT odd += max - min + 1 - int ( max / 2 ) + int ( ( min - 1 ) / 2 ) NEW_LINE DEDENT print ( " even ▁ = ▁ " + str ( even ) + " , ▁ odd ▁ = ▁ " + str ( odd ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT min_val = 1 NEW_LINE max_val = 4 NEW_LINE steps = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) NEW_LINE count_even_odd ( min_val , max_val , steps ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class JohnyLikesNumbers : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n // k + 1 ) * k ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE def printKPFNums ( A , B , K ) : NEW_LINE INDENT prime = [ True ] * ( B + 1 ) NEW_LINE p_factors = [ 0 ] * ( B + 1 ) NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if p_factors [ p ] == 0 : NEW_LINE INDENT for i in range ( p , B + 1 , p ) : NEW_LINE INDENT p_factors [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if p_factors [ i ] == K : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT A = 14 NEW_LINE B = 18 NEW_LINE K = 2 NEW_LINE printKPFNums ( A , B , K ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def reverseWords ( self , str ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] != ' ▁ ' : NEW_LINE INDENT st . append ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while st : NEW_LINE INDENT print ( st . pop ( ) , end = ' ' ) NEW_LINE DEDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT DEDENT while st : NEW_LINE INDENT print ( st . pop ( ) , end = ' ' ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT str = " Geeks ▁ for ▁ Geeks " NEW_LINE self . reverseWords ( str ) NEW_LINE DEDENT DEDENT gfg = GFG ( ) NEW_LINE gfg . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE n = int ( input ( ) ) NEW_LINE p = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE onlyFirstSolve = 0 NEW_LINE onlySecondSolve = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = int ( input ( ) ) NEW_LINE if p [ i ] == 1 and r == 0 : NEW_LINE INDENT onlyFirstSolve += 1 NEW_LINE DEDENT elif p [ i ] == 0 and r == 1 : NEW_LINE INDENT onlySecondSolve += 1 NEW_LINE DEDENT DEDENT if onlyFirstSolve == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( onlySecondSolve + onlyFirstSolve ) // onlyFirstSolve ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE import math NEW_LINE N = int ( 1e7 ) NEW_LINE IsPrime = [ ] NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE is_prime ( ) NEW_LINE x = 1 if n <= 2 else 2 NEW_LINE n += 1 NEW_LINE print ( x ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if IsPrime [ i ] : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE DEDENT DEDENT sys . stdout . close ( ) NEW_LINE DEDENT def is_prime ( ) : NEW_LINE INDENT global IsPrime NEW_LINE IsPrime = [ True ] * N NEW_LINE IsPrime [ 0 ] = IsPrime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( math . sqrt ( N ) ) ) : NEW_LINE INDENT if IsPrime [ i ] : NEW_LINE INDENT for j in range ( i * i , N , i ) : NEW_LINE INDENT IsPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT class IRead : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . st = " " NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . st : NEW_LINE INDENT self . st = input ( ) . split ( ) NEW_LINE DEDENT result = self . st [ 0 ] NEW_LINE self . st = self . st [ 1 : ] NEW_LINE return result NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input_obj = IRead ( ) NEW_LINE main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE h = 0 NEW_LINE w = 0 NEW_LINE c = 0 NEW_LINE ans = 0 NEW_LINE count = 0 NEW_LINE color_order = [ ] NEW_LINE map = [ ] NEW_LINE tmp = [ ] NEW_LINE while True : NEW_LINE INDENT ns = input ( ) . split ( " ▁ " ) NEW_LINE stack = [ ] NEW_LINE for i in range ( len ( ns ) ) : NEW_LINE INDENT if len ( ns [ i ] ) > 1 : NEW_LINE INDENT stack . append ( float ( ns [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sw = ns [ i ] [ 0 ] NEW_LINE if sw . isdigit ( ) : NEW_LINE INDENT stack . append ( float ( ns [ i ] ) ) NEW_LINE DEDENT elif sw == ' + ' : NEW_LINE INDENT x = stack . pop ( ) NEW_LINE y = stack . pop ( ) NEW_LINE stack . append ( x + y ) NEW_LINE DEDENT elif sw == ' - ' : NEW_LINE INDENT x = stack . pop ( ) NEW_LINE y = stack . pop ( ) NEW_LINE stack . append ( y - x ) NEW_LINE DEDENT elif sw == ' * ' : NEW_LINE INDENT x = stack . pop ( ) NEW_LINE y = stack . pop ( ) NEW_LINE stack . append ( y * x ) NEW_LINE DEDENT elif sw == ' / ' : NEW_LINE INDENT x = stack . pop ( ) NEW_LINE y = stack . pop ( ) NEW_LINE stack . append ( y / x ) NEW_LINE DEDENT DEDENT DEDENT ans = stack . pop ( ) NEW_LINE print ( " { : . 6f } " . format ( ans ) ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 1 if n >= k else k // n if k % n == 0 else k // n + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def findNthTerm ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE print ( int ( math . pow ( 3 , n - 1 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n = ( n // 2 ) + 1 NEW_LINE print ( int ( math . pow ( 2 , n - 1 ) ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE N = 11 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] >= arr [ i ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( len + 1 ) * len ) // 2 NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if len > 1 : NEW_LINE INDENT cnt += ( ( len - 1 ) * len ) // 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 5 , 2 , 3 , 7 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNonIncreasing ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
import numpy as np NEW_LINE def maximize ( A1 , A2 , n , x , y ) : NEW_LINE INDENT c = np . zeros ( n ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = A2 [ i ] - A1 [ i ] NEW_LINE sum += A1 [ i ] NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if c [ i ] < c [ i + 1 ] : NEW_LINE INDENT temp = c [ i ] NEW_LINE c [ i ] = c [ i + 1 ] NEW_LINE c [ i + 1 ] = temp NEW_LINE DEDENT DEDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += c [ i ] NEW_LINE if i + 1 >= ( n - x ) : NEW_LINE INDENT maxi = max ( sum , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT A1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE A2 = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE n = 5 NEW_LINE x = 3 NEW_LINE y = 3 NEW_LINE print ( maximize ( A1 , A2 , n , x , y ) ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE s = str ( x ) NEW_LINE extra = len ( s ) NEW_LINE temp = int ( s [ 0 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , temp ) : NEW_LINE INDENT ans += 10 NEW_LINE DEDENT ans += ( extra ) * ( extra + 1 ) // 2 NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE INFINITY = sys . maxsize // 2 NEW_LINE N = int ( input ( ) ) NEW_LINE K = [ [ INFINITY for _ in range ( N ) ] for _ in range ( N ) ] NEW_LINE m = int ( input ( ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT str_input = input ( ) . strip ( ) . split ( " , " ) NEW_LINE a = int ( str_input [ 0 ] ) - 1 NEW_LINE b = int ( str_input [ 1 ] ) - 1 NEW_LINE K [ a ] [ b ] = int ( str_input [ 2 ] ) NEW_LINE K [ b ] [ a ] = int ( str_input [ 3 ] ) NEW_LINE DEDENT str_input = input ( ) . split ( " , " ) NEW_LINE start = int ( str_input [ 0 ] ) - 1 NEW_LINE goal = int ( str_input [ 1 ] ) - 1 NEW_LINE V = int ( str_input [ 2 ] ) NEW_LINE P = int ( str_input [ 3 ] ) NEW_LINE for k in range ( N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if K [ i ] [ j ] > K [ i ] [ k ] + K [ k ] [ j ] : NEW_LINE INDENT K [ i ] [ j ] = K [ i ] [ k ] + K [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( V - P - K [ start ] [ goal ] - K [ goal ] [ start ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT r1 , r2 , c1 , c2 , d1 , d2 = map ( int , input ( ) . split ( ) ) NEW_LINE if ( c1 + c2 - r1 - r2 ) != 0 or ( d1 + d2 - r1 - r2 ) != 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE t = ( r2 - d2 + c2 ) // 2 NEW_LINE z = d2 - c2 + t NEW_LINE y = c2 - t NEW_LINE x = r1 + r2 - y - z - t NEW_LINE box = [ x , y , z , t ] NEW_LINE for gem in box : NEW_LINE INDENT if gem > 9 or gem < 1 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( x == y ) or ( x == z ) or ( x == t ) or ( y == z ) or ( y == t ) or ( z == t ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT if flag : NEW_LINE INDENT print ( f " { x } ▁ { y } \n { z } ▁ { t } " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def calcNearestWeight ( x , w , i , sum , additions ) : NEW_LINE INDENT if x == sum : NEW_LINE INDENT return True NEW_LINE DEDENT if i == len ( w ) : NEW_LINE INDENT additions . add ( abs ( x - sum ) ) NEW_LINE return False NEW_LINE DEDENT if calcNearestWeight ( x , w , i + 1 , sum , additions ) : NEW_LINE INDENT return True NEW_LINE DEDENT if calcNearestWeight ( x , w , i + 1 , sum + w [ i ] , additions ) : NEW_LINE INDENT return True NEW_LINE DEDENT return calcNearestWeight ( x , w , i + 1 , sum - w [ i ] , additions ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE commonAdditions = None NEW_LINE for i in range ( n ) : NEW_LINE INDENT additions = set ( ) NEW_LINE bJust = calcNearestWeight ( a [ i ] , w , 0 , 0 , additions ) NEW_LINE if not bJust : NEW_LINE INDENT if commonAdditions is None : NEW_LINE INDENT commonAdditions = additions NEW_LINE DEDENT else : NEW_LINE INDENT commonAdditions . intersection_update ( additions ) NEW_LINE DEDENT DEDENT DEDENT if commonAdditions is None : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( commonAdditions ) > 0 : NEW_LINE INDENT print ( min ( commonAdditions ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE class DP : NEW_LINE INDENT mod = int ( 1e9 + 7 ) NEW_LINE def main ( self ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE dp = [ float ( ' inf ' ) ] * ( 1 << 3 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for _ in range ( N ) : NEW_LINE INDENT price , s = map ( str , input ( ) . split ( ) ) NEW_LINE price = int ( price ) NEW_LINE mask = 0 NEW_LINE if ' A ' in s : NEW_LINE INDENT mask |= 1 NEW_LINE DEDENT if ' B ' in s : NEW_LINE INDENT mask |= 2 NEW_LINE DEDENT if ' C ' in s : NEW_LINE INDENT mask |= 4 NEW_LINE DEDENT for k in range ( 1 << 3 ) : NEW_LINE INDENT if dp [ k ] != float ( ' inf ' ) : NEW_LINE INDENT t = k | mask NEW_LINE dp [ t ] = min ( dp [ t ] , dp [ k ] + price ) NEW_LINE DEDENT DEDENT DEDENT print ( - 1 if dp [ 7 ] == float ( ' inf ' ) else dp [ 7 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT dp = DP ( ) NEW_LINE dp . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def startsWith ( self , str , pre ) : NEW_LINE INDENT strLen = len ( str ) NEW_LINE preLen = len ( pre ) NEW_LINE i , j = 0 , 0 NEW_LINE while i < strLen and j < preLen : NEW_LINE INDENT if str [ i ] != pre [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def endsWith ( self , str , suff ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE j = len ( suff ) - 1 NEW_LINE while i >= 0 and j >= 0 : NEW_LINE INDENT if str [ i ] != suff [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def checkString ( self , str , a , b ) : NEW_LINE INDENT if len ( str ) != len ( a ) + len ( b ) : NEW_LINE INDENT return False NEW_LINE DEDENT if self . startsWith ( str , a ) : NEW_LINE INDENT if self . endsWith ( str , b ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if self . startsWith ( str , b ) : NEW_LINE INDENT if self . endsWith ( str , a ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT str = " GeeksforGeeks " NEW_LINE a = " Geeksfo " NEW_LINE b = " rGeeks " NEW_LINE if self . checkString ( str , a , b ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if i % 3 != 0 : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if j % 3 != 0 : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if k % 3 != 0 and ( i + j + k ) == n : NEW_LINE INDENT print ( i , j , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 233 NEW_LINE printCombination ( n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n - i + 1 ) : NEW_LINE INDENT for k in range ( n - i - j + 1 ) : NEW_LINE INDENT if i + j + k == n : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT TEN = 10 NEW_LINE @ staticmethod NEW_LINE def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % GFG . TEN NEW_LINE n //= GFG . TEN NEW_LINE DEDENT return sum NEW_LINE DEDENT @ staticmethod NEW_LINE def getNthTerm ( n ) : NEW_LINE INDENT sum = GFG . digitSum ( n ) NEW_LINE if sum % GFG . TEN == 0 : NEW_LINE INDENT return n * GFG . TEN NEW_LINE DEDENT extra = GFG . TEN - ( sum % GFG . TEN ) NEW_LINE return ( n * GFG . TEN ) + extra NEW_LINE DEDENT @ staticmethod NEW_LINE def firstNTerms ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( GFG . getNthTerm ( i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT n = 10 NEW_LINE GFG . firstNTerms ( n ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def power ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while a > 0 : NEW_LINE INDENT if ( a & 1 ) > 0 : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT @ staticmethod NEW_LINE def breakInteger ( N ) : NEW_LINE INDENT if N == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if N == 3 : NEW_LINE INDENT return 2 NEW_LINE DEDENT maxProduct = - 1 NEW_LINE if N % 3 == 0 : NEW_LINE INDENT maxProduct = GFG . power ( 3 , N // 3 ) NEW_LINE DEDENT elif N % 3 == 1 : NEW_LINE INDENT maxProduct = 2 * 2 * GFG . power ( 3 , ( N // 3 ) - 1 ) NEW_LINE DEDENT elif N % 3 == 2 : NEW_LINE INDENT maxProduct = 2 * GFG . power ( 3 , N // 3 ) NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT maxProduct = GFG . breakInteger ( 10 ) NEW_LINE print ( maxProduct ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE class Main : NEW_LINE INDENT def eulerPhiTable ( self , n ) : NEW_LINE INDENT res = [ 0 ] * ( n + 1 ) NEW_LINE p = [ True ] * ( n + 1 ) NEW_LINE p [ 0 ] = p [ 1 ] = False NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT res [ i ] = i NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if p [ i ] : NEW_LINE INDENT res [ i ] -= res [ i ] // i NEW_LINE for j in range ( i + i , n + 1 , i ) : NEW_LINE INDENT p [ j ] = False NEW_LINE res [ j ] -= res [ j ] // i NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT N = 1000000 NEW_LINE f = self . eulerPhiTable ( N ) NEW_LINE res = [ 0 ] * ( N + 1 ) NEW_LINE res [ 1 ] = 2 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] + f [ i ] NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE while T != 0 : NEW_LINE INDENT print ( res [ int ( input ( ) ) ] ) NEW_LINE T -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT
import java . util . * ; NEW_LINE public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; StringBuilder sb = new StringBuilder ( s ) ; s = s . replace ( "2017" , "2018" ) ; System . out . println ( s ) ; } } NEW_LINE
from collections import deque NEW_LINE MAX_CHAR = 26 NEW_LINE def firstNonRepeating ( str ) : NEW_LINE INDENT charCount = [ 0 ] * MAX_CHAR NEW_LINE q = deque ( ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE q . append ( ch ) NEW_LINE charCount [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE while q : NEW_LINE INDENT if charCount [ ord ( q [ 0 ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( q [ 0 ] , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT if not q : NEW_LINE INDENT print ( - 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " aabc " NEW_LINE firstNonRepeating ( str ) NEW_LINE DEDENT
arr = [ ] NEW_LINE totalFalse = 0 NEW_LINE def main ( ) : NEW_LINE INDENT global arr , totalFalse NEW_LINE n = int ( input ( ) ) NEW_LINE arr = [ Node ( i ) for i in range ( n ) ] NEW_LINE totalFalse = 0 NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE arr [ a ] . neighbors . append ( b ) NEW_LINE arr [ b ] . neighbors . append ( a ) NEW_LINE DEDENT dfs ( 0 , True ) NEW_LINE total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] . parity : NEW_LINE INDENT total += ( totalFalse - len ( arr [ i ] . neighbors ) ) NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE DEDENT def dfs ( currNode , parity ) : NEW_LINE INDENT arr [ currNode ] . parity = parity NEW_LINE global totalFalse NEW_LINE if not parity : NEW_LINE INDENT totalFalse += 1 NEW_LINE DEDENT for nextNode in arr [ currNode ] . neighbors : NEW_LINE INDENT if arr [ nextNode ] . parity is not None : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( nextNode , not parity ) NEW_LINE DEDENT DEDENT class Node : NEW_LINE INDENT def __init__ ( self , index ) : NEW_LINE INDENT self . index = index NEW_LINE self . neighbors = [ ] NEW_LINE self . parity = None NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import numpy as np NEW_LINE def solve ( n , m , obstacles , range ) : NEW_LINE INDENT val = min ( n , m ) NEW_LINE range . sort ( ) NEW_LINE c = 1 NEW_LINE for i in range ( obstacles - 1 , - 1 , - 1 ) : NEW_LINE INDENT range [ i ] = 2 * range [ i ] NEW_LINE val -= range [ i ] NEW_LINE if val <= 0 : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if val > 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE obstacles = 3 NEW_LINE range = np . array ( [ 1.0 , 1.25 , 1.15 ] ) NEW_LINE print ( solve ( n , m , obstacles , range ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = input NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT exp = input ( ) NEW_LINE self . calc ( exp ) NEW_LINE DEDENT def calc ( self , exp ) : NEW_LINE INDENT ans1 = 0 NEW_LINE ans2 = int ( exp [ 0 ] ) NEW_LINE temp = ans2 NEW_LINE i = 0 NEW_LINE while i < len ( exp ) / 2 : NEW_LINE INDENT e = exp [ 2 * i + 1 ] NEW_LINE k = int ( exp [ 2 * i + 2 ] ) NEW_LINE if e == " + " : NEW_LINE INDENT ans2 += k NEW_LINE ans1 += temp NEW_LINE temp = k NEW_LINE DEDENT else : NEW_LINE INDENT ans2 *= k NEW_LINE temp *= k NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ans1 += temp NEW_LINE bob_ans = int ( input ( ) ) NEW_LINE output = " " NEW_LINE if bob_ans == ans1 : NEW_LINE INDENT if bob_ans == ans2 : NEW_LINE INDENT output = " U " NEW_LINE DEDENT else : NEW_LINE INDENT output = " M " NEW_LINE DEDENT DEDENT elif bob_ans == ans2 : NEW_LINE INDENT output = " L " NEW_LINE DEDENT else : NEW_LINE INDENT output = " I " NEW_LINE DEDENT print ( output ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class MinStack : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . minStack = [ ] NEW_LINE DEDENT def push ( self , x : int ) -> None : NEW_LINE INDENT self . stack . append ( x ) NEW_LINE if len ( self . minStack ) == 0 or x <= self . minStack [ - 1 ] : NEW_LINE INDENT self . minStack . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT self . minStack . append ( self . minStack [ - 1 ] ) NEW_LINE DEDENT DEDENT def pop ( self ) -> None : NEW_LINE INDENT self . stack . pop ( ) NEW_LINE self . minStack . pop ( ) NEW_LINE DEDENT def top ( self ) -> int : NEW_LINE INDENT return self . stack [ - 1 ] NEW_LINE DEDENT def getMin ( self ) -> int : NEW_LINE INDENT return self . minStack [ - 1 ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = MinStack ( ) NEW_LINE m . push ( - 2 ) NEW_LINE m . push ( 0 ) NEW_LINE m . push ( - 3 ) NEW_LINE print ( m . getMin ( ) ) NEW_LINE m . pop ( ) NEW_LINE print ( m . top ( ) ) NEW_LINE print ( m . getMin ( ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT one = [ " " , " one ▁ " , " two ▁ " , " three ▁ " , " four ▁ " , " five ▁ " , " six ▁ " , " seven ▁ " , " eight ▁ " , " nine ▁ " , " ten ▁ " , " eleven ▁ " , " twelve ▁ " , " thirteen ▁ " , " fourteen ▁ " , " fifteen ▁ " , " sixteen ▁ " , " seventeen ▁ " , " eighteen ▁ " , " nineteen ▁ " ] NEW_LINE ten = [ " " , " " , " twenty ▁ " , " thirty ▁ " , " forty ▁ " , " fifty ▁ " , " sixty ▁ " , " seventy ▁ " , " eighty ▁ " , " ninety ▁ " ] NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT str = " " NEW_LINE if n > 19 : NEW_LINE INDENT str += GFG . ten [ n // 10 ] + GFG . one [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT str += GFG . one [ n ] NEW_LINE DEDENT if n != 0 : NEW_LINE INDENT str += s NEW_LINE DEDENT return str NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = " " NEW_LINE out += GFG . numToWords ( int ( n / 10000000 ) , " crore ▁ " ) NEW_LINE out += GFG . numToWords ( int ( ( n / 100000 ) % 100 ) , " lakh ▁ " ) NEW_LINE out += GFG . numToWords ( int ( ( n / 1000 ) % 100 ) , " thousand ▁ " ) NEW_LINE out += GFG . numToWords ( int ( ( n / 100 ) % 10 ) , " hundred ▁ " ) NEW_LINE if n > 100 and n % 100 > 0 : NEW_LINE INDENT out += " and ▁ " NEW_LINE DEDENT out += GFG . numToWords ( int ( n % 100 ) , " " ) NEW_LINE return out NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 438237764 NEW_LINE print ( GFG . convertToWords ( n ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def flipSign ( a ) : NEW_LINE INDENT neg = 0 NEW_LINE tmp = 1 if a < 0 else - 1 NEW_LINE while a != 0 : NEW_LINE INDENT neg += tmp NEW_LINE a += tmp NEW_LINE DEDENT return neg NEW_LINE DEDENT def areDifferentSign ( a , b ) : NEW_LINE INDENT return ( a < 0 and b > 0 ) or ( a > 0 and b < 0 ) NEW_LINE DEDENT def sub ( a , b ) : NEW_LINE INDENT return a + GFG . flipSign ( b ) NEW_LINE DEDENT def mul ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT return GFG . mul ( b , a ) NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( abs ( b ) ) : NEW_LINE INDENT sum += a NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT sum = GFG . flipSign ( sum ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def division ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT raise ArithmeticError ( " Divide ▁ by ▁ 0" ) NEW_LINE DEDENT quotient = 0 NEW_LINE dividend = abs ( a ) NEW_LINE divisor = GFG . flipSign ( abs ( b ) ) NEW_LINE while dividend >= abs ( divisor ) : NEW_LINE INDENT dividend += divisor NEW_LINE quotient += 1 NEW_LINE DEDENT if GFG . areDifferentSign ( a , b ) : NEW_LINE INDENT quotient = GFG . flipSign ( quotient ) NEW_LINE DEDENT return quotient NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT print ( " Subtraction ▁ is " , GFG . sub ( 4 , - 2 ) ) NEW_LINE print ( " Product ▁ is " , GFG . mul ( - 9 , 6 ) ) NEW_LINE try : NEW_LINE INDENT print ( " Division ▁ is " , GFG . division ( 8 , 2 ) ) NEW_LINE DEDENT except ArithmeticError as e : NEW_LINE INDENT print ( " Exception ▁ : - " , e ) NEW_LINE DEDENT DEDENT DEDENT GFG . main ( ) NEW_LINE
def factorial ( n ) : NEW_LINE INDENT i = n NEW_LINE fact = 1 NEW_LINE while n / i != n : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 5 NEW_LINE print ( " Factorial ▁ of ▁ " + str ( num ) + " ▁ is ▁ " + str ( factorial ( 5 ) ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( number % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE print ( CntDivbyX ( arr , n , x ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE stat = [ 0 ] * 30 NEW_LINE for _ in range ( N ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE stat [ bin ( a ) . count ( '1' ) ] += 1 NEW_LINE DEDENT answer = 0 NEW_LINE for count in stat : NEW_LINE INDENT answer += count * ( count - 1 ) NEW_LINE DEDENT answer //= 2 NEW_LINE print ( answer ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GfG : NEW_LINE INDENT def min_noOf_operation ( arr , n , k ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if arr [ i ] > arr [ i - 1 ] : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) // k NEW_LINE if ( arr [ i ] - arr [ i - 1 ] ) % k != 0 : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] -= k * noOfSubtraction NEW_LINE DEDENT res += noOfSubtraction NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( argc ) : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = 4 NEW_LINE k = 5 NEW_LINE print ( GfG . min_noOf_operation ( arr , N , k ) ) NEW_LINE DEDENT DEDENT GfG . main ( None ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def CountSubSet ( arr , n , X ) : NEW_LINE INDENT N = 2 ** n NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) != 0 : NEW_LINE INDENT if arr [ j ] == X : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 4 , 5 , 6 , 7 ] NEW_LINE X = 5 NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubSet ( arr , n , X ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT n = 5 NEW_LINE @ staticmethod NEW_LINE def FindMaxProduct ( arr , n ) : NEW_LINE INDENT max_val = 0 NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j - 3 ) >= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] NEW_LINE if max_val < result : NEW_LINE INDENT max_val = result NEW_LINE DEDENT DEDENT if ( i - 3 ) >= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] NEW_LINE if max_val < result : NEW_LINE INDENT max_val = result NEW_LINE DEDENT DEDENT if ( i - 3 ) >= 0 and ( j - 3 ) >= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] NEW_LINE if max_val < result : NEW_LINE INDENT max_val = result NEW_LINE DEDENT DEDENT if ( i - 3 ) >= 0 and ( j - 1 ) <= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] NEW_LINE if max_val < result : NEW_LINE INDENT max_val = result NEW_LINE DEDENT DEDENT DEDENT DEDENT return max_val NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 6 , 7 , 8 , 9 , 1 ] , [ 2 , 3 , 4 , 5 , 6 ] , [ 7 , 8 , 9 , 1 , 0 ] , [ 9 , 6 , 4 , 2 , 3 ] ] NEW_LINE print ( self . FindMaxProduct ( arr , self . n ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE
` ` ` python NEW_LINE MAX = 50002 NEW_LINE primes = [ ] NEW_LINE def sieve ( ) : NEW_LINE INDENT global primes NEW_LINE isPrime = [ True ] * MAX NEW_LINE for p in range ( 2 , int ( MAX ** 0.5 ) + 1 ) : NEW_LINE INDENT if isPrime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT primes = [ p for p in range ( 2 , MAX ) if isPrime [ p ] ] NEW_LINE DEDENT def power ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE z = y NEW_LINE while x >= z : NEW_LINE INDENT count += ( x // z ) NEW_LINE z *= y NEW_LINE DEDENT return count NEW_LINE DEDENT def modMult ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while b > 0 : NEW_LINE INDENT if b % 2 == 1 : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def countWays ( n , m ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , len ( primes ) ) : NEW_LINE INDENT powers = power ( n , primes [ i ] ) NEW_LINE if powers == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = modMult ( ans , powers + 1 , m ) % m NEW_LINE DEDENT if ( ans - 1 ) % m < 0 : NEW_LINE INDENT return ( ans - 1 + m ) % m NEW_LINE DEDENT else : NEW_LINE INDENT return ( ans - 1 ) % m NEW_LINE DEDENT DEDENT sieve ( ) NEW_LINE n , m = 4 , 7 NEW_LINE print ( countWays ( n , m ) ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def smallestIndexsum ( arr , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while i >= 0 and arr [ i ] % 2 == 1 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE for j in range ( 0 , i + 1 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 6 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestIndexsum ( arr , n ) ) NEW_LINE DEDENT DEDENT
from datetime import datetime , timedelta , timezone NEW_LINE t1 = input ( ) NEW_LINE t2 = input ( ) NEW_LINE date_format = " % Y : % m : % d " NEW_LINE date1 = datetime . strptime ( t1 , date_format ) NEW_LINE date2 = datetime . strptime ( t2 , date_format ) NEW_LINE date1 = date1 . replace ( tzinfo = timezone . utc ) NEW_LINE date2 = date2 . replace ( tzinfo = timezone . utc ) NEW_LINE print ( abs ( ( date2 - date1 ) . days ) ) NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT s = input ( ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT al = [ ] NEW_LINE c = s [ i ] NEW_LINE if c == ' Q ' : NEW_LINE INDENT al . append ( c ) NEW_LINE DEDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT a = s [ j ] NEW_LINE if len ( al ) > 0 : NEW_LINE INDENT if al [ - 1 ] == ' Q ' and a == ' A ' : NEW_LINE INDENT al . append ( a ) NEW_LINE DEDENT if al [ - 1 ] == ' A ' and a == ' Q ' : NEW_LINE INDENT al . append ( a ) NEW_LINE DEDENT if al [ - 1 ] == ' A ' and a == ' A ' : NEW_LINE INDENT al . append ( a ) NEW_LINE DEDENT DEDENT if len ( al ) >= 3 and al [ 0 ] == ' Q ' and al [ - 1 ] == ' Q ' : NEW_LINE INDENT count = count + len ( al ) - 3 NEW_LINE al . pop ( ) NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT m = Main ( ) NEW_LINE m . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def isNeeded ( now , n , k , a ) : NEW_LINE INDENT dp = [ [ False for _ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT if i == now : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT if dp [ i - 1 ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE if j + a [ i - 1 ] <= k : NEW_LINE INDENT dp [ i ] [ j + a [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for i in range ( k - 1 , max ( k - a [ now - 1 ] , 0 ) - 1 , - 1 ) : NEW_LINE INDENT if dp [ n ] [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 if k > a [ 0 ] else 0 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT a . sort ( ) NEW_LINE ng , ok = 0 , n + 1 NEW_LINE while ok - ng > 1 : NEW_LINE INDENT mid = ( ok + ng ) // 2 NEW_LINE if isNeeded ( mid , n , k , a ) : NEW_LINE INDENT ok = mid NEW_LINE DEDENT else : NEW_LINE INDENT ng = mid NEW_LINE DEDENT DEDENT print ( ng ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , s = map ( int , input ( ) . split ( ) ) NEW_LINE k = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT k = s // i NEW_LINE count += k NEW_LINE s -= k * i NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT v = [ ] NEW_LINE @ staticmethod NEW_LINE def multiply ( x ) : NEW_LINE INDENT carry = 0 NEW_LINE size = len ( GFG . v ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT res = carry + GFG . v [ i ] * x NEW_LINE GFG . v [ i ] = res % 10 NEW_LINE carry = res // 10 NEW_LINE DEDENT while carry != 0 : NEW_LINE INDENT GFG . v . append ( carry % 10 ) NEW_LINE carry //= 10 NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def findSumOfDigits ( n ) : NEW_LINE INDENT GFG . v . append ( 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT GFG . multiply ( i ) NEW_LINE DEDENT total_sum = sum ( GFG . v ) NEW_LINE return total_sum NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT n = 1000 NEW_LINE print ( GFG . findSumOfDigits ( n ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE input ( ) NEW_LINE answer = [ 0 ] * M NEW_LINE for n in range ( N ) : NEW_LINE INDENT S = list ( input ( ) . strip ( ) ) NEW_LINE for m in range ( M ) : NEW_LINE INDENT c = S [ m ] NEW_LINE if c == ' L ' : NEW_LINE INDENT hit = m - n NEW_LINE if hit >= 0 : NEW_LINE INDENT answer [ hit ] += 1 NEW_LINE DEDENT DEDENT elif c == ' R ' : NEW_LINE INDENT hit = m + n NEW_LINE if hit < M : NEW_LINE INDENT answer [ hit ] += 1 NEW_LINE DEDENT DEDENT elif c == ' U ' : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT answer [ m ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT output = ' ▁ ' . join ( map ( str , answer ) ) NEW_LINE print ( output ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE from collections import defaultdict NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin . readline NEW_LINE self . tokenizer = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT if not self . tokenizer or not self . tokenizer . hasMoreElements ( ) : NEW_LINE INDENT self . tokenizer = iter ( self . input ( ) . split ( ) ) NEW_LINE DEDENT return next ( self . tokenizer ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT in_ = FastReader ( ) NEW_LINE n = in_ . nextInt ( ) NEW_LINE left = set ( range ( n ) ) NEW_LINE answer = [ 0 ] * n NEW_LINE q = in_ . nextInt ( ) NEW_LINE while q > 0 : NEW_LINE INDENT q -= 1 NEW_LINE l = in_ . nextInt ( ) - 1 NEW_LINE r = in_ . nextInt ( ) - 1 NEW_LINE win = in_ . nextInt ( ) NEW_LINE while left and min ( left ) <= r : NEW_LINE INDENT curr = min ( left ) NEW_LINE answer [ curr ] = win NEW_LINE left . remove ( curr ) NEW_LINE DEDENT answer [ win - 1 ] = 0 NEW_LINE left . add ( win - 1 ) NEW_LINE DEDENT ans = ' ▁ ' . join ( map ( str , answer ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
from sys import stdin , stdout NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( stdin . readline ( ) ) NEW_LINE a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE dp = [ - 1 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = a [ n - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i + 1 ] , a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] > dp [ i + 1 ] : NEW_LINE INDENT stdout . write ( '0 ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT stdout . write ( str ( dp [ i + 1 ] - a [ i ] + 1 ) + ' ▁ ' ) NEW_LINE DEDENT DEDENT stdout . write ( ' \n ' ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def pell ( n ) : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT return 2 * pell ( n - 1 ) + pell ( n - 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( pell ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE def debug ( * obj ) : NEW_LINE INDENT print ( * obj , file = sys . stderr ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE square = n * n NEW_LINE odd = [ ] NEW_LINE even = [ ] NEW_LINE for i in range ( 1 , square + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT even . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . append ( i ) NEW_LINE DEDENT DEDENT loop = square // n NEW_LINE div = loop // 2 NEW_LINE debug ( div ) NEW_LINE for i in range ( 1 , loop + 1 ) : NEW_LINE INDENT for j in range ( div ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT print ( odd . pop ( 0 ) , even . pop ( ) , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( even . pop ( 0 ) , odd . pop ( ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import array as arr NEW_LINE def printSmall ( arr , asize , n ) : NEW_LINE INDENT copy_arr = arr . array ( ' i ' , arr ) NEW_LINE copy_arr = sorted ( copy_arr ) NEW_LINE for i in range ( asize ) : NEW_LINE INDENT if copy_arr . index ( arr [ i ] ) < n : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE asize = len ( arr ) NEW_LINE n = 5 NEW_LINE printSmall ( arr , asize , n ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countNumbers ( n ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if ( n & 1 ) == 0 : NEW_LINE INDENT count += int ( 2 ** k ) NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 11 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , m , money = map ( int , input ( ) . split ( ) ) NEW_LINE min_val = float ( ' inf ' ) NEW_LINE max_val = float ( ' - inf ' ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE min_val = min ( num , min_val ) NEW_LINE DEDENT for _ in range ( m ) : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE max_val = max ( num , max_val ) NEW_LINE DEDENT if money % min_val == 0 : NEW_LINE INDENT div = money // min_val NEW_LINE div *= max_val NEW_LINE print ( max ( div , money ) ) NEW_LINE DEDENT else : NEW_LINE INDENT div = money // min_val NEW_LINE div = ( div * max_val ) + ( money % min_val ) NEW_LINE print ( max ( div , money ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE maximum = float ( ' - inf ' ) NEW_LINE x = 0 NEW_LINE ans = float ( ' inf ' ) NEW_LINE graph = [ [ ] for _ in range ( 100 ) ] NEW_LINE weight = [ 0 , 5 , 10 , 11 , 8 , 6 ] NEW_LINE def __builtin_popcount ( x ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 60 ) : NEW_LINE INDENT if ( ( x >> i ) & 1 ) != 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def dfs ( node , parent ) : NEW_LINE INDENT global maximum , ans NEW_LINE a = __builtin_popcount ( weight [ node ] + x ) NEW_LINE if maximum < a : NEW_LINE INDENT maximum = a NEW_LINE ans = node NEW_LINE DEDENT elif maximum == a : NEW_LINE INDENT ans = min ( ans , node ) NEW_LINE DEDENT for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if graph [ node ] [ i ] == parent : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( graph [ node ] [ i ] , node ) NEW_LINE DEDENT DEDENT x = 15 NEW_LINE graph [ 1 ] . append ( 2 ) NEW_LINE graph [ 2 ] . extend ( [ 3 , 4 ] ) NEW_LINE graph [ 1 ] . append ( 5 ) NEW_LINE dfs ( 1 , 1 ) NEW_LINE print ( ans ) NEW_LINE
class GFG : NEW_LINE INDENT MAX = 26 NEW_LINE @ staticmethod NEW_LINE def updateFreq ( str , freq ) : NEW_LINE INDENT len_str = len ( str ) NEW_LINE for i in range ( len_str ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def maxCount ( str , patt ) : NEW_LINE INDENT strFreq = [ 0 ] * GFG . MAX NEW_LINE GFG . updateFreq ( str , strFreq ) NEW_LINE pattFreq = [ 0 ] * GFG . MAX NEW_LINE GFG . updateFreq ( patt , pattFreq ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE for i in range ( GFG . MAX ) : NEW_LINE INDENT if pattFreq [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT ans = min ( ans , strFreq [ i ] // pattFreq [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE patt = " geeks " NEW_LINE print ( GFG . maxCount ( str , patt ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE b = [ 0 ] * ( n + 1 ) NEW_LINE a1 , b1 , ans = 0 , 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT b [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a1 = a1 | a [ i ] NEW_LINE b1 = b1 | b [ i ] NEW_LINE if a1 + b1 > ans : NEW_LINE INDENT ans = a1 + b1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE N , L , R , QL , QR = map ( int , input ( ) . split ( ) ) NEW_LINE W = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum = [ 0 ] * ( N + 1 ) NEW_LINE for n in range ( N ) : NEW_LINE INDENT sum [ n + 1 ] = sum [ n ] + W [ n ] NEW_LINE DEDENT min_val = float ( ' inf ' ) NEW_LINE for firstR in range ( N + 1 ) : NEW_LINE INDENT lCount = firstR NEW_LINE rCount = N - lCount NEW_LINE cand = sum [ lCount ] * L + ( sum [ N ] - sum [ lCount ] ) * R NEW_LINE llCount = max ( 0 , lCount - rCount - 1 ) NEW_LINE rrCount = max ( 0 , rCount - lCount - 1 ) NEW_LINE cand += llCount * QL NEW_LINE cand += rrCount * QR NEW_LINE min_val = min ( cand , min_val ) NEW_LINE DEDENT print ( min_val ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def wastedWater ( V , M , N ) : NEW_LINE INDENT amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT V , M , N = 700 , 10 , 3 NEW_LINE print ( self . wastedWater ( V , M , N ) ) NEW_LINE V , M , N = 1000 , 100 , 50 NEW_LINE print ( self . wastedWater ( V , M , N ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
def maxSubStr ( str , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT if count0 == count1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if count0 != count1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT str = "0100110101" NEW_LINE n = len ( str ) NEW_LINE print ( maxSubStr ( str , n ) ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT abc = [ int ( input ( ) ) for _ in range ( 3 ) ] NEW_LINE maximum = max ( abc ) NEW_LINE minimum = min ( abc ) NEW_LINE print ( minimum , maximum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE n = 1 NEW_LINE while sum < s : NEW_LINE INDENT sum += n NEW_LINE if sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT s = 15 NEW_LINE n = GFG . findS ( s ) NEW_LINE if n == - 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def maximumAbsolute ( arr , n ) : NEW_LINE INDENT mn = float ( ' inf ' ) NEW_LINE mx = float ( ' - inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i > 0 and arr [ i ] == - 1 and arr [ i - 1 ] != - 1 : NEW_LINE INDENT mn = min ( mn , arr [ i - 1 ] ) NEW_LINE mx = max ( mx , arr [ i - 1 ] ) NEW_LINE DEDENT if i < n - 1 and arr [ i ] == - 1 and arr [ i + 1 ] != - 1 : NEW_LINE INDENT mn = min ( mn , arr [ i + 1 ] ) NEW_LINE mx = max ( mx , arr [ i + 1 ] ) NEW_LINE DEDENT DEDENT common_integer = ( mn + mx ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == - 1 : NEW_LINE INDENT arr [ i ] = common_integer NEW_LINE DEDENT DEDENT max_diff = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE if diff > max_diff : NEW_LINE INDENT max_diff = diff NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ - 1 , - 1 , 11 , - 1 , 3 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( self . maximumAbsolute ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
MOD = 1000000007 NEW_LINE def countStrings ( N ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( 3 ) ] for i in range ( N + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 2 ] = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE print ( countStrings ( N ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def longest_subseq ( n , k , s ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE max_length = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE lower = max ( 0 , curr - k ) NEW_LINE upper = min ( 25 , curr + k ) NEW_LINE for j in range ( lower , upper + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , max_length [ j ] + 1 ) NEW_LINE DEDENT max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in dp : NEW_LINE INDENT ans = max ( i , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE n = len ( s ) NEW_LINE k = 3 NEW_LINE print ( GFG . longest_subseq ( n , k , s ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
class GFG : NEW_LINE INDENT def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT len = 2 NEW_LINE mx = float ( ' - inf ' ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] + a [ i - 2 ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = 2 NEW_LINE DEDENT mx = max ( mx , len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE DEDENT DEDENT
from collections import defaultdict NEW_LINE def minimumSubarrays ( ar ) : NEW_LINE INDENT se = set ( ) NEW_LINE cnt = 1 NEW_LINE for i in range ( len ( ar ) ) : NEW_LINE INDENT if ar [ i ] not in se : NEW_LINE INDENT se . add ( ar [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE se . clear ( ) NEW_LINE se . add ( ar [ i ] ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE print ( minimumSubarrays ( ar ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE i = 0 NEW_LINE while i < 10 : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT while s != 0 : NEW_LINE INDENT r = s % 10 NEW_LINE s = int ( s / 10 ) NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor__ = 0 NEW_LINE i = 0 NEW_LINE while i < 10 : NEW_LINE INDENT xor__ = xor__ ^ freq [ i ] NEW_LINE if xor__ == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT s = 122233 NEW_LINE if GFG . check ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE class FastScanner : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin NEW_LINE self . token = " " NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . token : NEW_LINE INDENT self . token = self . input . readline ( ) . strip ( ) NEW_LINE DEDENT result = self . token NEW_LINE self . token = " " NEW_LINE return result NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT return self . input . readline ( ) . strip ( ) NEW_LINE DEDENT def nextByte ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextShort ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT in = FastScanner ( ) NEW_LINE n = in . nextInt ( ) NEW_LINE m = in . nextInt ( ) NEW_LINE g = m NEW_LINE f = 0 NEW_LINE sum = 0 NEW_LINE arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = in . nextInt ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if m <= sum : NEW_LINE INDENT f += sum // m NEW_LINE sum %= m NEW_LINE DEDENT print ( f , end = " ▁ " ) NEW_LINE f -= f NEW_LINE DEDENT out . close ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT MAXN = 1000005 NEW_LINE even = [ 0 ] * MAXN NEW_LINE odd = [ 0 ] * MAXN NEW_LINE @ staticmethod NEW_LINE def precompute ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 1 : NEW_LINE INDENT GFG . odd [ i ] = 1 NEW_LINE DEDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT GFG . even [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT GFG . even [ i ] = GFG . even [ i ] + GFG . even [ i - 1 ] NEW_LINE GFG . odd [ i ] = GFG . odd [ i ] + GFG . odd [ i - 1 ] NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def isOdd ( L , R ) : NEW_LINE INDENT cnt = GFG . odd [ R ] NEW_LINE if L > 0 : NEW_LINE INDENT cnt -= GFG . odd [ L - 1 ] NEW_LINE DEDENT if cnt == R - L + 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT @ staticmethod NEW_LINE def performQueries ( a , n , q , m ) : NEW_LINE INDENT GFG . precompute ( a , n ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT L , R = q [ i ] [ 0 ] , q [ i ] [ 1 ] NEW_LINE if GFG . isOdd ( L , R ) : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT a = [ 2 , 1 , 5 , 7 , 6 , 8 , 9 ] NEW_LINE n = len ( a ) NEW_LINE q = [ [ 0 , 2 ] , [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 6 ] ] NEW_LINE m = len ( q ) NEW_LINE GFG . performQueries ( a , n , q , m ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = sys . stdin NEW_LINE self . st = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st is None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = self . br . readline ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT return self . br . readline ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT obj = FastReader ( ) NEW_LINE s = [ None ] * 1000 NEW_LINE for n in range ( 1 , 1001 ) : NEW_LINE INDENT flag = True NEW_LINE for i in range ( 1001 ) : NEW_LINE INDENT for j in range ( 1001 ) : NEW_LINE INDENT if ( n - i * 3 - j * 5 ) % 7 == 0 and ( n - i * 3 - j * 5 ) // 7 >= 0 : NEW_LINE INDENT s [ n - 1 ] = f " { i } ▁ { j } ▁ { ( n ▁ - ▁ i ▁ * ▁ 3 ▁ - ▁ j ▁ * ▁ 5 ) ▁ / / ▁ 7 } " NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT s [ n - 1 ] = " - 1" NEW_LINE DEDENT DEDENT tc = obj . nextInt ( ) NEW_LINE while tc != 0 : NEW_LINE INDENT n = obj . nextInt ( ) NEW_LINE print ( s [ n - 1 ] ) NEW_LINE tc -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE a , tA = map ( int , input ( ) . split ( ) ) NEW_LINE b , tB = map ( int , input ( ) . split ( ) ) NEW_LINE timing = input ( ) NEW_LINE hrs , mins = map ( int , timing . split ( ' : ' ) ) NEW_LINE simDeparture = hrs * 60 + mins NEW_LINE simArrival = simDeparture + tA NEW_LINE counter = 0 NEW_LINE for i in range ( 300 , 1440 , b ) : NEW_LINE INDENT busDeparture = i NEW_LINE busArrival = i + tB NEW_LINE if busDeparture >= simArrival or simDeparture >= busArrival : NEW_LINE INDENT continue NEW_LINE DEDENT counter += 1 NEW_LINE DEDENT print ( counter ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE out = 3 NEW_LINE good = True NEW_LINE playing = [ 1 , 2 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT win = int ( input ( ) ) NEW_LINE if win == out : NEW_LINE INDENT good = False NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT replace = 0 NEW_LINE for j in range ( 1 , 4 ) : NEW_LINE INDENT if win != j and out != j : NEW_LINE INDENT replace = j NEW_LINE break NEW_LINE DEDENT DEDENT index = 0 NEW_LINE for j in range ( len ( playing ) ) : NEW_LINE INDENT if playing [ j ] == replace : NEW_LINE INDENT index = j NEW_LINE break NEW_LINE DEDENT DEDENT playing . pop ( index ) NEW_LINE playing . append ( out ) NEW_LINE out = replace NEW_LINE DEDENT DEDENT if good : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def times ( steps , n ) : NEW_LINE INDENT current_level = 0 NEW_LINE previous_level = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT previous_level = current_level NEW_LINE current_level = current_level + steps [ i ] NEW_LINE if ( previous_level < 0 and current_level >= 0 ) or ( previous_level > 0 and current_level <= 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT steps = [ 1 , - 1 , 0 , 0 , 1 , 1 , - 3 , 2 ] NEW_LINE n = len ( steps ) NEW_LINE print ( times ( steps , n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE holidays = [ None ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT month , day , time , value = map ( int , input ( ) . split ( ) ) NEW_LINE holidays [ i ] = Holiday ( month , day , time , value ) NEW_LINE DEDENT min_val = float ( ' inf ' ) NEW_LINE for i in range ( 1 , 361 ) : NEW_LINE INDENT max_val = 0 NEW_LINE for holiday in holidays : NEW_LINE INDENT max_val = max ( max_val , holiday . get_crowded ( i ) ) NEW_LINE DEDENT min_val = min ( min_val , max_val ) NEW_LINE DEDENT print ( min_val ) NEW_LINE DEDENT DEDENT class Holiday : NEW_LINE INDENT def __init__ ( self , month , day , time , value ) : NEW_LINE INDENT self . start = ( month - 1 ) * 30 + day NEW_LINE self . end = self . start + time - 1 NEW_LINE if self . end > 360 : NEW_LINE INDENT self . end -= 360 NEW_LINE DEDENT self . value = value NEW_LINE DEDENT def get_crowded ( self , target ) : NEW_LINE INDENT if self . start > self . end : NEW_LINE INDENT if target <= self . end or target >= self . start : NEW_LINE INDENT return self . value NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . start <= target <= self . end : NEW_LINE INDENT return self . value NEW_LINE DEDENT DEDENT v1 = max ( 0 , self . value - abs ( self . start - target ) if target < self . start else self . value - abs ( 360 + self . start - target ) ) NEW_LINE v2 = max ( 0 , self . value - abs ( target - self . end ) if self . end < target else self . value - abs ( 360 + target - self . end ) ) NEW_LINE return max ( v1 , v2 ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE import io NEW_LINE import os NEW_LINE class PetrPermutations : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT scanner = self . FastScanner ( ) NEW_LINE out = io . StringIO ( ) NEW_LINE N = scanner . nextInt ( ) NEW_LINE perm = [ 0 ] * N NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT perm [ i ] = scanner . nextInt ( ) NEW_LINE i += 1 NEW_LINE DEDENT swaps = 0 NEW_LINE vis = [ False ] * N NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT j = i NEW_LINE cycle = 0 NEW_LINE while not vis [ j ] : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = perm [ j ] - 1 NEW_LINE cycle += 1 NEW_LINE DEDENT if cycle > 0 : NEW_LINE INDENT swaps += cycle - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if swaps % 2 != N % 2 : NEW_LINE INDENT out . write ( " Um _ nik \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT out . write ( " Petr \n " ) NEW_LINE DEDENT sys . stdout . write ( out . getvalue ( ) ) NEW_LINE DEDENT class FastScanner : NEW_LINE INDENT def __init__ ( self , in_stream = None ) : NEW_LINE INDENT if in_stream : NEW_LINE INDENT self . br = in_stream NEW_LINE DEDENT else : NEW_LINE INDENT self . br = io . StringIO ( ) NEW_LINE DEDENT DEDENT def next ( self ) : NEW_LINE INDENT while not hasattr ( self , ' st ' ) or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = io . StringIO ( self . br . readline ( ) ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def readNextLine ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT return self . br . readline ( ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT def readIntArray ( self , n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE idx = 0 NEW_LINE while idx < n : NEW_LINE INDENT a [ idx ] = self . nextInt ( ) NEW_LINE idx += 1 NEW_LINE DEDENT return a NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT PetrPermutations ( ) . main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def smallest ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = " " NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT if s [ i ] > s [ i + 1 ] : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT ans += s [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT ans = s [ : l - 1 ] NEW_LINE return ans NEW_LINE DEDENT s = " abcda " NEW_LINE print ( smallest ( s ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE g = [ 0 , 0 , 2 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE if g [ a ] == g [ b ] : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = float ( ' inf ' ) NEW_LINE found = False NEW_LINE sum = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE if sum == k : NEW_LINE INDENT min_num = min ( min_num , ( n - ( i + 1 ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif sum > k : NEW_LINE INDENT while sum > k : NEW_LINE INDENT sum = sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if sum == k : NEW_LINE INDENT min_num = min ( min_num , ( n - ( i + 1 ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if found : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE class Main : NEW_LINE INDENT sc = None NEW_LINE pr = None NEW_LINE @ staticmethod NEW_LINE def solve ( ) : NEW_LINE INDENT s = list ( input ( ) ) NEW_LINE cnt = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == '1' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT Main . pr . println ( cnt ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT Main . sc = sys . stdin NEW_LINE Main . pr = sys . stdout NEW_LINE Main . solve ( ) NEW_LINE Main . pr . close ( ) NEW_LINE Main . sc . close ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main . main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def nthPalindrome ( n , k ) : NEW_LINE INDENT temp = ( k // 2 ) if ( k % 2 != 0 ) else ( k // 2 - 1 ) NEW_LINE palindrome = 10 ** temp NEW_LINE palindrome += n - 1 NEW_LINE print ( palindrome , end = " " ) NEW_LINE if ( k % 2 ) > 0 : NEW_LINE INDENT palindrome //= 10 NEW_LINE DEDENT while palindrome > 0 : NEW_LINE INDENT print ( palindrome % 10 , end = " " ) NEW_LINE palindrome //= 10 NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE k = 5 NEW_LINE print ( str ( n ) + " th ▁ palindrome ▁ of ▁ " + str ( k ) + " ▁ digit ▁ = ▁ " , end = " " ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE n = 10 NEW_LINE k = 6 NEW_LINE print ( str ( n ) + " th ▁ palindrome ▁ of ▁ " + str ( k ) + " ▁ digit ▁ = ▁ " , end = " " ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . INF = sys . maxsize NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . solve ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT N , X = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE xsum = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT xsum [ i + 1 ] = xsum [ i ] + x [ i ] NEW_LINE DEDENT ans = X * N + 5 * xsum [ N ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT cost = X * i + 5 * ( xsum [ N ] - xsum [ N - i ] ) NEW_LINE j = 5 NEW_LINE k = N - i NEW_LINE while k >= 0 : NEW_LINE INDENT if cost > ans : NEW_LINE INDENT break NEW_LINE DEDENT cost += j * ( xsum [ k ] - xsum [ max ( k - i , 0 ) ] ) NEW_LINE j += 2 NEW_LINE k -= i NEW_LINE DEDENT ans = min ( ans , cost ) NEW_LINE DEDENT print ( ans + N * X ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT MAX = 10000 NEW_LINE hashTable = [ 0 ] * MAX NEW_LINE @ staticmethod NEW_LINE def minOperations ( arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Solution . hashTable [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if Solution . hashTable [ arr [ i ] ] != 0 : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if arr [ j ] % arr [ i ] == 0 : NEW_LINE INDENT Solution . hashTable [ arr [ j ] ] = 0 NEW_LINE DEDENT DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ] NEW_LINE print ( Solution . minOperations ( arr ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT p1 , p2 , p3 , p4 , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE min_val = min ( p1 , p2 , p3 , p4 ) NEW_LINE count = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if i < min_val : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class p033 : NEW_LINE INDENT def main ( args ) : NEW_LINE INDENT print ( p033 ( ) . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT numer = 1 NEW_LINE denom = 1 NEW_LINE for d in range ( 10 , 100 ) : NEW_LINE INDENT for n in range ( 10 , d ) : NEW_LINE INDENT n0 = n % 10 NEW_LINE n1 = n // 10 NEW_LINE d0 = d % 10 NEW_LINE d1 = d // 10 NEW_LINE if n1 == d0 and n0 * d == n * d1 or n0 == d1 and n1 * d == n * d0 : NEW_LINE INDENT numer *= n NEW_LINE denom *= d NEW_LINE DEDENT DEDENT DEDENT return str ( denom // math . gcd ( numer , denom ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countOfOddsPascal ( n ) : NEW_LINE INDENT c = countSetBits ( n ) NEW_LINE return int ( math . pow ( 2 , c ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 20 NEW_LINE print ( countOfOddsPascal ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = max ( max ( x , a - 1 - x ) * b , a * max ( y , b - 1 - y ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GfG : NEW_LINE INDENT def minSwaps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arrpos = [ ( arr [ i ] , i ) for i in range ( n ) ] NEW_LINE arrpos . sort ( key = lambda x : x [ 0 ] ) NEW_LINE vis = [ False ] * n NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if vis [ i ] or arrpos [ i ] [ 1 ] == i : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while not vis [ j ] : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = arrpos [ j ] [ 1 ] NEW_LINE cycle_size += 1 NEW_LINE DEDENT if cycle_size > 0 : NEW_LINE INDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 5 , 4 , 3 , 2 ] NEW_LINE g = GfG ( ) NEW_LINE print ( g . minSwaps ( a ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT N = 1000005 NEW_LINE prime = [ False ] * N NEW_LINE @ staticmethod NEW_LINE def sieve ( ) : NEW_LINE INDENT GFG . prime = [ True ] * GFG . N NEW_LINE GFG . prime [ 1 ] = False NEW_LINE GFG . prime [ 0 ] = False NEW_LINE for i in range ( 2 , GFG . N ) : NEW_LINE INDENT if GFG . prime [ i ] : NEW_LINE INDENT for j in range ( i * 2 , GFG . N , i ) : NEW_LINE INDENT GFG . prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def sumTruncatablePrimes ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT num = i NEW_LINE flag = True NEW_LINE while num > 0 : NEW_LINE INDENT if not GFG . prime [ num ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT num //= 10 NEW_LINE DEDENT num = i NEW_LINE power = 10 NEW_LINE while num // power > 0 : NEW_LINE INDENT if not GFG . prime [ num % power ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT power *= 10 NEW_LINE DEDENT if flag : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT n = 25 NEW_LINE GFG . sieve ( ) NEW_LINE print ( GFG . sumTruncatablePrimes ( n ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def findWeights ( X ) : NEW_LINE INDENT sum = 0 NEW_LINE power = 0 NEW_LINE number = 3 NEW_LINE while sum < X : NEW_LINE INDENT sum = number - 1 NEW_LINE sum //= 2 NEW_LINE power += 1 NEW_LINE number *= 3 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 1 , power + 1 ) : NEW_LINE INDENT print ( ans , end = " ▁ " ) NEW_LINE ans = ans * 3 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = 2 NEW_LINE findWeights ( X ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def addToArrayForm ( A , K ) : NEW_LINE INDENT v = [ ] NEW_LINE ans = [ ] NEW_LINE rem = 0 NEW_LINE i = 0 NEW_LINE for i in range ( len ( A ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT my = A [ i ] + K % 10 + rem NEW_LINE if my > 9 : NEW_LINE INDENT rem = 1 NEW_LINE v . append ( my % 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( my ) NEW_LINE rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT while K > 0 : NEW_LINE INDENT my = K % 10 + rem NEW_LINE v . append ( my % 10 ) NEW_LINE if my // 10 > 0 : NEW_LINE INDENT rem = 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT if rem > 0 : NEW_LINE INDENT v . append ( rem ) NEW_LINE DEDENT for j in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans . append ( v [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT A = [ 2 , 7 , 4 ] NEW_LINE K = 181 NEW_LINE ans = addToArrayForm ( A , K ) NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def printPaths ( input , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT GFG . dfs ( input , " " , 0 , i , R , C ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT def dfs ( input , res , i , j , R , C ) : NEW_LINE INDENT if i == R : NEW_LINE INDENT print ( res + " ▁ " , end = " " ) NEW_LINE return NEW_LINE DEDENT res = res + input [ i ] [ j ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT GFG . dfs ( input , res , i + 1 , k , R , C ) NEW_LINE if i + 1 == R : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT input = [ [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] ] NEW_LINE R = len ( input ) NEW_LINE C = len ( input [ 0 ] ) NEW_LINE GFG . printPaths ( input , R , C ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE line = input ( ) NEW_LINE hotel = [ 0 ] * 10 NEW_LINE for i in range ( num ) : NEW_LINE INDENT actual = line [ i ] NEW_LINE if actual == ' L ' : NEW_LINE INDENT bb = True NEW_LINE pos = 0 NEW_LINE while pos < 10 and bb : NEW_LINE INDENT if hotel [ pos ] == 0 : NEW_LINE INDENT hotel [ pos ] = 1 NEW_LINE bb = False NEW_LINE DEDENT pos += 1 NEW_LINE DEDENT DEDENT elif actual == ' R ' : NEW_LINE INDENT bb = True NEW_LINE pos = 9 NEW_LINE while pos >= 0 and bb : NEW_LINE INDENT if hotel [ pos ] == 0 : NEW_LINE INDENT hotel [ pos ] = 1 NEW_LINE bb = False NEW_LINE DEDENT pos -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT pos = int ( actual ) NEW_LINE hotel [ pos ] = 0 NEW_LINE DEDENT DEDENT res = ' ' . join ( map ( str , hotel ) ) NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin NEW_LINE self . tokens = [ ] NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . tokens : NEW_LINE INDENT self . tokens = self . input . readline ( ) . split ( ) NEW_LINE DEDENT return self . tokens . pop ( 0 ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT return self . input . readline ( ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT reader = FastReader ( ) NEW_LINE T = reader . nextInt ( ) NEW_LINE while T != 0 : NEW_LINE INDENT T -= 1 NEW_LINE a1 = reader . nextInt ( ) NEW_LINE b1 = reader . nextInt ( ) NEW_LINE a2 = reader . nextInt ( ) NEW_LINE b2 = reader . nextInt ( ) NEW_LINE r1 = [ min ( a1 , b1 ) , max ( a1 , b1 ) ] NEW_LINE r2 = [ min ( a2 , b2 ) , max ( a2 , b2 ) ] NEW_LINE if r1 [ 0 ] == r2 [ 0 ] and r1 [ 1 ] + r2 [ 1 ] == r1 [ 0 ] : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif r1 [ 1 ] == r2 [ 1 ] and r1 [ 0 ] + r2 [ 0 ] == r1 [ 1 ] : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class Eulerian : NEW_LINE INDENT def precisionCompute ( x , y , n ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT print ( " Infinite " , end = " " ) NEW_LINE return NEW_LINE DEDENT if x == 0 : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE return NEW_LINE DEDENT if n <= 0 : NEW_LINE INDENT print ( x // y , end = " " ) NEW_LINE return NEW_LINE DEDENT if ( ( x > 0 and y < 0 ) or ( x < 0 and y > 0 ) ) : NEW_LINE INDENT print ( " - " , end = " " ) NEW_LINE x = x if x > 0 else - x NEW_LINE y = y if y > 0 else - y NEW_LINE DEDENT d = x // y NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE x = x - ( y * d ) NEW_LINE if x == 0 : NEW_LINE INDENT break NEW_LINE DEDENT x = x * 10 NEW_LINE d = x // y NEW_LINE if i == 0 : NEW_LINE INDENT print ( " . " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT x = 22 NEW_LINE y = 7 NEW_LINE n = 15 NEW_LINE Eulerian . precisionCompute ( x , y , n ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT Eulerian . main ( [ ] ) NEW_LINE
import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT if n < 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( lcm , arr [ i ] ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectCube ( arr , n ) : NEW_LINE INDENT minPerfectCube = 0 NEW_LINE lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectCube = lcm NEW_LINE cnt = 0 NEW_LINE while lcm > 1 and lcm % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT if cnt % 3 == 2 : NEW_LINE INDENT minPerfectCube *= 2 NEW_LINE DEDENT elif cnt % 3 == 1 : NEW_LINE INDENT minPerfectCube *= 4 NEW_LINE DEDENT i = 3 NEW_LINE while lcm > 1 : NEW_LINE INDENT cnt = 0 NEW_LINE while lcm % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= i NEW_LINE DEDENT if cnt % 3 == 1 : NEW_LINE INDENT minPerfectCube *= i * i NEW_LINE DEDENT elif cnt % 3 == 2 : NEW_LINE INDENT minPerfectCube *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectCube NEW_LINE DEDENT arr = [ 10 , 125 , 14 , 42 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectCube ( arr , n ) ) NEW_LINE
from queue import Queue NEW_LINE from collections import deque NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class BinaryTree : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . root = None NEW_LINE DEDENT def printSpecificLevelOrderUtil ( self , root , s ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT q = Queue ( ) NEW_LINE q . put ( root . left ) NEW_LINE q . put ( root . right ) NEW_LINE first = None NEW_LINE second = None NEW_LINE while not q . empty ( ) : NEW_LINE INDENT first = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE second = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE s . append ( second . left ) NEW_LINE s . append ( first . right ) NEW_LINE s . append ( second . right ) NEW_LINE s . append ( first . left ) NEW_LINE if first . left . left is not None : NEW_LINE INDENT q . put ( first . right ) NEW_LINE q . put ( second . left ) NEW_LINE q . put ( first . left ) NEW_LINE q . put ( second . right ) NEW_LINE DEDENT DEDENT DEDENT def printSpecificLevelOrder ( self , root ) : NEW_LINE INDENT s = deque ( ) NEW_LINE s . append ( root ) NEW_LINE if root . left is not None : NEW_LINE INDENT s . append ( root . right ) NEW_LINE s . append ( root . left ) NEW_LINE DEDENT if root . left . left is not None : NEW_LINE INDENT self . printSpecificLevelOrderUtil ( root , s ) NEW_LINE DEDENT while s : NEW_LINE INDENT print ( s [ 0 ] . data , end = " ▁ " ) NEW_LINE s . popleft ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT tree = BinaryTree ( ) NEW_LINE tree . root = Node ( 1 ) NEW_LINE tree . root . left = Node ( 2 ) NEW_LINE tree . root . right = Node ( 3 ) NEW_LINE print ( " Specific ▁ Level ▁ Order ▁ Traversal ▁ of ▁ Binary ▁ Tree ▁ is " ) NEW_LINE tree . printSpecificLevelOrder ( tree . root ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def hollowSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT if i == 1 or i == rows : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT if j == 1 or j == rows : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT def solidSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def printPattern ( rows ) : NEW_LINE INDENT print ( " Solid ▁ Square : " ) NEW_LINE GFG . solidSquare ( rows ) NEW_LINE print ( " \n Hollow ▁ Square : " ) NEW_LINE GFG . hollowSquare ( rows ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT rows = 5 NEW_LINE GFG . printPattern ( rows ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( ' ab ' ) NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT print ( ' abc ' ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n // 4 ) : NEW_LINE INDENT sys . stdout . write ( ' abcd ' ) NEW_LINE DEDENT t = n % 4 NEW_LINE if t == 1 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif t == 2 : NEW_LINE INDENT print ( ' ab ' ) NEW_LINE DEDENT elif t == 3 : NEW_LINE INDENT print ( ' abc ' ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE n = int ( input ( ) ) NEW_LINE data = [ [ 0 , 0 ] for _ in range ( n + 1 ) ] NEW_LINE maxLen = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT data [ i ] [ 0 ] , data [ i ] [ 1 ] = map ( int , input ( ) . split ( ) ) NEW_LINE maxLen += data [ i ] [ 0 ] NEW_LINE DEDENT dp = [ 10000 ] * ( maxLen + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( maxLen , data [ i ] [ 0 ] - 1 , - 1 ) : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , dp [ j - data [ i ] [ 0 ] ] + data [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( maxLen , - 1 , - 1 ) : NEW_LINE INDENT if maxLen - i >= dp [ i ] : NEW_LINE INDENT print ( maxLen - i ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE if x < a or ( a + b ) < x : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def findLargest ( arr , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( arr [ i ] , gcd ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT return a if b == 0 else __gcd ( b , a % b ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 3 , 6 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findLargest ( arr , n ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def findWinner ( n ) : NEW_LINE INDENT if ( n - 1 ) % 6 == 0 : NEW_LINE INDENT print ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ Player ▁ wins ▁ the ▁ game " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT n = 7 NEW_LINE findWinner ( n ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
` ` ` python NEW_LINE from collections import deque NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self , v ) : NEW_LINE INDENT self . V = v NEW_LINE self . adj = [ deque ( ) for _ in range ( v ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * self . V NEW_LINE queue = deque ( ) NEW_LINE visited [ s ] = True NEW_LINE queue . append ( s ) NEW_LINE while queue : NEW_LINE INDENT s = queue . popleft ( ) NEW_LINE print ( s , end = " ▁ " ) NEW_LINE for n in self . adj [ s ] : NEW_LINE INDENT if not visited [ n ] : NEW_LINE INDENT visited [ n ] = True NEW_LINE queue . append ( n ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = Graph ( 4 ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( " Following ▁ is ▁ Breadth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) NEW_LINE g . BFS ( 2 ) NEW_LINE DEDENT ` ` ` NEW_LINE
from collections import deque NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self , v ) : NEW_LINE INDENT self . V = v NEW_LINE self . adj = [ deque ( ) for _ in range ( v ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * self . V NEW_LINE queue = deque ( ) NEW_LINE visited [ s ] = True NEW_LINE queue . append ( s ) NEW_LINE while queue : NEW_LINE INDENT s = queue . popleft ( ) NEW_LINE print ( s , end = " ▁ " ) NEW_LINE for n in self . adj [ s ] : NEW_LINE INDENT if not visited [ n ] : NEW_LINE INDENT visited [ n ] = True NEW_LINE queue . append ( n ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = Graph ( 4 ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( " Following ▁ is ▁ Breadth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) NEW_LINE g . BFS ( 2 ) NEW_LINE DEDENT
import numpy as np NEW_LINE def getElements ( a , arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE elements = np . zeros ( n + 1 , dtype = int ) NEW_LINE elements [ 0 ] = a NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 13 , 2 , 6 , 1 ] NEW_LINE a = 5 NEW_LINE getElements ( a , arr ) NEW_LINE
` ` ` python NEW_LINE class A : NEW_LINE INDENT cs = [ ' P ' , ' R ' , ' S ' ] NEW_LINE dp = [ [ ' ' for i in range ( 13 ) ] for j in range ( 3 ) ] NEW_LINE @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT A . dp [ 0 ] [ 0 ] = " P " NEW_LINE A . dp [ 1 ] [ 0 ] = " R " NEW_LINE A . dp [ 2 ] [ 0 ] = " S " NEW_LINE for i in range ( 1 , len ( A . dp [ 0 ] ) ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT A . dp [ j ] [ i ] = A . dp [ j ] [ i - 1 ] + A . dp [ ( j + 1 ) % 3 ] [ i - 1 ] NEW_LINE o = A . dp [ ( j + 1 ) % 3 ] [ i - 1 ] + A . dp [ j ] [ i - 1 ] NEW_LINE if o < A . dp [ j ] [ i ] : NEW_LINE INDENT A . dp [ j ] [ i ] = o NEW_LINE DEDENT DEDENT DEDENT T = int ( input ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT print ( " Case ▁ # " + str ( i ) + " : ▁ " , end = " " ) NEW_LINE print ( A . solve ( ) ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def solve ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE R = int ( input ( ) ) NEW_LINE P = int ( input ( ) ) NEW_LINE S = int ( input ( ) ) NEW_LINE ret = None NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT c = [ 0 , 0 , 0 ] NEW_LINE for ch in A . dp [ i ] [ N ] : NEW_LINE INDENT if ch == ' P ' : NEW_LINE INDENT c [ 0 ] += 1 NEW_LINE DEDENT if ch == ' R ' : NEW_LINE INDENT c [ 1 ] += 1 NEW_LINE DEDENT if ch == ' S ' : NEW_LINE INDENT c [ 2 ] += 1 NEW_LINE DEDENT DEDENT if c [ 0 ] == P and c [ 1 ] == R and c [ 2 ] == S : NEW_LINE INDENT ret = A . dp [ i ] [ N ] NEW_LINE DEDENT DEDENT return " IMPOSSIBLE " if ret is None else ret NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE row = [ False ] * n NEW_LINE col = [ False ] * n NEW_LINE for _ in range ( k ) : NEW_LINE INDENT val , val2 = map ( int , input ( ) . split ( ) ) NEW_LINE row [ val - 1 ] = True NEW_LINE col [ val2 - 1 ] = True NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if n % 2 == 1 and i == n // 2 : NEW_LINE INDENT if not row [ i ] or not col [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT elif not row [ i ] or not col [ i ] : NEW_LINE INDENT ans += 2 if not row [ i ] and not col [ i ] else 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE ` ` ` NEW_LINE
class RepeatElement : NEW_LINE INDENT def printRepeating ( self , arr , size ) : NEW_LINE INDENT S = 0 NEW_LINE P = 1 NEW_LINE x , y = 0 , 0 NEW_LINE D = 0 NEW_LINE n = size - 2 NEW_LINE for i in range ( size ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE DEDENT S = S - n * ( n + 1 ) / 2 NEW_LINE P = P // self . fact ( n ) NEW_LINE D = int ( ( S * S - 4 * P ) ** 0.5 ) NEW_LINE x = ( D + S ) // 2 NEW_LINE y = ( S - D ) // 2 NEW_LINE print ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : ▁ " , x , " & " , y ) NEW_LINE DEDENT def fact ( self , n ) : NEW_LINE INDENT return 1 if n == 0 else n * self . fact ( n - 1 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT repeat = RepeatElement ( ) NEW_LINE arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE repeat . printRepeating ( arr , arr_size ) NEW_LINE DEDENT DEDENT
import math NEW_LINE count = 1 NEW_LINE isPrime = [ True ] * 10001 NEW_LINE primes = [ 0 ] * 100000 NEW_LINE sum = [ 0 ] * 100000 NEW_LINE for i in range ( 10001 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( int ( math . sqrt ( len ( isPrime ) ) ) ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT for j in range ( i + i , len ( isPrime ) , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( isPrime ) ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT primes [ count ] = i NEW_LINE sum [ count ] = sum [ count - 1 ] + primes [ count ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE cnt = 0 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( count ) : NEW_LINE INDENT for j in range ( i + 1 , count ) : NEW_LINE INDENT if sum [ j ] - sum [ i ] == n : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x = [ 0.0 ] * n NEW_LINE y = [ 0.0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT x [ i ] = float ( input ( ) ) NEW_LINE y [ i ] = float ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT deg = [ 0.0 ] * ( n - 1 ) NEW_LINE cnt = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT deg [ cnt ] = math . atan2 ( y [ j ] - y [ i ] , x [ j ] - x [ i ] ) NEW_LINE cnt += 1 NEW_LINE DEDENT deg . sort ( ) NEW_LINE ans = 0.0 NEW_LINE for j in range ( n - 2 ) : NEW_LINE INDENT ans = max ( ans , deg [ ( j + 1 ) % ( n - 1 ) ] - deg [ j ] ) NEW_LINE DEDENT ans = max ( ans , math . pi * 2 + deg [ 0 ] - deg [ n - 2 ] ) NEW_LINE ans = ans - math . pi NEW_LINE if ans <= 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " { : . 20f } " . format ( ans / ( 2 * math . pi ) ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def check ( c ) : NEW_LINE INDENT if c in [ ' q ' , ' w ' , ' e ' , ' r ' , ' t ' , ' a ' , ' s ' , ' d ' , ' f ' , ' g ' , ' z ' , ' x ' , ' c ' , ' v ' , ' b ' ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT try : NEW_LINE INDENT while True : NEW_LINE INDENT st = input ( ) NEW_LINE if st == " # " : NEW_LINE INDENT break NEW_LINE DEDENT c = list ( st ) NEW_LINE count = 0 NEW_LINE t = check ( c [ 0 ] ) NEW_LINE for i in range ( 1 , len ( c ) ) : NEW_LINE INDENT if t != check ( c [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE t = check ( c [ i ] ) NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT print ( " Error " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE str = input ( ) NEW_LINE S = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if str [ i ] == ' S ' and str [ i + 1 ] == ' F ' : NEW_LINE INDENT S += 1 NEW_LINE DEDENT elif str [ i ] == ' F ' and str [ i + 1 ] == ' S ' : NEW_LINE INDENT S -= 1 NEW_LINE DEDENT DEDENT if S > 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for j in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_product = 0 NEW_LINE if n == 2 : NEW_LINE INDENT max_product = a [ 0 ] * a [ 1 ] NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if a [ i - 1 ] > a [ i + 1 ] : NEW_LINE INDENT if a [ i ] * a [ i - 1 ] > max_product : NEW_LINE INDENT max_product = a [ i ] * a [ i - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ i ] * a [ i + 1 ] > max_product : NEW_LINE INDENT max_product = a [ i ] * a [ i + 1 ] NEW_LINE DEDENT DEDENT DEDENT print ( max_product ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from math import gcd NEW_LINE def FindLCM ( a , b ) : NEW_LINE INDENT return ( a * b ) // ( a // gcd ( a , b ) * b ) NEW_LINE DEDENT def rangeDivisor ( m , n , a , b ) : NEW_LINE INDENT lcm = FindLCM ( a , b ) NEW_LINE a_divisor = n // a - ( m - 1 ) // a NEW_LINE b_divisor = n // b - ( m - 1 ) // b NEW_LINE common_divisor = n // lcm - ( m - 1 ) // lcm NEW_LINE ans = a_divisor + b_divisor - common_divisor NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m , n , a , b = 3 , 11 , 2 , 3 NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) NEW_LINE m , n , a , b = 11 , 1000000 , 6 , 35 NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def isLatinLetter ( c ) : NEW_LINE INDENT return c >= ' a ' and c <= ' z ' NEW_LINE DEDENT def isPunctuation ( c ) : NEW_LINE INDENT return c in [ ' . ' , ' , ' , ' ! ' , ' ? ' ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = sys . stdin . readline ( ) . strip ( ) NEW_LINE sb = [ ] NEW_LINE sb . append ( s [ 0 ] ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT c = s [ i ] NEW_LINE if isLatinLetter ( c ) : NEW_LINE INDENT if not isLatinLetter ( s [ i - 1 ] ) : NEW_LINE INDENT sb . append ( ' ▁ ' ) NEW_LINE DEDENT sb . append ( c ) NEW_LINE DEDENT elif isPunctuation ( c ) : NEW_LINE INDENT sb . append ( c ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( sb ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
from collections import defaultdict NEW_LINE def smallestKFreq ( a , n , k ) : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE DEDENT res = float ( ' inf ' ) NEW_LINE for temp in m : NEW_LINE INDENT if m [ temp ] == k : NEW_LINE INDENT res = min ( res , temp ) NEW_LINE DEDENT DEDENT return res if res != float ( ' inf ' ) else - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 2 , 1 , 3 , 1 ] NEW_LINE k = 2 NEW_LINE print ( smallestKFreq ( arr , len ( arr ) , k ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = chr ( 64 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' i ' or s [ i ] == ' o ' or s [ i ] == ' u ' : NEW_LINE INDENT if s [ i ] < c : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT s = " aabbbddeecc " NEW_LINE if GFG . areVowelsInOrder ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE N = 0 NEW_LINE min_val = 0 NEW_LINE cnt = 0 NEW_LINE a = [ 0 ] * 180 NEW_LINE b = [ 0 ] * 45 NEW_LINE alreadyA = [ 0 ] * 1000000 NEW_LINE alreadyB = [ 0 ] * 1000000 NEW_LINE def tetrahedral ( a ) : NEW_LINE INDENT return ( a * ( a + 1 ) * ( a + 2 ) ) // 6 NEW_LINE DEDENT def a ( ) : NEW_LINE INDENT for i in range ( 1 , 1000000 ) : NEW_LINE INDENT mina = math . inf NEW_LINE minb = math . inf NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE j = 0 NEW_LINE while j < 180 and a [ j ] <= i : NEW_LINE INDENT mina = min ( 1 + alreadyA [ i - a [ j ] ] , mina ) NEW_LINE if a [ j ] % 2 == 1 : NEW_LINE INDENT minb = min ( 1 + alreadyB [ i - a [ j ] ] , minb ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT alreadyA [ i ] = mina NEW_LINE alreadyB [ i ] = minb NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i < 180 and tetrahedral ( i ) <= 1000000 : NEW_LINE INDENT t = tetrahedral ( i ) NEW_LINE a [ cnt ] = t NEW_LINE cnt += 1 NEW_LINE i += 1 NEW_LINE DEDENT alreadyA = [ 0 ] * 1000000 NEW_LINE alreadyB = [ 0 ] * 1000000 NEW_LINE cnt = 0 NEW_LINE i = 1 NEW_LINE while tetrahedral ( i ) <= 1000000 : NEW_LINE INDENT t = tetrahedral ( i ) NEW_LINE if t % 2 == 1 : NEW_LINE INDENT b [ cnt ] = t NEW_LINE cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT cnt = 0 NEW_LINE min_val = math . inf NEW_LINE print ( alreadyA [ N ] , alreadyB [ N ] ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countOfLetters ( self , string ) : NEW_LINE INDENT letter = 0 NEW_LINE for char in string : NEW_LINE INDENT if ( ' A ' <= char <= ' Z ' ) or ( ' a ' <= char <= ' z ' ) : NEW_LINE INDENT letter += 1 NEW_LINE DEDENT DEDENT return letter NEW_LINE DEDENT def countOfNumbers ( self , string ) : NEW_LINE INDENT number = 0 NEW_LINE for char in string : NEW_LINE INDENT if '0' <= char <= '9' : NEW_LINE INDENT number += 1 NEW_LINE DEDENT DEDENT return number NEW_LINE DEDENT def check ( self , string ) : NEW_LINE INDENT if self . countOfLetters ( string ) == self . countOfNumbers ( string ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT gfg = GFG ( ) NEW_LINE string = " GeeKs01324" NEW_LINE gfg . check ( string ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( args ) : NEW_LINE INDENT box = [ 0 ] * 10 NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT i -= 1 NEW_LINE print ( box [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT box [ i ] = n NEW_LINE i += 1 NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT ` ` ` NEW_LINE
from collections import deque NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT N , x = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 1 or x == 2 * N - 1 : NEW_LINE INDENT print ( " No " ) NEW_LINE break NEW_LINE DEDENT print ( " Yes " ) NEW_LINE low , high = x - 1 , x + 1 NEW_LINE deq = deque ( ) NEW_LINE deq . append ( x ) NEW_LINE while low != 0 or high != 2 * N : NEW_LINE INDENT if low == 0 : NEW_LINE INDENT deq . appendleft ( high ) NEW_LINE deq . append ( high + 1 ) NEW_LINE high += 2 NEW_LINE DEDENT elif high == 2 * N : NEW_LINE INDENT deq . append ( low ) NEW_LINE deq . appendleft ( low - 1 ) NEW_LINE low -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT deq . appendleft ( low ) NEW_LINE low -= 1 NEW_LINE deq . append ( high ) NEW_LINE high += 1 NEW_LINE DEDENT DEDENT for s in deq : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
MAX = 100001 NEW_LINE perfectDiv = [ 0 ] * MAX NEW_LINE def precomputeCounts ( ) : NEW_LINE INDENT for i in range ( 1 , int ( MAX ** 0.5 ) ) : NEW_LINE INDENT for j in range ( i * i , MAX , i * i ) : NEW_LINE INDENT perfectDiv [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT return perfectDiv [ n ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT precomputeCounts ( ) NEW_LINE n = 16 NEW_LINE print ( " Total ▁ perfect ▁ divisors ▁ of " , n , " = " , countPerfectDivisors ( n ) ) NEW_LINE n = 12 NEW_LINE print ( " Total ▁ perfect ▁ divisors ▁ of " , n , " = " , countPerfectDivisors ( n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE nn = sum ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mm = sum ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( nn * mm ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE n , t , e = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT check = x [ i ] * ( ( t + e ) // x [ i ] ) NEW_LINE if check <= t + e and check >= t - e : NEW_LINE INDENT print ( i + 1 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE
0ERROR
import math NEW_LINE def printRoots ( n ) : NEW_LINE INDENT theta = 2 * math . pi / n NEW_LINE for k in range ( n ) : NEW_LINE INDENT real = math . cos ( k * theta ) NEW_LINE img = math . sin ( k * theta ) NEW_LINE print ( " { : . 3f } " . format ( real ) , end = " " ) NEW_LINE if img >= 0 : NEW_LINE INDENT print ( " ▁ + ▁ i ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ - ▁ i ▁ " , end = " " ) NEW_LINE DEDENT print ( " { : . 3f } " . format ( abs ( img ) ) ) NEW_LINE DEDENT DEDENT printRoots ( 1 ) NEW_LINE printRoots ( 2 ) NEW_LINE printRoots ( 3 ) NEW_LINE
import java NEW_LINE import util NEW_LINE def findCart ( arr1 , arr2 , n , n1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n1 ) : NEW_LINE INDENT print ( " { " + str ( arr1 [ i ] ) + " , ▁ " + str ( arr2 [ j ] ) + " } , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE findCart ( arr1 , arr2 , n1 , n2 ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT @ staticmethod NEW_LINE def no_of_ways ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count_left = 0 NEW_LINE count_right = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == s [ 0 ] : NEW_LINE INDENT count_left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == s [ n - 1 ] : NEW_LINE INDENT count_right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if s [ 0 ] == s [ n - 1 ] : NEW_LINE INDENT return ( count_left + 1 ) * ( count_right + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return count_left + count_right + 1 NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( Solution . no_of_ways ( s ) ) NEW_LINE DEDENT DEDENT Solution . main ( ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ False ] * ( MAX + 1 ) NEW_LINE @ staticmethod NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( len ( GFG . prime ) ) : NEW_LINE INDENT GFG . prime [ i ] = True NEW_LINE DEDENT GFG . prime [ 1 ] = False NEW_LINE GFG . prime [ 0 ] = False NEW_LINE for p in range ( 2 , int ( GFG . MAX ** 0.5 ) + 1 ) : NEW_LINE INDENT if GFG . prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , GFG . MAX + 1 , p ) : NEW_LINE INDENT GFG . prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if GFG . prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT GFG . SieveOfEratosthenes ( ) NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE GFG . SumOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
class GFG : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ False ] * ( MAX + 1 ) NEW_LINE @ staticmethod NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( 0 , GFG . MAX + 1 ) : NEW_LINE INDENT GFG . prime [ i ] = True NEW_LINE DEDENT GFG . prime [ 1 ] = False NEW_LINE GFG . prime [ 0 ] = False NEW_LINE for p in range ( 2 , int ( GFG . MAX ** 0.5 ) + 1 ) : NEW_LINE INDENT if GFG . prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , GFG . MAX + 1 , p ) : NEW_LINE INDENT GFG . prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def solve ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if GFG . prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT GFG . SieveOfEratosthenes ( ) NEW_LINE n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE GFG . solve ( arr , n , k ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
class GFG : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ False ] * ( MAX + 1 ) NEW_LINE @ staticmethod NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT GFG . prime [ 1 ] = True NEW_LINE GFG . prime [ 0 ] = True NEW_LINE p = 2 NEW_LINE while p * p <= GFG . MAX : NEW_LINE INDENT if not GFG . prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , GFG . MAX + 1 , p ) : NEW_LINE INDENT GFG . prime [ i ] = True NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def productOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not GFG . prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT product *= arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( product ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT GFG . SieveOfEratosthenes ( ) NEW_LINE n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE GFG . productOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
import java NEW_LINE def findAllSequences ( diff , out , start , end ) : NEW_LINE INDENT if abs ( diff ) > ( end - start + 1 ) / 2 : NEW_LINE INDENT return NEW_LINE DEDENT if start > end : NEW_LINE INDENT if diff == 0 : NEW_LINE INDENT print ( ' ' . join ( out [ : - 1 ] ) , end = ' ▁ ' ) NEW_LINE DEDENT return NEW_LINE DEDENT out [ start ] = '0' NEW_LINE out [ end ] = '1' NEW_LINE findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = out [ end ] = '1' NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = out [ end ] = '0' NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = '1' NEW_LINE out [ end ] = '0' NEW_LINE findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 2 NEW_LINE out = [ ' ' ] * ( 2 * n + 1 ) NEW_LINE out [ 2 * n ] = ' \0' NEW_LINE findAllSequences ( 0 , out , 0 , 2 * n - 1 ) NEW_LINE print ( ' ' ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import heapq NEW_LINE n , h = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE overAllPq = [ ] NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT heapq . heappush ( overAllPq , - arr [ i ] ) NEW_LINE pq = [ - x for x in overAllPq ] NEW_LINE heapq . heapify ( pq ) NEW_LINE c1 , c2 = h , h NEW_LINE flag = True NEW_LINE while pq : NEW_LINE INDENT if flag : NEW_LINE INDENT if c1 >= - pq [ 0 ] : NEW_LINE INDENT c1 -= - heapq . heappop ( pq ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT flag = False NEW_LINE DEDENT else : NEW_LINE INDENT if c2 >= - pq [ 0 ] : NEW_LINE INDENT c2 -= - heapq . heappop ( pq ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT flag = True NEW_LINE DEDENT DEDENT if not pq : NEW_LINE INDENT ans = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
class GFG : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while node is not None : NEW_LINE INDENT print ( node . data , " - > " , end = " ▁ " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( " NULL " ) NEW_LINE DEDENT def cntNodes ( node ) : NEW_LINE INDENT if node is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + cntNodes ( node . next ) NEW_LINE DEDENT def updateList ( head , m ) : NEW_LINE INDENT cnt = cntNodes ( head ) NEW_LINE if cnt != m and m < cnt : NEW_LINE INDENT skip = cnt - m NEW_LINE prev = None NEW_LINE curr = head NEW_LINE while skip > 0 : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE skip -= 1 NEW_LINE DEDENT prev . next = None NEW_LINE tempHead = head NEW_LINE head = curr NEW_LINE while curr . next is not None : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT curr . next = tempHead NEW_LINE DEDENT printList ( head ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT head = Node ( 4 ) NEW_LINE head . next = Node ( 5 ) NEW_LINE head . next . next = Node ( 6 ) NEW_LINE head . next . next . next = Node ( 1 ) NEW_LINE head . next . next . next . next = Node ( 2 ) NEW_LINE head . next . next . next . next . next = Node ( 3 ) NEW_LINE m = 3 NEW_LINE updateList ( head , m ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def maxSubStrings ( s , k ) : NEW_LINE INDENT maxSubStr = 0 NEW_LINE n = len ( s ) NEW_LINE for c in range ( 26 ) : NEW_LINE INDENT ch = chr ( ord ( ' a ' ) + c ) NEW_LINE curr = 0 NEW_LINE i = 0 NEW_LINE while i <= n - k : NEW_LINE INDENT if s [ i ] != ch : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT cnt = 0 NEW_LINE while i < n and s [ i ] == ch and cnt != k : NEW_LINE INDENT i += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE if cnt == k : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT DEDENT maxSubStr = max ( maxSubStr , curr ) NEW_LINE DEDENT return maxSubStr NEW_LINE DEDENT s = " aaacaabbaa " NEW_LINE k = 2 NEW_LINE print ( maxSubStrings ( s , k ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def ansQueries ( prefeven , prefodd , l , r ) : NEW_LINE INDENT if ( r - l + 1 ) % 2 == 0 : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT if l % 2 == 0 : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * 100 NEW_LINE prefeven = [ 0 ] * 100 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i != q : NEW_LINE INDENT GFG . ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = [ 2 , 3 , 4 ] NEW_LINE q = len ( l ) NEW_LINE GFG . wrapper ( arr , n , l , r , q ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE n = int ( input ( ) ) NEW_LINE ans = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans . sort ( ) NEW_LINE count = ans [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ans [ i ] < ans [ i + 1 ] : NEW_LINE INDENT count += ans [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT while ans [ i ] >= ans [ i + 1 ] : NEW_LINE INDENT ans [ i ] -= 1 NEW_LINE DEDENT if ans [ i ] > 0 : NEW_LINE INDENT count += ans [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin . readline NEW_LINE self . tokens = [ ] NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . tokens : NEW_LINE INDENT self . tokens = self . input ( ) . split ( ) NEW_LINE DEDENT return self . tokens . pop ( 0 ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT return self . input ( ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT reader = FastReader ( ) NEW_LINE num = reader . nextInt ( ) NEW_LINE while num > 0 : NEW_LINE INDENT n = reader . nextInt ( ) NEW_LINE k = reader . nextInt ( ) NEW_LINE arr = [ 0 ] * ( n * k ) NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT arr [ i ] = reader . nextLong ( ) NEW_LINE DEDENT sum = 0 NEW_LINE skip = 0 NEW_LINE start = k * n NEW_LINE if n % 2 == 0 : NEW_LINE INDENT skip = n // 2 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT sum += arr [ start - skip - 1 ] NEW_LINE start = start - skip - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT skip = n // 2 + 1 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT sum += arr [ start - skip ] NEW_LINE start = start - skip NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE num -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE from collections import deque NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE stack = { i : deque ( ) for i in range ( n ) } NEW_LINE output = [ ] NEW_LINE for _ in range ( q ) : NEW_LINE INDENT cmd , t = map ( int , input ( ) . split ( ) ) NEW_LINE if cmd == 0 : NEW_LINE INDENT stack [ t ] . append ( int ( input ( ) ) ) NEW_LINE DEDENT elif cmd == 1 and stack [ t ] : NEW_LINE INDENT output . append ( str ( stack [ t ] [ 0 ] ) ) NEW_LINE DEDENT elif cmd == 2 and stack [ t ] : NEW_LINE INDENT stack [ t ] . popleft ( ) NEW_LINE DEDENT DEDENT print ( " \n " . join ( output ) ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT maxVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT GFG . removeMin ( arr , n ) NEW_LINE DEDENT else : NEW_LINE INDENT GFG . removeFromMax ( arr , n ) NEW_LINE DEDENT GFG . printArray ( arr , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE GFG . modifyArray ( arr , n , k ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def find_centroid ( v ) : NEW_LINE INDENT ans = [ 0.0 , 0.0 ] NEW_LINE n = len ( v ) NEW_LINE signed_area = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x0 , y0 = v [ i ] [ 0 ] , v [ i ] [ 1 ] NEW_LINE x1 , y1 = v [ ( i + 1 ) % n ] [ 0 ] , v [ ( i + 1 ) % n ] [ 1 ] NEW_LINE A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE signed_area += A NEW_LINE ans [ 0 ] += ( x0 + x1 ) * A NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A NEW_LINE DEDENT signed_area *= 0.5 NEW_LINE ans [ 0 ] = ans [ 0 ] / ( 6 * signed_area ) NEW_LINE ans [ 1 ] = ans [ 1 ] / ( 6 * signed_area ) NEW_LINE return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT vp = [ [ 1 , 2 ] , [ 3 , - 4 ] , [ 6 , - 7 ] ] NEW_LINE ans = GFG . find_centroid ( vp ) NEW_LINE print ( " { : . 3f } ▁ { : . 3f } " . format ( ans [ 0 ] , ans [ 1 ] ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE color = " blue " NEW_LINE locked = False NEW_LINE lines = int ( input ( ) ) NEW_LINE for i in range ( lines ) : NEW_LINE INDENT next_input = input ( ) NEW_LINE if next_input == " lock " : NEW_LINE INDENT locked = True NEW_LINE continue NEW_LINE DEDENT if next_input == " unlock " : NEW_LINE INDENT locked = False NEW_LINE continue NEW_LINE DEDENT if locked : NEW_LINE INDENT continue NEW_LINE DEDENT color = next_input NEW_LINE DEDENT print ( color ) NEW_LINE
import numpy as np NEW_LINE def minOperations ( ar , k ) : NEW_LINE INDENT ar . sort ( ) NEW_LINE opsNeeded = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT opsNeeded += ar [ k - 1 ] - ar [ i ] NEW_LINE DEDENT ans = opsNeeded NEW_LINE for i in range ( k , len ( ar ) ) : NEW_LINE INDENT opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) NEW_LINE opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) NEW_LINE ans = min ( ans , opsNeeded ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 1 , 9 , 100 ] NEW_LINE k = 3 NEW_LINE print ( minOperations ( arr , k ) ) NEW_LINE
def charCheck ( input_char ) : NEW_LINE INDENT if ( input_char >= ' A ' and input_char <= ' Z ' ) or ( input_char >= ' a ' and input_char <= ' z ' ) : NEW_LINE INDENT print ( " Alphabet " ) NEW_LINE DEDENT elif input_char >= '0' and input_char <= '9' : NEW_LINE INDENT print ( " Digit " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Special ▁ Character " ) NEW_LINE DEDENT DEDENT input_char = ' $ ' NEW_LINE charCheck ( input_char ) NEW_LINE
from collections import defaultdict NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE mp [ i + 1 ] = 1 NEW_LINE flag = 0 NEW_LINE j = i NEW_LINE while flag == 0 : NEW_LINE INDENT if mp [ lst [ j ] ] == 0 : NEW_LINE INDENT mp [ lst [ j ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE print ( lst [ j ] , end = " ▁ " ) NEW_LINE DEDENT j = lst [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE tab = [ set ( ) for _ in range ( n ) ] NEW_LINE ans = 3000003 NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE for x in tab [ a ] : NEW_LINE INDENT if x in tab [ b ] : NEW_LINE INDENT ans = min ( p [ a ] + p [ b ] + p [ x ] , ans ) NEW_LINE DEDENT DEDENT tab [ a ] . add ( b ) NEW_LINE tab [ b ] . add ( a ) NEW_LINE DEDENT if ans == 3000003 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class CF67B : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = sys . stdin NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n , k = map ( int , self . sc . readline ( ) . split ( ) ) NEW_LINE bb = list ( map ( int , self . sc . readline ( ) . split ( ) ) ) NEW_LINE aa = [ 0 ] * n NEW_LINE m = 0 NEW_LINE for a in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while bb [ a ] > 0 : NEW_LINE INDENT if aa [ j ] >= a + k : NEW_LINE INDENT bb [ a ] -= 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT for j_ in range ( m , j , - 1 ) : NEW_LINE INDENT aa [ j_ ] = aa [ j_ - 1 ] NEW_LINE DEDENT aa [ j ] = a NEW_LINE m += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( aa [ i ] + 1 , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT o = CF67B ( ) NEW_LINE o . main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class Point : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE table = [ [ 0 for _ in range ( 50 ) ] for _ in range ( 50 ) ] NEW_LINE map = { } NEW_LINE cnt = 0 NEW_LINE m = 0 NEW_LINE sb = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT row = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( c [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE if table [ i ] [ j ] == cnt : NEW_LINE INDENT continue NEW_LINE DEDENT sb . append ( str ( i + 1 ) + " ▁ " + str ( j + 1 ) + " ▁ " ) NEW_LINE point = Point ( i + 1 , j + 1 ) NEW_LINE sb . append ( str ( map [ cnt ] . x ) + " ▁ " + str ( map [ cnt ] . y ) + " \n " ) NEW_LINE tmp = table [ i ] [ j ] NEW_LINE table [ i ] [ j ] = table [ map [ cnt ] . x - 1 ] [ map [ cnt ] . y - 1 ] NEW_LINE table [ map [ cnt ] . x - 1 ] [ map [ cnt ] . y - 1 ] = tmp NEW_LINE map [ tmp ] = map [ cnt ] NEW_LINE m += 1 NEW_LINE DEDENT DEDENT print ( m ) NEW_LINE s = ' ' . join ( sb ) NEW_LINE if m > 0 : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT @ staticmethod NEW_LINE def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ctX = 0 NEW_LINE ctY = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if arr [ j ] == x : NEW_LINE INDENT ctX += 1 NEW_LINE DEDENT elif arr [ j ] == y : NEW_LINE INDENT ctY += 1 NEW_LINE DEDENT if ctX == ctY : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE print ( Solution . sameOccurrence ( arr , n , x , y ) ) NEW_LINE DEDENT DEDENT Solution . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a = list ( input ( ) ) NEW_LINE if len ( a ) >= 3 : NEW_LINE INDENT z = 0 NEW_LINE o = 0 NEW_LINE for j in range ( len ( a ) ) : NEW_LINE INDENT if a [ j ] == '1' : NEW_LINE INDENT o += 1 NEW_LINE DEDENT else : NEW_LINE INDENT z += 1 NEW_LINE DEDENT DEDENT if z > o : NEW_LINE INDENT print ( o ) NEW_LINE DEDENT elif o > z : NEW_LINE INDENT print ( z ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( z - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE n = 0 NEW_LINE a = [ ] NEW_LINE def solve ( ) : NEW_LINE INDENT global n , a NEW_LINE mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( a [ i ] , mx ) NEW_LINE DEDENT cnt = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ a [ i ] ] = cnt . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT if cnt [ mx ] % 2 != 0 : NEW_LINE INDENT return " Conan \n " NEW_LINE DEDENT elif cnt [ mx ] == n : NEW_LINE INDENT return " Agasa \n " NEW_LINE DEDENT else : NEW_LINE INDENT for key , value in cnt . items ( ) : NEW_LINE INDENT if value % 2 != 0 : NEW_LINE INDENT return " Conan \n " NEW_LINE DEDENT DEDENT return " Agasa \n " NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT lenv = False NEW_LINE if lenv : NEW_LINE INDENT with open ( " input . txt " , ' r ' ) as f : NEW_LINE INDENT input_data = f . read ( ) . splitlines ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT input_data = sys . stdin . read ( ) . splitlines ( ) NEW_LINE DEDENT n = int ( input_data [ 0 ] ) NEW_LINE a = list ( map ( int , input_data [ 1 ] . split ( ) ) ) NEW_LINE result = solve ( ) NEW_LINE print ( result ) NEW_LINE DEDENT ` ` ` NEW_LINE
a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def main ( args ) : NEW_LINE INDENT target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT toFind = target / ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if arr [ k ] == toFind : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( " Total ▁ number ▁ of ▁ triplets ▁ found : ▁ " + str ( totalCount ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin . readline NEW_LINE self . tokens = [ ] NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . tokens : NEW_LINE INDENT self . tokens = self . input ( ) . split ( ) NEW_LINE DEDENT return self . tokens . pop ( 0 ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT return self . input ( ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT t = FastReader ( ) NEW_LINE n = t . nextInt ( ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = t . nextLong ( ) NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( "1 ▁ 1" ) NEW_LINE print ( - a [ 0 ] ) NEW_LINE print ( "1 ▁ 1" ) NEW_LINE print ( "0" ) NEW_LINE print ( "1 ▁ 1" ) NEW_LINE print ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "1 ▁ 1" ) NEW_LINE print ( - a [ 0 ] ) NEW_LINE print ( "1 ▁ " + str ( n ) ) NEW_LINE a [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sys . stdout . write ( str ( - n * a [ i ] ) + " ▁ " ) NEW_LINE DEDENT print ( " \n 2 ▁ " + str ( n ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sys . stdout . write ( str ( ( n - 1 ) * a [ i ] ) + " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def finalNum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = __gcd ( result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT return a if b == 0 else __gcd ( b , a % b ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 3 , 9 , 6 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( finalNum ( arr , n ) ) NEW_LINE DEDENT DEDENT
import numpy as np NEW_LINE class GFG : NEW_LINE INDENT N = 1000 NEW_LINE @ staticmethod NEW_LINE def lastElement ( a , n ) : NEW_LINE INDENT steps = 1 NEW_LINE v = [ np . array ( [ ] ) for _ in range ( GFG . N ) ] NEW_LINE if n == 1 : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT v [ steps ] = np . bitwise_or ( a [ i ] , a [ i + 1 ] ) NEW_LINE DEDENT while len ( v [ steps ] ) > 1 : NEW_LINE INDENT steps += 1 NEW_LINE new_v = [ ] NEW_LINE for i in range ( 0 , len ( v [ steps - 1 ] ) , 2 ) : NEW_LINE INDENT if steps % 2 == 1 : NEW_LINE INDENT new_v . append ( np . bitwise_or ( v [ steps - 1 ] [ i ] , v [ steps - 1 ] [ i + 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT new_v . append ( np . bitwise_xor ( v [ steps - 1 ] [ i ] , v [ steps - 1 ] [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT v [ steps ] = np . array ( new_v ) NEW_LINE DEDENT return v [ steps ] [ 0 ] NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT a = np . array ( [ 1 , 4 , 5 , 6 ] ) NEW_LINE n = len ( a ) NEW_LINE index = 0 NEW_LINE value = 2 NEW_LINE a [ 0 ] = 2 NEW_LINE print ( GFG . lastElement ( a , n ) ) NEW_LINE index = 3 NEW_LINE value = 5 NEW_LINE a [ index ] = value NEW_LINE print ( GFG . lastElement ( a , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
import math NEW_LINE def number_cake ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 ) // 6 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_cake ( n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT input_str = input ( ) NEW_LINE input = list ( input_str ) NEW_LINE result = 0 NEW_LINE p = 0 NEW_LINE g = 1 NEW_LINE for i in range ( 1 , len ( input ) ) : NEW_LINE INDENT if input [ i ] == ' g ' : NEW_LINE INDENT if p + 1 <= g : NEW_LINE INDENT result += 1 NEW_LINE p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT g += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if p + 1 <= g : NEW_LINE INDENT p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT g += 1 NEW_LINE result -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class solution : NEW_LINE INDENT def pattern ( N ) : NEW_LINE INDENT i , j , k , space = 0 , 0 , 0 , 1 NEW_LINE rows = N NEW_LINE for i in range ( rows , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT if i != rows : NEW_LINE INDENT for k in range ( 1 , space + 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT space += 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if j != rows : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT print ( " \n " ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 6 NEW_LINE pattern ( N ) NEW_LINE DEDENT DEDENT
from math import max NEW_LINE def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) // 2 NEW_LINE high = ( n + 1 - k ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n = 9 NEW_LINE k = 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class TreeNode : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . val = rootData NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . result = 0 NEW_LINE self . cache = { } NEW_LINE DEDENT def pathSum ( self , root , sum ) : NEW_LINE INDENT self . result = 0 NEW_LINE self . cache = { 0 : 1 } NEW_LINE self . pathSumHelper ( root , sum , 0 ) NEW_LINE return self . result NEW_LINE DEDENT def pathSumHelper ( self , root , target , soFar ) : NEW_LINE INDENT if root : NEW_LINE INDENT complement = soFar + root . val - target NEW_LINE if complement in self . cache : NEW_LINE INDENT self . result += self . cache [ complement ] NEW_LINE DEDENT self . cache [ soFar + root . val ] = self . cache . get ( soFar + root . val , 0 ) + 1 NEW_LINE self . pathSumHelper ( root . left , target , soFar + root . val ) NEW_LINE self . pathSumHelper ( root . right , target , soFar + root . val ) NEW_LINE self . cache [ soFar + root . val ] -= 1 NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE tree = TreeNode ( 10 ) NEW_LINE tree . left = TreeNode ( 5 ) NEW_LINE tree . right = TreeNode ( - 3 ) NEW_LINE tree . left . left = TreeNode ( 3 ) NEW_LINE tree . left . right = TreeNode ( 2 ) NEW_LINE tree . right . right = TreeNode ( 11 ) NEW_LINE tree . left . left . left = TreeNode ( 3 ) NEW_LINE tree . left . left . right = TreeNode ( - 2 ) NEW_LINE tree . left . right . right = TreeNode ( 1 ) NEW_LINE sum = 8 NEW_LINE out = sObj . pathSum ( tree , sum ) NEW_LINE print ( out ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java NEW_LINE def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def msm ( n , c ) : NEW_LINE INDENT if c == 11 : NEW_LINE INDENT return NEW_LINE DEDENT str_num = str ( n * n ) NEW_LINE str_num = str_num . zfill ( 8 ) [ 2 : 6 ] NEW_LINE out = int ( str_num ) NEW_LINE print ( out ) NEW_LINE msm ( out , c + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " Case ▁ " + str ( i ) + " : " ) NEW_LINE msm ( int ( input ( ) ) , 1 ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE sosu = [ True ] * ( 123456 * 2 + 1 ) NEW_LINE sosu [ 0 ] = False NEW_LINE sosu [ 1 ] = False NEW_LINE for i in range ( 2 , int ( math . sqrt ( 123456 * 2 ) ) + 1 ) : NEW_LINE INDENT if sosu [ i ] : NEW_LINE INDENT for j in range ( 2 , ( 123456 * 2 // i ) + 1 ) : NEW_LINE INDENT sosu [ i * j ] = False NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n + 1 , n * 2 + 1 ) : NEW_LINE INDENT if sosu [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def maxOR ( arr , n ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) NEW_LINE DEDENT DEDENT return maxVal NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxOR ( arr , n ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numJewelsInStones ( self , J : str , S : str ) -> int : NEW_LINE INDENT result = 0 NEW_LINE jHash = set ( ) NEW_LINE for j in J : NEW_LINE INDENT jHash . add ( j ) NEW_LINE DEDENT for s in S : NEW_LINE INDENT if s in jHash : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE J = " aA " NEW_LINE S = " aAAbbbb " NEW_LINE out = sObj . numJewelsInStones ( J , S ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT sObj = Solution ( ) NEW_LINE sObj . main ( ) NEW_LINE
` ` ` python NEW_LINE MAX = 100 NEW_LINE n = 0 NEW_LINE store = [ 0 ] * MAX NEW_LINE graph = [ [ 0 ] * MAX for _ in range ( MAX ) ] NEW_LINE d = [ 0 ] * MAX NEW_LINE def is_clique ( b ) : NEW_LINE INDENT for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( i + 1 , b ) : NEW_LINE INDENT if graph [ store [ i ] ] [ store [ j ] ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def maxCliques ( i , l ) : NEW_LINE INDENT max_ = 0 NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT store [ l ] = j NEW_LINE if is_clique ( l + 1 ) : NEW_LINE INDENT max_ = max ( max_ , l ) NEW_LINE max_ = max ( max_ , maxCliques ( j , l + 1 ) ) NEW_LINE DEDENT DEDENT return max_ NEW_LINE DEDENT edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 1 ] , [ 4 , 2 ] ] NEW_LINE size = len ( edges ) NEW_LINE n = 4 NEW_LINE for i in range ( size ) : NEW_LINE INDENT graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 NEW_LINE graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 NEW_LINE d [ edges [ i ] [ 0 ] ] += 1 NEW_LINE d [ edges [ i ] [ 1 ] ] += 1 NEW_LINE DEDENT print ( maxCliques ( 0 , 1 ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def setBitNumber ( n ) : NEW_LINE INDENT k = int ( math . log ( n ) / math . log ( 2 ) ) NEW_LINE return int ( math . pow ( 2 , k ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 273 NEW_LINE print ( GFG . setBitNumber ( n ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE input = sys . stdin . readline ( ) . split ( ) NEW_LINE m = int ( input [ 1 ] ) NEW_LINE s = int ( input [ 2 ] ) NEW_LINE f = int ( input [ 3 ] ) NEW_LINE maxT = - 1 NEW_LINE map = { } NEW_LINE while m > 0 : NEW_LINE INDENT mth = sys . stdin . readline ( ) . split ( ) NEW_LINE k = int ( mth [ 0 ] ) NEW_LINE map [ k ] = [ int ( mth [ 1 ] ) , int ( mth [ 2 ] ) ] NEW_LINE maxT = max ( maxT , k ) NEW_LINE m -= 1 NEW_LINE DEDENT actions = " " NEW_LINE M = ' R ' if s < f else ' L ' NEW_LINE d = 1 if s < f else - 1 NEW_LINE cur = s NEW_LINE a = - 1 NEW_LINE b = - 1 NEW_LINE for t in range ( 1 , maxT + 1 ) : NEW_LINE INDENT if t in map : NEW_LINE INDENT a = map [ t ] [ 0 ] NEW_LINE b = map [ t ] [ 1 ] NEW_LINE DEDENT if t in map and ( ( cur >= a and cur <= b ) or ( cur + d >= a and cur + d <= b ) ) : NEW_LINE INDENT actions += ' X ' NEW_LINE DEDENT else : NEW_LINE INDENT actions += M NEW_LINE cur += d NEW_LINE DEDENT if cur == f : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT while cur != f : NEW_LINE INDENT actions += M NEW_LINE cur += d NEW_LINE DEDENT print ( actions ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class Test : NEW_LINE INDENT @ staticmethod NEW_LINE def subsetPairNotDivisibleByK ( arr , N , K ) : NEW_LINE INDENT f = [ 0 ] * K NEW_LINE for i in range ( N ) : NEW_LINE INDENT f [ arr [ i ] % K ] += 1 NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT f [ K // 2 ] = min ( f [ K // 2 ] , 1 ) NEW_LINE DEDENT res = min ( f [ 0 ] , 1 ) NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT res += max ( f [ i ] , f [ K - i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 9 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( self . subsetPairNotDivisibleByK ( arr , N , K ) ) NEW_LINE DEDENT DEDENT Test ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE ans = 0 NEW_LINE def get ( a ) : NEW_LINE INDENT ret = 0 NEW_LINE now = 1 NEW_LINE t = 1 NEW_LINE while True : NEW_LINE INDENT if now * 10 > a : NEW_LINE INDENT ret += ( a - now + 1 ) * t NEW_LINE break NEW_LINE DEDENT ret += now * 9 * t NEW_LINE now *= 10 NEW_LINE t += 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def binarySearch ( k , l , r , x ) : NEW_LINE INDENT global ans NEW_LINE if r >= l : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if mid > ans and mid * k <= x : NEW_LINE INDENT ans = mid NEW_LINE DEDENT if k * mid == x : NEW_LINE INDENT return mid NEW_LINE DEDENT if k * mid > x : NEW_LINE INDENT return binarySearch ( k , l , mid - 1 , x ) NEW_LINE DEDENT return binarySearch ( k , mid + 1 , r , x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT gen , st , tim = map ( int , input ( ) . split ( ) ) NEW_LINE gen //= tim NEW_LINE beg , end = st - 1 , 10 ** 18 NEW_LINE while True : NEW_LINE INDENT med = ( beg + end ) // 2 + 1 NEW_LINE if get ( med ) - get ( st - 1 ) > gen : NEW_LINE INDENT end = med - 1 NEW_LINE DEDENT else : NEW_LINE INDENT beg = med NEW_LINE DEDENT if beg == end : NEW_LINE INDENT print ( beg - st + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def printRoots ( a , b , c ) : NEW_LINE INDENT print ( 1 , " , ▁ " , c / ( a * 1.0 ) ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE c = - 5 NEW_LINE self . printRoots ( a , b , c ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT memo = [ [ [ 0 for _ in range ( 2 ) ] for _ in range ( 2 ) ] for _ in range ( 32 ) ] NEW_LINE @ staticmethod NEW_LINE def dp ( pos , fl , pr , bin ) : NEW_LINE INDENT if pos == len ( bin ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if GFG . memo [ pos ] [ fl ] [ pr ] != - 1 : NEW_LINE INDENT return GFG . memo [ pos ] [ fl ] [ pr ] NEW_LINE DEDENT val = 0 NEW_LINE if bin [ pos ] == '0' : NEW_LINE INDENT val += GFG . dp ( pos + 1 , fl , 0 , bin ) NEW_LINE DEDENT elif bin [ pos ] == '1' : NEW_LINE INDENT val += GFG . dp ( pos + 1 , 1 , 0 , bin ) NEW_LINE DEDENT if pr == 0 : NEW_LINE INDENT if fl == 1 : NEW_LINE INDENT val += GFG . dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT elif bin [ pos ] == '1' : NEW_LINE INDENT val += GFG . dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT DEDENT GFG . memo [ pos ] [ fl ] [ pr ] = val NEW_LINE return val NEW_LINE DEDENT @ staticmethod NEW_LINE def findIntegers ( num ) : NEW_LINE INDENT bin = " " NEW_LINE while num > 0 : NEW_LINE INDENT if num % 2 == 1 : NEW_LINE INDENT bin += "1" NEW_LINE DEDENT else : NEW_LINE INDENT bin += "0" NEW_LINE DEDENT num //= 2 NEW_LINE DEDENT bin = GFG . reverse ( bin ) NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT for l in range ( 2 ) : NEW_LINE INDENT GFG . memo [ i ] [ j ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT return GFG . dp ( 0 , 0 , 0 , bin ) NEW_LINE DEDENT @ staticmethod NEW_LINE def reverse ( input ) : NEW_LINE INDENT a = list ( input ) NEW_LINE l , r = 0 , len ( a ) - 1 NEW_LINE while l < r : NEW_LINE INDENT temp = a [ l ] NEW_LINE a [ l ] = a [ r ] NEW_LINE a [ r ] = temp NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return ' ' . join ( a ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT N = 12 NEW_LINE print ( GFG . findIntegers ( N ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE
class GFG : NEW_LINE INDENT N = 4 NEW_LINE @ staticmethod NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for _ in range ( n ) ] for _ in range ( n ) ] NEW_LINE if mat [ 0 ] [ 0 ] == 1 : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ 0 ] [ i ] == 1 : NEW_LINE INDENT dp [ 0 ] [ i ] = int ( dp [ 0 ] [ i - 1 ] + 2 ** i ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ 0 ] == 1 : NEW_LINE INDENT dp [ i ] [ 0 ] = int ( dp [ i - 1 ] [ 0 ] + 2 ** i ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ j ] == 1 : NEW_LINE INDENT dp [ i ] [ j ] = int ( max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + 2 ** ( i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ] NEW_LINE print ( GFG . MaximumDecimalValue ( mat , 4 ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while curr < maxElement : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def findFibonacciPair ( n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE GFG . createHash ( hash , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i in hash and ( n - i ) in hash : NEW_LINE INDENT print ( i , " , ▁ " , ( n - i ) , " \n " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " - 1 \n " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 90 NEW_LINE GFG . findFibonacciPair ( N ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import java NEW_LINE def countgroup ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT if xs == 0 : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countgroup ( a , n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def maxLength ( s , n ) : NEW_LINE INDENT ans = float ( ' - inf ' ) NEW_LINE A = [ ] NEW_LINE L = [ ] NEW_LINE R = [ ] NEW_LINE freq = [ 0 ] * ( n + 5 ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ord ( s [ j ] ) - ord ( ' a ' ) == i : NEW_LINE INDENT count += 1 NEW_LINE DEDENT freq [ j ] = count NEW_LINE DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT L . append ( ( 2 * freq [ j - 1 ] ) - j ) NEW_LINE R . append ( ( 2 * freq [ j ] ) - j ) NEW_LINE DEDENT max_len = float ( ' - inf ' ) NEW_LINE min_val = float ( ' inf ' ) NEW_LINE for j in range ( len ( L ) ) : NEW_LINE INDENT min_val = min ( min_val , L [ j ] ) NEW_LINE A . append ( min_val ) NEW_LINE l , r = 0 , j NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if A [ mid ] <= R [ j ] : NEW_LINE INDENT max_len = max ( max_len , j - mid + 1 ) NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT DEDENT ans = max ( ans , max_len ) NEW_LINE A . clear ( ) NEW_LINE R . clear ( ) NEW_LINE L . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT s = " ababbbacbcbcca " NEW_LINE n = len ( s ) NEW_LINE print ( GFG . maxLength ( s , n ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT class pair : NEW_LINE INDENT def __init__ ( self , first , second ) : NEW_LINE INDENT self . first = first NEW_LINE self . second = second NEW_LINE DEDENT DEDENT N = 100005 NEW_LINE gr = [ [ ] for _ in range ( N ) ] NEW_LINE colour = [ - 1 ] * N NEW_LINE edges = [ ] NEW_LINE bip = False NEW_LINE @ staticmethod NEW_LINE def add_edge ( x , y ) : NEW_LINE INDENT GFG . gr [ x ] . append ( y ) NEW_LINE GFG . gr [ y ] . append ( x ) NEW_LINE GFG . edges . append ( GFG . pair ( x , y ) ) NEW_LINE DEDENT @ staticmethod NEW_LINE def dfs ( x , col ) : NEW_LINE INDENT GFG . colour [ x ] = col NEW_LINE for i in GFG . gr [ x ] : NEW_LINE INDENT if GFG . colour [ i ] == - 1 : NEW_LINE INDENT GFG . dfs ( i , col ^ 1 ) NEW_LINE DEDENT elif GFG . colour [ i ] == col : NEW_LINE INDENT GFG . bip = False NEW_LINE DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def Directed_Graph ( n , m ) : NEW_LINE INDENT for i in range ( GFG . N ) : NEW_LINE INDENT GFG . colour [ i ] = - 1 NEW_LINE DEDENT GFG . bip = True NEW_LINE GFG . dfs ( 1 , 1 ) NEW_LINE if not GFG . bip : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if GFG . colour [ GFG . edges [ i ] . first ] == 0 : NEW_LINE INDENT GFG . edges [ i ] . first , GFG . edges [ i ] . second = GFG . edges [ i ] . second , GFG . edges [ i ] . first NEW_LINE DEDENT print ( GFG . edges [ i ] . first , GFG . edges [ i ] . second ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT n , m = 4 , 3 NEW_LINE for i in range ( GFG . N ) : NEW_LINE INDENT GFG . gr [ i ] = [ ] NEW_LINE DEDENT GFG . add_edge ( 1 , 2 ) NEW_LINE GFG . add_edge ( 1 , 3 ) NEW_LINE GFG . add_edge ( 1 , 4 ) NEW_LINE GFG . Directed_Graph ( n , m ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE n = int ( input ( ) . strip ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE odd = False NEW_LINE even = False NEW_LINE ans = [ ] NEW_LINE for num in arr : NEW_LINE INDENT if num % 2 == 0 : NEW_LINE INDENT even = True NEW_LINE DEDENT else : NEW_LINE INDENT odd = True NEW_LINE DEDENT ans . append ( num ) NEW_LINE DEDENT if odd and even : NEW_LINE INDENT ans . sort ( ) NEW_LINE DEDENT for num in ans : NEW_LINE INDENT print ( num ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT o , g , x = 0 , 0 , 0 NEW_LINE n , borrow = 0 , 0 NEW_LINE o = int ( input ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE g = int ( input ( ) ) NEW_LINE for i in range ( 1 , g + 1 ) : NEW_LINE INDENT x = x + i * o NEW_LINE DEDENT borrow = x - n NEW_LINE if borrow <= 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( borrow ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
def isPrime ( k ) : NEW_LINE INDENT if k <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , k ) : NEW_LINE INDENT if k % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if num % i == 0 : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT if num % k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findCount ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE if not isPrime ( k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT ans = check ( i , k ) NEW_LINE if ans == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT a = 2020 NEW_LINE b = 6300 NEW_LINE k = 29 NEW_LINE print ( findCount ( a , b , k ) ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE class Main : NEW_LINE INDENT a = [ ] NEW_LINE l = [ ] NEW_LINE ans = [ ] NEW_LINE map = { } NEW_LINE @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE str_list = [ 0 if i % 2 == 0 else 1 for i in range ( n - k + 2 ) ] NEW_LINE j = 2 NEW_LINE for i in range ( n - k + 2 , n ) : NEW_LINE INDENT str_list . append ( j ) NEW_LINE j += 1 NEW_LINE DEDENT for char in str_list : NEW_LINE INDENT sys . stdout . write ( chr ( char + 97 ) ) NEW_LINE DEDENT sys . stdout . flush ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT maxn = 16 NEW_LINE @ staticmethod NEW_LINE def precompute ( ) : NEW_LINE INDENT dp = [ - 1 ] * GFG . maxn NEW_LINE arr = [ 4 , 6 , 9 ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , GFG . maxn ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT j = arr [ k ] NEW_LINE if i >= j and dp [ i - j ] != - 1 : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp NEW_LINE DEDENT @ staticmethod NEW_LINE def Maximum_Summands ( dp , n ) : NEW_LINE INDENT if n < GFG . maxn : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT t = ( n - GFG . maxn ) // 4 + 1 NEW_LINE return t + dp [ n - 4 * t ] NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT n = 12 NEW_LINE dp = GFG . precompute ( ) NEW_LINE print ( GFG . Maximum_Summands ( dp , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
def countSquares ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) // 2 ) * ( 2 * n + 1 ) // 3 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( " Count ▁ of ▁ squares ▁ is " , countSquares ( n ) ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum [ i ] = a [ i ] + sum [ i - 1 ] NEW_LINE DEDENT map = defaultdict ( int ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT map [ sum [ i ] % m ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = map [ sum [ i ] % m ] NEW_LINE map [ sum [ i ] % m ] = x + 1 NEW_LINE DEDENT ans = 0 NEW_LINE if 0 in map : NEW_LINE INDENT ans = map [ 0 ] NEW_LINE DEDENT for i in map : NEW_LINE INDENT if map [ i ] >= 2 : NEW_LINE INDENT for j in range ( map [ i ] , 1 , - 1 ) : NEW_LINE INDENT ans += j - 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT class Pair : NEW_LINE INDENT def __init__ ( self , from_ , end , num , bango ) : NEW_LINE INDENT self . from_ = from_ NEW_LINE self . end = end NEW_LINE self . num = num NEW_LINE self . bango = bango NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return self . from_ < other . from_ NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def FindSubarray ( arr , n , k ) : NEW_LINE INDENT count_one = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_one [ i ] = bin ( arr [ i ] ) . count ( '1' ) NEW_LINE DEDENT sum = count_one [ 0 ] NEW_LINE if n == 1 : NEW_LINE INDENT if count_one [ 0 ] >= k : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT ans = float ( ' inf ' ) NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while i < n : NEW_LINE INDENT if k == count_one [ j ] : NEW_LINE INDENT ans = 1 NEW_LINE break NEW_LINE DEDENT elif k == count_one [ i ] : NEW_LINE INDENT ans = 1 NEW_LINE break NEW_LINE DEDENT elif sum + count_one [ i ] < k : NEW_LINE INDENT sum += count_one [ i ] NEW_LINE i += 1 NEW_LINE DEDENT elif sum + count_one [ i ] > k : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) NEW_LINE sum -= count_one [ j ] NEW_LINE j += 1 NEW_LINE DEDENT elif sum + count_one [ i ] == k : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) NEW_LINE sum += count_one [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if ans != float ( ' inf ' ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( FindSubarray ( arr , n , k ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) NEW_LINE print ( " Loss ▁ = ▁ { : . 3f } " . format ( loss ) ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT SP = 2400 NEW_LINE P = 30 NEW_LINE GFG . Loss ( SP , P ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n , m , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a [ int ( input ( ) ) ] = 1 NEW_LINE DEDENT ans1 , ans2 = 0 , 0 NEW_LINE for i in range ( x , 0 , - 1 ) : NEW_LINE INDENT ans1 += a [ i ] NEW_LINE DEDENT for i in range ( x , n ) : NEW_LINE INDENT ans2 += a [ i ] NEW_LINE DEDENT print ( min ( ans1 , ans2 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE n = int ( input ( ) ) NEW_LINE sushi = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE len = 1 NEW_LINE prev = 0 NEW_LINE oneSeq = 0 NEW_LINE twoSeq = 0 NEW_LINE for x in sushi : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT if prev == 1 : NEW_LINE INDENT oneSeq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT oneSeq = 1 NEW_LINE DEDENT prev = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if prev == 2 : NEW_LINE INDENT twoSeq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT twoSeq = 1 NEW_LINE DEDENT prev = 2 NEW_LINE DEDENT if min ( oneSeq , twoSeq ) > len : NEW_LINE INDENT len = min ( oneSeq , twoSeq ) NEW_LINE DEDENT DEDENT print ( len * 2 ) NEW_LINE ` ` ` NEW_LINE
class p092 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT LIMIT = pow ( 10 , 7 ) NEW_LINE def run ( self ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , self . LIMIT ) : NEW_LINE INDENT if self . isClass89 ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT def isClass89 ( self , x ) : NEW_LINE INDENT while True : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT elif x == 89 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT x = self . nextNumber ( x ) NEW_LINE DEDENT DEDENT DEDENT def nextNumber ( self , x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += ( x % 10 ) * ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT p = p092 ( ) NEW_LINE p . main ( [ ] ) NEW_LINE
` ` ` python NEW_LINE def fact ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def countStrings ( s , n ) : NEW_LINE INDENT distinct_char = set ( s ) NEW_LINE return fact ( len ( distinct_char ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE n = len ( s ) NEW_LINE print ( countStrings ( s , n ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import numpy as np NEW_LINE def printCommonElements ( mat ) : NEW_LINE INDENT M = 4 NEW_LINE N = 5 NEW_LINE mp = { } NEW_LINE for j in range ( N ) : NEW_LINE INDENT mp [ mat [ 0 ] [ j ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if mat [ i ] [ j ] in mp and mp [ mat [ i ] [ j ] ] == i : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if i == M - 1 : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT mat = np . array ( [ [ 1 , 2 , 1 , 4 , 8 ] , [ 3 , 7 , 8 , 5 , 1 ] , [ 8 , 7 , 7 , 3 , 1 ] , [ 8 , 1 , 2 , 7 , 9 ] ] ) NEW_LINE printCommonElements ( mat ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE class Pair : NEW_LINE INDENT def __init__ ( self , i , a , b ) : NEW_LINE INDENT self . x1 = a NEW_LINE self . x2 = b NEW_LINE self . id = i NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return self . x1 < other . x1 NEW_LINE DEDENT DEDENT eps = 10e-9 NEW_LINE n = int ( input ( ) ) NEW_LINE start , end = map ( float , input ( ) . split ( ) ) NEW_LINE first = [ ] NEW_LINE second = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( float , input ( ) . split ( ) ) NEW_LINE y1 = a * ( start + eps ) + b NEW_LINE y2 = a * ( end - eps ) + b NEW_LINE first . append ( Pair ( i + 1 , y1 , y2 ) ) NEW_LINE second . append ( Pair ( i + 1 , y2 , y1 ) ) NEW_LINE DEDENT first . sort ( ) NEW_LINE second . sort ( ) NEW_LINE for i in range ( len ( first ) ) : NEW_LINE INDENT if first [ i ] . id != second [ i ] . id : NEW_LINE INDENT print ( " YES " ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n , t = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE d = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s_i , d_i = map ( int , input ( ) . split ( ) ) NEW_LINE s . append ( s_i ) NEW_LINE d . append ( d_i ) NEW_LINE DEDENT print ( solve ( s , d , t ) ) NEW_LINE DEDENT def solve ( s , d , t ) : NEW_LINE INDENT minTime = float ( ' inf ' ) NEW_LINE result = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT time = divideToCeil ( t - s [ i ] , d [ i ] ) * d [ i ] + s [ i ] NEW_LINE if time < minTime : NEW_LINE INDENT minTime = time NEW_LINE result = i + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def divideToCeil ( x , y ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return x // y + ( 0 if x % y == 0 else 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + a NEW_LINE a = a + d NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( self . sumOfAP ( a , d , n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def find3Numbers ( arr , n ) : NEW_LINE INDENT small = 2147483647 NEW_LINE large = 2147483647 NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] <= small : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif arr [ i ] <= large : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == n : NEW_LINE INDENT print ( " No ▁ such ▁ triplet ▁ found " ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 ) : NEW_LINE INDENT if arr [ j ] < large : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small , large , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT def main ( arg ) : NEW_LINE INDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE GFG . find3Numbers ( arr , n ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT print ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : " ) NEW_LINE for i in range ( int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT print ( i * i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 96 NEW_LINE numbersWith3Divisors ( n ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def findPairCount ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE rem = [ 0 ] * K NEW_LINE rem [ 0 ] = N // K NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem [ i ] = ( N - i ) // K + 1 NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT count += ( rem [ K // 2 ] * ( rem [ K // 2 ] - 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 NEW_LINE for i in range ( 1 , ( K // 2 ) + 1 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT N = 10 NEW_LINE K = 4 NEW_LINE print ( GFG . findPairCount ( N , K ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE while n != 0 and m != 0 : NEW_LINE INDENT array = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE array . sort ( ) NEW_LINE interval = 0 NEW_LINE nt = 0 NEW_LINE for time in array : NEW_LINE INDENT if time - nt > interval : NEW_LINE INDENT interval = time - nt NEW_LINE DEDENT nt = time NEW_LINE DEDENT print ( interval ) NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def solve ( a ) : NEW_LINE INDENT total_sum = sum ( a ) NEW_LINE max_num = max ( a ) NEW_LINE return total_sum % 2 == 0 and max_num * 2 <= total_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( " YES " if solve ( a ) else " NO " ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT PHI = 1.6180339 NEW_LINE f = [ 0 , 1 , 1 , 2 , 3 , 5 ] NEW_LINE @ staticmethod NEW_LINE def fib ( n ) : NEW_LINE INDENT if n < 6 : NEW_LINE INDENT return GFG . f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = round ( fn * GFG . PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 9 NEW_LINE print ( str ( n ) + " th ▁ Fibonacci ▁ Number ▁ = ▁ " + str ( GFG . fib ( n ) ) ) NEW_LINE DEDENT DEDENT
def kthSmallest ( n , k ) : NEW_LINE INDENT return ( 2 * k ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE k = 4 NEW_LINE print ( kthSmallest ( n , k ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT n = 5 NEW_LINE @ staticmethod NEW_LINE def printSumTricky ( mat , k ) : NEW_LINE INDENT if k > GFG . n : NEW_LINE INDENT return NEW_LINE DEDENT stripSum = [ [ 0 for i in range ( GFG . n ) ] for j in range ( GFG . n ) ] NEW_LINE for j in range ( GFG . n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT stripSum [ 0 ] [ j ] = sum NEW_LINE for i in range ( 1 , GFG . n - k + 1 ) : NEW_LINE INDENT sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) NEW_LINE stripSum [ i ] [ j ] = sum NEW_LINE DEDENT DEDENT for i in range ( GFG . n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT sum += stripSum [ i ] [ j ] NEW_LINE print ( sum , end = " ▁ " ) NEW_LINE DEDENT for j in range ( 1 , GFG . n - k + 1 ) : NEW_LINE INDENT sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) NEW_LINE print ( sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE GFG . printSumTricky ( mat , k ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
from math import pow NEW_LINE def main ( ) : NEW_LINE INDENT A = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE for x in range ( - 1000 , 1001 ) : NEW_LINE INDENT if pow ( x , N ) * A == B : NEW_LINE INDENT print ( x ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def ncr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT def totalWays ( X , Y , M , W ) : NEW_LINE INDENT return ( ncr ( M , X ) * ncr ( W , Y ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X , Y , M , W = 4 , 3 , 6 , 5 NEW_LINE print ( totalWays ( X , Y , M , W ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if n != 0 and ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT def removeElement ( n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = GFG . nextPowerOf2 ( n ) NEW_LINE if n == a or n == a - 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n == a - 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( removeElement ( n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class NumTh : NEW_LINE INDENT @ staticmethod NEW_LINE def choose ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n , n - k , - 1 ) : NEW_LINE INDENT res *= i NEW_LINE res //= k - n + i NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , P = map ( int , input ( ) . split ( ) ) NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A = int ( input ( ) ) NEW_LINE if A % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if odd == 0 : NEW_LINE INDENT if P == 0 : NEW_LINE INDENT print ( ( 1 << even ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ( 1 << ( N - 1 ) ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( a * x ) % m == 1 : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , m = 3 , 11 NEW_LINE print ( GFG . modInverse ( a , m ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if i % 2 == 0 and GFG . sumOfDigits ( i ) % 3 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , r = 1000 , 6000 NEW_LINE print ( GFG . countNumbers ( l , r ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
def findGreater ( a , b ) : NEW_LINE INDENT x = float ( a ) * float ( math . log ( float ( b ) ) ) NEW_LINE y = float ( b ) * float ( math . log ( float ( a ) ) ) NEW_LINE if y > x : NEW_LINE INDENT print ( " a ^ b ▁ is ▁ greater " ) NEW_LINE DEDENT elif y < x : NEW_LINE INDENT print ( " b ^ a ▁ is ▁ greater " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Both ▁ are ▁ equal " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT import math NEW_LINE a , b , c , d = 3 , 5 , 2 , 4 NEW_LINE findGreater ( a , b ) NEW_LINE findGreater ( c , d ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def findAnswer ( str1 , str2 , n ) : NEW_LINE INDENT l , r = 0 , 0 NEW_LINE ans = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT l = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT if r < l : NEW_LINE INDENT return 26 * ( n + 1 ) NEW_LINE DEDENT elif l == r : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i - 1 ] : NEW_LINE INDENT ans -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if str1 [ i - 1 ] != str2 [ i ] : NEW_LINE INDENT ans -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT str1 = " toy " NEW_LINE str2 = " try " NEW_LINE n = len ( str1 ) NEW_LINE print ( GFG . findAnswer ( str1 , str2 , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE result = [ ] NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , x , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = [ ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT arr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT si = x NEW_LINE ei = x NEW_LINE for i in range ( m ) : NEW_LINE INDENT l = arr [ i ] [ 0 ] NEW_LINE r = arr [ i ] [ 1 ] NEW_LINE if ( l <= si <= r ) or ( l <= ei <= r ) : NEW_LINE INDENT si = min ( l , si ) NEW_LINE ei = max ( r , ei ) NEW_LINE DEDENT DEDENT result . append ( str ( ei - si + 1 ) ) NEW_LINE DEDENT print ( " \n " . join ( result ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def bitsAreInAltPatrnInGivenTRange ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) NEW_LINE prev = num & 1 NEW_LINE num = num >> 1 NEW_LINE for i in range ( 1 , ( r - l ) ) : NEW_LINE INDENT curr = num & 1 NEW_LINE if curr == prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE num = num >> 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if GFG . bitsAreInAltPatrnInGivenTRange ( n , l , r ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = " " NEW_LINE o = arr . count ( 1 ) NEW_LINE e = n - o NEW_LINE for _ in range ( k ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if ( r - l + 1 ) % 2 == 1 : NEW_LINE INDENT res += "0 \n " NEW_LINE DEDENT else : NEW_LINE INDENT if ( r - l + 1 ) // 2 <= o and ( r - l + 1 ) // 2 <= e : NEW_LINE INDENT res += "1 \n " NEW_LINE DEDENT else : NEW_LINE INDENT res += "0 \n " NEW_LINE DEDENT DEDENT DEDENT sys . stdout . write ( res ) NEW_LINE
import math NEW_LINE def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * int ( math . pow ( n , 2 ) ) + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE magic_square = [ [ 0 for _ in range ( n ) ] for _ in range ( n ) ] NEW_LINE row , column = - 1 , - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT magic_square [ i ] [ j ] = int ( input ( ) ) NEW_LINE if magic_square [ i ] [ j ] == 0 : NEW_LINE INDENT row = i NEW_LINE column = j NEW_LINE DEDENT DEDENT DEDENT if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT sum_val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if row != 0 : NEW_LINE INDENT sum_val += magic_square [ 0 ] [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum_val += magic_square [ 1 ] [ i ] NEW_LINE DEDENT DEDENT answer = sum_val NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer -= magic_square [ row ] [ i ] NEW_LINE DEDENT magic_square [ row ] [ column ] = answer NEW_LINE m = 0 NEW_LINE current_sumi = 0 NEW_LINE current_sumj = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT current_sumi += magic_square [ i ] [ j ] NEW_LINE current_sumj += magic_square [ j ] [ i ] NEW_LINE DEDENT if current_sumi != sum_val or current_sumj != sum_val : NEW_LINE INDENT m += 1 NEW_LINE DEDENT current_sumi = 0 NEW_LINE current_sumj = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT current_sumi += magic_square [ i ] [ i ] NEW_LINE current_sumj += magic_square [ n - i - 1 ] [ i ] NEW_LINE DEDENT if current_sumi != sum_val or current_sumj != sum_val : NEW_LINE INDENT m += 1 NEW_LINE DEDENT if m == 0 and answer > 0 : NEW_LINE INDENT print ( answer ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java . util . * ; NEW_LINE public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i + + ) { arr [ i ] = sc . nextInt ( ) ; sum1 = sum1 + arr [ i ] ; } for ( int i = 1 ; i < n ; i + + ) { int csum = 0 ; csum = arr [ i ] + arr [ i - 1 ] ; if ( k > csum ) { arr [ i ] = arr [ i ] + k - csum ; } } for ( int i = 0 ; i < n ; i + + ) { sum2 = sum2 + arr [ i ] ; } System . out . println ( sum2 - sum1 ) ; for ( int i = 0 ; i < n ; i + + ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; } static boolean isPrime ( long n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 | | n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 | | n % ( i + 2 ) == 0 ) return false ; } return true ; } static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static long lcm ( long a , long b ) { return ( a / gcd ( a , b ) ) * b ; } } NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT MAX = 1000000 NEW_LINE @ staticmethod NEW_LINE def maximumOccurredElement ( L , R , n ) : NEW_LINE INDENT arr = [ 0 ] * GFG . MAX NEW_LINE maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ L [ i ] ] += 1 NEW_LINE arr [ R [ i ] + 1 ] -= 1 NEW_LINE if R [ i ] > maxi : NEW_LINE INDENT maxi = R [ i ] NEW_LINE DEDENT DEDENT msum = arr [ 0 ] NEW_LINE ind = 0 NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE if msum < arr [ i ] : NEW_LINE INDENT msum = arr [ i ] NEW_LINE ind = i NEW_LINE DEDENT DEDENT return ind NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT L = [ 1 , 4 , 9 , 13 , 21 ] NEW_LINE R = [ 15 , 8 , 12 , 20 , 30 ] NEW_LINE n = len ( L ) NEW_LINE print ( GFG . maximumOccurredElement ( L , R , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] != arr [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT if m != 0 : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0 ▁ 0" ) NEW_LINE DEDENT return NEW_LINE DEDENT if m <= n : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT m = 1 NEW_LINE DEDENT print ( n , m + n - 1 ) NEW_LINE return NEW_LINE DEDENT print ( m , m + n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from typing import List NEW_LINE def func ( x : float ) -> float : NEW_LINE INDENT return ( 1 / ( 1 + x * x ) ) NEW_LINE DEDENT def calculate ( lower_limit : float , upper_limit : float , interval_limit : int ) -> float : NEW_LINE INDENT value : float NEW_LINE interval_size : float = ( upper_limit - lower_limit ) / interval_limit NEW_LINE sum : float = func ( lower_limit ) + func ( upper_limit ) NEW_LINE for i in range ( 1 , interval_limit ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT sum = sum + 2 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + 3 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT DEDENT return ( 3 * interval_size / 8 ) * sum NEW_LINE DEDENT def main ( args : List [ str ] ) -> None : NEW_LINE INDENT interval_limit : int = 10 NEW_LINE lower_limit : float = 1 NEW_LINE upper_limit : float = 10 NEW_LINE integral_res : float = calculate ( lower_limit , upper_limit , interval_limit ) NEW_LINE print ( " { : . 4f } " . format ( integral_res ) ) NEW_LINE DEDENT
import sys NEW_LINE class Main : NEW_LINE INDENT def run ( self ) : NEW_LINE INDENT n , k , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE sum = 0 NEW_LINE if n > k : NEW_LINE INDENT sum += x * k NEW_LINE sum += y * ( n - k ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += x * n NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE while True : NEW_LINE INDENT x , h = map ( float , input ( ) . split ( ) ) NEW_LINE if x == 0 and h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT c = math . sqrt ( h * h + ( x / 2 ) * ( x / 2 ) ) NEW_LINE ans = x * x + x * c / 2 * 4 NEW_LINE print ( ans ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def count ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE while num > 0 : NEW_LINE INDENT sum += num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT k = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE mo = 19 NEW_LINE while i != k : NEW_LINE INDENT mo += 1 NEW_LINE if 10 == count ( mo ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( mo ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE MAX = 1000000 NEW_LINE prime = [ True ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT global prime NEW_LINE prime = [ True ] * MAX NEW_LINE for p in range ( 2 , int ( math . sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] : NEW_LINE INDENT print ( i , i + 2 , i + 6 , i + 8 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 20 NEW_LINE sieve ( ) NEW_LINE printPrimeQuad ( n ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT MAX = 1000 NEW_LINE @ staticmethod NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( GFG . MAX ) ] for j in range ( GFG . MAX ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if x [ j - 1 ] == y [ i - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT x = list ( " ABCD " ) NEW_LINE y = list ( " BACDBDCD " ) NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE print ( GFG . maxSubsequenceSubstring ( x , y , n , m ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % a == 0 or i % b == 0 : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( self . findSum ( n , a , b ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE a = [ 0 ] * 123 NEW_LINE b = [ 0 ] * len ( s1 ) NEW_LINE y = 0 NEW_LINE w = 0 NEW_LINE for i in range ( len ( s2 ) ) : NEW_LINE INDENT a [ ord ( s2 [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT ch = s1 [ i ] NEW_LINE if a [ ord ( ch ) ] >= 1 : NEW_LINE INDENT a [ ord ( ch ) ] -= 1 NEW_LINE b [ i ] = 1 NEW_LINE y += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT ch = s1 [ i ] NEW_LINE if b [ i ] == 0 : NEW_LINE INDENT if ch <= ' Z ' : NEW_LINE INDENT ch = chr ( ord ( ch ) + 32 ) NEW_LINE DEDENT else : NEW_LINE INDENT ch = chr ( ord ( ch ) - 32 ) NEW_LINE DEDENT if a [ ord ( ch ) ] >= 1 : NEW_LINE INDENT a [ ord ( ch ) ] -= 1 NEW_LINE w += 1 NEW_LINE DEDENT DEDENT DEDENT print ( y , w ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
MAX = 1000 NEW_LINE sequence = [ 0 ] * MAX NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if sequence [ j ] == sequence [ i ] : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT vanEckSequence ( ) NEW_LINE n = 6 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
MAX = 100000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if sequence [ j ] == sequence [ i ] : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT count = 1 NEW_LINE i = n - 1 NEW_LINE while sequence [ i + 1 ] != 0 : NEW_LINE INDENT count += 1 NEW_LINE i = i - sequence [ i + 1 ] NEW_LINE DEDENT return count NEW_LINE DEDENT vanEckSequence ( ) NEW_LINE n = 5 NEW_LINE print ( getCount ( n ) ) NEW_LINE n = 11 NEW_LINE print ( getCount ( n ) ) NEW_LINE
MAX = 100000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if sequence [ j ] == sequence [ i ] : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT nthTerm = sequence [ n - 1 ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if sequence [ i ] == nthTerm : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT vanEckSequence ( ) NEW_LINE n = 5 NEW_LINE print ( getCount ( n ) ) NEW_LINE n = 11 NEW_LINE print ( getCount ( n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def __gcd ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) // __gcd ( a , b ) NEW_LINE l = 1 NEW_LINE r = min ( a , b ) * n NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE val = mid // a + mid // b - mid // lcm NEW_LINE if val == n : NEW_LINE INDENT return max ( ( mid // a ) * a , ( mid // b ) * b ) NEW_LINE DEDENT if val < n : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from datetime import datetime NEW_LINE def check_leap ( y ) : NEW_LINE INDENT return y % 400 == 0 or ( y % 4 == 0 and y % 100 != 0 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT y = int ( input ( ) ) NEW_LINE leap = check_leap ( y ) NEW_LINE sum = 0 NEW_LINE mod = 0 NEW_LINE for i in range ( y + 1 , y + 10000 ) : NEW_LINE INDENT if check_leap ( i ) : NEW_LINE INDENT sum += 366 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 365 NEW_LINE DEDENT if sum % 7 == 0 : NEW_LINE INDENT if ( check_leap ( i ) and leap ) or ( not check_leap ( i ) and not leap ) : NEW_LINE INDENT print ( i ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from collections import deque NEW_LINE n = 0 NEW_LINE sc = input NEW_LINE events = deque ( ) NEW_LINE def read ( ) : NEW_LINE INDENT global events NEW_LINE cnt = 0 NEW_LINE events = deque ( ) NEW_LINE while cnt < 3 : NEW_LINE INDENT event = sc ( ) NEW_LINE if event == " OUT " : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT events . append ( event ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT ans = 0 NEW_LINE s = 0 NEW_LINE while events : NEW_LINE INDENT e = events . popleft ( ) NEW_LINE s = ( s << 1 ) + 1 NEW_LINE if e == " HIT " : NEW_LINE INDENT if ( s & 8 ) > 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT s = ( s & 7 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , 16 ) : NEW_LINE INDENT if ( s & i ) >= 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = int ( sc ( ) ) NEW_LINE while n > 0 and read ( ) : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE n -= 1 NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def find_value ( x , y , z ) : NEW_LINE INDENT g = gcd ( y , z ) NEW_LINE return ( x * g ) // gcd ( x , g ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x , y , z = 30 , 40 , 400 NEW_LINE print ( find_value ( x , y , z ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT @ staticmethod NEW_LINE def foot ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) NEW_LINE x2 = a * k + x1 NEW_LINE y2 = b * k + y1 NEW_LINE z2 = c * k + z1 NEW_LINE print ( " x2 ▁ = ▁ { : . 1f } " . format ( x2 ) , end = " " ) NEW_LINE print ( " ▁ y2 ▁ = ▁ { : . 1f } " . format ( y2 ) , end = " " ) NEW_LINE print ( " ▁ z2 ▁ = ▁ { : . 1f } " . format ( z2 ) ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT a = 1 NEW_LINE b = - 2 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE x1 = - 1 NEW_LINE y1 = 3 NEW_LINE z1 = 4 NEW_LINE Solution . foot ( a , b , c , d , x1 , y1 , z1 ) NEW_LINE DEDENT DEDENT Solution . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE c1 = input ( ) NEW_LINE c2 = input ( ) NEW_LINE if c1 [ 0 ] == c2 [ - 1 ] and c2 [ 0 ] == c1 [ - 1 ] and c1 [ 1 ] == c2 [ 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT ` ` ` NEW_LINE
import numpy as np NEW_LINE def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE large = max ( ar ) NEW_LINE dp = np . zeros ( ( n , large + 1 ) ) NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = float ( ' inf ' ) NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = float ( ' inf ' ) NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE print ( getMinimumOps ( arr ) ) NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE class GFG : NEW_LINE INDENT PI = 3.14159265 NEW_LINE def area_leaf ( a ) : NEW_LINE INDENT return ( a * a * ( GFG . PI / 2 - 1 ) ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = 7 NEW_LINE print ( GFG . area_leaf ( a ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
def removeAlternate ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return 2 * removeAlternate ( n // 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( n - 1 ) // 2 ) + 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( " \n " + str ( removeAlternate ( n ) ) ) NEW_LINE DEDENT
import java NEW_LINE def check ( n , m ) : NEW_LINE INDENT if n == 2 or m == 2 or n % m == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT m = 3 NEW_LINE n = 9 NEW_LINE check ( n , m ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def solve ( m , n , k , colors ) : NEW_LINE INDENT sum = 0 NEW_LINE for color in colors : NEW_LINE INDENT sum += color NEW_LINE DEDENT flag = check ( m , n , colors ) or check ( n , m , colors ) NEW_LINE print ( " Yes " if flag else " No " ) NEW_LINE DEDENT def check ( m , n , colors ) : NEW_LINE INDENT count = 0 NEW_LINE color_set = set ( ) NEW_LINE for color in colors : NEW_LINE INDENT max_val = color // m NEW_LINE if max_val >= 2 : NEW_LINE INDENT count += max_val NEW_LINE color_set . add ( max_val ) NEW_LINE DEDENT DEDENT if count < n : NEW_LINE INDENT return False NEW_LINE DEDENT if len ( color_set ) >= 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( color_set ) == 1 : NEW_LINE INDENT if 2 in color_set : NEW_LINE INDENT return n % 2 == 0 NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT m , n , k = map ( int , input ( ) . split ( ) ) NEW_LINE colors = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE solve ( m , n , k , colors ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if arr [ i ] == 1 : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return positive * negative NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( negProdSubArr ( arr , n ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if arr [ i ] == 1 : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return positive * negative NEW_LINE DEDENT def posProdSubArr ( arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) / 2 NEW_LINE cntNeg = GFG . negProdSubArr ( arr , n ) NEW_LINE return total - cntNeg NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . posProdSubArr ( arr , n ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE class CF3 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin . readline NEW_LINE self . tok = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . tok : NEW_LINE INDENT self . tok = self . input ( ) . split ( ) NEW_LINE DEDENT res = self . tok [ 0 ] NEW_LINE self . tok = None NEW_LINE return res NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT return self . input ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT in_ = CF3 ( ) NEW_LINE t = in_ . nextInt ( ) NEW_LINE while t > 0 : NEW_LINE INDENT n = in_ . nextLong ( ) NEW_LINE k = in_ . nextLong ( ) NEW_LINE sum_ = 0 NEW_LINE cur = 1 NEW_LINE while cur < k : NEW_LINE INDENT cur *= 2 NEW_LINE sum_ += 1 NEW_LINE DEDENT if cur < n : NEW_LINE INDENT sum_ += ( n - cur + k - 1 ) // k NEW_LINE DEDENT print ( sum_ ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT z = sys . stdin . readline ( ) . split ( ) NEW_LINE x , y , a , b = map ( int , z ) NEW_LINE c = 0 NEW_LINE lcm = x * y // gcd ( x , y ) NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if i % lcm == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( b , a - 1 , - 1 ) : NEW_LINE INDENT if j % lcm == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j % lcm == 0 and i % lcm == 0 : NEW_LINE INDENT c = ( j - i ) // lcm + 1 NEW_LINE DEDENT sys . stdout . write ( str ( c ) + " \n " ) NEW_LINE DEDENT ` ` ` NEW_LINE
class Main : NEW_LINE INDENT def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 1 ] * n NEW_LINE len = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return n - len NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE from collections import deque NEW_LINE def print_max ( a , n , k ) : NEW_LINE INDENT max_upto = [ 0 ] * n NEW_LINE s = deque ( ) NEW_LINE s . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while s and a [ s [ - 1 ] ] < a [ i ] : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = i - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT while s : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = n - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT while j < i or max_upto [ j ] < i + k - 1 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print ( a [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 9 , 7 , 2 , 4 , 6 , 8 , 2 , 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print_max ( a , n , k ) NEW_LINE DEDENT ` ` ` NEW_LINE
from math import pow NEW_LINE class p056 : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT max_val = 0 NEW_LINE for a in range ( 1 , 100 ) : NEW_LINE INDENT for b in range ( 1 , 100 ) : NEW_LINE INDENT pow_val = pow ( a , b ) NEW_LINE max_val = max ( self . digit_sum ( pow_val ) , max_val ) NEW_LINE DEDENT DEDENT return str ( max_val ) NEW_LINE DEDENT def digit_sum ( self , n ) : NEW_LINE INDENT return sum ( int ( digit ) for digit in str ( n ) ) NEW_LINE DEDENT DEDENT p = p056 ( ) NEW_LINE p . main ( ) NEW_LINE
` ` ` python NEW_LINE class Test : NEW_LINE INDENT @ staticmethod NEW_LINE def countWindowDistinct ( win , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if win [ i ] == win [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == i : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT DEDENT return dist_count NEW_LINE DEDENT @ staticmethod NEW_LINE def countDistinct ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT print ( Test . countWindowDistinct ( arr [ i : i + k ] , k ) ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 , 3 ] NEW_LINE k = 4 NEW_LINE Test . countDistinct ( arr , len ( arr ) , k ) NEW_LINE DEDENT DEDENT Test . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def evenNumSubstring ( str ) : NEW_LINE INDENT len = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( len ) : NEW_LINE INDENT temp = int ( str [ i ] ) NEW_LINE if temp % 2 == 0 : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "1234" NEW_LINE print ( evenNumSubstring ( str ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class solution : NEW_LINE INDENT max = 4 NEW_LINE @ staticmethod NEW_LINE def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if index == n : NEW_LINE INDENT if cnt == k : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if dp [ index ] [ cnt ] != - 1 : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += solution . countWays ( index + 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * solution . countWays ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE dp [ index ] [ cnt ] = ans NEW_LINE return dp [ index ] [ cnt ] NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE k = 2 NEW_LINE dp = [ [ - 1 for _ in range ( solution . max ) ] for _ in range ( n + 1 ) ] NEW_LINE print ( m * solution . countWays ( 1 , 0 , dp , n , m , k ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import math NEW_LINE def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT sum += i NEW_LINE DEDENT else : NEW_LINE INDENT sum += i NEW_LINE sum += n / i NEW_LINE DEDENT DEDENT DEDENT return int ( sum - n ) NEW_LINE DEDENT def printAliquot ( n ) : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE s = set ( ) NEW_LINE s . add ( n ) NEW_LINE next = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n = getSum ( n ) NEW_LINE if n in s and n != max ( s ) : NEW_LINE INDENT print ( " \n Repeats ▁ with " , n , end = " " ) NEW_LINE break NEW_LINE DEDENT print ( n , end = " ▁ " ) NEW_LINE s . add ( n ) NEW_LINE DEDENT DEDENT printAliquot ( 12 ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE dims = input ( ) . split ( ) NEW_LINE total = int ( dims [ 0 ] ) NEW_LINE at = int ( dims [ 1 ] ) NEW_LINE pt = int ( dims [ 2 ] ) NEW_LINE vals = [ False ] * total NEW_LINE as_input = input ( ) . split ( ) NEW_LINE for a in as_input : NEW_LINE INDENT x = int ( a ) NEW_LINE vals [ x - 1 ] = True NEW_LINE DEDENT output = " " NEW_LINE for val in vals : NEW_LINE INDENT output += "1 ▁ " if val else "2 ▁ " NEW_LINE DEDENT print ( output ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT arr [ i ] , arr [ n - i - 1 ] = arr [ n - i - 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE a = 1 NEW_LINE cnt = 0 NEW_LINE flag = True NEW_LINE sum += a NEW_LINE while cnt < N : NEW_LINE INDENT if flag == True : NEW_LINE INDENT nextElement = a * 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * 3 / 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT a = nextElement NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT N = 8 NEW_LINE GFG . printSeriesSum ( N ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE gcd_val = gcd ( h , w ) NEW_LINE h //= gcd_val NEW_LINE w //= gcd_val NEW_LINE if h == w : NEW_LINE INDENT print ( "1 ▁ 0" ) NEW_LINE DEDENT elif h % 2 == 0 or w % 2 == 0 : NEW_LINE INDENT print ( "1 ▁ 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT a = ( h * w ) // 2 + 1 NEW_LINE b = ( h * w ) // 2 NEW_LINE print ( a , b ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE sz = int ( 1e5 ) NEW_LINE isPrime = [ True ] * ( sz + 1 ) NEW_LINE def sieve ( ) : NEW_LINE INDENT global isPrime NEW_LINE isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( math . sqrt ( sz ) ) + 1 ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT for j in range ( i * i , sz + 1 , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def minDifference ( L , R ) : NEW_LINE INDENT global isPrime NEW_LINE fst = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT fst = i NEW_LINE break NEW_LINE DEDENT DEDENT snd = 0 NEW_LINE for i in range ( fst + 1 , R + 1 ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT snd = i NEW_LINE break NEW_LINE DEDENT DEDENT if snd == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT diff = snd - fst NEW_LINE left = snd + 1 NEW_LINE right = R NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT if i - snd <= diff : NEW_LINE INDENT fst = snd NEW_LINE snd = i NEW_LINE diff = snd - fst NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT sieve ( ) NEW_LINE L = 21 NEW_LINE R = 50 NEW_LINE print ( minDifference ( L , R ) ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def getMaxLength ( arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE preCnt = 0 NEW_LINE while start < n and arr [ start ] == 1 : NEW_LINE INDENT preCnt += 1 NEW_LINE start += 1 NEW_LINE DEDENT end = n - 1 NEW_LINE suffCnt = 0 NEW_LINE while end >= 0 and arr [ end ] == 1 : NEW_LINE INDENT suffCnt += 1 NEW_LINE end -= 1 NEW_LINE DEDENT if start > end : NEW_LINE INDENT return n NEW_LINE DEDENT midCnt = 0 NEW_LINE result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT midCnt += 1 NEW_LINE result = max ( result , midCnt ) NEW_LINE DEDENT else : NEW_LINE INDENT midCnt = 0 NEW_LINE DEDENT DEDENT return max ( result , preCnt + suffCnt ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMaxLength ( arr , n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT d , n = map ( int , input ( ) . split ( ) ) NEW_LINE temp = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE c = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a_i , b_i , c_i = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( a_i ) NEW_LINE b . append ( b_i ) NEW_LINE c . append ( c_i ) NEW_LINE DEDENT dp = [ [ - 1 for _ in range ( n ) ] for _ in range ( d ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= temp [ 0 ] and b [ i ] >= temp [ 0 ] : NEW_LINE INDENT dp [ 0 ] [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , d ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ j ] <= temp [ i ] and b [ j ] >= temp [ i ] : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if dp [ i - 1 ] [ k ] < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( c [ j ] - c [ k ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , dp [ d - 1 ] [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE mod = int ( 1e9 + 7 ) NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i1 , i2 = 0 , 0 NEW_LINE flag = True NEW_LINE ch = list ( s ) NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ch [ i ] > ch [ i + 1 ] : NEW_LINE INDENT i1 = i + 1 NEW_LINE i2 = i + 2 NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( i1 , i2 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def sqroot ( s ) : NEW_LINE INDENT pSq = 0 NEW_LINE N = 0 NEW_LINE for i in range ( int ( s ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT pSq = i NEW_LINE N = j NEW_LINE break NEW_LINE DEDENT DEDENT if pSq > 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT d = s - pSq NEW_LINE P = d / ( 2.0 * N ) NEW_LINE A = N + P NEW_LINE sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) NEW_LINE return sqrt_of_s NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT num = 9.2345 NEW_LINE sqroot_of_num = sqroot ( num ) NEW_LINE print ( " Square ▁ root ▁ of " , num , " = " , round ( sqroot_of_num * 100000.0 ) / 100000.0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT a = list ( map ( int , line . split ( ) ) ) NEW_LINE n = a [ 0 ] NEW_LINE a = a [ 1 : ] NEW_LINE b = [ 0 ] * n NEW_LINE s = - 1 NEW_LINE tem = 1 NEW_LINE q = 0 NEW_LINE while q != n : NEW_LINE INDENT s += 1 NEW_LINE if tem == 1 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= q and b [ i ] == 0 : NEW_LINE INDENT b [ i ] = 1 NEW_LINE q += 1 NEW_LINE DEDENT DEDENT tem = 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] <= q and b [ i ] == 0 : NEW_LINE INDENT b [ i ] = 1 NEW_LINE q += 1 NEW_LINE DEDENT DEDENT tem = 1 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE INF = 100.0 NEW_LINE def crossTime ( x , y , r ) : NEW_LINE INDENT d = int ( math . pow ( - 2 * ( y + r ) , 2 ) ) - 4 * ( x * x + y * y + 2 * y * r ) NEW_LINE if d <= 0 : NEW_LINE INDENT return INF NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( 2 * ( y + r ) - math . sqrt ( d ) ) / 2 NEW_LINE return ans NEW_LINE DEDENT DEDENT def printHeight ( field ) : NEW_LINE INDENT for i in range ( len ( field ) ) : NEW_LINE INDENT print ( str ( i - 20 ) + " - " + str ( ( i - 20 ) + 1 ) + " : ▁ " + str ( field [ i ] ) ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT r , n = map ( int , input ( ) . split ( ) ) NEW_LINE if r == 0 : NEW_LINE INDENT break NEW_LINE DEDENT field = [ 0 ] * 40 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xl , xr , h = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( xl + 20 , xr + 20 ) : NEW_LINE INDENT field [ j ] = max ( field [ j ] , h ) NEW_LINE DEDENT DEDENT minTime = INF NEW_LINE for i in range ( len ( field ) ) : NEW_LINE INDENT minTime = min ( minTime , crossTime ( i - 20 , field [ i ] , r ) ) NEW_LINE minTime = min ( minTime , crossTime ( i + 1 - 20 , field [ i ] , r ) ) NEW_LINE DEDENT print ( minTime ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def find ( lst ) : NEW_LINE INDENT lst . sort ( ) NEW_LINE n = len ( lst ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if lst [ i ] <= i + 1 : NEW_LINE INDENT print ( i + 2 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE find ( lst ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE num = int ( input ( ) ) NEW_LINE while num != 0 : NEW_LINE INDENT s = oct ( num ) [ 2 : ] NEW_LINE table = [ 0 , 1 , 2 , 3 , 5 , 7 , 8 , 9 ] NEW_LINE for digit in s : NEW_LINE INDENT num2 = int ( digit , 8 ) NEW_LINE sys . stdout . write ( str ( table [ num2 ] ) ) NEW_LINE DEDENT sys . stdout . write ( " \n " ) NEW_LINE num = int ( input ( ) ) NEW_LINE DEDENT
0ERROR
import numpy as np NEW_LINE def generateArr ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] & arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev & arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev & arr [ n - 1 ] NEW_LINE DEDENT arr = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 ] ) NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
import java NEW_LINE def ReplaceElements ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
import java NEW_LINE def ReplaceElements ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev + arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev + arr [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if i * k > j * j : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A , B , C = 3 , 2 , 2 NEW_LINE print ( countTriplets ( A , B , C ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE MAX = 100000 NEW_LINE prime = [ False ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def smallestPrime ( d ) : NEW_LINE INDENT l = 10 ** ( d - 1 ) NEW_LINE r = 10 ** d - 1 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def largestPrime ( d ) : NEW_LINE INDENT l = 10 ** ( d - 1 ) NEW_LINE r = 10 ** d - 1 NEW_LINE for i in range ( r , l - 1 , - 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT queries = [ 2 , 5 ] NEW_LINE q = len ( queries ) NEW_LINE SieveOfEratosthenes ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( smallestPrime ( queries [ i ] ) , largestPrime ( queries [ i ] ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE INF = sys . maxsize // 2 NEW_LINE def main ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT n , m = map ( int , line . split ( ) ) NEW_LINE tir = [ [ INF ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE tir [ m ] [ n ] = 0 NEW_LINE d = [ int ( sys . stdin . readline ( ) ) for _ in range ( n ) ] NEW_LINE c = [ int ( sys . stdin . readline ( ) ) for _ in range ( m ) ] NEW_LINE for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT tir [ i ] [ j ] = min ( tir [ i + 1 ] [ j ] , tir [ i + 1 ] [ j + 1 ] + d [ j ] * c [ i ] ) NEW_LINE DEDENT DEDENT print ( tir [ 0 ] [ 0 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT input = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE n = input [ 0 ] NEW_LINE k = input [ 1 ] NEW_LINE x = input [ 2 ] NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( int ( input ( ) ) ) NEW_LINE DEDENT for i in range ( len ( arr ) - k , len ( arr ) ) : NEW_LINE INDENT arr [ i ] = x NEW_LINE DEDENT total_sum = sum ( arr ) NEW_LINE print ( total_sum ) NEW_LINE DEDENT DEDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , m , a , d = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE time = 0 NEW_LINE x = d // a + 1 NEW_LINE y = d - ( x - 1 ) * a NEW_LINE if y < 0 : NEW_LINE INDENT y = 0 NEW_LINE DEDENT last = 0 NEW_LINE i = 0 NEW_LINE while i < m : NEW_LINE INDENT b = max ( min ( ( arr [ i ] - 1 ) // a , n ) , 0 ) NEW_LINE c = b - time NEW_LINE k = c // x NEW_LINE count += k NEW_LINE time += k * x NEW_LINE if k != 0 : NEW_LINE INDENT while i < m and arr [ i ] <= time * a + y : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if i >= m : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE last = arr [ i ] + d NEW_LINE if time < n : NEW_LINE INDENT last = min ( last , ( time + 1 ) * a + d ) NEW_LINE DEDENT while i < m and arr [ i ] <= last : NEW_LINE INDENT i += 1 NEW_LINE DEDENT time = max ( time , min ( n , last // a ) ) NEW_LINE DEDENT if time < n : NEW_LINE INDENT count += ( n - time + x - 1 ) // x NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n1 = int ( input ( ) ) NEW_LINE sum = n1 * ( n1 + 1 ) // 2 NEW_LINE valu = 0 NEW_LINE for i in range ( 1 , n1 + 1 ) : NEW_LINE INDENT valu += i NEW_LINE DEDENT result = sum - ( valu * 2 ) NEW_LINE print ( result ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE ar = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ch = s [ i ] NEW_LINE ar [ ord ( ch ) - 97 ] += 1 NEW_LINE DEDENT cntod = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( ar [ i ] % 2 ) != 0 : NEW_LINE INDENT cntod += 1 NEW_LINE DEDENT DEDENT if cntod == 0 : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT else : NEW_LINE INDENT if cntod % 2 == 0 : NEW_LINE INDENT print ( " Second " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def reverse ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while n != 0 : NEW_LINE INDENT rev = ( rev * 10 ) + ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT def getSum ( n ) : NEW_LINE INDENT n = GFG . reverse ( n ) NEW_LINE sumOdd , sumEven , c = 0 , 0 , 1 NEW_LINE while n != 0 : NEW_LINE INDENT if c % 2 == 0 : NEW_LINE INDENT sumEven += n % 10 NEW_LINE DEDENT else : NEW_LINE INDENT sumOdd += n % 10 NEW_LINE DEDENT n //= 10 NEW_LINE c += 1 NEW_LINE DEDENT print ( " Sum ▁ odd ▁ = " , sumOdd ) NEW_LINE print ( " Sum ▁ even ▁ = " , sumEven ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 457892 NEW_LINE GFG . getSum ( n ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def disp ( row_no , block ) : NEW_LINE INDENT print ( row_no * block ) NEW_LINE DEDENT def row ( ht , h ) : NEW_LINE INDENT return ht // h NEW_LINE DEDENT def calculate ( l , w , h , a , ht ) : NEW_LINE INDENT no_block = ( 4 * a ) // l NEW_LINE if h < w : NEW_LINE INDENT row_no = row ( ht , w ) NEW_LINE DEDENT else : NEW_LINE INDENT row_no = row ( ht , h ) NEW_LINE DEDENT disp ( row_no , no_block ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , w , h = 50 , 20 , 35 NEW_LINE a = 700 NEW_LINE ht = 140 NEW_LINE calculate ( l , w , h , a , ht ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT bin = [ "000" , "001" , "010" , "011" , "100" , "101" , "110" , "111" ] NEW_LINE @ staticmethod NEW_LINE def maxFreq ( s ) : NEW_LINE INDENT binary = " " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT binary += GFG . bin [ int ( s [ i ] ) ] NEW_LINE DEDENT binary = binary [ : - 1 ] NEW_LINE count = 1 NEW_LINE prev = - 1 NEW_LINE j = 0 NEW_LINE for i in range ( len ( binary ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if binary [ i ] == '1' : NEW_LINE INDENT count = max ( count , j - prev ) NEW_LINE prev = j NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT octal = "13" NEW_LINE print ( GFG . maxFreq ( octal ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def isVowel ( c ) : NEW_LINE INDENT return c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT cv = [ 0 ] * n NEW_LINE cc = [ 0 ] * n NEW_LINE if GFG . isVowel ( s [ 0 ] ) : NEW_LINE INDENT cv [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cc [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT cv [ i ] = cv [ i - 1 ] + ( 1 if GFG . isVowel ( s [ i ] ) else 0 ) NEW_LINE cc [ i ] = cc [ i - 1 ] + ( 0 if GFG . isVowel ( s [ i ] ) else 1 ) NEW_LINE DEDENT ans = " " NEW_LINE prod = 0 NEW_LINE prod = cc [ k - 1 ] * cv [ k - 1 ] NEW_LINE ans += str ( prod ) NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) NEW_LINE ans += str ( prod ) NEW_LINE DEDENT return ans NEW_LINE DEDENT s = " hello " NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( list ( s ) , n , k ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def harmonicMean ( arr , freq , n ) : NEW_LINE INDENT sum_val = 0 NEW_LINE frequency_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_val += float ( freq [ i ] ) / arr [ i ] NEW_LINE frequency_sum += freq [ i ] NEW_LINE DEDENT return frequency_sum / sum_val NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT num = [ 13 , 14 , 15 , 16 , 17 ] NEW_LINE freq = [ 2 , 5 , 13 , 7 , 3 ] NEW_LINE n = len ( num ) NEW_LINE print ( " { : . 4f } " . format ( GFG . harmonicMean ( num , freq , n ) ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE def polyarea ( n , a ) : NEW_LINE INDENT if a < 0 and n < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a * a * n ) / ( 4 * math . tan ( ( 180 / n ) * math . pi / 180 ) ) NEW_LINE return A NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( " { : . 3f } " . format ( polyarea ( n , a ) ) ) NEW_LINE DEDENT
def __gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a // __gcd ( a , b ) * b ) NEW_LINE DEDENT def getMinValue ( c ) : NEW_LINE INDENT ans = float ( ' inf ' ) NEW_LINE for i in range ( 1 , int ( c ** 0.5 ) + 1 ) : NEW_LINE INDENT if c % i == 0 and lcm ( i , c // i ) == c : NEW_LINE INDENT ans = min ( ans , max ( i , c // i ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT c = 6 NEW_LINE print ( getMinValue ( c ) ) NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT data = list ( map ( int , line . split ( ) ) ) NEW_LINE m = data [ 0 ] NEW_LINE nmin = data [ 1 ] NEW_LINE nmax = data [ 2 ] NEW_LINE if m + nmin + nmax == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = [ 0 ] * ( m + 1 ) NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT p [ i ] = data [ i + 2 ] NEW_LINE DEDENT gap = 0 NEW_LINE n = 0 NEW_LINE for i in range ( nmin , nmax + 1 ) : NEW_LINE INDENT if gap <= p [ i ] - p [ i + 1 ] and n < i : NEW_LINE INDENT gap = p [ i ] - p [ i + 1 ] NEW_LINE n = i NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT start , ratio , max_val , m = map ( int , input ( ) . split ( ) ) NEW_LINE bad = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if abs ( start ) > max_val : NEW_LINE INDENT print ( "0" ) NEW_LINE return NEW_LINE DEDENT if start == 0 : NEW_LINE INDENT if start in bad : NEW_LINE INDENT print ( "0" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( " inf " ) NEW_LINE return NEW_LINE DEDENT DEDENT if ratio == 1 : NEW_LINE INDENT if start in bad : NEW_LINE INDENT print ( "0" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( " inf " ) NEW_LINE return NEW_LINE DEDENT DEDENT if ratio == - 1 : NEW_LINE INDENT if start in bad and - start in bad : NEW_LINE INDENT print ( "0" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( " inf " ) NEW_LINE return NEW_LINE DEDENT DEDENT if ratio == 0 : NEW_LINE INDENT if ratio not in bad : NEW_LINE INDENT print ( " inf " ) NEW_LINE return NEW_LINE DEDENT elif start in bad : NEW_LINE INDENT print ( "0" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( "1" ) NEW_LINE return NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE while abs ( start ) <= max_val : NEW_LINE INDENT if start not in bad : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT start *= ratio NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE arr . append ( ( num , i + 1 ) ) NEW_LINE DEDENT arr . sort ( key = lambda x : x [ 0 ] ) NEW_LINE if n >= 2 : NEW_LINE INDENT print ( arr [ 0 ] [ 1 ] , arr [ n - 1 ] [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE def findIndex ( n ) : NEW_LINE INDENT fibo = 2.078087 * math . log ( n ) + 1.672276 NEW_LINE return round ( fibo ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 21 NEW_LINE print ( findIndex ( n ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def isSmaller ( str1 , str2 ) : NEW_LINE INDENT n1 , n2 = len ( str1 ) , len ( str2 ) NEW_LINE if n1 < n2 : NEW_LINE INDENT return True NEW_LINE DEDENT if n2 < n1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if str1 [ i ] < str2 [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT elif str1 [ i ] > str2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findDiff ( str1 , str2 ) : NEW_LINE INDENT if GFG . isSmaller ( str1 , str2 ) : NEW_LINE INDENT str1 , str2 = str2 , str1 NEW_LINE DEDENT str = " " NEW_LINE n1 , n2 = len ( str1 ) , len ( str2 ) NEW_LINE str1 = str1 [ : : - 1 ] NEW_LINE str2 = str2 [ : : - 1 ] NEW_LINE carry = 0 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT sub = ( int ( str1 [ i ] ) - int ( str2 [ i ] ) - carry ) NEW_LINE if sub < 0 : NEW_LINE INDENT sub += 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT str += str ( sub ) NEW_LINE DEDENT for i in range ( n2 , n1 ) : NEW_LINE INDENT sub = ( int ( str1 [ i ] ) - carry ) NEW_LINE if sub < 0 : NEW_LINE INDENT sub += 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT str += str ( sub ) NEW_LINE DEDENT return str [ : : - 1 ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT str1 = "978" NEW_LINE str2 = "12977" NEW_LINE print ( GFG . findDiff ( str1 , str2 ) ) NEW_LINE s1 = "100" NEW_LINE s2 = "1000000" NEW_LINE print ( GFG . findDiff ( s1 , s2 ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def minSwaps ( s1 , s2 ) : NEW_LINE INDENT c0 = 0 NEW_LINE c1 = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] == '0' and s2 [ i ] == '1' : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT elif s1 [ i ] == '1' and s2 [ i ] == '0' : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT ans = c0 // 2 + c1 // 2 NEW_LINE if c0 % 2 == 0 and c1 % 2 == 0 : NEW_LINE INDENT return ans NEW_LINE DEDENT elif ( c0 + c1 ) % 2 == 0 : NEW_LINE INDENT return ans + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT s1 = "0011" NEW_LINE s2 = "1111" NEW_LINE ans = minSwaps ( s1 , s2 ) NEW_LINE print ( ans ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE all_sum = sum ( x ) NEW_LINE seg = SegmentTree ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre = seg . query ( 0 , x [ i ] ) NEW_LINE seg . set ( x [ i ] , pre + x [ i ] ) NEW_LINE DEDENT fix = seg . query ( 0 , n + 1 ) NEW_LINE print ( all_sum - fix ) NEW_LINE DEDENT DEDENT class SegmentTree : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = 1 NEW_LINE while self . n < n : NEW_LINE INDENT self . n *= 2 NEW_LINE DEDENT self . val = [ 0 ] * ( 2 * self . n - 1 ) NEW_LINE DEDENT def set ( self , k , l ) : NEW_LINE INDENT k += self . n - 1 NEW_LINE self . val [ k ] = l NEW_LINE while k > 0 : NEW_LINE INDENT k = ( k - 1 ) // 2 NEW_LINE self . val [ k ] = max ( self . val [ 2 * k + 1 ] , self . val [ 2 * k + 2 ] ) NEW_LINE DEDENT DEDENT def query ( self , a , b ) : NEW_LINE INDENT return self . _query ( a , b , 0 , self . n , 0 ) NEW_LINE DEDENT def _query ( self , a , b , l , r , k ) : NEW_LINE INDENT if r <= a or b <= l : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif a <= l and r <= b : NEW_LINE INDENT return self . val [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT vl = self . _query ( a , b , l , ( l + r ) // 2 , 2 * k + 1 ) NEW_LINE vr = self . _query ( a , b , ( l + r ) // 2 , r , 2 * k + 2 ) NEW_LINE return max ( vl , vr ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE s = input ( ) NEW_LINE part = s . index ( " ^ " ) NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE for i in range ( part ) : NEW_LINE INDENT if s [ i ] . isdigit ( ) : NEW_LINE INDENT left += ( part - i ) * int ( s [ i ] ) NEW_LINE DEDENT DEDENT for j in range ( part + 1 , len ( s ) ) : NEW_LINE INDENT if s [ j ] . isdigit ( ) : NEW_LINE INDENT right += ( j - part ) * int ( s [ j ] ) NEW_LINE DEDENT DEDENT if left == right : NEW_LINE INDENT print ( " balance " ) NEW_LINE DEDENT elif left < right : NEW_LINE INDENT print ( " right " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " left " ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def normalSieve ( n ) : NEW_LINE INDENT prime = [ False ] * ( n // 2 ) NEW_LINE for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if not prime [ i // 2 ] : NEW_LINE INDENT for j in range ( i * i , n , i * 2 ) : NEW_LINE INDENT prime [ j // 2 ] = True NEW_LINE DEDENT DEDENT DEDENT print ( "2" , end = " ▁ " ) NEW_LINE for i in range ( 3 , n , 2 ) : NEW_LINE INDENT if not prime [ i // 2 ] : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 100 NEW_LINE normalSieve ( n ) NEW_LINE DEDENT
` ` ` python NEW_LINE word = input ( ) NEW_LINE uppercase = 0 NEW_LINE lowercase = 0 NEW_LINE for ch in word : NEW_LINE INDENT if ch . isupper ( ) : NEW_LINE INDENT uppercase += 1 NEW_LINE DEDENT else : NEW_LINE INDENT lowercase += 1 NEW_LINE DEDENT DEDENT if uppercase > lowercase : NEW_LINE INDENT print ( word . upper ( ) ) NEW_LINE DEDENT elif lowercase > uppercase : NEW_LINE INDENT print ( word . lower ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( word . lower ( ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def frequencyOfSmallest ( n , arr ) : NEW_LINE INDENT mn = arr [ 0 ] NEW_LINE freq = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] < mn : NEW_LINE INDENT mn = arr [ i ] NEW_LINE freq = 1 NEW_LINE DEDENT elif arr [ i ] == mn : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 3 , 2 , 3 , 4 , 4 ] NEW_LINE print ( frequencyOfSmallest ( N , arr ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def isSubArray ( A , B , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if A [ i ] == B [ j ] : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE if j == m : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i = i - j + 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT A = [ 2 , 3 , 0 , 5 , 1 , 1 , 2 ] NEW_LINE n = len ( A ) NEW_LINE B = [ 3 , 0 , 5 , 1 ] NEW_LINE m = len ( B ) NEW_LINE if GFG . isSubArray ( A , B , n , m ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = arr [ 0 ] + 1 NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT ans += abs ( arr [ i ] - arr [ i - 1 ] ) + 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = 0 NEW_LINE self . MOD = 1000000007 NEW_LINE self . TOKENS = [ " A " , " C " , " G " , " T " ] NEW_LINE self . memo = [ ] NEW_LINE self . N = int ( input ( ) ) NEW_LINE self . memo = [ { } for _ in range ( self . N + 1 ) ] NEW_LINE DEDENT def calc ( self ) : NEW_LINE INDENT return self . dfs ( 0 , " TTT " ) NEW_LINE DEDENT def isOK ( self , last4 ) : NEW_LINE INDENT if " AGC " in last4 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT vals = list ( last4 ) NEW_LINE vals [ i ] , vals [ i + 1 ] = vals [ i + 1 ] , vals [ i ] NEW_LINE s = " " . join ( vals ) NEW_LINE if " AGC " in s : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( self , current , last3 ) : NEW_LINE INDENT if last3 in self . memo [ current ] : NEW_LINE INDENT return self . memo [ current ] [ last3 ] NEW_LINE DEDENT if current == self . N : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for c in self . TOKENS : NEW_LINE INDENT if self . isOK ( last3 + c ) : NEW_LINE INDENT result = ( result + self . dfs ( current + 1 , last3 [ 1 : ] + c ) ) % self . MOD NEW_LINE DEDENT DEDENT self . memo [ current ] [ last3 ] = result NEW_LINE return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ins = Main ( ) NEW_LINE print ( ins . calc ( ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import re NEW_LINE sum = 0 NEW_LINE n = 0 NEW_LINE total = 0 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT value , amount = map ( int , re . split ( ' , | \n ' , input ( ) ) ) NEW_LINE sum += value * amount NEW_LINE total += amount NEW_LINE n += 1 NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE print ( round ( total / n ) ) NEW_LINE
import math NEW_LINE MAX = 100 NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT def sumOfproduct ( n ) : NEW_LINE INDENT return binomialCoeff ( 2 * n , n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( sumOfproduct ( n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT string1 = input ( " Enter ▁ the ▁ first ▁ string : ▁ " ) NEW_LINE print ( " Enter ▁ the ▁ first ▁ string : ▁ " + string1 ) NEW_LINE string2 = input ( " Enter ▁ the ▁ second ▁ string : ▁ " ) NEW_LINE print ( " Enter ▁ the ▁ second ▁ string : ▁ " + string2 ) NEW_LINE print ( " Are ▁ both ▁ strings ▁ same : ▁ " , end = " " ) NEW_LINE if string1 == string2 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def pairCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( math . sqrt ( max_val ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count * ( count - 1 ) ) // 2 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairCount ( arr , n ) ) NEW_LINE
import math NEW_LINE def getPrime ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT maximum = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT arr = [ 2 , 10 , 15 , 7 , 6 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getPrime ( arr , n ) ) NEW_LINE
from functools import reduce NEW_LINE class p013 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . NUMBERS = [ "37107287533902102798797998220837590246510135740250" , "46376937677490009712648124896970078050417018260538" , "74324986199524741059474233309513058123726617309629" , ] NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT sum = reduce ( lambda x , y : int ( x ) + int ( y ) , self . NUMBERS ) NEW_LINE return str ( sum ) [ : 10 ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( p013 ( ) . run ( ) ) NEW_LINE DEDENT
import java NEW_LINE import java . util NEW_LINE def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE DEDENT
import numpy as np NEW_LINE def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while i < n - 1 and arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE BIG_NUM = 2000000000 NEW_LINE MOD = 1000000007 NEW_LINE def main ( ) : NEW_LINE INDENT try : NEW_LINE INDENT input_str = sys . stdin . readline ( ) . split ( ) NEW_LINE A = int ( input_str [ 0 ] ) NEW_LINE B = int ( input_str [ 1 ] ) NEW_LINE ans = A * B NEW_LINE print ( ans ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def nth_term ( a , b , n ) : NEW_LINE INDENT z = 0 NEW_LINE if n % 6 == 1 : NEW_LINE INDENT z = a NEW_LINE DEDENT elif n % 6 == 2 : NEW_LINE INDENT z = b NEW_LINE DEDENT elif n % 6 == 3 : NEW_LINE INDENT z = b - a NEW_LINE DEDENT elif n % 6 == 4 : NEW_LINE INDENT z = - a NEW_LINE DEDENT elif n % 6 == 5 : NEW_LINE INDENT z = - b NEW_LINE DEDENT if n % 6 == 0 : NEW_LINE INDENT z = - ( b - a ) NEW_LINE DEDENT return z NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = 10 NEW_LINE b = 17 NEW_LINE n = 3 NEW_LINE print ( nth_term ( a , b , n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def findSubSequence ( s , num ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while num > 0 : NEW_LINE INDENT if ( num & 1 ) == 1 : NEW_LINE INDENT res += int ( s [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE num = num >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def combinedSum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c_sum = 0 NEW_LINE range = ( 1 << n ) - 1 NEW_LINE for i in range ( range + 1 ) : NEW_LINE INDENT c_sum += GFG . findSubSequence ( s , i ) NEW_LINE DEDENT return c_sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT s = "123" NEW_LINE print ( GFG . combinedSum ( s ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 , dp2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def countMultiples ( n ) : NEW_LINE INDENT return n // 3 + n // 7 - n // 21 NEW_LINE DEDENT print ( " Count ▁ = ▁ " + str ( countMultiples ( 25 ) ) ) NEW_LINE
` ` ` python NEW_LINE class GfG : NEW_LINE INDENT SIZE = 26 NEW_LINE @ staticmethod NEW_LINE def longSubstring ( str1 , k ) : NEW_LINE INDENT freq = [ 0 ] * GfG . SIZE NEW_LINE str = list ( str1 ) NEW_LINE start = 0 NEW_LINE maxLen = 0 NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE freq [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE if freq [ ord ( ch ) - ord ( ' a ' ) ] > k : NEW_LINE INDENT if maxLen < ( i - start ) : NEW_LINE INDENT maxLen = i - start NEW_LINE DEDENT while freq [ ord ( ch ) - ord ( ' a ' ) ] > k : NEW_LINE INDENT freq [ ord ( str [ start ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT if maxLen < ( n - start ) : NEW_LINE INDENT maxLen = n - start NEW_LINE DEDENT return maxLen NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( argc ) : NEW_LINE INDENT str = " babcaag " NEW_LINE k = 1 NEW_LINE print ( " Length ▁ = ▁ " + str ( GfG . longSubstring ( str , k ) ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ch = [ ' ' ] * n NEW_LINE s1 , s2 = 0 , 0 NEW_LINE j , flag = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE temp1 = s1 + x NEW_LINE temp2 = s2 + y NEW_LINE if abs ( temp1 - s2 ) <= 500 : NEW_LINE INDENT s1 += x NEW_LINE ch [ j ] = ' A ' NEW_LINE j += 1 NEW_LINE continue NEW_LINE DEDENT if abs ( temp2 - s1 ) <= 500 : NEW_LINE INDENT s2 += y NEW_LINE ch [ j ] = ' G ' NEW_LINE j += 1 NEW_LINE continue NEW_LINE DEDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' ' . join ( ch ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def toHex ( self , num : int ) -> str : NEW_LINE INDENT hex_map = "0123456789abcdef " NEW_LINE if num == 0 : NEW_LINE INDENT return "0" NEW_LINE DEDENT res = " " NEW_LINE while num != 0 and len ( res ) < 8 : NEW_LINE INDENT res = hex_map [ num & 15 ] + res NEW_LINE num = num >> 4 NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 26 NEW_LINE out = sObj . toHex ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT s = Solution ( ) NEW_LINE s . main ( ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE count = int ( input ( ) ) NEW_LINE print_island ( n , count ) NEW_LINE DEDENT def print_island ( n , count ) : NEW_LINE INDENT a = ( n + 1 ) // 2 NEW_LINE b = n // 2 NEW_LINE max_val = a * a + b * b NEW_LINE if count > max_val : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT print ( " YES " ) NEW_LINE result = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i + j ) % 2 == 0 and count > 0 : NEW_LINE INDENT result += ' L ' NEW_LINE count -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += ' S ' NEW_LINE DEDENT DEDENT result += " \n " NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def longestString ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result += chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT str1 = " geeks " NEW_LINE str2 = " cake " NEW_LINE GFG . longestString ( str1 , str2 ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
class GFG : NEW_LINE INDENT def msb ( x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( x >> ( ret + 1 ) ) != 0 : NEW_LINE INDENT ret += 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def xorRange ( l , r ) : NEW_LINE INDENT max_bit = GFG . msb ( r ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE i = 1 NEW_LINE while i <= max_bit : NEW_LINE INDENT if ( l // mul ) * mul == ( r // mul ) * mul : NEW_LINE INDENT if ( l & ( 1 << i ) ) != 0 and ( r - l + 1 ) % 2 == 1 : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE i += 1 NEW_LINE continue NEW_LINE DEDENT odd_c = 0 NEW_LINE if ( l & ( 1 << i ) ) != 0 and l % 2 == 1 : NEW_LINE INDENT odd_c ^= 1 NEW_LINE DEDENT if ( r & ( 1 << i ) ) != 0 and r % 2 == 0 : NEW_LINE INDENT odd_c ^= 1 NEW_LINE DEDENT if odd_c != 0 : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE i += 1 NEW_LINE DEDENT zero_bit_cnt = ( r - l + 1 ) // 2 NEW_LINE if l % 2 == 1 and r % 2 == 1 : NEW_LINE INDENT zero_bit_cnt += 1 NEW_LINE DEDENT if zero_bit_cnt % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT l = 1 NEW_LINE r = 4 NEW_LINE print ( xorRange ( l , r ) ) NEW_LINE DEDENT
def q1 ( s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT if s [ i ] == ' a ' : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT def q2 ( s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT if s [ i ] == ' a ' : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT def q3 ( s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT if s [ i ] == ' a ' : NEW_LINE INDENT q4 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT def q4 ( s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT if s [ i ] == ' a ' : NEW_LINE INDENT q4 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT def q0 ( s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT if s [ i ] == ' a ' : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT s = " abbaabb " NEW_LINE q0 ( s , 0 ) NEW_LINE
import sys NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT m = [ 0 ] * 10000 NEW_LINE t = [ 0 ] NEW_LINE a , b = 0 , 0 NEW_LINE max_val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = [ 0 ] * 10000 NEW_LINE t = [ 1 ] NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( 0 , a * b + 1 , a ) : NEW_LINE INDENT for k in range ( max_val + 1 ) : NEW_LINE INDENT if t [ k ] > 0 : NEW_LINE INDENT m [ j + k ] += t [ k ] NEW_LINE DEDENT DEDENT DEDENT max_val += a * b NEW_LINE t = m [ : ] NEW_LINE DEDENT s = int ( input ( ) ) NEW_LINE for i in range ( s ) : NEW_LINE INDENT print ( m [ int ( input ( ) ) ] ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def findTime ( T , K ) : NEW_LINE INDENT minutes = ( ( int ( T [ 0 ] ) - 0 ) * 10 + int ( T [ 1 ] ) - 0 ) * 60 + ( ( int ( T [ 3 ] ) - 0 ) * 10 + int ( T [ 4 ] ) - 0 ) NEW_LINE minutes += K NEW_LINE hour = ( minutes // 60 ) % 24 NEW_LINE min = minutes % 60 NEW_LINE if hour < 10 : NEW_LINE INDENT print ( "0" + str ( hour ) + " : " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str ( hour ) + " : " , end = " " ) NEW_LINE DEDENT if min < 10 : NEW_LINE INDENT print ( "0" + str ( min ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str ( min ) ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT T = "21:39" NEW_LINE K = 43 NEW_LINE GFG . findTime ( T , K ) NEW_LINE DEDENT DEDENT
0ERROR
class GFG : NEW_LINE INDENT def min ( x , y , z ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return x if x < z else z NEW_LINE DEDENT else : NEW_LINE INDENT return y if y < z else z NEW_LINE DEDENT DEDENT def minCost ( cost , m , n ) : NEW_LINE INDENT if n < 0 or m < 0 : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT elif m == 0 and n == 0 : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) NEW_LINE DEDENT DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE n = int ( input ( ) ) NEW_LINE x = [ 0 ] * ( n + 1 ) NEW_LINE ji = [ 0 ] * ( n + 1 ) NEW_LINE shu = [ 0 ] * ( n // 2 ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT shu [ i ] = int ( input ( ) ) NEW_LINE DEDENT shu . sort ( ) NEW_LINE l1 = 0 NEW_LINE l2 = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT s1 = i * 2 + 1 NEW_LINE s2 = i * 2 + 2 NEW_LINE id = shu [ i ] NEW_LINE if id != s1 : NEW_LINE INDENT l1 += abs ( s1 - id ) NEW_LINE DEDENT if id != s2 : NEW_LINE INDENT l2 += abs ( s2 - id ) NEW_LINE DEDENT DEDENT min_val = min ( l1 , l2 ) NEW_LINE print ( min_val ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT parents = [ ] NEW_LINE weight = [ ] NEW_LINE rank = [ ] NEW_LINE def main ( self ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE self . parents = [ i for i in range ( n ) ] NEW_LINE self . weight = [ 0 ] * n NEW_LINE self . rank = [ 0 ] * n NEW_LINE for _ in range ( q ) : NEW_LINE INDENT query = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if query [ 0 ] == 0 : NEW_LINE INDENT self . relate ( query [ 1 ] , query [ 2 ] , query [ 3 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT self . diff ( query [ 1 ] , query [ 2 ] ) NEW_LINE DEDENT DEDENT DEDENT def find ( self , x ) : NEW_LINE INDENT if x == self . parents [ x ] : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT r = self . find ( self . parents [ x ] ) NEW_LINE self . weight [ x ] += self . weight [ self . parents [ x ] ] NEW_LINE self . parents [ x ] = r NEW_LINE return self . parents [ x ] NEW_LINE DEDENT DEDENT def weight_func ( self , x ) : NEW_LINE INDENT self . find ( x ) NEW_LINE return self . weight [ x ] NEW_LINE DEDENT def relate ( self , x , y , z ) : NEW_LINE INDENT z += self . weight_func ( x ) NEW_LINE z -= self . weight_func ( y ) NEW_LINE x = self . find ( x ) NEW_LINE y = self . find ( y ) NEW_LINE if x == y : NEW_LINE INDENT return NEW_LINE DEDENT if self . rank [ x ] < self . rank [ y ] : NEW_LINE INDENT x , y = y , x NEW_LINE z = - z NEW_LINE DEDENT if self . rank [ x ] == self . rank [ y ] : NEW_LINE INDENT self . rank [ x ] += 1 NEW_LINE DEDENT self . parents [ y ] = x NEW_LINE self . weight [ y ] = z NEW_LINE DEDENT def diff ( self , x , y ) : NEW_LINE INDENT if self . find ( x ) == self . find ( y ) : NEW_LINE INDENT print ( self . weight_func ( y ) - self . weight_func ( x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ? " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if i % M == 0 : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT A , B , M = 6 , 15 , 3 NEW_LINE print ( GFG . sumDivisibles ( A , B , M ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def countNumbersWith4 ( n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( math . log10 ( n ) ) NEW_LINE a = [ 0 ] * ( d + 2 ) NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + int ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT p = int ( math . ceil ( math . pow ( 10 , d ) ) ) NEW_LINE msd = n // p NEW_LINE if msd == 4 : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if msd > 4 : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 328 NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + str ( n ) + " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is ▁ " + str ( countNumbersWith4 ( n ) ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE lst = [ x , y , y - x ] NEW_LINE i = 2 NEW_LINE while not ( lst [ i ] == y and lst [ i - 1 ] == x or lst [ i ] == 0 and lst [ i - 1 ] == 0 ) : NEW_LINE INDENT lst . append ( lst [ i ] - lst [ i - 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT k = int ( input ( ) ) NEW_LINE i -= 1 NEW_LINE k = k % i NEW_LINE if k == 0 : NEW_LINE INDENT k = i NEW_LINE DEDENT print ( ( ( lst [ k - 1 ] % 1000000007 ) + 1000000007 ) % 1000000007 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class Solution : NEW_LINE INDENT class INT : NEW_LINE INDENT def __init__ ( self , d ) : NEW_LINE INDENT self . data = d NEW_LINE DEDENT DEDENT def findPostOrderUtil ( pre , n , minval , maxval , preIndex ) : NEW_LINE INDENT if preIndex . data == n : NEW_LINE INDENT return NEW_LINE DEDENT if pre [ preIndex . data ] < minval or pre [ preIndex . data ] > maxval : NEW_LINE INDENT return NEW_LINE DEDENT val = pre [ preIndex . data ] NEW_LINE preIndex . data += 1 NEW_LINE findPostOrderUtil ( pre , n , minval , val , preIndex ) NEW_LINE findPostOrderUtil ( pre , n , val , maxval , preIndex ) NEW_LINE print ( val , end = " ▁ " ) NEW_LINE DEDENT def findPostOrder ( pre , n ) : NEW_LINE INDENT preIndex = Solution . INT ( 0 ) NEW_LINE findPostOrderUtil ( pre , n , float ( ' - inf ' ) , float ( ' inf ' ) , preIndex ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT pre = [ 40 , 30 , 35 , 80 , 100 ] NEW_LINE n = len ( pre ) NEW_LINE findPostOrder ( pre , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( None ) NEW_LINE DEDENT DEDENT
from collections import Counter NEW_LINE def countWays ( n , arr , k ) : NEW_LINE INDENT if k <= 0 or k >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = set ( arr ) NEW_LINE if len ( s ) <= k : NEW_LINE INDENT return 0 NEW_LINE DEDENT return len ( s ) - k NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 100 , 200 , 400 , 50 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( countWays ( n , arr , k ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class _250B : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . inp = sys . stdin NEW_LINE self . out = sys . stdout NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT sb = " " NEW_LINE n = self . nextInt ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = self . nextToken ( ) . split ( " : " ) NEW_LINE k , m = 0 , len ( s ) - 1 NEW_LINE if s [ k ] == " " : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if s [ m ] == " " : NEW_LINE INDENT m -= 1 NEW_LINE DEDENT for j in range ( k , m + 1 ) : NEW_LINE INDENT if s [ j ] == " " : NEW_LINE INDENT for l in range ( 1 , 8 - m + k + 1 ) : NEW_LINE INDENT sb += "0000" NEW_LINE if l < 8 - m + k : NEW_LINE INDENT sb += " : " NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT sb += "0" * ( 4 - len ( s [ j ] ) ) + s [ j ] NEW_LINE DEDENT if j < m : NEW_LINE INDENT sb += " : " NEW_LINE DEDENT DEDENT sb += " \n " NEW_LINE DEDENT return sb NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT self . out . write ( self . solve ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT sys . exit ( 0 ) NEW_LINE DEDENT DEDENT def nextToken ( self ) : NEW_LINE INDENT return self . inp . readline ( ) . strip ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . nextToken ( ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT _250B ( ) . run ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT return True if flag == 1 else False NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( sr - math . floor ( sr ) ) == 0 NEW_LINE DEDENT def countInterestingPrimes ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT for j in range ( 1 , int ( i ** ( 1 / 4 ) ) + 1 ) : NEW_LINE INDENT if isPerfectSquare ( i - j ** 4 ) : NEW_LINE INDENT answer += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT N = 10 NEW_LINE print ( countInterestingPrimes ( N ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE previous = input ( ) NEW_LINE used_words = set ( ) NEW_LINE used_words . add ( previous ) NEW_LINE while N > 1 : NEW_LINE INDENT next_word = input ( ) NEW_LINE if not ( previous [ - 1 ] == next_word [ 0 ] and next_word not in used_words ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT previous = next_word NEW_LINE used_words . add ( next_word ) NEW_LINE N -= 1 NEW_LINE DEDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main_instance = Main ( ) NEW_LINE main_instance . main ( None ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT div = [ 8 , 3 ] NEW_LINE rem = [ 2 , 2 ] NEW_LINE N = len ( div ) NEW_LINE print ( findNum ( div , rem , N ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def segregate0and1 ( arr ) : NEW_LINE INDENT type0 = 0 NEW_LINE type1 = len ( arr ) - 1 NEW_LINE while type0 < type1 : NEW_LINE INDENT if arr [ type0 ] == 1 : NEW_LINE INDENT arr [ type1 ] , arr [ type0 ] = arr [ type1 ] + arr [ type0 ] , arr [ type1 ] NEW_LINE arr [ type1 ] = arr [ type1 ] - arr [ type0 ] NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT array = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE GFG . segregate0and1 ( array ) NEW_LINE print ( " Array ▁ after ▁ segregation ▁ is " , end = " ▁ " ) NEW_LINE for a in array : NEW_LINE INDENT print ( a , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE n = int ( input ( ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d . sort ( ) NEW_LINE ans = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if d [ i ] != d [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE s = input ( ) NEW_LINE s1 = input ( ) NEW_LINE c = list ( s ) NEW_LINE c1 = list ( s1 ) NEW_LINE diff = ord ( c1 [ 0 ] ) - ord ( c [ 0 ] ) NEW_LINE dif = int ( c1 [ 1 ] ) - int ( c [ 1 ] ) NEW_LINE n = abs ( diff ) NEW_LINE m = abs ( dif ) NEW_LINE ans = " " NEW_LINE while diff != 0 or dif != 0 : NEW_LINE INDENT if diff > 0 : NEW_LINE INDENT ans += " R " NEW_LINE diff -= 1 NEW_LINE DEDENT if diff < 0 : NEW_LINE INDENT ans += " L " NEW_LINE diff += 1 NEW_LINE DEDENT if dif > 0 : NEW_LINE INDENT ans += " U " NEW_LINE dif -= 1 NEW_LINE DEDENT if dif < 0 : NEW_LINE INDENT ans += " D " NEW_LINE dif += 1 NEW_LINE DEDENT ans += " \n " NEW_LINE DEDENT print ( max ( n , m ) ) NEW_LINE print ( ans ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE h , w = map ( int , input ( ) . split ( ) ) NEW_LINE total = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j , x in enumerate ( map ( int , input ( ) . split ( ) ) ) : NEW_LINE INDENT total += x * ( i + 1 ) * ( h - i ) * ( j + 1 ) * ( w - j ) NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE lab = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lab . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT ans = True NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( n ) : NEW_LINE INDENT if lab [ x ] [ y ] != 1 : NEW_LINE INDENT cur = lab [ x ] [ y ] NEW_LINE isValid = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if lab [ x ] [ i ] + lab [ j ] [ y ] == cur : NEW_LINE INDENT isValid = True NEW_LINE break NEW_LINE DEDENT DEDENT if isValid : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not isValid : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if not ans : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " Yes " if ans else " No " ) NEW_LINE
import java . util . Scanner NEW_LINE def printBin ( str ) : NEW_LINE INDENT for i in range ( len ( str ) - 32 , len ( str ) ) : NEW_LINE INDENT print ( str [ i ] , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def fillZero ( str ) : NEW_LINE INDENT zero = " " NEW_LINE if len ( str ) < 32 : NEW_LINE INDENT for i in range ( 32 - len ( str ) ) : NEW_LINE INDENT zero += "0" NEW_LINE DEDENT DEDENT return zero + str NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE printBin ( fillZero ( bin ( x & y ) [ 2 : ] ) ) NEW_LINE printBin ( fillZero ( bin ( x | y ) [ 2 : ] ) ) NEW_LINE printBin ( fillZero ( bin ( x ^ y ) [ 2 : ] ) ) NEW_LINE DEDENT
import sys NEW_LINE def printBin ( str ) : NEW_LINE INDENT for i in range ( len ( str ) - 32 , len ( str ) ) : NEW_LINE INDENT sys . stdout . write ( str [ i ] ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def fillZero ( str ) : NEW_LINE INDENT zero = " " NEW_LINE if len ( str ) < 32 : NEW_LINE INDENT for i in range ( 32 - len ( str ) ) : NEW_LINE INDENT zero += "0" NEW_LINE DEDENT DEDENT return zero + str NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE printBin ( fillZero ( bin ( x ) [ 2 : ] ) ) NEW_LINE printBin ( fillZero ( bin ( ~ x & 0xffffffff ) [ 2 : ] ) ) NEW_LINE printBin ( fillZero ( bin ( x << 1 ) [ 2 : ] ) ) NEW_LINE printBin ( fillZero ( bin ( x >> 1 ) [ 2 : ] ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE M = 5 NEW_LINE def main ( ) : NEW_LINE INDENT ma = [ 0 ] * M NEW_LINE sc = Scanner ( System . in ) NEW_LINE n = int ( sc . next ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s = list ( sc . next ( ) ) NEW_LINE if s [ 0 ] == ' M ' : NEW_LINE INDENT ma [ 0 ] += 1 NEW_LINE DEDENT elif s [ 0 ] == ' A ' : NEW_LINE INDENT ma [ 1 ] += 1 NEW_LINE DEDENT elif s [ 0 ] == ' R ' : NEW_LINE INDENT ma [ 2 ] += 1 NEW_LINE DEDENT elif s [ 0 ] == ' C ' : NEW_LINE INDENT ma [ 3 ] += 1 NEW_LINE DEDENT elif s [ 0 ] == ' H ' : NEW_LINE INDENT ma [ 4 ] += 1 NEW_LINE DEDENT DEDENT sc . close ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( M - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , M - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , M ) : NEW_LINE INDENT ans += ma [ i ] * ma [ j ] * ma [ k ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def intercepted_message ( ) : NEW_LINE INDENT total_first_files = int ( input ( ) ) NEW_LINE total_second_files = int ( input ( ) ) NEW_LINE first_files = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE second_files = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_files = 0 NEW_LINE first_pointer = 0 NEW_LINE second_pointer = 0 NEW_LINE has_finished = False NEW_LINE temp_first_number = 0 NEW_LINE temp_second_number = 0 NEW_LINE while not has_finished : NEW_LINE INDENT if first_pointer == 0 and second_pointer == 0 : NEW_LINE INDENT temp_first_number += first_files [ first_pointer ] NEW_LINE temp_second_number += second_files [ second_pointer ] NEW_LINE DEDENT if temp_first_number == temp_second_number : NEW_LINE INDENT max_files += 1 NEW_LINE first_pointer += 1 NEW_LINE second_pointer += 1 NEW_LINE if first_pointer > len ( first_files ) - 1 and second_pointer > len ( second_files ) - 1 : NEW_LINE INDENT break NEW_LINE DEDENT temp_first_number = first_files [ first_pointer ] NEW_LINE temp_second_number = second_files [ second_pointer ] NEW_LINE DEDENT elif temp_first_number < temp_second_number : NEW_LINE INDENT first_pointer += 1 NEW_LINE temp_first_number += first_files [ first_pointer ] NEW_LINE DEDENT else : NEW_LINE INDENT second_pointer += 1 NEW_LINE temp_second_number += second_files [ second_pointer ] NEW_LINE DEDENT DEDENT return max_files NEW_LINE DEDENT print ( intercepted_message ( ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE while True : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE op = input ( ) NEW_LINE b = int ( input ( ) ) NEW_LINE if op == " ? " : NEW_LINE INDENT break NEW_LINE DEDENT if op == " + " : NEW_LINE INDENT print ( a + b ) NEW_LINE DEDENT if op == " - " : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT if op == " * " : NEW_LINE INDENT print ( a * b ) NEW_LINE DEDENT if op == " / " : NEW_LINE INDENT print ( a / b ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT if i == N - 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif A [ i ] == A [ i + 1 ] : NEW_LINE INDENT pass NEW_LINE DEDENT elif A [ i ] < A [ i + 1 ] : NEW_LINE INDENT while A [ i ] <= A [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE if i == N - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT while A [ i ] >= A [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE if i == N - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 ] * MAX NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( countPairs ( s ) ) NEW_LINE DEDENT
import math NEW_LINE def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def sortedArray ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not prime [ arr [ i ] ] : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v [ j ] , end = " ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE arr = [ 100 , 11 , 500 , 2 , 17 , 1 ] NEW_LINE sortedArray ( arr , n ) NEW_LINE DEDENT
` ` ` python NEW_LINE from collections import defaultdict NEW_LINE def create_hash ( hash_set , max_element ) : NEW_LINE INDENT prev , curr = 0 , 1 NEW_LINE hash_set . add ( prev ) NEW_LINE hash_set . add ( curr ) NEW_LINE while curr <= max_element : NEW_LINE INDENT temp = curr + prev NEW_LINE hash_set . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def gcd_fibonacci_freq ( arr ) : NEW_LINE INDENT hash_set = set ( ) NEW_LINE create_hash ( hash_set , max ( arr ) ) NEW_LINE m = defaultdict ( int ) NEW_LINE for num in arr : NEW_LINE INDENT m [ num ] += 1 NEW_LINE DEDENT gcd = 0 NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT if value in hash_set : NEW_LINE INDENT gcd = __gcd ( gcd , key ) NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT return a if b == 0 else __gcd ( b , a % b ) NEW_LINE DEDENT arr = [ 5 , 3 , 6 , 5 , 6 , 6 , 5 , 5 ] NEW_LINE print ( gcd_fibonacci_freq ( arr ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - math . sqrt ( 2 ) ) NEW_LINE area = ( 3.14 * R * R ) / 2.0 NEW_LINE return area NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 4 NEW_LINE print ( " Area ▁ of ▁ semicircle ▁ = ▁ { : . 4f } " . format ( find_Area ( a ) ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def findQuadruples ( a , b , c , d , x , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT for l in range ( n ) : NEW_LINE INDENT if ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT x = 3 NEW_LINE a = [ 0 , 1 ] NEW_LINE b = [ 2 , 0 ] NEW_LINE c = [ 0 , 1 ] NEW_LINE d = [ 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findQuadruples ( a , b , c , d , x , n ) ) NEW_LINE DEDENT DEDENT
import java NEW_LINE class GFG : NEW_LINE INDENT class Query : NEW_LINE INDENT def __init__ ( self , l , r , n ) : NEW_LINE INDENT self . l = l NEW_LINE self . r = r NEW_LINE self . n = n NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def printSmallest ( s , q ) : NEW_LINE INDENT N = len ( s ) NEW_LINE H = [ [ 0 ] * 26 for _ in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT H [ i ] [ ord ( s [ i - 1 ] ) - ord ( ' a ' ) ] += 1 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT H [ i ] [ j ] += H [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT m = len ( q ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT l , r , n = q [ j ] . l , q [ j ] . r , q [ j ] . n NEW_LINE sum = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT sum += H [ r ] [ i ] - H [ l - 1 ] [ i ] NEW_LINE if sum >= n : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT s = " afbccdeb " NEW_LINE q = [ GFG . Query ( 2 , 4 , 1 ) , GFG . Query ( 1 , 6 , 4 ) , GFG . Query ( 1 , 8 , 7 ) ] NEW_LINE GFG . printSmallest ( s , q ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT testCases = int ( input ( ) ) NEW_LINE for _ in range ( testCases ) : NEW_LINE INDENT activating , placing , inputStr = map ( int , input ( ) . split ( ) ) NEW_LINE res = 0 NEW_LINE if placing >= activating : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( inputStr ) : NEW_LINE INDENT if inputStr [ i ] == '0' : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT res += activating NEW_LINE while i < len ( inputStr ) and inputStr [ i ] == '1' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT diff = activating // placing NEW_LINE firstOne = - 1 NEW_LINE for i in range ( len ( inputStr ) ) : NEW_LINE INDENT if inputStr [ i ] == '1' : NEW_LINE INDENT firstOne = i NEW_LINE break NEW_LINE DEDENT DEDENT if firstOne == - 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT array = [ ] NEW_LINE lastOne = firstOne NEW_LINE for i in range ( firstOne + 1 , len ( inputStr ) ) : NEW_LINE INDENT if inputStr [ i ] == '1' : NEW_LINE INDENT array . append ( i - lastOne - 1 ) NEW_LINE lastOne = i NEW_LINE DEDENT DEDENT res1 = 0 NEW_LINE for first in array : NEW_LINE INDENT if first <= diff : NEW_LINE INDENT res1 += first * placing NEW_LINE DEDENT else : NEW_LINE INDENT res1 += activating NEW_LINE DEDENT DEDENT res1 += activating NEW_LINE print ( res1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for j in range ( t ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if x == 1 : NEW_LINE INDENT print ( "2" ) NEW_LINE DEDENT elif x == 2 : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT elif x % 3 == 0 : NEW_LINE INDENT print ( x // 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x // 3 + 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def reverse ( s , last ) : NEW_LINE INDENT arr = list ( s ) NEW_LINE counter_up = 0 NEW_LINE counter_down = last NEW_LINE while counter_up <= last // 2 : NEW_LINE INDENT arr [ counter_up ] , arr [ counter_down ] = arr [ counter_down ] , arr [ counter_up ] NEW_LINE counter_up += 1 NEW_LINE counter_down -= 1 NEW_LINE DEDENT return ' ' . join ( arr ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT if t % i == 0 : NEW_LINE INDENT s = reverse ( s , i - 1 ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT ` ` ` NEW_LINE
import java . util . * ; NEW_LINE public class GFG { public static void printPairs ( int [ ] arr , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i + + ) { for ( int j = i + 1 ; j < n ; j + + ) { if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) { v . add ( Math . abs ( arr [ i ] ) ) ; } } } if ( v . size ( ) == 0 ) { return ; } Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i + + ) { System . out . print ( - v . get ( i ) + " ▁ " + v . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 4 , 8 , 9 , - 4 , 1 , - 1 , - 8 , - 9 } ; int n = arr . length ; printPairs ( arr , n ) ; } } NEW_LINE
` ` ` python NEW_LINE def doublefactorial ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * doublefactorial ( n - 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( " Double ▁ factorial ▁ is " , doublefactorial ( 5 ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import java NEW_LINE def isPalindrome ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while h > l : NEW_LINE INDENT if str [ l ] != str [ h ] : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minRemovals ( str ) : NEW_LINE INDENT if str [ 0 ] == '0' : NEW_LINE INDENT return 0 NEW_LINE DEDENT if isPalindrome ( str ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT print ( minRemovals ( "010010" ) ) NEW_LINE print ( minRemovals ( "0100101" ) ) NEW_LINE
` ` ` python NEW_LINE def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ 0 ] * n NEW_LINE sumofdigit [ 0 ] = int ( num [ 0 ] ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = int ( num [ i ] ) NEW_LINE sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT num = "1234" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * ( a // n ) * ( b // n ) NEW_LINE ans += ( a // n ) * ( b % n ) NEW_LINE ans += ( a % n ) * ( b // n ) NEW_LINE ans += ( ( a % n ) + ( b % n ) ) // n NEW_LINE return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class p071 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT LIMIT = 1000000 NEW_LINE def run ( self ) : NEW_LINE INDENT maxN = 0 NEW_LINE maxD = 1 NEW_LINE for d in range ( 1 , self . LIMIT + 1 ) : NEW_LINE INDENT n = d * 3 // 7 NEW_LINE if d % 7 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT if n * maxD > maxN * d : NEW_LINE INDENT maxN = n NEW_LINE maxD = d NEW_LINE DEDENT DEDENT return str ( maxN ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT c = [ 0 ] * 100 NEW_LINE @ staticmethod NEW_LINE def coef ( n ) : NEW_LINE INDENT GFG . c [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT GFG . c [ 0 ] = - GFG . c [ 0 ] NEW_LINE GFG . c [ i + 1 ] = 1 NEW_LINE for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT GFG . c [ j ] = GFG . c [ j - 1 ] - GFG . c [ j ] NEW_LINE DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def isPrime ( n ) : NEW_LINE INDENT GFG . coef ( n ) NEW_LINE GFG . c [ 0 ] += 1 NEW_LINE GFG . c [ n ] -= 1 NEW_LINE i = n NEW_LINE while i > 0 and GFG . c [ i ] % n == 0 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT return i < 0 NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT n = 37 NEW_LINE if GFG . isPrime ( n ) : NEW_LINE INDENT print ( " Prime " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime " ) NEW_LINE DEDENT DEDENT DEDENT
class GFG : NEW_LINE INDENT def count_greater ( arr , n ) : NEW_LINE INDENT min_val = float ( ' inf ' ) NEW_LINE counter = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] > min_val : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT if arr [ i ] <= min_val : NEW_LINE INDENT min_val = arr [ i ] NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( count_greater ( arr , n ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE N , x = map ( int , input ( ) . split ( ) ) NEW_LINE sweet = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sweet . sort ( ) NEW_LINE num = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if x - sweet [ num ] >= 0 : NEW_LINE INDENT x -= sweet [ num ] NEW_LINE num += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if num == N and x > 0 : NEW_LINE INDENT num -= 1 NEW_LINE DEDENT print ( num ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT casos = int ( input ( ) ) NEW_LINE conta = 0 NEW_LINE cont = 0 NEW_LINE for i in range ( casos ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x > 0 : NEW_LINE INDENT conta += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cont += 1 NEW_LINE DEDENT DEDENT if conta > 1 and cont > 1 : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT T , D , L = map ( int , input ( ) . split ( ) ) NEW_LINE if T == 0 and D == 0 and L == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = 0 NEW_LINE time = 0 NEW_LINE for i in range ( T - 1 ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if x >= L : NEW_LINE INDENT time = D - 1 NEW_LINE ans += 1 NEW_LINE DEDENT elif time != 0 : NEW_LINE INDENT time -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT input ( ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java NEW_LINE def minimumSwaps ( arr ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT if arr [ i ] != i + 1 : NEW_LINE INDENT while arr [ i ] != i + 1 : NEW_LINE INDENT temp = arr [ arr [ i ] - 1 ] NEW_LINE arr [ arr [ i ] - 1 ] = arr [ i ] NEW_LINE arr [ i ] = temp NEW_LINE count += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 1 , 5 ] NEW_LINE print ( minimumSwaps ( arr ) ) NEW_LINE DEDENT
import queue NEW_LINE class p500 : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . TARGET = 500500 NEW_LINE self . MODULUS = 500500507 NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT queue = [ ] NEW_LINE nextPrime = 2 NEW_LINE queue . append ( nextPrime ) NEW_LINE product = 1 NEW_LINE for i in range ( self . TARGET ) : NEW_LINE INDENT item = queue . pop ( 0 ) NEW_LINE product *= item % self . MODULUS NEW_LINE product %= self . MODULUS NEW_LINE queue . append ( item * item ) NEW_LINE if item == nextPrime : NEW_LINE INDENT nextPrime += 1 NEW_LINE while not self . isPrime ( nextPrime ) : NEW_LINE INDENT nextPrime += 1 NEW_LINE DEDENT queue . append ( nextPrime ) NEW_LINE DEDENT DEDENT return str ( product ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def findUniquePair ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE DEDENT set_bit_no = XOR & ~ ( XOR - 1 ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) > 0 : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ unique ▁ pair ▁ is ▁ ( " + str ( x ) + " , ▁ " + str ( y ) + " ) " ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = [ 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 ] NEW_LINE n = len ( a ) NEW_LINE GFG . findUniquePair ( a , n ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class CustomScanner : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input_buffer = [ ] NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT if not self . input_buffer : NEW_LINE INDENT self . input_buffer = input ( ) . split ( ) NEW_LINE DEDENT return self . input_buffer . pop ( 0 ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT cs = CustomScanner ( ) NEW_LINE n = cs . nextInt ( ) NEW_LINE xch , nxch = ' \u0000' , ' \u0000' NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = cs . next ( ) NEW_LINE if i == 0 : NEW_LINE INDENT xch = line [ 0 ] NEW_LINE nxch = line [ 1 ] NEW_LINE DEDENT if xch == nxch : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if j == i or j == n - i - 1 : NEW_LINE INDENT if line [ j ] != xch : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if line [ j ] != nxch : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " YES " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def doIt ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT str = input ( ) NEW_LINE len = len ( str ) NEW_LINE i = 0 NEW_LINE while i < len : NEW_LINE INDENT now = str [ i ] NEW_LINE if now != ' @ ' : NEW_LINE INDENT print ( now , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE num = int ( str [ i ] ) NEW_LINE i += 1 NEW_LINE if 0 <= num <= 9 : NEW_LINE INDENT now = str [ i ] NEW_LINE for j in range ( num ) : NEW_LINE INDENT print ( now , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT obj = Main ( ) NEW_LINE obj . doIt ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
from collections import defaultdict NEW_LINE def isMajority ( a , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in mp : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT for key , value in mp . items ( ) : NEW_LINE INDENT if value >= n / 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if isMajority ( a , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class Knap : NEW_LINE INDENT def __init__ ( self , value , weight ) : NEW_LINE INDENT self . value = value NEW_LINE self . weight = weight NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return self . value * other . weight > other . value * self . weight NEW_LINE DEDENT DEDENT def dfw ( idx , weight ) : NEW_LINE INDENT if weight < 0 : NEW_LINE INDENT return float ( ' - inf ' ) NEW_LINE DEDENT if idx < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ idx ] [ weight ] != 0 : NEW_LINE INDENT return dp [ idx ] [ weight ] NEW_LINE DEDENT if weight % knaps [ idx ] . weight == 0 : NEW_LINE INDENT dp [ idx ] [ weight ] = weight // knaps [ idx ] . weight * knaps [ idx ] . value NEW_LINE return dp [ idx ] [ weight ] NEW_LINE DEDENT max_val = 0 NEW_LINE for i in range ( weight // knaps [ idx ] . weight + 1 ) : NEW_LINE INDENT max_val = max ( max_val , dfw ( idx - 1 , weight - knaps [ idx ] . weight * i ) + knaps [ idx ] . value * i ) NEW_LINE DEDENT dp [ idx ] [ weight ] = max_val NEW_LINE return dp [ idx ] [ weight ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , w = map ( int , input ( ) . split ( ) ) NEW_LINE knaps = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT value , weight = map ( int , input ( ) . split ( ) ) NEW_LINE knaps . append ( Knap ( value , weight ) ) NEW_LINE DEDENT knaps . sort ( ) NEW_LINE dp = [ [ 0 ] * ( w + 1 ) for _ in range ( n ) ] NEW_LINE print ( dfw ( n - 1 , w ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def doIt ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE while n != - 1 : NEW_LINE INDENT rad = 0 NEW_LINE hyp = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT rad += math . atan ( 1 / hyp ) NEW_LINE hyp = math . sqrt ( hyp * hyp + 1 ) NEW_LINE DEDENT print ( hyp * math . cos ( rad ) ) NEW_LINE print ( hyp * math . sin ( rad ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT doIt ( ) NEW_LINE DEDENT
import numpy as np NEW_LINE def printKMissing ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while i < n and arr [ i ] <= 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT count = 0 NEW_LINE curr = 1 NEW_LINE while count < k and i < n : NEW_LINE INDENT if arr [ i ] != curr : NEW_LINE INDENT print ( curr , end = " ▁ " ) NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT curr += 1 NEW_LINE DEDENT while count < k : NEW_LINE INDENT print ( curr , end = " ▁ " ) NEW_LINE curr += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = np . array ( [ 2 , 3 , 4 ] ) NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printKMissing ( arr , n , k ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def printNumbers ( a , n ) : NEW_LINE INDENT mpp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE for j in range ( 1 , int ( num ** 0.5 ) + 1 ) : NEW_LINE INDENT if num % j == 0 : NEW_LINE INDENT if j != 1 : NEW_LINE INDENT if j in mpp : NEW_LINE INDENT mpp [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ j ] = 1 NEW_LINE DEDENT DEDENT if ( num // j ) != j : NEW_LINE INDENT if ( num // j ) in mpp : NEW_LINE INDENT mpp [ num // j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ num // j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT maxi = 0 NEW_LINE for key , value in mpp . items ( ) : NEW_LINE INDENT maxi = max ( value , maxi ) NEW_LINE DEDENT for key , value in mpp . items ( ) : NEW_LINE INDENT if value == maxi : NEW_LINE INDENT print ( key , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT a = [ 12 , 15 , 27 , 20 , 40 ] NEW_LINE n = len ( a ) NEW_LINE GFG . printNumbers ( a , n ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE index = s . find ( " a " ) NEW_LINE aCnt = 0 NEW_LINE while index != - 1 : NEW_LINE INDENT aCnt += 1 NEW_LINE index = s . find ( " a " , index + 1 ) NEW_LINE DEDENT sLength = ( len ( s ) - aCnt ) // 2 NEW_LINE s = s [ : len ( s ) - sLength ] NEW_LINE s2 = s NEW_LINE r = s [ len ( s ) - sLength : ] NEW_LINE s = s . replace ( " a " , " " ) NEW_LINE if s == r : NEW_LINE INDENT print ( s2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " : ( " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class Voting : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE max_count = 0 NEW_LINE a = [ 0 ] * 1000001 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b = int ( input ( ) ) NEW_LINE a [ b ] += 1 NEW_LINE if a [ b ] > max_count : NEW_LINE INDENT max_count = a [ b ] NEW_LINE ans = b NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT class FScanner : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = sys . stdin NEW_LINE self . sb = " " NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . sb : NEW_LINE INDENT self . sb = self . br . readline ( ) NEW_LINE DEDENT return self . sb NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT DEDENT voting = Voting ( ) NEW_LINE voting . main ( sys . argv ) NEW_LINE
class GFG : NEW_LINE INDENT def checkIfStartsWithCapital ( str ) : NEW_LINE INDENT if ord ( str [ 0 ] ) >= 65 and ord ( str [ 0 ] ) <= 90 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def check ( str ) : NEW_LINE INDENT if GFG . checkIfStartsWithCapital ( str ) == 1 : NEW_LINE INDENT print ( " Accepted " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Accepted " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT str = " GeeksforGeeks " NEW_LINE GFG . check ( str ) NEW_LINE str = " geeksforgeeks " NEW_LINE GFG . check ( str ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( prev_avg * n + x ) / ( n + 1 ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) NEW_LINE print ( " Average ▁ of ▁ " + str ( i + 1 ) + " ▁ numbers ▁ is ▁ " + " { : . 1f } " . format ( avg ) ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE streamAvg ( arr , n ) NEW_LINE DEDENT DEDENT
class p050 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT LIMIT = Library . pow ( 10 , 6 ) NEW_LINE def run ( self ) : NEW_LINE INDENT isPrime = Library . listPrimality ( LIMIT ) NEW_LINE primes = Library . listPrimes ( LIMIT ) NEW_LINE maxSum = 0 NEW_LINE maxRun = - 1 NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , len ( primes ) ) : NEW_LINE INDENT sum += primes [ j ] NEW_LINE if sum > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT elif j - i > maxRun and sum > maxSum and isPrime [ sum ] : NEW_LINE INDENT maxSum = sum NEW_LINE maxRun = j - i NEW_LINE DEDENT DEDENT DEDENT return str ( maxSum ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def lis ( arr , n ) : NEW_LINE INDENT max_val = 0 NEW_LINE lst = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] and lst [ i ] < lst [ j ] + 1 : NEW_LINE INDENT lst [ i ] = lst [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max_val < lst [ i ] : NEW_LINE INDENT max_val = lst [ i ] NEW_LINE DEDENT DEDENT return max_val NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ lst ▁ is " , GFG . lis ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def main ( ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE k = int ( math . log10 ( b ) + 1 ) NEW_LINE a = int ( a * math . pow ( 10 , k ) + b ) NEW_LINE yono = math . sqrt ( a ) NEW_LINE if yono - math . ceil ( yono ) == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def fix ( A ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT s . add ( A [ i ] ) NEW_LINE DEDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if i in s : NEW_LINE INDENT A [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = - 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT A = [ - 1 , - 1 , 6 , 1 , 9 , 3 , 2 , - 1 , 4 , - 1 ] NEW_LINE print ( GFG . fix ( A ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . systemin = sys . stdin NEW_LINE self . log = None NEW_LINE self . result = sys . stdout NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE sum = a + b + c + d NEW_LINE s1 = abs ( sum - ( a + b ) * 2 ) NEW_LINE s2 = abs ( sum - ( a + c ) * 2 ) NEW_LINE s3 = abs ( sum - ( a + d ) * 2 ) NEW_LINE min_val = min ( s1 , s2 , s3 ) NEW_LINE print ( min_val ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT instance = Main ( ) NEW_LINE instance . main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = GFG . Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if head_ref is not None : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT @ staticmethod NEW_LINE def makeOddNode ( head_ref , A , n ) : NEW_LINE INDENT ptr = head_ref NEW_LINE i = 0 NEW_LINE while ptr is not None : NEW_LINE INDENT next_node = ptr . next NEW_LINE if ptr . data % 2 == 0 : NEW_LINE INDENT ptr . data = A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ptr = next_node NEW_LINE DEDENT return head_ref NEW_LINE DEDENT @ staticmethod NEW_LINE def printList ( head ) : NEW_LINE INDENT while head is not None : NEW_LINE INDENT print ( head . data , end = " ▁ " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT head = None NEW_LINE Arr = [ 3 , 5 , 23 , 17 , 1 ] NEW_LINE head = self . push ( head , 4 ) NEW_LINE head = self . push ( head , 7 ) NEW_LINE head = self . push ( head , 8 ) NEW_LINE head = self . push ( head , 9 ) NEW_LINE head = self . push ( head , 6 ) NEW_LINE n = len ( Arr ) NEW_LINE print ( " Original ▁ List : ▁ " , end = " " ) NEW_LINE self . printList ( head ) NEW_LINE print ( ) NEW_LINE head = self . makeOddNode ( head , Arr , n ) NEW_LINE print ( " New ▁ odd ▁ List : ▁ " , end = " " ) NEW_LINE self . printList ( head ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE
import sys NEW_LINE def dfs ( depth , sum , dp , use ) : NEW_LINE INDENT dp [ depth - 1 ] [ sum ] += 1 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if not use [ i ] : NEW_LINE INDENT use [ i ] = True NEW_LINE dfs ( depth + 1 , sum + depth * i , dp , use ) NEW_LINE use [ i ] = False NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT dp = [ [ 0 for _ in range ( 331 ) ] for _ in range ( 11 ) ] NEW_LINE use = [ False for _ in range ( 10 ) ] NEW_LINE dfs ( 1 , 0 , dp , use ) NEW_LINE for line in sys . stdin : NEW_LINE INDENT values = line . split ( ) NEW_LINE n = int ( values [ 0 ] ) NEW_LINE s = int ( values [ 1 ] ) NEW_LINE if n > 10 or s > 330 : NEW_LINE INDENT print ( "0" ) NEW_LINE continue NEW_LINE DEDENT print ( dp [ n ] [ s ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE mod = 1000000007 NEW_LINE def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def powmod ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT pt = powmod ( a , n // 2 ) NEW_LINE pt = ( pt * pt ) % mod NEW_LINE if n % 2 == 1 : NEW_LINE INDENT return ( pt * a ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return pt NEW_LINE DEDENT DEDENT def CountSubset ( arr , n ) : NEW_LINE INDENT ans = powmod ( 2 , n - 1 ) NEW_LINE arr . sort ( ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = i + 1 NEW_LINE while j < n and arr [ j ] == arr [ i ] : NEW_LINE INDENT r = n - 1 - j NEW_LINE l = i NEW_LINE ans = ( ans + nCr ( l + r , l ) ) % mod NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubset ( arr , n ) ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT MAX = 1000001 NEW_LINE primeUpto = [ 0 ] * MAX NEW_LINE @ staticmethod NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime = [ 1 ] * GFG . MAX NEW_LINE isPrime [ 0 ] = isPrime [ 1 ] = 0 NEW_LINE for i in range ( 2 , int ( GFG . MAX ** 0.5 ) + 1 ) : NEW_LINE INDENT if isPrime [ i ] == 1 : NEW_LINE INDENT for j in range ( i * 2 , GFG . MAX , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , GFG . MAX ) : NEW_LINE INDENT GFG . primeUpto [ i ] = GFG . primeUpto [ i - 1 ] NEW_LINE if isPrime [ i ] == 1 : NEW_LINE INDENT GFG . primeUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def countOfNumbers ( N , K ) : NEW_LINE INDENT GFG . SieveOfEratosthenes ( ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if mid - GFG . primeUpto [ mid ] >= K : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT ans = ans if ans != 0 else 0 NEW_LINE return N - ans + 1 NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT N , K = 10 , 3 NEW_LINE print ( GFG . countOfNumbers ( N , K ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countOperations ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i ) < n and ( n % i ) > 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i * i ) > n : NEW_LINE INDENT i = n NEW_LINE DEDENT return ( 1 + ( n - i ) // 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( countOperations ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def exec_func ( in_data , out_data ) : NEW_LINE INDENT in_data . readline ( ) NEW_LINE Q = int ( in_data . readline ( ) ) NEW_LINE S = in_data . readline ( ) . strip ( ) NEW_LINE t = [ 0 ] * len ( S ) NEW_LINE for i in range ( len ( t ) - 1 ) : NEW_LINE INDENT if S [ i ] == ' A ' and S [ i + 1 ] == ' C ' : NEW_LINE INDENT t [ i + 1 ] = t [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT t [ i + 1 ] = t [ i ] NEW_LINE DEDENT DEDENT for i in range ( Q ) : NEW_LINE INDENT l , r = map ( int , in_data . readline ( ) . split ( ) ) NEW_LINE out_data . write ( str ( t [ r - 1 ] - t [ l - 1 ] ) + ' \n ' ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT exec_func ( sys . stdin , sys . stdout ) NEW_LINE DEDENT
import sys NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT try : NEW_LINE INDENT l = input ( ) NEW_LINE r = input ( ) NEW_LINE print ( l + " ▁ " + str ( int ( l ) * 2 ) ) NEW_LINE DEDENT except : NEW_LINE INDENT sys . exit ( 0 ) NEW_LINE DEDENT DEDENT sys . exit ( 0 ) NEW_LINE
class p249 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . LIMIT = 5000 NEW_LINE self . MODULUS = 10000000000000000 NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT isPrime = Library . listPrimality ( self . LIMIT * self . LIMIT / 2 ) NEW_LINE numSubsets = [ 0 ] * ( self . LIMIT * self . LIMIT / 2 ) NEW_LINE numSubsets [ 0 ] = 1 NEW_LINE maxSum = 0 NEW_LINE for i in range ( self . LIMIT ) : NEW_LINE INDENT if not isPrime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT maxSum += i NEW_LINE for j in range ( maxSum , i , - 1 ) : NEW_LINE INDENT temp = numSubsets [ j ] + numSubsets [ j - i ] NEW_LINE if temp < self . MODULUS : NEW_LINE INDENT numSubsets [ j ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT numSubsets [ j ] = temp - self . MODULUS NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( len ( numSubsets ) ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT sum = ( sum + numSubsets [ i ] ) % self . MODULUS NEW_LINE DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def countOddNumber ( row_num ) : NEW_LINE INDENT count = 0 NEW_LINE while row_num > 0 : NEW_LINE INDENT count += row_num & 1 NEW_LINE row_num >>= 1 NEW_LINE DEDENT return ( 1 << count ) NEW_LINE DEDENT def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( n ) : NEW_LINE INDENT print ( countOddNumber ( row_num ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 16 NEW_LINE gouldSequence ( n ) NEW_LINE DEDENT DEDENT
from collections import deque NEW_LINE deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE def findMin ( V ) : NEW_LINE INDENT ans = deque ( ) NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT while V >= deno [ i ] : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 93 NEW_LINE print ( " Following ▁ is ▁ minimal ▁ number ▁ of ▁ change ▁ for " , n , " : ▁ " , end = " " ) NEW_LINE findMin ( n ) NEW_LINE DEDENT
` ` ` python NEW_LINE import array NEW_LINE class p052 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT i = 1 NEW_LINE while True : NEW_LINE INDENT if i > ( 2 ** 31 - 1 ) / 6 : NEW_LINE INDENT raise ArithmeticError ( " Overflow " ) NEW_LINE DEDENT if self . multiplesHaveSameDigits ( i ) : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def multiplesHaveSameDigits ( self , x ) : NEW_LINE INDENT for i in range ( 2 , 7 ) : NEW_LINE INDENT if self . toSortedDigits ( x ) != self . toSortedDigits ( i * x ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def toSortedDigits ( self , x ) : NEW_LINE INDENT result = list ( str ( x ) ) NEW_LINE result . sort ( ) NEW_LINE return result NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE def count ( arr , n , x ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % x == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 NEW_LINE return ans NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE
import numpy as np NEW_LINE def findEle ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE sum = np . sum ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == sum - arr [ i ] : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 6 ] NEW_LINE print ( findEle ( arr ) ) NEW_LINE
class GFG : NEW_LINE INDENT def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT m1 = [ 0 ] * 256 NEW_LINE for i in range ( len ( strB ) ) : NEW_LINE INDENT m1 [ ord ( strB [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( strA ) ) : NEW_LINE INDENT m1 [ ord ( strA [ i ] ) ] -= 1 NEW_LINE DEDENT for i in range ( len ( m1 ) ) : NEW_LINE INDENT if m1 [ i ] == 1 : NEW_LINE INDENT return chr ( i ) NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT strA = " abcd " NEW_LINE strB = " cbdad " NEW_LINE print ( findExtraCharcter ( list ( strA ) , list ( strB ) ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = Scanner ( ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT Main ( ) NEW_LINE DEDENT DEDENT class aoj1216 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = [ 0 ] * 101 NEW_LINE self . b = [ 0 ] * 101 NEW_LINE DEDENT def doIt ( self ) : NEW_LINE INDENT for i in range ( 101 ) : NEW_LINE INDENT self . a [ i ] = i * i * i NEW_LINE DEDENT for i in range ( 101 ) : NEW_LINE INDENT self . b [ i ] = i * ( i + 1 ) * ( i + 2 ) / 6 NEW_LINE DEDENT while True : NEW_LINE INDENT n = self . sc . nextInt ( ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( 101 ) : NEW_LINE INDENT for j in range ( 101 ) : NEW_LINE INDENT if self . a [ i ] + self . b [ j ] <= n : NEW_LINE INDENT num = max ( num , self . a [ i ] + self . b [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( num ) NEW_LINE DEDENT DEDENT DEDENT
from collections import deque NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT conv = [ input ( ) . split ( ) for _ in range ( n ) ] NEW_LINE before = input ( ) NEW_LINE after = input ( ) NEW_LINE deque = deque ( ) NEW_LINE deque . append ( before ) NEW_LINE depth = 0 NEW_LINE convertable = False NEW_LINE while deque : NEW_LINE INDENT depth += 1 NEW_LINE size = len ( deque ) NEW_LINE for _ in range ( size ) : NEW_LINE INDENT poll = deque . popleft ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT test = poll . replace ( conv [ i ] [ 0 ] , conv [ i ] [ 1 ] ) NEW_LINE if test == poll : NEW_LINE INDENT continue NEW_LINE DEDENT elif test == after : NEW_LINE INDENT convertable = True NEW_LINE break NEW_LINE DEDENT elif len ( test ) <= len ( after ) : NEW_LINE INDENT deque . append ( test ) NEW_LINE DEDENT DEDENT if convertable : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if convertable : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if convertable : NEW_LINE INDENT print ( depth ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE freq = [ 0 ] * 1010 NEW_LINE can = ( n + 1 ) NEW_LINE for i in a : NEW_LINE INDENT freq [ i ] += 1 NEW_LINE if freq [ i ] > can / 2 : NEW_LINE INDENT sb . append ( " NO " ) NEW_LINE return NEW_LINE DEDENT DEDENT sb . append ( " YES " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT t = 1 NEW_LINE for tests in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT print ( sb ) NEW_LINE DEDENT
class AAB : NEW_LINE INDENT @ staticmethod NEW_LINE def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = float ( ' - inf ' ) NEW_LINE max2 = float ( ' - inf ' ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if arr1 [ i ] > max1 : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( n2 ) : NEW_LINE INDENT if arr2 [ i ] > max2 : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( AAB . maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def operations ( op , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE count = 0 NEW_LINE nVal = 0 NEW_LINE min_val = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT nVal += op [ i ] NEW_LINE min_val = min ( min_val , nVal ) NEW_LINE if ( k + nVal ) <= 0 : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT if nVal >= 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT times = ( k - abs ( min_val ) ) // abs ( nVal ) NEW_LINE k = k - ( times * abs ( nVal ) ) NEW_LINE count = times * n NEW_LINE while k > 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT k = k + op [ i ] NEW_LINE count += 1 NEW_LINE if k <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT op = [ - 60 , 65 , - 1 , 14 , - 25 ] NEW_LINE n = len ( op ) NEW_LINE k = 100000 NEW_LINE print ( operations ( op , n , k ) ) NEW_LINE DEDENT
import math NEW_LINE class GFG : NEW_LINE INDENT pref = [ 0 ] * 100010 NEW_LINE @ staticmethod NEW_LINE def isPerfectCube ( x ) : NEW_LINE INDENT cr = round ( math . pow ( x , 1 / 3 ) ) NEW_LINE if cr * cr * cr == x : NEW_LINE INDENT return x NEW_LINE DEDENT return 0 NEW_LINE DEDENT @ staticmethod NEW_LINE def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT GFG . pref [ i ] = GFG . pref [ i - 1 ] + GFG . isPerfectCube ( i ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def printSum ( L , R ) : NEW_LINE INDENT sum = GFG . pref [ R ] - GFG . pref [ L - 1 ] NEW_LINE print ( sum , end = " ▁ " ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT GFG . compute ( ) NEW_LINE Q = 4 NEW_LINE arr = [ [ 1 , 10 ] , [ 1 , 100 ] , [ 2 , 25 ] , [ 4 , 50 ] ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT GFG . printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT GFG . main ( ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT N , R , L = map ( int , input ( ) . split ( ) ) NEW_LINE po = [ 0 ] * N NEW_LINE c = [ 0 ] * N NEW_LINE now = 0 NEW_LINE index = 0 NEW_LINE for _ in range ( R ) : NEW_LINE INDENT d , t , x = map ( int , input ( ) . split ( ) ) NEW_LINE d -= 1 NEW_LINE c [ index ] += t - now NEW_LINE po [ d ] += x NEW_LINE now = t NEW_LINE if x > 0 : NEW_LINE INDENT if d == index : NEW_LINE INDENT continue NEW_LINE DEDENT if po [ index ] < po [ d ] : NEW_LINE INDENT index = d NEW_LINE DEDENT elif po [ index ] == po [ d ] and index > d : NEW_LINE INDENT index = d NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if d != index : NEW_LINE INDENT continue NEW_LINE DEDENT maxp = float ( ' - inf ' ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT if maxp < po [ j ] : NEW_LINE INDENT maxp = po [ j ] NEW_LINE index = j NEW_LINE DEDENT DEDENT DEDENT DEDENT c [ index ] += L - now NEW_LINE ans = 0 NEW_LINE max_val = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if c [ i ] > max_val : NEW_LINE INDENT max_val = c [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT print ( ans + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( str ( n ) + " th ▁ Centered " + " ▁ cube ▁ number : ▁ " + str ( centered_cube ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( str ( n ) + " th ▁ Centered " + " ▁ cube ▁ number : ▁ " + str ( centered_cube ( n ) ) ) NEW_LINE DEDENT
import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = sys . stdin NEW_LINE self . st = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st is None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = self . br . readline ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT return self . br . readline ( ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT obj = FastReader ( ) NEW_LINE tc = obj . nextInt ( ) NEW_LINE while tc != 0 : NEW_LINE INDENT n = obj . nextInt ( ) NEW_LINE arr = list ( obj . next ( ) ) NEW_LINE r = n - 1 NEW_LINE l = - 1 NEW_LINE while r >= 0 and arr [ r ] == '1' : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT while l + 1 < n and arr [ 0 ] == '0' and arr [ l + 1 ] == '0' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT flag = [ False ] * n NEW_LINE for i in range ( l + 1 ) : NEW_LINE INDENT flag [ i ] = True NEW_LINE DEDENT for i in range ( n - 1 , max ( r , 0 ) - 1 , - 1 ) : NEW_LINE INDENT flag [ i ] = True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if flag [ i ] : NEW_LINE INDENT sys . stdout . write ( arr [ i ] ) NEW_LINE DEDENT DEDENT sys . stdout . write ( ' \n ' ) NEW_LINE tc -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT nth += math . pow ( i , i ) NEW_LINE DEDENT return nth NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Test : NEW_LINE INDENT def main ( args ) : NEW_LINE INDENT print ( " True " if isPower ( 10 , 1 ) else " False " ) NEW_LINE print ( " True " if isPower ( 1 , 20 ) else " False " ) NEW_LINE print ( " True " if isPower ( 2 , 128 ) else " False " ) NEW_LINE print ( " True " if isPower ( 2 , 30 ) else " False " ) NEW_LINE DEDENT def isPower ( x , y ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return y == 1 NEW_LINE DEDENT pow = 1 NEW_LINE while pow < y : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return pow == y NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class Test : NEW_LINE INDENT def main ( args ) : NEW_LINE INDENT print ( 1 if isPower ( 10 , 1 ) else 0 ) NEW_LINE print ( 1 if isPower ( 1 , 20 ) else 0 ) NEW_LINE print ( 1 if isPower ( 2 , 128 ) else 0 ) NEW_LINE print ( 1 if isPower ( 2 , 30 ) else 0 ) NEW_LINE DEDENT def isPower ( x , y ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return y == 1 NEW_LINE DEDENT pow = 1 NEW_LINE while pow < y : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return pow == y NEW_LINE DEDENT DEDENT
import numpy as np NEW_LINE def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE answer = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] NEW_LINE DEDENT return answer * ( 2 * k - 2 ) NEW_LINE DEDENT arr = [ 4 , 21 , 5 , 3 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( minimumValue ( arr , n , k ) ) NEW_LINE
import queue NEW_LINE N = int ( input ( ) ) NEW_LINE vs = set ( ) NEW_LINE indeg = { } NEW_LINE outdeg = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT u , d , rel = input ( ) . split ( ) NEW_LINE u = ' u ' + u NEW_LINE d = ' d ' + d NEW_LINE vs . add ( u ) NEW_LINE vs . add ( d ) NEW_LINE indeg . setdefault ( u , set ( ) ) NEW_LINE indeg . setdefault ( d , set ( ) ) NEW_LINE outdeg . setdefault ( u , set ( ) ) NEW_LINE outdeg . setdefault ( d , set ( ) ) NEW_LINE if rel == " lock " : NEW_LINE INDENT indeg [ u ] . add ( d ) NEW_LINE outdeg [ d ] . add ( u ) NEW_LINE DEDENT else : NEW_LINE INDENT indeg [ d ] . add ( u ) NEW_LINE outdeg [ u ] . add ( d ) NEW_LINE DEDENT DEDENT que = queue . Queue ( ) NEW_LINE for v in indeg . keys ( ) : NEW_LINE INDENT if len ( indeg [ v ] ) == 0 : NEW_LINE INDENT que . put ( v ) NEW_LINE DEDENT DEDENT while not que . empty ( ) : NEW_LINE INDENT u = que . get ( ) NEW_LINE for v in outdeg [ u ] : NEW_LINE INDENT indeg [ v ] . remove ( u ) NEW_LINE if len ( indeg [ v ] ) == 0 : NEW_LINE INDENT que . put ( v ) NEW_LINE DEDENT DEDENT vs . remove ( u ) NEW_LINE DEDENT print ( 0 if len ( vs ) == 0 else 1 ) NEW_LINE
def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) / 2 NEW_LINE if N == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( 2 ** ( E - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def __gcd ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def findLCM ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // __gcd ( arr [ i ] , lcm ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def countNumbers ( arr , n , l , r ) : NEW_LINE INDENT lcm = findLCM ( arr , n ) NEW_LINE count = ( r // lcm ) - ( ( l - 1 ) // lcm ) NEW_LINE return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countNumbers ( arr , n , l , r ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = min ( n , 4 ) NEW_LINE num = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE num . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( a ) : NEW_LINE INDENT for j in range ( a ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT ans . append ( int ( str ( num [ i ] ) + str ( num [ j ] ) ) ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE print ( ans [ 2 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE import math NEW_LINE def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE op = " " NEW_LINE for _ in range ( T ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE area = a [ 0 ] * a [ - 1 ] NEW_LINE yes = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT lf = i * 2 NEW_LINE rg = 4 * n - ( i * 2 ) - 1 NEW_LINE if a [ lf ] != a [ lf + 1 ] or a [ rg ] != a [ rg - 1 ] or a [ lf ] * a [ rg ] != area : NEW_LINE INDENT yes = False NEW_LINE break NEW_LINE DEDENT DEDENT if yes : NEW_LINE INDENT op += " YES \n " NEW_LINE DEDENT else : NEW_LINE INDENT op += " NO \n " NEW_LINE DEDENT DEDENT print ( op ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def MinDeletion ( a , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for x , frequency in mp . items ( ) : NEW_LINE INDENT if x <= frequency : NEW_LINE INDENT ans += ( frequency - x ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += frequency NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE print ( MinDeletion ( a , n ) ) NEW_LINE DEDENT
class DeleteN : NEW_LINE INDENT def main ( args ) : NEW_LINE INDENT in_ = 1234 NEW_LINE inp = str ( in_ ) NEW_LINE del_ = 3 NEW_LINE print ( " num _ after _ deleting _ from _ starting ▁ " + fromStart ( inp , del_ ) ) NEW_LINE print ( " num _ after _ deleting _ from _ ending ▁ " + fromEnd ( inp , del_ ) ) NEW_LINE DEDENT def fromStart ( inp , del_ ) : NEW_LINE INDENT try : NEW_LINE INDENT inp1 = inp [ 0 : del_ - 1 ] NEW_LINE inp2 = inp [ del_ : len ( inp ) ] NEW_LINE return inp1 + inp2 NEW_LINE DEDENT except : NEW_LINE INDENT return " Check ▁ Input " NEW_LINE DEDENT DEDENT def fromEnd ( inp , del_ ) : NEW_LINE INDENT try : NEW_LINE INDENT inp1 = inp [ 0 : len ( inp ) - del_ ] NEW_LINE inp2 = inp [ len ( inp ) - del_ + 1 : len ( inp ) ] NEW_LINE return inp1 + inp2 NEW_LINE DEDENT except : NEW_LINE INDENT return " Check ▁ Input " NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE def nondecdigits ( n ) : NEW_LINE INDENT x = 0 NEW_LINE for x in range ( n , 0 , - 1 ) : NEW_LINE INDENT no = x NEW_LINE prev_dig = 11 NEW_LINE flag = True NEW_LINE while no != 0 : NEW_LINE INDENT if prev_dig < no % 10 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev_dig = no % 10 NEW_LINE no //= 10 NEW_LINE DEDENT if flag == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 200 NEW_LINE print ( nondecdigits ( n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 == x2 : NEW_LINE INDENT dif = abs ( y1 - y2 ) NEW_LINE print ( x1 + dif , y1 , x1 + dif , y2 ) NEW_LINE DEDENT elif y1 == y2 : NEW_LINE INDENT dif = abs ( x1 - x2 ) NEW_LINE print ( x1 , y1 + dif , x2 , y2 + dif ) NEW_LINE DEDENT elif abs ( x1 - x2 ) == abs ( y1 - y2 ) : NEW_LINE INDENT print ( x1 , y2 , x2 , y1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def canTake ( xNeeded , xAvailable , yNeeded , yAvailable ) : NEW_LINE INDENT if xNeeded > xAvailable : NEW_LINE INDENT return False NEW_LINE DEDENT if yNeeded > yAvailable : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE turn = 0 NEW_LINE while True : NEW_LINE INDENT if turn % 2 == 0 : NEW_LINE INDENT if canTake ( 2 , x , 2 , y ) : NEW_LINE INDENT x -= 2 NEW_LINE y -= 2 NEW_LINE DEDENT elif canTake ( 1 , x , 12 , y ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 12 NEW_LINE DEDENT elif canTake ( 0 , x , 22 , y ) : NEW_LINE INDENT y -= 22 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Hanako " ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if canTake ( 0 , x , 22 , y ) : NEW_LINE INDENT y -= 22 NEW_LINE DEDENT elif canTake ( 1 , x , 12 , y ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 12 NEW_LINE DEDENT elif canTake ( 2 , x , 2 , y ) : NEW_LINE INDENT x -= 2 NEW_LINE y -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Ciel " ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT turn += 1 NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE class DZYLovesChessboard : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = [ list ( input ( ) ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT w = i % 2 == 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT w = not w NEW_LINE if arr [ i ] [ j ] == ' . ' : NEW_LINE INDENT print ( ' W ' if w else ' B ' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - ' , end = ' ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT dzl = DZYLovesChessboard ( ) NEW_LINE dzl . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def check_no ( brr ) : NEW_LINE INDENT val = 0 NEW_LINE for i in brr : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT val += 1 NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_val = float ( ' - inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT x = 0 NEW_LINE brr = arr . copy ( ) NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT if brr [ k ] == 0 : NEW_LINE INDENT brr [ k ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT brr [ k ] = 0 NEW_LINE DEDENT DEDENT count = check_no ( brr ) NEW_LINE if count > max_val : NEW_LINE INDENT max_val = count NEW_LINE DEDENT DEDENT DEDENT if n == 1 : NEW_LINE INDENT if arr [ 0 ] == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( max_val ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Test : NEW_LINE INDENT @ staticmethod NEW_LINE def countDistictSubarray ( arr , n ) : NEW_LINE INDENT vis = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT vis [ arr [ i ] ] = 1 NEW_LINE DEDENT k = len ( vis ) NEW_LINE vis . clear ( ) NEW_LINE ans = 0 NEW_LINE right = 0 NEW_LINE window = 0 NEW_LINE for left in range ( n ) : NEW_LINE INDENT while right < n and window < k : NEW_LINE INDENT vis [ arr [ right ] ] = vis . get ( arr [ right ] , 0 ) + 1 NEW_LINE if vis [ arr [ right ] ] == 1 : NEW_LINE INDENT window += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if window == k : NEW_LINE INDENT ans += ( n - right + 1 ) NEW_LINE DEDENT vis [ arr [ left ] ] = vis . get ( arr [ left ] , 0 ) - 1 NEW_LINE if vis [ arr [ left ] ] == 0 : NEW_LINE INDENT window -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT arr = [ 2 , 1 , 3 , 2 , 3 ] NEW_LINE print ( Test . countDistictSubarray ( arr , len ( arr ) ) ) NEW_LINE DEDENT DEDENT Test . main ( None ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE class FastScanner : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin NEW_LINE self . tokens = [ ] NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . tokens : NEW_LINE INDENT self . tokens = self . input . readline ( ) . split ( ) NEW_LINE DEDENT return self . tokens . pop ( 0 ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT return self . input . readline ( ) . strip ( ) NEW_LINE DEDENT def nextByte ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextShort ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT in = FastScanner ( ) NEW_LINE n = in . nextInt ( ) NEW_LINE s = in . nextInt ( ) NEW_LINE max = 0 NEW_LINE while n > 0 : NEW_LINE INDENT f = in . nextInt ( ) NEW_LINE t = in . nextInt ( ) NEW_LINE if max < f + t : NEW_LINE INDENT max = f + t NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT print ( max ( s , max ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def primeBitsInRange ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT tot_bit = bin ( i ) . count ( '1' ) NEW_LINE if GFG . isPrime ( tot_bit ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT l = 6 NEW_LINE r = 10 NEW_LINE print ( primeBitsInRange ( l , r ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = GFG . countSetBits ( arr [ i ] ) + GFG . countSetBits ( arr [ j ] ) NEW_LINE if sum == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE DEDENT DEDENT
from collections import deque NEW_LINE class Reverse_k_element_queue : NEW_LINE INDENT queue = deque ( ) NEW_LINE @ staticmethod NEW_LINE def reverseQueueFirstKElements ( k ) : NEW_LINE INDENT if len ( Reverse_k_element_queue . queue ) == 0 or k > len ( Reverse_k_element_queue . queue ) : NEW_LINE INDENT return NEW_LINE DEDENT if k <= 0 : NEW_LINE INDENT return NEW_LINE DEDENT stack = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT stack . append ( Reverse_k_element_queue . queue . popleft ( ) ) NEW_LINE DEDENT while stack : NEW_LINE INDENT Reverse_k_element_queue . queue . append ( stack . pop ( ) ) NEW_LINE DEDENT for i in range ( len ( Reverse_k_element_queue . queue ) - k ) : NEW_LINE INDENT Reverse_k_element_queue . queue . append ( Reverse_k_element_queue . queue . popleft ( ) ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def Print ( ) : NEW_LINE INDENT while Reverse_k_element_queue . queue : NEW_LINE INDENT print ( Reverse_k_element_queue . queue . popleft ( ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT Reverse_k_element_queue . queue . extend ( [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 ] ) NEW_LINE k = 5 NEW_LINE Reverse_k_element_queue . reverseQueueFirstKElements ( k ) NEW_LINE Reverse_k_element_queue . Print ( ) NEW_LINE DEDENT DEDENT Reverse_k_element_queue . main ( ) NEW_LINE
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = - int ( input ( ) ) NEW_LINE numbers = input ( ) . strip ( ) . split ( " ▁ " ) NEW_LINE for x in numbers : NEW_LINE INDENT sum += int ( x ) NEW_LINE DEDENT if sum % 2 == 0 : NEW_LINE INDENT print ( " maomao90" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " errorgorn " ) NEW_LINE DEDENT DEDENT
def xorCalc ( k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( k + 1 ) & k ) == 0 : NEW_LINE INDENT return k // 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = 31 NEW_LINE print ( xorCalc ( k ) ) NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def isPerfectSquare ( self , num : int ) -> bool : NEW_LINE INDENT low = 1 NEW_LINE high = num NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if mid * mid == num : NEW_LINE INDENT return True NEW_LINE DEDENT elif mid * mid < num : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 16 NEW_LINE out = sObj . isPerfectSquare ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE result = " No " NEW_LINE if max ( a , max ( b , c ) ) * 2 == a + b + c : NEW_LINE INDENT result = " Yes " NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main . main ( sys . argv ) NEW_LINE DEDENT ` ` ` NEW_LINE
from typing import List NEW_LINE def main ( ) : NEW_LINE INDENT n1 = int ( input ( ) ) NEW_LINE arr = [ float ( input ( ) ) for _ in range ( n1 ) ] NEW_LINE summ = sum ( arr ) / n1 NEW_LINE nos = sum ( 1 for num in arr if num == summ ) NEW_LINE print ( nos ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if arr [ i ] == summ : NEW_LINE INDENT print ( i + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT size = int ( input ( ) ) NEW_LINE quantum = int ( input ( ) ) NEW_LINE sum = 0 NEW_LINE queue = Queue ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT name = input ( ) NEW_LINE time = int ( input ( ) ) NEW_LINE if time <= quantum : NEW_LINE INDENT sum += time NEW_LINE print ( name + " ▁ " + str ( sum ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += quantum NEW_LINE queue . enqueue ( Process ( name , time - quantum ) ) NEW_LINE DEDENT DEDENT while not queue . isEmpty ( ) : NEW_LINE INDENT process = queue . dequeue ( ) NEW_LINE if process . quantum <= quantum : NEW_LINE INDENT sum += process . quantum NEW_LINE print ( process . name + " ▁ " + str ( sum ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += quantum NEW_LINE queue . enqueue ( Process ( process . name , process . quantum - quantum ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT class Queue : NEW_LINE INDENT SIZE = 100000 NEW_LINE array = [ None ] * SIZE NEW_LINE head = 0 NEW_LINE tail = 0 NEW_LINE def dequeue ( self ) : NEW_LINE INDENT if self . isEmpty ( ) : NEW_LINE INDENT raise ValueError ( " You ▁ dequeued ▁ from ▁ empty ▁ queue . " ) NEW_LINE DEDENT value = self . array [ self . tail ] NEW_LINE self . tail += 1 NEW_LINE if self . tail == self . SIZE : NEW_LINE INDENT self . tail -= self . SIZE NEW_LINE DEDENT return value NEW_LINE DEDENT def enqueue ( self , process ) : NEW_LINE INDENT if self . isFull ( ) : NEW_LINE INDENT raise ValueError ( " You ▁ enqueued ▁ to ▁ full ▁ queue . " ) NEW_LINE DEDENT self . array [ self . head ] = process NEW_LINE self . head += 1 NEW_LINE if self . head == self . SIZE : NEW_LINE INDENT self . head -= self . SIZE NEW_LINE DEDENT DEDENT def isFull ( self ) : NEW_LINE INDENT return self . head + 1 == ( self . tail % self . SIZE ) NEW_LINE DEDENT def isEmpty ( self ) : NEW_LINE INDENT return self . head == self . tail NEW_LINE DEDENT DEDENT class Process : NEW_LINE INDENT def __init__ ( self , name , quantum ) : NEW_LINE INDENT self . name = name NEW_LINE self . quantum = quantum NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
from typing import List NEW_LINE def findElement ( arr : List [ int ] , ranges : List [ List [ int ] ] , rotations : int , index : int ) -> int : NEW_LINE INDENT for i in range ( rotations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if left <= index and right >= index : NEW_LINE INDENT if index == left : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index -= 1 NEW_LINE DEDENT DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE rotations = 2 NEW_LINE ranges = [ [ 0 , 2 ] , [ 0 , 3 ] ] NEW_LINE index = 1 NEW_LINE print ( findElement ( arr , ranges , rotations , index ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT MAXN = 1000001 NEW_LINE spf = [ 0 ] * MAXN NEW_LINE hash1 = [ 0 ] * MAXN NEW_LINE @ staticmethod NEW_LINE def sieve ( ) : NEW_LINE INDENT GFG . spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , GFG . MAXN ) : NEW_LINE INDENT GFG . spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , GFG . MAXN , 2 ) : NEW_LINE INDENT GFG . spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , int ( GFG . MAXN ** 0.5 ) + 1 ) : NEW_LINE INDENT if GFG . spf [ i ] == i : NEW_LINE INDENT for j in range ( i * i , GFG . MAXN , i ) : NEW_LINE INDENT if GFG . spf [ j ] == j : NEW_LINE INDENT GFG . spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def getFactorization ( x ) : NEW_LINE INDENT temp = 0 NEW_LINE while x != 1 : NEW_LINE INDENT temp = GFG . spf [ x ] NEW_LINE if x % temp == 0 : NEW_LINE INDENT GFG . hash1 [ GFG . spf [ x ] ] += 1 NEW_LINE x = x // GFG . spf [ x ] NEW_LINE DEDENT while x % temp == 0 : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def check ( x ) : NEW_LINE INDENT temp = 0 NEW_LINE while x != 1 : NEW_LINE INDENT temp = GFG . spf [ x ] NEW_LINE if x % temp == 0 and GFG . hash1 [ temp ] > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT while x % temp == 0 : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT @ staticmethod NEW_LINE def hasValidNum ( arr , n ) : NEW_LINE INDENT GFG . sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT GFG . getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if GFG . check ( arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if GFG . hasValidNum ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT GFG . main ( ) NEW_LINE
from collections import defaultdict NEW_LINE def isExists ( a , n ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE sum += a [ i ] NEW_LINE DEDENT if sum % 2 == 0 : NEW_LINE INDENT if freq [ sum // 2 ] != 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 5 , 1 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if isExists ( a , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE return area NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT d1 = 4 NEW_LINE d2 = 6 NEW_LINE print ( " Area ▁ of ▁ Kite ▁ = ▁ " + str ( areaOfKite ( d1 , d2 ) ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ [ False for j in range ( 11 ) ] for i in range ( 4 ) ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n -= 1 NEW_LINE j += i // 3 NEW_LINE i = ( i + 1 ) % 4 NEW_LINE if i == 2 and j != 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT a [ i ] [ j ] = True NEW_LINE DEDENT print ( " + - - - - - - - - - - - - - - - - - - - - - - - - + " ) NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT print ( " | " , end = " " ) NEW_LINE for j in range ( 11 ) : NEW_LINE INDENT if a [ i ] [ j ] : NEW_LINE INDENT print ( " O . " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT if i == 2 : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT print ( " # . " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " . . " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " # . " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if i == 0 : NEW_LINE INDENT print ( " | D | ) " ) NEW_LINE DEDENT else : NEW_LINE INDENT if i == 2 : NEW_LINE INDENT print ( " . . | " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " | . | " , end = " " ) NEW_LINE DEDENT if i == 3 : NEW_LINE INDENT print ( " ) " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " " ) NEW_LINE DEDENT DEDENT DEDENT print ( " + - - - - - - - - - - - - - - - - - - - - - - - - + " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def productEqual ( n ) : NEW_LINE INDENT if n < 10 : NEW_LINE INDENT return False NEW_LINE DEDENT prodOdd = 1 NEW_LINE prodEven = 1 NEW_LINE while n > 0 : NEW_LINE INDENT digit = n % 10 NEW_LINE prodOdd *= digit NEW_LINE n //= 10 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT digit = n % 10 NEW_LINE prodEven *= digit NEW_LINE n //= 10 NEW_LINE DEDENT if prodEven == prodOdd : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 4324 NEW_LINE if productEqual ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT n = int ( line ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT key = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = input ( ) . strip ( ) NEW_LINE key_count = 0 NEW_LINE result = " " NEW_LINE for c in s : NEW_LINE INDENT for _ in range ( key [ key_count ] ) : NEW_LINE INDENT if c == ' a ' : NEW_LINE INDENT c = ' z ' NEW_LINE DEDENT elif c == ' A ' : NEW_LINE INDENT c = ' Z ' NEW_LINE DEDENT else : NEW_LINE INDENT c = chr ( ord ( c ) - 1 ) NEW_LINE DEDENT DEDENT key_count = ( key_count + 1 ) % n NEW_LINE result += c NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT ` ` ` NEW_LINE
import java NEW_LINE def checkEVENodd ( arr , n , l , r ) : NEW_LINE INDENT if arr [ r ] == 1 : NEW_LINE INDENT print ( " odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " even " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE checkEVENodd ( arr , n , 1 , 3 ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT try : NEW_LINE INDENT str = input ( ) NEW_LINE split = str . split ( " ▁ " ) NEW_LINE w = int ( split [ 0 ] ) NEW_LINE h = int ( split [ 1 ] ) NEW_LINE x = int ( split [ 2 ] ) NEW_LINE y = int ( split [ 3 ] ) NEW_LINE r = int ( split [ 4 ] ) NEW_LINE if ( x - r >= 0 ) and ( x + r <= w ) and ( y - r >= 0 ) and ( y + r <= h ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT except Exception as e : NEW_LINE INDENT print ( " ? ? ¨ ? ? ? ? ? ? " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT @ staticmethod NEW_LINE def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while num > 0 : NEW_LINE INDENT if GFG . isPrime ( num ) : NEW_LINE INDENT return num NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT @ staticmethod NEW_LINE def minNumber ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if GFG . isPrime ( sum ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = GFG . findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . minNumber ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import numpy as np NEW_LINE def compositeProduct ( arr ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = np . ones ( max_val + 1 , dtype = bool ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT product = 1 NEW_LINE for num in arr : NEW_LINE INDENT if not prime [ num ] : NEW_LINE INDENT product *= num NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE print ( compositeProduct ( arr ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT intx = 0 NEW_LINE inty = 0 NEW_LINE intWork = 0 NEW_LINE try : NEW_LINE INDENT while True : NEW_LINE INDENT strLine = sys . stdin . readline ( ) . strip ( ) NEW_LINE if strLine : NEW_LINE INDENT strNumList = strLine . split ( " ▁ " ) NEW_LINE intx = int ( strNumList [ 0 ] ) NEW_LINE inty = int ( strNumList [ 1 ] ) NEW_LINE if intx != 0 or inty != 0 : NEW_LINE INDENT if intx > inty : NEW_LINE INDENT intWork = intx NEW_LINE intx = inty NEW_LINE inty = intWork NEW_LINE DEDENT print ( intx , inty ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT except IOError as e1 : NEW_LINE INDENT print ( e1 ) NEW_LINE DEDENT except ValueError as e2 : NEW_LINE INDENT print ( e2 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT strarr = [ " FILIPINO " , " JAPANESE " , " KOREAN " ] NEW_LINE t = int ( input ( ) ) NEW_LINE indexWord = 0 NEW_LINE for i in range ( t ) : NEW_LINE INDENT s1 = input ( ) NEW_LINE if s1 . endswith ( " po " ) : NEW_LINE INDENT indexWord = 0 NEW_LINE DEDENT elif s1 . endswith ( " mnida " ) : NEW_LINE INDENT indexWord = 2 NEW_LINE DEDENT else : NEW_LINE INDENT indexWord = 1 NEW_LINE DEDENT print ( strarr [ indexWord ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = Main ( ) NEW_LINE m . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
0ERROR
` ` ` python NEW_LINE def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if z . is_integer ( ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y + int ( z ) ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT n , a , b , c = 10 , 5 , 3 , 4 NEW_LINE print ( maxResult ( n , a , b , c ) ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def sort ( a ) : NEW_LINE INDENT for i in range ( len ( a ) - 1 ) : NEW_LINE INDENT for j in range ( len ( a ) - 1 , i , - 1 ) : NEW_LINE INDENT if a [ j ] > a [ j - 1 ] : NEW_LINE INDENT t = a [ j ] NEW_LINE a [ j ] = a [ j - 1 ] NEW_LINE a [ j - 1 ] = t NEW_LINE DEDENT DEDENT DEDENT DEDENT def print_hill ( a ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT hills = [ 0 ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT num = input ( ) NEW_LINE n = int ( num ) NEW_LINE hills [ i ] = n NEW_LINE DEDENT sort ( hills ) NEW_LINE print_hill ( hills ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def fact ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i NEW_LINE DEDENT return ans NEW_LINE DEDENT def numberOfPossiblePallindrome ( str , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] in mp : NEW_LINE INDENT mp [ str [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ str [ i ] ] = 1 NEW_LINE DEDENT DEDENT k = 0 NEW_LINE num = 0 NEW_LINE den = 1 NEW_LINE fi = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if value % 2 == 0 : NEW_LINE INDENT fi = value // 2 NEW_LINE DEDENT else : NEW_LINE INDENT fi = ( value - 1 ) // 2 NEW_LINE k += 1 NEW_LINE DEDENT num += fi NEW_LINE den *= GFG . fact ( fi ) NEW_LINE DEDENT if num != 0 : NEW_LINE INDENT num = GFG . fact ( num ) NEW_LINE DEDENT ans = num // den NEW_LINE if k != 0 : NEW_LINE INDENT ans = ans * k NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT str = " ababab " NEW_LINE n = len ( str ) NEW_LINE print ( GFG . numberOfPossiblePallindrome ( str , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT size = int ( input ( ) ) NEW_LINE arr = [ 0 ] * ( size + 1 ) NEW_LINE for i in range ( 1 , size + 1 ) : NEW_LINE INDENT arr [ i ] = int ( input ( ) ) NEW_LINE DEDENT print ( split ( arr , 1 , size ) ) NEW_LINE DEDENT def split ( arr , s , m ) : NEW_LINE INDENT if s == m : NEW_LINE INDENT return 1 NEW_LINE DEDENT half = ( m - s + 1 ) // 2 NEW_LINE mid = half + s NEW_LINE ans1 = split ( arr , s , mid - 1 ) NEW_LINE ans2 = split ( arr , mid , m ) NEW_LINE if arr [ mid ] >= arr [ mid - 1 ] and ans1 == ans2 and ans1 == half : NEW_LINE INDENT return ans1 + ans2 NEW_LINE DEDENT elif ans1 > ans2 : NEW_LINE INDENT return ans1 NEW_LINE DEDENT else : NEW_LINE INDENT return ans2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import java . util . * ; NEW_LINE public class GfG { public static int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; } public static void main ( String argc [ ] ) { int n = 107 ; int m = 4 ; n = toggleLastMBits ( n , m ) ; System . out . println ( n ) ; } } NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE f = True NEW_LINE for ch in s : NEW_LINE INDENT if ch == ' A ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE if a < b : NEW_LINE INDENT print ( " NO " ) NEW_LINE f = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if f : NEW_LINE INDENT if b != 0 and s [ - 1 ] == ' B ' : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def first_subString ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = 0 NEW_LINE mpp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' ▁ ' or s [ i ] == ' # ' : NEW_LINE INDENT s1 = s [ c : i ] NEW_LINE mpp [ s1 ] = 1 NEW_LINE c = i + 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' ▁ ' : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if s [ i ] == ' ▁ ' : NEW_LINE INDENT break NEW_LINE DEDENT s1 = s [ i : j + 1 ] NEW_LINE s2 = s1 NEW_LINE s1 = GFG . reverse ( s1 ) NEW_LINE if s1 in mpp : NEW_LINE INDENT return s2 NEW_LINE DEDENT DEDENT DEDENT return " - 1" NEW_LINE DEDENT def reverse ( input ) : NEW_LINE INDENT a = list ( input ) NEW_LINE l = 0 NEW_LINE r = len ( a ) - 1 NEW_LINE while l < r : NEW_LINE INDENT temp = a [ l ] NEW_LINE a [ l ] = a [ r ] NEW_LINE a [ r ] = temp NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return ' ' . join ( a ) NEW_LINE DEDENT s = " mango ▁ is ▁ sweet ▁ when ▁ nam ▁ en ▁ tastes ▁ it # " NEW_LINE s1 = first_subString ( s ) NEW_LINE print ( s1 ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def countConsecutive ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 44522255 NEW_LINE print ( countConsecutive ( n ) ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def findAngle ( n ) : NEW_LINE INDENT interiorAngle = ( n - 2 ) * 180 / n NEW_LINE exteriorAngle = 360 / n NEW_LINE print ( " Interior ▁ angle : ▁ " + str ( interiorAngle ) ) NEW_LINE print ( " Exterior ▁ angle : ▁ " + str ( exteriorAngle ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 10 NEW_LINE findAngle ( n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE def nDigitPerfectSquares ( n ) : NEW_LINE INDENT smallest = int ( math . pow ( math . ceil ( math . sqrt ( math . pow ( 10 , n - 1 ) ) ) , 2 ) ) NEW_LINE print ( smallest , end = " ▁ " ) NEW_LINE largest = int ( math . pow ( math . ceil ( math . sqrt ( math . pow ( 10 , n ) ) ) - 1 , 2 ) ) NEW_LINE print ( largest ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE nDigitPerfectSquares ( n ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class A : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . inp = None NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT self . solve ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT self . inp = input ( ) NEW_LINE t = int ( self . inp ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE message = list ( input ( ) ) NEW_LINE self . identify_message ( message , n ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT def identify_message ( self , message , n ) : NEW_LINE INDENT message . reverse ( ) NEW_LINE left_symbols = 0 NEW_LINE for character in message : NEW_LINE INDENT if character == " ) " : NEW_LINE INDENT left_symbols += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " Yes " if left_symbols > ( n - left_symbols ) else " No " ) NEW_LINE DEDENT DEDENT A ( ) . main ( None ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE class akarshanand2810 : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT self . solve ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( input ( ) ) NEW_LINE cnt = 0 NEW_LINE idx = [ ] NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE idx . append ( i ) NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE for index in idx : NEW_LINE INDENT if arr [ index ] == ' a ' : NEW_LINE INDENT arr [ index ] = ' b ' NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = ' a ' NEW_LINE DEDENT DEDENT print ( " " . join ( arr ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ak = akarshanand2810 ( ) NEW_LINE ak . main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT discard_count = 0 NEW_LINE @ staticmethod NEW_LINE def power ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = GFG . power ( a , n // 2 ) NEW_LINE p = p * p NEW_LINE if n % 2 == 1 : NEW_LINE INDENT p = p * a NEW_LINE DEDENT return p NEW_LINE DEDENT @ staticmethod NEW_LINE def solve ( i , n , sum , k , a , prefix ) : NEW_LINE INDENT global discard_count NEW_LINE if sum > k : NEW_LINE INDENT discard_count += GFG . power ( 2 , n - i ) NEW_LINE return NEW_LINE DEDENT if i == n : NEW_LINE INDENT return NEW_LINE DEDENT rem = prefix [ n - 1 ] - prefix [ i ] NEW_LINE if sum + a [ i ] + rem > k : NEW_LINE INDENT GFG . solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) NEW_LINE DEDENT if sum + rem > k : NEW_LINE INDENT GFG . solve ( i + 1 , n , sum , k , a , prefix ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def countSubsequences ( arr , n , K ) : NEW_LINE INDENT sum = 0.0 NEW_LINE k = float ( math . log ( K ) ) NEW_LINE prefix = [ 0.0 ] * n NEW_LINE a = [ 0.0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = float ( math . log ( arr [ i ] ) ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT prefix [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + a [ i ] NEW_LINE DEDENT total = GFG . power ( 2 , n ) - 1 NEW_LINE if sum <= k : NEW_LINE INDENT return int ( total ) NEW_LINE DEDENT GFG . solve ( 0 , n , 0.0 , k , a , prefix ) NEW_LINE return int ( total - GFG . discard_count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 7 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( GFG . countSubsequences ( arr , n , k ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def newNode ( data ) : NEW_LINE INDENT node = GFG . Node ( ) NEW_LINE node . data = data NEW_LINE node . left = None NEW_LINE node . right = None NEW_LINE return node NEW_LINE DEDENT @ staticmethod NEW_LINE def inorder ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT GFG . inorder ( root . left ) NEW_LINE print ( root . data , end = " ▁ " ) NEW_LINE GFG . inorder ( root . right ) NEW_LINE DEDENT @ staticmethod NEW_LINE def isIdentical ( root1 , root2 ) : NEW_LINE INDENT if root1 is None and root2 is None : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif root1 is not None and root2 is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif root1 is None and root2 is not None : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if root1 . data == root2 . data and GFG . isIdentical ( root1 . left , root2 . left ) == 1 and GFG . isIdentical ( root1 . right , root2 . right ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT root1 = GFG . newNode ( 5 ) NEW_LINE root2 = GFG . newNode ( 5 ) NEW_LINE root1 . left = GFG . newNode ( 3 ) NEW_LINE root1 . right = GFG . newNode ( 8 ) NEW_LINE root1 . left . left = GFG . newNode ( 2 ) NEW_LINE root1 . left . right = GFG . newNode ( 4 ) NEW_LINE root2 . left = GFG . newNode ( 3 ) NEW_LINE root2 . right = GFG . newNode ( 8 ) NEW_LINE root2 . left . left = GFG . newNode ( 2 ) NEW_LINE root2 . left . right = GFG . newNode ( 4 ) NEW_LINE if GFG . isIdentical ( root1 , root2 ) == 1 : NEW_LINE INDENT print ( " Both ▁ BSTs ▁ are ▁ identical " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " BSTs ▁ are ▁ not ▁ identical " ) NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( input ( ) ) NEW_LINE leftJ = [ 0 ] * ( n + 2 ) NEW_LINE rightI = [ 0 ] * ( n + 2 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT leftJ [ i ] = leftJ [ i - 1 ] NEW_LINE if arr [ i - 1 ] == ' J ' : NEW_LINE INDENT leftJ [ i ] += 1 NEW_LINE DEDENT rightI [ n - i + 1 ] = rightI [ n - i + 2 ] NEW_LINE if arr [ n - i ] == ' I ' : NEW_LINE INDENT rightI [ n - i + 1 ] += 1 NEW_LINE DEDENT DEDENT sumI = 0 NEW_LINE sumJ = 0 NEW_LINE maxO = 0 NEW_LINE total = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if arr [ i - 1 ] == ' O ' : NEW_LINE INDENT tmp = leftJ [ i - 1 ] * rightI [ i + 1 ] NEW_LINE total += tmp NEW_LINE sumJ += ( leftJ [ i - 1 ] + 1 ) * rightI [ i + 1 ] NEW_LINE sumI += leftJ [ i - 1 ] * ( rightI [ i + 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = leftJ [ i - 1 ] * rightI [ i ] NEW_LINE DEDENT maxO = max ( maxO , tmp ) NEW_LINE DEDENT total += maxO NEW_LINE total = max ( total , sumJ ) NEW_LINE total = max ( total , sumI ) NEW_LINE print ( total ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT br = input ( ) . split ( ) NEW_LINE surface = br [ 0 ] . split ( " ▁ " ) NEW_LINE order = br [ 1 ] NEW_LINE dice1 = Dise ( ) NEW_LINE dice1 . setSurface ( surface ) NEW_LINE dice1 . SetDice ( 1 , 2 , 3 ) NEW_LINE dice1 . RollDice ( order ) NEW_LINE DEDENT DEDENT class Dise : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . surface = [ 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE self . Top = 0 NEW_LINE self . Bottom = 0 NEW_LINE self . Right = 0 NEW_LINE self . Left = 0 NEW_LINE self . Front = 0 NEW_LINE self . Back = 0 NEW_LINE DEDENT def setSurface ( self , SurfaceString ) : NEW_LINE INDENT for i in range ( 6 ) : NEW_LINE INDENT self . surface [ i ] = int ( SurfaceString [ i ] ) NEW_LINE DEDENT DEDENT def SetDice ( self , top , front , right ) : NEW_LINE INDENT self . Top = top - 1 NEW_LINE self . Front = front - 1 NEW_LINE self . Right = right - 1 NEW_LINE self . Bottom = 5 - ( top - 1 ) NEW_LINE self . Back = 5 - ( front - 1 ) NEW_LINE self . Left = 5 - ( right - 1 ) NEW_LINE DEDENT def RollDice ( self , RollString ) : NEW_LINE INDENT for i in range ( len ( RollString ) ) : NEW_LINE INDENT if RollString [ i ] == " W " : NEW_LINE INDENT self . Bottom , self . Left , self . Top , self . Right = self . Left , self . Top , 5 - self . Bottom , 5 - self . Left NEW_LINE DEDENT elif RollString [ i ] == " S " : NEW_LINE INDENT self . Bottom , self . Front , self . Top , self . Back = self . Front , self . Top , 5 - self . Bottom , 5 - self . Front NEW_LINE DEDENT elif RollString [ i ] == " E " : NEW_LINE INDENT self . Bottom , self . Right , self . Top , self . Left = self . Right , self . Top , 5 - self . Bottom , 5 - self . Right NEW_LINE DEDENT else : NEW_LINE INDENT self . Bottom , self . Back , self . Top , self . Front = self . Back , self . Top , 5 - self . Bottom , 5 - self . Back NEW_LINE DEDENT DEDENT print ( self . surface [ self . Top ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = Main ( ) NEW_LINE m . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT class node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def add ( data ) : NEW_LINE INDENT newnode = GFG . node ( ) NEW_LINE newnode . data = data NEW_LINE newnode . next = None NEW_LINE return newnode NEW_LINE DEDENT @ staticmethod NEW_LINE def printArr ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def findlength ( head ) : NEW_LINE INDENT curr = head NEW_LINE cnt = 0 NEW_LINE while curr is not None : NEW_LINE INDENT cnt += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT return cnt NEW_LINE DEDENT @ staticmethod NEW_LINE def convertArr ( head ) : NEW_LINE INDENT len = GFG . findlength ( head ) NEW_LINE arr = [ 0 ] * len NEW_LINE index = 0 NEW_LINE curr = head NEW_LINE while curr is not None : NEW_LINE INDENT arr [ index ] = curr . data NEW_LINE index += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT GFG . printArr ( arr , len ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT head = GFG . node ( ) NEW_LINE head = GFG . add ( 1 ) NEW_LINE head . next = GFG . add ( 2 ) NEW_LINE head . next . next = GFG . add ( 3 ) NEW_LINE head . next . next . next = GFG . add ( 4 ) NEW_LINE head . next . next . next . next = GFG . add ( 5 ) NEW_LINE GFG . convertArr ( head ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def nonDecNums ( n ) : NEW_LINE INDENT a = [ [ 0 for i in range ( 10 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return a [ n ] [ 0 ] NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT n = 2 NEW_LINE print ( " Non - decreasing ▁ digits ▁ = ▁ " + str ( GFG . nonDecNums ( n ) ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
from typing import List NEW_LINE class class29 : NEW_LINE INDENT def main ( self , arg : List [ str ] ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE st = set ( ) NEW_LINE flag = 0 NEW_LINE a = [ 0 ] * n NEW_LINE vis = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = int ( input ( ) ) NEW_LINE val = ( i + a [ i ] ) % n NEW_LINE if val < 0 : NEW_LINE INDENT val += n NEW_LINE DEDENT vis [ val ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if vis [ i ] == 0 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT t -= 1 NEW_LINE DEDENT DEDENT DEDENT
import java . util . Arrays NEW_LINE class Solution : NEW_LINE INDENT def minMoves ( self , nums ) : NEW_LINE INDENT if len ( nums ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT nums . sort ( ) NEW_LINE min_num = nums [ 0 ] NEW_LINE ans = 0 NEW_LINE for num in nums : NEW_LINE INDENT ans += num - min_num NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 ] NEW_LINE out = sObj . minMoves ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE if ( a <= 0 and b >= 0 ) or ( a >= 0 and b <= 0 ) : NEW_LINE INDENT print ( " Zero " ) NEW_LINE DEDENT elif a < 0 and b < 0 : NEW_LINE INDENT print ( " Positive " if ( b - a + 1 ) % 2 == 0 else " Negative " ) NEW_LINE DEDENT elif a > 0 and b > 0 : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = Main ( ) NEW_LINE m . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class geeks : NEW_LINE INDENT def firstSetBit ( n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 12 NEW_LINE print ( firstSetBit ( n ) ) NEW_LINE DEDENT DEDENT
MAX_CHAR = 256 NEW_LINE def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE firstInd = [ - 1 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT first_ind = firstInd [ ord ( str [ i ] ) ] NEW_LINE if first_ind == - 1 : NEW_LINE INDENT firstInd [ ord ( str [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abba " NEW_LINE print ( maximumChars ( str ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class Kefa : NEW_LINE INDENT def __init__ ( self , money , friend ) : NEW_LINE INDENT self . money = money NEW_LINE self . friend = friend NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE list = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT money , friend = map ( int , input ( ) . split ( ) ) NEW_LINE list . append ( Kefa ( money , friend ) ) NEW_LINE DEDENT list . sort ( key = lambda x : x . money ) NEW_LINE ans = 0 NEW_LINE s = 0 NEW_LINE e = 0 NEW_LINE sum = 0 NEW_LINE while e < n : NEW_LINE INDENT if list [ e ] . money - list [ s ] . money < k : NEW_LINE INDENT sum += list [ e ] . friend NEW_LINE e += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= list [ s ] . friend NEW_LINE s += 1 NEW_LINE DEDENT ans = max ( ans , sum ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def findArea ( a ) : NEW_LINE INDENT area = 5 * math . sqrt ( 3 ) * a * a NEW_LINE return area NEW_LINE DEDENT def findVolume ( a ) : NEW_LINE INDENT volume = ( 5 / 12 ) * ( 3 + math . sqrt ( 5 ) ) * a * a * a NEW_LINE return volume NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 5 NEW_LINE print ( " Area : ▁ { : . 2f } " . format ( findArea ( a ) ) ) NEW_LINE print ( " Volume : ▁ { : . 2f } " . format ( findVolume ( a ) ) ) NEW_LINE DEDENT
class p205 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT PYRAMIDAL_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 ] NEW_LINE CUBIC_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE def run ( self ) : NEW_LINE INDENT ninePyramidalPdf = [ 1 ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT ninePyramidalPdf = self . convolve ( ninePyramidalPdf , self . PYRAMIDAL_DIE_PDF ) NEW_LINE DEDENT sixCubicPdf = [ 1 ] NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT sixCubicPdf = self . convolve ( sixCubicPdf , self . CUBIC_DIE_PDF ) NEW_LINE DEDENT numer = 0 NEW_LINE for i in range ( len ( ninePyramidalPdf ) ) : NEW_LINE INDENT numer += ( long ( ninePyramidalPdf [ i ] ) * self . sum ( sixCubicPdf , 0 , i ) ) NEW_LINE DEDENT denom = ( self . sum ( ninePyramidalPdf , 0 , len ( ninePyramidalPdf ) ) * self . sum ( sixCubicPdf , 0 , len ( sixCubicPdf ) ) ) NEW_LINE return " % .7f " % ( float ( numer ) / denom ) NEW_LINE DEDENT def convolve ( self , a , b ) : NEW_LINE INDENT c = [ 0 ] * ( len ( a ) + len ( b ) - 1 ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( b ) ) : NEW_LINE INDENT c [ i + j ] += a [ i ] * b [ j ] NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def sum ( self , array , start , end ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT total += array [ i ] NEW_LINE DEDENT return total NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import java . util . * ; NEW_LINE import java . lang . * ; NEW_LINE import java . io . * ; NEW_LINE class GFG : NEW_LINE INDENT def main ( args : Array [ str ] ) : NEW_LINE INDENT N = 6 NEW_LINE Even = N // 2 NEW_LINE Odd = N - Even NEW_LINE print ( Even * Odd ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def solve ( M , N , s ) : NEW_LINE INDENT if N % s == 0 : NEW_LINE INDENT N = N // s NEW_LINE DEDENT else : NEW_LINE INDENT N = ( N // s ) + 1 NEW_LINE DEDENT if M % s == 0 : NEW_LINE INDENT M = M // s NEW_LINE DEDENT else : NEW_LINE INDENT M = ( M // s ) + 1 NEW_LINE DEDENT return M * N NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 12 NEW_LINE M = 13 NEW_LINE s = 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT
import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT list = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT _l = int ( input ( ) ) NEW_LINE list . append ( _l ) NEW_LINE sum += _l NEW_LINE DEDENT for i in range ( 4 ) : NEW_LINE INDENT for j in range ( i + 1 , 5 ) : NEW_LINE INDENT for k in range ( j + 1 , 6 ) : NEW_LINE INDENT sum1 = list [ i ] + list [ j ] + list [ k ] NEW_LINE if sum1 == sum - sum1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def _popcnt32 ( self , number ) : NEW_LINE INDENT counter = 0 NEW_LINE while number > 0 : NEW_LINE INDENT if number % 2 == 1 : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT number = number // 2 NEW_LINE DEDENT return counter NEW_LINE DEDENT @ staticmethod NEW_LINE def maximize ( a ) : NEW_LINE INDENT n = GFG ( ) . _popcnt32 ( a ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = res | ( 1 << ( 32 - i ) ) NEW_LINE DEDENT return abs ( res ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT a = 1 NEW_LINE print ( GFG ( ) . maximize ( a ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE counter = 0 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if a [ i ] <= k : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT num1 = int ( input ( ) ) NEW_LINE num2 = int ( input ( ) ) NEW_LINE counter = 0 NEW_LINE while num1 != 0 and num2 != 0 : NEW_LINE INDENT if num1 == 1 and num2 == 1 : NEW_LINE INDENT break NEW_LINE DEDENT if num1 <= num2 : NEW_LINE INDENT num1 += 1 NEW_LINE num2 -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT num1 -= 2 NEW_LINE num2 += 1 NEW_LINE DEDENT counter += 1 NEW_LINE DEDENT print ( counter ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT def xorQueries ( self , arr , queries ) : NEW_LINE INDENT res = [ 0 ] * len ( queries ) NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT arr [ i ] ^= arr [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( queries ) ) : NEW_LINE INDENT q = queries [ i ] NEW_LINE res [ i ] = arr [ q [ 0 ] - 1 ] ^ arr [ q [ 1 ] ] if q [ 0 ] > 0 else arr [ q [ 1 ] ] NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT sObj = Solution ( ) NEW_LINE arr = [ 1 , 3 , 4 , 8 ] NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 2 ] , [ 0 , 3 ] , [ 3 , 3 ] ] NEW_LINE out = sObj . xorQueries ( arr , queries ) NEW_LINE print ( out ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def encodedChar ( str , k ) : NEW_LINE INDENT expand = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while i < len ( str ) and str [ i ] . isalpha ( ) : NEW_LINE INDENT temp += str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while i < len ( str ) and str [ i ] . isdigit ( ) : NEW_LINE INDENT freq = freq * 10 + int ( str [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT expand += temp * freq NEW_LINE DEDENT if freq == 0 : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " ab4c12ed3" NEW_LINE k = 21 NEW_LINE print ( GFG . encodedChar ( str , k ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def printPossible ( a , b , c ) : NEW_LINE INDENT if ( a + b + c ) % 2 != 0 or a + b < c : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE c = 2 NEW_LINE printPossible ( a , b , c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) // 2 NEW_LINE sign = 1 if ( n + 1 ) % 2 == 0 else - 1 NEW_LINE result_sum = sign * abs_sum NEW_LINE return result_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2 NEW_LINE print ( summation ( N ) ) NEW_LINE DEDENT
import java NEW_LINE import java . io NEW_LINE def sortSquares ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ - 6 , - 3 , - 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Before ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT sortSquares ( arr ) NEW_LINE print ( " " ) NEW_LINE print ( " After ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT main ( None ) NEW_LINE
from sys import stdin NEW_LINE def main ( ) : NEW_LINE INDENT n , t = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE pos = 1 NEW_LINE while pos < t : NEW_LINE INDENT pos += arr [ pos - 1 ] NEW_LINE DEDENT if pos == t : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE N = int ( sys . stdin . readline ( ) ) NEW_LINE a = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE indeg = [ 0 ] * N NEW_LINE used = [ False ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT indeg [ ( i + a [ i ] ) % N ] += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT j = i NEW_LINE while not used [ j ] and indeg [ j ] == 0 : NEW_LINE INDENT used [ j ] = True NEW_LINE j = ( j + a [ j ] ) % N NEW_LINE indeg [ j ] -= 1 NEW_LINE DEDENT DEDENT print ( sum ( 1 for x in indeg if x != 0 ) ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def isTriangular ( num ) : NEW_LINE INDENT if num < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b , a = 1 , 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if d < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE if root1 > 0 and math . floor ( root1 ) == root1 : NEW_LINE INDENT return True NEW_LINE DEDENT if root2 > 0 and math . floor ( root2 ) == root2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT num = 55 NEW_LINE if isTriangular ( num ) : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def printNumberWithDR ( k , d ) : NEW_LINE INDENT if d == 0 and k != 1 : NEW_LINE INDENT sys . stdout . write ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( str ( d ) ) NEW_LINE k -= 1 NEW_LINE while k > 0 : NEW_LINE INDENT sys . stdout . write ( "0" ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT k = 4 NEW_LINE d = 4 NEW_LINE printNumberWithDR ( k , d ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT N = 3 NEW_LINE @ staticmethod NEW_LINE def rotateMatrix ( mat ) : NEW_LINE INDENT for i in range ( GFG . N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( GFG . N - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE GFG . rotateMatrix ( mat ) NEW_LINE DEDENT ` ` ` NEW_LINE
import java . util . * ; NEW_LINE public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int p = sc . nextInt ( ) ; System . out . println ( p // 500 * 500 ) ; } } NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def getProduct ( n ) : NEW_LINE INDENT product = 1 NEW_LINE while n != 0 : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4513 NEW_LINE print ( getProduct ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class Slot : NEW_LINE INDENT def __init__ ( self , b , r , g , c , s , t ) : NEW_LINE INDENT self . b = b NEW_LINE self . r = r NEW_LINE self . g = g NEW_LINE self . c = c NEW_LINE self . s = s NEW_LINE self . t = t NEW_LINE DEDENT def getLost ( self ) : NEW_LINE INDENT return ( self . t - 5 * self . b - 3 * self . r - self . s ) * 3 + ( 5 * self . b + 3 * self . r ) * 2 NEW_LINE DEDENT def getBenefit ( self ) : NEW_LINE INDENT return self . b * 15 + self . r * 15 + self . g * 7 + self . c * 2 + ( self . b * 5 + self . r * 3 ) * 15 NEW_LINE DEDENT def isEnd ( self ) : NEW_LINE INDENT return self . b + self . r + self . g + self . c + self . s + self . t == 0 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT b , r , g , c , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE slot = Slot ( b , r , g , c , s , t ) NEW_LINE if slot . isEnd ( ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( 100 + slot . getBenefit ( ) - slot . getLost ( ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE mod = 1000000007 NEW_LINE MAXN = 1010 NEW_LINE def main ( ) : NEW_LINE INDENT comb = [ [ 0 for _ in range ( MAXN ) ] for _ in range ( MAXN ) ] NEW_LINE comb [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAXN ) : NEW_LINE INDENT comb [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT comb [ i ] [ j ] = ( comb [ i - 1 ] [ j ] + comb [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT DEDENT K = int ( input ( ) ) NEW_LINE color = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = 1 NEW_LINE total = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT res = ( res * comb [ total + color [ i ] - 1 ] [ color [ i ] - 1 ] ) % mod NEW_LINE total += color [ i ] NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE class GFG : NEW_LINE INDENT PI = 3.14159265 NEW_LINE @ staticmethod NEW_LINE def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * GFG . PI * r ) + 6 * r ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT r = 7 NEW_LINE print ( GFG . length_rope ( r ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def reverseDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT rev_n = GFG . reverseDigits ( n ) NEW_LINE if rev_n == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT n = 4562 NEW_LINE print ( " Is ▁ " + str ( n ) + " ▁ a ▁ Palindrome ▁ number ? ▁ - > ▁ " + ( " True " if GFG . isPalindrome ( n ) == 1 else " False " ) ) NEW_LINE n = 2002 NEW_LINE print ( " Is ▁ " + str ( n ) + " ▁ a ▁ Palindrome ▁ number ? ▁ - > ▁ " + ( " True " if GFG . isPalindrome ( n ) == 1 else " False " ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addStrings ( self , num1 : str , num2 : str ) -> str : NEW_LINE INDENT sb = [ ] NEW_LINE carry = 0 NEW_LINE i , j = len ( num1 ) - 1 , len ( num2 ) - 1 NEW_LINE while i >= 0 or j >= 0 or carry == 1 : NEW_LINE INDENT x = int ( num1 [ i ] ) if i >= 0 else 0 NEW_LINE y = int ( num2 [ j ] ) if j >= 0 else 0 NEW_LINE sb . append ( str ( ( x + y + carry ) % 10 ) ) NEW_LINE carry = ( x + y + carry ) // 10 NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ' ' . join ( sb [ : : - 1 ] ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE num1 = "11" NEW_LINE num2 = "123" NEW_LINE out = sObj . addStrings ( num1 , num2 ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT s = Solution ( ) NEW_LINE s . main ( ) NEW_LINE
class GFG : NEW_LINE INDENT def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if i * i != n : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if sum == n and n != 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( " Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000" ) NEW_LINE for n in range ( 2 , 10000 ) : NEW_LINE INDENT if GFG . isPerfect ( n ) : NEW_LINE INDENT print ( str ( n ) + " ▁ is ▁ a ▁ perfect ▁ number " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
` ` ` python NEW_LINE import math NEW_LINE def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT p = x NEW_LINE while p <= n : NEW_LINE INDENT p *= x NEW_LINE if p == n : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if isPower ( i ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT y = 2 NEW_LINE p = x ** y NEW_LINE while p <= n and p > 0 : NEW_LINE INDENT if p == n : NEW_LINE INDENT return True NEW_LINE DEDENT y += 1 NEW_LINE p = x ** y NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if isPower ( i ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def findTwoNumbers ( sum , gcd ) : NEW_LINE INDENT if gcd ( gcd , sum - gcd ) == gcd and sum != gcd : NEW_LINE INDENT print ( " a ▁ = ▁ " + str ( min ( gcd , sum - gcd ) ) + " , ▁ b ▁ = ▁ " + str ( int ( sum - min ( gcd , sum - gcd ) ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT sum = 8 NEW_LINE gcd = 2 NEW_LINE findTwoNumbers ( sum , gcd ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def time ( m , n , rb , cb , rd , cd ) : NEW_LINE INDENT t = 0 NEW_LINE dr = 1 NEW_LINE dc = 1 NEW_LINE while True : NEW_LINE INDENT if rb == rd or cb == cd : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE if ( rb + dr ) <= 0 or ( rb + dr > m ) : NEW_LINE INDENT dr *= - 1 NEW_LINE DEDENT if ( cb + dc ) <= 0 or ( cb + dc > n ) : NEW_LINE INDENT dc *= - 1 NEW_LINE DEDENT rb += dr NEW_LINE cb += dc NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT testCases = int ( input ( ) ) NEW_LINE for _ in range ( testCases ) : NEW_LINE INDENT input_data = input ( ) . split ( " ▁ " ) NEW_LINE t = time ( int ( input_data [ 0 ] ) , int ( input_data [ 1 ] ) , int ( input_data [ 2 ] ) , int ( input_data [ 3 ] ) , int ( input_data [ 4 ] ) , int ( input_data [ 5 ] ) ) NEW_LINE print ( t ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE n , a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE ans1 , ans2 = 100000 , 1000000 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if a * i >= n : NEW_LINE INDENT ans1 = i * b NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if c * i >= n : NEW_LINE INDENT ans2 = i * d NEW_LINE break NEW_LINE DEDENT DEDENT print ( min ( ans1 , ans2 ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( arr , n ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = GFG . countSetBits ( arr [ i ] ) NEW_LINE if count in m : NEW_LINE INDENT m [ count ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ count ] = 1 NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT result += ( value * ( value - 1 ) ) // 2 NEW_LINE DEDENT return result NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 7 , 5 , 3 , 9 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . totalPairs ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( str ( n ) + " th ▁ centered ▁ " + " hexadecagonal ▁ number : ▁ " , end = " " ) NEW_LINE print ( center_hexadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( str ( n ) + " th ▁ centered ▁ " + " hexadecagonal ▁ number : ▁ " , end = " " ) NEW_LINE print ( center_hexadecagonal_num ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT Q , H , S , D , N = map ( int , input ( ) . split ( ) ) NEW_LINE one_price = min ( min ( Q * 4 , H * 2 ) , S ) NEW_LINE if one_price <= D / 2 : NEW_LINE INDENT print ( N * one_price ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( N // 2 ) * D + ( N % 2 ) * one_price ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countNumbers ( L , R , K ) : NEW_LINE INDENT if K == 9 : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers // 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if rem1 == K : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT a , b , c , d , e , f = map ( int , line . split ( ) ) NEW_LINE y = min ( c , b ) NEW_LINE x = a NEW_LINE if y + x <= d : NEW_LINE INDENT print ( y * f + x * e ) NEW_LINE DEDENT elif f >= e : NEW_LINE INDENT print ( min ( y , d ) * f + ( d - min ( y , d ) ) * e ) NEW_LINE DEDENT elif e >= f : NEW_LINE INDENT print ( min ( x , d ) * e + ( d - min ( x , d ) ) * f ) NEW_LINE DEDENT DEDENT
import numpy as np NEW_LINE def Solution ( A ) : NEW_LINE INDENT ans = 2 NEW_LINE n = len ( A ) NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT llap = np . full ( n , 2 ) NEW_LINE A . sort ( ) NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while i >= 0 and k < n : NEW_LINE INDENT if A [ i ] + A [ k ] == 2 * A [ j ] : NEW_LINE INDENT llap [ j ] = max ( llap [ k ] + 1 , llap [ j ] ) NEW_LINE ans = max ( ans , llap [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT elif A [ i ] + A [ k ] < 2 * A [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT a = [ 9 , 4 , 7 , 2 , 10 ] NEW_LINE print ( Solution ( a ) ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def minimumChanges ( arr , n , d ) : NEW_LINE INDENT maxFreq = - 1 NEW_LINE freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = arr [ i ] - ( i ) * d NEW_LINE if a0 in freq : NEW_LINE INDENT freq [ a0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a0 ] = 1 NEW_LINE DEDENT if freq [ a0 ] > maxFreq : NEW_LINE INDENT maxFreq = freq [ a0 ] NEW_LINE DEDENT DEDENT return ( n - maxFreq ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 5 NEW_LINE d = 1 NEW_LINE arr = [ 1 , 3 , 3 , 4 , 6 ] NEW_LINE print ( GFG . minimumChanges ( arr , n , d ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE vec = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT vec . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT ans = 500 NEW_LINE ansprice = 20000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT fl = 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if vec [ i ] [ 0 ] < vec [ j ] [ 0 ] and vec [ i ] [ 1 ] < vec [ j ] [ 1 ] and vec [ i ] [ 2 ] < vec [ j ] [ 2 ] : NEW_LINE INDENT fl = 0 NEW_LINE DEDENT DEDENT if fl == 1 : NEW_LINE INDENT if vec [ i ] [ 3 ] < ansprice : NEW_LINE INDENT ansprice = vec [ i ] [ 3 ] NEW_LINE ans = i + 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import numpy as np NEW_LINE def countPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if a [ i ] + y < b [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT if b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y = 1 , 4 NEW_LINE a = [ 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 1 , 1 , 2 ] NEW_LINE m = len ( b ) NEW_LINE print ( countPoints ( n , m , a , b , x , y ) ) NEW_LINE DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 4 NEW_LINE print ( multiplyWith3Point5 ( x ) ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( n , a , s ) : NEW_LINE INDENT ans = - 1 NEW_LINE sum = 0 NEW_LINE r = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE r = min ( a [ i ] , r ) NEW_LINE DEDENT if sum < s : NEW_LINE INDENT return - 1 NEW_LINE DEDENT l = 0 NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if possible ( n , a , s , mid ) : NEW_LINE INDENT ans = mid NEW_LINE l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def possible ( n , a , s , least ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( a [ i ] - least ) NEW_LINE DEDENT if s <= sum : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , s = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( solve ( n , a , s ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 NEW_LINE maxi = 1 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] != s [ i - 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) NEW_LINE return maxi NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ccccdeededff " NEW_LINE print ( longestSubstring ( s ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT main = Main ( ) NEW_LINE main . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT k = int ( input ( ) ) NEW_LINE n = 50 NEW_LINE sum = k // n NEW_LINE amari = k % n NEW_LINE a = [ 0 ] * 50 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = i + sum NEW_LINE DEDENT for i in range ( amari ) : NEW_LINE INDENT a [ n - 1 - i ] += 1 NEW_LINE DEDENT print ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " \n " if i == n - 1 else " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def zeroUpto ( digits ) : NEW_LINE INDENT first = int ( ( pow ( 10 , digits ) - 1 ) / 9 ) NEW_LINE second = int ( ( pow ( 9 , digits ) - 1 ) / 8 ) NEW_LINE return 9 * ( first - second ) NEW_LINE DEDENT def toInt ( c ) : NEW_LINE INDENT return ord ( c ) - 48 NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT k = len ( num ) NEW_LINE total = GFG . zeroUpto ( k - 1 ) NEW_LINE non_zero = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT if num [ i ] == '0' : NEW_LINE INDENT non_zero -= 1 NEW_LINE break NEW_LINE DEDENT non_zero += ( GFG . toInt ( num [ i ] ) - 1 ) * ( pow ( 9 , k - 1 - i ) ) NEW_LINE DEDENT no = 0 NEW_LINE remaining = 0 NEW_LINE calculatedUpto = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT no = no * 10 + ( GFG . toInt ( num [ i ] ) ) NEW_LINE if i != 0 : NEW_LINE INDENT calculatedUpto = calculatedUpto * 10 + 9 NEW_LINE DEDENT DEDENT remaining = no - calculatedUpto NEW_LINE ans = GFG . zeroUpto ( k - 1 ) + ( remaining - non_zero - 1 ) NEW_LINE return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT num = "107" NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + num + " ▁ is ▁ " + str ( GFG . countZero ( num ) ) ) NEW_LINE num = "1264" NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + num + " ▁ is ▁ " + str ( GFG . countZero ( num ) ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def cone ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = ( a * math . sqrt ( 2 ) ) / 3 NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = 3.14 * ( r ** 2 ) * h NEW_LINE return V NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 5 NEW_LINE print ( " { : . 4f } " . format ( cone ( a ) ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def Prime ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkSumPrime ( str ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT summ += abs ( ord ( str [ i - 1 ] ) - ord ( str [ i ] ) ) NEW_LINE DEDENT if GFG . Prime ( summ ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT num = 142 NEW_LINE str = "142" NEW_LINE if GFG . checkSumPrime ( str ) : NEW_LINE INDENT print ( " Prime " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def sum ( self , n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + self . sum ( n - 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = GFG ( ) NEW_LINE print ( " { : . 3f } " . format ( g . sum ( 8 ) ) ) NEW_LINE print ( " { : . 3f } " . format ( g . sum ( 10 ) ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def countElements ( p , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT p = [ 2 , 5 , 1 , 3 , 4 ] NEW_LINE n = len ( p ) NEW_LINE print ( countElements ( p , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT a = input ( ) [ 0 ] NEW_LINE b = input ( ) [ 0 ] NEW_LINE if a > b : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def findVolume ( l , b , h ) : NEW_LINE INDENT volume = ( l * b * h ) / 2 NEW_LINE return volume NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 18 NEW_LINE b = 12 NEW_LINE h = 9 NEW_LINE print ( " Volume ▁ of ▁ triangular ▁ prism : ▁ " + str ( findVolume ( l , b , h ) ) ) NEW_LINE DEDENT
import sys NEW_LINE from collections import defaultdict NEW_LINE class c462b : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . left = 0 NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return self . left < other . left NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT f = sys . stdin NEW_LINE out = sys . stdout NEW_LINE n , k = map ( int , f . readline ( ) . split ( ) ) NEW_LINE cards = [ c462b ( ) for _ in range ( 26 ) ] NEW_LINE s = f . readline ( ) . strip ( ) NEW_LINE for t in range ( n ) : NEW_LINE INDENT cards [ ord ( s [ t ] ) - ord ( ' A ' ) ] . left += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT cards . sort ( ) NEW_LINE change = min ( cards [ 25 ] . left , k - i ) NEW_LINE ans += change * change NEW_LINE cards [ 25 ] . left -= change NEW_LINE i += change - 1 NEW_LINE DEDENT out . write ( str ( ans ) + ' \n ' ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class p045 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT i = 286 NEW_LINE j = 166 NEW_LINE k = 144 NEW_LINE while True : NEW_LINE INDENT triangle = i * ( i + 1 ) // 2 NEW_LINE pentagon = j * ( 3 * j - 1 ) // 2 NEW_LINE hexagon = k * ( 2 * k - 1 ) NEW_LINE min_val = min ( triangle , pentagon , hexagon ) NEW_LINE if min_val == triangle and min_val == pentagon and min_val == hexagon : NEW_LINE INDENT return str ( min_val ) NEW_LINE DEDENT if min_val == triangle : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if min_val == pentagon : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if min_val == hexagon : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT p = p045 ( ) NEW_LINE p . main ( [ ] ) NEW_LINE
class GFG : NEW_LINE INDENT def maxPrimefactorNum ( N ) : NEW_LINE INDENT if N < 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr = [ False ] * ( N + 1 ) NEW_LINE prod = 1 NEW_LINE res = 0 NEW_LINE p = 2 NEW_LINE while p * p <= N : NEW_LINE INDENT if not arr [ p ] : NEW_LINE INDENT i = p * 2 NEW_LINE while i <= N : NEW_LINE INDENT arr [ i ] = True NEW_LINE i += p NEW_LINE DEDENT prod *= p NEW_LINE if prod > N : NEW_LINE INDENT return res NEW_LINE DEDENT res += 1 NEW_LINE DEDENT p += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT N = 500 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def max_element ( a ) : NEW_LINE INDENT m = a [ 0 ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT m = max ( a [ i ] , m ) NEW_LINE DEDENT return m NEW_LINE DEDENT def checkDivisors ( a , n ) : NEW_LINE INDENT X = max_element ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( X ) ) + 1 ) : NEW_LINE INDENT if X % i == 0 : NEW_LINE INDENT b . append ( i ) NEW_LINE if X // i != i : NEW_LINE INDENT b . append ( X // i ) NEW_LINE DEDENT DEDENT DEDENT if len ( b ) != n : NEW_LINE INDENT return False NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] != a [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 8 , 1 , 2 , 12 , 48 , 6 , 4 , 24 , 16 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE if checkDivisors ( arr , N ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
class Test : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE @ staticmethod NEW_LINE def subArray ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( " All ▁ Non - empty ▁ Subarrays " ) NEW_LINE Test . subArray ( len ( arr ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE tc = int ( input ( ) ) NEW_LINE for _ in range ( tc ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x = float ( ' inf ' ) NEW_LINE y = float ( ' - inf ' ) NEW_LINE if n % 6 == 0 : NEW_LINE INDENT x = min ( x , n // 6 ) NEW_LINE y = max ( y , n // 6 ) NEW_LINE DEDENT if n % 6 == 2 and n != 2 : NEW_LINE INDENT x = min ( x , ( ( n // 6 ) - 1 ) + 2 ) NEW_LINE y = max ( y , ( ( n // 6 ) - 1 ) + 2 ) NEW_LINE DEDENT if n % 6 == 4 and n != 4 : NEW_LINE INDENT x = min ( x , n // 6 + 1 ) NEW_LINE y = max ( y , n // 6 + 1 ) NEW_LINE DEDENT if n % 4 == 0 : NEW_LINE INDENT x = min ( x , n // 4 ) NEW_LINE y = max ( y , n // 4 ) NEW_LINE DEDENT if n % 4 == 2 and n != 2 : NEW_LINE INDENT x = min ( x , ( n // 4 ) - 1 + 1 ) NEW_LINE y = max ( y , ( n // 4 ) - 1 + 1 ) NEW_LINE DEDENT if x != float ( ' inf ' ) and y != float ( ' - inf ' ) : NEW_LINE INDENT print ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( arr [ i ] * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 3 , 5 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import numpy as np NEW_LINE def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
import numpy as np NEW_LINE def findAnswer ( n , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 53 , 28 , 143 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAnswer ( n , arr ) ) NEW_LINE
import numpy as np NEW_LINE def findSum ( arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT if arr [ i ] != arr [ i + 1 ] : NEW_LINE INDENT sum = sum + arr [ i + 1 ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE print ( findSum ( arr ) ) NEW_LINE
from collections import deque NEW_LINE class GFG : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def newNode ( data ) : NEW_LINE INDENT temp = GFG . Node ( data ) NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE return temp NEW_LINE DEDENT @ staticmethod NEW_LINE def getDeepestLeftLeafNode ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return None NEW_LINE DEDENT q = deque ( ) NEW_LINE q . append ( root ) NEW_LINE result = None NEW_LINE while q : NEW_LINE INDENT temp = q . popleft ( ) NEW_LINE if temp . left : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE if temp . left . left is None and temp . left . right is None : NEW_LINE INDENT result = temp . left NEW_LINE DEDENT DEDENT if temp . right : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT root = self . newNode ( 1 ) NEW_LINE root . left = self . newNode ( 2 ) NEW_LINE root . right = self . newNode ( 3 ) NEW_LINE root . left . left = self . newNode ( 4 ) NEW_LINE root . right . left = self . newNode ( 5 ) NEW_LINE root . right . right = self . newNode ( 6 ) NEW_LINE root . right . left . right = self . newNode ( 7 ) NEW_LINE root . right . right . right = self . newNode ( 8 ) NEW_LINE root . right . left . right . left = self . newNode ( 9 ) NEW_LINE root . right . right . right . right = self . newNode ( 10 ) NEW_LINE result = self . getDeepestLeftLeafNode ( root ) NEW_LINE if result : NEW_LINE INDENT print ( " Deepest ▁ Left ▁ Leaf ▁ Node ▁ : : " , result . data ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ result , ▁ left ▁ leaf ▁ not ▁ found " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT gfg = GFG ( ) NEW_LINE gfg . main ( ) NEW_LINE DEDENT
from queue import Queue NEW_LINE class GFG : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def newNode ( data ) : NEW_LINE INDENT temp = GFG . Node ( data ) NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE return temp NEW_LINE DEDENT @ staticmethod NEW_LINE def getDeepestRightLeafNode ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return None NEW_LINE DEDENT q = Queue ( ) NEW_LINE q . put ( root ) NEW_LINE result = None NEW_LINE while not q . empty ( ) : NEW_LINE INDENT temp = q . get ( ) NEW_LINE if temp . left is not None : NEW_LINE INDENT q . put ( temp . left ) NEW_LINE DEDENT if temp . right is not None : NEW_LINE INDENT q . put ( temp . right ) NEW_LINE if temp . right . left is None and temp . right . right is None : NEW_LINE INDENT result = temp . right NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT root = self . newNode ( 1 ) NEW_LINE root . left = self . newNode ( 2 ) NEW_LINE root . right = self . newNode ( 3 ) NEW_LINE root . left . right = self . newNode ( 4 ) NEW_LINE root . right . left = self . newNode ( 5 ) NEW_LINE root . right . right = self . newNode ( 6 ) NEW_LINE root . right . left . right = self . newNode ( 7 ) NEW_LINE root . right . right . right = self . newNode ( 8 ) NEW_LINE root . right . left . right . left = self . newNode ( 9 ) NEW_LINE root . right . right . right . right = self . newNode ( 10 ) NEW_LINE result = self . getDeepestRightLeafNode ( root ) NEW_LINE if result is not None : NEW_LINE INDENT print ( " Deepest ▁ Right ▁ Leaf ▁ Node ▁ : : " , result . data ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ result , ▁ right ▁ leaf ▁ not ▁ found " ) NEW_LINE DEDENT DEDENT DEDENT gfg = GFG ( ) NEW_LINE gfg . main ( ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = [ 0 ] * ( n + 1 ) NEW_LINE arr [ 0 ] = 2 NEW_LINE arr [ 1 ] = 1 NEW_LINE for i in range ( 2 , len ( arr ) ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT print ( arr [ n ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def __gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def printRatio ( a , b , c , d ) : NEW_LINE INDENT if b * c > a * d : NEW_LINE INDENT temp = c NEW_LINE c = d NEW_LINE d = temp NEW_LINE temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT lcm = ( a * c ) // __gcd ( a , c ) NEW_LINE x = lcm // a NEW_LINE b *= x NEW_LINE y = lcm // c NEW_LINE d *= y NEW_LINE k = __gcd ( b , d ) NEW_LINE b //= k NEW_LINE d //= k NEW_LINE print ( str ( b ) + " : " + str ( d ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , b , c , d = 4 , 3 , 2 , 2 NEW_LINE printRatio ( a , b , c , d ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def maxsum_SIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i - 1 ] < arr [ i ] : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ sum ▁ : ▁ " + str ( GFG . maxsum_SIS ( arr , n ) ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def GCD ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def findMaxSumUtil ( arr , n ) : NEW_LINE INDENT finalGCD = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT finalGCD = GCD ( arr [ i ] , finalGCD ) NEW_LINE DEDENT return finalGCD NEW_LINE DEDENT def findMaxSum ( arr , n ) : NEW_LINE INDENT maxElement = findMaxSumUtil ( arr , n ) NEW_LINE return maxElement * n NEW_LINE DEDENT arr = [ 8 , 20 , 12 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE
import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT t = b NEW_LINE b = a % b NEW_LINE a = t NEW_LINE DEDENT return a NEW_LINE DEDENT def findMinDiff ( a , b , x , y ) : NEW_LINE INDENT g = gcd ( a , b ) NEW_LINE diff = abs ( x - y ) % g NEW_LINE return min ( diff , g - diff ) NEW_LINE DEDENT a = 20 NEW_LINE b = 52 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( findMinDiff ( a , b , x , y ) ) NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT a = int ( line ) NEW_LINE while a != 0 : NEW_LINE INDENT X , Y , W , H , N = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x , y = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE if ( X <= x <= X + W ) and ( Y <= y <= Y + H ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE a -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def divisibleby37 ( n1 ) : NEW_LINE INDENT l = len ( n1 ) NEW_LINE if n1 == "0" : NEW_LINE INDENT return 0 NEW_LINE DEDENT if l % 3 == 1 : NEW_LINE INDENT n1 = "00" + n1 NEW_LINE l += 2 NEW_LINE DEDENT elif l % 3 == 2 : NEW_LINE INDENT n1 = "0" + n1 NEW_LINE l += 1 NEW_LINE DEDENT n = list ( n1 ) NEW_LINE gSum = 0 NEW_LINE while l != 0 : NEW_LINE INDENT if l == 2 : NEW_LINE INDENT gvalue = ( int ( n [ l - 2 ] ) - 48 ) * 100 + ( int ( n [ l - 1 ] ) - 48 ) * 10 NEW_LINE DEDENT elif l == 1 : NEW_LINE INDENT gvalue = ( int ( n [ l - 1 ] ) - 48 ) * 100 NEW_LINE DEDENT else : NEW_LINE INDENT gvalue = ( int ( n [ l - 3 ] ) - 48 ) * 100 + ( int ( n [ l - 2 ] ) - 48 ) * 10 + ( int ( n [ l - 1 ] ) - 48 ) * 1 NEW_LINE DEDENT l = l - 3 NEW_LINE gSum = gSum + gvalue NEW_LINE DEDENT if gSum >= 1000 : NEW_LINE INDENT return GFG . divisibleby37 ( str ( gSum ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 if gSum % 37 == 0 else 0 NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT s = "8955795758" NEW_LINE if GFG . divisibleby37 ( s ) == 1 : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE import io NEW_LINE import math NEW_LINE class A111 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . fs = self . FastScanner ( ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT out = io . StringIO ( ) NEW_LINE n = self . fs . nextLong ( ) NEW_LINE x = self . fs . nextLong ( ) NEW_LINE y = self . fs . nextLong ( ) NEW_LINE p = y - n + 1 NEW_LINE pow = p * p + n - 1 NEW_LINE if pow < x or p <= 0 : NEW_LINE INDENT out . write ( " - 1 \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT out . write ( "1 \n " ) NEW_LINE DEDENT out . write ( str ( p ) + " \n " ) NEW_LINE DEDENT sys . stdout . write ( out . getvalue ( ) ) NEW_LINE DEDENT def sort ( self , a ) : NEW_LINE INDENT l = list ( a ) NEW_LINE l . sort ( ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT a [ i ] = l [ i ] NEW_LINE DEDENT DEDENT class FastScanner : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = io . StringIO ( sys . stdin . read ( ) ) NEW_LINE self . st = " " NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . st : NEW_LINE INDENT self . st = self . br . readline ( ) . strip ( ) NEW_LINE DEDENT result = self . st NEW_LINE self . st = " " NEW_LINE return result NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def readArray ( self , n ) : NEW_LINE INDENT a = [ self . nextInt ( ) for _ in range ( n ) ] NEW_LINE return a NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = A111 ( ) NEW_LINE a . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import numpy as np NEW_LINE def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = np . zeros ( ( m + 1 , n + 1 ) ) NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return int ( L [ m ] [ n ] ) NEW_LINE DEDENT def findMinCost ( X , Y , costX , costY ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE len_LCS = lcs ( X , Y , m , n ) NEW_LINE return costX * ( m - len_LCS ) + costY * ( n - len_LCS ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = " ef " NEW_LINE Y = " gh " NEW_LINE print ( " Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ identical ▁ is ▁ = " , findMinCost ( X , Y , 10 , 20 ) ) NEW_LINE DEDENT
def number_of_squares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base // 2 NEW_LINE return base * ( base + 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT base = 8 NEW_LINE print ( number_of_squares ( base ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE def rmsValue ( arr , n ) : NEW_LINE INDENT square = 0 NEW_LINE mean = 0 NEW_LINE root = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT square += arr [ i ] ** 2 NEW_LINE DEDENT mean = square / float ( n ) NEW_LINE root = math . sqrt ( mean ) NEW_LINE return root NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 4 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " { : . 4f } " . format ( rmsValue ( arr , n ) ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE M , N = map ( int , input ( ) . split ( ) ) NEW_LINE P = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE P . sort ( ) NEW_LINE dp = [ float ( ' inf ' ) ] * ( M + 10001 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for _ in range ( N ) : NEW_LINE INDENT C , E = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( len ( dp ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if j - C >= 0 and dp [ j - C ] != float ( ' inf ' ) : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , dp [ j - C ] + E ) NEW_LINE DEDENT DEDENT DEDENT sum_arr = [ 0 ] * len ( dp ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT sum_arr [ i + 1 ] = sum_arr [ i ] + P [ M - 1 - i ] NEW_LINE DEDENT for i in range ( M + 1 , len ( sum_arr ) ) : NEW_LINE INDENT sum_arr [ i ] = sum_arr [ M ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( sum_arr ) ) : NEW_LINE INDENT if dp [ i ] != float ( ' inf ' ) : NEW_LINE INDENT ans = max ( ans , sum_arr [ i ] - dp [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE array = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT array [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " node ▁ % d : ▁ key ▁ = ▁ % d , ▁ " % ( i , array [ i ] ) , end = " " ) NEW_LINE if i // 2 > 0 : NEW_LINE INDENT print ( " parent ▁ key ▁ = ▁ % d , ▁ " % array [ i // 2 ] , end = " " ) NEW_LINE DEDENT if 2 * i <= n : NEW_LINE INDENT print ( " left ▁ key ▁ = ▁ % d , ▁ " % array [ 2 * i ] , end = " " ) NEW_LINE DEDENT if ( 2 * i + 1 ) <= n : NEW_LINE INDENT print ( " right ▁ key ▁ = ▁ % d , ▁ " % array [ 2 * i + 1 ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT n = 6 NEW_LINE m = 6 NEW_LINE @ staticmethod NEW_LINE def maxSum ( arr ) : NEW_LINE INDENT dp = [ [ 0 ] * 3 for _ in range ( GFG . n + 1 ) ] NEW_LINE for i in range ( GFG . n ) : NEW_LINE INDENT m1 , m2 , m3 = 0 , 0 , 0 NEW_LINE for j in range ( GFG . m ) : NEW_LINE INDENT if ( j // ( GFG . m // 3 ) ) == 0 : NEW_LINE INDENT m1 = max ( m1 , arr [ i ] [ j ] ) NEW_LINE DEDENT elif ( j // ( GFG . m // 3 ) ) == 1 : NEW_LINE INDENT m2 = max ( m2 , arr [ i ] [ j ] ) NEW_LINE DEDENT elif ( j // ( GFG . m // 3 ) ) == 2 : NEW_LINE INDENT m3 = max ( m3 , arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 NEW_LINE dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 NEW_LINE DEDENT print ( max ( max ( dp [ GFG . n ] [ 0 ] , dp [ GFG . n ] [ 1 ] ) , dp [ GFG . n ] [ 2 ] ) ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT arr = [ [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] ] NEW_LINE GFG . maxSum ( arr ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
` ` ` python NEW_LINE def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y1 , y3 ) NEW_LINE x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE if x5 > x6 or y5 > y6 : NEW_LINE INDENT print ( " No ▁ intersection " ) NEW_LINE return NEW_LINE DEDENT print ( " ( " , x5 , " , ▁ " , y5 , " ) ▁ " , end = " " ) NEW_LINE print ( " ( " , x6 , " , ▁ " , y6 , " ) ▁ " , end = " " ) NEW_LINE x7 = x5 NEW_LINE y7 = y6 NEW_LINE print ( " ( " , x7 , " , ▁ " , y7 , " ) ▁ " , end = " " ) NEW_LINE x8 = x6 NEW_LINE y8 = y5 NEW_LINE print ( " ( " , x8 , " , ▁ " , y8 , " ) ▁ " , end = " " ) NEW_LINE DEDENT x1 , y1 , x2 , y2 = 0 , 0 , 10 , 8 NEW_LINE x3 , y3 , x4 , y4 = 2 , 3 , 7 , 9 NEW_LINE FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE sittingToStanding = 0 NEW_LINE sitting = 0 NEW_LINE standing = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' x ' : NEW_LINE INDENT sitting += 1 NEW_LINE DEDENT else : NEW_LINE INDENT standing += 1 NEW_LINE DEDENT DEDENT sittingToStanding = ( sitting - standing ) // 2 NEW_LINE print ( abs ( sittingToStanding ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' x ' and sittingToStanding > 0 : NEW_LINE INDENT print ( ' X ' , end = ' ' ) NEW_LINE sittingToStanding -= 1 NEW_LINE DEDENT elif s [ i ] == ' X ' and sittingToStanding < 0 : NEW_LINE INDENT print ( ' x ' , end = ' ' ) NEW_LINE sittingToStanding += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = sys . stdin NEW_LINE self . st = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st is None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = self . br . readline ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT return self . br . readline ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT input = FastReader ( ) NEW_LINE n = input . nextInt ( ) NEW_LINE d = input . nextInt ( ) NEW_LINE e = input . nextInt ( ) NEW_LINE ans = n NEW_LINE i = 0 NEW_LINE while i * 5 * e <= n : NEW_LINE INDENT ans = min ( ans , ( n - i * 5 * e ) % d ) NEW_LINE i += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def knapSack ( W , wt , val , n ) : NEW_LINE INDENT maxratio = float ( ' - inf ' ) NEW_LINE maxindex = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( val [ i ] / wt [ i ] ) > maxratio : NEW_LINE INDENT maxratio = ( val [ i ] / wt [ i ] ) NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT return ( W * maxratio ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT val = [ 14 , 27 , 44 , 19 ] NEW_LINE wt = [ 6 , 7 , 9 , 8 ] NEW_LINE n = len ( val ) NEW_LINE W = 50 NEW_LINE print ( knapSack ( W , wt , val , n ) ) NEW_LINE DEDENT DEDENT
import numpy as np NEW_LINE def AlternateRearrange ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT index = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE flag = False NEW_LINE if arr [ 0 ] % 2 == 0 : NEW_LINE INDENT flag = True NEW_LINE DEDENT while index < n : NEW_LINE INDENT if flag == True : NEW_LINE INDENT arr [ index ] = v1 [ i ] NEW_LINE i += 1 NEW_LINE index += 1 NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = v2 [ j ] NEW_LINE j += 1 NEW_LINE index += 1 NEW_LINE flag = not flag NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 9 , 8 , 13 , 2 , 19 , 14 ] NEW_LINE n = len ( arr ) NEW_LINE AlternateRearrange ( arr , n ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT A = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE C = int ( input ( ) ) NEW_LINE if A <= C and B >= C : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import java . util NEW_LINE def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 NEW_LINE i = 0 NEW_LINE while n > 0 : NEW_LINE INDENT binaryNum [ i ] = n % 2 NEW_LINE n = n // 2 NEW_LINE i += 1 NEW_LINE DEDENT binary = " " NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT binary += str ( binaryNum [ j ] ) NEW_LINE DEDENT return binary NEW_LINE DEDENT def countFreq ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE res = 0 NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while j < M : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT res += 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def findOccurrence ( arr , n , pattern ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT binary = decToBinary ( arr [ i ] ) NEW_LINE print ( countFreq ( pattern , binary ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 106 , 7 , 8 ] NEW_LINE pattern = "10" NEW_LINE n = len ( arr ) NEW_LINE findOccurrence ( arr , n , pattern ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += ( arr [ i ] & 1 ) NEW_LINE DEDENT print ( min ( x , n - x ) ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE GFG . makearrayequal ( arr , n ) NEW_LINE DEDENT DEDENT
import random NEW_LINE class Solution : NEW_LINE INDENT def findKthLargest ( self , nums , k ) : NEW_LINE INDENT self . shuffle ( nums ) NEW_LINE k = len ( nums ) - k NEW_LINE lo = 0 NEW_LINE hi = len ( nums ) - 1 NEW_LINE while lo < hi : NEW_LINE INDENT j = self . partition ( nums , lo , hi ) NEW_LINE if j < k : NEW_LINE INDENT lo = j + 1 NEW_LINE DEDENT elif j > k : NEW_LINE INDENT hi = j - 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return nums [ k ] NEW_LINE DEDENT def partition ( self , a , lo , hi ) : NEW_LINE INDENT i = lo NEW_LINE j = hi + 1 NEW_LINE while True : NEW_LINE INDENT while i < hi and self . less ( a [ i + 1 ] , a [ lo ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while j > lo and self . less ( a [ lo ] , a [ j - 1 ] ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if i >= j : NEW_LINE INDENT break NEW_LINE DEDENT self . exch ( a , i , j ) NEW_LINE DEDENT self . exch ( a , lo , j ) NEW_LINE return j NEW_LINE DEDENT def exch ( self , a , i , j ) : NEW_LINE INDENT tmp = a [ i ] NEW_LINE a [ i ] = a [ j ] NEW_LINE a [ j ] = tmp NEW_LINE DEDENT def less ( self , v , w ) : NEW_LINE INDENT return v < w NEW_LINE DEDENT def shuffle ( self , a ) : NEW_LINE INDENT for ind in range ( 1 , len ( a ) ) : NEW_LINE INDENT r = random . randint ( 0 , ind ) NEW_LINE self . exch ( a , ind , r ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 3 , 2 , 1 , 5 , 6 , 4 ] NEW_LINE k = 2 NEW_LINE out = sObj . findKthLargest ( nums , k ) NEW_LINE print ( out ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE while n > 0 : NEW_LINE INDENT k = n % 10 NEW_LINE if temp % k == 0 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return " NO " NEW_LINE DEDENT n = 9876543 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT k = int ( n % 10 ) NEW_LINE sum += k NEW_LINE n //= 10 NEW_LINE DEDENT if temp % sum == 0 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT return " NO " NEW_LINE DEDENT n = 123 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT a = input ( ) NEW_LINE b = input ( ) NEW_LINE answer = " " NEW_LINE naa = len ( a ) NEW_LINE nab = len ( b ) NEW_LINE i = 0 NEW_LINE if naa == nab : NEW_LINE INDENT if a == b : NEW_LINE INDENT answer = " EQUAL " NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( naa ) : NEW_LINE INDENT q = ord ( a [ i ] ) NEW_LINE l = ord ( b [ i ] ) NEW_LINE if q > l : NEW_LINE INDENT answer = " GREATER " NEW_LINE break NEW_LINE DEDENT elif q < l : NEW_LINE INDENT answer = " LESS " NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT elif naa > nab : NEW_LINE INDENT answer = " GREATER " NEW_LINE DEDENT elif naa < nab : NEW_LINE INDENT answer = " LESS " NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE INDENT totalSquares = ( l - size + 1 ) * ( b - size + 1 ) NEW_LINE area = totalSquares * size * size NEW_LINE totalArea += area NEW_LINE size += 1 NEW_LINE DEDENT return totalArea NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT l = 4 NEW_LINE b = 3 NEW_LINE print ( self . calculateAreaSum ( l , b ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def arrange ( N ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT print ( "1" ) NEW_LINE return NEW_LINE DEDENT if N == 2 or N == 3 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT even = - 1 NEW_LINE odd = - 1 NEW_LINE if N % 2 == 0 : NEW_LINE INDENT even = N NEW_LINE odd = N - 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = N NEW_LINE even = N - 1 NEW_LINE DEDENT while odd >= 1 : NEW_LINE INDENT print ( odd , end = " ▁ " ) NEW_LINE odd = odd - 2 NEW_LINE DEDENT while even >= 2 : NEW_LINE INDENT print ( even , end = " ▁ " ) NEW_LINE even = even - 2 NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT N = 5 NEW_LINE GFG . arrange ( N ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
import java NEW_LINE def findMinEqualSums ( a , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE min = java . lang . Integer . MAX_VALUE NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE sum2 = sum - sum1 NEW_LINE if abs ( sum1 - sum2 ) < min : NEW_LINE INDENT min = abs ( sum1 - sum2 ) NEW_LINE DEDENT if min == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 2 , 1 , 5 , 7 , 8 ] NEW_LINE N = len ( a ) NEW_LINE print ( findMinEqualSums ( a , N ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE builder = " " NEW_LINE mod = n % 3 NEW_LINE if mod == 1 : NEW_LINE INDENT for j in range ( n // 3 ) : NEW_LINE INDENT builder += "12" NEW_LINE DEDENT builder += "1" NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( n // 3 ) : NEW_LINE INDENT builder += "21" NEW_LINE DEDENT if mod == 2 : NEW_LINE INDENT builder += "2" NEW_LINE DEDENT DEDENT print ( builder ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import numpy as np NEW_LINE def findOptimalSolution ( a , N ) : NEW_LINE INDENT a . sort ( ) NEW_LINE points = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT points += a [ i ] * i NEW_LINE DEDENT return points NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEW_LINE N = len ( a ) NEW_LINE print ( findOptimalSolution ( a , N ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE import queue NEW_LINE import heapq NEW_LINE def main ( ) : NEW_LINE INDENT tasks = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE taskList = queue . Queue ( ) NEW_LINE events = [ ] NEW_LINE taskDur = [ 0 ] * tasks [ 0 ] NEW_LINE for i in range ( tasks [ 0 ] ) : NEW_LINE INDENT taskInput = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE taskDur [ i ] = taskInput [ 1 ] NEW_LINE events . append ( taskInput [ 0 ] * 2 + 1 ) NEW_LINE DEDENT sol = [ 0 ] * tasks [ 0 ] NEW_LINE nextTask = 0 NEW_LINE while len ( events ) > 0 : NEW_LINE INDENT event = events . pop ( 0 ) NEW_LINE time = event // 2 NEW_LINE if event % 2 == 0 : NEW_LINE INDENT taskId = taskList . get ( ) NEW_LINE sol [ taskId ] = time NEW_LINE if not taskList . empty ( ) : NEW_LINE INDENT heapq . heappush ( events , ( time + taskDur [ taskList . queue [ 0 ] ] ) * 2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT task = nextTask NEW_LINE nextTask += 1 NEW_LINE if taskList . qsize ( ) <= tasks [ 1 ] : NEW_LINE INDENT taskList . put ( task ) NEW_LINE if taskList . qsize ( ) == 1 : NEW_LINE INDENT heapq . heappush ( events , ( time + taskDur [ task ] ) * 2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT sol [ task ] = - 1 NEW_LINE DEDENT DEDENT DEDENT print ( ' ▁ ' . join ( map ( str , sol ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n > m : NEW_LINE INDENT print ( " NO " ) NEW_LINE continue NEW_LINE DEDENT a . sort ( ) NEW_LINE ans = a [ - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE if i > 0 : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT DEDENT if ans <= m : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def getPairs ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] < a [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = [ 2 , 4 , 3 , 1 ] NEW_LINE print ( getPairs ( a ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = sys . stdin NEW_LINE self . st = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st is None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = self . br . readline ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT return self . br . readline ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT obj = FastReader ( ) NEW_LINE n = obj . nextInt ( ) NEW_LINE k = obj . nextInt ( ) NEW_LINE num = list ( obj . next ( ) ) NEW_LINE if n == 1 and k > 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if k > 0 : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT if num [ i ] == '1' : NEW_LINE INDENT continue NEW_LINE DEDENT num [ i ] = '1' NEW_LINE k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if num [ i ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT num [ i ] = '0' NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT sys . stdout . write ( num [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ [ 0 ] * 4 for _ in range ( 4 ) ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT arr [ i ] [ j ] = int ( input ( ) ) NEW_LINE DEDENT DEDENT if arr [ 0 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 0 ] [ 1 ] == 1 or arr [ 0 ] [ 2 ] == 1 or arr [ 0 ] [ 0 ] == 1 or arr [ 1 ] [ 0 ] == 1 or arr [ 2 ] [ 1 ] == 1 or arr [ 3 ] [ 2 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 1 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 1 ] [ 1 ] == 1 or arr [ 1 ] [ 2 ] == 1 or arr [ 1 ] [ 0 ] == 1 or arr [ 2 ] [ 0 ] == 1 or arr [ 3 ] [ 1 ] == 1 or arr [ 0 ] [ 2 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 2 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 2 ] [ 1 ] == 1 or arr [ 2 ] [ 2 ] == 1 or arr [ 2 ] [ 0 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 0 ] [ 1 ] == 1 or arr [ 1 ] [ 2 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 3 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 3 ] [ 1 ] == 1 or arr [ 3 ] [ 2 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 0 ] [ 0 ] == 1 or arr [ 1 ] [ 1 ] == 1 or arr [ 2 ] [ 2 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
N = 10000 NEW_LINE MOD = 1000000007 NEW_LINE F = [ 0 ] * N NEW_LINE def precompute ( ) : NEW_LINE INDENT F [ 1 ] = 2 NEW_LINE F [ 2 ] = 3 NEW_LINE F [ 3 ] = 4 NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 8 NEW_LINE precompute ( ) NEW_LINE print ( F [ n ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( z ) : NEW_LINE INDENT i , j , k , c , t , b = 0 , 0 , 0 , 0 , 0 , 0 NEW_LINE s = input ( ) NEW_LINE t = int ( s ) NEW_LINE while t > 0 : NEW_LINE INDENT b = 0 NEW_LINE i = 0 NEW_LINE while i < t : NEW_LINE INDENT j = i + 1 NEW_LINE while j < t : NEW_LINE INDENT c = 0 NEW_LINE k = i NEW_LINE while k < j : NEW_LINE INDENT c += k NEW_LINE k += 1 NEW_LINE DEDENT b += 1 if c == t else 0 NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( b ) NEW_LINE t = int ( input ( ) ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class LIS : NEW_LINE INDENT @ staticmethod NEW_LINE def CeilIndex ( A , l , r , key ) : NEW_LINE INDENT while r - l > 1 : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if A [ m ] >= key : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT @ staticmethod NEW_LINE def LongestIncreasingSubsequenceLength ( A , size ) : NEW_LINE INDENT tailTable = [ 0 ] * size NEW_LINE len = 0 NEW_LINE tailTable [ 0 ] = A [ 0 ] NEW_LINE len = 1 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT if A [ i ] < tailTable [ 0 ] : NEW_LINE INDENT tailTable [ 0 ] = A [ i ] NEW_LINE DEDENT elif A [ i ] > tailTable [ len - 1 ] : NEW_LINE INDENT tailTable [ len ] = A [ i ] NEW_LINE len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tailTable [ LIS . CeilIndex ( tailTable , - 1 , len - 1 , A [ i ] ) ] = A [ i ] NEW_LINE DEDENT DEDENT return len NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT A = [ 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 ] NEW_LINE n = len ( A ) NEW_LINE print ( " Length ▁ of ▁ Longest ▁ Increasing ▁ Subsequence ▁ is " , LIS . LongestIncreasingSubsequenceLength ( A , n ) ) NEW_LINE DEDENT DEDENT LIS . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE N = int ( input ( ) ) NEW_LINE ban = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ban . sort ( ) NEW_LINE print ( ( ban [ - 1 ] - ban [ 0 ] + 1 ) // 2 ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class p074 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT LIMIT = pow ( 10 , 6 ) NEW_LINE def run ( self ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , self . LIMIT ) : NEW_LINE INDENT if self . get_chain_length ( i ) == 60 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT def get_chain_length ( self , n ) : NEW_LINE INDENT seen = set ( ) NEW_LINE while True : NEW_LINE INDENT if n in seen : NEW_LINE INDENT return len ( seen ) NEW_LINE DEDENT seen . add ( n ) NEW_LINE n = self . factorialize ( n ) NEW_LINE DEDENT DEDENT FACTORIAL = [ 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 ] NEW_LINE def factorialize ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum += self . FACTORIAL [ n % 10 ] NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT p = p074 ( ) NEW_LINE p . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def colourVisible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 ] * ( K + 1 ) NEW_LINE visible = 0 NEW_LINE max_height = height [ K - 1 ] NEW_LINE arr [ colour [ K - 1 ] ] = 1 NEW_LINE for i in range ( K - 2 , - 1 , - 1 ) : NEW_LINE INDENT if height [ i ] > max_height : NEW_LINE INDENT max_height = height [ i ] NEW_LINE arr [ colour [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT visible += 1 NEW_LINE DEDENT DEDENT return visible NEW_LINE DEDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE colour = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE K = len ( colour ) NEW_LINE print ( GFG . colourVisible ( height , colour , K ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = math . log ( n ) / math . log ( 8 ) NEW_LINE return ( i - math . floor ( i ) < 0.000001 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 65 NEW_LINE if checkPowerof8 ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE res = min ( ( a + b ) // 4 , min ( a , b ) ) NEW_LINE print ( res ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . maxes = [ ] NEW_LINE DEDENT def go ( self ) : NEW_LINE INDENT import sys NEW_LINE while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT points = [ 0 ] * n NEW_LINE max_val = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT points [ j ] += int ( input ( ) ) NEW_LINE if i == m - 1 and max_val < points [ j ] : NEW_LINE INDENT max_val = points [ j ] NEW_LINE DEDENT DEDENT DEDENT self . maxes . append ( max_val ) NEW_LINE DEDENT for max_val in self . maxes : NEW_LINE INDENT print ( max_val ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . go ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s < r [ i ] : NEW_LINE INDENT if l [ i ] > s : NEW_LINE INDENT s = l [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT s += 1 NEW_LINE DEDENT print ( s , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def countWays ( n , m ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i > m : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif i < m : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = 7 NEW_LINE m = 4 NEW_LINE print ( " Number ▁ of ▁ ways ▁ = ▁ " , self . countWays ( n , m ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def print ( n ) : NEW_LINE INDENT print ( n + n // 2 ) NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT n = 3 NEW_LINE GFG . print ( n ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT try : NEW_LINE INDENT str = input ( ) NEW_LINE res = 0 NEW_LINE han = 0 NEW_LINE ni_beki = 1 NEW_LINE ruijyo = 0 NEW_LINE if str == " " : NEW_LINE INDENT sys . exit ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res = int ( str ) NEW_LINE i = 0 NEW_LINE while i < 1 : NEW_LINE INDENT han = ( res >> ruijyo ) % 2 NEW_LINE if han == 0 : NEW_LINE INDENT res = ( res % ni_beki ) + 1 NEW_LINE i = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT ni_beki = ni_beki * 2 NEW_LINE ruijyo += 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT print ( sys . exc_info ( ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE while "0B " in s or "1B " in s : NEW_LINE INDENT s = s . replace ( "0B " , " " ) NEW_LINE s = s . replace ( "1B " , " " ) NEW_LINE DEDENT s = s . replace ( " B " , " " ) NEW_LINE print ( s ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE from itertools import permutations NEW_LINE while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE used = [ ] NEW_LINE for perm in permutations ( range ( 1 , a + 1 ) , 3 ) : NEW_LINE INDENT if sum ( perm ) == b : NEW_LINE INDENT sorted_perm = sorted ( perm ) NEW_LINE if sorted_perm in used : NEW_LINE INDENT continue NEW_LINE DEDENT used . append ( sorted_perm ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT MAX = 100 NEW_LINE def recur ( ind , cnt , last , a , n , k , dp ) : NEW_LINE INDENT if cnt == k : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ind == n : NEW_LINE INDENT return - 1e9 NEW_LINE DEDENT if dp [ ind ] [ cnt ] != - 1 : NEW_LINE INDENT return dp [ ind ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( ind , n ) : NEW_LINE INDENT if cnt % 2 == 0 : NEW_LINE INDENT ans = max ( ans , GFG . recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , GFG . __gcd ( a [ last ] , a [ i ] ) + GFG . recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) NEW_LINE DEDENT DEDENT dp [ ind ] [ cnt ] = ans NEW_LINE return dp [ ind ] [ cnt ] NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return GFG . __gcd ( b , a % b ) NEW_LINE DEDENT a = [ 4 , 5 , 3 , 7 , 8 , 10 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE k = 4 NEW_LINE dp = [ [ - 1 for j in range ( GFG . MAX ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( GFG . MAX ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT print ( GFG . recur ( 0 , 0 , 0 , a , n , k , dp ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE non_int = 0 NEW_LINE sum_before = 0 NEW_LINE sum = 0 NEW_LINE for num in arr : NEW_LINE INDENT sum_before += num NEW_LINE if num != int ( num ) : NEW_LINE INDENT non_int += 1 NEW_LINE DEDENT sum += int ( num ) NEW_LINE DEDENT max_sum = min ( n , non_int ) + sum NEW_LINE min_sum = max ( 0 , non_int - n ) + sum NEW_LINE if min_sum > sum_before : NEW_LINE INDENT ans = ( min_sum - sum_before ) NEW_LINE DEDENT elif max_sum < sum_before : NEW_LINE INDENT ans = ( sum_before - max_sum ) NEW_LINE DEDENT else : NEW_LINE INDENT x = sum_before - int ( sum_before ) NEW_LINE ans = min ( 1 - x , x ) NEW_LINE DEDENT print ( " { : . 3f } " . format ( ans ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def equivalentBase4 ( bin ) : NEW_LINE INDENT if bin == "00" : NEW_LINE INDENT return 0 NEW_LINE DEDENT if bin == "01" : NEW_LINE INDENT return 1 NEW_LINE DEDENT if bin == "10" : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT def isDivisibleBy5 ( bin ) : NEW_LINE INDENT l = len ( bin ) NEW_LINE if l % 2 != 0 : NEW_LINE INDENT bin = '0' + bin NEW_LINE DEDENT odd_sum = 0 NEW_LINE even_sum = 0 NEW_LINE isOddDigit = 1 NEW_LINE for i in range ( 0 , len ( bin ) , 2 ) : NEW_LINE INDENT if isOddDigit != 0 : NEW_LINE INDENT odd_sum += equivalentBase4 ( bin [ i : i + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT even_sum += equivalentBase4 ( bin [ i : i + 2 ] ) NEW_LINE DEDENT isOddDigit ^= 1 NEW_LINE DEDENT if abs ( odd_sum - even_sum ) % 5 == 0 : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT bin = "10000101001" NEW_LINE print ( isDivisibleBy5 ( bin ) ) NEW_LINE DEDENT DEDENT
from collections import deque NEW_LINE queue = deque ( ) NEW_LINE map = { } NEW_LINE str = " " NEW_LINE d = [ [ 0 , 1 , 4 ] , [ - 1 , 1 , 4 ] , [ - 1 , 1 , 4 ] , [ - 1 , 0 , 4 ] , [ 0 , 1 , - 4 ] , [ - 1 , 1 , - 4 ] , [ - 1 , 1 , - 4 ] , [ - 1 , 0 , - 4 ] ] NEW_LINE def bfs ( ) : NEW_LINE INDENT while queue : NEW_LINE INDENT str1 = queue . popleft ( ) NEW_LINE point = map [ str1 ] NEW_LINE str2 = " " NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT if str1 [ i ] == '0' : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT change = str1 [ i + d [ i ] [ j ] ] NEW_LINE str2 = str1 . replace ( '0' , '9' ) NEW_LINE str2 = str2 . replace ( change , '0' ) NEW_LINE str2 = str2 . replace ( '9' , change ) NEW_LINE if str2 not in map : NEW_LINE INDENT map [ str2 ] = point + 1 NEW_LINE queue . append ( str2 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT queue . append ( "01234567" ) NEW_LINE map [ "01234567" ] = 0 NEW_LINE bfs ( ) NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT s = input ( ) NEW_LINE token = s . split ( " ▁ " ) NEW_LINE str = " " . join ( token ) NEW_LINE print ( map . get ( str ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def util ( arr , ops , idx ) : NEW_LINE INDENT global min NEW_LINE if idx == 3 : NEW_LINE INDENT min = min ( arr [ 0 ] , min ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( arr ) ) : NEW_LINE INDENT a = [ arr [ k ] for k in range ( len ( arr ) ) if k != j and k != i ] NEW_LINE if ops [ idx ] == " + " : NEW_LINE INDENT res = arr [ i ] + arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT res = arr [ i ] * arr [ j ] NEW_LINE DEDENT a . append ( res ) NEW_LINE util ( a , ops , idx + 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT min = sys . maxsize NEW_LINE arr = [ ] NEW_LINE for _ in range ( 4 ) : NEW_LINE INDENT arr . append ( int ( input ( ) ) ) NEW_LINE DEDENT ops = [ input ( ) for _ in range ( 3 ) ] NEW_LINE util ( arr , ops , 0 ) NEW_LINE print ( min ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT MAX = 1005 NEW_LINE prime = [ True ] * MAX NEW_LINE for p in range ( 2 , int ( math . sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def minimumSquareFreeDivisors ( N ) : NEW_LINE INDENT primes = [ ] NEW_LINE SieveOfEratosthenes ( primes ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( primes ) and primes [ i ] * primes [ i ] <= N : NEW_LINE INDENT if N % primes [ i ] == 0 : NEW_LINE INDENT tmp = 0 NEW_LINE while N % primes [ i ] == 0 : NEW_LINE INDENT tmp += 1 NEW_LINE N //= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if max_count == 0 : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 24 NEW_LINE print ( " Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is " , minimumSquareFreeDivisors ( N ) ) NEW_LINE N = 6 NEW_LINE print ( " Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is " , minimumSquareFreeDivisors ( N ) ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( x - a ) % b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE idx = k - 1 NEW_LINE flag = True NEW_LINE while idx < n : NEW_LINE INDENT if arr [ idx ] != arr [ k - 1 ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT idx += 1 NEW_LINE DEDENT if not flag : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT i = k - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if arr [ i ] != arr [ k - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( i + 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT n = 7 NEW_LINE print ( " The ▁ number ▁ after ▁ unsetting ▁ the ▁ rightmost ▁ set ▁ bit " , fun ( n ) ) NEW_LINE
` ` ` python NEW_LINE from sortedcontainers import SortedSet NEW_LINE def LongestFibSubseq ( A , n ) : NEW_LINE INDENT S = SortedSet ( ) NEW_LINE for t in A : NEW_LINE INDENT S . add ( t ) NEW_LINE DEDENT maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ j ] NEW_LINE y = A [ i ] + A [ j ] NEW_LINE length = 3 NEW_LINE while S . __contains__ ( y ) and ( y != S [ - 1 ] ) : NEW_LINE INDENT z = x + y NEW_LINE x = y NEW_LINE y = z NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE length += 1 NEW_LINE DEDENT DEDENT DEDENT return maxLen if maxLen >= 3 else 0 NEW_LINE DEDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countPairs ( a , b , n , m ) : NEW_LINE INDENT cnt = 0 NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT sum = a [ i ] + b [ j ] NEW_LINE if sum not in s : NEW_LINE INDENT cnt += 1 NEW_LINE s . add ( sum ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = [ 12 , 2 , 7 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 4 , 3 , 8 ] NEW_LINE m = len ( b ) NEW_LINE print ( countPairs ( a , b , n , m ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def check ( arr , x , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = arr [ i ] ** 0.5 NEW_LINE if y . is_integer ( ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if sum % x == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 13 NEW_LINE if GFG . check ( arr , x , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
import heapq NEW_LINE n = int ( input ( ) ) NEW_LINE pque = [ [ ] for _ in range ( n ) ] NEW_LINE q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT command , t = map ( int , input ( ) . split ( ) ) NEW_LINE if command == 0 : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE heapq . heappush ( pque [ t ] , - x ) NEW_LINE DEDENT elif command == 1 : NEW_LINE INDENT if pque [ t ] : NEW_LINE INDENT print ( - pque [ t ] [ 0 ] ) NEW_LINE DEDENT DEDENT elif command == 2 : NEW_LINE INDENT if pque [ t ] : NEW_LINE INDENT heapq . heappop ( pque [ t ] ) NEW_LINE DEDENT DEDENT DEDENT
import numpy as np NEW_LINE def calculate_min_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE min_sum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT min_sum += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT return min_sum NEW_LINE DEDENT def calculate_max_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE max_sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT max_sum += abs ( a [ n - 1 - i ] - a [ i ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 10 , - 10 , 20 , - 40 ] NEW_LINE n = len ( a ) NEW_LINE print ( " The ▁ minimum ▁ sum ▁ of ▁ pairs ▁ is " , calculate_min_sum ( a , n ) ) NEW_LINE print ( " The ▁ maximum ▁ sum ▁ of ▁ pairs ▁ is " , calculate_max_sum ( a , n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT if i >= len ( b ) : NEW_LINE INDENT print ( "0" ) NEW_LINE break NEW_LINE DEDENT if i >= len ( a ) : NEW_LINE INDENT print ( "1" ) NEW_LINE break NEW_LINE DEDENT if a [ i ] > b [ i ] : NEW_LINE INDENT print ( "0" ) NEW_LINE break NEW_LINE DEDENT if a [ i ] < b [ i ] : NEW_LINE INDENT print ( "1" ) NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT sum = 0 NEW_LINE a = int ( input ( ) ) NEW_LINE stateList = [ ] NEW_LINE cnt4 = 0 NEW_LINE cnt2 = 0 NEW_LINE work = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT stateList . append ( int ( input ( ) ) ) NEW_LINE work = stateList [ i ] % 4 NEW_LINE if work == 0 : NEW_LINE INDENT cnt4 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT work = stateList [ i ] % 2 NEW_LINE if work == 0 : NEW_LINE INDENT cnt2 += 1 NEW_LINE DEDENT DEDENT DEDENT work = a // 2 NEW_LINE if work <= cnt4 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT work = a - ( cnt4 * 2 ) NEW_LINE if ( work == 0 ) or ( cnt2 == 0 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT if work == cnt2 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT print ( " No " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def isPalindrome ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ len ( s ) - i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def ans ( s ) : NEW_LINE INDENT s2 = s NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s2 = s2 [ len ( s2 ) - 1 ] + s2 NEW_LINE s2 = s2 [ : - 1 ] NEW_LINE if ( ( s is None and s2 is not None ) or ( s != s2 ) ) and isPalindrome ( s2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT if len ( s ) <= 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 ] * 25 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if max ( cnt ) >= ( len ( s ) - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 if ans ( s ) else 2 NEW_LINE DEDENT DEDENT s = " nolon " NEW_LINE print ( solve ( s ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def count_numbers ( k , n ) : NEW_LINE INDENT dp = [ [ 0 , 0 ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = 10 NEW_LINE n = 3 NEW_LINE print ( count_numbers ( k , n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GfG : NEW_LINE INDENT def minCost ( n , arr , cost ) : NEW_LINE INDENT sum = 0 NEW_LINE totalCost = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT totalCost += cost * sum NEW_LINE arr [ n - 1 ] += sum NEW_LINE totalCost += ( 2 * cost * arr [ n - 1 ] ) NEW_LINE return totalCost NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE cost = 1 NEW_LINE print ( minCost ( n , arr , cost ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . team_formation_make ( ) NEW_LINE DEDENT def team_formation_make ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT input_str = sys . stdin . readline ( ) . strip ( ) NEW_LINE year_num = int ( input_str ) NEW_LINE programmer_list = [ ] NEW_LINE team_num = 0 NEW_LINE for i in range ( year_num ) : NEW_LINE INDENT team_str = sys . stdin . readline ( ) . strip ( ) NEW_LINE team_strs = team_str . split ( " ▁ " ) NEW_LINE programmer_list . append ( [ ] ) NEW_LINE for j in range ( len ( team_strs ) ) : NEW_LINE INDENT programmer_list [ i ] . append ( int ( team_strs [ j ] ) ) NEW_LINE DEDENT for i in range ( year_num ) : NEW_LINE INDENT c = programmer_list [ i ] [ 0 ] NEW_LINE a = programmer_list [ i ] [ 1 ] NEW_LINE n = programmer_list [ i ] [ 2 ] NEW_LINE while True : NEW_LINE INDENT if c >= 1 and a >= 1 and n >= 1 : NEW_LINE INDENT team_num += 1 NEW_LINE c -= 1 NEW_LINE a -= 1 NEW_LINE n -= 1 NEW_LINE DEDENT elif c >= 2 and a >= 1 : NEW_LINE INDENT team_num += 1 NEW_LINE c -= 2 NEW_LINE a -= 1 NEW_LINE DEDENT elif c >= 3 : NEW_LINE INDENT team_num += 1 NEW_LINE c -= 3 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( team_num ) NEW_LINE team_num = 0 NEW_LINE DEDENT DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT m = int ( input ( ) ) - ( n << 1 ) NEW_LINE ch = list ( input ( ) ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while i < m : NEW_LINE INDENT if ch [ i ] == ' I ' : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ch [ i + 1 + ( j << 1 ) ] != ' O ' or ch [ i + ( ( j + 1 ) << 1 ) ] != ' I ' : NEW_LINE INDENT break NEW_LINE DEDENT elif j == n - 1 : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
from collections import deque NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE ans = 0 NEW_LINE lst = deque ( ) NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ch = s [ i ] NEW_LINE if len ( lst ) == 0 : NEW_LINE INDENT if ch == '0' or ch == '5' : NEW_LINE INDENT lst . append ( ch ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT found = False NEW_LINE for string in lst : NEW_LINE INDENT if int ( ch + string ) % 25 == 0 : NEW_LINE INDENT found = True NEW_LINE ans += len ( lst ) - 1 NEW_LINE break NEW_LINE DEDENT DEDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT if ch == '0' or ch == '5' : NEW_LINE INDENT lst . append ( ch ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( root , data ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT if data < root . data : NEW_LINE INDENT root . left = insert ( root . left , data ) NEW_LINE DEDENT if data > root . data : NEW_LINE INDENT root . right = insert ( root . right , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT def inOrder ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT inOrder ( root . left ) NEW_LINE print ( root . data , end = " ▁ " ) NEW_LINE inOrder ( root . right ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE root = None NEW_LINE for i in range ( n ) : NEW_LINE INDENT root = insert ( root , arr [ i ] ) NEW_LINE DEDENT inOrder ( root ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def removeChars ( str , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT res = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT
class LongestCommonSubSequence : NEW_LINE INDENT @ staticmethod NEW_LINE def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCStuff = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] : NEW_LINE INDENT LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCStuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT X = " OldSite : GeeksforGeeks . org " NEW_LINE Y = " NewSite : GeeksQuiz . com " NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( " Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is " , LongestCommonSubSequence . LCSubStr ( list ( X ) , list ( Y ) , m , n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countOccurrences ( x , d ) : NEW_LINE INDENT count = 0 NEW_LINE while x > 0 : NEW_LINE INDENT if x % 10 == d : NEW_LINE INDENT count += 1 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def maxOccurring ( x ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT x = - x NEW_LINE DEDENT result = 0 NEW_LINE max_count = 1 NEW_LINE for d in range ( 10 ) : NEW_LINE INDENT count = GFG . countOccurrences ( x , d ) NEW_LINE if count >= max_count : NEW_LINE INDENT max_count = count NEW_LINE result = d NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT x = 1223355 NEW_LINE print ( " Max ▁ occurring ▁ digit ▁ is " , GFG . maxOccurring ( x ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def printLogestIncSubArr ( arr , n ) : NEW_LINE INDENT max_val = 1 NEW_LINE length = 1 NEW_LINE max_index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ i - 1 ] : NEW_LINE INDENT length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if max_val < length : NEW_LINE INDENT max_val = length NEW_LINE max_index = i - max_val NEW_LINE DEDENT length = 1 NEW_LINE DEDENT DEDENT if max_val < length : NEW_LINE INDENT max_val = length NEW_LINE max_index = n - max_val NEW_LINE DEDENT for i in range ( max_index , max_val + max_index ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 5 , 6 , 3 , 5 , 7 , 8 , 9 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE GFG . printLogestIncSubArr ( arr , n ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import java . util . * ; NEW_LINE public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; System . out . println ( n + " ▁ " ) ; int m = n ; for ( int i = n - 1 ; i > 0 ; i - - ) { if ( m % i == 0 ) { System . out . println ( i + " ▁ " ) ; m = i ; } } } } NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for t1 in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE hash = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ i ] = p [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT l , r , x = map ( int , input ( ) . split ( ) ) NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE x -= 1 NEW_LINE ind = x NEW_LINE if ind < l or ind > r : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT hash1 = [ 0 ] * ( n + 1 ) NEW_LINE for j in range ( l ) : NEW_LINE INDENT hash1 [ p [ j ] ] += 1 NEW_LINE DEDENT for j in range ( r + 1 , n ) : NEW_LINE INDENT hash1 [ p [ j ] ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if hash1 [ j ] == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if j == hash [ x ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dif1 = ind - l + 1 NEW_LINE if dif1 != cnt : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def Max_Sum ( a , n ) : NEW_LINE INDENT b = [ 0 ] * n NEW_LINE S = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = res NEW_LINE res += a [ i ] NEW_LINE S += a [ i ] NEW_LINE res = max ( res , - S ) NEW_LINE DEDENT ans = S NEW_LINE ans = max ( ans , res ) NEW_LINE g = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT g -= a [ i ] NEW_LINE ans = max ( ans , g + b [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT a = [ - 6 , 10 , - 3 , 10 , - 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( " Maximum ▁ sum ▁ is : " , GFG . Max_Sum ( a , n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] == a [ 1 ] : NEW_LINE INDENT print ( 2 * a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 * a [ 1 ] - 1 ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def reverse ( self , string , x ) : NEW_LINE INDENT n = ( len ( string ) - x ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( string [ i ] , end = ' ' ) NEW_LINE DEDENT for i in range ( n + x - 1 , n - 1 , - 1 ) : NEW_LINE INDENT print ( string [ i ] , end = ' ' ) NEW_LINE DEDENT for i in range ( n + x , len ( string ) ) : NEW_LINE INDENT print ( string [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE x = 3 NEW_LINE self . reverse ( string , x ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def lps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if str [ i ] == str [ j ] and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif str [ i ] == str [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT def minimumNumberOfDeletions ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE len = GFG . lps ( str ) NEW_LINE return ( n - len ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE print ( " Minimum ▁ number ▁ " + " of ▁ deletions ▁ = ▁ " + str ( GFG . minimumNumberOfDeletions ( str ) ) ) NEW_LINE DEDENT DEDENT
def bit_check ( n ) : NEW_LINE INDENT if ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 14 NEW_LINE if bit_check ( n ) : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class Test : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE curr = arr [ n - 1 ] NEW_LINE c = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] <= curr : NEW_LINE INDENT curr = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT DEDENT test = Test ( ) NEW_LINE test . main ( ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE class p187 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT LIMIT = pow ( 10 , 8 ) - 1 NEW_LINE def run ( self ) : NEW_LINE INDENT count = 0 NEW_LINE primes = self . listPrimes ( self . LIMIT // 2 ) NEW_LINE sqrt = int ( math . sqrt ( self . LIMIT ) ) NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT if primes [ i ] <= sqrt : NEW_LINE INDENT end = self . binarySearch ( primes , self . LIMIT // primes [ i ] ) NEW_LINE if end >= 0 : NEW_LINE INDENT end += 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = - end - 1 NEW_LINE DEDENT count += end - i NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT def listPrimes ( self , n ) : NEW_LINE INDENT primes = [ ] NEW_LINE for num in range ( 2 , n + 1 ) : NEW_LINE INDENT if all ( num % i != 0 for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) ) : NEW_LINE INDENT primes . append ( num ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT def binarySearch ( self , arr , x ) : NEW_LINE INDENT low = 0 NEW_LINE high = len ( arr ) - 1 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] < x : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT elif arr [ mid ] > x : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT p = p187 ( ) NEW_LINE p . main ( [ ] ) NEW_LINE
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT M = 20 NEW_LINE dp = [ [ [ [ - 1 for _ in range ( 2 ) ] for _ in range ( 2 ) ] for _ in range ( M ) ] for _ in range ( M ) ] NEW_LINE d = 0 NEW_LINE K = 0 NEW_LINE @ staticmethod NEW_LINE def count ( pos , cnt , tight , nonz , num ) : NEW_LINE INDENT if pos == len ( num ) : NEW_LINE INDENT if cnt == Solution . K : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if Solution . dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 : NEW_LINE INDENT return Solution . dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = 9 if tight != 0 else num [ pos ] NEW_LINE for dig in range ( limit + 1 ) : NEW_LINE INDENT currCnt = cnt NEW_LINE if dig == Solution . d : NEW_LINE INDENT if Solution . d != 0 or ( Solution . d == 0 and nonz != 0 ) : NEW_LINE INDENT currCnt += 1 NEW_LINE DEDENT DEDENT currTight = tight NEW_LINE if dig < num [ pos ] : NEW_LINE INDENT currTight = 1 NEW_LINE DEDENT ans += Solution . count ( pos + 1 , currCnt , currTight , 1 if dig != 0 else 0 , num ) NEW_LINE DEDENT Solution . dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans NEW_LINE return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def solve ( x ) : NEW_LINE INDENT num = [ ] NEW_LINE while x != 0 : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE for i in range ( Solution . M ) : NEW_LINE INDENT for j in range ( Solution . M ) : NEW_LINE INDENT for k in range ( 2 ) : NEW_LINE INDENT for l in range ( 2 ) : NEW_LINE INDENT Solution . dp [ i ] [ j ] [ k ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return Solution . count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT L = 11 NEW_LINE R = 100 NEW_LINE Solution . d = 2 NEW_LINE Solution . K = 1 NEW_LINE print ( Solution . solve ( R ) - Solution . solve ( L - 1 ) ) NEW_LINE DEDENT DEDENT Solution . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class Test1 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT sc = input ( ) NEW_LINE list = [ ] NEW_LINE x = int ( sc ) NEW_LINE while x > 0 : NEW_LINE INDENT r = x % 10 NEW_LINE if 9 - r < r : NEW_LINE INDENT if x // 10 == 0 and 9 - r == 0 : NEW_LINE INDENT list . append ( r ) NEW_LINE DEDENT else : NEW_LINE INDENT list . append ( 9 - r ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT list . append ( r ) NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT pow = 0 NEW_LINE newNumber = 0 NEW_LINE for i in range ( len ( list ) ) : NEW_LINE INDENT newNumber = newNumber + list [ i ] * ( 10 ** pow ) NEW_LINE pow += 1 NEW_LINE DEDENT print ( newNumber ) NEW_LINE DEDENT DEDENT test = Test1 ( ) NEW_LINE test . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def isPeak ( arr , n , num , i , j ) : NEW_LINE INDENT if i >= 0 and arr [ i ] > num : NEW_LINE INDENT return False NEW_LINE DEDENT if j < n and arr [ j ] > num : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def isTrough ( arr , n , num , i , j ) : NEW_LINE INDENT if i >= 0 and arr [ i ] < num : NEW_LINE INDENT return False NEW_LINE DEDENT if j < n and arr [ j ] < num : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def printPeaksTroughs ( arr , n ) : NEW_LINE INDENT print ( " Peaks ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if isPeak ( arr , n , arr [ i ] , i - 1 , i + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE print ( " Troughs ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if isTrough ( arr , n , arr [ i ] , i - 1 , i + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 5 , 10 , 5 , 7 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printPeaksTroughs ( arr , n ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def index ( i ) : NEW_LINE INDENT return 1 + ( i >> 31 ) - ( - i >> 31 ) NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT s = [ " negative " , " zero " , " positive " ] NEW_LINE val = GFG . index ( n ) NEW_LINE print ( str ( n ) + " ▁ is ▁ " + s [ val ] ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT GFG . check ( 30 ) NEW_LINE GFG . check ( - 20 ) NEW_LINE GFG . check ( 0 ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def frequency ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == x : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = [ 0 , 5 , 5 , 5 , 4 ] NEW_LINE x = 5 NEW_LINE n = len ( a ) NEW_LINE print ( GFG . frequency ( a , n , x ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def isNumBalanced ( num ) : NEW_LINE INDENT num = abs ( num ) NEW_LINE str_num = str ( num ) NEW_LINE ch_arr = list ( str_num ) NEW_LINE hs = set ( ch_arr ) NEW_LINE str_len = len ( str_num ) NEW_LINE hs_len = len ( hs ) NEW_LINE if hs_len <= str_len // 2 or hs_len == str_len : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 1234567890 NEW_LINE flag = isNumBalanced ( N ) NEW_LINE if flag : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = int ( math . sqrt ( n ) ) NEW_LINE if 1 * sq * sq != n : NEW_LINE INDENT return False NEW_LINE DEDENT return True if isPrime ( sq ) else False NEW_LINE DEDENT num = 9 NEW_LINE if isThreeDisctFactors ( num ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 15 NEW_LINE if isThreeDisctFactors ( num ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 12397923568441 NEW_LINE if isThreeDisctFactors ( num ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT ` ` ` NEW_LINE
from math import BigInteger NEW_LINE class p065 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT return self . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT n = BigInteger . ONE NEW_LINE d = BigInteger . ZERO NEW_LINE for i in range ( 99 , - 1 , - 1 ) : NEW_LINE INDENT temp = BigInteger . valueOf ( self . continuedFractionTerm ( i ) ) . multiply ( n ) . add ( d ) NEW_LINE d = n NEW_LINE n = temp NEW_LINE DEDENT sum = 0 NEW_LINE while not n . equals ( BigInteger . ZERO ) : NEW_LINE INDENT divrem = n . divideAndRemainder ( BigInteger . TEN ) NEW_LINE sum += divrem [ 1 ] . intValue ( ) NEW_LINE n = divrem [ 0 ] NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT def continuedFractionTerm ( self , i ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif i % 3 == 2 : NEW_LINE INDENT return i // 3 * 2 + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT
import math NEW_LINE def __gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def LCM ( x , y , z ) : NEW_LINE INDENT ans = ( x * y ) // ( __gcd ( x , y ) ) NEW_LINE return ( z * ans ) // ( __gcd ( ans , z ) ) NEW_LINE DEDENT def findDivisible ( n , x , y , z ) : NEW_LINE INDENT lcm = LCM ( x , y , z ) NEW_LINE ndigitnumber = 10 ** ( n - 1 ) NEW_LINE reminder = ndigitnumber % lcm NEW_LINE if reminder == 0 : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT ndigitnumber += lcm - reminder NEW_LINE if ndigitnumber < 10 ** n : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE z = 5 NEW_LINE res = findDivisible ( n , x , y , z ) NEW_LINE if res != 0 : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT
MAXN = 100001 NEW_LINE prime = [ True ] * MAXN NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( MAXN ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p < MAXN : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , MAXN , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def common_prime ( a , b ) : NEW_LINE INDENT def __gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return __gcd ( b % a , a ) NEW_LINE DEDENT gcd = __gcd ( a , b ) NEW_LINE for i in range ( 2 , gcd + 1 ) : NEW_LINE INDENT if prime [ i ] and gcd % i == 0 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT SieveOfEratosthenes ( ) NEW_LINE a , b = 6 , 12 NEW_LINE common_prime ( a , b ) NEW_LINE
import sys NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . len = 393 NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = [ 0 ] * n NEW_LINE l = [ 0 ] * n NEW_LINE p = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ i ] , l [ i ] , p [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT dp = [ - 1 ] * ( self . len + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for j in range ( self . len + 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if dp [ j ] >= 0 : NEW_LINE INDENT for k in range ( s [ i ] , l [ i ] + 1 ) : NEW_LINE INDENT if j + k <= self . len : NEW_LINE INDENT dp [ j + k ] = max ( dp [ j + k ] , dp [ j ] + p [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT m = int ( input ( ) ) NEW_LINE ans = [ 0 ] * m NEW_LINE flg = True NEW_LINE for i in range ( m ) : NEW_LINE INDENT r = int ( input ( ) ) NEW_LINE ans [ i ] = dp [ r ] NEW_LINE if ans [ i ] == - 1 : NEW_LINE INDENT flg = False NEW_LINE DEDENT DEDENT if not flg : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in ans : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE from collections import defaultdict NEW_LINE class Main : NEW_LINE INDENT g = defaultdict ( list ) NEW_LINE @ staticmethod NEW_LINE def maxMatching ( v , p ) : NEW_LINE INDENT a = 0 NEW_LINE o = 0 NEW_LINE for w in Main . g [ v ] : NEW_LINE INDENT if w == p : NEW_LINE INDENT continue NEW_LINE DEDENT r = Main . maxMatching ( w , v ) NEW_LINE a += r // 2 NEW_LINE o += r % 2 NEW_LINE DEDENT return 2 * a + min ( 1 , o ) + 1 NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE Main . g [ a - 1 ] . append ( b - 1 ) NEW_LINE Main . g [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT m = Main . maxMatching ( 0 , - 1 ) // 2 NEW_LINE if 2 * m == n : NEW_LINE INDENT print ( " Second " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE N = 205 NEW_LINE M = 205 NEW_LINE grid = [ [ 0 for j in range ( M ) ] for i in range ( N ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = input ( ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT grid [ i ] [ j ] = int ( line [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( m - 1 ) : NEW_LINE INDENT sum = grid [ i ] [ j ] + grid [ i + 1 ] [ j ] + grid [ i ] [ j + 1 ] + grid [ i + 1 ] [ j + 1 ] NEW_LINE if sum == 3 : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " YES " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE tc = 1 NEW_LINE while tc > 0 : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE len = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE len [ i ] = len ( s ) NEW_LINE DEDENT p = input ( ) NEW_LINE plen = len ( p ) NEW_LINE kk = k NEW_LINE len . sort ( ) NEW_LINE min = 0 NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if len [ i ] == plen : NEW_LINE INDENT min += 1 NEW_LINE break NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE min += 1 NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT k = kk NEW_LINE min += 5 NEW_LINE DEDENT DEDENT k = kk NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if len [ i ] == plen and len [ i + 1 ] > plen : NEW_LINE INDENT max += 1 NEW_LINE break NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE max += 1 NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT k = kk NEW_LINE max += 5 NEW_LINE DEDENT DEDENT if len [ n - 1 ] == plen : NEW_LINE INDENT max += 1 NEW_LINE DEDENT print ( min , max ) NEW_LINE tc -= 1 NEW_LINE DEDENT
import re NEW_LINE def main ( ) : NEW_LINE INDENT word1 = re . sub ( " [ ^ a - zA - Z ] " , " " , input ( ) . lower ( ) ) NEW_LINE word2 = re . sub ( " [ ^ a - zA - Z ] " , " " , input ( ) . lower ( ) ) NEW_LINE word3 = re . sub ( " [ ^ a - zA - Z ] " , " " , input ( ) . lower ( ) ) NEW_LINE perm1 = word1 + word2 + word3 NEW_LINE perm2 = word1 + word3 + word2 NEW_LINE perm3 = word2 + word1 + word3 NEW_LINE perm4 = word2 + word3 + word1 NEW_LINE perm5 = word3 + word2 + word1 NEW_LINE perm6 = word3 + word1 + word2 NEW_LINE students = int ( input ( ) ) NEW_LINE for i in range ( students ) : NEW_LINE INDENT testCase = re . sub ( " [ ^ a - zA - Z ] " , " " , input ( ) . lower ( ) ) NEW_LINE if testCase == perm1 or testCase == perm2 or testCase == perm3 or testCase == perm4 or testCase == perm5 or testCase == perm6 : NEW_LINE INDENT print ( " ACC " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " WA " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT cases = int ( input ( ) ) NEW_LINE for caze in range ( 1 , cases + 1 ) : NEW_LINE INDENT N , L = map ( int , input ( ) . split ( ) ) NEW_LINE need = set ( ) NEW_LINE have = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = input ( ) NEW_LINE tmp2 = 0 NEW_LINE for j in range ( L ) : NEW_LINE INDENT if tmp [ j ] == '1' : NEW_LINE INDENT tmp2 |= ( 1 << j ) NEW_LINE DEDENT DEDENT have . add ( tmp2 ) NEW_LINE DEDENT lastNeeded = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = input ( ) NEW_LINE tmp2 = 0 NEW_LINE for j in range ( L ) : NEW_LINE INDENT if tmp [ j ] == '1' : NEW_LINE INDENT tmp2 |= ( 1 << j ) NEW_LINE DEDENT DEDENT need . add ( tmp2 ) NEW_LINE lastNeeded = tmp2 NEW_LINE DEDENT ans = L + 1 NEW_LINE for elem in have : NEW_LINE INDENT flip = lastNeeded ^ elem NEW_LINE got = set ( ) NEW_LINE for e in need : NEW_LINE INDENT got . add ( e ^ flip ) NEW_LINE DEDENT if got == have : NEW_LINE INDENT ans = min ( ans , bin ( flip ) . count ( '1' ) ) NEW_LINE DEDENT DEDENT print ( " Case ▁ # { } : ▁ { } " . format ( caze , " NOT ▁ POSSIBLE " if ans > L else ans ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
0ERROR
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def sum ( x , y , n ) : NEW_LINE INDENT sum1 = int ( ( x ** 2 * ( x ** ( 2 * n ) - 1 ) ) / ( x ** 2 - 1 ) ) NEW_LINE sum2 = int ( ( x * y * ( x ** n * y ** n - 1 ) ) / ( x * y - 1 ) ) NEW_LINE return sum1 + sum2 NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT x , y , n = 2 , 2 , 2 NEW_LINE print ( self . sum ( x , y , n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 687 NEW_LINE print ( GFG . getSum ( n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = GFG . Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT @ staticmethod NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT @ staticmethod NEW_LINE def deleteNonPrimeNodes ( head_ref ) : NEW_LINE INDENT ptr = head_ref NEW_LINE while ptr is not None and not GFG . isPrime ( ptr . data ) : NEW_LINE INDENT temp = ptr NEW_LINE ptr = ptr . next NEW_LINE DEDENT head_ref = ptr NEW_LINE if ptr is None : NEW_LINE INDENT return None NEW_LINE DEDENT curr = ptr . next NEW_LINE while curr is not None : NEW_LINE INDENT if not GFG . isPrime ( curr . data ) : NEW_LINE INDENT ptr . next = curr . next NEW_LINE curr = ptr . next NEW_LINE DEDENT else : NEW_LINE INDENT ptr = curr NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT return head_ref NEW_LINE DEDENT @ staticmethod NEW_LINE def printList ( head ) : NEW_LINE INDENT while head is not None : NEW_LINE INDENT print ( head . data , end = " ▁ " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT head = None NEW_LINE head = GFG . push ( head , 17 ) NEW_LINE head = GFG . push ( head , 7 ) NEW_LINE head = GFG . push ( head , 6 ) NEW_LINE head = GFG . push ( head , 16 ) NEW_LINE head = GFG . push ( head , 15 ) NEW_LINE print ( " Original ▁ List : ▁ " , end = " " ) NEW_LINE GFG . printList ( head ) NEW_LINE head = GFG . deleteNonPrimeNodes ( head ) NEW_LINE print ( " \n Modified ▁ List : ▁ " , end = " " ) NEW_LINE GFG . printList ( head ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT cs = [ ] NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . N , self . M , self . L = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( self . N * self . M ) : NEW_LINE INDENT self . cs . append ( [ ] ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT for i in range ( self . M ) : NEW_LINE INDENT D , A , K , T = map ( int , input ( ) . split ( ) ) NEW_LINE start = D * self . N + A - 1 NEW_LINE self . cs [ start ] . append ( ( K << 16 ) | T ) NEW_LINE DEDENT dp = [ [ 0 ] * ( self . N * self . M + 1 ) for _ in range ( self . L + 1 ) ] NEW_LINE for i in range ( self . N * self . M ) : NEW_LINE INDENT for j in range ( self . L ) : NEW_LINE INDENT for c in self . cs [ i ] : NEW_LINE INDENT length = c >> 16 NEW_LINE t = c & 0xFFFF NEW_LINE dp [ j + 1 ] [ i + length ] = max ( dp [ j + 1 ] [ i + length ] , dp [ j ] [ i ] + t ) NEW_LINE DEDENT DEDENT for j in range ( self . L + 1 ) : NEW_LINE INDENT dp [ j ] [ i + 1 ] = max ( dp [ j ] [ i + 1 ] , dp [ j ] [ i ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( self . L + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ self . N * self . M ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT class Box : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . bolls = 1 NEW_LINE self . isRed = False NEW_LINE DEDENT def add ( self , src ) : NEW_LINE INDENT self . isRed |= src . isRed NEW_LINE self . bolls += 1 NEW_LINE src . bolls -= 1 NEW_LINE if src . bolls == 0 : NEW_LINE INDENT src . isRed = False NEW_LINE DEDENT DEDENT DEDENT def main ( self , sc ) : NEW_LINE INDENT n = int ( sc . nextInt ( ) ) NEW_LINE m = int ( sc . nextInt ( ) ) NEW_LINE boxs = [ self . Box ( ) for _ in range ( n ) ] NEW_LINE boxs [ 0 ] . isRed = True NEW_LINE for _ in range ( m ) : NEW_LINE INDENT x = int ( sc . nextInt ( ) ) NEW_LINE y = int ( sc . nextInt ( ) ) NEW_LINE boxs [ y - 1 ] . add ( boxs [ x - 1 ] ) NEW_LINE DEDENT print ( sum ( 1 if box . isRed else 0 for box in boxs ) ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT import sys NEW_LINE sc = sys . stdin NEW_LINE Main ( ) . main ( sc ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE h , w = map ( int , input ( ) . split ( ) ) NEW_LINE max_distance = 0 NEW_LINE list = [ ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT arr = list ( input ( ) ) NEW_LINE for j in range ( w ) : NEW_LINE INDENT if arr [ j ] == ' . ' : NEW_LINE INDENT continue NEW_LINE DEDENT for x in list : NEW_LINE INDENT hh = x // w NEW_LINE ww = x % w NEW_LINE max_distance = max ( max_distance , abs ( i - hh ) + abs ( j - ww ) ) NEW_LINE DEDENT list . append ( i * w + j ) NEW_LINE DEDENT DEDENT print ( max_distance ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def minReplacement ( str ) : NEW_LINE INDENT if len ( str ) > 26 : NEW_LINE INDENT print ( " IMPOSSIBLE " ) NEW_LINE DEDENT else : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT if hash [ j ] == 0 : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE str = str [ : i ] + chr ( j + ord ( ' a ' ) ) + str [ i + 1 : ] NEW_LINE hash [ j ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( str ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT str = " xxxxyyyy " NEW_LINE GFG . minReplacement ( str ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
class GFG : NEW_LINE INDENT def longestSubseq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_0 = [ 0 ] * ( n + 2 ) NEW_LINE pre_count_1 = [ 0 ] * ( n + 1 ) NEW_LINE post_count_0 = [ 0 ] * ( n + 2 ) NEW_LINE pre_count_0 [ 0 ] = 0 NEW_LINE post_count_0 [ n + 1 ] = 0 NEW_LINE pre_count_1 [ 0 ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pre_count_0 [ j ] = pre_count_0 [ j - 1 ] NEW_LINE pre_count_1 [ j ] = pre_count_1 [ j - 1 ] NEW_LINE post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] NEW_LINE if s [ j - 1 ] == '0' : NEW_LINE INDENT pre_count_0 [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre_count_1 [ j ] += 1 NEW_LINE DEDENT if s [ n - j ] == '0' : NEW_LINE INDENT post_count_0 [ n - j + 1 ] += 1 NEW_LINE DEDENT DEDENT if pre_count_0 [ n ] == n or pre_count_0 [ n ] == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT s = "000011100000" NEW_LINE print ( GFG . longestSubseq ( s ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE
class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE i = 2 NEW_LINE while i <= N : NEW_LINE INDENT s [ i ] = 2 NEW_LINE i += 2 NEW_LINE DEDENT i = 3 NEW_LINE while i <= N : NEW_LINE INDENT if not prime [ i ] : NEW_LINE INDENT s [ i ] = i NEW_LINE j = i NEW_LINE while j * i <= N : NEW_LINE INDENT if not prime [ i * j ] : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT j += 2 NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE GFG . sieveOfEratosthenes ( N , s ) NEW_LINE print ( " Factor ▁ Power " ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while N > 1 : NEW_LINE INDENT N //= s [ N ] NEW_LINE if curr == s [ N ] : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print ( str ( curr ) + " \t " + str ( cnt ) ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT N = 360 NEW_LINE GFG . generatePrimeFactors ( N ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
class GFG : NEW_LINE INDENT def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 ] * 10 for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while num != 0 : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num //= 10 NEW_LINE DEDENT DEDENT longest = float ( ' - inf ' ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if hash [ i ] [ j ] == 1 and hash [ i + 1 ] [ j ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if j == 9 : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 63 ] NEW_LINE n = len ( a ) NEW_LINE print ( GFG . longestSubarray ( a , n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE from sys import stdin NEW_LINE def main ( ) : NEW_LINE INDENT test = int ( stdin . readline ( ) ) NEW_LINE for _ in range ( test ) : NEW_LINE INDENT a , b , c = map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE result = ( a + b + c ) // 2 NEW_LINE print ( result ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def Divisors ( x ) : NEW_LINE INDENT c = 0 NEW_LINE v = [ ] NEW_LINE while x % 2 == 0 : NEW_LINE INDENT c += 1 NEW_LINE x //= 2 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while x % 3 == 0 : NEW_LINE INDENT c += 1 NEW_LINE x //= 3 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while x % 7 == 0 : NEW_LINE INDENT c += 1 NEW_LINE x //= 7 NEW_LINE DEDENT v . append ( c ) NEW_LINE v . append ( x ) NEW_LINE return v NEW_LINE DEDENT def MinOperations ( a , b ) : NEW_LINE INDENT va = Divisors ( a ) NEW_LINE vb = Divisors ( b ) NEW_LINE if va [ 3 ] != vb [ 3 ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = abs ( va [ 0 ] - vb [ 0 ] ) + abs ( va [ 1 ] - vb [ 1 ] ) + abs ( va [ 2 ] - vb [ 2 ] ) NEW_LINE return minOperations NEW_LINE DEDENT a = 14 NEW_LINE b = 28 NEW_LINE print ( MinOperations ( a , b ) ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT N = 1000001 NEW_LINE c = 0 NEW_LINE n = 0 NEW_LINE m = 0 NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE @ staticmethod NEW_LINE def dfs ( a , b , v , vis ) : NEW_LINE INDENT vis [ a ] = 1 NEW_LINE GFG . c += 1 NEW_LINE for i in v [ a ] : NEW_LINE INDENT if vis [ i ] == 0 and i != b : NEW_LINE INDENT GFG . dfs ( i , b , v , vis ) NEW_LINE DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def calculate ( v ) : NEW_LINE INDENT vis = [ 0 ] * ( GFG . n + 1 ) NEW_LINE GFG . c = 0 NEW_LINE GFG . dfs ( GFG . a , GFG . b , v , vis ) NEW_LINE ans1 = GFG . n - GFG . c - 1 NEW_LINE vis = [ 0 ] * ( GFG . n + 1 ) NEW_LINE GFG . c = 0 NEW_LINE GFG . dfs ( GFG . b , GFG . a , v , vis ) NEW_LINE ans2 = GFG . n - GFG . c - 1 NEW_LINE print ( ans1 * ans2 ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT GFG . n = 7 NEW_LINE GFG . m = 7 NEW_LINE GFG . a = 3 NEW_LINE GFG . b = 5 NEW_LINE edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 7 , 5 ] ] NEW_LINE v = [ [ ] for _ in range ( GFG . n + 1 ) ] NEW_LINE for i in range ( GFG . n + 1 ) : NEW_LINE INDENT v [ i ] = [ ] NEW_LINE DEDENT for i in range ( GFG . m ) : NEW_LINE INDENT v [ edges [ i ] [ 0 ] ] . append ( edges [ i ] [ 1 ] ) NEW_LINE v [ edges [ i ] [ 1 ] ] . append ( edges [ i ] [ 0 ] ) NEW_LINE DEDENT GFG . calculate ( v ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = sys . stdin NEW_LINE self . st = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st is None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = self . br . readline ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT return self . br . readline ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT reader = FastReader ( ) NEW_LINE num = reader . nextInt ( ) NEW_LINE prod = 1 NEW_LINE ans = prodOfDigits ( num ) NEW_LINE while num > 9 : NEW_LINE INDENT prod *= 9 NEW_LINE digit = num % 10 NEW_LINE num = num // 10 NEW_LINE if digit == 9 : NEW_LINE INDENT ans = max ( ans , prodOfDigits ( num ) * prod ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , prodOfDigits ( num - 1 ) * prod ) NEW_LINE num = num - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT def prodOfDigits ( N ) : NEW_LINE INDENT prod = 1 NEW_LINE while N != 0 : NEW_LINE INDENT digit = N % 10 NEW_LINE if digit == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT prod *= digit NEW_LINE N //= 10 NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( sys . argv ) NEW_LINE DEDENT ` ` ` NEW_LINE
from sys import stdin NEW_LINE def main ( ) : NEW_LINE INDENT a , b = map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE res = a NEW_LINE while a >= b : NEW_LINE INDENT res += ( a // b ) NEW_LINE a = ( a // b ) + ( a % b ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE res = max ( res , getSum ( n // i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE def power ( a ) : NEW_LINE INDENT res = 0 NEW_LINE while a > 0 : NEW_LINE INDENT res += 1 NEW_LINE a = a // 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def mult ( a ) : NEW_LINE INDENT pow = power ( a ) NEW_LINE max = 0 NEW_LINE for j in range ( pow ) : NEW_LINE INDENT max = max * 10 + 9 NEW_LINE DEDENT return a * ( max - a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = int ( input ( ) ) NEW_LINE r = int ( input ( ) ) NEW_LINE res = 0 NEW_LINE maxxes = [ 0 ] * 10 NEW_LINE temp = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT temp = temp * 10 + 9 NEW_LINE maxxes [ i ] = temp // 2 * ( temp - temp // 2 ) NEW_LINE DEDENT res = max ( mult ( l ) , res ) NEW_LINE res = max ( mult ( r ) , res ) NEW_LINE temp = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT temp = temp * 10 + 9 NEW_LINE if l <= temp // 2 and temp // 2 <= r : NEW_LINE INDENT res = max ( maxxes [ i ] , res ) NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE printArray ( a ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT key = a [ i ] NEW_LINE j = i - 1 NEW_LINE while j >= 0 and a [ j ] > key : NEW_LINE INDENT a [ j + 1 ] = a [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT a [ j + 1 ] = key NEW_LINE printArray ( a ) NEW_LINE DEDENT DEDENT def printArray ( a ) : NEW_LINE INDENT for i in range ( len ( a ) - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( a [ len ( a ) - 1 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( sr - math . floor ( sr ) ) == 0 NEW_LINE DEDENT def isProduct ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 2 NEW_LINE while cnt < 2 and i * i <= num : NEW_LINE INDENT while num % i == 0 : NEW_LINE INDENT num //= i NEW_LINE cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if num > 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT def findNumbers ( N ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if isProduct ( i ) and not isPerfectSquare ( i ) : NEW_LINE INDENT vec . append ( i ) NEW_LINE DEDENT DEDENT for num in vec : NEW_LINE INDENT print ( num , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 30 NEW_LINE findNumbers ( N ) NEW_LINE DEDENT
s = "111111101010101111100101001111111 ▁ 100000100000000001010110001000001 ▁ 101110100110110000011010001011101 ▁ 101110101011001001111101001011101 ▁ 101110101100011000111100101011101 ▁ 100000101010101011010000101000001 ▁ 111111101010101010101010101111111 ▁ 000000001111101111100111100000000 ▁ 100010111100100001011110111111001 ▁ 110111001111111100100001000101100 ▁ 011100111010000101000111010001010 ▁ 011110000110001111110101100000011 ▁ 111111111111111000111001001011000 ▁ 111000010111010011010011010100100 ▁ 101010100010110010110101010000010 ▁ 101100000101010001111101000000000 ▁ 000010100011001101000111101011010 ▁ 101001001111101111000101010001110 ▁ 101101111111000100100001110001000 ▁ 000010011000100110000011010000010 ▁ 001101101001101110010010011011000 ▁ 011101011010001000111101010100110 ▁ 111010100110011101001101000001110 ▁ 110001010010101111000101111111000 ▁ 001000111011100001010110111110000 ▁ 000000001110010110100010100010110 ▁ 111111101000101111000110101011010 ▁ 100000100111010101111100100011011 ▁ 101110101001010000101000111111000 ▁ 101110100011010010010111111011010 ▁ 101110100100011011110110101110000 ▁ 100000100110011001111100111100000 ▁ 111111101101000101001101110010001" NEW_LINE array = s . split ( " ▁ " ) NEW_LINE x = int ( input ( ) ) NEW_LINE y = int ( input ( ) ) NEW_LINE print ( array [ x ] [ y ] ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE p = 1 NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE x = n NEW_LINE if n < 10 : NEW_LINE INDENT print ( n ) NEW_LINE continue NEW_LINE DEDENT while x > 0 : NEW_LINE INDENT count += 1 NEW_LINE x //= 10 NEW_LINE DEDENT first = 0 NEW_LINE while count > 0 : NEW_LINE INDENT first = first * 10 + 1 NEW_LINE count -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE if first <= n : NEW_LINE INDENT sum += n // first NEW_LINE DEDENT first //= 10 NEW_LINE while first > 0 : NEW_LINE INDENT sum += 9 NEW_LINE first //= 10 NEW_LINE DEDENT print ( sum ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def divSum ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT def areEquivalent ( num1 , num2 ) : NEW_LINE INDENT return divSum ( num1 ) == divSum ( num2 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT num1 = 559 NEW_LINE num2 = 703 NEW_LINE if areEquivalent ( num1 , num2 ) : NEW_LINE INDENT print ( " Equivalent " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Equivalent " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from typing import List NEW_LINE def findY ( x : int ) -> int : NEW_LINE INDENT if x > 2 : NEW_LINE INDENT return x - 2 NEW_LINE DEDENT return x + 2 NEW_LINE DEDENT def main ( args : List [ str ] ) -> None : NEW_LINE INDENT x = 5 NEW_LINE print ( findY ( x ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( [ ] ) NEW_LINE DEDENT
MOD = 1000000007 NEW_LINE def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( modFact ( n , m ) ) NEW_LINE DEDENT
from sys import stdin NEW_LINE n = int ( stdin . readline ( ) ) NEW_LINE A = list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT minj = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if A [ j ] < A [ minj ] : NEW_LINE INDENT minj = j NEW_LINE DEDENT DEDENT if minj != i : NEW_LINE INDENT A [ i ] , A [ minj ] = A [ minj ] , A [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( * A ) NEW_LINE print ( count ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . h = 0 NEW_LINE self . w = 0 NEW_LINE self . map = [ ] NEW_LINE self . v = [ ] NEW_LINE self . dy = [ - 1 , - 1 , 0 , 0 , 1 , 1 ] NEW_LINE self . dx1 = [ 0 , 1 , - 1 , 1 , 0 , 1 ] NEW_LINE self . dx2 = [ - 1 , 0 , - 1 , 1 , - 1 , 0 ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT scanner = Scanner ( sys . stdin ) NEW_LINE self . w = scanner . nextInt ( ) NEW_LINE self . h = scanner . nextInt ( ) NEW_LINE self . map = [ [ False for _ in range ( self . w + 2 ) ] for _ in range ( self . h + 2 ) ] NEW_LINE self . v = [ [ False for _ in range ( self . w + 2 ) ] for _ in range ( self . h + 2 ) ] NEW_LINE for i in range ( 1 , self . h + 1 ) : NEW_LINE INDENT for j in range ( 1 , self . w + 1 ) : NEW_LINE INDENT self . map [ i ] [ j ] = scanner . nextInt ( ) == 1 NEW_LINE DEDENT DEDENT print ( self . slove ( 0 , 0 ) ) NEW_LINE DEDENT def slove ( self , y , x ) : NEW_LINE INDENT self . v [ y ] [ x ] = True NEW_LINE res = 0 NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT ny = y + self . dy [ i ] NEW_LINE nx = x + ( self . dx1 [ i ] if y % 2 == 1 else self . dx2 [ i ] ) NEW_LINE if not self . isOK ( ny , nx ) : NEW_LINE INDENT continue NEW_LINE DEDENT if self . map [ ny ] [ nx ] : NEW_LINE INDENT res += 1 NEW_LINE continue NEW_LINE DEDENT if self . v [ ny ] [ nx ] : NEW_LINE INDENT continue NEW_LINE DEDENT res += self . slove ( ny , nx ) NEW_LINE DEDENT return res NEW_LINE DEDENT def isOK ( self , ny , nx ) : NEW_LINE INDENT return 0 <= ny <= self . h + 1 and 0 <= nx <= self . w + 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lists = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT start = [ a [ i ] ] NEW_LINE lists . append ( start ) NEW_LINE DEDENT else : NEW_LINE INDENT lo = 0 NEW_LINE hi = len ( lists ) - 1 NEW_LINE if lists [ hi ] [ - 1 ] > a [ i ] : NEW_LINE INDENT start = [ a [ i ] ] NEW_LINE lists . append ( start ) NEW_LINE DEDENT else : NEW_LINE INDENT while lo != hi : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE if lists [ mid ] [ - 1 ] < a [ i ] : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT lists [ lo ] . append ( a [ i ] ) NEW_LINE DEDENT DEDENT DEDENT for lis in lists : NEW_LINE INDENT for num in lis : NEW_LINE INDENT sys . stdout . write ( str ( num ) + " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def circlearea ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( 3.14 * math . pow ( a , 2 ) * math . pow ( b , 2 ) ) / ( 4 * ( math . pow ( a , 2 ) + math . pow ( b , 2 ) ) ) NEW_LINE return A NEW_LINE DEDENT a = 8 NEW_LINE b = 10 NEW_LINE print ( circlearea ( a , b ) ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def find ( arr , length , s ) : NEW_LINE INDENT for i in range ( 1 , 2 ** length + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( ( i >> j ) & 1 ) % 2 == 1 : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT DEDENT if sum == s : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT sum = 5 NEW_LINE array = [ - 1 , 2 , 4 , 121 ] NEW_LINE length = len ( array ) NEW_LINE GFG . find ( array , length , sum ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def K_String ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE fre = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT fre [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT str = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if fre [ i ] % k == 0 : NEW_LINE INDENT x = fre [ i ] // k NEW_LINE while x != 0 : NEW_LINE INDENT str += chr ( i + ord ( ' a ' ) ) NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT s = " aabb " NEW_LINE k = 2 NEW_LINE print ( GFG . K_String ( s , k ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT dp = [ [ 0.0 ] * 25 for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1.0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 24 ) : NEW_LINE INDENT pp = math . pow ( 2.0 , j ) NEW_LINE dp [ i + 1 ] [ j + 1 ] += dp [ i ] [ j ] * 1.0 / pp NEW_LINE dp [ i + 1 ] [ 0 ] += dp [ i ] [ j ] * ( 1.0 - ( 1.0 / pp ) ) NEW_LINE sum += j * dp [ i ] [ j ] * ( 1.0 - ( 1.0 / pp ) ) NEW_LINE DEDENT DEDENT for j in range ( 25 ) : NEW_LINE INDENT sum += j * dp [ n ] [ j ] NEW_LINE DEDENT print ( " % .20f " % sum ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE c = str ( a / b ) NEW_LINE f = [ 0 ] * 200 NEW_LINE idx = c . index ( " . " ) NEW_LINE f [ 0 ] = int ( c [ idx - 1 ] ) NEW_LINE for i in range ( 1 , min ( 200 , len ( c [ idx + 1 ] ) + 1 ) ) : NEW_LINE INDENT f [ i ] = int ( c [ idx + i ] ) NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += f [ i ] NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE nodec = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT nodec = False NEW_LINE DEDENT DEDENT if nodec : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT m = 500 NEW_LINE l , r = 1 , 210000 NEW_LINE mid = 2 NEW_LINE dec = [ 0 ] * m NEW_LINE while r - l > 1 : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE dec = [ 1 ] * m NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] and a [ i ] - 1 < m : NEW_LINE INDENT if dec [ a [ i ] - 1 ] < mid : NEW_LINE INDENT dec [ a [ i ] - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = a [ i ] - 1 NEW_LINE while pos > 0 : NEW_LINE INDENT dec [ pos - 1 ] += 1 NEW_LINE for j in range ( pos , m ) : NEW_LINE INDENT dec [ j ] = 1 NEW_LINE DEDENT if dec [ pos - 1 ] <= mid : NEW_LINE INDENT break NEW_LINE DEDENT pos -= 1 NEW_LINE DEDENT l = mid NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( a [ i ] - 1 , m ) : NEW_LINE INDENT dec [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT r = mid NEW_LINE DEDENT print ( r ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT lines = line . split ( ) NEW_LINE N = int ( lines [ 0 ] ) NEW_LINE K = int ( lines [ 1 ] ) NEW_LINE if N == 0 and K == 0 : NEW_LINE INDENT return NEW_LINE DEDENT bloodAmt = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT line = input ( ) NEW_LINE values = list ( map ( int , line . split ( ) ) ) NEW_LINE for j in range ( K ) : NEW_LINE INDENT bloodAmt [ j ] -= values [ j ] NEW_LINE DEDENT DEDENT for i in range ( K ) : NEW_LINE INDENT if bloodAmt [ i ] < 0 : NEW_LINE INDENT print ( " No " ) NEW_LINE break NEW_LINE DEDENT if i == K - 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java NEW_LINE class GFG : NEW_LINE INDENT def maxFreq ( s , a , b ) : NEW_LINE INDENT fre = [ 0 ] * 10 NEW_LINE n = len ( s ) NEW_LINE if a > b : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT fre [ int ( s [ i ] ) ] += 1 NEW_LINE DEDENT if fre [ a ] == 0 and fre [ b ] == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif fre [ a ] >= fre [ b ] : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT a = 4 NEW_LINE b = 7 NEW_LINE s = "47744" NEW_LINE print ( maxFreq ( s , a , b ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
class GFG : NEW_LINE INDENT def maxZeros ( n ) : NEW_LINE INDENT if n == 0 or ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT b = 4 NEW_LINE setBit = 1 NEW_LINE prev = 0 NEW_LINE i = 1 NEW_LINE while i <= b * 8 : NEW_LINE INDENT prev += 1 NEW_LINE if ( n & setBit ) == setBit : NEW_LINE INDENT setBit = setBit << 1 NEW_LINE break NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE i += 1 NEW_LINE DEDENT max0 = - 2147483648 NEW_LINE cur = prev NEW_LINE for j in range ( i + 1 , b * 8 + 1 ) : NEW_LINE INDENT cur += 1 NEW_LINE if ( n & setBit ) == setBit : NEW_LINE INDENT if max0 < ( cur - prev - 1 ) : NEW_LINE INDENT max0 = cur - prev - 1 NEW_LINE DEDENT prev = cur NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE DEDENT return max0 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 549 NEW_LINE print ( maxZeros ( n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
import math NEW_LINE def sumPowersK ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE num = 1 NEW_LINE while num <= n : NEW_LINE INDENT sum += num NEW_LINE num *= k NEW_LINE DEDENT return sum NEW_LINE DEDENT def getSum ( n , k ) : NEW_LINE INDENT pwrK = sumPowersK ( n , k ) NEW_LINE sumAll = ( n * ( n + 1 ) ) / 2 NEW_LINE return ( sumAll - pwrK ) NEW_LINE DEDENT n = 10 NEW_LINE k = 3 NEW_LINE print ( getSum ( n , k ) ) NEW_LINE
import numpy as np NEW_LINE def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT rslt = np . zeros ( 3 ) NEW_LINE x = - D / A NEW_LINE y = - D / B NEW_LINE z = - D / C NEW_LINE rslt [ 0 ] = x NEW_LINE rslt [ 1 ] = y NEW_LINE rslt [ 2 ] = z NEW_LINE return rslt NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT A = 2 NEW_LINE B = 5 NEW_LINE C = 7 NEW_LINE D = 8 NEW_LINE rslt = XandYandZintercept ( A , B , C , D ) NEW_LINE print ( rslt ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def maxSum ( a , n ) : NEW_LINE INDENT l = [ ] NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += abs ( a [ i ] ) NEW_LINE if a [ i ] >= 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE l . append ( i ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT print ( l [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT n = 4 NEW_LINE a = [ 1 , - 2 , - 3 , 4 ] NEW_LINE GFG . maxSum ( a , n ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT MAX = 1000 NEW_LINE @ staticmethod NEW_LINE def replace_spaces ( str ) : NEW_LINE INDENT space_count = 0 NEW_LINE i = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] == ' ▁ ' : NEW_LINE INDENT space_count += 1 NEW_LINE DEDENT DEDENT while str [ i - 1 ] == ' ▁ ' : NEW_LINE INDENT space_count -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT new_length = i + space_count * 2 NEW_LINE if new_length > GFG . MAX : NEW_LINE INDENT return str NEW_LINE DEDENT index = new_length - 1 NEW_LINE new_str = str NEW_LINE str = [ ' ' ] * new_length NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if new_str [ j ] == ' ▁ ' : NEW_LINE INDENT str [ index ] = '0' NEW_LINE str [ index - 1 ] = '2' NEW_LINE str [ index - 2 ] = ' % ' NEW_LINE index -= 3 NEW_LINE DEDENT else : NEW_LINE INDENT str [ index ] = new_str [ j ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT str = list ( " Mr ▁ John ▁ Smith ▁ " ) NEW_LINE str = self . replace_spaces ( str ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT print ( str [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE
class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = Scanner ( System . in ) NEW_LINE self . doIt ( ) NEW_LINE DEDENT def doIt ( self ) : NEW_LINE INDENT n = int ( self . sc . nextInt ( ) ) NEW_LINE str = self . sc . next ( ) NEW_LINE ctr = list ( str ) NEW_LINE m = int ( self . sc . nextInt ( ) ) NEW_LINE num = n NEW_LINE sb = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT sb += ctr [ i ] NEW_LINE DEDENT elif m < num : NEW_LINE INDENT if ctr [ i ] == '0' : NEW_LINE INDENT sb += '1' NEW_LINE m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT sb += '1' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ctr [ i ] == '0' : NEW_LINE INDENT sb += '1' NEW_LINE DEDENT else : NEW_LINE INDENT sb += '0' NEW_LINE DEDENT DEDENT num -= 1 NEW_LINE DEDENT print ( sb ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def check ( n ) : NEW_LINE INDENT m = n NEW_LINE while n != 0 : NEW_LINE INDENT r = n % 10 NEW_LINE if r > 0 : NEW_LINE INDENT if m % r != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT @ staticmethod NEW_LINE def count ( l , r ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if GFG . check ( i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT l , r = 10 , 20 NEW_LINE print ( GFG . count ( 10 , 20 ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( a * 10 + 1 , a * 10 + 2 ) NEW_LINE DEDENT elif a + 1 == b : NEW_LINE INDENT print ( a , b ) NEW_LINE DEDENT elif a + 1 == b * 10 : NEW_LINE INDENT print ( a , b * 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE num = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE maxdif = 0 NEW_LINE maxAll = 1000000000 NEW_LINE for i in range ( 1 , num - 1 ) : NEW_LINE INDENT for j in range ( len ( arr ) - 1 ) : NEW_LINE INDENT if j == i : NEW_LINE INDENT maxdif = max ( abs ( arr [ j - 1 ] - arr [ j + 1 ] ) , maxdif ) NEW_LINE DEDENT else : NEW_LINE INDENT maxdif = max ( abs ( arr [ j ] - arr [ j + 1 ] ) , maxdif ) NEW_LINE DEDENT DEDENT maxAll = min ( maxAll , maxdif ) NEW_LINE maxdif = 0 NEW_LINE DEDENT print ( maxAll ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT in_str = input ( ) NEW_LINE i = int ( in_str [ - 1 ] ) NEW_LINE if len ( in_str ) > 1 and ( int ( in_str [ - 2 ] ) * 10 + i ) % 4 == 0 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif len ( in_str ) == 1 and i % 4 == 0 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = sys . stdin NEW_LINE self . st = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st is None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = self . br . readline ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT return self . br . readline ( ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT obj = FastReader ( ) NEW_LINE k = obj . nextInt ( ) NEW_LINE str = list ( obj . next ( ) ) NEW_LINE n = len ( str ) NEW_LINE str . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += int ( str [ i ] ) NEW_LINE DEDENT idx = 0 NEW_LINE ans = 0 NEW_LINE while idx < n and sum < k : NEW_LINE INDENT sum -= int ( str [ idx ] ) NEW_LINE str [ idx ] = '9' NEW_LINE sum += 9 NEW_LINE idx += 1 NEW_LINE ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT N , K , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE cost = 0 NEW_LINE while N != 1 : NEW_LINE INDENT if N < K : NEW_LINE INDENT cost += ( N - 1 ) * A NEW_LINE break NEW_LINE DEDENT r = N % K NEW_LINE cost += r * A NEW_LINE N -= r NEW_LINE if B >= ( N - N // K ) * A : NEW_LINE INDENT cost += ( N - 1 ) * A NEW_LINE break NEW_LINE DEDENT cost += B NEW_LINE N //= K NEW_LINE DEDENT print ( cost ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GfG : NEW_LINE INDENT def digSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 or sum > 9 : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1234 NEW_LINE print ( digSum ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = input ( ) , input ( ) NEW_LINE dp = [ [ 0 ] * ( m + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) - 1 ) NEW_LINE if a [ i - 1 ] == b [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + 2 ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) / 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( str ( n ) + " th ▁ Centered ▁ " + " heptagonal ▁ number ▁ : ▁ " + str ( centered_heptagonal_num ( n ) ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def missingNum ( arr , n ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in arr : NEW_LINE INDENT list . append ( i ) NEW_LINE DEDENT minvalue = min ( list ) NEW_LINE xornum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xornum ^= ( minvalue ) ^ arr [ i ] NEW_LINE minvalue += 1 NEW_LINE DEDENT return xornum ^ minvalue NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 13 , 12 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . missingNum ( arr , n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def smallestPermute ( n ) : NEW_LINE INDENT res = [ ' ' ] * ( n + 1 ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) NEW_LINE DEDENT DEDENT res [ n - 1 ] = chr ( 48 + n - 2 ) NEW_LINE res [ n - 2 ] = chr ( 48 + n ) NEW_LINE res [ n - 3 ] = chr ( 48 + n - 1 ) NEW_LINE DEDENT res [ n ] = ' \0' NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT n = 7 NEW_LINE smallestPermute ( n ) NEW_LINE DEDENT
` ` ` python NEW_LINE class geeks : NEW_LINE INDENT def minOperations ( a , n , K ) : NEW_LINE INDENT map = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT try : NEW_LINE INDENT if map [ a [ i ] ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT try : NEW_LINE INDENT map [ a [ i ] ] = True NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = a [ i ] & K NEW_LINE DEDENT map . clear ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != b [ i ] : NEW_LINE INDENT try : NEW_LINE INDENT map [ b [ i ] ] = True NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT try : NEW_LINE INDENT if map [ a [ i ] ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT map . clear ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT try : NEW_LINE INDENT if map [ b [ i ] ] : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT try : NEW_LINE INDENT map [ b [ i ] ] = True NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT K = 3 NEW_LINE a = [ 1 , 2 , 3 , 7 ] NEW_LINE n = len ( a ) NEW_LINE print ( minOperations ( a , n , K ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . h = 0 NEW_LINE self . w = 0 NEW_LINE self . grid = [ ] NEW_LINE self . B = False NEW_LINE self . W = False NEW_LINE self . countB = 0 NEW_LINE self . countW = 0 NEW_LINE self . dx = [ 1 , - 1 , 0 , 0 ] NEW_LINE self . dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE self . from = ' ' NEW_LINE self . to = ' ' NEW_LINE self . countGrid = 0 NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT w = int ( input ( ) ) NEW_LINE while w != 0 : NEW_LINE INDENT self . h = int ( input ( ) ) NEW_LINE self . grid = [ list ( input ( ) ) for _ in range ( self . h ) ] NEW_LINE self . countB = 0 NEW_LINE self . countW = 0 NEW_LINE for i in range ( self . h ) : NEW_LINE INDENT for j in range ( self . w ) : NEW_LINE INDENT if self . grid [ i ] [ j ] == ' . ' : NEW_LINE INDENT self . B = False NEW_LINE self . W = False NEW_LINE self . countGrid = 0 NEW_LINE self . dfs ( j , i ) NEW_LINE if self . B and not self . W : NEW_LINE INDENT self . countB += self . countGrid NEW_LINE DEDENT if not self . B and self . W : NEW_LINE INDENT self . countW += self . countGrid NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( self . countB , self . countW ) NEW_LINE w = int ( input ( ) ) NEW_LINE DEDENT DEDENT def dfs ( self , x , y ) : NEW_LINE INDENT self . grid [ y ] [ x ] = ' x ' NEW_LINE self . countGrid += 1 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT nx = x + self . dx [ i ] NEW_LINE ny = y + self . dy [ i ] NEW_LINE if 0 <= nx < self . w and 0 <= ny < self . h : NEW_LINE INDENT if self . grid [ ny ] [ nx ] == ' B ' : NEW_LINE INDENT self . B = True NEW_LINE DEDENT elif self . grid [ ny ] [ nx ] == ' W ' : NEW_LINE INDENT self . W = True NEW_LINE DEDENT elif self . grid [ ny ] [ nx ] == ' . ' : NEW_LINE INDENT self . dfs ( nx , ny ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . solve ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if 360 % ( 180 - n ) == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE from math import factorial NEW_LINE from itertools import combinations NEW_LINE class p493 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . NUM_COLORS = 7 NEW_LINE self . BALLS_PER_COLOR = 10 NEW_LINE self . NUM_PICKED = 20 NEW_LINE self . numerator = 0 NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT self . explore ( self . NUM_PICKED , self . BALLS_PER_COLOR , [ ] ) NEW_LINE denominator = self . binomial ( self . NUM_COLORS * self . BALLS_PER_COLOR , self . NUM_PICKED ) NEW_LINE num = self . numerator NEW_LINE den = denominator NEW_LINE return str ( num / den ) NEW_LINE DEDENT def explore ( self , remain , limit , history ) : NEW_LINE INDENT if remain == 0 : NEW_LINE INDENT hist = history NEW_LINE histogram = [ hist . count ( i ) for i in range ( 1 , self . BALLS_PER_COLOR + 1 ) ] NEW_LINE count = factorial ( self . NUM_COLORS ) NEW_LINE for x in histogram : NEW_LINE INDENT count //= factorial ( x ) NEW_LINE DEDENT for x in hist : NEW_LINE INDENT count *= self . binomial ( self . BALLS_PER_COLOR , x ) NEW_LINE DEDENT distinctColors = len ( set ( history ) ) NEW_LINE self . numerator += count * distinctColors NEW_LINE DEDENT elif len ( history ) < self . NUM_COLORS : NEW_LINE INDENT for i in range ( min ( limit , remain ) , 0 , - 1 ) : NEW_LINE INDENT self . explore ( remain - i , i , history + [ i ] ) NEW_LINE DEDENT DEDENT DEDENT def binomial ( self , n , k ) : NEW_LINE INDENT return factorial ( n ) // ( factorial ( k ) * factorial ( n - k ) ) NEW_LINE DEDENT DEDENT p = p493 ( ) NEW_LINE print ( p . run ( ) ) NEW_LINE
import java . util . Scanner NEW_LINE def main ( ) : NEW_LINE INDENT sc = Scanner ( System . in ) NEW_LINE landings = sc . nextInt ( ) NEW_LINE time = sc . nextInt ( ) NEW_LINE minutes = [ 0 ] * landings NEW_LINE for i in range ( landings ) : NEW_LINE INDENT hours = sc . nextInt ( ) * 60 NEW_LINE minute = sc . nextInt ( ) NEW_LINE minutes [ i ] = minute + hours NEW_LINE DEDENT if time + 1 <= minutes [ 0 ] : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE return NEW_LINE DEDENT for i in range ( landings - 1 ) : NEW_LINE INDENT if minutes [ i + 1 ] - minutes [ i ] >= 2 * time + 2 : NEW_LINE INDENT flight = minutes [ i ] + time + 1 NEW_LINE h = flight // 60 NEW_LINE m = flight % 60 NEW_LINE print ( h , m ) NEW_LINE return NEW_LINE DEDENT DEDENT flight = minutes [ landings - 1 ] + time + 1 NEW_LINE h = flight // 60 NEW_LINE m = flight % 60 NEW_LINE print ( h , m ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT k = int ( input ( ) ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if B == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( A , A * B , ( B + 1 ) * A ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE import sys NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = sys . stdin NEW_LINE self . INF = 1 << 28 NEW_LINE self . EPS = 1e-9 NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT s = self . sc . readline ( ) . strip ( ) NEW_LINE t = self . sc . readline ( ) . strip ( ) NEW_LINE if s == "0" : NEW_LINE INDENT break NEW_LINE DEDENT hit = 0 NEW_LINE blow = 0 NEW_LINE for j in range ( 4 ) : NEW_LINE INDENT if t [ j ] == s [ j ] : NEW_LINE INDENT hit += 1 NEW_LINE DEDENT for i in range ( 4 ) : NEW_LINE INDENT if t [ j ] == s [ i ] : NEW_LINE INDENT blow += 1 NEW_LINE DEDENT DEDENT DEDENT blow -= hit NEW_LINE self . println ( str ( hit ) + " ▁ " + str ( blow ) ) NEW_LINE DEDENT DEDENT def debug ( self , * os ) : NEW_LINE INDENT print ( os , file = sys . stderr ) NEW_LINE DEDENT def print ( self , s ) : NEW_LINE INDENT sys . stdout . write ( s ) NEW_LINE DEDENT def println ( self , s ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def findMaxValue ( arr , n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT print ( " The ▁ array ▁ should ▁ have ▁ atleast ▁ 4 ▁ elements " ) NEW_LINE DEDENT table1 = [ float ( ' - inf ' ) ] * ( n + 1 ) NEW_LINE table2 = [ float ( ' - inf ' ) ] * n NEW_LINE table3 = [ float ( ' - inf ' ) ] * ( n - 1 ) NEW_LINE table4 = [ float ( ' - inf ' ) ] * ( n - 2 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT arr = [ 4 , 8 , 9 , 2 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxValue ( arr , n ) ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def centeredHexagonalSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( 3 * i * ( i - 1 ) + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE centeredHexagonalSeries ( n ) NEW_LINE DEDENT
` ` ` python NEW_LINE import re NEW_LINE ABC = [ " A " , " B " , " C " ] NEW_LINE def main ( ) : NEW_LINE INDENT S = input ( ) NEW_LINE if dfs ( S ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT def dfs ( S ) : NEW_LINE INDENT if S == " ABC " : NEW_LINE INDENT return True NEW_LINE DEDENT cnt = 0 NEW_LINE f = False NEW_LINE pos = [ False ] * len ( S ) NEW_LINE for j in range ( len ( S ) - 2 ) : NEW_LINE INDENT if S [ j : j + 3 ] == " ABC " : NEW_LINE INDENT pos [ j ] = True NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT if cnt < 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( len ( S ) ) : NEW_LINE INDENT if S [ j ] == chr ( 65 + i ) : NEW_LINE INDENT if j - i < 0 or not pos [ j - i ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT next = re . sub ( " ABC " , ABC [ i ] , S ) NEW_LINE f |= dfs ( next ) NEW_LINE DEDENT DEDENT return f NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE arrayOne = [ list ( input ( ) ) for _ in range ( m ) ] NEW_LINE sumr = 0 NEW_LINE sumc = 0 NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if arrayOne [ i ] [ j ] == ' B ' : NEW_LINE INDENT sumr += i + 1 NEW_LINE count1 += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if arrayOne [ i ] [ j ] == ' B ' : NEW_LINE INDENT sumc += j + 1 NEW_LINE count2 += 1 NEW_LINE DEDENT DEDENT DEDENT print ( sumr // count1 , sumc // count2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def diagonalsMinMax ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] NEW_LINE principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ n - 1 ] [ 0 ] NEW_LINE secondaryMax = mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT if mat [ i ] [ j ] < principalMin : NEW_LINE INDENT principalMin = mat [ i ] [ j ] NEW_LINE DEDENT if mat [ i ] [ j ] > principalMax : NEW_LINE INDENT principalMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( i + j ) == ( n - 1 ) : NEW_LINE INDENT if mat [ i ] [ j ] < secondaryMin : NEW_LINE INDENT secondaryMin = mat [ i ] [ j ] NEW_LINE DEDENT if mat [ i ] [ j ] > secondaryMax : NEW_LINE INDENT secondaryMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , principalMin ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " , principalMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , secondaryMin ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMax ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT matrix = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] NEW_LINE diagonalsMinMax ( matrix ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def diagonalsMinMax ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] NEW_LINE principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ n - 1 ] [ 0 ] NEW_LINE secondaryMax = mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] < principalMin : NEW_LINE INDENT principalMin = mat [ i ] [ i ] NEW_LINE DEDENT if mat [ i ] [ i ] > principalMax : NEW_LINE INDENT principalMax = mat [ i ] [ i ] NEW_LINE DEDENT if mat [ n - 1 - i ] [ i ] < secondaryMin : NEW_LINE INDENT secondaryMin = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT if mat [ n - 1 - i ] [ i ] > secondaryMax : NEW_LINE INDENT secondaryMax = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , principalMin ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , principalMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , secondaryMin ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMax ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT matrix = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] NEW_LINE diagonalsMinMax ( matrix ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def averageOdd ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT sum = 0 NEW_LINE count = 0 NEW_LINE while n >= 1 : NEW_LINE INDENT count += 1 NEW_LINE sum += n NEW_LINE n -= 2 NEW_LINE DEDENT return math . floor ( sum / count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE def averageOdd ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def areElementsContiguous ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE DEDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return count == len ( us ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if GFG . areElementsContiguous ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
from collections import deque NEW_LINE def getLeftMostZero ( zero ) : NEW_LINE INDENT if not zero : NEW_LINE INDENT return - 1 NEW_LINE DEDENT zero . popleft ( ) NEW_LINE return 0 NEW_LINE DEDENT def getLeftMostOne ( one ) : NEW_LINE INDENT if not one : NEW_LINE INDENT return - 1 NEW_LINE DEDENT one . popleft ( ) NEW_LINE return 1 NEW_LINE DEDENT def getLeftMostElement ( zero , one ) : NEW_LINE INDENT if not zero and not one : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif not zero : NEW_LINE INDENT one . popleft ( ) NEW_LINE return 1 NEW_LINE DEDENT elif not one : NEW_LINE INDENT zero . popleft ( ) NEW_LINE return 0 NEW_LINE DEDENT res = 0 if zero [ 0 ] < one [ 0 ] else 1 NEW_LINE if res == 0 : NEW_LINE INDENT zero . popleft ( ) NEW_LINE DEDENT else : NEW_LINE INDENT one . popleft ( ) NEW_LINE DEDENT return res NEW_LINE DEDENT def performQueries ( arr , queries ) : NEW_LINE INDENT zero = deque ( ) NEW_LINE one = deque ( ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT zero . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT one . append ( i ) NEW_LINE DEDENT DEDENT for query in queries : NEW_LINE INDENT if query == 1 : NEW_LINE INDENT print ( getLeftMostZero ( zero ) ) NEW_LINE DEDENT elif query == 2 : NEW_LINE INDENT print ( getLeftMostOne ( one ) ) NEW_LINE DEDENT elif query == 3 : NEW_LINE INDENT print ( getLeftMostElement ( zero , one ) ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 0 , 1 , 1 , 1 ] NEW_LINE queries = [ 1 , 3 , 1 ] NEW_LINE performQueries ( arr , queries ) NEW_LINE
class GFG : NEW_LINE INDENT def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) NEW_LINE print ( val * ( - 1 if x < 0 else 1 ) , "0" , end = " ▁ " ) NEW_LINE print ( "0" , val * ( - 1 if y < 0 else 1 ) ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT x , y = 3 , 3 NEW_LINE GFG . Vertices ( x , y ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 ] * n NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = P [ n - 1 ] NEW_LINE hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ P [ i ] ] = 1 NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( 1 , int ( S ** 0.5 ) + 1 ) : NEW_LINE INDENT if S % i == 0 : NEW_LINE INDENT pres = True NEW_LINE div1 = i NEW_LINE div2 = S // i NEW_LINE for j in range ( div1 , S + 1 , div1 ) : NEW_LINE INDENT if hash . get ( j ) is None or hash . get ( j ) != 1 : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if pres and div1 != S : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT pres = True NEW_LINE for j in range ( S // i , S + 1 , S // i ) : NEW_LINE INDENT if hash . get ( j ) is None or hash . get ( j ) != 1 : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if pres and div2 != S : NEW_LINE INDENT res . add ( div2 ) NEW_LINE DEDENT DEDENT DEDENT if len ( res ) == 0 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 1 , 2 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE GFG . getSum ( a , n ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
from array import array NEW_LINE def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = array ( ' i ' , [ 0 ] * n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr [ i ] = temp [ k ] NEW_LINE del temp [ k ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( Arr ) NEW_LINE originalArray ( Arr , n ) NEW_LINE DEDENT
` ` ` python NEW_LINE class practice : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE x , y , ans = 0 , 0 , 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT p = input ( ) NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ j ] == p [ 0 ] : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif s [ j ] == p [ 1 ] : NEW_LINE INDENT y += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += min ( x , y ) NEW_LINE x , y = 0 , 0 NEW_LINE DEDENT DEDENT ans += min ( x , y ) NEW_LINE x , y = 0 , 0 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import bisect NEW_LINE class Solution : NEW_LINE INDENT def findRadius ( self , houses , heaters ) : NEW_LINE INDENT heaters . sort ( ) NEW_LINE result = float ( ' - inf ' ) NEW_LINE for house in houses : NEW_LINE INDENT index = bisect . bisect_left ( heaters , house ) NEW_LINE if index < 0 : NEW_LINE INDENT index = - ( index + 1 ) NEW_LINE DEDENT dist1 = house - heaters [ index - 1 ] if index - 1 >= 0 else float ( ' inf ' ) NEW_LINE dist2 = heaters [ index ] - house if index < len ( heaters ) else float ( ' inf ' ) NEW_LINE result = max ( result , min ( dist1 , dist2 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE houses = [ 1 , 2 , 3 ] NEW_LINE heaters = [ 2 ] NEW_LINE out = sObj . findRadius ( houses , heaters ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT sObj = Solution ( ) NEW_LINE sObj . main ( ) NEW_LINE
class p130 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT sum = 0 NEW_LINE found = 0 NEW_LINE i = 7 NEW_LINE while found < 25 : NEW_LINE INDENT if i % 5 != 0 and not Library . isPrime ( i ) and ( i - 1 ) % self . findLeastDivisibleRepunit ( i ) == 0 : NEW_LINE INDENT sum += i NEW_LINE found += 1 NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT def findLeastDivisibleRepunit ( self , n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n > 2147483647 / 10 : NEW_LINE INDENT raise ValueError ( " Arithmetic ▁ overflow " ) NEW_LINE DEDENT sum = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while sum % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT DEDENT
import math NEW_LINE res = 0 NEW_LINE def checkRecursive ( num , x , k , n ) : NEW_LINE INDENT global res NEW_LINE if x == 0 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT r = int ( num ** ( 1.0 / n ) ) NEW_LINE for i in range ( k + 1 , r + 1 ) : NEW_LINE INDENT a = x - i ** n NEW_LINE if a >= 0 : NEW_LINE INDENT checkRecursive ( num , x - i ** n , i , n ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def check ( x , n ) : NEW_LINE INDENT return checkRecursive ( x , x , 0 , n ) NEW_LINE DEDENT print ( check ( 10 , 2 ) ) NEW_LINE
import java . util . Scanner NEW_LINE def main ( ) : NEW_LINE INDENT oper = " " NEW_LINE s = input ( ) NEW_LINE chs = list ( s ) NEW_LINE oper = dfs ( chs , 1 , int ( chs [ 0 ] ) , " " ) NEW_LINE sb = " " NEW_LINE for i in range ( len ( chs ) ) : NEW_LINE INDENT sb += chs [ i ] NEW_LINE if i < len ( chs ) - 1 : NEW_LINE INDENT sb += oper [ i ] NEW_LINE DEDENT DEDENT print ( sb + " = 7" ) NEW_LINE DEDENT def dfs ( chs , idx , cur , opers ) : NEW_LINE INDENT if idx == len ( chs ) : NEW_LINE INDENT if cur == 7 : NEW_LINE INDENT return opers NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT plus = dfs ( chs , idx + 1 , cur + int ( chs [ idx ] ) , opers + " + " ) NEW_LINE if plus is not None : NEW_LINE INDENT return plus NEW_LINE DEDENT nega = dfs ( chs , idx + 1 , cur - int ( chs [ idx ] ) , opers + " - " ) NEW_LINE if nega is not None : NEW_LINE INDENT return nega NEW_LINE DEDENT return None NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE b = [ 0.0 ] * n NEW_LINE total = 0.0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE total += b [ i ] / 2.0 NEW_LINE DEDENT dp = [ [ - 1.0 ] * 10001 for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = total NEW_LINE for i in range ( n ) : NEW_LINE INDENT for k in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 10001 ) : NEW_LINE INDENT if dp [ k ] [ j ] == - 1.0 : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ k + 1 ] [ j + a [ i ] ] = max ( dp [ k + 1 ] [ j + a [ i ] ] , dp [ k ] [ j ] + b [ i ] / 2.0 ) NEW_LINE DEDENT DEDENT DEDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = 0.0 NEW_LINE for j in range ( 10001 ) : NEW_LINE INDENT max_val = max ( max_val , min ( dp [ k ] [ j ] , j ) ) NEW_LINE DEDENT sys . stdout . write ( str ( max_val ) + " ▁ " ) NEW_LINE DEDENT sys . stdout . flush ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def solve ( n ) : NEW_LINE INDENT sum = [ int ( i ) for i in str ( n ) ] NEW_LINE for i in range ( len ( sum ) - 1 ) : NEW_LINE INDENT sum [ i ] -= 1 NEW_LINE sum [ i + 1 ] += 10 NEW_LINE DEDENT for i in range ( len ( sum ) - 1 , 0 , - 1 ) : NEW_LINE INDENT if sum [ i ] == 19 : NEW_LINE INDENT sum [ i ] -= 10 NEW_LINE sum [ i - 1 ] += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE print ( solve ( n ) ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT sum = a + b NEW_LINE temp = 1 NEW_LINE if sum == 0 : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while not prime ( sum + temp ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def Squares ( n , m , a ) : NEW_LINE INDENT return math . ceil ( m / a ) * math . ceil ( n / a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE m = 6 NEW_LINE a = 4 NEW_LINE print ( Squares ( n , m , a ) ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n % m == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countCubes ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , int ( i ** ( 1 / 3 ) ) + 1 ) : NEW_LINE INDENT if j * j * j == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = 7 , 30 NEW_LINE print ( " Count ▁ of ▁ Cubes ▁ is " , countCubes ( a , b ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE n = int ( input ( ) ) NEW_LINE oddList = [ 0 ] * 100001 NEW_LINE evenList = [ 0 ] * 100001 NEW_LINE values = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT v = values [ i - 1 ] NEW_LINE if i % 2 == 1 : NEW_LINE INDENT oddList [ v ] += 1 NEW_LINE DEDENT if i % 2 == 0 : NEW_LINE INDENT evenList [ v ] += 1 NEW_LINE DEDENT DEDENT maxOdd = 0 NEW_LINE maxEven = 0 NEW_LINE secondmaxOdd = 0 NEW_LINE secondmaxEven = 0 NEW_LINE countOdd = 0 NEW_LINE countEven = 0 NEW_LINE for i in range ( 1 , 100001 ) : NEW_LINE INDENT maxOdd = max ( oddList [ i ] , maxOdd ) NEW_LINE maxEven = max ( evenList [ i ] , maxEven ) NEW_LINE DEDENT oddnum = 0 NEW_LINE evennum = 0 NEW_LINE for i in range ( 1 , 100001 ) : NEW_LINE INDENT if oddList [ i ] == maxOdd : NEW_LINE INDENT oddnum = i NEW_LINE countOdd += 1 NEW_LINE DEDENT if evenList [ i ] == maxEven : NEW_LINE INDENT evennum = i NEW_LINE countEven += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT if oddList [ i ] != maxOdd : NEW_LINE INDENT secondmaxOdd = max ( oddList [ i ] , secondmaxOdd ) NEW_LINE DEDENT if evenList [ i ] != maxEven : NEW_LINE INDENT secondmaxEven = max ( evenList [ i ] , secondmaxEven ) NEW_LINE DEDENT DEDENT if countOdd >= 2 : NEW_LINE INDENT secondmaxOdd = maxOdd NEW_LINE DEDENT if countEven >= 2 : NEW_LINE INDENT secondmaxEven = maxEven NEW_LINE DEDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT if oddList [ i ] == maxOdd : NEW_LINE INDENT oddnum = i NEW_LINE DEDENT if evenList [ i ] == maxEven : NEW_LINE INDENT evennum = i NEW_LINE DEDENT DEDENT if oddnum == evennum : NEW_LINE INDENT if maxOdd > maxEven : NEW_LINE INDENT maxEven = secondmaxEven NEW_LINE DEDENT elif maxOdd < maxEven : NEW_LINE INDENT maxOdd = secondmaxOdd NEW_LINE DEDENT else : NEW_LINE INDENT maxEven = max ( secondmaxOdd , secondmaxEven ) NEW_LINE DEDENT DEDENT ans = n - maxOdd - maxEven NEW_LINE print ( ans ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def SubString ( str , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT print ( str [ i : j ] ) NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT str = " abcd " NEW_LINE GFG . SubString ( str , len ( str ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countPrimePosition ( arr ) : NEW_LINE INDENT c0 = 0 NEW_LINE c1 = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 and GFG . isPrime ( i ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT if arr [ i ] == 1 and GFG . isPrime ( i ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ 0s ▁ = ▁ " , c0 ) NEW_LINE print ( " Number ▁ of ▁ 1s ▁ = ▁ " , c1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 ] NEW_LINE GFG . countPrimePosition ( arr ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
import math NEW_LINE def angleextcycquad ( z ) : NEW_LINE INDENT print ( " The ▁ exterior ▁ angle ▁ of ▁ the ▁ cyclic ▁ quadrilateral ▁ is ▁ " + str ( z ) + " ▁ degrees " ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT z = 48 NEW_LINE angleextcycquad ( z ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def printMinIndexChar ( str , patt ) : NEW_LINE INDENT minIndex = float ( ' inf ' ) NEW_LINE m = len ( str ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if patt [ i ] == str [ j ] and j < minIndex : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if minIndex != float ( ' inf ' ) : NEW_LINE INDENT print ( " Minimum ▁ Index ▁ Character ▁ = ▁ " + str [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ character ▁ present " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE patt = " set " NEW_LINE printMinIndexChar ( str , patt ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b < a : NEW_LINE INDENT print ( " Happy ▁ Alex " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Poor ▁ Alex " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def maxnumber ( n , k ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 1 NEW_LINE while n // i > 0 : NEW_LINE INDENT temp = ( n // ( i * 10 ) ) * i + ( n % i ) NEW_LINE i *= 10 NEW_LINE ans = max ( ans , temp ) NEW_LINE DEDENT n = ans NEW_LINE DEDENT return n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6358 NEW_LINE k = 1 NEW_LINE print ( maxnumber ( n , k ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . log = sys . stdout NEW_LINE self . result = sys . stdout NEW_LINE self . sc = sys . stdin NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT N = int ( self . sc . readline ( ) ) NEW_LINE M = int ( self . sc . readline ( ) ) NEW_LINE w = [ 0 ] * N NEW_LINE for i in range ( M ) : NEW_LINE INDENT a = int ( self . sc . readline ( ) ) NEW_LINE L = int ( self . sc . readline ( ) ) NEW_LINE for j in range ( L ) : NEW_LINE INDENT w [ ( a + j ) % N ] = 1 NEW_LINE DEDENT DEDENT t = [ 0 ] * ( N + 1 ) NEW_LINE s = 0 NEW_LINE f = 0 NEW_LINE s0 = 0 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT if f == 0 and w [ i ] == 1 : NEW_LINE INDENT s = i NEW_LINE f = 1 NEW_LINE DEDENT elif f == 1 and w [ i ] == 0 : NEW_LINE INDENT f = 0 NEW_LINE if s == 0 : NEW_LINE INDENT s0 = i NEW_LINE DEDENT else : NEW_LINE INDENT t [ i - s ] += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if f == 1 : NEW_LINE INDENT t [ i - s + s0 ] += 1 NEW_LINE DEDENT elif s0 != 0 : NEW_LINE INDENT t [ s0 ] += 1 NEW_LINE DEDENT i = N NEW_LINE while i > 0 : NEW_LINE INDENT if t [ i ] > 0 : NEW_LINE INDENT self . result . write ( str ( i ) + " ▁ " + str ( t [ i ] ) + " \n " ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = Main ( ) NEW_LINE m . main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] = int ( input ( ) ) NEW_LINE DEDENT sum = 0 NEW_LINE now = 0 NEW_LINE border = 1 NEW_LINE end = 0 NEW_LINE ans_p = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE end = border - sum NEW_LINE if border > 0 : NEW_LINE INDENT if now < end : NEW_LINE INDENT ans_p += abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if now > end : NEW_LINE INDENT ans_p += abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT border = - border NEW_LINE DEDENT sum = 0 NEW_LINE now = 0 NEW_LINE border = - 1 NEW_LINE end = 0 NEW_LINE ans_m = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE end = border - sum NEW_LINE if border > 0 : NEW_LINE INDENT if now < end : NEW_LINE INDENT ans_m += abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if now > end : NEW_LINE INDENT ans_m += abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT border = - border NEW_LINE DEDENT print ( min ( ans_p , ans_m ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class AAA : NEW_LINE INDENT @ staticmethod NEW_LINE def get_last_two_digit ( N ) : NEW_LINE INDENT if N <= 10 : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT return int ( ans ) % 100 NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT N = 1 NEW_LINE for N in range ( 1 , 11 ) : NEW_LINE INDENT print ( " For ▁ N ▁ = ▁ " + str ( N ) + " ▁ : ▁ " + str ( self . get_last_two_digit ( N ) ) ) NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT binaryNumber = "1001" NEW_LINE print ( int ( binaryNumber , 2 ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
from math import ceil , floor NEW_LINE def isPossible ( x , y , z ) : NEW_LINE INDENT a = x * x + y * y + z * z NEW_LINE if ceil ( a ) == 1 and floor ( a ) == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT l , m , n = 0.70710678 , 0.5 , 0.5 NEW_LINE if isPossible ( l , m , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE MAX = 1000000 NEW_LINE MOD = 10000007 NEW_LINE result = [ 0 ] * ( MAX + 1 ) NEW_LINE fact = [ 0 ] * ( MAX + 1 ) NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( fact [ i - 1 ] % MOD ) * i % MOD NEW_LINE result [ i ] = ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE DEDENT
from array import array NEW_LINE def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE while T > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE mini = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = a [ i ] - a [ i - 1 ] NEW_LINE mini = mini + ( - 1 ) * diff * i NEW_LINE ans += mini NEW_LINE DEDENT print ( ans + a [ n - 1 ] ) NEW_LINE T -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] <= 0 : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT x = abs ( arr [ i ] ) NEW_LINE if x - 1 < size and arr [ x - 1 ] > 0 : NEW_LINE INDENT arr [ x - 1 ] = - arr [ x - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = Main . segregate ( arr , size ) NEW_LINE arr2 = [ 0 ] * ( size - shift ) NEW_LINE j = 0 NEW_LINE for i in range ( shift , size ) : NEW_LINE INDENT arr2 [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT return Main . findMissingPositive ( arr2 , j ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = Main . findMissing ( arr , arr_size ) NEW_LINE print ( " The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is " , missing ) NEW_LINE DEDENT DEDENT Main . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
mod = 1000000007 NEW_LINE def digitNumber ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 9 NEW_LINE DEDENT if n % 2 != 0 : NEW_LINE INDENT temp = digitNumber ( ( n - 1 ) // 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT DEDENT def countExcluding ( n , d ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT d = 9 NEW_LINE n = 3 NEW_LINE print ( countExcluding ( n , d ) ) NEW_LINE
import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = sys . stdin NEW_LINE self . st = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st is None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = self . br . readline ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT return self . br . readline ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sc = FastReader ( ) NEW_LINE ou = sys . stdout NEW_LINE t = sc . nextInt ( ) NEW_LINE for o in range ( t ) : NEW_LINE INDENT n = sc . nextInt ( ) NEW_LINE ar = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT ar [ i ] = sc . nextInt ( ) NEW_LINE DEDENT if ar [ 0 ] + ar [ 1 ] > ar [ n - 1 ] : NEW_LINE INDENT ou . write ( " - 1 \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT ou . write ( "1 ▁ 2 ▁ " + str ( n ) + " \n " ) NEW_LINE DEDENT DEDENT ou . flush ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def convert12 ( str ) : NEW_LINE INDENT h1 = int ( str [ 0 ] ) - 0 NEW_LINE h2 = int ( str [ 1 ] ) - 0 NEW_LINE hh = h1 * 10 + h2 NEW_LINE if hh < 12 : NEW_LINE INDENT Meridien = " AM " NEW_LINE DEDENT else : NEW_LINE INDENT Meridien = " PM " NEW_LINE DEDENT hh %= 12 NEW_LINE if hh == 0 : NEW_LINE INDENT print ( "12" , end = " " ) NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( hh , end = " " ) NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( " ▁ " + Meridien ) NEW_LINE DEDENT str = "17:35:20" NEW_LINE convert12 ( str ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def check ( s , k ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ i % k ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT @ staticmethod NEW_LINE def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n , m = len ( a ) , len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if n % i == 0 and m % i == 0 : NEW_LINE INDENT if a [ : i ] == b [ : i ] : NEW_LINE INDENT if GFG . check ( a , i ) and GFG . check ( b , i ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT a = " xaxa " NEW_LINE b = " xaxaxaxa " NEW_LINE print ( GFG . countCommonDivisors ( a , b ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def max ( a , b ) : NEW_LINE INDENT return a if a > b else b NEW_LINE DEDENT def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE print ( res ) NEW_LINE w = W NEW_LINE i = n NEW_LINE while i > 0 and res > 0 : NEW_LINE INDENT if res == K [ i - 1 ] [ w ] : NEW_LINE INDENT i -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] , end = " ▁ " ) NEW_LINE res -= val [ i - 1 ] NEW_LINE w -= wt [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT DEDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE printknapSack ( W , wt , val , n ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE z = n * 2 NEW_LINE c = 0 NEW_LINE arr = [ 0 ] * z NEW_LINE ff = [ ] NEW_LINE ss = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT ff . append ( int ( input ( ) ) ) NEW_LINE ss . append ( int ( input ( ) ) ) NEW_LINE DEDENT pp = len ( ff ) NEW_LINE for i in range ( pp ) : NEW_LINE INDENT for j in range ( pp ) : NEW_LINE INDENT if ff [ i ] == ss [ j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import array NEW_LINE def indexedSequentialSearch ( arr , n , k ) : NEW_LINE INDENT elements = array . array ( ' i ' , [ 0 ] * 20 ) NEW_LINE indices = array . array ( ' i ' , [ 0 ] * 20 ) NEW_LINE temp = 0 NEW_LINE j = 0 NEW_LINE ind = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT elements [ ind ] = arr [ i ] NEW_LINE indices [ ind ] = i NEW_LINE ind += 1 NEW_LINE i += 3 NEW_LINE DEDENT if k < elements [ 0 ] : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT i = 1 NEW_LINE while i <= ind : NEW_LINE INDENT if k < elements [ i ] : NEW_LINE INDENT start = indices [ i - 1 ] NEW_LINE end = indices [ i ] NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT i = start NEW_LINE while i <= end : NEW_LINE INDENT if k == arr [ i ] : NEW_LINE INDENT j = 1 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if j == 1 : NEW_LINE INDENT print ( " Found ▁ at ▁ index " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE DEDENT DEDENT arr = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 8 NEW_LINE indexedSequentialSearch ( arr , n , k ) NEW_LINE
class GFG : NEW_LINE INDENT def larrgestPalindrome ( n ) : NEW_LINE INDENT upper_limit = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT upper_limit *= 10 NEW_LINE upper_limit += 9 NEW_LINE DEDENT lower_limit = 1 + upper_limit // 10 NEW_LINE max_product = 0 NEW_LINE for i in range ( upper_limit , lower_limit - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i , lower_limit - 1 , - 1 ) : NEW_LINE INDENT product = i * j NEW_LINE if product < max_product : NEW_LINE INDENT break NEW_LINE DEDENT number = product NEW_LINE reverse = 0 NEW_LINE while number != 0 : NEW_LINE INDENT reverse = reverse * 10 + number % 10 NEW_LINE number //= 10 NEW_LINE DEDENT if product == reverse and product > max_product : NEW_LINE INDENT max_product = product NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( larrgestPalindrome ( n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def check ( dp , a ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( dp ) - 1 NEW_LINE while True : NEW_LINE INDENT if dp [ start ] >= a : NEW_LINE INDENT return start NEW_LINE DEDENT elif dp [ end ] <= a : NEW_LINE INDENT return end NEW_LINE DEDENT else : NEW_LINE INDENT if start + 1 == end : NEW_LINE INDENT return end NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if dp [ mid ] == a : NEW_LINE INDENT return mid NEW_LINE DEDENT elif dp [ mid ] > a : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE dp = [ 1000000001 ] * n NEW_LINE dp [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ check ( dp , a [ i ] ) ] = a [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if dp [ i ] > 1000000000 : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT if i == n - 1 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT test = int ( input ( ) ) NEW_LINE while test > 0 : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if b > c and b > a : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT if c > b and c > a : NEW_LINE INDENT a , c = c , a NEW_LINE DEDENT res = 0 NEW_LINE if a >= 1 : NEW_LINE INDENT a -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if b >= 1 : NEW_LINE INDENT b -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if c >= 1 : NEW_LINE INDENT c -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if a >= 1 and b >= 1 : NEW_LINE INDENT a -= 1 NEW_LINE b -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if a >= 1 and c >= 1 : NEW_LINE INDENT a -= 1 NEW_LINE c -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if c >= 1 and b >= 1 : NEW_LINE INDENT c -= 1 NEW_LINE b -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if a >= 1 and b >= 1 and c >= 1 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT test -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE arr = [ 0 ] * 100001 NEW_LINE dist = [ 0 ] * 100001 NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE line = sys . stdin . readline ( ) . split ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = int ( line [ i - 1 ] ) NEW_LINE DEDENT finalMax = 0 NEW_LINE for start in range ( 1 , 3 ) : NEW_LINE INDENT maxVal = 0 NEW_LINE sumVal = 0 NEW_LINE add = True NEW_LINE for i in range ( start , n ) : NEW_LINE INDENT dist [ i ] = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE if add : NEW_LINE INDENT sumVal += dist [ i ] NEW_LINE maxVal = max ( sumVal , maxVal ) NEW_LINE add = False NEW_LINE DEDENT else : NEW_LINE INDENT sumVal -= dist [ i ] NEW_LINE add = True NEW_LINE DEDENT if sumVal < 0 : NEW_LINE INDENT sumVal = 0 NEW_LINE add = True NEW_LINE DEDENT DEDENT finalMax = max ( maxVal , finalMax ) NEW_LINE DEDENT print ( finalMax ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
0ERROR
` ` ` python NEW_LINE def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ ' ' ] * 100 NEW_LINE i = 0 NEW_LINE while n != 0 : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if temp < 10 : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) NEW_LINE i += 1 NEW_LINE DEDENT n = n // 16 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( hexaDeciNum [ j ] , end = ' ' ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2545 NEW_LINE decToHexa ( n ) NEW_LINE DEDENT ` ` ` NEW_LINE
n = 0 NEW_LINE map = { } NEW_LINE def __init__ ( self , sc ) : NEW_LINE INDENT self . n = int ( sc . next ( ) ) NEW_LINE self . map = { i : 0 for i in range ( - 1 , 100002 ) } NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT a = int ( sc . next ( ) ) NEW_LINE self . map [ a ] = self . map . get ( a , 0 ) + 1 NEW_LINE DEDENT DEDENT def solve ( self ) : NEW_LINE INDENT max_val = float ( ' - inf ' ) NEW_LINE for x in range ( 100002 ) : NEW_LINE INDENT max_val = max ( max_val , self . map . get ( x - 1 , 0 ) + self . map . get ( x , 0 ) + self . map . get ( x + 1 , 0 ) ) NEW_LINE DEDENT print ( max_val ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Loc : NEW_LINE INDENT def __init__ ( self , i , j ) : NEW_LINE INDENT self . i = i NEW_LINE self . j = j NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT R , C = map ( int , input ( ) . split ( ) ) NEW_LINE if R == 0 and C == 0 : NEW_LINE INDENT break NEW_LINE DEDENT hm = { } NEW_LINE for i in range ( R ) : NEW_LINE INDENT str = input ( ) NEW_LINE for j in range ( C ) : NEW_LINE INDENT c = str [ j ] NEW_LINE if c == ' _ ' : NEW_LINE INDENT continue NEW_LINE DEDENT hm [ c ] = Loc ( i , j ) NEW_LINE DEDENT DEDENT str = input ( ) NEW_LINE iPos = 0 NEW_LINE jPos = 0 NEW_LINE count = len ( str ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT loc = hm . get ( str [ i ] ) NEW_LINE count += abs ( iPos - loc . i ) + abs ( jPos - loc . j ) NEW_LINE iPos = loc . i NEW_LINE jPos = loc . j NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( " Hello ▁ World " ) NEW_LINE DEDENT else : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( a + b ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = Main ( ) NEW_LINE m . run ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def extractMaximum ( str ) : NEW_LINE INDENT num = 0 NEW_LINE res = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] . isdigit ( ) : NEW_LINE INDENT num = num * 10 + int ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , num ) NEW_LINE num = 0 NEW_LINE DEDENT DEDENT return max ( res , num ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT str = "100klh564abc365bg " NEW_LINE print ( GFG . extractMaximum ( str ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT max = 50009 NEW_LINE @ staticmethod NEW_LINE def find_indices ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * GFG . max NEW_LINE index_1 , index_2 , index_3 , index = 0 , 0 , 0 , 0 NEW_LINE k , i = 0 , 0 NEW_LINE while i <= n : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ k ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT ans = - 1e15 NEW_LINE index_1 , index_2 , index_3 = - 1 , - 1 , - 1 NEW_LINE l = 0 NEW_LINE while l <= n : NEW_LINE INDENT index = 0 NEW_LINE vmin = 1e15 NEW_LINE r = l NEW_LINE while r <= n : NEW_LINE INDENT if sum [ r ] < vmin : NEW_LINE INDENT vmin = sum [ r ] NEW_LINE index = r NEW_LINE DEDENT if sum [ l ] + sum [ r ] - vmin > ans : NEW_LINE INDENT ans = sum [ l ] + sum [ r ] - vmin NEW_LINE index_1 = l NEW_LINE index_2 = index NEW_LINE index_3 = r NEW_LINE DEDENT r += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT print ( index_1 , index_2 , index_3 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ - 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE GFG . find_indices ( arr , n ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE
class GFG : NEW_LINE INDENT def printElements ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE GFG . printElements ( arr , n ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
class GFG : NEW_LINE INDENT def valueofX ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ar [ i ] NEW_LINE DEDENT if sum % n == 0 : NEW_LINE INDENT return sum / n NEW_LINE DEDENT else : NEW_LINE INDENT A = sum / n NEW_LINE B = sum / n + 1 NEW_LINE ValueA = 0 NEW_LINE ValueB = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) NEW_LINE ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) NEW_LINE DEDENT if ValueA < ValueB : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT return B NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE arr = [ 6 , 9 , 1 , 6 , 1 , 3 , 7 ] NEW_LINE print ( valueofX ( arr , n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , l = map ( int , input ( ) . split ( ) ) NEW_LINE s = " " NEW_LINE arr = [ 0 ] * l NEW_LINE for _ in range ( n ) : NEW_LINE INDENT temp = bin ( int ( input ( ) ) ) [ 2 : ] NEW_LINE temp = '0' * ( l - len ( temp ) ) + temp NEW_LINE for k in range ( l ) : NEW_LINE INDENT if k < len ( temp ) and temp [ k ] == '1' : NEW_LINE INDENT arr [ k ] += 1 NEW_LINE DEDENT DEDENT DEDENT for j in range ( l ) : NEW_LINE INDENT if n - arr [ j ] >= arr [ j ] : NEW_LINE INDENT s += '0' NEW_LINE DEDENT else : NEW_LINE INDENT s += '1' NEW_LINE DEDENT DEDENT print ( int ( s , 2 ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT s = input ( ) NEW_LINE sL = len ( s ) NEW_LINE sT = s NEW_LINE for i in range ( sL // 2 ) : NEW_LINE INDENT sL -= 2 NEW_LINE sT = sT [ : sL ] NEW_LINE if sT [ : sL // 2 ] == sT [ sL // 2 : ] : NEW_LINE INDENT print ( sL ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( None ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 19 NEW_LINE while True : NEW_LINE INDENT sum = 0 NEW_LINE x = curr NEW_LINE while x > 0 : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT if sum == 10 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == n : NEW_LINE INDENT return curr NEW_LINE DEDENT curr += 9 NEW_LINE DEDENT DEDENT print ( findNth ( 5 ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 1 NEW_LINE while True : NEW_LINE INDENT sum = 0 NEW_LINE x = curr NEW_LINE while x > 0 : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT if sum == 10 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == n : NEW_LINE INDENT return curr NEW_LINE DEDENT curr += 1 NEW_LINE DEDENT DEDENT print ( findNth ( 5 ) ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def countNumber ( N , S ) : NEW_LINE INDENT countElements = 0 NEW_LINE currSum = 0 NEW_LINE while currSum <= S : NEW_LINE INDENT currSum += N NEW_LINE N -= 1 NEW_LINE countElements += 1 NEW_LINE DEDENT return countElements NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT N = 5 NEW_LINE S = 11 NEW_LINE count = GFG . countNumber ( N , S ) NEW_LINE print ( count ) NEW_LINE DEDENT DEDENT
def strmatch ( str , pattern , n , m ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return n == 0 NEW_LINE DEDENT lookup = [ [ False for _ in range ( m + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE lookup [ 0 ] [ 0 ] = True NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if pattern [ j - 1 ] == ' * ' : NEW_LINE INDENT lookup [ 0 ] [ j ] = lookup [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if pattern [ j - 1 ] == ' * ' : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] or lookup [ i - 1 ] [ j ] NEW_LINE DEDENT elif pattern [ j - 1 ] == ' ? ' or str [ i - 1 ] == pattern [ j - 1 ] : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return lookup [ n ] [ m ] NEW_LINE DEDENT str = " baaabab " NEW_LINE pattern = " * * * * * ba * * * * * ab " NEW_LINE if strmatch ( str , pattern , len ( str ) , len ( pattern ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE from collections import defaultdict NEW_LINE class Main : NEW_LINE INDENT def run ( self ) : NEW_LINE INDENT p = [ True ] * 1000001 NEW_LINE p [ 0 ] = p [ 1 ] = False NEW_LINE for i in range ( 2 , 1000001 ) : NEW_LINE INDENT if p [ i ] : NEW_LINE INDENT for j in range ( i + i , 1000001 , i ) : NEW_LINE INDENT p [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a | b ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT sa = set ( ) NEW_LINE sb = set ( ) NEW_LINE k = 2 NEW_LINE while a > 1 : NEW_LINE INDENT if p [ k ] and a % k == 0 : NEW_LINE INDENT a //= k NEW_LINE sa . add ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT k = 2 NEW_LINE while b > 1 : NEW_LINE INDENT if p [ k ] and b % k == 0 : NEW_LINE INDENT b //= k NEW_LINE sb . add ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT pa = max ( sa ) NEW_LINE sa . remove ( pa ) NEW_LINE pb = max ( sb ) NEW_LINE sb . remove ( pb ) NEW_LINE for x in sa : NEW_LINE INDENT pa -= x NEW_LINE DEDENT for x in sb : NEW_LINE INDENT pb -= x NEW_LINE DEDENT print ( " a " if pa > pb else " b " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT
import math NEW_LINE def nCr ( n , r ) : NEW_LINE INDENT fac = [ 1 ] * 100 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT ans = fac [ n ] // ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE min_diff = sys . maxsize NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( a [ n - 1 ] - a [ i ] * 2 ) NEW_LINE if diff < min_diff : NEW_LINE INDENT min_diff = diff NEW_LINE ans = a [ i ] NEW_LINE DEDENT DEDENT print ( a [ n - 1 ] , ans ) NEW_LINE
import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powGCD ( a , n , b ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a = a * a NEW_LINE DEDENT return gcd ( a , b ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = 10 NEW_LINE b = 5 NEW_LINE n = 2 NEW_LINE print ( powGCD ( a , n , b ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = 0 NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE C = [ 0 ] * 10000 NEW_LINE sb = " " NEW_LINE def main ( ) : NEW_LINE INDENT global n , A , B , C , sb NEW_LINE n = int ( input ( ) ) NEW_LINE A = [ 0 ] * n NEW_LINE B = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT A [ i ] = int ( input ( ) ) NEW_LINE C [ A [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , 10000 ) : NEW_LINE INDENT C [ i ] = C [ i - 1 ] + C [ i ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT B [ C [ A [ i ] ] - 1 ] = A [ i ] NEW_LINE C [ A [ i ] ] -= 1 NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT sb += str ( B [ i ] ) + " ▁ " NEW_LINE DEDENT sb += str ( B [ n - 1 ] ) NEW_LINE print ( sb ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT sc = input ( ) NEW_LINE n = int ( sc ) NEW_LINE s = input ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '8' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( min ( count , n // 11 ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
def sumOfDigit ( n , b ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 50 NEW_LINE b = 2 NEW_LINE print ( sumOfDigit ( n , b ) ) NEW_LINE DEDENT
import math NEW_LINE def printLargestDivisible ( n , a ) : NEW_LINE INDENT c0 = 0 NEW_LINE c5 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c5 += 1 NEW_LINE DEDENT DEDENT c5 = math . floor ( c5 / 9 ) * 9 NEW_LINE if c0 == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif c5 == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( c5 ) : NEW_LINE INDENT print ( 5 , end = ' ' ) NEW_LINE DEDENT for i in range ( c0 ) : NEW_LINE INDENT print ( 0 , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 0 , 5 , 5 ] NEW_LINE n = len ( a ) NEW_LINE printLargestDivisible ( n , a ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if i + j + k + l == n : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE def numberOfMinutes ( S , S1 ) : NEW_LINE INDENT Min = 0 NEW_LINE Min = int ( ( ( S - S1 ) / math . floor ( S ) ) * 60 ) NEW_LINE return Min NEW_LINE DEDENT S = 30 NEW_LINE S1 = 10 NEW_LINE print ( numberOfMinutes ( S , S1 ) , " min " ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n < k : NEW_LINE INDENT print ( n ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT d = [ b [ i + 1 ] - b [ i ] - 1 for i in range ( n - 1 ) ] NEW_LINE d . sort ( ) NEW_LINE sum = b [ - 1 ] - b [ 0 ] + 1 NEW_LINE for i in range ( len ( d ) - 1 , len ( d ) - 1 - ( k - 1 ) , - 1 ) : NEW_LINE INDENT sum -= d [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def onesComplement ( n ) : NEW_LINE INDENT number_of_bits = int ( math . floor ( math . log ( n ) / math . log ( 2 ) ) ) + 1 NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 22 NEW_LINE print ( onesComplement ( n ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT w , h , n = map ( int , input ( ) . split ( ) ) NEW_LINE sheet = 1 NEW_LINE while w % 2 == 0 : NEW_LINE INDENT w //= 2 NEW_LINE sheet *= 2 NEW_LINE DEDENT while h % 2 == 0 : NEW_LINE INDENT h //= 2 NEW_LINE sheet *= 2 NEW_LINE DEDENT if sheet >= n : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( " ( " + str ( 2 * x2 - x1 ) + " , " + str ( 2 * y2 - y1 ) + " ▁ ) " ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = 0 , 0 , 1 , 1 NEW_LINE GFG . findPoint ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE n = int ( input ( ) ) + 1 NEW_LINE m = n // 2 NEW_LINE inputs = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( inputs [ 0 ] ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE a = a - m if ( a - m ) > 0 and n % 2 > 0 else a NEW_LINE b = b - m if ( b - m ) > 0 and n % 2 > 0 else b NEW_LINE result = ( m - 1 - max ( abs ( a ) , abs ( b ) ) ) % 3 + 1 NEW_LINE print ( result ) NEW_LINE DEDENT
import sys NEW_LINE def alter ( x , y ) : NEW_LINE INDENT while True : NEW_LINE INDENT if x == 0 or y == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if x >= 2 * y : NEW_LINE INDENT x = x % ( 2 * y ) NEW_LINE DEDENT elif y >= 2 * x : NEW_LINE INDENT y = y % ( 2 * x ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " X ▁ = ▁ " + str ( x ) + " , ▁ " + " Y ▁ = ▁ " + str ( y ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 12 NEW_LINE y = 5 NEW_LINE alter ( x , y ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE import random NEW_LINE def swap ( a , x , y ) : NEW_LINE INDENT t = a [ x ] NEW_LINE a [ x ] = a [ y ] NEW_LINE a [ y ] = t NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE v = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = set ( v ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT swap ( v , int ( random . random ( ) * ( i - 1 ) ) , i ) NEW_LINE DEDENT v . sort ( ) NEW_LINE ans = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d = v [ j ] - v [ i ] NEW_LINE if v [ i ] - d in s : NEW_LINE INDENT continue NEW_LINE DEDENT cnt , cur = 2 , v [ j ] NEW_LINE while cur + d in s : NEW_LINE INDENT cur += d NEW_LINE cnt += 1 NEW_LINE DEDENT ans = max ( ans , cnt ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT flag = False NEW_LINE finals = 0 NEW_LINE cases = int ( input ( ) ) NEW_LINE for _ in range ( cases ) : NEW_LINE INDENT flag = False NEW_LINE letters = int ( input ( ) ) NEW_LINE ab = input ( ) NEW_LINE for i in range ( 1 , letters ) : NEW_LINE INDENT if ab [ i - 1 ] != ab [ i ] : NEW_LINE INDENT flag = True NEW_LINE print ( i , i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT print ( " - 1 ▁ - 1" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
mod = 1000000007 NEW_LINE inv2 = 500000004 NEW_LINE def modulo ( num ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + int ( num [ i ] ) - 0 ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT def findSum ( L , R ) : NEW_LINE INDENT a = modulo ( L ) NEW_LINE b = modulo ( R ) NEW_LINE l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod NEW_LINE r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod NEW_LINE ret = ( r % mod - l % mod ) NEW_LINE if ret < 0 : NEW_LINE INDENT ret = ret + mod NEW_LINE DEDENT else : NEW_LINE INDENT ret = ret % mod NEW_LINE DEDENT return ret NEW_LINE DEDENT L = "88949273204" NEW_LINE R = "98429729474298592" NEW_LINE print ( findSum ( L , R ) ) NEW_LINE
class GFG : NEW_LINE INDENT def unsort ( l , r , a , k ) : NEW_LINE INDENT if k < 1 or l + 1 == r : NEW_LINE INDENT return NEW_LINE DEDENT k -= 2 NEW_LINE mid = ( l + r ) // 2 NEW_LINE temp = a [ mid - 1 ] NEW_LINE a [ mid - 1 ] = a [ mid ] NEW_LINE a [ mid ] = temp NEW_LINE unsort ( l , mid , a , k ) NEW_LINE unsort ( mid , r , a , k ) NEW_LINE DEDENT def arrayWithKCalls ( n , k ) : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT print ( " NO ▁ SOLUTION " ) NEW_LINE return NEW_LINE DEDENT a = [ 0 ] * ( n + 1 ) NEW_LINE a [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = i + 1 NEW_LINE DEDENT k -= 1 NEW_LINE unsort ( 0 , n , a , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE k = 17 NEW_LINE arrayWithKCalls ( n , k ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def mean ( mid , freq , n ) : NEW_LINE INDENT sum = 0 NEW_LINE freqSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + mid [ i ] * freq [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT return sum / freqSum NEW_LINE DEDENT def groupedSD ( lower_limit , upper_limit , freq , n ) : NEW_LINE INDENT mid = [ 0 ] * n NEW_LINE sum = 0 NEW_LINE freqSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 NEW_LINE sum = sum + freq [ i ] * mid [ i ] * mid [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT sd = math . sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) NEW_LINE return sd NEW_LINE DEDENT lower_limit = [ 50 , 61 , 71 , 86 , 96 ] NEW_LINE upper_limit = [ 60 , 70 , 85 , 95 , 100 ] NEW_LINE freq = [ 9 , 7 , 9 , 12 , 8 ] NEW_LINE n = len ( lower_limit ) NEW_LINE print ( groupedSD ( lower_limit , upper_limit , freq , n ) ) NEW_LINE
from math import gcd NEW_LINE class GFG : NEW_LINE INDENT def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def rectanglearea ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( rectanglearea ( a , b ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE MOD = int ( 1e9 + 7 ) NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n < a : NEW_LINE INDENT print ( " No " ) NEW_LINE continue NEW_LINE DEDENT if a == b : NEW_LINE INDENT if n % a == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT continue NEW_LINE DEDENT x = b // ( b - a ) NEW_LINE if n > x * a : NEW_LINE INDENT print ( " Yes " ) NEW_LINE continue NEW_LINE DEDENT low = 1 NEW_LINE high = x + 1 NEW_LINE ans = 1 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if mid * a < n : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT DEDENT if n > ( ans - 1 ) * b and n < ans * a : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def getsum ( x ) : NEW_LINE INDENT return ( x * ( x + 1 ) ) // 2 NEW_LINE DEDENT def countJumps ( n ) : NEW_LINE INDENT n = abs ( n ) NEW_LINE ans = 0 NEW_LINE while getsum ( ans ) < n or ( ( getsum ( ans ) - n ) & 1 ) > 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 9 NEW_LINE print ( countJumps ( n ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT MAX = 10 NEW_LINE @ staticmethod NEW_LINE def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if k < 0 : NEW_LINE INDENT return - 10000000 NEW_LINE DEDENT if n < 0 or m < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT try : NEW_LINE INDENT ans = max ( GFG . lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , GFG . lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if arr1 [ n - 1 ] == arr2 [ m - 1 ] : NEW_LINE INDENT ans = max ( ans , 1 + GFG . lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , 1 + GFG . lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT pass NEW_LINE DEDENT return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT k = 1 NEW_LINE arr1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE arr2 = [ 5 , 3 , 1 , 4 , 2 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE dp = [ [ [ - 1 for _ in range ( GFG . MAX ) ] for _ in range ( GFG . MAX ) ] for _ in range ( GFG . MAX ) ] NEW_LINE for i in range ( GFG . MAX ) : NEW_LINE INDENT for j in range ( GFG . MAX ) : NEW_LINE INDENT for l in range ( GFG . MAX ) : NEW_LINE INDENT dp [ i ] [ j ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT print ( GFG . lcs ( dp , arr1 , n , arr2 , m , k ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
from decimal import Decimal NEW_LINE def main ( ) : NEW_LINE INDENT N = float ( input ( ) ) NEW_LINE d = float ( input ( ) ) NEW_LINE x = float ( input ( ) ) NEW_LINE ans = Decimal ( "0.0" ) NEW_LINE while N > 0.5 : NEW_LINE INDENT adnum = Decimal ( d + x * ( N - 0.5 ) ) NEW_LINE ans += adnum NEW_LINE d = ( N + 1.0 ) * d / N + ( 5.0 * x ) / ( 2.0 * N ) NEW_LINE x = ( 1.0 + ( 2.0 / N ) ) * x NEW_LINE N -= 1 NEW_LINE DEDENT print ( ' { : . 20f } ' . format ( ans ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def reverseorder ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for i in range ( n , 1 , - 1 ) : NEW_LINE INDENT if prime [ i ] == True : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 25 NEW_LINE print ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) NEW_LINE if N == 1 : NEW_LINE INDENT print ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) NEW_LINE DEDENT else : NEW_LINE INDENT reverseorder ( N ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def pattern ( min_stars , p_height ) : NEW_LINE INDENT p_space = p_height - 1 NEW_LINE x = 1 NEW_LINE for i in range ( p_height ) : NEW_LINE INDENT for j in range ( p_space , i , - 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for k in range ( min_stars ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT for n in range ( p_height + p_height - 2 , x - 1 , - 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for k in range ( min_stars ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT min_stars = min_stars + 2 NEW_LINE x = x + 2 NEW_LINE print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT min_stars = 1 NEW_LINE p_height = 5 NEW_LINE pattern ( min_stars , p_height ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE n = int ( input ( ) ) NEW_LINE FfriendPerDay = [ 0 ] * 367 NEW_LINE MfriendPerDay = [ 0 ] * 367 NEW_LINE answer = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT c , a , b = input ( ) . split ( ) NEW_LINE a , b = int ( a ) , int ( b ) NEW_LINE for j in range ( a , b + 1 ) : NEW_LINE INDENT if c == ' M ' : NEW_LINE INDENT MfriendPerDay [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT FfriendPerDay [ j ] += 1 NEW_LINE DEDENT if MfriendPerDay [ j ] < FfriendPerDay [ j ] : NEW_LINE INDENT if MfriendPerDay [ j ] > answer : NEW_LINE INDENT answer = MfriendPerDay [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if FfriendPerDay [ j ] > answer : NEW_LINE INDENT answer = FfriendPerDay [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( answer * 2 ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE
import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 NEW_LINE return int ( round ( math . pow ( phi , n ) / math . sqrt ( 5 ) ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT def sumFibonacci ( k ) : NEW_LINE INDENT l = ( k * ( k - 1 ) ) // 2 NEW_LINE r = l + k NEW_LINE sum = calculateSum ( l , r - 1 ) NEW_LINE return sum NEW_LINE DEDENT k = 3 NEW_LINE print ( sumFibonacci ( k ) ) NEW_LINE
import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 NEW_LINE return int ( round ( math . pow ( phi , n ) / math . sqrt ( 5 ) ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + 5 ** 0.5 ) / 2 NEW_LINE return int ( round ( phi ** n / 5 ** 0.5 ) ) NEW_LINE DEDENT @ staticmethod NEW_LINE def calculateSum ( l , r ) : NEW_LINE INDENT sum = GFG . fib ( r + 2 ) - GFG . fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT l , r = 4 , 8 NEW_LINE print ( GFG . calculateSum ( l , r ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE str = list ( s ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l , r , c1 , c2 = input ( ) . split ( ) NEW_LINE l , r = int ( l ) - 1 , int ( r ) - 1 NEW_LINE start , end = l , r NEW_LINE while start <= end : NEW_LINE INDENT if str [ start ] == c1 : NEW_LINE INDENT str [ start ] = c2 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT DEDENT print ( ' ' . join ( str ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def compareStrings ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( str1 ) - 1 and str1 [ i ] == str2 [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if str1 [ i ] > str2 [ i ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if str1 [ i ] < str2 [ i ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def searchStr ( arr , str , first , last ) : NEW_LINE INDENT if first > last : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( last + first ) // 2 NEW_LINE if arr [ mid ] == " " : NEW_LINE INDENT left = mid - 1 NEW_LINE right = mid + 1 NEW_LINE while True : NEW_LINE INDENT if left < right and right > last : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if right <= last and arr [ right ] != " " : NEW_LINE INDENT mid = right NEW_LINE break NEW_LINE DEDENT if left >= right and arr [ left ] != " " : NEW_LINE INDENT mid = left NEW_LINE break NEW_LINE DEDENT right += 1 NEW_LINE left -= 1 NEW_LINE DEDENT DEDENT if GFG . compareStrings ( str , arr [ mid ] ) == 0 : NEW_LINE INDENT return mid NEW_LINE DEDENT if GFG . compareStrings ( str , arr [ mid ] ) < 0 : NEW_LINE INDENT return GFG . searchStr ( arr , str , mid + 1 , last ) NEW_LINE DEDENT return GFG . searchStr ( arr , str , first , mid - 1 ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ " for " , " " , " " , " " , " geeks " , " ide " , " " , " practice " , " " , " " , " quiz " , " " , " " ] NEW_LINE str = " quiz " NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . searchStr ( arr , str , 0 , n - 1 ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def getNum ( a , b ) : NEW_LINE INDENT reverseB = 0 NEW_LINE while b > 0 : NEW_LINE INDENT reverseB = reverseB * 10 + b % 10 NEW_LINE b //= 10 NEW_LINE DEDENT return a + reverseB NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE ans = getNum ( a , b ) NEW_LINE print ( ans ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE x1 , y1 , x2 , y2 , x3 , y3 = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE print ( "3" ) NEW_LINE print ( ( x1 + x2 - x3 ) , ( y1 + y2 - y3 ) ) NEW_LINE print ( ( x3 + x2 - x1 ) , ( y3 + y2 - y1 ) ) NEW_LINE print ( ( x1 + x3 - x2 ) , ( y1 + y3 - y2 ) ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE tmp = " " NEW_LINE freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( freq [ i ] ) : NEW_LINE INDENT tmp += chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != tmp [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def sumAP ( n , d ) : NEW_LINE INDENT n //= d NEW_LINE return ( n ) * ( 1 + n ) * d // 2 NEW_LINE DEDENT @ staticmethod NEW_LINE def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE return GFG . sumAP ( n , 2 ) + GFG . sumAP ( n , 5 ) - GFG . sumAP ( n , 10 ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT n = 20 NEW_LINE print ( GFG . sumMultiples ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , f = map ( int , input ( ) . split ( ) ) NEW_LINE sum += f - s NEW_LINE DEDENT if t <= sum : NEW_LINE INDENT print ( " OK " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( t - sum ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
def fact ( num ) : NEW_LINE INDENT fact = 1 NEW_LINE while num > 1 : NEW_LINE INDENT fact *= num NEW_LINE num -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT return fact ( 2 * n ) // ( fact ( n ) * fact ( n + 1 ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE for k in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < arr [ k ] : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT catalan_leftBST = catalan ( s ) NEW_LINE catalan_rightBST = catalan ( n - s - 1 ) NEW_LINE totalBST = catalan_rightBST * catalan_leftBST NEW_LINE print ( totalBST , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java . awt . font . FontRenderContext NEW_LINE import java . awt . image . ImageProducer NEW_LINE import java . beans . beancontext . BeanContextServiceRevokedEvent NEW_LINE import java . lang . reflect . Array NEW_LINE import java . util . * NEW_LINE import java . math . BigInteger NEW_LINE import java . util . spi . LocaleNameProvider NEW_LINE class ques : NEW_LINE INDENT def main ( args ) : NEW_LINE INDENT sc = Scanner ( System . in ) NEW_LINE n = sc . nextInt ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT a = sc . nextLong ( ) NEW_LINE b = sc . nextLong ( ) NEW_LINE if abs ( a - b ) == 1 : NEW_LINE INDENT System . out . println ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT System . out . println ( " YES " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT try : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT else : NEW_LINE INDENT if a % 2 != b % 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def countWays ( n , arr , length ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in range ( length ) : NEW_LINE INDENT if i - arr [ j ] >= 0 : NEW_LINE INDENT no_ways += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT count [ i ] = no_ways NEW_LINE DEDENT return count [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 5 ] NEW_LINE length = len ( arr ) NEW_LINE n = 5 NEW_LINE print ( countWays ( n , arr , length ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = input NEW_LINE self . doit ( ) NEW_LINE DEDENT def doit ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( self . sc ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT data = [ 0 ] * 12 NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT data [ i ] = int ( self . sc ( ) ) - int ( self . sc ( ) ) NEW_LINE DEDENT sum = 0 NEW_LINE flg = False NEW_LINE ans = - 1 NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT sum += data [ i ] NEW_LINE if sum >= n : NEW_LINE INDENT ans = i + 1 NEW_LINE flg = True NEW_LINE break NEW_LINE DEDENT DEDENT if flg : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT DEDENT DEDENT def debug ( self , * o ) : NEW_LINE INDENT print ( " debug ▁ = ▁ " + str ( o ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b and c == b : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = abs ( a - b ) + abs ( b - c ) + abs ( c - a ) NEW_LINE sum -= 4 NEW_LINE print ( max ( sum , 0 ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n , b , d = map ( int , input ( ) . split ( ) ) NEW_LINE a_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE for a in a_list : NEW_LINE INDENT if a <= b : NEW_LINE INDENT sum += a NEW_LINE DEDENT if sum > d : NEW_LINE INDENT sum = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , mid - 1 , key ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE key = 10 NEW_LINE print ( " Index : " , binarySearch ( arr , 0 , n , key ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE Xor = Xor ^ arr [ i ] NEW_LINE DEDENT if Sum == Xor : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE GFG . equal_xor_sum ( arr , n ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE x = [ False ] * 10000001 NEW_LINE def main ( ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE m_values = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for val in m_values : NEW_LINE INDENT x [ val ] = True NEW_LINE DEDENT pos = 1 NEW_LINE for _ in range ( k ) : NEW_LINE INDENT if x [ pos ] : NEW_LINE INDENT print ( pos ) NEW_LINE return NEW_LINE DEDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE pos = b if pos == a else a if pos == b else pos NEW_LINE DEDENT print ( pos ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
0ERROR
import sys NEW_LINE def minBroadcastRange ( houses , towers ) : NEW_LINE INDENT n = len ( houses ) NEW_LINE m = len ( towers ) NEW_LINE leftTower = - sys . maxsize - 1 NEW_LINE rightTower = towers [ 0 ] NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE min_range = 0 NEW_LINE while j < n : NEW_LINE INDENT if houses [ j ] < rightTower : NEW_LINE INDENT left = houses [ j ] - leftTower NEW_LINE right = rightTower - houses [ j ] NEW_LINE local_max = min ( left , right ) NEW_LINE if local_max > min_range : NEW_LINE INDENT min_range = local_max NEW_LINE DEDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT leftTower = towers [ k ] NEW_LINE if k < m - 1 : NEW_LINE INDENT k += 1 NEW_LINE rightTower = towers [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT rightTower = sys . maxsize NEW_LINE DEDENT DEDENT DEDENT return min_range NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = [ 12 , 13 , 11 , 80 ] NEW_LINE b = [ 4 , 6 , 15 , 60 ] NEW_LINE max_range = minBroadcastRange ( a , b ) NEW_LINE print ( max_range ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) NEW_LINE DEDENT print ( getRemainder ( 100 , 7 ) ) NEW_LINE
` ` ` python NEW_LINE def tennis ( ) : NEW_LINE INDENT n , m , z = map ( int , input ( ) . split ( ) ) NEW_LINE res = 0 NEW_LINE for i in range ( m , z + 1 , m ) : NEW_LINE INDENT for j in range ( n , z + 1 , n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT tennis ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . inp = Scanner ( System . in ) NEW_LINE self . doIt ( ) NEW_LINE DEDENT class AOJ0181 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . m = 0 NEW_LINE self . n = 0 NEW_LINE self . books = [ ] NEW_LINE DEDENT def isPossible ( self , width ) : NEW_LINE INDENT w = 0 NEW_LINE cnt = 1 NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT w += self . books [ i ] NEW_LINE if self . books [ i ] > width : NEW_LINE INDENT return False NEW_LINE DEDENT if w > width : NEW_LINE INDENT cnt += 1 NEW_LINE w = self . books [ i ] NEW_LINE DEDENT DEDENT return False if cnt > self . m else True NEW_LINE DEDENT def doIt ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT self . m = int ( input ( ) ) NEW_LINE self . n = int ( input ( ) ) NEW_LINE if self . n + self . m == 0 : NEW_LINE INDENT return NEW_LINE DEDENT self . books = [ int ( input ( ) ) for _ in range ( self . n ) ] NEW_LINE left = 1 NEW_LINE right = 1500000 NEW_LINE while right - left != 1 : NEW_LINE INDENT next = ( left + right ) // 2 NEW_LINE if self . isPossible ( next ) : NEW_LINE INDENT right = next NEW_LINE DEDENT else : NEW_LINE INDENT left = next NEW_LINE DEDENT DEDENT print ( right ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
from queue import PriorityQueue NEW_LINE class Stuff : NEW_LINE INDENT def __init__ ( self , v , w ) : NEW_LINE INDENT self . v = v NEW_LINE self . w = w NEW_LINE self . performance = 1.0 * v / w NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return self . performance > other . performance NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , w = map ( int , input ( ) . split ( ) ) NEW_LINE que = PriorityQueue ( ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT vi , wi = map ( int , input ( ) . split ( ) ) NEW_LINE que . put ( Stuff ( vi , wi ) ) NEW_LINE DEDENT res = 0 NEW_LINE while w > 0 and not que . empty ( ) : NEW_LINE INDENT s = que . get ( ) NEW_LINE if w >= s . w : NEW_LINE INDENT res += s . v NEW_LINE w -= s . w NEW_LINE DEDENT else : NEW_LINE INDENT res += s . performance * w NEW_LINE w = 0 NEW_LINE DEDENT DEDENT print ( format ( res , ' . 2f ' ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE common_bit_mask = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is " , getSingle ( arr , n ) ) NEW_LINE DEDENT DEDENT
from collections import defaultdict NEW_LINE def maxdiff ( arr , n ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) NEW_LINE DEDENT elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 1 , 3 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxdiff ( arr , n ) ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT count = int ( input ( ) ) NEW_LINE for i in range ( count ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = [ 0 ] * ( n * m ) NEW_LINE negative_times = 0 NEW_LINE min_num = float ( ' inf ' ) NEW_LINE sum_num = 0 NEW_LINE for j in range ( len ( arr ) ) : NEW_LINE INDENT arr [ j ] = int ( input ( ) ) NEW_LINE if arr [ j ] < 0 : NEW_LINE INDENT arr [ j ] = 0 - arr [ j ] NEW_LINE negative_times += 1 NEW_LINE sum_num += arr [ j ] NEW_LINE if min_num > arr [ j ] : NEW_LINE INDENT min_num = arr [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT sum_num += arr [ j ] NEW_LINE if min_num > arr [ j ] : NEW_LINE INDENT min_num = arr [ j ] NEW_LINE DEDENT DEDENT DEDENT if negative_times % 2 == 0 : NEW_LINE INDENT print ( sum_num ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum_num - min_num * 2 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class AP : NEW_LINE INDENT @ staticmethod NEW_LINE def makeAP ( arr , n ) : NEW_LINE INDENT initial_term , common_difference = 0 , 0 NEW_LINE if n == 3 : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( arr [ 1 ] - arr [ 0 ] ) == ( arr [ 2 ] - arr [ 1 ] ) : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) // 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( initial_term + ( i * common_difference ) , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE AP . makeAP ( arr , n ) NEW_LINE DEDENT DEDENT AP . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( y + x ) % ( y ^ x ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( y * x ) % ( y + x ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def longestPalindrome ( self , s : str ) -> int : NEW_LINE INDENT count = [ 0 ] * 128 NEW_LINE for c in s : NEW_LINE INDENT count [ ord ( c ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for v in count : NEW_LINE INDENT ans += v // 2 * 2 NEW_LINE if ans % 2 == 0 and v % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = " abccccdd " NEW_LINE out = sObj . longestPalindrome ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT s = Solution ( ) NEW_LINE s . main ( ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if k > n - k : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT @ staticmethod NEW_LINE def catalan ( n ) : NEW_LINE INDENT c = GFG . binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT @ staticmethod NEW_LINE def findWays ( n ) : NEW_LINE INDENT if ( n & 1 ) != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return GFG . catalan ( n // 2 ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT n = 6 NEW_LINE print ( " Total ▁ possible ▁ expressions ▁ of ▁ length " , n , " is " , GFG . findWays ( 6 ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( " ▁ " + input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT res = " " NEW_LINE count = 0 NEW_LINE for q in range ( 1 , 13 ) : NEW_LINE INDENT if s [ i ] [ q ] == ' X ' : NEW_LINE INDENT res = " ▁ 1x12" NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( 2 , 7 ) : NEW_LINE INDENT flag = 0 NEW_LINE if 12 % j == 0 : NEW_LINE INDENT for k in range ( 1 , 12 // j + 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE for p in range ( k , 13 , 12 // j ) : NEW_LINE INDENT if s [ i ] [ p ] == ' O ' : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT count += 1 NEW_LINE res += " ▁ " + str ( j ) + " x " + str ( 12 // j ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT flag = 0 NEW_LINE for l in range ( 1 , 13 ) : NEW_LINE INDENT if s [ i ] [ l ] == ' O ' : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT res += " ▁ 12x1" NEW_LINE count += 1 NEW_LINE DEDENT sys . stdout . write ( str ( count ) + res + " \n " ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class ATwoProblems : NEW_LINE INDENT def solve ( self , points , t , a , b , ta , tb ) : NEW_LINE INDENT for i in range ( t ) : NEW_LINE INDENT for j in range ( t ) : NEW_LINE INDENT if points == a - i * ta + b - j * tb or points == 0 or points == a - ta * i or points == b - tb * j : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT DEDENT class InputReader : NEW_LINE INDENT def __init__ ( self , input_stream ) : NEW_LINE INDENT self . reader = input_stream NEW_LINE self . tokenizer = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . tokenizer is None or not self . tokenizer . hasMoreTokens ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . tokenizer = self . reader . readline ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT raise RuntimeError ( e ) NEW_LINE DEDENT DEDENT return self . tokenizer . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT input_stream = sys . stdin NEW_LINE output_stream = sys . stdout NEW_LINE in_reader = InputReader ( input_stream ) NEW_LINE solver = ATwoProblems ( ) NEW_LINE points = in_reader . nextInt ( ) NEW_LINE t = in_reader . nextInt ( ) NEW_LINE a = in_reader . nextInt ( ) NEW_LINE b = in_reader . nextInt ( ) NEW_LINE ta = in_reader . nextInt ( ) NEW_LINE tb = in_reader . nextInt ( ) NEW_LINE solver . solve ( points , t , a , b , ta , tb ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT n = 10 NEW_LINE if GFG . isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
from collections import deque NEW_LINE def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT s = deque ( ) NEW_LINE if i <= n : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while s : NEW_LINE INDENT tp = s . pop ( ) NEW_LINE for j in range ( tp % 10 , 10 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if x <= n : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( countNumber ( n ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return float ( dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT cost = [ [ 1 , 2 , 3 ] , [ 6 , 5 , 4 ] , [ 7 , 3 , 9 ] ] NEW_LINE print ( maxAverageOfPath ( cost , 3 ) ) NEW_LINE DEDENT DEDENT
MAX = 1000000 NEW_LINE sieve_Prime = [ 0 ] * ( MAX + 4 ) NEW_LINE sieve_count = [ 0 ] * ( MAX + 4 ) NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if sieve_Prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if sieve_Prime [ j ] == 0 : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( " Count ▁ = ▁ " + str ( sieve_count [ n ] + 1 ) ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = ▁ " + str ( sieve_count [ n ] + 1 ) ) NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , k , t , u , v , l = map ( int , input ( ) . split ( ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d . append ( l ) NEW_LINE pos , c , nk = 0 , 0 , 0 NEW_LINE tm = 0 NEW_LINE while pos < l : NEW_LINE INDENT if pos < d [ c ] : NEW_LINE INDENT if nk > 0 : NEW_LINE INDENT nk -= 1 NEW_LINE x = min ( l , pos + t * v ) NEW_LINE tm += ( x - pos ) / v NEW_LINE pos = x NEW_LINE DEDENT else : NEW_LINE INDENT tm += ( d [ c ] - pos ) / u NEW_LINE pos = d [ c ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if d [ c ] == pos : NEW_LINE INDENT x = min ( l , pos + t * v ) NEW_LINE tm += ( x - pos ) / v NEW_LINE pos = x NEW_LINE c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if nk < k : NEW_LINE INDENT c += 1 NEW_LINE nk += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = min ( l , d [ c ] + t * v ) NEW_LINE tm += ( x - pos ) / v NEW_LINE pos = x NEW_LINE c += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( tm ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE prefix = [ 0 ] * n NEW_LINE suffix = [ 0 ] * n NEW_LINE seen = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = prefix [ i - 1 ] if i - 1 >= 0 else 0 NEW_LINE if seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT seen [ i ] = 0 NEW_LINE DEDENT suffix [ n - 1 ] = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] NEW_LINE if seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if prefix [ i ] == suffix [ i ] : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ababa " NEW_LINE print ( waysToSplit ( s ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE class p121 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT TURNS = 15 NEW_LINE ways = [ [ 0 ] * ( i + 1 ) for i in range ( TURNS + 1 ) ] NEW_LINE ways [ 0 ] = [ 1 ] NEW_LINE for i in range ( 1 , TURNS + 1 ) : NEW_LINE INDENT ways [ i ] = [ 0 ] * ( i + 1 ) NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT temp = 0 NEW_LINE if j < i : NEW_LINE INDENT temp = ways [ i - 1 ] [ j ] * i NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT temp += ways [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT ways [ i ] [ j ] = temp NEW_LINE DEDENT DEDENT numer = 0 NEW_LINE for i in range ( TURNS // 2 + 1 , TURNS + 1 ) : NEW_LINE INDENT numer += ways [ TURNS ] [ i ] NEW_LINE DEDENT denom = math . factorial ( TURNS + 1 ) NEW_LINE return str ( denom // numer ) NEW_LINE DEDENT DEDENT print ( p121 ( ) . run ( ) ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE b = [ 0 ] * ( n + 1 ) NEW_LINE num = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT b [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num [ b [ i ] ] += 1 NEW_LINE DEDENT ss = " " NEW_LINE ans = 0 NEW_LINE st = [ False ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT st [ i ] = True NEW_LINE sb = [ ] NEW_LINE x = b [ i ] NEW_LINE sss = [ str ( i ) ] NEW_LINE sb . append ( " ▁ " + " " . join ( reversed ( sss ) ) ) NEW_LINE s = 1 NEW_LINE while not st [ x ] and num [ x ] == 1 and x != 0 and a [ x ] != 1 : NEW_LINE INDENT sss = [ str ( x ) ] NEW_LINE sb . append ( " ▁ " + " " . join ( reversed ( sss ) ) ) NEW_LINE st [ x ] = True NEW_LINE x = b [ x ] NEW_LINE s += 1 NEW_LINE DEDENT if s > ans : NEW_LINE INDENT ans = s NEW_LINE ss = " " . join ( reversed ( sb ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE print ( ss ) NEW_LINE ` ` ` NEW_LINE
arr1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] NEW_LINE arr2 = [ 2 , 3 , 8 , 13 ] NEW_LINE def merge ( m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = m - 2 NEW_LINE last = arr1 [ m - 1 ] NEW_LINE while ( j >= 0 and arr1 [ j ] > arr2 [ i ] ) : NEW_LINE INDENT arr1 [ j + 1 ] = arr1 [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( j != m - 2 or last > arr2 [ i ] ) : NEW_LINE INDENT arr1 [ j + 1 ] = arr2 [ i ] NEW_LINE arr2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT merge ( len ( arr1 ) , len ( arr2 ) ) NEW_LINE print ( " After ▁ Merging ▁ \n First ▁ Array : ▁ " , arr1 ) NEW_LINE print ( " Second ▁ Array : ▁ " , arr2 ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def sameRemainder ( a , b , c ) : NEW_LINE INDENT a1 = b - a NEW_LINE b1 = c - b NEW_LINE c1 = c - a NEW_LINE return gcd ( a1 , gcd ( b1 , c1 ) ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = 62 NEW_LINE b = 132 NEW_LINE c = 237 NEW_LINE print ( sameRemainder ( a , b , c ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE import math NEW_LINE INF = 0x3f3f3f3f NEW_LINE LNF = 0x3f3f3f3f3f3f3f3f NEW_LINE def main ( ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE an = [ a , b , c ] NEW_LINE an . sort ( ) NEW_LINE ans = 0 NEW_LINE if an [ 1 ] - an [ 0 ] < d : NEW_LINE INDENT ans += ( d - an [ 1 ] + an [ 0 ] ) NEW_LINE DEDENT if an [ 2 ] - an [ 1 ] < d : NEW_LINE INDENT ans += ( d - an [ 2 ] + an [ 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT dp = [ [ [ 0 for i in range ( 5 ) ] for j in range ( 5001 ) ] for k in range ( 5001 ) ] NEW_LINE @ staticmethod NEW_LINE def countWaysUtil ( n , parts , nextPart ) : NEW_LINE INDENT if parts == 0 and n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n <= 0 or parts <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if GFG . dp [ n ] [ nextPart ] [ parts ] != - 1 : NEW_LINE INDENT return GFG . dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += GFG . countWaysUtil ( n - i , parts - 1 , i ) NEW_LINE DEDENT GFG . dp [ n ] [ nextPart ] [ parts ] = ans NEW_LINE return GFG . dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT @ staticmethod NEW_LINE def countWays ( n ) : NEW_LINE INDENT for i in range ( 5001 ) : NEW_LINE INDENT for j in range ( 5001 ) : NEW_LINE INDENT for l in range ( 5 ) : NEW_LINE INDENT GFG . dp [ i ] [ j ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT return GFG . countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT n = 8 NEW_LINE print ( GFG . countWays ( n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
def find_k ( a , b ) : NEW_LINE INDENT if ( a + b ) % 2 == 0 : NEW_LINE INDENT return ( a + b ) / 2 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 16 NEW_LINE print ( find_k ( a , b ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT N = 101 NEW_LINE mod = int ( 1e9 + 7 ) NEW_LINE exactsum = [ [ [ 0 for _ in range ( N ) ] for _ in range ( N ) ] for _ in range ( N ) ] NEW_LINE exactnum = [ [ [ 0 for _ in range ( N ) ] for _ in range ( N ) ] for _ in range ( N ) ] NEW_LINE @ staticmethod NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE GFG . exactnum [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT GFG . exactsum [ i ] [ j ] [ k ] += ( GFG . exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * GFG . exactnum [ i - 1 ] [ j ] [ k ] ) % GFG . mod NEW_LINE GFG . exactnum [ i ] [ j ] [ k ] += GFG . exactnum [ i - 1 ] [ j ] [ k ] % GFG . mod NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT GFG . exactsum [ i ] [ j ] [ k ] += ( GFG . exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * GFG . exactnum [ i ] [ j - 1 ] [ k ] ) % GFG . mod NEW_LINE GFG . exactnum [ i ] [ j ] [ k ] += GFG . exactnum [ i ] [ j - 1 ] [ k ] % GFG . mod NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT GFG . exactsum [ i ] [ j ] [ k ] += ( GFG . exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * GFG . exactnum [ i ] [ j ] [ k - 1 ] ) % GFG . mod NEW_LINE GFG . exactnum [ i ] [ j ] [ k ] += GFG . exactnum [ i ] [ j ] [ k - 1 ] % GFG . mod NEW_LINE DEDENT ans += GFG . exactsum [ i ] [ j ] [ k ] % GFG . mod NEW_LINE ans %= GFG . mod NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT x , y , z = 1 , 1 , 1 NEW_LINE print ( GFG . getSum ( x , y , z ) % GFG . mod ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT CHARS = 26 NEW_LINE @ staticmethod NEW_LINE def is_valid_string ( str ) : NEW_LINE INDENT freq = [ 0 ] * GFG . CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT freq1 = 0 NEW_LINE count_freq1 = 0 NEW_LINE for i in range ( GFG . CHARS ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT freq1 = freq [ i ] NEW_LINE count_freq1 = 1 NEW_LINE break NEW_LINE DEDENT DEDENT freq2 = 0 NEW_LINE count_freq2 = 0 NEW_LINE for j in range ( i + 1 , GFG . CHARS ) : NEW_LINE INDENT if freq [ j ] != 0 : NEW_LINE INDENT if freq [ j ] == freq1 : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1 NEW_LINE freq2 = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , GFG . CHARS ) : NEW_LINE INDENT if freq [ k ] != 0 : NEW_LINE INDENT if freq [ k ] == freq1 : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT if freq [ k ] == freq2 : NEW_LINE INDENT count_freq2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if count_freq1 > 1 and count_freq2 > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT str = " abcbc " NEW_LINE if GFG . is_valid_string ( str ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE class Codechef : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT s = input ( ) NEW_LINE ch = list ( s ) NEW_LINE for i in range ( len ( ch ) ) : NEW_LINE INDENT if ( i + 1 ) % 2 != 0 : NEW_LINE INDENT if ch [ i ] != ' a ' : NEW_LINE INDENT ch [ i ] = ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT ch [ i ] = ' b ' NEW_LINE DEDENT DEDENT elif ( i + 1 ) % 2 == 0 : NEW_LINE INDENT if ch [ i ] != ' z ' : NEW_LINE INDENT ch [ i ] = ' z ' NEW_LINE DEDENT else : NEW_LINE INDENT ch [ i ] = ' y ' NEW_LINE DEDENT DEDENT DEDENT s = ' ' . join ( ch ) NEW_LINE print ( s ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT except Exception as e : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT Codechef ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def findMinimumSubsequences ( A , B ) : NEW_LINE INDENT numberOfSubsequences = 1 NEW_LINE sizeOfB = len ( B ) NEW_LINE sizeOfA = len ( A ) NEW_LINE inf = 1000000 NEW_LINE next = [ [ inf for i in range ( sizeOfB ) ] for j in range ( 26 ) ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( sizeOfB ) : NEW_LINE INDENT next [ i ] [ j ] = inf NEW_LINE DEDENT DEDENT for i in range ( sizeOfB ) : NEW_LINE INDENT next [ ord ( B [ i ] ) - ord ( ' a ' ) ] [ i ] = i NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( sizeOfB - 2 , - 1 , - 1 ) : NEW_LINE INDENT if next [ i ] [ j ] == inf : NEW_LINE INDENT next [ i ] [ j ] = next [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT pos = 0 NEW_LINE i = 0 NEW_LINE while i < sizeOfA : NEW_LINE INDENT if pos == 0 and next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] == inf : NEW_LINE INDENT numberOfSubsequences = - 1 NEW_LINE break NEW_LINE DEDENT elif pos < sizeOfB and next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] < inf : NEW_LINE INDENT nextIndex = next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] + 1 NEW_LINE pos = nextIndex NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT numberOfSubsequences += 1 NEW_LINE pos = 0 NEW_LINE DEDENT DEDENT return numberOfSubsequences NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = " aacbe " NEW_LINE B = " aceab " NEW_LINE print ( findMinimumSubsequences ( A , B ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT row , col = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE ansarray = [ 0 ] * ( row * col ) NEW_LINE rowarray = [ 0 , 0 , row - 1 , row - 1 ] NEW_LINE colarray = [ 0 , col - 1 , 0 , col - 1 ] NEW_LINE p = 0 NEW_LINE for j in range ( row ) : NEW_LINE INDENT for k in range ( col ) : NEW_LINE INDENT dis = 0 NEW_LINE for l in range ( 4 ) : NEW_LINE INDENT dis = max ( dis , abs ( rowarray [ l ] - j ) + abs ( colarray [ l ] - k ) ) NEW_LINE DEDENT ansarray [ p ] = dis NEW_LINE p += 1 NEW_LINE DEDENT DEDENT ansarray . sort ( ) NEW_LINE for j in range ( len ( ansarray ) ) : NEW_LINE INDENT ans . append ( str ( ansarray [ j ] ) ) NEW_LINE DEDENT print ( ' ▁ ' . join ( ans ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java . util . * ; NEW_LINE class GFG : NEW_LINE INDENT def FindRank ( arr , length ) : NEW_LINE INDENT print ( "1 ▁ " , end = " " ) NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT rank = 1 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT rank += 1 NEW_LINE DEDENT DEDENT print ( rank , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 88 , 14 , 69 , 30 , 29 , 89 ] NEW_LINE len = len ( arr ) NEW_LINE GFG . FindRank ( arr , len ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( reverse = True ) NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT h -= b [ i - 1 ] NEW_LINE DEDENT cnt = 0 NEW_LINE if h > 0 : NEW_LINE INDENT cnt = ( h + a [ - 1 ] - 1 ) // a [ - 1 ] NEW_LINE DEDENT ans = min ( ans , cnt + i ) NEW_LINE DEDENT print ( ans ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class Digits : NEW_LINE INDENT @ staticmethod NEW_LINE def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while int ( product / ( 10 ** k ) ) != 0 : NEW_LINE INDENT product = product / 10 NEW_LINE DEDENT return product NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( Digits . firstkdigits ( n , k ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT try : NEW_LINE INDENT m , n = map ( int , line . split ( ) ) NEW_LINE if m < n : NEW_LINE INDENT m , n = n , m NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT t = n NEW_LINE n = m % n NEW_LINE m = t NEW_LINE DEDENT print ( m ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = [ 0 ] * 26 NEW_LINE sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT a [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT sum += a [ i ] % 2 NEW_LINE DEDENT print ( sum // 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def complement ( num ) : NEW_LINE INDENT i = 0 NEW_LINE len = 0 NEW_LINE temp = 0 NEW_LINE comp = 0 NEW_LINE temp = num NEW_LINE while True : NEW_LINE INDENT len += 1 NEW_LINE num = num // 10 NEW_LINE if abs ( num ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT num = temp NEW_LINE comp = 10 ** len - num NEW_LINE return comp NEW_LINE DEDENT print ( complement ( 25 ) ) NEW_LINE print ( complement ( 456 ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return bin ( x ^ n ) . count ( '1' ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def minOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE freq = [ 0 ] * 1000001 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x ] += 1 NEW_LINE DEDENT maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . minOperations ( arr , n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 , 0 ] for _ in range ( N + 1 ) ] NEW_LINE if X == 1 : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if X == 1 : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE class GFG : NEW_LINE INDENT def getMinNum ( self , a , b , c ) : NEW_LINE INDENT if c < a or c > b : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE c = 4 NEW_LINE g = GFG ( ) NEW_LINE print ( g . getMinNum ( a , b , c ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE x = 0 NEW_LINE max_val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' I ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT max_val = max ( max_val , x ) NEW_LINE DEDENT print ( max_val ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class State : NEW_LINE INDENT def __init__ ( self , d , p ) : NEW_LINE INDENT self . d = d NEW_LINE self . p = p NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return self . p > other . p NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT while True : NEW_LINE INDENT ans = 0 NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE states = [ ] NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for _ in range ( n ) : NEW_LINE INDENT d , p = map ( int , input ( ) . split ( ) ) NEW_LINE states . append ( State ( d , p ) ) NEW_LINE DEDENT states . sort ( ) NEW_LINE for st in states : NEW_LINE INDENT m -= st . d NEW_LINE if m <= 0 : NEW_LINE INDENT ans -= m * st . p NEW_LINE break NEW_LINE DEDENT DEDENT for st in states : NEW_LINE INDENT ans += st . d * st . p NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import queue NEW_LINE n = int ( input ( ) ) NEW_LINE front = [ ] NEW_LINE back = [ ] NEW_LINE arr = [ ] NEW_LINE frontSum = 0 NEW_LINE backSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE frontSum += x NEW_LINE front . append ( x ) NEW_LINE DEDENT arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE backSum += x NEW_LINE back . append ( - x ) NEW_LINE DEDENT values = [ 0 ] * ( n + 1 ) NEW_LINE values [ 0 ] = frontSum NEW_LINE values [ n ] = - backSum NEW_LINE for i in range ( n ) : NEW_LINE INDENT frontSum += arr [ i ] NEW_LINE front . append ( arr [ i ] ) NEW_LINE frontSum -= front . pop ( 0 ) NEW_LINE values [ i + 1 ] += frontSum NEW_LINE backSum += arr [ n - i - 1 ] NEW_LINE back . append ( - arr [ n - i - 1 ] ) NEW_LINE backSum += back . pop ( 0 ) NEW_LINE values [ n - i - 1 ] -= backSum NEW_LINE DEDENT max_val = float ( ' - inf ' ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT max_val = max ( max_val , values [ i ] ) NEW_LINE DEDENT print ( max_val ) NEW_LINE
class GFG : NEW_LINE INDENT arr = [ 1 , 5 , 6 ] NEW_LINE @ staticmethod NEW_LINE def countWays ( N ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( len ( GFG . arr ) ) : NEW_LINE INDENT if i >= GFG . arr [ j ] : NEW_LINE INDENT count [ i ] += count [ i - GFG . arr [ j ] ] NEW_LINE DEDENT DEDENT DEDENT return count [ N ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT N = 7 NEW_LINE print ( " Total ▁ number ▁ of ▁ ways ▁ = ▁ " , self . countWays ( N ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def numberOfWays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def countFreq ( a , n ) : NEW_LINE INDENT hm = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] += 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if hm [ a [ i ] ] != 0 : NEW_LINE INDENT print ( str ( a [ i ] ) + " - > " + str ( cumul ) ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT a = [ 1 , 3 , 2 , 4 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE GFG . countFreq ( a , n ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False NEW_LINE possibleA , possibleB , possibleC = 0 , 0 , 0 NEW_LINE numbersInRange = R - L + 1 NEW_LINE if numbersInRange < 3 : NEW_LINE INDENT flag = False NEW_LINE DEDENT elif numbersInRange > 3 : NEW_LINE INDENT flag = True NEW_LINE if L % 2 > 0 : NEW_LINE INDENT L += 1 NEW_LINE DEDENT possibleA = L NEW_LINE possibleB = L + 1 NEW_LINE possibleC = L + 2 NEW_LINE DEDENT else : NEW_LINE INDENT if not ( L % 2 > 0 ) : NEW_LINE INDENT flag = True NEW_LINE possibleA = L NEW_LINE possibleB = L + 1 NEW_LINE possibleC = L + 2 NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( " ( " + str ( possibleA ) + " , ▁ " + str ( possibleB ) + " , ▁ " + str ( possibleC ) + " ) " + " ▁ is ▁ one ▁ such ▁ possible " + " ▁ triplet ▁ between ▁ " + str ( L ) + " ▁ and ▁ " + str ( R ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Such ▁ Triplet " + " ▁ exists ▁ between ▁ " + str ( L ) + " ▁ and ▁ " + str ( R ) ) NEW_LINE DEDENT DEDENT L , R = 2 , 10 NEW_LINE possibleTripletInRange ( L , R ) NEW_LINE L , R = 23 , 46 NEW_LINE possibleTripletInRange ( L , R ) NEW_LINE
class GFG : NEW_LINE INDENT alphabets = list ( " abcdefghijklmnopqrstuvwxyz " ) NEW_LINE @ staticmethod NEW_LINE def conversion ( charSet , str1 ) : NEW_LINE INDENT s2 = " " NEW_LINE for i in str1 : NEW_LINE INDENT s2 += GFG . alphabets [ charSet . index ( i ) ] NEW_LINE DEDENT return s2 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT charSet = " qwertyuiopasdfghjklzxcvbnm " NEW_LINE str1 = " egrt " NEW_LINE print ( GFG . conversion ( charSet , list ( str1 ) ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
import itertools NEW_LINE class GFG : NEW_LINE INDENT set = set ( ) NEW_LINE @ staticmethod NEW_LINE def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if count == k : NEW_LINE INDENT GFG . set . add ( num ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT GFG . generateNumber ( count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT GFG . generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( " The " , len ( GFG . set ) , " distinct ▁ integers ▁ are : " , * GFG . set ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 3 , 8 , 17 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE GFG . printDistinctIntegers ( k , arr , n ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
class GFG : NEW_LINE INDENT def product ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while x > 0 : NEW_LINE INDENT prod *= ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT def findNumber ( l , r ) : NEW_LINE INDENT b = str ( r ) NEW_LINE ans = r NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if b [ i ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT curr = list ( b ) NEW_LINE curr [ i ] = chr ( ( ( ord ( curr [ i ] ) - ord ( '0' ) - 1 ) + ord ( '0' ) ) ) NEW_LINE for j in range ( i + 1 , len ( curr ) ) : NEW_LINE INDENT curr [ j ] = '9' NEW_LINE DEDENT num = 0 NEW_LINE for j in range ( len ( curr ) ) : NEW_LINE INDENT num = num * 10 + ( int ( curr [ j ] ) - int ( '0' ) ) NEW_LINE DEDENT if num >= l and GFG . product ( ans ) < GFG . product ( num ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT l , r = 1 , 10 NEW_LINE print ( GFG . findNumber ( l , r ) ) NEW_LINE l , r = 51 , 62 NEW_LINE print ( GFG . findNumber ( l , r ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT MAX = 100005 NEW_LINE isPrime = [ False ] * MAX NEW_LINE @ staticmethod NEW_LINE def sieveOfEratostheneses ( ) : NEW_LINE INDENT GFG . isPrime [ 1 ] = True NEW_LINE for i in range ( 2 , int ( GFG . MAX ** 0.5 ) ) : NEW_LINE INDENT if not GFG . isPrime [ i ] : NEW_LINE INDENT for j in range ( 2 * i , GFG . MAX , i ) : NEW_LINE INDENT GFG . isPrime [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while num > 0 : NEW_LINE INDENT if not GFG . isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT @ staticmethod NEW_LINE def minNumber ( arr , n ) : NEW_LINE INDENT GFG . sieveOfEratostheneses ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if not GFG . isPrime [ sum ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = GFG . findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . minNumber ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
class GFG : NEW_LINE INDENT MAX = 25 NEW_LINE @ staticmethod NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * GFG . MAX NEW_LINE max_bit = 0 NEW_LINE sum = 0 NEW_LINE ans = 0 NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] NEW_LINE f = 0 NEW_LINE while e > 0 : NEW_LINE INDENT rem = e % 2 NEW_LINE e = e // 2 NEW_LINE if rem == 1 : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = 2 ** d NEW_LINE if bits_count [ d ] > n // 2 : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans NEW_LINE sum = sum + arr [ d ] NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 3 , 5 , 7 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . getMinSum ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE
import sys NEW_LINE class _70B : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . inp = sys . stdin NEW_LINE self . out = sys . stdout NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT n , c , q = self . next_int ( ) , 0 , 0 NEW_LINE s = self . next_token ( ) NEW_LINE i , l , p = 0 , len ( s ) , 0 NEW_LINE while i < l : NEW_LINE INDENT h = s [ i ] NEW_LINE p += 1 NEW_LINE if h == ' . ' or h == ' ! ' or h == ' ? ' : NEW_LINE INDENT if p > n : NEW_LINE INDENT return " Impossible " NEW_LINE DEDENT if q == 0 : NEW_LINE INDENT q = p NEW_LINE DEDENT elif q + 1 + p <= n : NEW_LINE INDENT q += 1 + p NEW_LINE DEDENT else : NEW_LINE INDENT q = p NEW_LINE c += 1 NEW_LINE DEDENT p = 0 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if q > 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT out = self . out NEW_LINE out . write ( str ( self . solve ( ) ) ) NEW_LINE self . inp . close ( ) NEW_LINE DEDENT except : NEW_LINE INDENT sys . exit ( 0 ) NEW_LINE DEDENT DEDENT def next_token ( self ) : NEW_LINE INDENT return self . inp . readline ( ) . strip ( ) NEW_LINE DEDENT def next_int ( self ) : NEW_LINE INDENT return int ( self . next_token ( ) ) NEW_LINE DEDENT DEDENT _70B ( ) . run ( ) NEW_LINE
import sys NEW_LINE from collections import deque NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE a = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE g = [ [ ] for _ in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] != i : NEW_LINE INDENT g [ i ] . append ( a [ i ] ) NEW_LINE DEDENT g [ i ] . append ( i + 1 ) NEW_LINE g [ i + 1 ] . append ( i ) NEW_LINE DEDENT if a [ n - 1 ] != n - 1 : NEW_LINE INDENT g [ n - 1 ] . append ( a [ n - 1 ] ) NEW_LINE DEDENT dist = [ - 1 ] * n NEW_LINE dist [ 0 ] = 0 NEW_LINE q = deque ( [ 0 ] ) NEW_LINE while q : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE for v in g [ u ] : NEW_LINE INDENT if dist [ v ] == - 1 : NEW_LINE INDENT q . append ( v ) NEW_LINE dist [ v ] = dist [ u ] + 1 NEW_LINE DEDENT DEDENT DEDENT print ( * dist ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE class StrangeBirthDay : NEW_LINE INDENT def help_birth_day_boy ( self , n , m ) : NEW_LINE INDENT n . sort ( ) NEW_LINE ans = 0 NEW_LINE j = 0 NEW_LINE for i in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT k = n [ i ] NEW_LINE if k < len ( m ) : NEW_LINE INDENT if m [ k ] > m [ j ] : NEW_LINE INDENT ans += m [ j ] NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += m [ k ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT test = int ( input ( ) ) NEW_LINE strange = StrangeBirthDay ( ) NEW_LINE for _ in range ( test ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = [ int ( input ( ) ) - 1 for _ in range ( n ) ] NEW_LINE marr = [ int ( input ( ) ) for _ in range ( m ) ] NEW_LINE strange . help_birth_day_boy ( arr , marr ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def findMaximumNum ( arr , n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i <= arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count >= i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . findMaximumNum ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT sb = sys . stdin . readline ( ) . strip ( ) NEW_LINE n = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT split_command = sys . stdin . readline ( ) . strip ( ) . split ( " ▁ " ) NEW_LINE a = int ( split_command [ 1 ] ) NEW_LINE b = int ( split_command [ 2 ] ) NEW_LINE if split_command [ 0 ] . startswith ( " p " ) : NEW_LINE INDENT print ( sb [ a : b + 1 ] ) NEW_LINE DEDENT elif split_command [ 0 ] . startswith ( " rev " ) : NEW_LINE INDENT temp = sb [ a : b + 1 ] NEW_LINE sb = sb [ : a ] + temp [ : : - 1 ] + sb [ b + 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT p = split_command [ 3 ] NEW_LINE sb = sb [ : a ] + p + sb [ b + 1 : ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def solve ( A , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2000 ) ] for j in range ( 2000 ) ] NEW_LINE flag = 1 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT for i in range ( - sum , sum + 1 ) : NEW_LINE INDENT try : NEW_LINE INDENT dp [ 0 ] [ i ] = float ( ' inf ' ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE INDENT try : NEW_LINE INDENT dp [ flag ] [ j ] = float ( ' inf ' ) NEW_LINE if j - A [ i - 1 ] <= sum and j - A [ i - 1 ] >= - sum : NEW_LINE INDENT dp [ flag ] [ j ] = dp [ flag ^ 1 ] [ j - A [ i - 1 ] ] NEW_LINE DEDENT if j + A [ i - 1 ] <= sum and j + A [ i - 1 ] >= - sum and dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] != float ( ' inf ' ) : NEW_LINE INDENT dp [ flag ] [ j ] = min ( dp [ flag ] [ j ] , dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] + 1 ) NEW_LINE DEDENT DEDENT except Exception as e : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT flag = flag ^ 1 NEW_LINE DEDENT for i in range ( sum + 1 ) : NEW_LINE INDENT if dp [ flag ^ 1 ] [ i ] != float ( ' inf ' ) : NEW_LINE INDENT return dp [ flag ^ 1 ] [ i ] NEW_LINE DEDENT DEDENT return n - 1 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( solve ( arr , n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE eps = 1e-10 NEW_LINE for line in sys . stdin : NEW_LINE INDENT values = list ( map ( float , line . split ( ) ) ) NEW_LINE x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = values NEW_LINE vax , vay = x2 - x1 , y2 - y1 NEW_LINE vbx , vby = x4 - x3 , y4 - y3 NEW_LINE if abs ( vax * vbx + vay * vby ) < eps : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import java . util . Scanner NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . inp = Scanner ( System . in ) NEW_LINE self . doIt ( ) NEW_LINE DEDENT def doIt ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT m = self . inp . nextInt ( ) NEW_LINE n = self . inp . nextInt ( ) NEW_LINE if m + n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT person = [ False ] * m NEW_LINE user = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT input_val = self . inp . next ( ) NEW_LINE talk = self . getTalk ( i ) NEW_LINE if input_val != talk and m - cnt > 1 : NEW_LINE INDENT person [ user ] = True NEW_LINE cnt += 1 NEW_LINE DEDENT user = self . getUser ( user ) NEW_LINE DEDENT i = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if not person [ i ] : NEW_LINE INDENT print ( i + 1 , end = ' ▁ ' ) NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , m ) : NEW_LINE INDENT if not person [ j ] : NEW_LINE INDENT print ( j + 1 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT def getTalk ( self , num ) : NEW_LINE INDENT return " FizzBuzz " if num % 15 == 0 else " Fizz " if num % 3 == 0 else " Buzz " if num % 5 == 0 else str ( num ) NEW_LINE DEDENT def getUser ( self , currentUser ) : NEW_LINE INDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if not person [ ( currentUser + i ) % m ] : NEW_LINE INDENT return ( currentUser + i ) % m NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT Main ( ) NEW_LINE
l = [ [ 0 ] * 1001 for _ in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE array = [ 0 ] * 101 NEW_LINE for i in range ( a , b ) : NEW_LINE INDENT array [ i ] += 1 NEW_LINE DEDENT for i in range ( c , d ) : NEW_LINE INDENT array [ i ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 101 ) : NEW_LINE INDENT if array [ i ] == 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if b [ i ] != 0 : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = int ( a [ i ] / mul ) NEW_LINE print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE DEDENT
import sys NEW_LINE def quickSort ( a , d , c ) : NEW_LINE INDENT i = d NEW_LINE j = c NEW_LINE mid = a [ ( d + c ) // 2 ] NEW_LINE while i <= j : NEW_LINE INDENT while a [ i ] < mid : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while a [ j ] > mid : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if i <= j : NEW_LINE INDENT tg = a [ i ] NEW_LINE a [ i ] = a [ j ] NEW_LINE a [ j ] = tg NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT if d < j : NEW_LINE INDENT quickSort ( a , d , j ) NEW_LINE DEDENT if i < c : NEW_LINE INDENT quickSort ( a , i , c ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ 0 ] * ( n + 5 ) NEW_LINE b = [ 0 ] * ( n + 5 ) NEW_LINE c = [ 0 ] * ( n + 5 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT b [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT c [ i ] = int ( input ( ) ) NEW_LINE DEDENT quickSort ( a , 1 , n ) NEW_LINE quickSort ( b , 1 , n - 1 ) NEW_LINE quickSort ( c , 1 , n - 2 ) NEW_LINE resA = a [ n ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] != b [ i ] : NEW_LINE INDENT resA = a [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( resA ) NEW_LINE resB = b [ n - 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if b [ i ] != c [ i ] : NEW_LINE INDENT resB = b [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( resB ) NEW_LINE DEDENT
import sys NEW_LINE T = int ( input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE c = list ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if c [ i ] == ' > ' or c [ n - 1 - i ] == ' < ' : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE from java . util import Scanner NEW_LINE class codforce : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT str = Scanner ( System . in ) NEW_LINE n = str . nextInt ( ) NEW_LINE s = " " NEW_LINE while n > 0 : NEW_LINE INDENT x = n % 2 NEW_LINE n //= 2 NEW_LINE s += str ( x ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT VP = int ( input ( ) ) NEW_LINE VD = int ( input ( ) ) NEW_LINE T = int ( input ( ) ) NEW_LINE F = int ( input ( ) ) NEW_LINE C = int ( input ( ) ) NEW_LINE if VD <= VP : NEW_LINE INDENT print ( "0" ) NEW_LINE return NEW_LINE DEDENT answer = 0 NEW_LINE start = T NEW_LINE while True : NEW_LINE INDENT x = start * VP / ( VD - VP ) NEW_LINE if ( start + x ) * VP >= C : NEW_LINE INDENT break NEW_LINE DEDENT start += 2 * x + F NEW_LINE answer += 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
from datetime import datetime NEW_LINE s = input ( ) . split ( " : " ) NEW_LINE t = input ( ) . split ( " : " ) NEW_LINE x = datetime . strptime ( s [ 0 ] + " : " + s [ 1 ] , " % H : % M " ) . time ( ) NEW_LINE y = datetime . strptime ( t [ 0 ] + " : " + t [ 1 ] , " % H : % M " ) . time ( ) NEW_LINE diff = datetime . combine ( datetime . min , x ) - datetime . combine ( datetime . min , y ) NEW_LINE print ( diff ) NEW_LINE
class GFG : NEW_LINE INDENT def longestAlternatingSubarray ( a , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] * a [ i - 1 ] < 0 : NEW_LINE INDENT cnt += 1 NEW_LINE longest = max ( longest , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT return longest NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = [ - 5 , - 1 , - 1 , 2 , - 2 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestAlternatingSubarray ( a , n ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def checkTypeOfTriangle ( a , b , c ) : NEW_LINE INDENT sqa = a ** 2 NEW_LINE sqb = b ** 2 NEW_LINE sqc = c ** 2 NEW_LINE if sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb : NEW_LINE INDENT print ( " Right - angled ▁ Triangle " ) NEW_LINE DEDENT elif sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb : NEW_LINE INDENT print ( " Obtuse - angled ▁ Triangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Acute - angled ▁ Triangle " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT a , b , c = 2 , 2 , 2 NEW_LINE checkTypeOfTriangle ( a , b , c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT max = 100 NEW_LINE @ staticmethod NEW_LINE def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' G ' : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE DEDENT elif s [ i ] == ' F ' : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT s = " GFGFG " NEW_LINE n = len ( s ) NEW_LINE self . countSubsequence ( s , n ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE MAX = 100 NEW_LINE def check ( n , x , y , h , cx , cy ) : NEW_LINE INDENT ch = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if h [ i ] > 0 : NEW_LINE INDENT ch = abs ( x [ i ] - cx ) + abs ( y [ i ] - cy ) + h [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if h [ i ] != max ( ch - abs ( x [ i ] - cx ) - abs ( y [ i ] - cy ) , 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return ch NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x = [ 0 ] * n NEW_LINE y = [ 0 ] * n NEW_LINE h = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT x [ i ] = int ( input ( ) ) NEW_LINE y [ i ] = int ( input ( ) ) NEW_LINE h [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT for j in range ( MAX + 1 ) : NEW_LINE INDENT ch = check ( n , x , y , h , i , j ) NEW_LINE if ch > 0 : NEW_LINE INDENT print ( i , j , ch ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ` ` ` NEW_LINE
def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while n > 0 : NEW_LINE INDENT largest = int ( n ** ( 1 / 3 ) ) NEW_LINE n -= ( largest * largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 150 NEW_LINE print ( countSteps ( n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT class AOJ_0138 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . num = 0 NEW_LINE self . time = 0.0 NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return self . time < other . time NEW_LINE DEDENT DEDENT def doIt ( self ) : NEW_LINE INDENT m = 0 NEW_LINE data = [ self . AOJ_0138 ( ) for _ in range ( 8 ) ] NEW_LINE sub = [ self . AOJ_0138 ( ) for _ in range ( 18 ) ] NEW_LINE for _ in range ( 3 ) : NEW_LINE INDENT for k in range ( 8 ) : NEW_LINE INDENT data [ k ] . num = int ( input ( ) ) NEW_LINE data [ k ] . time = float ( input ( ) ) NEW_LINE DEDENT data . sort ( ) NEW_LINE print ( f " { data [ 0 ] . num } ▁ { data [ 0 ] . time : .2f } " ) NEW_LINE print ( f " { data [ 1 ] . num } ▁ { data [ 1 ] . time : .2f } " ) NEW_LINE for k in range ( 2 , 8 ) : NEW_LINE INDENT sub [ m ] = data [ k ] NEW_LINE m += 1 NEW_LINE DEDENT DEDENT sub . sort ( ) NEW_LINE print ( f " { sub [ 0 ] . num } ▁ { sub [ 0 ] . time : .2f } " ) NEW_LINE print ( f " { sub [ 1 ] . num } ▁ { sub [ 1 ] . time : .2f } " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . doIt ( ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mx = float ( ' - inf ' ) NEW_LINE mn = float ( ' inf ' ) NEW_LINE mxCount = 0 NEW_LINE mnCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( arr [ i ] , mx ) NEW_LINE mn = min ( arr [ i ] , mn ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == mx : NEW_LINE INDENT mxCount += 1 NEW_LINE DEDENT if arr [ i ] == mn : NEW_LINE INDENT mnCount += 1 NEW_LINE DEDENT DEDENT if mx != mn : NEW_LINE INDENT print ( mx - mn , mxCount * mnCount ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( mx - mn , mxCount * ( mxCount - 1 ) // 2 ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def find_count ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bin ( i ) . count ( '1' ) NEW_LINE if i % x == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( " YES " if check ( A ) else " NO " ) NEW_LINE DEDENT def check ( A ) : NEW_LINE INDENT N = len ( A ) NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT if sum % ( ( N * ( N + 1 ) ) / 2 ) != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT op = int ( sum / ( ( N * ( N + 1 ) ) / 2 ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT diff = A [ ( i + 1 ) % N ] - A [ i ] NEW_LINE if diff > op : NEW_LINE INDENT return False NEW_LINE DEDENT if ( op - diff ) % N != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def maxProd ( N ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if N < 10 : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( GFG . maxProd ( N // 10 ) * ( N % 10 ) , GFG . maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 390 NEW_LINE print ( GFG . maxProd ( N ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE n = int ( input ( ) ) NEW_LINE sugoroku = " " NEW_LINE def solveSugoroku ( ) : NEW_LINE INDENT global sugoroku NEW_LINE dice = 0 NEW_LINE safes = sugoroku . split ( "0" ) NEW_LINE for safe in safes : NEW_LINE INDENT dice = max ( dice , len ( safe ) ) NEW_LINE DEDENT print ( dice + 1 ) NEW_LINE DEDENT def inputSugoroku ( ) : NEW_LINE INDENT global sugoroku NEW_LINE sugoroku = " " . join ( input ( ) . split ( ) ) NEW_LINE DEDENT inputSugoroku ( ) NEW_LINE solveSugoroku ( ) NEW_LINE ` ` ` NEW_LINE
import array NEW_LINE import numpy as np NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x = np . zeros ( n , dtype = int ) NEW_LINE y = np . zeros ( n , dtype = int ) NEW_LINE t1 , t2 = 0 , 0 NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT x1 , y1 = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 == 0 : NEW_LINE INDENT y [ t2 ] = y1 * y1 NEW_LINE t2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x [ t1 ] = x1 * x1 NEW_LINE t1 += 1 NEW_LINE DEDENT DEDENT x . sort ( ) NEW_LINE y . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum += np . sqrt ( x [ i ] + y [ i ] ) NEW_LINE DEDENT print ( sum ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count //= i NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( GFG . countNonDecreasing ( n ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import java NEW_LINE def reduceString ( s , l ) : NEW_LINE INDENT count = 1 NEW_LINE steps = 0 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT steps += count // 2 NEW_LINE count = 1 NEW_LINE DEDENT DEDENT steps += count // 2 NEW_LINE return steps NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE l = len ( s ) NEW_LINE print ( reduceString ( s , l ) ) NEW_LINE
import sys NEW_LINE a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE def getHonest ( ) : NEW_LINE INDENT dis = b + 1 NEW_LINE lst = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not lst : NEW_LINE INDENT lst . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT if q ( lst [ - 1 ] , i ) : NEW_LINE INDENT lst . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT lst . pop ( ) NEW_LINE dis -= 1 NEW_LINE DEDENT DEDENT if len ( lst ) >= dis : NEW_LINE INDENT return lst . pop ( ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def q ( a , b ) : NEW_LINE INDENT print ( " ? ▁ " + str ( a ) + " ▁ " + str ( b ) ) NEW_LINE return input ( ) == " Y " NEW_LINE DEDENT if b >= a : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = " " NEW_LINE honest = getHonest ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += '1' if q ( honest , i ) else '0' NEW_LINE DEDENT print ( " ! ▁ " + ans ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT x , y , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE res = [ ] NEW_LINE for i in range ( a , x + 1 ) : NEW_LINE INDENT for j in range ( b , y + 1 ) : NEW_LINE INDENT if i <= j : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( str ( i ) + " ▁ " + str ( j ) ) NEW_LINE DEDENT DEDENT print ( len ( res ) ) NEW_LINE for s in res : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
mod = 1000000007 NEW_LINE def mult ( a , b ) : NEW_LINE INDENT return ( ( a % mod ) * ( b % mod ) ) % mod NEW_LINE DEDENT def calculate_factors ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE cnt = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT if cnt % 2 == 1 : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT i = 3 NEW_LINE while i <= int ( n ** 0.5 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // i NEW_LINE DEDENT if cnt % 2 == 1 : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT i += 2 NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT ans = mult ( ans , 2 ) NEW_LINE DEDENT return ans % mod NEW_LINE DEDENT n = 193748576239475639 NEW_LINE mod = 17 NEW_LINE print ( calculate_factors ( n ) ) NEW_LINE
` ` ` python NEW_LINE s = input ( ) NEW_LINE str = " " NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if s [ i ] == ' . ' : NEW_LINE INDENT str += '0' NEW_LINE DEDENT else : NEW_LINE INDENT if s [ i ] == ' - ' and s [ i + 1 ] == ' . ' : NEW_LINE INDENT str += '1' NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT str += '2' NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( str ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 2 , 1 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxAbsDiff ( arr , n ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT a , b , c , N = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT sys . exit ( 0 ) NEW_LINE DEDENT checking = [ 0 ] * ( a + b + c ) NEW_LINE temp = [ ] NEW_LINE for _ in range ( 2 ) : NEW_LINE INDENT for _ in range ( N ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT a1 , b1 , c1 , check = map ( int , input ( ) . split ( ) ) NEW_LINE if check == 1 : NEW_LINE INDENT checking [ a1 - 1 ] = 1 NEW_LINE checking [ b1 - 1 ] = 1 NEW_LINE checking [ c1 - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp . extend ( [ a1 , b1 , c1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if not temp : NEW_LINE INDENT break NEW_LINE DEDENT a2 = temp . pop ( ) NEW_LINE b2 = temp . pop ( ) NEW_LINE c2 = temp . pop ( ) NEW_LINE if checking [ a2 - 1 ] + checking [ b2 - 1 ] + checking [ c2 - 1 ] == 2 : NEW_LINE INDENT if checking [ a2 - 1 ] != 1 : NEW_LINE INDENT checking [ a2 - 1 ] = 3 NEW_LINE DEDENT elif checking [ b2 - 1 ] != 1 : NEW_LINE INDENT checking [ b2 - 1 ] = 3 NEW_LINE DEDENT else : NEW_LINE INDENT checking [ c2 - 1 ] = 3 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for contents in checking : NEW_LINE INDENT if contents == 3 : NEW_LINE INDENT result = 0 NEW_LINE DEDENT elif contents == 0 : NEW_LINE INDENT result = 2 NEW_LINE DEDENT else : NEW_LINE INDENT result = 1 NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def minRemove ( a , b , n , m ) : NEW_LINE INDENT countA = defaultdict ( int ) NEW_LINE countB = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT countA [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT countB [ b [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in countA : NEW_LINE INDENT if x in countB : NEW_LINE INDENT res += min ( countB [ x ] , countA [ x ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE b = [ 2 , 3 , 4 , 5 , 8 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( minRemove ( a , b , n , m ) ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT M = 20 NEW_LINE dp = [ [ [ [ - 1 for _ in range ( 2 ) ] for _ in range ( M ) ] for _ in range ( M ) ] for _ in range ( M ) ] NEW_LINE @ staticmethod NEW_LINE def count ( pos , firstD , lastD , tight , num ) : NEW_LINE INDENT if pos == len ( num ) : NEW_LINE INDENT if firstD == lastD : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if GFG . dp [ pos ] [ firstD ] [ lastD ] [ tight ] != - 1 : NEW_LINE INDENT return GFG . dp [ pos ] [ firstD ] [ lastD ] [ tight ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = 9 if tight == 1 else num [ pos ] NEW_LINE for dig in range ( limit + 1 ) : NEW_LINE INDENT currFirst = firstD NEW_LINE if pos == 0 : NEW_LINE INDENT currFirst = dig NEW_LINE DEDENT if currFirst == 0 and dig != 0 : NEW_LINE INDENT currFirst = dig NEW_LINE DEDENT currTight = tight NEW_LINE if dig < num [ pos ] : NEW_LINE INDENT currTight = 1 NEW_LINE DEDENT ans += GFG . count ( pos + 1 , currFirst , dig , currTight , num ) NEW_LINE DEDENT GFG . dp [ pos ] [ firstD ] [ lastD ] [ tight ] = ans NEW_LINE return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def solve ( x ) : NEW_LINE INDENT num = [ ] NEW_LINE while x > 0 : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE for i in range ( GFG . M ) : NEW_LINE INDENT for j in range ( GFG . M ) : NEW_LINE INDENT for k in range ( GFG . M ) : NEW_LINE INDENT for l in range ( 2 ) : NEW_LINE INDENT GFG . dp [ i ] [ j ] [ k ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return GFG . count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT L , R = 2 , 60 NEW_LINE print ( GFG . solve ( R ) - GFG . solve ( L - 1 ) ) NEW_LINE L , R = 1 , 1000 NEW_LINE print ( GFG . solve ( R ) - GFG . solve ( L - 1 ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE old = - 1 NEW_LINE ans = 0 NEW_LINE for i in range ( num ) : NEW_LINE INDENT s = int ( input ( ) ) NEW_LINE if s == 1 : NEW_LINE INDENT if old >= 0 : NEW_LINE INDENT ans *= ( i - old ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT old = i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def bit ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while x > 0 : NEW_LINE INDENT x //= 2 NEW_LINE ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def check ( d , x ) : NEW_LINE INDENT if bit ( x // d ) <= bit ( d ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def bs ( n ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( math . sqrt ( n ) ) NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if check ( m , n ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if not check ( l , n ) : NEW_LINE INDENT return l + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return l NEW_LINE DEDENT DEDENT def countDivisor ( n ) : NEW_LINE INDENT return n - bs ( n ) + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( countDivisor ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ sys . maxsize ] * n NEW_LINE s1 = " " NEW_LINE s2 = " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : ] NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if s1 == s2 : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaaaaaaa " NEW_LINE n = len ( s ) NEW_LINE print ( minimalSteps ( s , n ) // 2 ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def checkUtil ( num , dig , base ) : NEW_LINE INDENT if dig == 1 and num < base : NEW_LINE INDENT return True NEW_LINE DEDENT if dig > 1 and num >= base : NEW_LINE INDENT return checkUtil ( num // base , dig - 1 , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 33 ) : NEW_LINE INDENT if checkUtil ( num , dig , base ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT num = 8 NEW_LINE dig = 3 NEW_LINE if check ( num , dig ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
class GFG : NEW_LINE INDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while i <= j : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while i <= j : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT tmpArr = [ 0 ] * n NEW_LINE tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT tmpArr [ i ] = abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) NEW_LINE DEDENT tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) NEW_LINE GFG . printArray ( tmpArr , n ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE GFG . generateArr ( arr , n ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = input ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' B ' : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT DEDENT ans = sum NEW_LINE sum1 = sum NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum1 -= a [ i ] NEW_LINE DEDENT ans = max ( ans , sum1 ) NEW_LINE DEDENT sum1 = sum NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum1 -= a [ i ] NEW_LINE DEDENT ans = max ( ans , sum1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT xa , ya , xb , yb , xc , yc , xd , yd = map ( float , input ( ) . split ( ) ) NEW_LINE katamukiab = ( yb - ya ) / ( xb - xa ) NEW_LINE katamukicd = ( yd - yc ) / ( xd - xc ) NEW_LINE if katamukiab == katamukicd : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
def nthXorFib ( n , a , b ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return b NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return a ^ b NEW_LINE DEDENT return nthXorFib ( n % 3 , a , b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE n = 10 NEW_LINE print ( nthXorFib ( n , a , b ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE n = int ( input ( ) ) NEW_LINE player1 = 0 NEW_LINE player2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT card1 , card2 = input ( ) . split ( ) NEW_LINE if card1 > card2 : NEW_LINE INDENT player1 += 3 NEW_LINE DEDENT elif card1 < card2 : NEW_LINE INDENT player2 += 3 NEW_LINE DEDENT else : NEW_LINE INDENT player1 += 1 NEW_LINE player2 += 1 NEW_LINE DEDENT DEDENT print ( player1 , player2 ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def Area ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.268 * a NEW_LINE A = 0.70477 * math . pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE ` ` ` NEW_LINE
class p073 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT return str ( self . sternBrocotCount ( 1 , 3 , 1 , 2 ) ) NEW_LINE DEDENT def sternBrocotCount ( self , leftN , leftD , rightN , rightD ) : NEW_LINE INDENT n = leftN + rightN NEW_LINE d = leftD + rightD NEW_LINE if d > 12000 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + self . sternBrocotCount ( leftN , leftD , n , d ) + self . sternBrocotCount ( n , d , rightN , rightD ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( p073 ( ) . run ( ) ) NEW_LINE DEDENT
import sys NEW_LINE def find ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( 60 + 1 ) NEW_LINE arr [ 1 ] = 0 NEW_LINE arr [ 2 ] = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 2 ] * 2 NEW_LINE DEDENT return arr [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( 0 if n % 2 == 1 else int ( 2 ** ( n / 2 ) ) ) NEW_LINE sys . stdout . close ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT i = p * p NEW_LINE while i <= n : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT i = 0 NEW_LINE maxVal = int ( math . pow ( 10 , d ) ) - 1 NEW_LINE prime = [ True ] * ( maxVal + 1 ) NEW_LINE GFG . sieve ( prime , maxVal ) NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT d = 3 NEW_LINE print ( sumPrime ( d ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT i = p * p NEW_LINE while i <= n : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = int ( math . pow ( 2 , d ) - 1 ) NEW_LINE prime = [ True ] * ( maxVal + 1 ) NEW_LINE sieve ( prime , maxVal ) NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT d = 8 NEW_LINE print ( sumPrime ( d ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE from collections import defaultdict NEW_LINE def main ( ) : NEW_LINE INDENT test = int ( input ( ) ) NEW_LINE for t in range ( test ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE div = 1 NEW_LINE count = 0 NEW_LINE total = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT total += arr [ i ] NEW_LINE if total / ( div * 1.0 ) >= k : NEW_LINE INDENT count += 1 NEW_LINE div += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from datetime import datetime NEW_LINE def age_difference ( ) : NEW_LINE INDENT d = [ int ( input ( ) ) for _ in range ( 6 ) ] NEW_LINE d1 = datetime ( d [ 0 ] , d [ 1 ] , d [ 2 ] ) NEW_LINE d2 = datetime ( d [ 3 ] , d [ 4 ] , d [ 5 ] ) NEW_LINE age_diff = abs ( d2 . year - d1 . year ) NEW_LINE if d [ 1 ] == d [ 4 ] and d [ 2 ] == d [ 5 ] : NEW_LINE INDENT print ( age_diff ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( age_diff + 1 ) NEW_LINE DEDENT DEDENT age_difference ( ) NEW_LINE
import math NEW_LINE def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if max_so_far == i : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countMaxContiguous ( arr , n ) : NEW_LINE INDENT current_max = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 != 0 : NEW_LINE INDENT current_max = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current_max += 1 NEW_LINE max_so_far = max ( current_max , max_so_far ) NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 0 , 2 , 4 , 3 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . countMaxContiguous ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def cube ( h , r ) : NEW_LINE INDENT if h < 0 and r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( h * r * math . sqrt ( 2 ) ) / ( h + math . sqrt ( 2 ) * r ) NEW_LINE return a NEW_LINE DEDENT h = 5 NEW_LINE r = 6 NEW_LINE print ( cube ( h , r ) ) NEW_LINE
import java NEW_LINE class GFG : NEW_LINE INDENT def pattern ( rows_no ) : NEW_LINE INDENT for i in range ( 1 , rows_no + 1 ) : NEW_LINE INDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT for i in range ( rows_no - 1 , 0 , - 1 ) : NEW_LINE INDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT rows_no = 7 NEW_LINE pattern ( rows_no ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = input ( ) NEW_LINE for i in range ( 1 , len ( n ) ) : NEW_LINE INDENT if n [ i ] != '0' : NEW_LINE INDENT total_sum = 0 NEW_LINE for j in range ( len ( n ) ) : NEW_LINE INDENT total_sum += int ( n [ j ] ) NEW_LINE DEDENT print ( total_sum ) NEW_LINE return NEW_LINE DEDENT DEDENT if n [ 0 ] == '1' : NEW_LINE INDENT print ( 10 ) NEW_LINE return NEW_LINE DEDENT print ( n [ 0 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class Geeks : NEW_LINE INDENT def check_digits ( n ) : NEW_LINE INDENT while n > 0 : NEW_LINE INDENT if ( n % 10 ) % 2 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT i = n NEW_LINE while True : NEW_LINE INDENT if Geeks . check_digits ( i ) > 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2397 NEW_LINE print ( Geeks . smallest_number ( N ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def check_digits ( n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT if ( n % 10 ) % 2 != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT i = n NEW_LINE while True : NEW_LINE INDENT if GFG . check_digits ( i ) != 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def triangular_series ( n ) : NEW_LINE INDENT j = 1 NEW_LINE k = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( k , end = " ▁ " ) NEW_LINE j = j + 1 NEW_LINE k = k + j NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE triangular_series ( n ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def getNumberOfWays1 ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT count = count + ( arr [ i ] * ( n - arr [ i ] ) ) NEW_LINE DEDENT return count // 2 NEW_LINE DEDENT def sumNatual ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT def getNumberOfWays2 ( arr , n ) : NEW_LINE INDENT t = sumNatual ( n ) NEW_LINE for x in arr : NEW_LINE INDENT t -= sumNatual ( x ) NEW_LINE DEDENT return t NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = sys . stdin . readline ( ) . split ( ) NEW_LINE n = int ( str [ 0 ] ) NEW_LINE m = int ( str [ 1 ] ) NEW_LINE arr = [ 0 ] * m NEW_LINE str = sys . stdin . readline ( ) . split ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ int ( str [ i ] ) - 1 ] += 1 NEW_LINE DEDENT print ( getNumberOfWays2 ( arr , n ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def findPosition ( k , n ) : NEW_LINE INDENT f1 , f2 = 0 , 1 NEW_LINE i = 2 NEW_LINE while i != 0 : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = f3 NEW_LINE if f2 % k == 0 : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 5 NEW_LINE k = 4 NEW_LINE print ( " Position ▁ of ▁ n ' th ▁ multiple ▁ of ▁ k ▁ in ▁ Fibonacci ▁ Series ▁ is " , findPosition ( k , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE len_s = len ( s ) NEW_LINE n = 0 NEW_LINE e = [ False ] * 26 NEW_LINE for i in range ( len_s ) : NEW_LINE INDENT if not e [ ord ( s [ i ] ) - 97 ] : NEW_LINE INDENT n += 1 NEW_LINE DEDENT e [ ord ( s [ i ] ) - 97 ] = True NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT c = 0 NEW_LINE DEDENT else : NEW_LINE INDENT c = len_s - 2 NEW_LINE if s [ 0 ] == s [ len_s - 1 ] : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT DEDENT if c % 2 == 0 : NEW_LINE INDENT ans = " Second " NEW_LINE DEDENT else : NEW_LINE INDENT ans = " First " NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import numpy as np NEW_LINE def countMinimumMoves ( arr , n , k ) : NEW_LINE INDENT for i in range ( k - 1 , n ) : NEW_LINE INDENT if arr [ i ] != arr [ k - 1 ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] != arr [ k - 1 ] : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT arr = np . array ( [ 1 , 2 , 3 , 4 ] ) NEW_LINE K = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( countMinimumMoves ( arr , n , K ) ) NEW_LINE
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT @ staticmethod NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y & 1 != 0 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT @ staticmethod NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return Solution . gcd ( b % a , a ) NEW_LINE DEDENT @ staticmethod NEW_LINE def powerGCD ( a , b , n ) : NEW_LINE INDENT e = Solution . power ( a , n , b ) NEW_LINE return Solution . gcd ( e , b ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT a , b , n = 5 , 4 , 2 NEW_LINE print ( Solution . powerGCD ( a , b , n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE import math NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT inputStream = sys . stdin NEW_LINE outputStream = sys . stdout NEW_LINE in_ = InputReader ( inputStream ) NEW_LINE out = outputStream NEW_LINE solver = TaskA ( ) NEW_LINE solver . solve ( 1 , in_ , out ) NEW_LINE out . close ( ) NEW_LINE DEDENT DEDENT class TaskA : NEW_LINE INDENT def solve ( self , testNumber , in_ , out ) : NEW_LINE INDENT t = in_ . nextInt ( ) NEW_LINE s = in_ . nextInt ( ) NEW_LINE q = in_ . nextInt ( ) NEW_LINE sum = 0 NEW_LINE while s < t : NEW_LINE INDENT s *= q NEW_LINE sum += 1 NEW_LINE DEDENT out . println ( sum ) NEW_LINE DEDENT DEDENT class InputReader : NEW_LINE INDENT def __init__ ( self , stream ) : NEW_LINE INDENT self . reader = stream NEW_LINE self . tokenizer = None NEW_LINE DEDENT def hasNext ( self ) : NEW_LINE INDENT while self . tokenizer is None or not self . tokenizer . hasMoreTokens ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . tokenizer = StringTokenizer ( self . reader . readLine ( ) ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . tokenizer is None or not self . tokenizer . hasMoreTokens ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . tokenizer = StringTokenizer ( self . reader . readLine ( ) ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT raise RuntimeException ( e ) NEW_LINE DEDENT DEDENT return self . tokenizer . nextToken ( ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT return self . reader . readLine ( ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextBigInteger ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextBigDecimal ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = n - 2 NEW_LINE print ( s * s ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countIdenticalRows ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( mat ) ) : NEW_LINE INDENT hs = set ( ) NEW_LINE for j in range ( len ( mat [ i ] ) ) : NEW_LINE INDENT hs . add ( mat [ i ] [ j ] ) NEW_LINE DEDENT if len ( hs ) == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT mat = [ [ 1 , 1 , 1 ] , [ 1 , 2 , 3 ] , [ 5 , 5 , 5 ] ] NEW_LINE print ( countIdenticalRows ( mat ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
from bisect import insort NEW_LINE def createSorted ( a , n ) : NEW_LINE INDENT b = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if not b : NEW_LINE INDENT b . append ( a [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT pos = 0 NEW_LINE start , end = 0 , len ( b ) - 1 NEW_LINE while start <= end : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE if b [ mid ] == a [ j ] : NEW_LINE INDENT insort ( b , a [ j ] ) NEW_LINE break NEW_LINE DEDENT elif b [ mid ] > a [ j ] : NEW_LINE INDENT pos = end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = start = mid + 1 NEW_LINE DEDENT if start > end : NEW_LINE INDENT pos = start NEW_LINE insort ( b , a [ j ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 5 , 4 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE createSorted ( a , n ) NEW_LINE DEDENT
` ` ` python NEW_LINE class geeks : NEW_LINE INDENT def countTotalDistinct ( str ) : NEW_LINE INDENT cnt = 0 NEW_LINE items = set ( ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE ans = set ( ) NEW_LINE for j in range ( i , len ( str ) ) : NEW_LINE INDENT temp += str [ j ] NEW_LINE ans . add ( str [ j ] ) NEW_LINE if temp not in items : NEW_LINE INDENT items . add ( temp ) NEW_LINE cnt += len ( ans ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT str = " ABCA " NEW_LINE print ( geeks . countTotalDistinct ( str ) ) NEW_LINE DEDENT DEDENT geeks . main ( None ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def firstDigit ( n ) : NEW_LINE INDENT digits = int ( math . log10 ( n ) ) NEW_LINE n = int ( n / int ( math . pow ( 10 , digits ) ) ) NEW_LINE return n NEW_LINE DEDENT def lastDigit ( n ) : NEW_LINE INDENT return n % 10 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 98562 NEW_LINE print ( firstDigit ( n ) , lastDigit ( n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT @ staticmethod NEW_LINE def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != 0 : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT if ind == - 1 : NEW_LINE INDENT print ( " Array ▁ has ▁ leading ▁ zeros ▁ only " ) NEW_LINE return NEW_LINE DEDENT b = [ 0 ] * ( n - ind ) NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT b [ i ] = a [ ind + i ] NEW_LINE DEDENT for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT a = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] NEW_LINE n = len ( a ) NEW_LINE Solution . removeZeros ( a , n ) NEW_LINE DEDENT DEDENT Solution . main ( ) NEW_LINE ` ` ` NEW_LINE
from collections import defaultdict NEW_LINE def find_maxm ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if key == value : NEW_LINE INDENT ans = max ( ans , key ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 2 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_maxm ( arr , n ) ) NEW_LINE DEDENT
import sys NEW_LINE from bisect import bisect_left NEW_LINE class Main : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE tsk = Task ( ) NEW_LINE print ( tsk . solve ( arr ) ) NEW_LINE DEDENT DEDENT class Task : NEW_LINE INDENT def solve ( self , arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE sorted_arr = sorted ( arr ) NEW_LINE total = n * ( n + 1 ) // 2 NEW_LINE l , r = 0 , n - 1 NEW_LINE while l < r : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE target = sorted_arr [ mid ] NEW_LINE cur = 0 NEW_LINE cnt = 0 NEW_LINE bit = [ 0 ] * ( 2 * n + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cur += 1 if arr [ i ] <= target else - 1 NEW_LINE x = cur + n + 1 NEW_LINE while x < len ( bit ) : NEW_LINE INDENT bit [ x ] += 1 NEW_LINE x += x & - x NEW_LINE DEDENT x = cur + n NEW_LINE while x > 0 : NEW_LINE INDENT cnt += bit [ x ] NEW_LINE x -= x & - x NEW_LINE DEDENT DEDENT if cnt >= total // 2 + 1 : NEW_LINE INDENT r = mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return sorted_arr [ l ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = Main ( ) NEW_LINE m . main ( sys . argv ) NEW_LINE DEDENT
import math NEW_LINE def sumOfDigitsSingle ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while x != 0 : NEW_LINE INDENT ans += x % 10 NEW_LINE x //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT def closest ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ans * 10 + 9 <= x : NEW_LINE INDENT ans = ans * 10 + 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sumOfDigitsTwoParts ( N ) : NEW_LINE INDENT A = closest ( N ) NEW_LINE return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) NEW_LINE DEDENT N = 35 NEW_LINE print ( sumOfDigitsTwoParts ( N ) ) NEW_LINE
import sys NEW_LINE ca = [ 35.5 , 37.5 , 40 , 43 , 50 , 55 , 70 ] NEW_LINE cb = [ 71 , 77 , 83 , 89 , 105 , 116 , 148 ] NEW_LINE c = [ " AAA " , " AA " , " A " , " B " , " C " , " D " , " E " , " NA " ] NEW_LINE for line in sys . stdin : NEW_LINE INDENT a , b = map ( float , line . split ( ) ) NEW_LINE ar = 100 NEW_LINE br = 100 NEW_LINE for i in range ( len ( ca ) ) : NEW_LINE INDENT if ca [ i ] > a : NEW_LINE INDENT ar = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( len ( cb ) ) : NEW_LINE INDENT if cb [ i ] > b : NEW_LINE INDENT br = i NEW_LINE break NEW_LINE DEDENT DEDENT ans = max ( ar , br ) NEW_LINE if ans == 100 : NEW_LINE INDENT ans = len ( c ) - 1 NEW_LINE DEDENT print ( c [ ans ] ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE res = max ( c - 1 , a - c ) + max ( d - 1 , b - d ) NEW_LINE print ( res ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if arr [ i + 1 ] - arr [ i ] <= 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == n - 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def cal_sin ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE denominator = 0.0 NEW_LINE sinx = 0.0 NEW_LINE sinval = 0.0 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = n NEW_LINE sinx = n NEW_LINE sinval = math . sin ( n ) NEW_LINE i = 1 NEW_LINE while accuracy <= abs ( sinval - sinx ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i + 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE sinx = sinx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT print ( sinx ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 90 NEW_LINE cal_sin ( n ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE @ staticmethod NEW_LINE def multiply ( ) : NEW_LINE INDENT pro = 1 NEW_LINE for i in range ( len ( GFG . arr ) ) : NEW_LINE INDENT pro = pro * GFG . arr [ i ] NEW_LINE DEDENT return pro NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( GFG . multiply ( ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE from decimal import Decimal NEW_LINE def main ( ) : NEW_LINE INDENT q , order_num , i , j , n , counter = 0 , 0 , 0 , 0 , 0 , 0 NEW_LINE flag = [ False ] * 64 NEW_LINE q = int ( input ( ) ) NEW_LINE for j in range ( q ) : NEW_LINE INDENT order_num = int ( input ( ) ) NEW_LINE if order_num <= 3 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE DEDENT if order_num == 0 : NEW_LINE INDENT print ( "1" if flag [ n ] else "0" ) NEW_LINE DEDENT elif order_num == 1 : NEW_LINE INDENT flag [ n ] = True NEW_LINE DEDENT elif order_num == 2 : NEW_LINE INDENT flag [ n ] = False NEW_LINE DEDENT elif order_num == 3 : NEW_LINE INDENT flag [ n ] = not flag [ n ] NEW_LINE DEDENT elif order_num == 4 : NEW_LINE INDENT counter = 1 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if not flag [ i ] : NEW_LINE INDENT counter = 0 NEW_LINE break NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE DEDENT elif order_num == 5 : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] : NEW_LINE INDENT counter = 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE DEDENT elif order_num == 6 : NEW_LINE INDENT counter = 1 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] : NEW_LINE INDENT counter = 0 NEW_LINE break NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE DEDENT elif order_num == 7 : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE DEDENT elif order_num == 8 : NEW_LINE INDENT sum = Decimal ( "0" ) NEW_LINE big = Decimal ( "2" ) NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] : NEW_LINE INDENT sum += big ** i NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = GFG . bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE excl_new = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = incl if incl > excl else excl NEW_LINE incl , excl = excl + arr [ i ] , excl_new NEW_LINE DEDENT return incl if incl > excl else excl NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . maxSumOfBits ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class PythonApplication70 : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE counter = 0 NEW_LINE fine = 0 NEW_LINE arr = [ ] NEW_LINE for i in range ( num ) : NEW_LINE INDENT s = input ( ) NEW_LINE arr . append ( s ) NEW_LINE DEDENT for i in range ( num ) : NEW_LINE INDENT for k in range ( num ) : NEW_LINE INDENT if arr [ k ] [ i ] == ' C ' : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT fine += ( counter * ( counter - 1 ) ) / 2 NEW_LINE counter = 0 NEW_LINE DEDENT for i in range ( num ) : NEW_LINE INDENT for k in range ( num ) : NEW_LINE INDENT if arr [ i ] [ k ] == ' C ' : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT fine += ( counter * ( counter - 1 ) ) / 2 NEW_LINE counter = 0 NEW_LINE DEDENT print ( fine ) NEW_LINE DEDENT DEDENT app = PythonApplication70 ( ) NEW_LINE app . main ( ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def findMinIndex ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return 0 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return GFG . findMinIndex ( arr , low , mid - 1 ) NEW_LINE DEDENT return GFG . findMinIndex ( arr , mid + 1 , high ) NEW_LINE DEDENT def binary_search ( arr , l , h , x ) : NEW_LINE INDENT while l <= h : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] <= x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT return h NEW_LINE DEDENT def countEleLessThanOrEqual ( arr , n , x ) : NEW_LINE INDENT min_index = GFG . findMinIndex ( arr , 0 , n - 1 ) NEW_LINE if x <= arr [ n - 1 ] : NEW_LINE INDENT return ( GFG . binary_search ( arr , min_index , n - 1 , x ) + 1 - min_index ) NEW_LINE DEDENT if ( min_index - 1 ) >= 0 and x <= arr [ min_index - 1 ] : NEW_LINE INDENT return ( n - min_index + GFG . binary_search ( arr , 0 , min_index - 1 , x ) + 1 ) NEW_LINE DEDENT return n NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 6 , 10 , 12 , 15 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 14 NEW_LINE print ( " Count ▁ = ▁ " + str ( GFG . countEleLessThanOrEqual ( arr , n , x ) ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def f ( x , y ) : NEW_LINE INDENT v = y - 2 * x * x + 1 NEW_LINE return v NEW_LINE DEDENT def predict ( x , y , h ) : NEW_LINE INDENT y1p = y + h * f ( x , y ) NEW_LINE return y1p NEW_LINE DEDENT def correct ( x , y , x1 , y1 , h ) : NEW_LINE INDENT e = 0.00001 NEW_LINE y1c = y1 NEW_LINE while abs ( y1c - y1 ) > e : NEW_LINE INDENT y1 = y1c NEW_LINE y1c = y + 0.5 * h * ( f ( x , y ) + f ( x1 , y1 ) ) NEW_LINE DEDENT return y1c NEW_LINE DEDENT def printFinalValues ( x , xn , y , h ) : NEW_LINE INDENT while x < xn : NEW_LINE INDENT x1 = x + h NEW_LINE y1p = predict ( x , y , h ) NEW_LINE y1c = correct ( x , y , x1 , y1p , h ) NEW_LINE x = x1 NEW_LINE y = y1c NEW_LINE DEDENT print ( " The ▁ final ▁ value ▁ of ▁ y ▁ at ▁ x ▁ = ▁ " + str ( int ( x ) ) + " ▁ is ▁ : ▁ " + " { : . 4f } " . format ( y ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0.5 NEW_LINE xn = 1 NEW_LINE h = 0.2 NEW_LINE printFinalValues ( x , xn , y , h ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def D_Pattern ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if j == 1 or ( ( i == 0 or i == n - 1 ) and ( j > 1 and j < n - 2 ) ) or ( j == n - 2 and i != 0 and i != n - 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 9 NEW_LINE D_Pattern ( n ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def kthString ( n , k ) : NEW_LINE INDENT total = 0 NEW_LINE i = 1 NEW_LINE while total < k : NEW_LINE INDENT total = total + n - i NEW_LINE i += 1 NEW_LINE DEDENT first_y_position = i - 1 NEW_LINE second_y_position = k - ( total - n + first_y_position ) NEW_LINE for j in range ( 1 , first_y_position ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE j = first_y_position + 1 NEW_LINE while second_y_position > 1 : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE second_y_position -= 1 NEW_LINE j += 1 NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE while j < n : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT n = 5 NEW_LINE k = 7 NEW_LINE GFG . kthString ( n , k ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT def count_of_subarrays ( N ) : NEW_LINE INDENT count = GFG . binomialCoeff ( 2 * N - 1 , N ) NEW_LINE return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = 3 NEW_LINE print ( GFG . count_of_subarrays ( N ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT def productExceptSelf ( self , nums ) : NEW_LINE INDENT n = len ( nums ) NEW_LINE res = [ 0 ] * n NEW_LINE res [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] * nums [ i - 1 ] NEW_LINE DEDENT right = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT res [ i ] *= right NEW_LINE right *= nums [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 , 4 ] NEW_LINE out = sObj . productExceptSelf ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT s = Solution ( ) NEW_LINE s . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def getSmallestAndLargest ( s , k ) : NEW_LINE INDENT currStr = s [ : k ] NEW_LINE lexMin = currStr NEW_LINE lexMax = currStr NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT currStr = currStr [ 1 : k ] + s [ i ] NEW_LINE if lexMax < currStr : NEW_LINE INDENT lexMax = currStr NEW_LINE DEDENT if lexMin > currStr : NEW_LINE INDENT lexMin = currStr NEW_LINE DEDENT DEDENT print ( lexMin ) NEW_LINE print ( lexMax ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT str = " GeeksForGeeks " NEW_LINE k = 3 NEW_LINE GFG . getSmallestAndLargest ( str , k ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( [ int ( x ) for x in input ( ) . split ( ) ] + [ i ] ) NEW_LINE DEDENT a . sort ( reverse = True ) NEW_LINE b . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) NEW_LINE res = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT e = b [ i ] NEW_LINE res [ e [ 1 ] ] = a [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT INT_BITS = 32 NEW_LINE @ staticmethod NEW_LINE def maxSubarrayXOR ( set , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( GFG . INT_BITS - 1 , - 1 , - 1 ) : NEW_LINE INDENT maxInd = index NEW_LINE maxEle = - 2147483648 NEW_LINE for j in range ( index , n ) : NEW_LINE INDENT if ( set [ j ] & ( 1 << i ) ) != 0 and set [ j ] > maxEle : NEW_LINE INDENT maxEle = set [ j ] NEW_LINE maxInd = j NEW_LINE DEDENT DEDENT if maxEle == - 2147483648 : NEW_LINE INDENT continue NEW_LINE DEDENT temp = set [ index ] NEW_LINE set [ index ] = set [ maxInd ] NEW_LINE set [ maxInd ] = temp NEW_LINE maxInd = index NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j != maxInd and ( set [ j ] & ( 1 << i ) ) != 0 : NEW_LINE INDENT set [ j ] = set [ j ] ^ set [ maxInd ] NEW_LINE DEDENT DEDENT index += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res ^= set [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( arg ) : NEW_LINE INDENT set = [ 9 , 8 , 5 ] NEW_LINE n = len ( set ) NEW_LINE print ( " Max ▁ subset ▁ XOR ▁ is " , end = " ▁ " ) NEW_LINE print ( GFG . maxSubarrayXOR ( set , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT number = int ( input ( ) ) NEW_LINE wooden = [ int ( input ( ) ) for _ in range ( number ) ] NEW_LINE height = [ 0 ] * len ( wooden ) NEW_LINE for i in range ( len ( wooden ) ) : NEW_LINE INDENT if wooden [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE for j in range ( i + 1 , len ( wooden ) ) : NEW_LINE INDENT if wooden [ i ] == wooden [ j ] : NEW_LINE INDENT wooden [ j ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT height [ i ] = count NEW_LINE DEDENT DEDENT index = 0 NEW_LINE max_height = height [ 0 ] NEW_LINE for i in range ( len ( height ) ) : NEW_LINE INDENT if height [ i ] != 0 : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if max_height < height [ i ] : NEW_LINE INDENT max_height = height [ i ] NEW_LINE DEDENT DEDENT print ( max_height , index ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def minAbsSumPair ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE min_sum = 999999 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE min_l = l NEW_LINE min_r = n - 1 NEW_LINE if n < 2 : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return NEW_LINE DEDENT arr . sort ( ) NEW_LINE while l < r : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if abs ( sum ) < abs ( min_sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT if sum < 0 : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are ▁ " + str ( arr [ min_l ] ) + " ▁ and ▁ " + str ( arr [ min_r ] ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE minAbsSumPair ( arr , n ) NEW_LINE DEDENT def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ high ] NEW_LINE i = ( low - 1 ) NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT if arr [ j ] <= pivot : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ high ] = arr [ high ] , arr [ i + 1 ] NEW_LINE return i + 1 NEW_LINE DEDENT def sort ( arr , low , high ) : NEW_LINE INDENT if low < high : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE sort ( arr , low , pi - 1 ) NEW_LINE sort ( arr , pi + 1 , high ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def firstUniqChar ( self , s : str ) -> int : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = " leetcode " NEW_LINE out = sObj . firstUniqChar ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT Solution ( ) . main ( ) NEW_LINE
from collections import deque NEW_LINE def checkStackPermutation ( ip , op , n ) : NEW_LINE INDENT input_queue = deque ( ip ) NEW_LINE output_queue = deque ( op ) NEW_LINE temp_stack = [ ] NEW_LINE while input_queue : NEW_LINE INDENT ele = input_queue . popleft ( ) NEW_LINE if ele == output_queue [ 0 ] : NEW_LINE INDENT output_queue . popleft ( ) NEW_LINE while temp_stack and temp_stack [ - 1 ] == output_queue [ 0 ] : NEW_LINE INDENT temp_stack . pop ( ) NEW_LINE output_queue . popleft ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp_stack . append ( ele ) NEW_LINE DEDENT DEDENT return not input_queue and not temp_stack NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input_arr = [ 1 , 2 , 3 ] NEW_LINE output_arr = [ 2 , 1 , 3 ] NEW_LINE n = 3 NEW_LINE if checkStackPermutation ( input_arr , output_arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE t = input ( ) NEW_LINE l = len ( s ) NEW_LINE ans = True NEW_LINE for i in range ( l ) : NEW_LINE INDENT if s . find ( s [ i ] , i + 1 ) != t . find ( t [ i ] , i + 1 ) : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT print ( " Yes " if ans else " No " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class solution : NEW_LINE INDENT @ staticmethod NEW_LINE def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 10 == d : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 30 NEW_LINE d = 3 NEW_LINE print ( solution . getSum ( n , d ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
from sys import stdin NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT st , end , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE sum = 0 NEW_LINE if st > end : NEW_LINE INDENT temp = end NEW_LINE end = st NEW_LINE st = temp NEW_LINE DEDENT if n + m <= st : NEW_LINE INDENT sum = end - st NEW_LINE DEDENT elif n + m >= st and n - m < st : NEW_LINE INDENT sum = end - n - m NEW_LINE DEDENT elif n - m >= st and n <= end - m : NEW_LINE INDENT sum = end - st - 2 * m NEW_LINE DEDENT elif n - m < end and n + m >= end : NEW_LINE INDENT sum = n - m - st NEW_LINE DEDENT else : NEW_LINE INDENT sum = end - st NEW_LINE DEDENT if sum < 0 : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE class Codechef : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT e , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE temp = max ( e - s , e - t ) NEW_LINE print ( temp + 1 ) NEW_LINE DEDENT DEDENT except Exception as e : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT codechef = Codechef ( ) NEW_LINE codechef . main ( ) NEW_LINE DEDENT
import java NEW_LINE class GFG : NEW_LINE INDENT def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT N = 10 NEW_LINE K = 2 NEW_LINE print ( findSum ( N , K ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = 1 + ( ( 4 * n ) // gcd ( 4 * n , n + 1 ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE class GFG : NEW_LINE INDENT PI = 3.14 NEW_LINE @ staticmethod NEW_LINE def find_area ( r , d ) : NEW_LINE INDENT R = d / GFG . PI NEW_LINE R += math . pow ( r , 2 ) NEW_LINE R = math . sqrt ( R ) NEW_LINE area = GFG . PI * math . pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT r = 4 NEW_LINE d = 5 NEW_LINE print ( GFG . find_area ( r , d ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( s % n ) > 0 : NEW_LINE INDENT return s // n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return s // n NEW_LINE DEDENT DEDENT n = 5 NEW_LINE s = 11 NEW_LINE print ( minimumNumbers ( n , s ) ) NEW_LINE
import java . util . Arrays NEW_LINE def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for end in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while start < mid : NEW_LINE INDENT prod = arr [ end ] * arr [ start ] * arr [ mid ] NEW_LINE if prod > m : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif prod < m : NEW_LINE INDENT start += 1 NEW_LINE DEDENT elif prod == m : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE m = 1 NEW_LINE print ( countTriplets ( arr , n , m ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def findIndex ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT a , b , c = 0 , 1 , 1 NEW_LINE res = 1 NEW_LINE while c < n : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT result = self . findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def isVowel ( ch ) : NEW_LINE INDENT return ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] NEW_LINE DEDENT def isSatisfied ( str , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if not isVowel ( str [ i ] ) and not isVowel ( str [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if isVowel ( str [ i ] ) and not isVowel ( str [ i - 1 ] ) and not isVowel ( str [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " acaba " NEW_LINE n = len ( str ) NEW_LINE if isSatisfied ( list ( str ) , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
class GFG : NEW_LINE INDENT def countWays ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def expect ( m , n ) : NEW_LINE INDENT ans = 0.0 NEW_LINE for i in range ( m , 0 , - 1 ) : NEW_LINE INDENT ans += ( ( i / m ) ** n - ( ( i - 1 ) / m ) ** n ) * i NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT m = 6 NEW_LINE n = 3 NEW_LINE print ( " { : . 5f } " . format ( self . expect ( m , n ) ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def ProdOfPrimes ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE for p in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT prod = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT prod *= i NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( ProdOfPrimes ( n ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
class p019 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT count = 0 NEW_LINE for y in range ( 1901 , 2001 ) : NEW_LINE INDENT for m in range ( 1 , 13 ) : NEW_LINE INDENT if self . dayOfWeek ( y , m , 1 ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return str ( count ) NEW_LINE DEDENT def dayOfWeek ( self , year , month , day ) : NEW_LINE INDENT if year < 0 or year > 10000 or month < 1 or month > 12 or day < 1 or day > 31 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT m = ( month - 3 + 4800 ) % 4800 NEW_LINE y = ( year + m // 12 ) % 400 NEW_LINE m %= 12 NEW_LINE return ( y + y // 4 - y // 100 + ( 13 * m + 2 ) // 5 + day + 2 ) % 7 NEW_LINE DEDENT DEDENT p = p019 ( ) NEW_LINE p . main ( [ ] ) NEW_LINE
class GFG : NEW_LINE INDENT class Date : NEW_LINE INDENT def __init__ ( self , d , m , y ) : NEW_LINE INDENT self . d = d NEW_LINE self . m = m NEW_LINE self . y = y NEW_LINE DEDENT DEDENT monthDays = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE @ staticmethod NEW_LINE def countLeapYears ( d ) : NEW_LINE INDENT years = d . y NEW_LINE if d . m <= 2 : NEW_LINE INDENT years -= 1 NEW_LINE DEDENT return years // 4 - years // 100 + years // 400 NEW_LINE DEDENT @ staticmethod NEW_LINE def getDifference ( dt1 , dt2 ) : NEW_LINE INDENT n1 = dt1 . y * 365 + dt1 . d NEW_LINE for i in range ( dt1 . m - 1 ) : NEW_LINE INDENT n1 += GFG . monthDays [ i ] NEW_LINE DEDENT n1 += GFG . countLeapYears ( dt1 ) NEW_LINE n2 = dt2 . y * 365 + dt2 . d NEW_LINE for i in range ( dt2 . m - 1 ) : NEW_LINE INDENT n2 += GFG . monthDays [ i ] NEW_LINE DEDENT n2 += GFG . countLeapYears ( dt2 ) NEW_LINE return n2 - n1 NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT dt1 = GFG . Date ( 1 , 2 , 2000 ) NEW_LINE dt2 = GFG . Date ( 1 , 2 , 2004 ) NEW_LINE print ( " Difference ▁ between ▁ two ▁ dates ▁ is " , GFG . getDifference ( dt1 , dt2 ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT st = set ( ) NEW_LINE @ staticmethod NEW_LINE def generateNumbers ( n , num , a , b ) : NEW_LINE INDENT if 0 < num < n : NEW_LINE INDENT GFG . st . add ( num ) NEW_LINE DEDENT if num >= n : NEW_LINE INDENT return NEW_LINE DEDENT if num * 10 + a > num : NEW_LINE INDENT GFG . generateNumbers ( n , num * 10 + a , a , b ) NEW_LINE DEDENT GFG . generateNumbers ( n , num * 10 + b , a , b ) NEW_LINE DEDENT @ staticmethod NEW_LINE def printNumbers ( n ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( i + 1 , 10 ) : NEW_LINE INDENT GFG . generateNumbers ( n , 0 , i , j ) NEW_LINE DEDENT DEDENT print ( " The ▁ numbers ▁ are : " , GFG . st ) NEW_LINE GFG . st . clear ( ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT n = 12 NEW_LINE GFG . printNumbers ( n ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE n , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE temp = ( t * k * n ) / 100.0 NEW_LINE x = 0 NEW_LINE while temp - k >= 0 : NEW_LINE INDENT temp -= k NEW_LINE x += 1 NEW_LINE DEDENT for i in range ( x ) : NEW_LINE INDENT print ( k , end = " ▁ " ) NEW_LINE DEDENT if temp != 0 : NEW_LINE INDENT print ( int ( temp ) , end = " ▁ " ) NEW_LINE x += 1 NEW_LINE DEDENT for i in range ( x , n ) : NEW_LINE INDENT print ( 0 , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = Scanner ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT N = self . ni ( ) NEW_LINE Q = self . ni ( ) NEW_LINE if ( N | Q ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT list = [ ] NEW_LINE map = { } NEW_LINE for i in range ( 1 , 100 ) : NEW_LINE INDENT map [ i ] = 0 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT M = self . ni ( ) NEW_LINE sublist = [ ] NEW_LINE for j in range ( M ) : NEW_LINE INDENT d = self . ni ( ) NEW_LINE sublist . append ( d ) NEW_LINE map [ d ] = map . get ( d , 0 ) + 1 NEW_LINE DEDENT list . append ( sublist ) NEW_LINE DEDENT max = 0 NEW_LINE idx = 0 NEW_LINE for key in map : NEW_LINE INDENT n = map [ key ] NEW_LINE if n >= Q : NEW_LINE INDENT if max < n : NEW_LINE INDENT idx = key NEW_LINE max = n NEW_LINE DEDENT DEDENT DEDENT print ( idx ) NEW_LINE DEDENT DEDENT def ni ( self ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class OddOccurance : NEW_LINE INDENT def getOddOccurrence ( self , ar ) : NEW_LINE INDENT res = 0 NEW_LINE for num in ar : NEW_LINE INDENT res = res ^ num NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT occur = OddOccurance ( ) NEW_LINE ar = [ 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ] NEW_LINE print ( occur . getOddOccurrence ( ar ) ) NEW_LINE DEDENT DEDENT occur = OddOccurance ( ) NEW_LINE occur . main ( ) NEW_LINE
class GFG : NEW_LINE INDENT def isKthBitSet ( x , k ) : NEW_LINE INDENT rslt = 1 if ( x & ( 1 << ( k - 1 ) ) ) != 0 else 0 NEW_LINE return rslt NEW_LINE DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 NEW_LINE r = ( 32 // 8 ) * 8 NEW_LINE while l < r : NEW_LINE INDENT if GFG . isKthBitSet ( x , l ) != GFG . isKthBitSet ( x , r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT x = 1 << 15 + 1 << 16 NEW_LINE print ( GFG . isPalindrome ( x ) ) NEW_LINE x = ( 1 << 31 ) + 1 NEW_LINE print ( GFG . isPalindrome ( x ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if isPrime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE isPrime = [ False ] * ( n + 1 ) NEW_LINE GFG . SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT x = n // i NEW_LINE if isPrime [ i ] and isPrime [ x ] and x != i and x * i == n : NEW_LINE INDENT print ( i , x ) NEW_LINE flag = 1 NEW_LINE return NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ found " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 39 NEW_LINE GFG . findPrimePair ( n ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " + str ( a ) + " ▁ , ▁ " + str ( b ) + " ) ▁ = ▁ " + str ( g ) ) NEW_LINE a = 35 NEW_LINE b = 10 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " + str ( a ) + " ▁ , ▁ " + str ( b ) + " ) ▁ = ▁ " + str ( g ) ) NEW_LINE a = 31 NEW_LINE b = 2 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " + str ( a ) + " ▁ , ▁ " + str ( b ) + " ) ▁ = ▁ " + str ( g ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " + str ( a ) + " ▁ , ▁ " + str ( b ) + " ) ▁ = ▁ " + str ( g ) ) NEW_LINE a = 35 NEW_LINE b = 10 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " + str ( a ) + " ▁ , ▁ " + str ( b ) + " ) ▁ = ▁ " + str ( g ) ) NEW_LINE a = 31 NEW_LINE b = 2 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " + str ( a ) + " ▁ , ▁ " + str ( b ) + " ) ▁ = ▁ " + str ( g ) ) NEW_LINE ` ` ` NEW_LINE
class p174 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . SIZE_LIMIT = 1000000 NEW_LINE self . TYPE_LIMIT = 10 NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT type = [ 0 ] * ( self . SIZE_LIMIT + 1 ) NEW_LINE for n in range ( 3 , ( n - 1 ) * 4 <= self . SIZE_LIMIT , n + 1 ) : NEW_LINE INDENT for m in range ( n - 2 , 0 , - 2 ) : NEW_LINE INDENT tiles = n * n - m * m NEW_LINE if tiles > self . SIZE_LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT type [ tiles ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for t in type : NEW_LINE INDENT if 1 <= t <= self . TYPE_LIMIT : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class BinaryRemoval : NEW_LINE INDENT @ staticmethod NEW_LINE def remove ( s ) : NEW_LINE INDENT one = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT if s [ i - 1 ] == '1' : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ i - 1 ] == '0' and one > 0 : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " YES " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT test = int ( input ( ) ) NEW_LINE for _ in range ( test ) : NEW_LINE INDENT s = input ( ) NEW_LINE BinaryRemoval . remove ( s ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def maxZeros ( N ) : NEW_LINE INDENT maxm = - 1 NEW_LINE cnt = 0 NEW_LINE while N != 0 : NEW_LINE INDENT if ( N & 1 ) == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE N >>= 1 NEW_LINE maxm = max ( maxm , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT maxm = max ( maxm , cnt ) NEW_LINE cnt = 0 NEW_LINE N >>= 1 NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 14 NEW_LINE print ( maxZeros ( N ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import java NEW_LINE def getLongestSeq ( a , n ) : NEW_LINE INDENT maxIdx = 0 NEW_LINE maxLen = 0 NEW_LINE currLen = 0 NEW_LINE currIdx = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if a [ k ] > 0 : NEW_LINE INDENT currLen += 1 NEW_LINE if currLen == 1 : NEW_LINE INDENT currIdx = k NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if currLen > maxLen : NEW_LINE INDENT maxLen = currLen NEW_LINE maxIdx = currIdx NEW_LINE DEDENT currLen = 0 NEW_LINE DEDENT DEDENT if maxLen > 0 : NEW_LINE INDENT print ( " Index ▁ : ▁ " + str ( maxIdx ) ) NEW_LINE print ( " , Length ▁ : ▁ " + str ( maxLen ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ positive ▁ sequence ▁ detected . " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , - 3 , 2 , 3 , 4 , - 6 , 1 , 2 , 3 , 4 , 5 , - 8 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE getLongestSeq ( arr , n ) NEW_LINE
class Linked_list_2D_Matrix : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . right = None NEW_LINE self . down = None NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def construct ( arr , i , j , m , n ) : NEW_LINE INDENT if i > n - 1 or j > m - 1 : NEW_LINE INDENT return None NEW_LINE DEDENT temp = Linked_list_2D_Matrix . Node ( ) NEW_LINE temp . data = arr [ i ] [ j ] NEW_LINE temp . right = Linked_list_2D_Matrix . construct ( arr , i , j + 1 , m , n ) NEW_LINE temp . down = Linked_list_2D_Matrix . construct ( arr , i + 1 , j , m , n ) NEW_LINE return temp NEW_LINE DEDENT @ staticmethod NEW_LINE def display ( head ) : NEW_LINE INDENT Rp = None NEW_LINE Dp = head NEW_LINE while Dp is not None : NEW_LINE INDENT Rp = Dp NEW_LINE while Rp is not None : NEW_LINE INDENT print ( Rp . data , end = " ▁ " ) NEW_LINE Rp = Rp . right NEW_LINE DEDENT print ( ) NEW_LINE Dp = Dp . down NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE m = 3 NEW_LINE n = 3 NEW_LINE head = Linked_list_2D_Matrix . construct ( arr , 0 , 0 , m , n ) NEW_LINE Linked_list_2D_Matrix . display ( head ) NEW_LINE DEDENT DEDENT Linked_list_2D_Matrix . main ( ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def is_prime ( x ) : NEW_LINE INDENT if x < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if x <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if x % 2 == 0 or x % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= x : NEW_LINE INDENT if x % i == 0 or x % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT if is_prime ( int ( input ( ) ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def findNthTerm ( N ) : NEW_LINE INDENT if N % 2 == 0 : NEW_LINE INDENT ans = ( N // 2 ) * 6 + ( N // 2 ) * 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N // 2 + 1 ) * 6 + ( N // 2 ) * 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if a == b and a == c and a == d and c == d and b == c and b == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == b and c == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == d and c == b : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == c and d == b : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT a , b , c , d = 1 , 2 , 3 , 4 NEW_LINE if self . isRectangle ( a , b , c , d ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( ( m ** 0.5 ) + 1 ) NEW_LINE an = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m NEW_LINE DEDENT value = [ 0 ] * m NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if value [ an ] == 0 : NEW_LINE INDENT value [ an ] = i NEW_LINE DEDENT an = ( an * an ) % m NEW_LINE DEDENT cur = b NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if value [ cur ] > 0 : NEW_LINE INDENT ans = value [ cur ] * n - i NEW_LINE if ans < m : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE m = 5 NEW_LINE print ( GFG . discreteLogarithm ( a , b , m ) ) NEW_LINE a = 3 NEW_LINE b = 7 NEW_LINE m = 11 NEW_LINE print ( GFG . discreteLogarithm ( a , b , m ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ind == ( n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif dp [ ind ] != - 1 : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = float ( ' inf ' ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ind + i < n : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + GFG . FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return dp [ ind ] NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 ] * n NEW_LINE print ( GFG . FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def __gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def Probability ( sum , times ) : NEW_LINE INDENT favorable = 0 NEW_LINE total = 36 NEW_LINE probability = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT for j in range ( 1 , 7 ) : NEW_LINE INDENT if ( i + j ) == sum : NEW_LINE INDENT favorable += 1 NEW_LINE DEDENT DEDENT DEDENT gcd1 = __gcd ( int ( favorable ) , int ( total ) ) NEW_LINE favorable = favorable / float ( gcd1 ) NEW_LINE total = total / float ( gcd1 ) NEW_LINE probability = int ( math . pow ( total , times ) ) NEW_LINE return probability NEW_LINE DEDENT sum = 7 NEW_LINE times = 7 NEW_LINE print ( "1" + " / " + str ( Probability ( sum , times ) ) ) NEW_LINE
import math NEW_LINE mod = 998244353 NEW_LINE nchoosek = [ [ 0 for i in range ( 4001 ) ] for j in range ( 4001 ) ] NEW_LINE for i in range ( 4001 ) : NEW_LINE INDENT nchoosek [ i ] [ 0 ] = nchoosek [ i ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , 4001 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT nchoosek [ i ] [ j ] = ( nchoosek [ i - 1 ] [ j ] + nchoosek [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT DEDENT k = int ( input ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( 2 , 2 * k + 1 ) : NEW_LINE INDENT if i > k : NEW_LINE INDENT pairs = k - i // 2 NEW_LINE DEDENT else : NEW_LINE INDENT pairs = ( i - 1 ) // 2 NEW_LINE DEDENT active = k - 2 * pairs NEW_LINE if i % 2 == 0 : NEW_LINE INDENT active -= 1 NEW_LINE DEDENT times2 = 1 NEW_LINE total = 0 NEW_LINE for j in range ( pairs + 1 ) : NEW_LINE INDENT choice = times2 * nchoosek [ pairs ] [ j ] % mod NEW_LINE times2 = times2 * 2 % mod NEW_LINE if active + j - 1 < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT total += choice * nchoosek [ n + active - 1 ] [ active + j - 1 ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT total += choice * nchoosek [ n + active - 2 ] [ active + j - 1 ] NEW_LINE DEDENT total %= mod NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE total = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT money = float ( input ( ) ) NEW_LINE A = input ( ) NEW_LINE B = " JPY " NEW_LINE if A == B : NEW_LINE INDENT total += money NEW_LINE DEDENT else : NEW_LINE INDENT total += money * 380000 NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import array NEW_LINE def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == num1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i >= n - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT j = 0 NEW_LINE for j in range ( n - 1 , i , - 1 ) : NEW_LINE INDENT if arr [ j ] == num2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == i : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = array . array ( ' i ' , [ 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 ] ) NEW_LINE n = len ( arr ) NEW_LINE num1 = 5 NEW_LINE num2 = 4 NEW_LINE print ( getCount ( arr , n , num1 , num2 ) ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE min_diff = float ( ' inf ' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT min_diff = min ( min_diff , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT print ( min_diff ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE setBits = [ 0 ] * ( n + 1 ) NEW_LINE setBits [ 0 ] = 0 NEW_LINE setBits [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT setBits [ i ] = setBits [ i // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 6 NEW_LINE print ( GFG . countSetBits ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def largestGCD1Subset ( A , n ) : NEW_LINE INDENT currentGCD = A [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currentGCD = gcd ( currentGCD , A [ i ] ) NEW_LINE if currentGCD == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT A = [ 2 , 18 , 6 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestGCD1Subset ( A , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE class p179 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT LIMIT = pow ( 10 , 7 ) NEW_LINE numDivisors = [ 2 ] * ( LIMIT + 1 ) NEW_LINE for i in range ( 2 , len ( numDivisors ) ) : NEW_LINE INDENT for j in range ( i * 2 , len ( numDivisors ) , i ) : NEW_LINE INDENT numDivisors [ j ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( 2 , len ( numDivisors ) - 1 ) : NEW_LINE INDENT if numDivisors [ i ] == numDivisors [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT DEDENT print ( p179 ( ) . run ( ) ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT arr [ 0 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE GFG . updateArray ( arr , N ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def findEncryptedArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum - arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE GFG . findEncryptedArray ( arr , N ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE GFG . updateArray ( arr , N ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
class GFG : NEW_LINE INDENT def findMinDifference ( arr , n ) : NEW_LINE INDENT min_val = min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE second_min = arr [ 0 ] if arr [ 0 ] < arr [ 1 ] else arr [ 1 ] NEW_LINE max_val = max ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE second_max = arr [ 1 ] if arr [ 0 ] < arr [ 1 ] else arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if arr [ i ] > max_val : NEW_LINE INDENT second_max = max_val NEW_LINE max_val = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second_max : NEW_LINE INDENT second_max = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < min_val : NEW_LINE INDENT second_min = min_val NEW_LINE min_val = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < second_min : NEW_LINE INDENT second_min = arr [ i ] NEW_LINE DEDENT DEDENT diff = min ( max_val - second_min , second_max - min_val ) NEW_LINE return diff NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinDifference ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def main ( ) : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE pairs = [ ] NEW_LINE for i in range ( num ) : NEW_LINE INDENT pair = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE pairs . append ( pair ) NEW_LINE DEDENT common_factors = set ( ) NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT X = pairs [ 0 ] [ i ] NEW_LINE for k in range ( 2 , math . ceil ( math . sqrt ( X ) ) + 1 ) : NEW_LINE INDENT if X % k == 0 : NEW_LINE INDENT while X % k == 0 : NEW_LINE INDENT X //= k NEW_LINE DEDENT common_factors . add ( k ) NEW_LINE DEDENT DEDENT if X != 1 : NEW_LINE INDENT common_factors . add ( X ) NEW_LINE DEDENT DEDENT for val in common_factors : NEW_LINE INDENT works = True NEW_LINE for pair in pairs : NEW_LINE INDENT if pair [ 0 ] % val > 0 and pair [ 1 ] % val > 0 : NEW_LINE INDENT works = False NEW_LINE break NEW_LINE DEDENT DEDENT if works : NEW_LINE INDENT print ( val ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE from collections import Counter NEW_LINE def main ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT n = int ( line ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT colors = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE color_count = Counter ( colors ) NEW_LINE majority_color = max ( color_count , key = color_count . get ) NEW_LINE if color_count [ majority_color ] > n / 2 : NEW_LINE INDENT print ( majority_color ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO ▁ COLOR " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class Factorial : NEW_LINE INDENT def factorial ( self , n ) : NEW_LINE INDENT return 1 if n == 1 or n == 0 else n * self . factorial ( n - 1 ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT obj = Factorial ( ) NEW_LINE num = 5 NEW_LINE print ( " Factorial ▁ of ▁ " + str ( num ) + " ▁ is ▁ " + str ( obj . factorial ( num ) ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT line = sys . stdin . readline ( ) . strip ( ) NEW_LINE n , d , x = map ( int , line . split ( ) ) NEW_LINE price = [ ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT line = sys . stdin . readline ( ) . strip ( ) NEW_LINE prices = list ( map ( int , line . split ( ) ) ) NEW_LINE price . append ( prices ) NEW_LINE DEDENT for i in range ( d - 1 ) : NEW_LINE INDENT dp = [ j for j in range ( x + 1 ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT for k in range ( x , - 1 , - 1 ) : NEW_LINE INDENT if k >= price [ i ] [ j ] : NEW_LINE INDENT dp [ k ] = max ( dp [ k ] , dp [ k - price [ i ] [ j ] ] + price [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT x = dp [ x ] NEW_LINE DEDENT print ( x ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class TaskB : NEW_LINE INDENT def solve ( self , br , out ) : NEW_LINE INDENT st = br . readline ( ) . split ( ) NEW_LINE n = int ( st [ 0 ] ) NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE sumA = [ 0 ] * ( n + 1 ) NEW_LINE sumB = [ 0 ] * ( n + 1 ) NEW_LINE a [ 0 ] = sumA [ 0 ] = sumB [ 0 ] = 0 NEW_LINE st = br . readline ( ) . split ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] = int ( st [ i - 1 ] ) NEW_LINE sumA [ i ] = sumA [ i - 1 ] + a [ i ] NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sumB [ i ] = sumB [ i - 1 ] + a [ i ] NEW_LINE DEDENT st = br . readline ( ) . split ( ) NEW_LINE m = int ( st [ 0 ] ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT st = br . readline ( ) . split ( ) NEW_LINE type = int ( st [ 0 ] ) NEW_LINE l = int ( st [ 1 ] ) NEW_LINE r = int ( st [ 2 ] ) NEW_LINE if type == 1 : NEW_LINE INDENT out . write ( str ( sumA [ r ] - sumA [ l - 1 ] ) + " \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT out . write ( str ( sumB [ r ] - sumB [ l - 1 ] ) + " \n " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT task = TaskB ( ) NEW_LINE task . solve ( sys . stdin , sys . stdout ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( a ) NEW_LINE if len ( st ) == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if len ( st ) == 2 : NEW_LINE INDENT el1 , el2 = st NEW_LINE if ( el2 - el1 ) % 2 == 0 : NEW_LINE INDENT return ( el2 - el1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( el2 - el1 ) NEW_LINE DEDENT DEDENT if len ( st ) == 3 : NEW_LINE INDENT el1 , el2 , el3 = st NEW_LINE if ( el2 - el1 ) == ( el3 - el2 ) : NEW_LINE INDENT return el2 - el1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def findX ( n , k ) : NEW_LINE INDENT r = n NEW_LINE m = int ( math . sqrt ( k ) ) + 1 NEW_LINE for i in range ( 2 , m + 1 ) : NEW_LINE INDENT if i == m : NEW_LINE INDENT i = k NEW_LINE DEDENT u = v = 0 NEW_LINE while k % i == 0 : NEW_LINE INDENT v += 1 NEW_LINE k /= i NEW_LINE DEDENT if v > 0 : NEW_LINE INDENT t = n NEW_LINE while t > 0 : NEW_LINE INDENT t //= i NEW_LINE u += t NEW_LINE DEDENT r = min ( r , u // v ) NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( findX ( n , k ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT if x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = 7 NEW_LINE b = 2 NEW_LINE x = 4 NEW_LINE y = 5 NEW_LINE if GFG . LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT print ( " Given ▁ point ▁ lies ▁ inside ▁ the ▁ rectangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Given ▁ point ▁ does ▁ not ▁ lie ▁ on ▁ the ▁ rectangle " ) NEW_LINE DEDENT DEDENT DEDENT
class GFG : NEW_LINE INDENT N = 1000 NEW_LINE @ staticmethod NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT size = ( 2 * GFG . N ) + 1 NEW_LINE freq = [ 0 ] * size NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x + GFG . N ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if freq [ i ] > 0 : NEW_LINE INDENT ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) // 2 NEW_LINE for j in range ( i + 2 , 2001 , 2 ) : NEW_LINE INDENT if freq [ j ] > 0 and ( freq [ ( i + j ) // 2 ] > 0 ) : NEW_LINE INDENT ans += ( freq [ i ] * freq [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT arr = [ 4 , 2 , 5 , 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . countPairs ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
class GFG : NEW_LINE INDENT sum = 0 NEW_LINE n = 0 NEW_LINE @ staticmethod NEW_LINE def getAvg ( x ) : NEW_LINE INDENT GFG . sum += x NEW_LINE GFG . n += 1 NEW_LINE return float ( GFG . sum ) / GFG . n NEW_LINE DEDENT @ staticmethod NEW_LINE def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = GFG . getAvg ( int ( arr [ i ] ) ) NEW_LINE print ( " Average ▁ of ▁ " + str ( i + 1 ) + " ▁ numbers ▁ is ▁ " + str ( avg ) ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE GFG . streamAvg ( arr , n ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE MAX = 10000 NEW_LINE s = set ( ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( MAX ** 0.5 ) ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT product *= p NEW_LINE s . add ( product + 1 ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT return n in s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if isEuclid ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = 42 NEW_LINE if isEuclid ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE n , b = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE v = [ ] NEW_LINE odd = 0 NEW_LINE even = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i != 0 and odd == even : NEW_LINE INDENT v . append ( abs ( arr [ i ] - arr [ i - 1 ] ) ) NEW_LINE DEDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if b >= v [ i ] : NEW_LINE INDENT count += 1 NEW_LINE b -= v [ i ] NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def maxOperations ( str ) : NEW_LINE INDENT i , g , gk , gks = 0 , 0 , 0 , 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] == ' g ' : NEW_LINE INDENT g += 1 NEW_LINE DEDENT elif str [ i ] == ' k ' : NEW_LINE INDENT if g > 0 : NEW_LINE INDENT g -= 1 NEW_LINE gk += 1 NEW_LINE DEDENT DEDENT elif str [ i ] == ' s ' : NEW_LINE INDENT if gk > 0 : NEW_LINE INDENT gk -= 1 NEW_LINE gks += 1 NEW_LINE DEDENT DEDENT DEDENT return gks NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT a = " ggkssk " NEW_LINE print ( GFG . maxOperations ( a ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE min_val = a [ 0 ] NEW_LINE max_val = a [ n - 1 ] NEW_LINE res = max_val - min_val + 1 - n NEW_LINE print ( res ) NEW_LINE
from collections import deque NEW_LINE class Forming_Teams : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . count = 0 NEW_LINE self . seen = [ ] NEW_LINE self . path = 0 NEW_LINE self . cycle = 1 NEW_LINE self . graph = [ ] NEW_LINE DEDENT def dfs ( self , child , par ) : NEW_LINE INDENT if self . seen [ child ] == True : NEW_LINE INDENT return self . cycle NEW_LINE DEDENT self . seen [ child ] = True NEW_LINE for i in self . graph [ child ] : NEW_LINE INDENT if i != par : NEW_LINE INDENT self . count += 1 NEW_LINE if self . dfs ( i , child ) == self . cycle : NEW_LINE INDENT return self . cycle NEW_LINE DEDENT DEDENT DEDENT return self . path NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE ft = Forming_Teams ( ) NEW_LINE ft . graph = [ deque ( ) for _ in range ( m + 1 ) ] NEW_LINE ft . seen = [ False for _ in range ( m + 1 ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ft . graph [ x ] . append ( y ) NEW_LINE ft . graph [ y ] . append ( x ) NEW_LINE DEDENT toremove = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if not ft . seen [ i ] : NEW_LINE INDENT ft . count = 0 NEW_LINE if ft . dfs ( i , 0 ) == ft . cycle : NEW_LINE INDENT if ft . count % 2 == 1 : NEW_LINE INDENT toremove += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( m - toremove ) % 2 == 1 : NEW_LINE INDENT toremove += 1 NEW_LINE DEDENT print ( toremove ) NEW_LINE DEDENT
import numpy as np NEW_LINE def kth_smallest ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE k = 2 NEW_LINE print ( " K ' th ▁ smallest ▁ element ▁ is " , kth_smallest ( arr , k ) ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr2 = [ i + 1 for i in range ( n ) ] NEW_LINE try : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT if arr2 [ j ] == arr [ j ] : NEW_LINE INDENT arr2 [ j ] , arr2 [ j + 1 ] = arr2 [ j + 1 ] , arr2 [ j ] NEW_LINE DEDENT DEDENT if arr2 [ n - 1 ] == arr [ n - 1 ] : NEW_LINE INDENT arr2 [ n - 1 ] , arr2 [ n - 2 ] = arr2 [ n - 2 ] , arr2 [ n - 1 ] NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT print ( arr2 [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT except : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE class p329 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . START_NUM = 1 NEW_LINE self . END_NUM = 500 NEW_LINE self . CROAK_SEQ = " PPPPNNPPPNPPNPN " NEW_LINE assert 0 <= self . START_NUM and self . START_NUM < self . END_NUM and self . END_NUM < math . inf NEW_LINE assert 1 <= len ( self . CROAK_SEQ ) and len ( self . CROAK_SEQ ) <= 31 NEW_LINE self . NUM_JUMPS = len ( self . CROAK_SEQ ) - 1 NEW_LINE self . NUM_TRIALS = 1 << self . NUM_JUMPS NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT globalNumerator = 0 NEW_LINE isPrime = [ self . is_prime ( i ) for i in range ( self . END_NUM + 1 ) ] NEW_LINE for i in range ( self . START_NUM , self . END_NUM + 1 ) : NEW_LINE INDENT for j in range ( self . NUM_TRIALS ) : NEW_LINE INDENT pos = i NEW_LINE trialNumerator = 1 NEW_LINE if isPrime [ pos ] == ( self . CROAK_SEQ [ 0 ] == ' P ' ) : NEW_LINE INDENT trialNumerator *= 2 NEW_LINE DEDENT for k in range ( self . NUM_JUMPS ) : NEW_LINE INDENT if pos <= self . START_NUM : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT elif pos >= self . END_NUM : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT elif ( ( j >> k ) & 1 ) == 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if isPrime [ pos ] == ( self . CROAK_SEQ [ k + 1 ] == ' P ' ) : NEW_LINE INDENT trialNumerator *= 2 NEW_LINE DEDENT DEDENT globalNumerator += trialNumerator NEW_LINE DEDENT DEDENT globalDenominator = ( self . END_NUM + 1 - self . START_NUM ) * ( 2 ** self . NUM_JUMPS ) * ( 3 ** len ( self . CROAK_SEQ ) ) NEW_LINE return str ( globalNumerator ) + " / " + str ( globalDenominator ) NEW_LINE DEDENT def is_prime ( self , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT print ( p329 ( ) . run ( ) ) NEW_LINE
import math NEW_LINE def distance ( lat1 , lat2 , lon1 , lon2 ) : NEW_LINE INDENT lon1 = math . radians ( lon1 ) NEW_LINE lon2 = math . radians ( lon2 ) NEW_LINE lat1 = math . radians ( lat1 ) NEW_LINE lat2 = math . radians ( lat2 ) NEW_LINE dlon = lon2 - lon1 NEW_LINE dlat = lat2 - lat1 NEW_LINE a = math . pow ( math . sin ( dlat / 2 ) , 2 ) + math . cos ( lat1 ) * math . cos ( lat2 ) * math . pow ( math . sin ( dlon / 2 ) , 2 ) NEW_LINE c = 2 * math . asin ( math . sqrt ( a ) ) NEW_LINE r = 6371 NEW_LINE return c * r NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT lat1 = 53.32055555555556 NEW_LINE lat2 = 53.31861111111111 NEW_LINE lon1 = - 1.7297222222222221 NEW_LINE lon2 = - 1.6997222222222223 NEW_LINE print ( distance ( lat1 , lat2 , lon1 , lon2 ) , " K . M " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def centeredOctahedral ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) // 3 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( centeredOctahedral ( n ) ) NEW_LINE n = 9 NEW_LINE print ( centeredOctahedral ( n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import copy NEW_LINE N = 0 NEW_LINE M = 0 NEW_LINE p = 0 NEW_LINE INF = 1 << 24 NEW_LINE min_val = 1 << 24 NEW_LINE Limit = 0 NEW_LINE isDist = [ ] NEW_LINE def main ( ) : NEW_LINE INDENT global N , M , p , Limit , isDist NEW_LINE N = int ( input ( ) ) NEW_LINE M = int ( input ( ) ) NEW_LINE p = int ( input ( ) ) NEW_LINE Limit = N * 50 NEW_LINE isDist = [ False ] * N NEW_LINE for _ in range ( M ) : NEW_LINE INDENT d = int ( input ( ) ) NEW_LINE isDist [ d ] = True NEW_LINE DEDENT isDist2 = copy . deepcopy ( isDist ) NEW_LINE solv ( 1 , p , 0 , 0 , False , isDist ) NEW_LINE solv ( - 1 , p , 0 , 0 , False , isDist2 ) NEW_LINE print ( min_val ) NEW_LINE DEDENT def solv ( vec , now , coun , cos , alC , isDist ) : NEW_LINE INDENT global min_val NEW_LINE nowp = now NEW_LINE cost = cos NEW_LINE count = coun NEW_LINE while True : NEW_LINE INDENT if min_val <= cost : NEW_LINE INDENT return NEW_LINE DEDENT if nowp == N : NEW_LINE INDENT nowp = 0 NEW_LINE DEDENT elif nowp == - 1 : NEW_LINE INDENT nowp = N - 1 NEW_LINE DEDENT if count == M : NEW_LINE INDENT if min_val > cost : NEW_LINE INDENT min_val = cost NEW_LINE DEDENT return NEW_LINE DEDENT if isDist [ nowp ] : NEW_LINE INDENT isDist [ nowp ] = False NEW_LINE count += 1 NEW_LINE if not alC and cost < Limit : NEW_LINE INDENT isDist2 = copy . deepcopy ( isDist ) NEW_LINE solv ( vec * - 1 , nowp + vec * - 1 , count , cost + 100 , True , isDist2 ) NEW_LINE DEDENT DEDENT if count == M : NEW_LINE INDENT if min_val > cost : NEW_LINE INDENT min_val = cost NEW_LINE DEDENT return NEW_LINE DEDENT while True : NEW_LINE INDENT if nowp == N : NEW_LINE INDENT nowp = 0 NEW_LINE DEDENT elif nowp == - 1 : NEW_LINE INDENT nowp = N - 1 NEW_LINE DEDENT if not isDist [ nowp ] : NEW_LINE INDENT nowp += vec NEW_LINE cost += 100 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT @ staticmethod NEW_LINE def max_element ( A ) : NEW_LINE INDENT max_val = float ( ' - inf ' ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if max_val < A [ i ] : NEW_LINE INDENT max_val = A [ i ] NEW_LINE DEDENT DEDENT return max_val NEW_LINE DEDENT @ staticmethod NEW_LINE def SumDivPrime ( A , n ) : NEW_LINE INDENT max_val = Solution . max_element ( A ) + 1 NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT sum_val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ A [ i ] ] : NEW_LINE INDENT sum_val += A [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if prime [ A [ i ] ] and sum_val % A [ i ] == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE Solution . SumDivPrime ( A , n ) NEW_LINE DEDENT DEDENT Solution . main ( ) NEW_LINE ` ` ` NEW_LINE
import java NEW_LINE class GFG : NEW_LINE INDENT def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( arr [ i % n ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE GFG . leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 3 NEW_LINE GFG . leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 4 NEW_LINE GFG . leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x NEW_LINE DEDENT n = n + x // 2 NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 56287 NEW_LINE x = 27 NEW_LINE print ( closestMultiple ( n , x ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class compititive_programmer : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE input ( ) NEW_LINE while t != 0 : NEW_LINE INDENT t -= 1 NEW_LINE s = input ( ) NEW_LINE zero = 0 NEW_LINE sum = 0 NEW_LINE even = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE if s [ i ] == '0' : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ord ( s [ i ] ) % 2 == 0 and s [ i ] != '0' : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if zero != len ( s ) and ( ( even == 0 and zero == 1 ) or zero == 0 or sum % 3 != 0 ) : NEW_LINE INDENT print ( " cyan " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " red " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import numpy as np NEW_LINE dp = np . full ( ( 901 , 8101 ) , - 1 , dtype = int ) NEW_LINE def minimumNumberOfDigits ( a , b ) : NEW_LINE INDENT if a > b or a < 0 or b < 0 or a > 900 or b > 8100 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if a == 0 and b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ a ] [ b ] != - 1 : NEW_LINE INDENT return dp [ a ] [ b ] NEW_LINE DEDENT ans = 101 NEW_LINE for i in range ( 9 , 0 , - 1 ) : NEW_LINE INDENT k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) NEW_LINE if k != - 1 : NEW_LINE INDENT ans = min ( ans , k + 1 ) NEW_LINE DEDENT DEDENT dp [ a ] [ b ] = ans NEW_LINE return ans NEW_LINE DEDENT def printSmallestNumber ( a , b ) : NEW_LINE INDENT dp . fill ( - 1 ) NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE k = minimumNumberOfDigits ( a , b ) NEW_LINE if k == - 1 or k > 100 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT while a > 0 and b > 0 : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if a >= i and b >= i * i and 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE a -= i NEW_LINE b -= i * i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT a = 18 NEW_LINE b = 162 NEW_LINE printSmallestNumber ( a , b ) NEW_LINE ` ` ` NEW_LINE
import collections NEW_LINE class GFG : NEW_LINE INDENT N = 5005 NEW_LINE n = 0 NEW_LINE k = 0 NEW_LINE gr = [ [ ] for _ in range ( N ) ] NEW_LINE d = [ [ 0 ] * 505 for _ in range ( N ) ] NEW_LINE ans = 0 NEW_LINE @ staticmethod NEW_LINE def add_edge ( x , y ) : NEW_LINE INDENT GFG . gr [ x ] . append ( y ) NEW_LINE GFG . gr [ y ] . append ( x ) NEW_LINE DEDENT @ staticmethod NEW_LINE def dfs ( v , par ) : NEW_LINE INDENT GFG . d [ v ] [ 0 ] = 1 NEW_LINE for i in GFG . gr [ v ] : NEW_LINE INDENT if i != par : NEW_LINE INDENT GFG . dfs ( i , v ) NEW_LINE for j in range ( 1 , GFG . k + 1 ) : NEW_LINE INDENT GFG . ans += GFG . d [ i ] [ j - 1 ] * GFG . d [ v ] [ GFG . k - j ] NEW_LINE DEDENT for j in range ( 1 , GFG . k + 1 ) : NEW_LINE INDENT GFG . d [ v ] [ j ] += GFG . d [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT GFG . n = 5 NEW_LINE GFG . k = 2 NEW_LINE for i in range ( GFG . N ) : NEW_LINE INDENT GFG . gr [ i ] = [ ] NEW_LINE DEDENT GFG . add_edge ( 1 , 2 ) NEW_LINE GFG . add_edge ( 2 , 3 ) NEW_LINE GFG . add_edge ( 3 , 4 ) NEW_LINE GFG . add_edge ( 2 , 5 ) NEW_LINE GFG . dfs ( 1 , 0 ) NEW_LINE print ( GFG . ans ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def findSubsequence ( arr , n ) : NEW_LINE INDENT len = 1 NEW_LINE tmp = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE d = 0 NEW_LINE dp = [ 0 ] * 10 NEW_LINE cnt = [ 0 ] * 10 NEW_LINE locMax = 0 NEW_LINE tmp = arr [ 0 ] NEW_LINE while tmp > 0 : NEW_LINE INDENT dp [ tmp % 10 ] = 1 NEW_LINE tmp //= 10 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE locMax = 1 NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while tmp > 0 : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 NEW_LINE tmp //= 10 NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if cnt [ d ] == 1 : NEW_LINE INDENT dp [ d ] += 1 NEW_LINE locMax = max ( locMax , dp [ d ] ) NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if cnt [ d ] == 1 : NEW_LINE INDENT dp [ d ] = locMax NEW_LINE DEDENT DEDENT len = max ( len , locMax ) NEW_LINE DEDENT return len NEW_LINE DEDENT arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if int ( input ( ) ) in s : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GCD : NEW_LINE INDENT @ staticmethod NEW_LINE def totalPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT @ staticmethod NEW_LINE def countPairs ( G , L ) : NEW_LINE INDENT if L % G != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT div = L // G NEW_LINE return 1 << GCD . totalPrimeFactors ( div ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT G = 2 NEW_LINE L = 12 NEW_LINE print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ " + str ( G ) , end = " " ) NEW_LINE print ( " ▁ & ▁ LCM ▁ " + str ( L ) , end = " " ) NEW_LINE print ( " ▁ = ▁ " + str ( GCD . countPairs ( G , L ) ) , end = " " ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def calculate_sum ( a , N ) : NEW_LINE INDENT m = N // a NEW_LINE sum = m * ( m + 1 ) // 2 NEW_LINE ans = a * sum NEW_LINE return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = 7 NEW_LINE N = 49 NEW_LINE print ( " Sum ▁ of ▁ multiples ▁ of ▁ " + str ( a ) + " ▁ up ▁ to ▁ " + str ( N ) + " ▁ = ▁ " + str ( GFG . calculate_sum ( a , N ) ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE skills = { } NEW_LINE for _ in range ( n ) : NEW_LINE INDENT skill_name , skill_score = input ( ) . split ( ) NEW_LINE skill_score = int ( skill_score ) NEW_LINE new_skill_score = int ( skill_score * k / 100 ) NEW_LINE if new_skill_score < 100 : NEW_LINE INDENT continue NEW_LINE DEDENT skills [ skill_name ] = new_skill_score NEW_LINE DEDENT for _ in range ( m ) : NEW_LINE INDENT skill_name = input ( ) NEW_LINE if skill_name not in skills : NEW_LINE INDENT skills [ skill_name ] = 0 NEW_LINE DEDENT DEDENT print ( len ( skills ) ) NEW_LINE for skill , score in skills . items ( ) : NEW_LINE INDENT print ( skill , score ) NEW_LINE DEDENT sys . stdout . flush ( ) NEW_LINE
import math NEW_LINE def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT if a == ( i + ( a ^ i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def next ( arr , target ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( arr ) - 1 NEW_LINE ans = - 1 NEW_LINE while start <= end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if arr [ mid ] <= target : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 5 , 8 , 12 ] NEW_LINE print ( GFG . next ( arr , 8 ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT word = [ " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " ] NEW_LINE @ staticmethod NEW_LINE def printWordsWithoutIfSwitch ( n ) : NEW_LINE INDENT digits = [ 0 ] * 10 NEW_LINE dc = 0 NEW_LINE while n != 0 : NEW_LINE INDENT digits [ dc ] = n % 10 NEW_LINE n = n // 10 NEW_LINE dc += 1 NEW_LINE DEDENT for i in range ( dc - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( GFG . word [ digits [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 350 NEW_LINE GFG . printWordsWithoutIfSwitch ( n ) NEW_LINE DEDENT DEDENT gfg = GFG ( ) NEW_LINE gfg . main ( ) NEW_LINE
import sys NEW_LINE n , k , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE sum = 0 NEW_LINE for num in a : NEW_LINE INDENT sum += num NEW_LINE DEDENT max = ( sum + min ( m , n * k ) ) / n NEW_LINE for i in range ( 1 , min ( n , m + 1 ) ) : NEW_LINE INDENT sum -= a [ i - 1 ] NEW_LINE max = max ( max , ( sum + min ( m - i , ( n - i ) * k ) ) / ( n - i ) ) NEW_LINE DEDENT print ( " { : . 20f } " . format ( max ) ) NEW_LINE
class GFG : NEW_LINE INDENT def solve ( a , b ) : NEW_LINE INDENT l = len ( a ) NEW_LINE min_val = 0 NEW_LINE max_val = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if a [ i ] == ' + ' or b [ i ] == ' + ' or a [ i ] != b [ i ] : NEW_LINE INDENT max_val += 1 NEW_LINE DEDENT if a [ i ] != ' + ' and b [ i ] != ' + ' and a [ i ] != b [ i ] : NEW_LINE INDENT min_val += 1 NEW_LINE DEDENT DEDENT print ( min_val + max_val ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " a + c " NEW_LINE s2 = " + + b " NEW_LINE solve ( list ( s1 ) , list ( s2 ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def TotalWays ( n , s , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ s - 1 ] = 1 NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE s = 2 NEW_LINE print ( " Total ▁ Ways ▁ = ▁ " + str ( GFG . TotalWays ( n , s , k ) ) ) NEW_LINE DEDENT DEDENT
import java NEW_LINE def countEvenOdd ( n ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE if rem % 2 == 0 : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT print ( " Even ▁ count ▁ : ▁ " + str ( even_count ) ) NEW_LINE print ( " Odd ▁ count ▁ : ▁ " + str ( odd_count ) ) NEW_LINE if even_count % 2 == 0 and odd_count % 2 != 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2335453 NEW_LINE t = countEvenOdd ( n ) NEW_LINE if t == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE lists = [ [ ] for _ in range ( 10 ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT c , g = map ( int , input ( ) . split ( ) ) NEW_LINE lists [ g - 1 ] . append ( c ) NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT lists [ i ] . sort ( reverse = True ) NEW_LINE for j in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if dp [ j ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT total = 0 NEW_LINE for l in range ( len ( lists [ i ] ) ) : NEW_LINE INDENT if j + l < k : NEW_LINE INDENT total += lists [ i ] [ l ] NEW_LINE dp [ j + l + 1 ] = max ( dp [ j + l + 1 ] , dp [ j ] + total + ( l + 1 ) * l ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( dp [ k ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
from typing import List NEW_LINE class GFG : NEW_LINE INDENT class Point : NEW_LINE INDENT def __init__ ( self , x : int , y : int ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def findmin ( p : List [ Point ] , n : int ) -> int : NEW_LINE INDENT a , b , c , d = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] . x <= 0 : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif p [ i ] . x >= 0 : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if p [ i ] . y >= 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif p [ i ] . y <= 0 : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( min ( a , b ) , min ( c , d ) ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args : List [ str ] ) : NEW_LINE INDENT p = [ GFG . Point ( 1 , 1 ) , GFG . Point ( 2 , 2 ) , GFG . Point ( - 1 , - 1 ) , GFG . Point ( - 2 , 2 ) ] NEW_LINE n = len ( p ) NEW_LINE print ( GFG . findmin ( p , n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT @ staticmethod NEW_LINE def maxGCD ( N , P ) : NEW_LINE INDENT ans = 1 NEW_LINE prime_factors = { } NEW_LINE i = 2 NEW_LINE while i * i <= P : NEW_LINE INDENT while P % i == 0 : NEW_LINE INDENT if i not in prime_factors : NEW_LINE INDENT prime_factors [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime_factors [ i ] += 1 NEW_LINE DEDENT P //= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if P != 1 : NEW_LINE INDENT if P not in prime_factors : NEW_LINE INDENT prime_factors [ P ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime_factors [ P ] += 1 NEW_LINE DEDENT DEDENT for key , value in prime_factors . items ( ) : NEW_LINE INDENT ans *= key ** ( value // N ) NEW_LINE DEDENT return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT N = 3 NEW_LINE P = 24 NEW_LINE print ( Solution . maxGCD ( N , P ) ) NEW_LINE DEDENT DEDENT Solution . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE mask = [ int ( input ( ) ) for _ in range ( k ) ] NEW_LINE for i in range ( 2 ** k ) : NEW_LINE INDENT bitArray = [ 0 ] * n NEW_LINE temp = i NEW_LINE index = 0 NEW_LINE j = 0 NEW_LINE while temp > 0 : NEW_LINE INDENT if temp % 2 == 1 : NEW_LINE INDENT bitArray [ mask [ j ] ] = 1 NEW_LINE index += 2 ** mask [ j ] NEW_LINE DEDENT temp //= 2 NEW_LINE j += 1 NEW_LINE DEDENT print ( index , end = " : " ) NEW_LINE for j in range ( k ) : NEW_LINE INDENT if bitArray [ mask [ j ] ] == 1 : NEW_LINE INDENT print ( " ▁ " + str ( mask [ j ] ) , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT class primeFactorization : NEW_LINE INDENT def __init__ ( self , countOfPf , primeFactor ) : NEW_LINE INDENT self . countOfPf = countOfPf NEW_LINE self . primeFactor = primeFactor NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def generateDivisors ( curIndex , curDivisor , arr ) : NEW_LINE INDENT if curIndex == len ( arr ) : NEW_LINE INDENT print ( curDivisor , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT for i in range ( arr [ curIndex ] . countOfPf + 1 ) : NEW_LINE INDENT GFG . generateDivisors ( curIndex + 1 , curDivisor , arr ) NEW_LINE curDivisor *= arr [ curIndex ] . primeFactor NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def findDivisors ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT count = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT n //= i NEW_LINE count += 1 NEW_LINE DEDENT arr . append ( GFG . primeFactorization ( count , i ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n > 1 : NEW_LINE INDENT arr . append ( GFG . primeFactorization ( 1 , n ) ) NEW_LINE DEDENT curIndex , curDivisor = 0 , 1 NEW_LINE GFG . generateDivisors ( curIndex , curDivisor , arr ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT n = 6 NEW_LINE GFG . findDivisors ( n ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT max_val = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE beacon = [ 0 ] * 1000001 NEW_LINE dp = [ 0 ] * 1000001 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE beacon [ a ] = b NEW_LINE DEDENT if beacon [ 0 ] != 0 : NEW_LINE INDENT dp [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , 1000001 ) : NEW_LINE INDENT if beacon [ i ] != 0 and beacon [ i ] < i : NEW_LINE INDENT dp [ i ] = dp [ i - beacon [ i ] - 1 ] + 1 NEW_LINE DEDENT elif beacon [ i ] != 0 : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE DEDENT max_val = max ( max_val , dp [ i ] ) NEW_LINE DEDENT print ( n - max_val ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def largestPalinSub ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = input ( ) NEW_LINE t = 0 NEW_LINE u = " " NEW_LINE for k in range ( n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT count = 1 NEW_LINE t = s [ i ] NEW_LINE while i < len ( s ) - 1 and s [ i + 1 ] == t : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT u += str ( count ) + t NEW_LINE i += 1 NEW_LINE DEDENT s = u NEW_LINE u = " " NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE dp = [ 0 ] * 100001 NEW_LINE def factoriseopt ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE if n == 1 : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE return ans NEW_LINE DEDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT cnt = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // i NEW_LINE DEDENT ans . append ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n != 1 : NEW_LINE INDENT ans . append ( n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ansArrayList = factoriseopt ( arr [ i ] ) NEW_LINE best = 0 NEW_LINE for x in ansArrayList : NEW_LINE INDENT best = max ( best , dp [ x ] ) NEW_LINE DEDENT for x in ansArrayList : NEW_LINE INDENT dp [ x ] = best + 1 NEW_LINE DEDENT DEDENT maxsofar = 0 NEW_LINE for x in dp : NEW_LINE INDENT maxsofar = max ( maxsofar , x ) NEW_LINE DEDENT print ( maxsofar ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def initializeDiffArray ( A , D ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D [ 0 ] = A [ 0 ] NEW_LINE D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT A [ i ] = D [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE return 0 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE n = len ( A ) NEW_LINE D = [ 0 ] * ( n + 1 ) NEW_LINE GFG . initializeDiffArray ( A , D ) NEW_LINE GFG . update ( D , 0 , 1 , 10 ) NEW_LINE GFG . printArray ( A , D ) NEW_LINE GFG . update ( D , 1 , 3 , 20 ) NEW_LINE GFG . update ( D , 2 , 2 , 30 ) NEW_LINE GFG . printArray ( A , D ) NEW_LINE DEDENT DEDENT
import numpy as np NEW_LINE def findMaxGuests ( arrl , exit , n ) : NEW_LINE INDENT arrl = np . sort ( arrl ) NEW_LINE exit = np . sort ( exit ) NEW_LINE guests_in = 1 NEW_LINE max_guests = 1 NEW_LINE time = arrl [ 0 ] NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while i < n and j < n : NEW_LINE INDENT if arrl [ i ] <= exit [ j ] : NEW_LINE INDENT guests_in += 1 NEW_LINE if guests_in > max_guests : NEW_LINE INDENT max_guests = guests_in NEW_LINE time = arrl [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT guests_in -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " + str ( max_guests ) + " ▁ at ▁ time ▁ " + str ( time ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arrl = np . array ( [ 1 , 2 , 10 , 5 , 5 ] ) NEW_LINE exit = np . array ( [ 4 , 5 , 12 , 9 , 12 ] ) NEW_LINE n = len ( arrl ) NEW_LINE findMaxGuests ( arrl , exit , n ) NEW_LINE DEDENT
import sys NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = sys . stdin NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT in_str = input ( ) NEW_LINE if in_str == " # END " : NEW_LINE INDENT return NEW_LINE DEDENT ans = " " NEW_LINE for i in range ( 1 , len ( in_str ) ) : NEW_LINE INDENT lcs_str = self . lcs ( in_str [ : i ] , in_str [ i : ] ) NEW_LINE if len ( lcs_str ) > len ( ans ) : NEW_LINE INDENT ans = lcs_str NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT def lcs ( self , s , t ) : NEW_LINE INDENT n = len ( s ) NEW_LINE m = len ( t ) NEW_LINE dp = [ [ 0 ] * ( m + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if s [ i ] == t [ j ] : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = [ ' ' ] * dp [ n ] [ m ] NEW_LINE while n > 0 and m > 0 : NEW_LINE INDENT if dp [ n ] [ m ] == dp [ n - 1 ] [ m ] : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT elif dp [ n ] [ m ] == dp [ n ] [ m - 1 ] : NEW_LINE INDENT m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res [ dp [ n ] [ m ] - 1 ] = s [ n - 1 ] NEW_LINE n -= 1 NEW_LINE m -= 1 NEW_LINE DEDENT DEDENT return ' ' . join ( res ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def calcFunction ( n , r ) : NEW_LINE INDENT finalDenominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = i ** i NEW_LINE numerator = ( i - mx ) ** ( i - mx ) NEW_LINE finalDenominator = ( finalDenominator * denominator ) // numerator NEW_LINE DEDENT return finalDenominator NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 6 NEW_LINE r = 2 NEW_LINE print ( "1 / " + str ( calcFunction ( n , r ) ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = int ( math . sqrt ( x ) ) NEW_LINE if sr * sr == x : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 7 NEW_LINE k = 2 NEW_LINE isPerfectSquare ( n + k ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from queue import PriorityQueue NEW_LINE NUM = int ( 1e5 + 2 ) NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE map = { } NEW_LINE nums = PriorityQueue ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = int ( input ( ) ) NEW_LINE nums . put ( tmp ) NEW_LINE map [ tmp ] = i NEW_LINE DEDENT bin = 0 NEW_LINE diff = 0 NEW_LINE while not nums . empty ( ) : NEW_LINE INDENT num = nums . get ( ) NEW_LINE idx = map [ num ] NEW_LINE if ( bin % 2 ) != ( idx % 2 ) : NEW_LINE INDENT diff += 1 NEW_LINE DEDENT bin += 1 NEW_LINE bin %= 2 NEW_LINE DEDENT ans = diff // 2 NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( set ( a ) ) NEW_LINE a . sort ( ) NEW_LINE found = False NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if i + 2 < len ( a ) : NEW_LINE INDENT if a [ i ] + 1 == a [ i + 1 ] and a [ i + 1 ] + 1 == a [ i + 2 ] : NEW_LINE INDENT found = True NEW_LINE DEDENT DEDENT DEDENT print ( " YES " if found else " NO " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def check ( b ) : NEW_LINE INDENT if b [ 0 ] != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 1 , len ( b ) ) : NEW_LINE INDENT if b [ i - 1 ] != b [ i ] - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def gap ( b ) : NEW_LINE INDENT for i in range ( len ( b ) ) : NEW_LINE INDENT if b [ i ] <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def remove_gap ( b ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( b ) : NEW_LINE INDENT if b [ i ] <= 0 : NEW_LINE INDENT b . pop ( i ) NEW_LINE i -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT b . trimToSize ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT list = [ ] NEW_LINE while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT list . append ( int ( input ( ) ) ) NEW_LINE DEDENT c = 0 NEW_LINE while not check ( list ) and c < 10000 : NEW_LINE INDENT c += 1 NEW_LINE if gap ( list ) : NEW_LINE INDENT size = len ( list ) NEW_LINE for i in range ( len ( list ) ) : NEW_LINE INDENT list [ i ] -= 1 NEW_LINE DEDENT list . append ( size ) NEW_LINE DEDENT remove_gap ( list ) NEW_LINE DEDENT print ( c if check ( list ) else - 1 ) NEW_LINE list . clear ( ) NEW_LINE list . trimToSize ( ) NEW_LINE gc . collect ( ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def isDivisible ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if S [ n - 1 ] != '5' and S [ n - 1 ] != '0' : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT sum += int ( S [ i ] ) NEW_LINE DEDENT if sum % 3 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT S = "15645746327462384723984023940239" NEW_LINE if GFG . isDivisible ( S ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT S1 = "15645746327462384723984023940235" NEW_LINE if GFG . isDivisible ( S1 ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
class p142 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . isSquare = [ ] NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT sumLimit = 10 NEW_LINE while True : NEW_LINE INDENT self . isSquare = [ False ] * sumLimit NEW_LINE i = 0 NEW_LINE while i * i < sumLimit : NEW_LINE INDENT self . isSquare [ i * i ] = True NEW_LINE i += 1 NEW_LINE DEDENT sum_val = self . findSum ( sumLimit ) NEW_LINE if sum_val != - 1 : NEW_LINE INDENT sum_val = sumLimit NEW_LINE break NEW_LINE DEDENT sumLimit *= 10 NEW_LINE DEDENT while True : NEW_LINE INDENT sum_val = self . findSum ( sumLimit ) NEW_LINE if sum_val == - 1 : NEW_LINE INDENT return str ( sumLimit ) NEW_LINE DEDENT sumLimit = sum_val NEW_LINE DEDENT DEDENT def findSum ( self , limit ) : NEW_LINE INDENT for a in range ( 1 , limit ) : NEW_LINE INDENT if a * a >= limit : NEW_LINE INDENT break NEW_LINE DEDENT for b in range ( a - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( a + b ) % 2 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT x = ( a * a + b * b ) // 2 NEW_LINE y = ( a * a - b * b ) // 2 NEW_LINE if x + y + 1 >= limit : NEW_LINE INDENT continue NEW_LINE DEDENT zlimit = min ( y , limit - x - y ) NEW_LINE c = int ( y ** 0.5 ) + 1 NEW_LINE while c * c - y < zlimit : NEW_LINE INDENT z = c * c - y NEW_LINE if self . isSquare [ x + z ] and self . isSquare [ x - z ] and self . isSquare [ y - z ] : NEW_LINE INDENT return x + y + z NEW_LINE DEDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT print ( p142 ( ) . run ( ) ) NEW_LINE
def isVowel ( c ) : NEW_LINE INDENT return c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE ans = " " NEW_LINE for l in range ( n - k + 1 ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE for r in range ( l , l + k ) : NEW_LINE INDENT if isVowel ( s [ r ] ) : NEW_LINE INDENT countVowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countConsonants += 1 NEW_LINE DEDENT DEDENT ans += str ( countVowels * countConsonants ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = " hello " NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT return a if b == 0 else gcd ( b , a % b ) NEW_LINE DEDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE S , T = input ( ) , input ( ) NEW_LINE gcdNM = gcd ( N , M ) NEW_LINE lcmNM = ( N // gcd ( N , M ) ) * M NEW_LINE stepS = M // gcdNM NEW_LINE stepT = N // gcdNM NEW_LINE curS , curT = 0 , 0 NEW_LINE isExisted = True NEW_LINE while curS < len ( S ) and curT < len ( T ) : NEW_LINE INDENT idxXS = curS * stepS + 1 NEW_LINE idxXT = curT * stepT + 1 NEW_LINE if idxXS == idxXT : NEW_LINE INDENT if S [ curS ] != T [ curT ] : NEW_LINE INDENT isExisted = False NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT curS += 1 NEW_LINE curT += 1 NEW_LINE DEDENT DEDENT elif idxXS < idxXT : NEW_LINE INDENT curS += 1 NEW_LINE DEDENT elif idxXT < idxXS : NEW_LINE INDENT curT += 1 NEW_LINE DEDENT DEDENT if isExisted : NEW_LINE INDENT print ( lcmNM ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE black = [ [ 0 for _ in range ( N + 2 ) ] for _ in range ( N + 2 ) ] NEW_LINE for m in range ( 1 , M + 1 ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE for xx in range ( x - 1 , x + 2 ) : NEW_LINE INDENT for yy in range ( y - 1 , y + 2 ) : NEW_LINE INDENT black [ xx ] [ yy ] += 1 NEW_LINE if black [ xx ] [ yy ] == 9 : NEW_LINE INDENT print ( m ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " - 1" ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE dx = [ 1 , 1 , 0 , - 1 ] NEW_LINE dy = [ 0 , 1 , 1 , 1 ] NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ [ 0 for _ in range ( n ) ] for _ in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT a [ i ] [ j ] = int ( s [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( 4 ) : NEW_LINE INDENT cnt = 0 NEW_LINE sy = i NEW_LINE sx = j NEW_LINE while 0 <= sx < n and sy < n and a [ sy ] [ sx ] == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE sx += dx [ k ] NEW_LINE sy += dy [ k ] NEW_LINE DEDENT ans = max ( ans , cnt ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import math NEW_LINE def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def maxLengthSub ( arr ) : NEW_LINE INDENT max_val = 0 NEW_LINE start = 0 NEW_LINE map = { } NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT temp = 0 NEW_LINE if arr [ i ] - 1 in map : NEW_LINE INDENT temp = map [ arr [ i ] - 1 ] NEW_LINE DEDENT if arr [ i ] in map : NEW_LINE INDENT temp = max ( temp , map [ arr [ i ] ] ) NEW_LINE DEDENT if arr [ i ] + 1 in map : NEW_LINE INDENT temp = max ( temp , map [ arr [ i ] + 1 ] ) NEW_LINE DEDENT temp += 1 NEW_LINE if temp > max_val : NEW_LINE INDENT max_val = temp NEW_LINE DEDENT map [ arr [ i ] ] = temp NEW_LINE DEDENT return max_val NEW_LINE DEDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] NEW_LINE print ( " Maximum ▁ length ▁ subsequence ▁ = ▁ " + str ( maxLengthSub ( arr ) ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import java NEW_LINE def rearrange ( arr ) : NEW_LINE INDENT if arr is None or len ( arr ) % 2 == 1 : NEW_LINE INDENT return NEW_LINE DEDENT currIdx = ( len ( arr ) - 1 ) // 2 NEW_LINE while currIdx > 0 : NEW_LINE INDENT count = currIdx NEW_LINE swapIdx = currIdx NEW_LINE while count > 0 : NEW_LINE INDENT temp = arr [ swapIdx + 1 ] NEW_LINE arr [ swapIdx + 1 ] = arr [ swapIdx ] NEW_LINE arr [ swapIdx ] = temp NEW_LINE swapIdx += 1 NEW_LINE count -= 1 NEW_LINE DEDENT currIdx -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 2 , 4 , 6 ] NEW_LINE rearrange ( arr ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( " ▁ " + str ( arr [ i ] ) , end = " " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE INF = 1 << 58 NEW_LINE while True : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n | k == 0 : NEW_LINE INDENT break NEW_LINE DEDENT fare = [ [ INF ] * n for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT fare [ i ] [ i ] = 0 NEW_LINE DEDENT for _ in range ( k ) : NEW_LINE INDENT init = int ( input ( ) ) NEW_LINE if init == 1 : NEW_LINE INDENT c , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE c , d = c - 1 , d - 1 NEW_LINE if e < fare [ c ] [ d ] : NEW_LINE INDENT fare [ c ] [ d ] = fare [ d ] [ c ] = e NEW_LINE for p in range ( n ) : NEW_LINE INDENT for q in range ( n ) : NEW_LINE INDENT fare [ p ] [ q ] = min ( fare [ p ] [ q ] , fare [ p ] [ c ] + fare [ c ] [ d ] + fare [ d ] [ q ] ) NEW_LINE fare [ p ] [ q ] = min ( fare [ p ] [ q ] , fare [ p ] [ d ] + fare [ c ] [ d ] + fare [ c ] [ q ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = a - 1 , b - 1 NEW_LINE print ( fare [ a ] [ b ] if fare [ a ] [ b ] != INF else - 1 ) NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ch >= '0' and ch <= '9' : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( " Vowels : " , vowels ) NEW_LINE print ( " Consonant : " , consonant ) NEW_LINE print ( " Digit : " , digit ) NEW_LINE print ( " Special ▁ Character : " , specialChar ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeks ▁ for ▁ geeks121" NEW_LINE countCharacterType ( str ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def increaseInVol ( l , b , h ) : NEW_LINE INDENT percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) NEW_LINE percentInc -= 1 NEW_LINE percentInc *= 100 NEW_LINE return percentInc NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT l , b , h = 50 , 20 , 10 NEW_LINE print ( str ( self . increaseInVol ( l , b , h ) ) + " % " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import java NEW_LINE import java . util NEW_LINE def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and not flag : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT a = [ 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxTotalRectangleArea ( a , n ) ) NEW_LINE
class GFG : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def getNode ( data ) : NEW_LINE INDENT new_node = GFG . Node ( ) NEW_LINE new_node . data = data NEW_LINE return new_node NEW_LINE DEDENT @ staticmethod NEW_LINE def insertEnd ( head , new_node ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT last = head . prev NEW_LINE new_node . next = head NEW_LINE head . prev = new_node NEW_LINE new_node . prev = last NEW_LINE last . next = new_node NEW_LINE return head NEW_LINE DEDENT @ staticmethod NEW_LINE def reverse ( head ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE last = head . prev NEW_LINE curr = last NEW_LINE while curr . prev != last : NEW_LINE INDENT prev = curr . prev NEW_LINE new_head = GFG . insertEnd ( new_head , curr ) NEW_LINE curr = prev NEW_LINE DEDENT new_head = GFG . insertEnd ( new_head , curr ) NEW_LINE return new_head NEW_LINE DEDENT @ staticmethod NEW_LINE def display ( head ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print ( " Forward ▁ direction : ▁ " , end = " " ) NEW_LINE while temp . next != head : NEW_LINE INDENT print ( temp . data , end = " ▁ " ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data , end = " ▁ " ) NEW_LINE last = head . prev NEW_LINE temp = last NEW_LINE print ( " \n Backward ▁ direction : ▁ " , end = " " ) NEW_LINE while temp . prev != last : NEW_LINE INDENT print ( temp . data , end = " ▁ " ) NEW_LINE temp = temp . prev NEW_LINE DEDENT print ( temp . data , end = " ▁ " ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT head = None NEW_LINE head = GFG . insertEnd ( head , GFG . getNode ( 1 ) ) NEW_LINE head = GFG . insertEnd ( head , GFG . getNode ( 2 ) ) NEW_LINE head = GFG . insertEnd ( head , GFG . getNode ( 3 ) ) NEW_LINE head = GFG . insertEnd ( head , GFG . getNode ( 4 ) ) NEW_LINE head = GFG . insertEnd ( head , GFG . getNode ( 5 ) ) NEW_LINE print ( " Current ▁ list : " ) NEW_LINE GFG . display ( head ) NEW_LINE head = GFG . reverse ( head ) NEW_LINE print ( " \n \n Reversed ▁ list : " ) NEW_LINE GFG . display ( head ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT GFG . main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def lastFiveDigits ( n ) : NEW_LINE INDENT n = ( n // 10000 ) * 10000 + ( ( n // 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n // 10 ) % 10 ) * 10 + ( n // 1000 ) % 10 NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 12345 NEW_LINE GFG . lastFiveDigits ( n ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
from math import isqrt NEW_LINE class p080 : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT return self . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , 101 ) : NEW_LINE INDENT x = i NEW_LINE x *= 10 ** ( 100 * 2 ) NEW_LINE y = self . sqrt ( x ) NEW_LINE if y * y != x : NEW_LINE INDENT s = str ( y ) [ : 100 ] NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT sum += int ( s [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT def sqrt ( self , x ) : NEW_LINE INDENT i = 0 NEW_LINE while 10 ** ( i * 2 ) <= x : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = 0 NEW_LINE for _ in range ( i , - 1 , - 1 ) : NEW_LINE INDENT j = 9 NEW_LINE delta = None NEW_LINE while j >= 0 : NEW_LINE INDENT temp = j * 10 ** _ NEW_LINE delta = ( y << 1 ) + temp * temp NEW_LINE if delta <= x : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT if j < 0 : NEW_LINE INDENT raise AssertionError NEW_LINE DEDENT x -= delta NEW_LINE y += j * 10 ** _ NEW_LINE DEDENT return y NEW_LINE DEDENT DEDENT p = p080 ( ) NEW_LINE print ( p . main ( ) ) NEW_LINE
import math NEW_LINE def evaluate ( n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT print ( " No ▁ Pythagoras ▁ Triplet ▁ exists " ) NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT var = 1 * n * n / 4 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . ▁ " , end = " " ) NEW_LINE print ( n , var - 1 , var + 1 ) NEW_LINE DEDENT elif n % 2 != 0 : NEW_LINE INDENT var = 1 * n * n + 1 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . ▁ " , end = " " ) NEW_LINE print ( n , var // 2 - 1 , var // 2 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 22 NEW_LINE evaluate ( n ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT a , b , x = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE count = 0 NEW_LINE count += b // x + 1 NEW_LINE if a != 0 : NEW_LINE INDENT count -= ( a - 1 ) // x + 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findNumber ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == ans : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findNumber ( arr , n ) ) NEW_LINE
class GFG : NEW_LINE INDENT def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rem = A [ i ] % K NEW_LINE if rem != 0 : NEW_LINE INDENT ans += freq [ K - rem ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += freq [ 0 ] NEW_LINE DEDENT freq [ rem ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = len ( A ) NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE DEDENT DEDENT
import re NEW_LINE def main ( ) : NEW_LINE INDENT input_str = input ( ) NEW_LINE a , b , c = re . split ( ' , ' , input_str ) NEW_LINE print ( a , b , c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE nums = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l , r = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l == 0 and nums [ n - i - 1 ] != nums [ 0 ] : NEW_LINE INDENT l = n - i - 1 NEW_LINE DEDENT if r == 0 and nums [ i ] != nums [ n - 1 ] : NEW_LINE INDENT r = n - i - 1 NEW_LINE DEDENT DEDENT print ( max ( l , r ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) == 1 : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if difference < 0 : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays ▁ are " , countSubarrays ( arr , n ) ) NEW_LINE DEDENT DEDENT
SIZE = 26 NEW_LINE def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 0 : NEW_LINE INDENT print ( str [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 1 : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE GFG . printChar ( str , n ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE
class GFG : NEW_LINE INDENT def countGreater ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE leftGreater = n NEW_LINE while l <= r : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if arr [ m ] > k : NEW_LINE INDENT leftGreater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return n - leftGreater NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 7 NEW_LINE print ( countGreater ( arr , n , k ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . INF = 1 << 28 NEW_LINE self . EPS = 1e-10 NEW_LINE self . MOD = 1000000 NEW_LINE self . es = [ [ 0 , 1 , 2 , 3 ] , [ 0 , 1 , 2 ] , [ 0 , 1 , 2 , 4 ] , [ 2 , 3 ] , [ 0 , 4 ] ] NEW_LINE self . len = 5 NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE if w == 1 : NEW_LINE INDENT ret = 1 NEW_LINE for i in range ( h ) : NEW_LINE INDENT ret = ret * 2 % self . MOD NEW_LINE DEDENT print ( ret ) NEW_LINE return NEW_LINE DEDENT cnt = [ [ 0 ] * self . len for _ in range ( 2 ) ] NEW_LINE cnt [ 0 ] [ 0 ] = 1 NEW_LINE p = 1 NEW_LINE for i in range ( h + 1 ) : NEW_LINE INDENT cnt [ p ] = [ 0 ] * self . len NEW_LINE for j in range ( self . len ) : NEW_LINE INDENT for k in range ( len ( self . es [ j ] ) ) : NEW_LINE INDENT cnt [ p ] [ self . es [ j ] [ k ] ] = ( cnt [ p ] [ self . es [ j ] [ k ] ] + cnt [ 1 - p ] [ j ] ) % self . MOD NEW_LINE DEDENT DEDENT p = 1 - p NEW_LINE DEDENT print ( cnt [ 1 - p ] [ 2 ] ) NEW_LINE DEDENT def debug ( self , * os ) : NEW_LINE INDENT print ( os , file = sys . stderr ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if val < 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT a = ( N + math . sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - math . sqrt ( val ) ) / 2.0 NEW_LINE print ( " a ▁ = ▁ " , a ) NEW_LINE print ( " b ▁ = ▁ " , b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 69.0 NEW_LINE findAandB ( N ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE while t != 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE temp1 = float ( ' - inf ' ) NEW_LINE temp2 = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE temp1 = max ( temp1 , x ) NEW_LINE temp2 = min ( temp2 , y ) NEW_LINE DEDENT print ( max ( 0 , temp1 - temp2 ) ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT set = set ( ) NEW_LINE n = 0 NEW_LINE m = 0 NEW_LINE def main ( self ) : NEW_LINE INDENT inpt = input ( ) . split ( ) NEW_LINE self . n = int ( inpt [ 0 ] ) NEW_LINE self . m = int ( inpt [ 1 ] ) NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT string = input ( ) NEW_LINE if " X " in string : NEW_LINE INDENT self . set . add ( string ) NEW_LINE DEDENT DEDENT if len ( self . set ) == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE MOD = 1000000007 NEW_LINE while True : NEW_LINE INDENT aa = list ( input ( ) ) NEW_LINE if aa [ 0 ] == '0' : NEW_LINE INDENT break NEW_LINE DEDENT bb = list ( input ( ) ) NEW_LINE cc = list ( input ( ) ) NEW_LINE n = len ( aa ) NEW_LINE dp = [ [ 0 , 0 ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT da = - 1 if aa [ n - i ] == ' ? ' else int ( aa [ n - i ] ) NEW_LINE db = - 1 if bb [ n - i ] == ' ? ' else int ( bb [ n - i ] ) NEW_LINE dc = - 1 if cc [ n - i ] == ' ? ' else int ( cc [ n - i ] ) NEW_LINE for j in range ( 2 ) : NEW_LINE INDENT for carry in range ( 2 ) : NEW_LINE INDENT patterns = 0 NEW_LINE for a in range ( 10 ) : NEW_LINE INDENT if da != - 1 and da != a : NEW_LINE INDENT continue NEW_LINE DEDENT for b in range ( 10 ) : NEW_LINE INDENT if db != - 1 and db != b : NEW_LINE INDENT continue NEW_LINE DEDENT c = a + b + carry NEW_LINE if ( j == 0 and c >= 10 ) or ( j == 1 and c < 10 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if i == n : NEW_LINE INDENT if a * b * c == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if dc == - 1 or dc == c % 10 : NEW_LINE INDENT patterns += 1 NEW_LINE DEDENT DEDENT DEDENT dp [ i ] [ j ] += dp [ i - 1 ] [ carry ] * patterns % MOD NEW_LINE dp [ i ] [ j ] %= MOD NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] [ 0 ] ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE two = 0 NEW_LINE three = 0 NEW_LINE while a % 2 == 0 : NEW_LINE INDENT a = a // 2 NEW_LINE two += 1 NEW_LINE DEDENT while a % 3 == 0 : NEW_LINE INDENT a = a // 3 NEW_LINE three += 1 NEW_LINE DEDENT if a == 1 : NEW_LINE INDENT if three >= two : NEW_LINE INDENT temp = two NEW_LINE three -= two NEW_LINE temp += three * 2 NEW_LINE print ( temp ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def minIncrementForUnique ( A ) : NEW_LINE INDENT mpp = { } NEW_LINE for i in A : NEW_LINE INDENT if i in mpp : NEW_LINE INDENT mpp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ i ] = 1 NEW_LINE DEDENT DEDENT taken = [ ] NEW_LINE ans = 0 NEW_LINE for x in range ( 100000 ) : NEW_LINE INDENT if x in mpp and mpp [ x ] >= 2 : NEW_LINE INDENT taken . append ( x * ( mpp [ x ] - 1 ) ) NEW_LINE DEDENT elif len ( taken ) > 0 and ( ( x in mpp and mpp [ x ] == 0 ) or x not in mpp ) : NEW_LINE INDENT ans += x - taken [ - 1 ] NEW_LINE taken . pop ( ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT A = [ 3 , 2 , 1 , 2 , 1 , 7 ] NEW_LINE print ( GFG . minIncrementForUnique ( A ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE MOD = 1000003 NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE ans = 1 if n == 0 else pow ( 3 , n - 1 , MOD ) NEW_LINE print ( ans ) NEW_LINE DEDENT def pow ( a , p , m ) : NEW_LINE INDENT if p == 0 : NEW_LINE INDENT return 1 % m NEW_LINE DEDENT if p == 1 : NEW_LINE INDENT return a % m NEW_LINE DEDENT v = pow ( a , p // 2 , m ) NEW_LINE ans = ( v * v ) % m NEW_LINE if p % 2 == 1 : NEW_LINE INDENT ans = ( ans * a ) % m NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
MOD = int ( 1e9 + 7 ) NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for _ in range ( 13 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = int ( s [ i ] ) if s [ i ] != ' ? ' else j NEW_LINE for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % 13 NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] NEW_LINE dp [ i + 1 ] [ rem ] %= MOD NEW_LINE DEDENT if s [ i ] != ' ? ' : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ n ] [ 5 ] ) NEW_LINE DEDENT s = " ? 44" NEW_LINE n = len ( s ) NEW_LINE print ( modulo_13 ( s , n ) ) NEW_LINE
def countNums ( a , b , c , d ) : NEW_LINE INDENT def __gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return __gcd ( b , a % b ) NEW_LINE DEDENT x = b // c - ( a - 1 ) // c NEW_LINE y = b // d - ( a - 1 ) // d NEW_LINE k = ( c * d ) // __gcd ( c , d ) NEW_LINE z = b // k - ( a - 1 ) // k NEW_LINE return b - a + 1 - x - y + z NEW_LINE DEDENT a = 10 NEW_LINE b = 50 NEW_LINE c = 4 NEW_LINE d = 6 NEW_LINE print ( countNums ( a , b , c , d ) ) NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def printSubstrings ( n ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) NEW_LINE d = int ( math . pow ( 10 , s ) + 0.5 ) NEW_LINE k = d NEW_LINE while n > 0 : NEW_LINE INDENT while d > 0 : NEW_LINE INDENT print ( n // d ) NEW_LINE d = d // 10 NEW_LINE DEDENT n = n % k NEW_LINE k = k // 10 NEW_LINE d = k NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 123 NEW_LINE printSubstrings ( n ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def NthCharacter ( n ) : NEW_LINE INDENT s = " " NEW_LINE c = 1 NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT if c < 10 : NEW_LINE INDENT s += str ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT s1 = " " NEW_LINE dup = c NEW_LINE while dup > 0 : NEW_LINE INDENT s1 += str ( dup % 10 ) NEW_LINE dup //= 10 NEW_LINE DEDENT s += s1 [ : : - 1 ] NEW_LINE DEDENT c += 1 NEW_LINE if len ( s ) >= n : NEW_LINE INDENT return s [ n - 1 ] NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 11 NEW_LINE print ( self . NthCharacter ( n ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE tosi = [ 0 ] * n NEW_LINE M = [ 0 ] * n NEW_LINE D = [ 0 ] * n NEW_LINE for k in range ( n ) : NEW_LINE INDENT total = 0 NEW_LINE day = 0 NEW_LINE tosi [ k ] , M [ k ] , D [ k ] = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( tosi [ k ] + 1 , 1001 ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT total += 200 NEW_LINE DEDENT else : NEW_LINE INDENT total += 195 NEW_LINE DEDENT DEDENT if tosi [ k ] % 3 == 0 : NEW_LINE INDENT tuki = ( M [ k ] - 1 ) * 20 NEW_LINE day = tuki + D [ k ] - 6 NEW_LINE DEDENT else : NEW_LINE INDENT if ( M [ k ] - 1 ) % 2 == 0 : NEW_LINE INDENT day = ( ( M [ k ] - 1 ) // 2 ) * 20 + ( ( M [ k ] - 1 ) // 2 ) * 19 + D [ k ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT day = ( ( M [ k ] ) // 2 ) * 20 + ( ( M [ k ] - 1 ) // 2 ) * 19 + D [ k ] - 1 NEW_LINE DEDENT DEDENT total = total - day NEW_LINE print ( total ) NEW_LINE DEDENT
` ` ` python NEW_LINE def check_prime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def countPrimeFrequent ( s ) : NEW_LINE INDENT count = 0 NEW_LINE mp = { } NEW_LINE for char in s : NEW_LINE INDENT if char in mp : NEW_LINE INDENT mp [ char ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ char ] = 1 NEW_LINE DEDENT DEDENT for value in mp . values ( ) : NEW_LINE INDENT if check_prime ( value ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE print ( countPrimeFrequent ( s ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE req = [ ] NEW_LINE pre = [ ] NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT req . append ( int ( input ( ) ) ) NEW_LINE DEDENT for _ in range ( m ) : NEW_LINE INDENT pre . append ( int ( input ( ) ) ) NEW_LINE DEDENT i , j = n - 1 , m - 1 NEW_LINE ans = 0 NEW_LINE while i >= 0 and j >= 0 : NEW_LINE INDENT if req [ i ] > pre [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( ans + i + 1 ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 0 ] * ( n + 2 ) NEW_LINE catalan [ 0 ] = 1 NEW_LINE catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalanDP ( i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
from fractions import Fraction NEW_LINE import math NEW_LINE class p243 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT TARGET = Fraction ( 15499 , 94744 ) NEW_LINE totient = 1 NEW_LINE denominator = 1 NEW_LINE p = 2 NEW_LINE while True : NEW_LINE INDENT totient *= ( p - 1 ) NEW_LINE denominator *= p NEW_LINE p = self . next_prime ( p ) NEW_LINE if Fraction ( totient , denominator ) < TARGET : NEW_LINE INDENT for i in range ( 1 , p ) : NEW_LINE INDENT numer = i * totient NEW_LINE denom = i * denominator NEW_LINE if Fraction ( numer , denom - 1 ) < TARGET : NEW_LINE INDENT return str ( denom ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def next_prime ( self , n ) : NEW_LINE INDENT while True : NEW_LINE INDENT n += 1 NEW_LINE if self . is_prime ( n ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT DEDENT def is_prime ( self , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT p = p243 ( ) NEW_LINE p . main ( ) NEW_LINE
` ` ` python NEW_LINE s = input ( ) NEW_LINE x , y = 0 , 0 NEW_LINE k = 0 NEW_LINE co = [ [ 0 for _ in range ( 101 ) ] for _ in range ( 2 ) ] NEW_LINE ch = list ( s ) NEW_LINE co [ 0 ] [ k ] = x NEW_LINE co [ 1 ] [ k ] = y NEW_LINE k += 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ch [ i ] == ' L ' : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT elif ch [ i ] == ' R ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif ch [ i ] == ' U ' : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif ch [ i ] == ' D ' : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT co [ 0 ] [ k ] = x NEW_LINE co [ 1 ] [ k ] = y NEW_LINE k += 1 NEW_LINE DEDENT flag = True NEW_LINE for i in range ( k - 3 ) : NEW_LINE INDENT for j in range ( i + 3 , k ) : NEW_LINE INDENT dx = co [ 0 ] [ i ] - co [ 0 ] [ j ] NEW_LINE dy = co [ 1 ] [ i ] - co [ 1 ] [ j ] NEW_LINE if dx < 0 : NEW_LINE INDENT dx *= - 1 NEW_LINE DEDENT if dy < 0 : NEW_LINE INDENT dy *= - 1 NEW_LINE DEDENT if ( dx <= 1 and dy == 0 ) or ( dy <= 1 and dx == 0 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( " OK " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " BUG " ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPossible ( N ) : NEW_LINE INDENT if isPrime ( N ) and isPrime ( N - 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 13 NEW_LINE if isPossible ( n ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res // ( n + 1 ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 4 NEW_LINE print ( " Number ▁ of ▁ Dyck ▁ Paths ▁ is ▁ " + str ( GFG . countDyckPaths ( n ) ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def solve ( n ) : NEW_LINE INDENT if n <= 30 : NEW_LINE INDENT return " NO " NEW_LINE DEDENT elif n == 36 or n == 40 or n == 44 : NEW_LINE INDENT return " YES \n 6 ▁ 10 ▁ 15 ▁ { } " . format ( n - 31 ) NEW_LINE DEDENT else : NEW_LINE INDENT return " YES \n 6 ▁ 10 ▁ 14 ▁ { } " . format ( n - 30 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( solve ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = gcd ( ans , a [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_score = 0 NEW_LINE for from_idx in range ( 14 ) : NEW_LINE INDENT stones = a [ from_idx ] NEW_LINE remainder = stones // 14 NEW_LINE score = remainder if remainder % 2 == 0 else 0 NEW_LINE for i in range ( 1 , 14 ) : NEW_LINE INDENT count = a [ ( from_idx + i ) % 14 ] + ( stones + 14 - i ) // 14 NEW_LINE if count % 2 == 0 : NEW_LINE INDENT score += count NEW_LINE DEDENT DEDENT max_score = max ( max_score , score ) NEW_LINE DEDENT print ( max_score ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
def pentdiagonal ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = 6 NEW_LINE print ( pentdiagonal ( a ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def hexDiagonal ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.73 * a NEW_LINE return d NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = 9 NEW_LINE print ( hexDiagonal ( a ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java NEW_LINE def translate ( str ) : NEW_LINE INDENT len = len ( str ) NEW_LINE if len < 2 : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while j < len - 1 : NEW_LINE INDENT if str [ j ] == ' A ' and str [ j + 1 ] == ' B ' : NEW_LINE INDENT j = j + 2 NEW_LINE str [ i ] = ' C ' NEW_LINE i += 1 NEW_LINE continue NEW_LINE DEDENT str [ i ] = str [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT if j == len - 1 : NEW_LINE INDENT str [ i ] = str [ j ] NEW_LINE i += 1 NEW_LINE DEDENT str [ i ] = ' ▁ ' NEW_LINE str [ len - 1 ] = ' ▁ ' NEW_LINE DEDENT st = " helloABworldABGfG " NEW_LINE str = list ( st ) NEW_LINE translate ( str ) NEW_LINE print ( " The ▁ modified ▁ string ▁ is ▁ : " ) NEW_LINE print ( ' ' . join ( str ) ) NEW_LINE
import re NEW_LINE def translate ( str ) : NEW_LINE INDENT str = re . sub ( ' AB ' , ' C ' , str ) NEW_LINE return str NEW_LINE DEDENT st = " helloABworldABGfG " NEW_LINE str = list ( st ) NEW_LINE translated_str = translate ( st ) NEW_LINE print ( " The ▁ modified ▁ string ▁ is ▁ : " ) NEW_LINE print ( translated_str ) NEW_LINE
class p128 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT TARGET = 2000 NEW_LINE def run ( self ) : NEW_LINE INDENT count = 2 NEW_LINE ring = 2 NEW_LINE while True : NEW_LINE INDENT if ring * 12 + 5 > 2147483647 : NEW_LINE INDENT raise ArithmeticError NEW_LINE DEDENT if Library . isPrime ( ring * 6 - 1 ) and Library . isPrime ( ring * 6 + 1 ) and Library . isPrime ( ring * 12 + 5 ) : NEW_LINE INDENT count += 1 NEW_LINE if count == self . TARGET : NEW_LINE INDENT return str ( ( ring * ( ring - 1 ) * 3 + 2 ) ) NEW_LINE DEDENT DEDENT if Library . isPrime ( ring * 6 - 1 ) and Library . isPrime ( ring * 6 + 5 ) and Library . isPrime ( ring * 12 - 7 ) : NEW_LINE INDENT count += 1 NEW_LINE if count == self . TARGET : NEW_LINE INDENT return str ( ( ring * ( ring + 1 ) * 3 + 1 ) ) NEW_LINE DEDENT DEDENT ring += 1 NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( max ( n , m ) + 1 ) : NEW_LINE INDENT for j in range ( max ( n , m ) + 1 ) : NEW_LINE INDENT if ( i * i ) + j == n and i + ( j * j ) == m : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def Digits ( n ) : NEW_LINE INDENT largest = 0 NEW_LINE smallest = 9 NEW_LINE while n != 0 : NEW_LINE INDENT r = n % 10 NEW_LINE largest = max ( r , largest ) NEW_LINE smallest = min ( r , smallest ) NEW_LINE n = n // 10 NEW_LINE DEDENT print ( largest , smallest ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2346 NEW_LINE GFG . Digits ( n ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def solve ( d1 , d2 , d3 ) : NEW_LINE INDENT maxx = max ( d1 , max ( d2 , d3 ) ) NEW_LINE sum = d1 + d2 + d3 NEW_LINE if 2 * maxx > sum or sum % 2 == 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT x1 , y1 = 0 , 0 NEW_LINE x2 , y2 = d1 , 0 NEW_LINE x3 = ( d1 + d2 - d3 ) // 2 NEW_LINE y3 = ( d2 + d3 - d1 ) // 2 NEW_LINE print ( " ( " , x1 , " , ▁ " , y1 , " ) , ▁ ( " , x2 , " , ▁ " , y2 , " ) ▁ and ▁ ( " , x3 , " , ▁ " , y3 , " ) " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT d1 , d2 , d3 = 3 , 4 , 5 NEW_LINE solve ( d1 , d2 , d3 ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def distributingBalls ( k , n , string ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if a [ i ] > k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 6 NEW_LINE k = 3 NEW_LINE string = " aacaab " NEW_LINE if distributingBalls ( k , n , string ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from datetime import datetime NEW_LINE def check ( sb ) : NEW_LINE INDENT t = 0 NEW_LINE for char in sb : NEW_LINE INDENT if char == " T " : NEW_LINE INDENT t += 1 NEW_LINE DEDENT elif char == " M " : NEW_LINE INDENT if t <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT t -= 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE sb = input ( ) NEW_LINE if " M " not in sb : NEW_LINE INDENT print ( " NO " ) NEW_LINE continue NEW_LINE DEDENT T = sb . count ( " T " ) NEW_LINE m = sb . count ( " M " ) NEW_LINE if T // 2 != m : NEW_LINE INDENT print ( " NO " ) NEW_LINE continue NEW_LINE DEDENT if check ( sb ) and check ( sb [ : : - 1 ] ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT e = [ 0 ] * 13 NEW_LINE p = 0 NEW_LINE scan = input ( ) . split ( ) NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT e [ i ] = int ( scan [ i ] ) NEW_LINE DEDENT for i in range ( 12 ) : NEW_LINE INDENT for j in range ( 12 - i ) : NEW_LINE INDENT if e [ j ] < e [ j + 1 ] : NEW_LINE INDENT y = e [ j ] NEW_LINE e [ j ] = e [ j + 1 ] NEW_LINE e [ j + 1 ] = y NEW_LINE DEDENT DEDENT DEDENT for u in range ( 3 ) : NEW_LINE INDENT for k in range ( 4 ) : NEW_LINE INDENT i = u * 4 NEW_LINE if e [ i ] == e [ i + 1 ] and e [ i + 2 ] == e [ i + 3 ] and e [ i ] == e [ i + 2 ] and e [ i + 1 ] == e [ i + 3 ] and e [ i ] == e [ i + 3 ] and e [ i + 1 ] == e [ i + 2 ] : NEW_LINE INDENT p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 0 NEW_LINE DEDENT DEDENT DEDENT if p == 12 : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT DEDENT DEDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT R = 4 NEW_LINE C = 4 NEW_LINE @ staticmethod NEW_LINE def first ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid == 0 or arr [ mid - 1 ] == 0 ) and arr [ mid ] == 1 : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] == 0 : NEW_LINE INDENT return GFG . first ( arr , mid + 1 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return GFG . first ( arr , low , mid - 1 ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT @ staticmethod NEW_LINE def rowWith0s ( mat ) : NEW_LINE INDENT max_row_index = 0 NEW_LINE max_val = float ( ' - inf ' ) NEW_LINE min_row_index = 0 NEW_LINE min_val = float ( ' inf ' ) NEW_LINE for i in range ( GFG . R ) : NEW_LINE INDENT index = GFG . first ( mat [ i ] , 0 , GFG . C - 1 ) NEW_LINE cnt_zeroes = 0 NEW_LINE if index == - 1 : NEW_LINE INDENT cnt_zeroes = GFG . C NEW_LINE DEDENT else : NEW_LINE INDENT cnt_zeroes = index NEW_LINE DEDENT if max_val < cnt_zeroes : NEW_LINE INDENT max_val = cnt_zeroes NEW_LINE max_row_index = i NEW_LINE DEDENT if min_val > cnt_zeroes : NEW_LINE INDENT min_val = cnt_zeroes NEW_LINE min_row_index = i NEW_LINE DEDENT DEDENT print ( " Row ▁ with ▁ min ▁ 0s : " , min_row_index + 1 ) NEW_LINE print ( " Row ▁ with ▁ max ▁ 0s : " , max_row_index + 1 ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT mat = [ [ 0 , 0 , 0 , 1 ] , [ 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE GFG . rowWith0s ( mat ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def bitAtGivenPosSetOrUnset ( n , k ) : NEW_LINE INDENT new_num = n >> ( k - 1 ) NEW_LINE return ( new_num & 1 ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 10 NEW_LINE k = 2 NEW_LINE if GFG . bitAtGivenPosSetOrUnset ( n , k ) == 1 : NEW_LINE INDENT print ( " Set " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Unset " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE n = int ( input ( ) ) NEW_LINE genome = input ( ) . strip ( ) NEW_LINE if n % 4 != 0 : NEW_LINE INDENT print ( " = = = " ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT themost = n // 4 NEW_LINE numA = genome . count ( ' A ' ) NEW_LINE numG = genome . count ( ' G ' ) NEW_LINE numC = genome . count ( ' C ' ) NEW_LINE numT = genome . count ( ' T ' ) NEW_LINE numQM = genome . count ( ' ? ' ) NEW_LINE if numA > themost or numC > themost or numG > themost or numT > themost : NEW_LINE INDENT print ( " = = = " ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT for _ in range ( numQM ) : NEW_LINE INDENT for i in range ( len ( genome ) ) : NEW_LINE INDENT if genome [ i ] == ' ? ' : NEW_LINE INDENT if numA < themost : NEW_LINE INDENT genome = genome [ : i ] + ' A ' + genome [ i + 1 : ] NEW_LINE numA += 1 NEW_LINE DEDENT elif numC < themost : NEW_LINE INDENT genome = genome [ : i ] + ' C ' + genome [ i + 1 : ] NEW_LINE numC += 1 NEW_LINE DEDENT elif numG < themost : NEW_LINE INDENT genome = genome [ : i ] + ' G ' + genome [ i + 1 : ] NEW_LINE numG += 1 NEW_LINE DEDENT elif numT < themost : NEW_LINE INDENT genome = genome [ : i ] + ' T ' + genome [ i + 1 : ] NEW_LINE numT += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( genome ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT pos = [ 0 ] * 9 NEW_LINE start = ord ( input ( ) [ 0 ] ) - ord ( ' A ' ) NEW_LINE end = ord ( input ( ) [ 0 ] ) - ord ( ' A ' ) NEW_LINE not_val = ord ( input ( ) [ 0 ] ) - ord ( ' A ' ) NEW_LINE pos [ start ] = 1 NEW_LINE next_pos = [ 0 ] * 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 9 ) : NEW_LINE INDENT next_pos [ j ] = 0 NEW_LINE DEDENT for j in range ( 9 ) : NEW_LINE INDENT if j % 3 != 0 and not_val != j - 1 : NEW_LINE INDENT next_pos [ j - 1 ] += pos [ j ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next_pos [ j ] += pos [ j ] / 4 NEW_LINE DEDENT if j % 3 != 2 and not_val != j + 1 : NEW_LINE INDENT next_pos [ j + 1 ] += pos [ j ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next_pos [ j ] += pos [ j ] / 4 NEW_LINE DEDENT if j / 3 != 0 and not_val != j - 3 : NEW_LINE INDENT next_pos [ j - 3 ] += pos [ j ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next_pos [ j ] += pos [ j ] / 4 NEW_LINE DEDENT if j / 3 != 2 and not_val != j + 3 : NEW_LINE INDENT next_pos [ j + 3 ] += pos [ j ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next_pos [ j ] += pos [ j ] / 4 NEW_LINE DEDENT DEDENT tmp = next_pos NEW_LINE next_pos = pos NEW_LINE pos = tmp NEW_LINE DEDENT print ( " % .8f " % pos [ end ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( argc ) : NEW_LINE INDENT l = int ( input ( ) ) NEW_LINE r = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE i = 1 NEW_LINE while i <= r : NEW_LINE INDENT j = 1 NEW_LINE while j * i <= r : NEW_LINE INDENT if i * j >= l : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT j *= 3 NEW_LINE DEDENT i *= 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( None ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE K = int ( input ( ) ) NEW_LINE t = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = min ( 2 * t , t + K ) NEW_LINE DEDENT print ( t ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import java NEW_LINE def arePermutations ( a , b , n , m ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE mul1 = 1 NEW_LINE mul2 = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE mul1 *= a [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT sum2 += b [ i ] NEW_LINE mul2 *= b [ i ] NEW_LINE DEDENT return ( sum1 == sum2 ) and ( mul1 == mul2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 3 , 2 ] NEW_LINE b = [ 3 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if arePermutations ( a , b , n , m ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
MAX_CHAR = 26 NEW_LINE def findAndPrintUncommonChars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT if present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 2 NEW_LINE DEDENT DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if present [ i ] == 1 or present [ i ] == 2 : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " characters " NEW_LINE str2 = " alphabets " NEW_LINE findAndPrintUncommonChars ( str1 , str2 ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def isInside ( circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT if ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def main ( self , arg ) : NEW_LINE INDENT x , y = 1 , 1 NEW_LINE circle_x , circle_y , rad = 0 , 1 , 2 NEW_LINE if self . isInside ( circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT print ( " Inside " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def minSum ( arr , n , x ) : NEW_LINE INDENT sum = 0 NEW_LINE largestDivisible = - 1 NEW_LINE minimum = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if arr [ i ] % x == 0 and largestDivisible < arr [ i ] : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if arr [ i ] < minimum : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if largestDivisible == - 1 : NEW_LINE INDENT return sum NEW_LINE DEDENT sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible // x ) NEW_LINE return min ( sum , sumAfterOperation ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 5 , 5 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( GFG . minSum ( arr , n , x ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def nthTerm ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT nth = 2 * ( ( n * n ) - n ) NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( 2 * n * n ) - n NEW_LINE DEDENT return nth NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( GFG . nthTerm ( n ) ) NEW_LINE n = 25 NEW_LINE print ( GFG . nthTerm ( n ) ) NEW_LINE n = 25000000 NEW_LINE print ( GFG . nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE print ( GFG . nthTerm ( n ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
from collections import deque NEW_LINE def main ( ) : NEW_LINE INDENT list = deque ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cmd = int ( input ( ) ) NEW_LINE if cmd == 0 : NEW_LINE INDENT list . appendleft ( int ( input ( ) ) ) NEW_LINE DEDENT elif cmd == 1 : NEW_LINE INDENT d = int ( input ( ) ) NEW_LINE if d > 0 : NEW_LINE INDENT for j in range ( d ) : NEW_LINE INDENT list . rotate ( - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( - d ) : NEW_LINE INDENT list . rotate ( 1 ) NEW_LINE DEDENT DEDENT DEDENT elif cmd == 2 : NEW_LINE INDENT list . popleft ( ) NEW_LINE DEDENT DEDENT for i in list : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ : i ] == s [ len ( s ) - i : ] : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT sb = s [ len ( s ) - ans : ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT sb += s [ ans : ] NEW_LINE DEDENT print ( sb ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class INT : NEW_LINE INDENT def __init__ ( self , a ) : NEW_LINE INDENT self . a = a NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT temp = GFG . Node ( ) NEW_LINE temp . data = data NEW_LINE temp . left = None NEW_LINE temp . right = None NEW_LINE return temp NEW_LINE DEDENT def printInorder ( node ) : NEW_LINE INDENT if node is None : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( node . left ) NEW_LINE print ( node . data , end = " ▁ " ) NEW_LINE printInorder ( node . right ) NEW_LINE DEDENT def conBinaryTreeUtil ( pre , preM , preIndex , l , h , size ) : NEW_LINE INDENT if preIndex . a >= size or l > h : NEW_LINE INDENT return None NEW_LINE DEDENT root = newNode ( pre [ preIndex . a ] ) NEW_LINE preIndex . a += 1 NEW_LINE if l == h : NEW_LINE INDENT return root NEW_LINE DEDENT i = l NEW_LINE while i <= h : NEW_LINE INDENT if pre [ preIndex . a ] == preM [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if i <= h : NEW_LINE INDENT root . left = conBinaryTreeUtil ( pre , preM , preIndex , i , h , size ) NEW_LINE root . right = conBinaryTreeUtil ( pre , preM , preIndex , l + 1 , i - 1 , size ) NEW_LINE DEDENT return root NEW_LINE DEDENT def conBinaryTree ( root , pre , preMirror , size ) : NEW_LINE INDENT preIndex = GFG . INT ( 0 ) NEW_LINE preMIndex = 0 NEW_LINE root = conBinaryTreeUtil ( pre , preMirror , preIndex , 0 , size - 1 , size ) NEW_LINE printInorder ( root ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT preOrder = [ 1 , 2 , 4 , 5 , 3 , 6 , 7 ] NEW_LINE preOrderMirror = [ 1 , 3 , 7 , 6 , 2 , 5 , 4 ] NEW_LINE size = len ( preOrder ) NEW_LINE root = GFG . Node ( ) NEW_LINE conBinaryTree ( root , preOrder , preOrderMirror , size ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT no_of_chars = 256 NEW_LINE @ staticmethod NEW_LINE def findSubString ( str , pat ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 ] * GFG . no_of_chars NEW_LINE hash_str = [ 0 ] * GFG . no_of_chars NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT hash_pat [ ord ( pat [ i ] ) ] += 1 NEW_LINE DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = float ( ' inf ' ) NEW_LINE count = 0 NEW_LINE for j in range ( len1 ) : NEW_LINE INDENT hash_str [ ord ( str [ j ] ) ] += 1 NEW_LINE if hash_pat [ ord ( str [ j ] ) ] != 0 and hash_str [ ord ( str [ j ] ) ] <= hash_pat [ ord ( str [ j ] ) ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] or hash_pat [ ord ( str [ start ] ) ] == 0 : NEW_LINE INDENT if hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] : NEW_LINE INDENT hash_str [ ord ( str [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if start_index == - 1 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT return str [ start_index : start_index + min_len ] NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT str = " this ▁ is ▁ a ▁ test ▁ string " NEW_LINE pat = " tist " NEW_LINE print ( " Smallest ▁ window ▁ is : \n " , GFG . findSubString ( str , pat ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class Point2 : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def ccw ( p1 , p2 , p3 ) : NEW_LINE INDENT return ( p2 . y - p1 . y ) * ( p3 . x - p1 . x ) - ( p3 . y - p1 . y ) * ( p2 . x - p1 . x ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT p = [ Point2 ( float ( input ( ) ) , float ( input ( ) ) ) for _ in range ( 4 ) ] NEW_LINE judge = False NEW_LINE if ( ccw ( p [ 0 ] , p [ 3 ] , p [ 1 ] ) > 0 and ccw ( p [ 1 ] , p [ 3 ] , p [ 2 ] ) > 0 and ccw ( p [ 2 ] , p [ 3 ] , p [ 0 ] ) > 0 ) or ( ccw ( p [ 0 ] , p [ 3 ] , p [ 1 ] ) < 0 and ccw ( p [ 1 ] , p [ 3 ] , p [ 2 ] ) < 0 and ccw ( p [ 2 ] , p [ 3 ] , p [ 0 ] ) < 0 ) : NEW_LINE INDENT judge = True NEW_LINE DEDENT print ( " YES " if judge else " NO " ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class PolandBoardAndGame : NEW_LINE INDENT map = { } NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n > m : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif m > n : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT for _ in range ( n ) : NEW_LINE INDENT PolandBoardAndGame . map [ input ( ) ] = 1 NEW_LINE DEDENT dem = 0 NEW_LINE for _ in range ( m ) : NEW_LINE INDENT if input ( ) in PolandBoardAndGame . map : NEW_LINE INDENT dem += 1 NEW_LINE DEDENT DEDENT if dem % 2 == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE for p in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT return n == 3 or n == 5 or n == 7 NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE i = 0 NEW_LINE while i < len ( v ) and n > 0 : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while a != 0 : NEW_LINE INDENT d = a % 10 NEW_LINE a = a // 10 NEW_LINE if is_prime ( d ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT n -= 1 NEW_LINE sum += v [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT science = [ 0 , 0 , 0 , 0 ] NEW_LINE minsc = 100 NEW_LINE sumsc = 0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT science [ i ] = int ( input ( ) ) NEW_LINE minsc = min ( minsc , science [ i ] ) NEW_LINE sumsc += science [ i ] NEW_LINE DEDENT sumsc -= minsc NEW_LINE sumso = int ( input ( ) ) NEW_LINE x = int ( input ( ) ) NEW_LINE if sumso < x : NEW_LINE INDENT sumso = x NEW_LINE DEDENT print ( sumsc + sumso ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main_instance = Main ( ) NEW_LINE main_instance . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class BearAndGame1 : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE array = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE flag = 15 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if array [ i ] <= flag : NEW_LINE INDENT flag = array [ i ] + 15 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT result = min ( flag , 90 ) NEW_LINE print ( result ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT bear_and_game = BearAndGame1 ( ) NEW_LINE bear_and_game . main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT v = [ ] NEW_LINE dp = [ [ [ [ - 1 for _ in range ( 2 ) ] for _ in range ( 180 ) ] for _ in range ( 180 ) ] for _ in range ( 18 ) ] NEW_LINE @ staticmethod NEW_LINE def memo ( index , evenSum , oddSum , tight ) : NEW_LINE INDENT if index == len ( GFG . v ) : NEW_LINE INDENT if evenSum > oddSum : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if GFG . dp [ index ] [ evenSum ] [ oddSum ] [ tight ] != - 1 : NEW_LINE INDENT return GFG . dp [ index ] [ evenSum ] [ oddSum ] [ tight ] NEW_LINE DEDENT limit = GFG . v [ index ] if tight > 0 else 9 NEW_LINE ans = 0 NEW_LINE for d in range ( limit + 1 ) : NEW_LINE INDENT currTight = 0 NEW_LINE if d == GFG . v [ index ] : NEW_LINE INDENT currTight = tight NEW_LINE DEDENT if d % 2 != 0 : NEW_LINE INDENT ans += GFG . memo ( index + 1 , evenSum , oddSum + d , currTight ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += GFG . memo ( index + 1 , evenSum + d , oddSum , currTight ) NEW_LINE DEDENT DEDENT GFG . dp [ index ] [ evenSum ] [ oddSum ] [ tight ] = ans NEW_LINE return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def count_num ( n ) : NEW_LINE INDENT GFG . v . clear ( ) NEW_LINE while n > 0 : NEW_LINE INDENT GFG . v . append ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT GFG . v . reverse ( ) NEW_LINE for i in range ( 18 ) : NEW_LINE INDENT for j in range ( 180 ) : NEW_LINE INDENT for k in range ( 180 ) : NEW_LINE INDENT for l in range ( 2 ) : NEW_LINE INDENT GFG . dp [ i ] [ j ] [ k ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return GFG . memo ( 0 , 0 , 0 , 1 ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT L , R = 2 , 10 NEW_LINE print ( GFG . count_num ( R ) - GFG . count_num ( L - 1 ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
import java . util . Scanner NEW_LINE def main ( ) : NEW_LINE INDENT sc = Scanner ( System . in ) NEW_LINE sb = " " NEW_LINE c = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE b = True NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT c [ i ] [ j ] = sc . nextInt ( ) NEW_LINE DEDENT DEDENT for i in range ( 2 ) : NEW_LINE INDENT for j in range ( i + 1 , 3 ) : NEW_LINE INDENT if c [ i ] [ 0 ] - c [ j ] [ 0 ] == c [ i ] [ 1 ] - c [ j ] [ 1 ] and c [ i ] [ 1 ] - c [ j ] [ 1 ] == c [ i ] [ 2 ] - c [ j ] [ 2 ] : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT b = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 ) : NEW_LINE INDENT for j in range ( i + 1 , 3 ) : NEW_LINE INDENT if c [ 0 ] [ i ] - c [ 0 ] [ j ] == c [ 1 ] [ i ] - c [ 1 ] [ j ] and c [ 1 ] [ i ] - c [ 1 ] [ j ] == c [ 2 ] [ i ] - c [ 2 ] [ j ] : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT b = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if b : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE flag = True NEW_LINE b [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] != 0 and b [ i - 1 ] - a [ i ] >= 0 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = b [ i - 1 ] + a [ i ] NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class p218 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( p218 ( ) . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def search ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = GFG . search ( arr , x ) NEW_LINE if result == - 1 : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index ▁ " + str ( result ) ) NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE n , c = map ( int , input ( ) . split ( ) ) NEW_LINE positions = [ 0 ] * ( n + 1 ) NEW_LINE values = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pos , val = map ( int , input ( ) . split ( ) ) NEW_LINE positions [ i ] = pos NEW_LINE values [ i ] = val NEW_LINE DEDENT forward_max = [ 0 ] * ( n + 1 ) NEW_LINE backward_max = [ 0 ] * ( n + 1 ) NEW_LINE max_val = 0 NEW_LINE sum_val = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum_val += values [ i ] NEW_LINE max_val = max ( max_val , sum_val - positions [ i ] ) NEW_LINE forward_max [ i ] = max_val NEW_LINE DEDENT max_val = 0 NEW_LINE sum_val = 0 NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT sum_val += values [ i ] NEW_LINE max_val = max ( max_val , sum_val - ( c - positions [ i ] ) ) NEW_LINE backward_max [ i ] = max_val NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT res = max ( res , forward_max [ i ] ) NEW_LINE if i != n : NEW_LINE INDENT res = max ( res , forward_max [ i ] - positions [ i ] + backward_max [ i + 1 ] ) NEW_LINE DEDENT res = max ( res , backward_max [ i ] ) NEW_LINE if i != 0 : NEW_LINE INDENT res = max ( res , backward_max [ i ] - ( c - positions [ i ] ) + forward_max [ i - 1 ] ) NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE
import math NEW_LINE def toggleBitsFromLToR ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def unsetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( 1 << ( 4 * 8 - 1 ) ) - 1 NEW_LINE num = toggleBitsFromLToR ( num , l , r ) NEW_LINE return ( n & num ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE print ( unsetBitsInGivenRange ( n , l , r ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def MinStep ( a , n ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 0 NEW_LINE zero = 0 NEW_LINE step = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT elif a [ i ] < 0 : NEW_LINE INDENT negative += 1 NEW_LINE step += ( - 1 - a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT positive += 1 NEW_LINE step += ( a [ i ] - 1 ) NEW_LINE DEDENT DEDENT if negative % 2 == 0 : NEW_LINE INDENT step += zero NEW_LINE DEDENT else : NEW_LINE INDENT if zero > 0 : NEW_LINE INDENT step += zero NEW_LINE DEDENT else : NEW_LINE INDENT step += 2 NEW_LINE DEDENT DEDENT return step NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = [ 0 , - 2 , - 1 , - 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( GFG . MinStep ( a , n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT number , start , end = map ( int , input ( ) . split ( ) ) NEW_LINE arr = [ int ( x ) for x in input ( ) ] NEW_LINE if arr [ start - 1 ] == arr [ end - 1 ] : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ start - 1 ] - arr [ end - 1 ] ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE num = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE num . sort ( ) NEW_LINE print ( num [ - 1 ] + num [ - 2 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def __gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return __gcd ( b , a % b ) NEW_LINE DEDENT def noOfSquares ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT dx = abs ( x2 - x1 ) NEW_LINE dy = abs ( y2 - y1 ) NEW_LINE ans = dx + dy - __gcd ( dx , dy ) NEW_LINE print ( ans ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = 1 , 1 , 4 , 3 NEW_LINE GFG . noOfSquares ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def get_maximum ( s , a ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if int ( s [ i ] ) < a [ int ( s [ i ] ) ] : NEW_LINE INDENT j = i NEW_LINE while j < n and int ( s [ j ] ) <= a [ int ( s [ j ] ) ] : NEW_LINE INDENT s [ j ] = str ( a [ int ( s [ j ] ) ] ) NEW_LINE j += 1 NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT s = "1337" NEW_LINE a = [ 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 ] NEW_LINE print ( GFG . get_maximum ( list ( s ) , a ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
import java NEW_LINE MAX_DIGITS = 20 NEW_LINE def isOctal ( n ) : NEW_LINE INDENT while n > 0 : NEW_LINE INDENT if n % 10 >= 8 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 10 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divide = 8 if isOctal ( n ) == 0 else 10 NEW_LINE octal = [ 0 ] * MAX_DIGITS NEW_LINE i = 0 NEW_LINE while n != 0 : NEW_LINE INDENT octal [ i ] = n % divide NEW_LINE i += 1 NEW_LINE n = n // divide NEW_LINE DEDENT j = i - 1 NEW_LINE k = 0 NEW_LINE while k <= j : NEW_LINE INDENT if octal [ j ] != octal [ k ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT n = 97 NEW_LINE if isPalindrome ( n ) > 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE t = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE str = input ( ) NEW_LINE l = list ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] != '4' and l [ i ] != '7' : NEW_LINE INDENT t = 1 NEW_LINE DEDENT DEDENT if t == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT x = x + int ( l [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 , ( n // 2 ) - 1 , - 1 ) : NEW_LINE INDENT y = y + int ( l [ i ] ) NEW_LINE DEDENT if x == y : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def binarySearch ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE midValue = arr [ mid ] NEW_LINE if mid == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT leftindex = min ( mid - 1 , midValue ) NEW_LINE left = GFG . binarySearch ( arr , low , leftindex ) NEW_LINE if left >= 0 : NEW_LINE INDENT return left NEW_LINE DEDENT rightindex = max ( mid + 1 , midValue ) NEW_LINE right = GFG . binarySearch ( arr , rightindex , high ) NEW_LINE return right NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ - 10 , - 5 , 2 , 2 , 2 , 3 , 4 , 7 , 9 , 12 , 13 ] NEW_LINE print ( " Fixed ▁ Point ▁ is ▁ " + str ( GFG . binarySearch ( arr , 0 , len ( arr ) - 1 ) ) ) NEW_LINE arr1 = [ - 10 , - 1 , 3 , 3 , 10 , 30 , 30 , 50 , 100 ] NEW_LINE print ( " Fixed ▁ Point ▁ is ▁ " + str ( GFG . binarySearch ( arr1 , 0 , len ( arr1 ) - 1 ) ) ) NEW_LINE DEDENT DEDENT
from typing import List NEW_LINE MAX = 10000 NEW_LINE prodDig = [ 0 ] * MAX NEW_LINE def getDigitProduct ( x : int ) -> int : NEW_LINE INDENT if x < 10 : NEW_LINE INDENT return x NEW_LINE DEDENT if prodDig [ x ] != 0 : NEW_LINE INDENT return prodDig [ x ] NEW_LINE DEDENT prod = ( x % 10 ) * getDigitProduct ( x // 10 ) NEW_LINE prodDig [ x ] = prod NEW_LINE return prod NEW_LINE DEDENT def findSeed ( n : int ) -> None : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT if i * getDigitProduct ( i ) == n : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT if len ( res ) == 0 : NEW_LINE INDENT print ( " NO ▁ seed ▁ exists " ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( ) -> None : NEW_LINE INDENT n = 138 NEW_LINE findSeed ( n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT left = x [ i ] NEW_LINE right = x [ i + k - 1 ] NEW_LINE ans = min ( ans , min ( abs ( left ) , abs ( right ) ) + right - left ) NEW_LINE DEDENT print ( ans ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def diff ( n , mid ) : NEW_LINE INDENT if n > ( mid * mid * mid ) : NEW_LINE INDENT return ( n - ( mid * mid * mid ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( mid * mid * mid ) - n ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def cubicRoot ( n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n NEW_LINE e = 0.0000001 NEW_LINE while True : NEW_LINE INDENT mid = ( start + end ) / 2 NEW_LINE error = GFG . diff ( n , mid ) NEW_LINE if error <= e : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid * mid * mid ) > n : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 3 NEW_LINE print ( " Cubic ▁ root ▁ of " , n , " is " , GFG . cubicRoot ( n ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_val = max ( a ) + m NEW_LINE for _ in range ( m ) : NEW_LINE INDENT min_val = min ( a ) NEW_LINE a [ a . index ( min_val ) ] += 1 NEW_LINE DEDENT min_val = max ( a ) NEW_LINE print ( min_val , max_val ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE t = 0 NEW_LINE q = 0 NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE if m == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT while a > 1 : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if x1 < 0 : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT def findMinX ( num , rem , k ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT prod *= num [ i ] NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT pp = prod // num [ i ] NEW_LINE result += rem [ i ] * inv ( pp , num [ i ] ) * pp NEW_LINE DEDENT return result % prod NEW_LINE DEDENT num = [ 3 , 4 , 5 ] NEW_LINE rem = [ 2 , 3 , 1 ] NEW_LINE k = len ( num ) NEW_LINE print ( " x ▁ is " , findMinX ( num , rem , k ) ) NEW_LINE
class solution : NEW_LINE INDENT def compare ( self , a , b ) : NEW_LINE INDENT return a > b NEW_LINE DEDENT @ staticmethod NEW_LINE def findMaxOR ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT DEDENT maxOR = arr [ 0 ] NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( maxOR | arr [ i ] ) > maxOR : NEW_LINE INDENT maxOR = maxOR | arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( self . findMaxOR ( arr , n ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def aliquotSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 12 NEW_LINE print ( aliquotSum ( n ) ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) // 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( pentagon_pyramidal ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE def fifthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( fifthPowerSum ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def squaresum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE
import math NEW_LINE def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
import java NEW_LINE def fourthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT print ( squareSum ( 8 ) ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum / n NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def solve ( n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT remainder = n % base NEW_LINE sum += remainder NEW_LINE n = n // base NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumsOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for base in range ( 2 , n // 2 + 1 ) : NEW_LINE INDENT sum += solve ( n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 8 NEW_LINE SumsOfDigits ( n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT N = 10000 NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . solve ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT import sys NEW_LINE p = [ ] NEW_LINE i = 2 NEW_LINE while len ( p ) <= self . N : NEW_LINE INDENT f = True NEW_LINE for j in range ( len ( p ) ) : NEW_LINE INDENT f &= i % p [ j ] != 0 NEW_LINE if not f : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT p . append ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT total_sum = sum ( p [ : n ] ) NEW_LINE print ( total_sum ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import java NEW_LINE class GFG : NEW_LINE INDENT def main ( args ) : NEW_LINE INDENT print ( bin ( 4 ) . count ( '1' ) ) NEW_LINE print ( bin ( 15 ) . count ( '1' ) ) NEW_LINE DEDENT DEDENT
class Optimal_BST2 : NEW_LINE INDENT def optimalSearchTree ( keys , freq , n ) : NEW_LINE INDENT cost = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cost [ i ] [ i ] = freq [ i ] NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE cost [ i ] [ j ] = float ( ' inf ' ) NEW_LINE for r in range ( i , j + 1 ) : NEW_LINE INDENT c = ( cost [ i ] [ r - 1 ] if r > i else 0 ) + ( cost [ r + 1 ] [ j ] if r < j else 0 ) + sum ( freq , i , j ) NEW_LINE if c < cost [ i ] [ j ] : NEW_LINE INDENT cost [ i ] [ j ] = c NEW_LINE DEDENT DEDENT DEDENT DEDENT return cost [ 0 ] [ n - 1 ] NEW_LINE DEDENT def sum ( freq , i , j ) : NEW_LINE INDENT s = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT if k >= len ( freq ) : NEW_LINE INDENT continue NEW_LINE DEDENT s += freq [ k ] NEW_LINE DEDENT return s NEW_LINE DEDENT keys = [ 10 , 12 , 20 ] NEW_LINE freq = [ 34 , 8 , 50 ] NEW_LINE n = len ( keys ) NEW_LINE print ( " Cost ▁ of ▁ Optimal ▁ BST ▁ is " , optimalSearchTree ( keys , freq , n ) ) NEW_LINE DEDENT
def get ( x , y , z ) : NEW_LINE INDENT if x > z : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) // y NEW_LINE ans = div * y + x NEW_LINE return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 1 NEW_LINE y = 5 NEW_LINE z = 8 NEW_LINE print ( get ( x , y , z ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE class CodeForces : NEW_LINE INDENT BUFFERSIZE = 512000 NEW_LINE sc = sys . stdin NEW_LINE out = sys . stdout NEW_LINE @ staticmethod NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( CodeForces . sc . readline ( ) ) NEW_LINE map = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ int ( CodeForces . sc . readline ( ) ) ] = i NEW_LINE DEDENT lastLoc = map [ 1 ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT newLoc = map [ i ] NEW_LINE ans += abs ( lastLoc - newLoc ) NEW_LINE lastLoc = newLoc NEW_LINE DEDENT CodeForces . out . write ( str ( ans ) + " \n " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT CodeForces . solve ( ) NEW_LINE DEDENT
import math NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def maxcoefficientvalue ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return binomialCoeff ( n , n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return binomialCoeff ( n , ( n + 1 ) // 2 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( maxcoefficientvalue ( n ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def isVowel ( ch ) : NEW_LINE INDENT return ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] NEW_LINE DEDENT def vowelPairs ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if GFG . isVowel ( s [ i ] ) and GFG . isVowel ( s [ i + 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT s = " abaebio " NEW_LINE n = len ( s ) NEW_LINE print ( vowelPairs ( s , n ) ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT W , H = map ( int , input ( ) . split ( ) ) NEW_LINE map = [ [ 0 for _ in range ( H + 1 ) ] for _ in range ( W + 1 ) ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE map [ x ] [ y ] += 1 NEW_LINE DEDENT S , T = map ( int , input ( ) . split ( ) ) NEW_LINE max_count = 0 NEW_LINE for s in range ( 1 , W - S + 2 ) : NEW_LINE INDENT for t in range ( 1 , H - T + 2 ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( s , s + S ) : NEW_LINE INDENT for b in range ( t , t + T ) : NEW_LINE INDENT count += map [ a ] [ b ] NEW_LINE DEDENT DEDENT if max_count < count : NEW_LINE INDENT max_count = count NEW_LINE DEDENT DEDENT DEDENT print ( max_count ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def isSubstring ( s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while j < M : NEW_LINE INDENT if s2 [ i + j ] != s1 [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT s1 = " for " NEW_LINE s2 = " geeksforgeeks " NEW_LINE res = self . isSubstring ( s1 , s2 ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( " Not ▁ present " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Present ▁ at ▁ index " , res ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
def angle_on_circumference ( z ) : NEW_LINE INDENT return z / 2 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT angle = 65 NEW_LINE z = angle_on_circumference ( angle ) NEW_LINE print ( " The ▁ angle ▁ is ▁ " + str ( z ) + " ▁ degrees " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java NEW_LINE def countSubarraysof1and0 ( a , n ) : NEW_LINE INDENT count1 = 0 NEW_LINE count0 = 0 NEW_LINE number1 = 0 NEW_LINE number0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number1 += ( count1 ) * ( count1 + 1 ) / 2 NEW_LINE count1 = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number0 += ( count0 ) * ( count0 + 1 ) / 2 NEW_LINE count0 = 0 NEW_LINE DEDENT DEDENT if count1 > 0 : NEW_LINE INDENT number1 += ( count1 ) * ( count1 + 1 ) / 2 NEW_LINE DEDENT if count0 > 0 : NEW_LINE INDENT number0 += ( count0 ) * ( count0 + 1 ) / 2 NEW_LINE DEDENT print ( " Count ▁ of ▁ subarrays ▁ of ▁ 0 ▁ only : ▁ " + str ( number0 ) ) NEW_LINE print ( " \n Count ▁ of ▁ subarrays ▁ of ▁ 1 ▁ only : ▁ " + str ( number1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countSubarraysof1and0 ( a , n ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if N > 0 : NEW_LINE INDENT while x > 0 and flag == 1 : NEW_LINE INDENT digit = x % 10 NEW_LINE if digit != 1 and digit != 3 : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT print ( N , end = " ▁ " ) NEW_LINE DEDENT GFG . printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT N = 20 NEW_LINE GFG . printNumbers ( N ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def printPermutation ( n , k ) : NEW_LINE INDENT mx = n NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT sys . stdout . write ( str ( mx ) + " ▁ " ) NEW_LINE mx -= 1 NEW_LINE DEDENT for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT sys . stdout . write ( str ( i ) + " ▁ " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT N = 5 NEW_LINE K = 3 NEW_LINE if K >= N - 1 : NEW_LINE INDENT sys . stdout . write ( " Not ▁ Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT printPermutation ( N , K ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE rank = 1 NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE sum = a + b + c + d NEW_LINE arr . append ( sum ) NEW_LINE DEDENT for j in arr : NEW_LINE INDENT if arr [ 0 ] < j : NEW_LINE INDENT rank += 1 NEW_LINE DEDENT DEDENT print ( rank ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def check ( s1 , s2 ) : NEW_LINE INDENT mp = { } NEW_LINE for char in s1 : NEW_LINE INDENT mp [ char ] = mp . get ( char , 0 ) + 1 NEW_LINE DEDENT for char in s2 : NEW_LINE INDENT if mp . get ( char , 0 ) > 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT s1 = " geeksforgeeks " NEW_LINE s2 = " geeks " NEW_LINE yes_or_no = GFG . check ( s1 , s2 ) NEW_LINE if yes_or_no : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE flag = False NEW_LINE k = n * ( a - b ) NEW_LINE m = n * ( a + b ) NEW_LINE if k > ( c + d ) or m < ( c - d ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java NEW_LINE def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE DEDENT
tri = [ [ 1 , 0 , 0 ] , [ 4 , 8 , 0 ] , [ 1 , 5 , 3 ] ] NEW_LINE def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT print ( maxPathSum ( tri , 2 , 2 ) ) NEW_LINE
class GFG : NEW_LINE INDENT def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , ( n - 2 ) // 2 + 1 ) : NEW_LINE INDENT if arr [ 2 * i + 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT if 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE if GFG . isHeap ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
class GFG : NEW_LINE INDENT def isHeap ( arr , i , n ) : NEW_LINE INDENT if i > ( n - 2 ) / 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) - 1 NEW_LINE if isHeap ( arr , 0 , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE ax , ay , bx , by , cx , cy = map ( int , input ( ) . split ( ) ) NEW_LINE if ( ( bx - ax ) * ( cy - ay ) == ( cx - ax ) * ( by - ay ) ) or ( ( ax - bx ) * ( ax - bx ) + ( ay - by ) * ( ay - by ) != ( cx - bx ) * ( cx - bx ) + ( cy - by ) * ( cy - by ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def findMinDel ( arr , n ) : NEW_LINE INDENT min_num = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == min_num : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return n - cnt NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 3 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinDel ( arr , n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def count ( x , y ) : NEW_LINE INDENT ans = 0 NEW_LINE m = { } NEW_LINE while x % y != 0 : NEW_LINE INDENT x = x % y NEW_LINE ans += 1 NEW_LINE if x in m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT m [ x ] = 1 NEW_LINE x = x * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT res = GFG . count ( 1 , 2 ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( " INF " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT res = GFG . count ( 5 , 3 ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( " INF " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT res = GFG . count ( 3 , 5 ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( " INF " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
import java NEW_LINE def isPossibleToMakeDivisible ( arr , n ) : NEW_LINE INDENT remainder = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 NEW_LINE DEDENT return remainder == 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 40 , 50 , 90 ] NEW_LINE n = 3 NEW_LINE if isPossibleToMakeDivisible ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE vec = [ [ ] for _ in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = int ( input ( ) ) - 1 NEW_LINE if i != 0 : NEW_LINE INDENT vec [ a ] . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT if a != 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT def dfs ( v , pre ) : NEW_LINE INDENT hight = 0 NEW_LINE for j in range ( len ( vec [ v ] ) ) : NEW_LINE INDENT hight = max ( hight , dfs ( vec [ v ] [ j ] , v ) ) NEW_LINE DEDENT if pre != 0 and hight == K - 1 : NEW_LINE INDENT hight = 0 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hight += 1 NEW_LINE DEDENT return hight NEW_LINE DEDENT dfs ( 0 , 0 ) NEW_LINE print ( ans ) NEW_LINE ` ` ` NEW_LINE
def printCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if j * j * j == i : NEW_LINE INDENT print ( j * j * j , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = 1 , 100 NEW_LINE print ( " Perfect ▁ cubes ▁ in ▁ given ▁ range : " ) NEW_LINE printCubes ( a , b ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 6 NEW_LINE d = 4 NEW_LINE print ( n , " ▁ moduo ▁ " , d , " ▁ is ▁ " , getModulo ( n , d ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = sys . stdin NEW_LINE self . st = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st is None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = self . br . readline ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT return self . br . readline ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT obj = FastReader ( ) NEW_LINE n = obj . nextInt ( ) NEW_LINE d = obj . nextInt ( ) NEW_LINE arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = obj . nextInt ( ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE max_val = float ( ' - inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE l = arr [ i ] + d NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if l < arr [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT max_val = max ( max_val , count ) NEW_LINE DEDENT print ( n - max_val ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE class CodeForce : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT sr = input ( ) NEW_LINE ss = sr [ : - 1 ] NEW_LINE ch = sr [ - 1 ] NEW_LINE list = [ ' f ' , ' e ' , ' d ' , ' a ' , ' b ' , ' c ' ] NEW_LINE x = int ( ss ) NEW_LINE m = x % 2 NEW_LINE k = ( x - 1 ) // 4 NEW_LINE re = x - k NEW_LINE total = 0 NEW_LINE total = 16 * k NEW_LINE if m == 0 : NEW_LINE INDENT total += 7 + list . index ( ch ) + 1 NEW_LINE DEDENT if m == 1 : NEW_LINE INDENT total += list . index ( ch ) + 1 NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT codeforce = CodeForce ( ) NEW_LINE codeforce . main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE def isPerfectCube ( x ) : NEW_LINE INDENT cr = int ( math . pow ( x , 1 / 3 ) ) NEW_LINE return cr * cr * cr == x NEW_LINE DEDENT def canBePerfectCube ( N , K ) : NEW_LINE INDENT if isPerfectCube ( N + K ) or isPerfectCube ( N - K ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 7 NEW_LINE K = 1 NEW_LINE canBePerfectCube ( N , K ) NEW_LINE N = 5 NEW_LINE K = 4 NEW_LINE canBePerfectCube ( N , K ) NEW_LINE N = 7 NEW_LINE K = 2 NEW_LINE canBePerfectCube ( N , K ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE result = 2 * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT foot = t [ : n - i ] NEW_LINE if s . endswith ( foot ) : NEW_LINE INDENT result -= len ( foot ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class Graph : NEW_LINE INDENT def __init__ ( self , v ) : NEW_LINE INDENT self . V = v NEW_LINE self . adj = [ [ ] for _ in range ( v ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFSUtil ( self , v , visited ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE print ( v , end = " ▁ " ) NEW_LINE for n in self . adj [ v ] : NEW_LINE INDENT if not visited [ n ] : NEW_LINE INDENT self . DFSUtil ( n , visited ) NEW_LINE DEDENT DEDENT DEDENT def DFS ( self , v ) : NEW_LINE INDENT visited = [ False ] * self . V NEW_LINE self . DFSUtil ( v , visited ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = Graph ( 4 ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( " Following ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) NEW_LINE g . DFS ( 2 ) NEW_LINE DEDENT
import math NEW_LINE def countDigits ( val , arr ) : NEW_LINE INDENT while int ( val ) > 0 : NEW_LINE INDENT digit = int ( val ) % 10 NEW_LINE arr [ digit ] += 1 NEW_LINE val = int ( val ) / 10 NEW_LINE DEDENT DEDENT def countFrequency ( x , n ) : NEW_LINE INDENT freq_count = [ 0 ] * 10 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val = math . pow ( x , i ) NEW_LINE countDigits ( val , freq_count ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( freq_count [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 15 NEW_LINE n = 3 NEW_LINE countFrequency ( x , n ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE n = 0 NEW_LINE str = " " NEW_LINE a = [ ] NEW_LINE def solve ( ) : NEW_LINE INDENT a . sort ( ) NEW_LINE cur = a [ 0 ] * 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if a [ i ] < cur : NEW_LINE INDENT str += " YES \n " NEW_LINE return NEW_LINE DEDENT cur = a [ i ] * 2 NEW_LINE DEDENT str += " NO \n " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT lenv = False NEW_LINE if lenv : NEW_LINE INDENT with open ( " input . txt " , ' r ' ) as f : NEW_LINE INDENT lines = f . readlines ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT lines = sys . stdin . readlines ( ) NEW_LINE DEDENT n = int ( lines [ 0 ] . strip ( ) ) NEW_LINE a = list ( map ( int , lines [ 1 ] . strip ( ) . split ( ) ) ) NEW_LINE solve ( ) NEW_LINE print ( str ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def maxLeft ( n ) : NEW_LINE INDENT return n - 2 if n > 2 else 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( maxLeft ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE hs = set ( a [ 1 : ] + b [ 1 : ] ) NEW_LINE if len ( hs ) == n : NEW_LINE INDENT print ( " I ▁ become ▁ the ▁ guy . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Oh , ▁ my ▁ keyboard ! " ) NEW_LINE DEDENT ` ` ` NEW_LINE
import numpy as np NEW_LINE def linearCheck ( ar , arr ) : NEW_LINE INDENT m = 6 NEW_LINE n = 4 NEW_LINE for i in range ( m ) : NEW_LINE INDENT matched = True NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ar [ i ] [ j ] != arr [ j ] : NEW_LINE INDENT matched = False NEW_LINE break NEW_LINE DEDENT DEDENT if matched : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT mat = np . array ( [ [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 40 , 40 ] , [ 43 , 44 , 55 , 68 ] , [ 81 , 73 , 100 , 132 ] , [ 100 , 75 , 125 , 133 ] ] ) NEW_LINE row = np . array ( [ 10 , 9 , 22 , 23 ] ) NEW_LINE print ( linearCheck ( mat , row ) ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT if sum % n == 0 : NEW_LINE INDENT div = sum // n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > div : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT t -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT main = Main ( ) NEW_LINE main . solveD ( ) NEW_LINE DEDENT def solveD ( self ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE t = [ 0 ] * N NEW_LINE sum_t = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT t [ i ] = int ( input ( ) ) * 2 NEW_LINE sum_t += t [ i ] NEW_LINE DEDENT v = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT v [ i ] = int ( input ( ) ) * 2 NEW_LINE DEDENT tmp_v = 0 NEW_LINE tmp_t = 0 NEW_LINE max_v = [ 0 ] * ( sum_t + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT max_v [ tmp_t ] = v [ i ] if v [ i ] < tmp_v else tmp_v NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE for t_ind in range ( t [ i ] ) : NEW_LINE INDENT max_v [ tmp_t + 1 ] = v [ i ] if v [ i ] < tmp_v + 1 else tmp_v + 1 NEW_LINE tmp_t += 1 NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE DEDENT DEDENT tmp_v = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT max_v [ tmp_t ] = v [ i ] if v [ i ] < tmp_v else tmp_v NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE for t_ind in range ( t [ i ] ) : NEW_LINE INDENT back_v = v [ i ] if v [ i ] < tmp_v + 1 else tmp_v + 1 NEW_LINE tmp_t -= 1 NEW_LINE max_v [ tmp_t ] = max_v [ tmp_t ] if max_v [ tmp_t ] < back_v else back_v NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE DEDENT DEDENT answer = 0 NEW_LINE for i in range ( sum_t ) : NEW_LINE INDENT answer += ( max_v [ i ] + max_v [ i + 1 ] ) NEW_LINE DEDENT print ( answer * 0.125 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT
import math NEW_LINE def nthTerm ( n ) : NEW_LINE INDENT return 2 * int ( math . pow ( n , 2 ) ) + 4 * n - 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
import math NEW_LINE def nthTerm ( n ) : NEW_LINE INDENT return 7 * int ( math . pow ( n , 2 ) ) - 7 * n + 7 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
import math NEW_LINE def nthTerm ( n ) : NEW_LINE INDENT return 5 * int ( math . pow ( n , 2 ) ) - 5 * n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
import math NEW_LINE def nthTerm ( n ) : NEW_LINE INDENT return int ( math . pow ( n , 2 ) + 2 * n + 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
import math NEW_LINE def nthTerm ( n ) : NEW_LINE INDENT return 2 * ( n ** 3 ) + ( n ** 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
import math NEW_LINE def nthTerm ( n ) : NEW_LINE INDENT return 2 * int ( math . pow ( n , 2 ) ) - n - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class solution : NEW_LINE INDENT @ staticmethod NEW_LINE def nthTerm ( n ) : NEW_LINE INDENT return int ( pow ( n , 2 ) - 2 * n + 2 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( solution . nthTerm ( N ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def nthTerm ( n ) : NEW_LINE INDENT return 3 * ( n ** 2 ) + n - 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE n1 = int ( input ( ) ) NEW_LINE n2 = int ( input ( ) ) NEW_LINE x = abs ( n1 ) + abs ( n2 ) NEW_LINE if n1 >= 0 and n2 >= 0 : NEW_LINE INDENT print ( 0 , x , x , 0 ) NEW_LINE DEDENT elif n1 < 0 and n2 >= 0 : NEW_LINE INDENT print ( - x , 0 , 0 , x ) NEW_LINE DEDENT elif n1 < 0 and n2 < 0 : NEW_LINE INDENT print ( - x , 0 , 0 , - x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , - x , x , 0 ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE K = int ( input ( ) ) NEW_LINE subs = set ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT index = i NEW_LINE for j in range ( K ) : NEW_LINE INDENT if index + 1 + j <= len ( s ) : NEW_LINE INDENT subs . add ( s [ index : index + 1 + j ] ) NEW_LINE DEDENT DEDENT DEDENT subs2 = list ( subs ) NEW_LINE subs2 . sort ( ) NEW_LINE print ( subs2 [ K - 1 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
from typing import List NEW_LINE class Solution : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . memo = [ 0 , 1 ] NEW_LINE DEDENT def fib ( self , N : int ) -> int : NEW_LINE INDENT if N < len ( self . memo ) : NEW_LINE INDENT return self . memo [ N ] NEW_LINE DEDENT for i in range ( len ( self . memo ) , N + 1 ) : NEW_LINE INDENT self . memo . append ( self . memo [ i - 1 ] + self . memo [ i - 2 ] ) NEW_LINE DEDENT return self . memo [ N ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE N = 2 NEW_LINE out = sObj . fib ( N ) NEW_LINE print ( out ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT alph = [ 0 ] * 26 NEW_LINE s = input ( ) NEW_LINE abc = input ( ) NEW_LINE for char in s : NEW_LINE INDENT alph [ ord ( char ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if abc == " abc " and ( alph [ 0 ] > 0 and alph [ 1 ] > 0 and alph [ 2 ] > 0 ) : NEW_LINE INDENT res = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT while alph [ 2 ] > 0 : NEW_LINE INDENT res += chr ( 2 + ord ( ' a ' ) ) NEW_LINE alph [ 2 ] -= 1 NEW_LINE DEDENT while alph [ 1 ] > 0 : NEW_LINE INDENT res += chr ( 1 + ord ( ' a ' ) ) NEW_LINE alph [ 1 ] -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT while alph [ i ] > 0 : NEW_LINE INDENT res += chr ( i + ord ( ' a ' ) ) NEW_LINE alph [ i ] -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT res = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT while alph [ i ] > 0 : NEW_LINE INDENT res += chr ( i + ord ( ' a ' ) ) NEW_LINE alph [ i ] -= 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE class GFG : NEW_LINE INDENT PI = 3.142 NEW_LINE @ staticmethod NEW_LINE def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( GFG . PI / 180.0 ) NEW_LINE res = 1 NEW_LINE sign = 1 NEW_LINE fact = 1 NEW_LINE pow = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * - 1 NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) NEW_LINE pow = pow * x * x NEW_LINE res = res + sign * pow / fact NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT x = 50 NEW_LINE n = 5 NEW_LINE print ( float ( self . cosXSertiesSum ( x , 5 ) * 1000000 ) / 1000000.00 ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( N * ( N + 1 ) ) / 4 ) - ( ( S + 1 ) / 2 ) NEW_LINE return i NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = GFG . findNumber ( N , S ) NEW_LINE integerI = int ( i ) NEW_LINE if i - integerI == 0 : NEW_LINE INDENT print ( " Yes : ▁ " + str ( integerI ) + " , ▁ " + str ( integerI + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT N = 4 NEW_LINE S = 3 NEW_LINE GFG . check ( N , S ) NEW_LINE N = 5 NEW_LINE S = 3 NEW_LINE GFG . check ( N , S ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
import math NEW_LINE def multipleOfThree ( K , dig0 , dig1 ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = ( dig0 + dig1 ) % 10 NEW_LINE sum = dig0 + dig1 NEW_LINE if K == 2 : NEW_LINE INDENT if sum % 3 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT sum += temp NEW_LINE numberofGroups = ( K - 3 ) // 4 NEW_LINE remNumberofDigits = ( K - 3 ) % 4 NEW_LINE sum += ( numberofGroups * 20 ) NEW_LINE for i in range ( remNumberofDigits ) : NEW_LINE INDENT temp = ( 2 * temp ) % 10 NEW_LINE sum += temp NEW_LINE DEDENT if sum % 3 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT K = 5 NEW_LINE dig0 = 3 NEW_LINE dig1 = 4 NEW_LINE if multipleOfThree ( K , dig0 , dig1 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java . util . * ; NEW_LINE public class Codechef { public static void main ( String [ ] args ) throws Exception { try { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; long sum = 0 ; for ( int i = 0 ; i < n ; i + + ) { a [ i ] = sc . nextInt ( ) ; sum += a [ i ] ; } for ( int i = 0 ; i < n ; i + + ) { b [ i ] = sc . nextInt ( ) ; } Arrays . sort ( b ) ; long ans = b [ n - 1 ] + b [ n - 2 ] ; if ( sum <= ans ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } catch ( Exception e ) { } } } NEW_LINE
class GFG : NEW_LINE INDENT def countOcc ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( s ) - 3 ) : NEW_LINE INDENT c , l , a , p = 0 , 0 , 0 , 0 NEW_LINE for j in range ( i , i + 4 ) : NEW_LINE INDENT if s [ j ] == ' c ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif s [ j ] == ' l ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif s [ j ] == ' a ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif s [ j ] == ' p ' : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT if c == 1 and l == 1 and a == 1 and p == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " clapc " NEW_LINE print ( countOcc ( s . lower ( ) ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def countSteps ( x , y ) : NEW_LINE INDENT if x % y == 0 : NEW_LINE INDENT return x // y NEW_LINE DEDENT return x // y + countSteps ( y , x % y ) NEW_LINE DEDENT x = 100 NEW_LINE y = 19 NEW_LINE print ( countSteps ( x , y ) ) NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( sr - math . floor ( sr ) ) == 0 NEW_LINE DEDENT def isSunnyNum ( n ) : NEW_LINE INDENT if isPerfectSquare ( n + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE if isSunnyNum ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE class GFG : NEW_LINE INDENT PI = 3.14159265 NEW_LINE @ staticmethod NEW_LINE def area_inscribed ( P , B , H ) : NEW_LINE INDENT return ( ( P + B - H ) * ( P + B - H ) * ( GFG . PI / 4 ) ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT P , B , H = 3 , 4 , 5 NEW_LINE print ( GFG . area_inscribed ( P , B , H ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT replaces = [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT char1 , char2 = input ( ) . split ( ) NEW_LINE replaces [ ord ( char1 ) ] = char2 NEW_LINE DEDENT M = int ( input ( ) ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT c = input ( ) NEW_LINE print ( replaces [ c ] if replaces [ c ] != 0 else c , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import bisect NEW_LINE def getCount ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = n - 1 - upperBound ( v , n , v [ i ] - 1 ) NEW_LINE if tmp == v [ i ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def upperBound ( array , length , value ) : NEW_LINE INDENT low = 0 NEW_LINE high = length NEW_LINE while low < high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if value >= array [ mid ] : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE v = [ 1 , 2 , 3 , 4 ] NEW_LINE print ( getCount ( v , n ) ) NEW_LINE DEDENT
def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT val = i NEW_LINE while val % 2 == 0 and val > 0 : NEW_LINE INDENT val //= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while val % 5 == 0 and val > 0 : NEW_LINE INDENT val //= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 12 NEW_LINE print ( trailing_zeros ( N ) ) NEW_LINE DEDENT
class GfG : NEW_LINE INDENT def removeZero ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 10 != 0 : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def isEqual ( a , b ) : NEW_LINE INDENT if GfG . removeZero ( a ) + GfG . removeZero ( b ) == GfG . removeZero ( a + b ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = 105 NEW_LINE b = 106 NEW_LINE if GfG . isEqual ( a , b ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , str ) : NEW_LINE INDENT sp = str . split ( " " ) NEW_LINE self . type = sp [ 0 ] NEW_LINE self . isOption = len ( sp ) == 2 NEW_LINE self . child = [ ] NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT scan = Scanner ( System . in ) NEW_LINE N = scan . nextInt ( ) NEW_LINE node = [ Node ( scan . next ( ) ) for _ in range ( N ) ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT node [ scan . nextInt ( ) - 1 ] . child . append ( scan . nextInt ( ) - 1 ) NEW_LINE DEDENT print ( looprun ( node [ 0 ] ) % MOD ) NEW_LINE scan . close ( ) NEW_LINE DEDENT def looprun ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE if n . type == " E " : NEW_LINE INDENT for no in n . child : NEW_LINE INDENT ans *= looprun ( node [ no ] ) NEW_LINE ans %= MOD NEW_LINE DEDENT if n . isOption : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT elif n . type == " R " : NEW_LINE INDENT for no in n . child : NEW_LINE INDENT ans *= looprun ( node [ no ] ) + 1 NEW_LINE ans %= MOD NEW_LINE DEDENT if not n . isOption : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT DEDENT elif n . type == " A " : NEW_LINE INDENT for no in n . child : NEW_LINE INDENT ans += looprun ( node [ no ] ) NEW_LINE DEDENT if not n . isOption : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import java . util . Arrays NEW_LINE import java . util . Locale NEW_LINE import java . util . Scanner NEW_LINE def main ( ) : NEW_LINE INDENT scn = Scanner ( System . in ) NEW_LINE size = scn . nextInt ( ) NEW_LINE arr = [ 0 ] * size NEW_LINE for i in range ( size ) : NEW_LINE INDENT arr [ i ] = scn . nextInt ( ) NEW_LINE DEDENT print ( asd ( arr ) ) NEW_LINE DEDENT def asd ( arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ len ( arr ) // 2 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE count = 0 NEW_LINE while True : NEW_LINE INDENT if a > 0 and b > 0 : NEW_LINE INDENT count += 1 NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ans = a // 2 + b // 2 NEW_LINE print ( count , ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT n , m = map ( float , input ( ) . split ( ) ) NEW_LINE for i in range ( int ( m - ( n % m ) ) ) : NEW_LINE INDENT sys . stdout . write ( str ( int ( n / m ) ) + " ▁ " ) NEW_LINE DEDENT for i in range ( int ( m - ( n % m ) ) , int ( m ) ) : NEW_LINE INDENT sys . stdout . write ( str ( math . ceil ( n / m ) ) + " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE arr1 = [ 0 ] * 7 NEW_LINE arr2 = [ 0 ] * 7 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = bin ( ord ( s1 [ i ] ) ) . count ( '1' ) NEW_LINE arr1 [ set_bits ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = bin ( ord ( s2 [ i ] ) ) . count ( '1' ) NEW_LINE arr2 [ set_bits ] += 1 NEW_LINE DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT s1 = " geeks " NEW_LINE s2 = " forgeeks " NEW_LINE print ( GFG . totalPairs ( s1 , s2 ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def countSubSeq ( i , sum , cnt , a , n ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT if sum == 0 and cnt > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE ans += countSubSeq ( i + 1 , sum , cnt , a , n ) NEW_LINE ans += countSubSeq ( i + 1 , sum + a [ i ] , cnt + 1 , a , n ) NEW_LINE return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = [ - 1 , 2 , - 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubSeq ( 0 , 0 , 0 , a , n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE newS = [ ' ' ] * n NEW_LINE mid = ( n - 1 ) // 2 NEW_LINE counter = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = i + 1 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT newS [ mid - counter ] = s [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT newS [ mid + counter ] = s [ i ] NEW_LINE DEDENT if counter >= 0 : NEW_LINE INDENT counter -= temp NEW_LINE DEDENT else : NEW_LINE INDENT counter += temp NEW_LINE DEDENT DEDENT print ( ' ' . join ( newS ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def getCount ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while x > 0 : NEW_LINE INDENT count += x % 10 NEW_LINE x //= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE count = 0 NEW_LINE i = 1 NEW_LINE while math . pow ( i + a , n ) <= m : NEW_LINE INDENT x = int ( math . pow ( i + a , n ) ) NEW_LINE y = getCount ( x ) NEW_LINE if y == i : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def pivotedBinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = findPivot ( arr , 0 , n - 1 ) NEW_LINE if pivot == - 1 : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binarySearch ( arr , 0 , pivot - 1 , key ) NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) NEW_LINE DEDENT def findPivot ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if mid < high and arr [ mid ] > arr [ mid + 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if arr [ low ] >= arr [ mid ] : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return findPivot ( arr , mid + 1 , high ) NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE key = 3 NEW_LINE print ( " Index ▁ of ▁ the ▁ element ▁ is ▁ : ▁ " + str ( pivotedBinarySearch ( arr1 , n , key ) ) ) NEW_LINE
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE mod = 1000000007 NEW_LINE res = 0 NEW_LINE c = [ [ 0 for _ in range ( 4050 ) ] for _ in range ( 4050 ) ] NEW_LINE dp = [ 0 for _ in range ( 4050 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT c [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i ) : NEW_LINE INDENT c [ i ] [ j ] = ( c [ i - 1 ] [ j - 1 ] + c [ i - 1 ] [ j ] ) % mod NEW_LINE DEDENT c [ i ] [ i ] = 1 NEW_LINE DEDENT dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT dp [ i ] = ( dp [ i ] + dp [ j ] * c [ i - 1 ] [ j ] ) % mod NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT g = dp [ i ] * c [ n ] [ i ] % mod NEW_LINE res = ( res + g ) % mod NEW_LINE DEDENT print ( res ) NEW_LINE
from typing import List NEW_LINE class Point : NEW_LINE INDENT def __init__ ( self , x : int , y : int ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE P = [ Point ( 0 , 0 ) for _ in range ( N ) ] NEW_LINE for n in range ( N ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE P [ n ] = Point ( x , y ) NEW_LINE DEDENT P . sort ( key = lambda point : point . y ) NEW_LINE output = [ ] NEW_LINE lineCount = 0 NEW_LINE used = [ False ] * N NEW_LINE for n in range ( N ) : NEW_LINE INDENT if not used [ n ] : NEW_LINE INDENT lineCount += 1 NEW_LINE count = 0 NEW_LINE pos = n NEW_LINE line = [ ] NEW_LINE while not used [ pos ] : NEW_LINE INDENT count += 1 NEW_LINE used [ pos ] = True NEW_LINE line . append ( str ( pos + 1 ) ) NEW_LINE pos = P [ pos ] . x NEW_LINE DEDENT output . append ( str ( count ) + ' ▁ ' + ' ▁ ' . join ( line ) ) NEW_LINE DEDENT DEDENT print ( lineCount ) NEW_LINE for line in output : NEW_LINE INDENT print ( line ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java . util . * ; NEW_LINE public class Main { public static void main ( String [ ] args ) { Scanner stdin = new Scanner ( System . in ) ; int d = stdin . nextInt ( ) ; int [ ] dx = { 0 , 1 , 0 , - 1 } ; int [ ] dy = { - 1 , 0 , 1 , 0 } ; final int UP = 0 ; final int RIGHT = 1 ; final int DOWN = 2 ; final int LEFT = 3 ; for ( int t = 0 ; t < d ; t + + ) { int n = stdin . nextInt ( ) ; char [ ] [ ] map = new char [ n ] [ n ] ; for ( char [ ] array : map ) { Arrays . fill ( array , ' ▁ ' ) ; } int x = 0 ; int y = n ; int dir = UP ; int [ ] move = getMoveDistance ( n ) ; for ( int i = 0 ; i < n ; i + + ) { for ( int j = 0 ; j < move [ i ] ; j + + ) { x += dx [ dir ] ; y += dy [ dir ] ; map [ y ] [ x ] = ' # ' ; } dir = ( dir + 1 ) % 4 ; } for ( char [ ] array : map ) { System . out . println ( new String ( array ) ) ; } if ( t < d - 1 ) { System . out . println ( ) ; } } } static int [ ] getMoveDistance ( final int n ) { if ( n == 1 ) { int [ ] ans = { 1 } ; return ans ; } else { int [ ] ans = new int [ n ] ; ans [ 0 ] = n ; int rest = n ; rest -= 1 ; for ( int index = 1 ; index < n ; ) { ans [ index ] = rest ; index + + ; if ( index >= n ) { break ; } ans [ index ] = rest ; index + + ; rest -= 2 ; } return ans ; } } } NEW_LINE
class p090 : NEW_LINE INDENT def main ( args ) : NEW_LINE INDENT print ( p090 ( ) . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 << 10 ) : NEW_LINE INDENT for j in range ( i , 1 << 10 ) : NEW_LINE INDENT if bin ( i ) . count ( '1' ) == 6 and bin ( j ) . count ( '1' ) == 6 and self . isArrangementValid ( i , j ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return str ( count ) NEW_LINE DEDENT SQUARES = [ [ 0 , 1 ] , [ 0 , 4 ] , [ 0 , 9 ] , [ 1 , 6 ] , [ 2 , 5 ] , [ 3 , 6 ] , [ 4 , 9 ] , [ 6 , 4 ] , [ 8 , 1 ] ] NEW_LINE def isArrangementValid ( self , a , b ) : NEW_LINE INDENT if ( a >> 6 ) & 1 or ( a >> 9 ) & 1 : NEW_LINE INDENT a |= ( 1 << 6 ) | ( 1 << 9 ) NEW_LINE DEDENT if ( b >> 6 ) & 1 or ( b >> 9 ) & 1 : NEW_LINE INDENT b |= ( 1 << 6 ) | ( 1 << 9 ) NEW_LINE DEDENT for sqr in self . SQUARES : NEW_LINE INDENT if not ( ( a >> sqr [ 0 ] ) & 1 and ( b >> sqr [ 1 ] ) & 1 or ( a >> sqr [ 1 ] ) & 1 and ( b >> sqr [ 0 ] ) & 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
from collections import deque NEW_LINE class Graph : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . totalVertex = 0 NEW_LINE self . adjList = [ ] NEW_LINE DEDENT def loadAdjList ( self ) : NEW_LINE INDENT self . totalVertex = int ( input ( ) ) NEW_LINE for i in range ( self . totalVertex ) : NEW_LINE INDENT tmp = deque ( ) NEW_LINE idx1 = int ( input ( ) ) - 1 NEW_LINE degree = int ( input ( ) ) NEW_LINE for j in range ( degree ) : NEW_LINE INDENT idx2 = int ( input ( ) ) - 1 NEW_LINE tmp . append ( idx2 ) NEW_LINE DEDENT self . adjList . append ( tmp ) NEW_LINE DEDENT DEDENT def printAdjMatrix ( self ) : NEW_LINE INDENT adjMatrix = [ [ 0 for _ in range ( self . totalVertex ) ] for _ in range ( self . totalVertex ) ] NEW_LINE for i in range ( self . totalVertex ) : NEW_LINE INDENT vertexes = self . adjList [ i ] NEW_LINE for j in range ( self . totalVertex ) : NEW_LINE INDENT if j in vertexes : NEW_LINE INDENT adjMatrix [ i ] [ j ] = 1 NEW_LINE print ( "1" , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT adjMatrix [ i ] [ j ] = 0 NEW_LINE print ( "0" , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = Graph ( ) NEW_LINE g . loadAdjList ( ) NEW_LINE g . printAdjMatrix ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE pic = [ list ( input ( ) ) for _ in range ( n ) ] NEW_LINE inc1 = 0 NEW_LINE comeIn = [ False ] * 4 NEW_LINE if n > 1 or m > 1 : NEW_LINE INDENT for x in range ( n - 1 ) : NEW_LINE INDENT for y in range ( m - 1 ) : NEW_LINE INDENT for i in range ( x , 2 + x ) : NEW_LINE INDENT for j in range ( y , 2 + y ) : NEW_LINE INDENT if pic [ i ] [ j ] == ' f ' and not comeIn [ 0 ] : NEW_LINE INDENT inc1 += 1 NEW_LINE comeIn [ 0 ] = True NEW_LINE DEDENT elif pic [ i ] [ j ] == ' a ' and not comeIn [ 1 ] : NEW_LINE INDENT inc1 += 1 NEW_LINE comeIn [ 1 ] = True NEW_LINE DEDENT elif pic [ i ] [ j ] == ' c ' and not comeIn [ 2 ] : NEW_LINE INDENT inc1 += 1 NEW_LINE comeIn [ 2 ] = True NEW_LINE DEDENT elif pic [ i ] [ j ] == ' e ' and not comeIn [ 3 ] : NEW_LINE INDENT inc1 += 1 NEW_LINE comeIn [ 3 ] = True NEW_LINE DEDENT DEDENT DEDENT if inc1 == 4 : NEW_LINE INDENT inc1 += 1 NEW_LINE DEDENT inc1 = 0 NEW_LINE comeIn = [ False ] * 4 NEW_LINE DEDENT DEDENT print ( inc1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE in_data = sys . stdin . readline ( ) . strip ( ) NEW_LINE stk = [ ] NEW_LINE for c in in_data : NEW_LINE INDENT if not stk : NEW_LINE INDENT stk . append ( c ) NEW_LINE continue NEW_LINE DEDENT top = stk [ - 1 ] NEW_LINE if top == c : NEW_LINE INDENT stk . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( c ) NEW_LINE DEDENT DEDENT if not stk : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT X , Y , E = 0 , 0 , 0 NEW_LINE x , y = [ ] , [ ] NEW_LINE g = [ ] NEW_LINE vis = [ ] NEW_LINE matchTo = [ ] NEW_LINE def main ( self ) : NEW_LINE INDENT sc = Scanner ( ) NEW_LINE self . X = sc . nextInt ( ) NEW_LINE self . Y = sc . nextInt ( ) NEW_LINE self . E = sc . nextInt ( ) NEW_LINE self . x = [ 0 ] * self . E NEW_LINE self . y = [ 0 ] * self . E NEW_LINE self . g = [ [ ] for _ in range ( self . X + self . Y ) ] NEW_LINE for i in range ( self . X + self . Y ) : NEW_LINE INDENT self . g [ i ] = [ ] NEW_LINE DEDENT for i in range ( self . E ) : NEW_LINE INDENT self . x [ i ] = sc . nextInt ( ) NEW_LINE self . y [ i ] = sc . nextInt ( ) + self . X NEW_LINE self . g [ self . x [ i ] ] . append ( self . y [ i ] ) NEW_LINE self . g [ self . y [ i ] ] . append ( self . x [ i ] ) NEW_LINE DEDENT self . vis = [ False ] * ( self . X + self . Y ) NEW_LINE self . matchTo = [ - 1 ] * ( self . X + self . Y ) NEW_LINE match = 0 NEW_LINE for i in range ( self . X ) : NEW_LINE INDENT self . vis = [ False ] * ( self . X + self . Y ) NEW_LINE if self . dfs ( i ) : NEW_LINE INDENT match += 1 NEW_LINE DEDENT DEDENT print ( match ) NEW_LINE DEDENT def dfs ( self , v ) : NEW_LINE INDENT if v < 0 : NEW_LINE INDENT return True NEW_LINE DEDENT for u in self . g [ v ] : NEW_LINE INDENT if self . vis [ u ] : NEW_LINE INDENT continue NEW_LINE DEDENT self . vis [ u ] = True NEW_LINE if self . dfs ( self . matchTo [ u ] ) : NEW_LINE INDENT self . matchTo [ u ] = v NEW_LINE self . matchTo [ v ] = u NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT MAX = 100 NEW_LINE @ staticmethod NEW_LINE def count_mountains ( a , n ) : NEW_LINE INDENT A = [ [ 0 for _ in range ( n + 2 ) ] for _ in range ( n + 2 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT for j in range ( n + 2 ) : NEW_LINE INDENT if i == 0 or j == 0 or i == n + 1 or j == n + 1 : NEW_LINE INDENT A [ i ] [ j ] = float ( ' - inf ' ) NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( A [ i ] [ j ] > A [ i - 1 ] [ j ] and A [ i ] [ j ] > A [ i + 1 ] [ j ] and A [ i ] [ j ] > A [ i ] [ j - 1 ] and A [ i ] [ j ] > A [ i ] [ j + 1 ] and A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] and A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] and A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] and A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE n = 3 NEW_LINE print ( GFG . count_mountains ( a , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
N = 100005 NEW_LINE d = [ 0 ] * N NEW_LINE pre = [ 0 ] * N NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT global d , pre NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , int ( i ** 0.5 ) + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if d [ i ] == d [ i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print ( pre [ n ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT t , m = map ( int , input ( ) . split ( ) ) NEW_LINE memory = [ 0 ] * m NEW_LINE allocIdx = 0 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT command = input ( ) NEW_LINE if command == " alloc " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE len = 0 NEW_LINE canAlloc = False NEW_LINE for i in range ( m ) : NEW_LINE INDENT if memory [ i ] == 0 : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = 0 NEW_LINE DEDENT if len == n : NEW_LINE INDENT canAlloc = True NEW_LINE len = i - n + 1 NEW_LINE break NEW_LINE DEDENT DEDENT if canAlloc : NEW_LINE INDENT allocIdx += 1 NEW_LINE for i in range ( len , len + n ) : NEW_LINE INDENT memory [ i ] = allocIdx NEW_LINE DEDENT print ( allocIdx ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NULL " ) NEW_LINE DEDENT DEDENT elif command == " erase " : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if x <= 0 : NEW_LINE INDENT print ( " ILLEGAL _ ERASE _ ARGUMENT " ) NEW_LINE continue NEW_LINE DEDENT hasErased = False NEW_LINE for i in range ( m ) : NEW_LINE INDENT if memory [ i ] == x : NEW_LINE INDENT memory [ i ] = 0 NEW_LINE hasErased = True NEW_LINE DEDENT DEDENT if not hasErased : NEW_LINE INDENT print ( " ILLEGAL _ ERASE _ ARGUMENT " ) NEW_LINE DEDENT DEDENT elif command == " defragment " : NEW_LINE INDENT d = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if memory [ i ] == 0 : NEW_LINE INDENT d += 1 NEW_LINE DEDENT else : NEW_LINE INDENT memory [ i - d ] = memory [ i ] NEW_LINE DEDENT DEDENT for i in range ( m - d , m ) : NEW_LINE INDENT memory [ i ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " h " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sol = Solution ( ) NEW_LINE sol . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def area_of_regular_polygon ( n , len ) : NEW_LINE INDENT P = ( len * n ) NEW_LINE A = len / ( 2 * math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE area = ( P * A ) / 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_inscribed ( n , len ) : NEW_LINE INDENT area = area_of_regular_polygon ( n , len ) NEW_LINE triangle = area / n NEW_LINE ins_tri = ( triangle * 3 ) NEW_LINE return ins_tri NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 6 NEW_LINE len = 10 NEW_LINE print ( " { : . 3f } " . format ( area_of_triangle_inscribed ( n , len ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
MAX = 256 NEW_LINE def lastNonRepeating ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if freq [ ord ( str [ i ] ) ] == 1 : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return " - 1" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksForGeeks " NEW_LINE n = len ( str ) NEW_LINE print ( lastNonRepeating ( str , n ) ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE left = float ( ' inf ' ) NEW_LINE right = float ( ' - inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ai , bi = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( ai ) NEW_LINE b . append ( bi ) NEW_LINE left = min ( a [ i ] , left ) NEW_LINE right = max ( b [ i ] , right ) NEW_LINE DEDENT ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == left and b [ i ] == right : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def y ( x ) : NEW_LINE INDENT return 1 / ( 1 + x ) NEW_LINE DEDENT @ staticmethod NEW_LINE def BooleRule ( a , b ) : NEW_LINE INDENT n = 4 NEW_LINE h = int ( ( b - a ) / n ) NEW_LINE sum = 0 NEW_LINE bl = ( 7 * GFG . y ( a ) + 32 * GFG . y ( a + h ) + 12 * GFG . y ( a + 2 * h ) + 32 * GFG . y ( a + 3 * h ) + 7 * GFG . y ( a + 4 * h ) ) * 2 * h / 45 NEW_LINE sum = sum + bl NEW_LINE return sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT print ( " f ( x ) ▁ = ▁ % .4f " % GFG . BooleRule ( 0 , 4 ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT maxN = 300 NEW_LINE maxM = 300 NEW_LINE dp = [ [ 0 for i in range ( maxM ) ] for j in range ( maxN ) ] NEW_LINE v = [ [ False for i in range ( maxM ) ] for j in range ( maxN ) ] NEW_LINE @ staticmethod NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT if curr == m : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if GFG . v [ i ] [ curr ] : NEW_LINE INDENT return GFG . dp [ i ] [ curr ] NEW_LINE DEDENT GFG . v [ i ] [ curr ] = True NEW_LINE l = GFG . findLen ( arr , i + 1 , curr , n , m ) NEW_LINE r = GFG . findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) NEW_LINE GFG . dp [ i ] [ curr ] = l NEW_LINE if r != - 1 : NEW_LINE INDENT GFG . dp [ i ] [ curr ] = max ( GFG . dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return GFG . dp [ i ] [ curr ] NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE ans = GFG . findLen ( arr , 0 , ( ( 1 << 8 ) - 1 ) , n , m ) NEW_LINE if ans == - 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT maxN = 20 NEW_LINE maxM = 64 NEW_LINE dp = [ [ 0 for i in range ( maxM ) ] for j in range ( maxN ) ] NEW_LINE v = [ [ False for i in range ( maxM ) ] for j in range ( maxN ) ] NEW_LINE def findLen ( self , arr , i , curr , n , m ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT if curr == m : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if self . v [ i ] [ curr ] : NEW_LINE INDENT return self . dp [ i ] [ curr ] NEW_LINE DEDENT self . v [ i ] [ curr ] = True NEW_LINE l = self . findLen ( arr , i + 1 , curr , n , m ) NEW_LINE r = self . findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) NEW_LINE self . dp [ i ] [ curr ] = l NEW_LINE if r != - 1 : NEW_LINE INDENT self . dp [ i ] [ curr ] = max ( self . dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return self . dp [ i ] [ curr ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE ans = self . findLen ( arr , 0 , 0 , n , m ) NEW_LINE if ans == - 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE n = 0 NEW_LINE cost = [ ] NEW_LINE def main ( ) : NEW_LINE INDENT global n , cost NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT cost = [ [ 0 for _ in range ( n + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE cost [ a ] [ b ] = cost [ b ] [ a ] = c NEW_LINE ans += cost [ a ] [ b ] * 2 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT reaf = 0 NEW_LINE ii , jj = 0 , 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if cost [ i ] [ j ] > 0 or cost [ i ] [ j ] == - 1 : NEW_LINE INDENT reaf += 1 NEW_LINE ii = i NEW_LINE jj = j NEW_LINE DEDENT DEDENT if i != 1 and reaf == 1 : NEW_LINE INDENT ans -= cost [ ii ] [ jj ] * 2 NEW_LINE cost [ ii ] [ jj ] = cost [ jj ] [ ii ] = - 1 NEW_LINE DEDENT DEDENT print ( ans - max ( 1 ) ) NEW_LINE DEDENT DEDENT def max ( m ) : NEW_LINE INDENT cut = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if cost [ m ] [ i ] > 0 : NEW_LINE INDENT cost [ i ] [ m ] = 0 NEW_LINE cut = max ( cut , cost [ m ] [ i ] + max ( i ) ) NEW_LINE DEDENT DEDENT return cut NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def f ( a , m , N ) : NEW_LINE INDENT if m >= 0 : NEW_LINE INDENT return f ( a + 3 * 10 ** m , m - 1 , N ) + f ( a + 5 * 10 ** m , m - 1 , N ) + f ( a + 7 * 10 ** m , m - 1 , N ) NEW_LINE DEDENT else : NEW_LINE INDENT s = str ( a ) NEW_LINE if '3' in s and '5' in s and '7' in s and a <= N : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = input ( ) NEW_LINE N = int ( S ) NEW_LINE ans = 0 NEW_LINE for i in range ( 3 , len ( S ) ) : NEW_LINE INDENT ans += ( 3 ** i ) - 3 * ( 2 ** i ) + 3 NEW_LINE DEDENT ans += f ( 3 * 10 ** ( len ( S ) - 1 ) , len ( S ) - 2 , N ) NEW_LINE ans += f ( 5 * 10 ** ( len ( S ) - 1 ) , len ( S ) - 2 , N ) NEW_LINE ans += f ( 7 * 10 ** ( len ( S ) - 1 ) , len ( S ) - 2 , N ) NEW_LINE print ( ans ) NEW_LINE DEDENT ` ` ` NEW_LINE
import numpy as np NEW_LINE def minDiff ( arr , n , k ) : NEW_LINE INDENT result = np . inf NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 100 , 300 , 200 , 1000 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minDiff ( arr , n , k ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 0 NEW_LINE self . t = [ 0 ] * 10 NEW_LINE self . input_values ( ) NEW_LINE DEDENT def input_values ( self ) : NEW_LINE INDENT self . n = int ( input ( ) ) NEW_LINE while self . n > 0 : NEW_LINE INDENT self . n -= 1 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT self . t [ i ] = int ( input ( ) ) NEW_LINE DEDENT print ( self . solve ( ) ) NEW_LINE DEDENT DEDENT def solve ( self ) : NEW_LINE INDENT L , R = 0 , 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if L < self . t [ i ] : NEW_LINE INDENT L = self . t [ i ] NEW_LINE DEDENT elif R < self . t [ i ] : NEW_LINE INDENT R = self . t [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT return " YES " NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE val = 0 NEW_LINE turn = 0 NEW_LINE while val < x : NEW_LINE INDENT val += turn + 1 NEW_LINE turn += 1 NEW_LINE DEDENT if val == x : NEW_LINE INDENT print ( turn ) NEW_LINE DEDENT elif val == x + 1 : NEW_LINE INDENT print ( turn + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( turn ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def Mean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT return sum / n NEW_LINE DEDENT def meanAbsDevtion ( arr , n ) : NEW_LINE INDENT absSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT absSum = absSum + abs ( arr [ i ] - Mean ( arr , n ) ) NEW_LINE DEDENT return absSum / n NEW_LINE DEDENT arr = [ 10 , 15 , 15 , 17 , 18 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( meanAbsDevtion ( arr , n ) ) NEW_LINE
class p204 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . LIMIT = Library . pow ( 10 , 9 ) NEW_LINE self . primes = Library . listPrimes ( 100 ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT return str ( self . count ( 0 , 1 ) ) NEW_LINE DEDENT def count ( self , primeIndex , product ) : NEW_LINE INDENT if primeIndex == len ( self . primes ) : NEW_LINE INDENT return 1 if product <= self . LIMIT else 0 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE while product <= self . LIMIT : NEW_LINE INDENT count += self . count ( primeIndex + 1 , product ) NEW_LINE product *= self . primes [ primeIndex ] NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( p204 ( ) . run ( ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE def maximumXOR ( n , l , r ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( int ( math . log ( r ) / math . log ( 2 ) ) , - 1 , - 1 ) : NEW_LINE INDENT if ( n & ( 1 << i ) ) > 0 : NEW_LINE INDENT if ( x > r ) or ( x + ( 1 << i ) - 1 < l ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( x ^ ( 1 << i ) ) <= r : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT DEDENT return n ^ x NEW_LINE DEDENT n = 7 NEW_LINE l = 2 NEW_LINE r = 23 NEW_LINE print ( " The ▁ output ▁ is " , maximumXOR ( n , l , r ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ False ] * ( N + 5 ) NEW_LINE i = 3 NEW_LINE while i * i <= N : NEW_LINE INDENT if not arr [ i ] : NEW_LINE INDENT j = i * i NEW_LINE while j <= N : NEW_LINE INDENT arr [ j ] = True NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT prime = [ 2 ] NEW_LINE i = 3 NEW_LINE while i <= N : NEW_LINE INDENT if not arr [ i ] : NEW_LINE INDENT prime . append ( i ) NEW_LINE DEDENT i += 2 NEW_LINE DEDENT i = 0 NEW_LINE ans = 1 NEW_LINE while ans * prime [ i ] <= N and i < len ( prime ) : NEW_LINE INDENT ans *= prime [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT N = 40 NEW_LINE print ( GFG . maxPrimefactorNum ( N ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = bin ( n ) [ 2 : ] NEW_LINE bit1 = bit [ : : - 1 ] NEW_LINE zero = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if bit1 [ i ] == '0' : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE ` ` ` NEW_LINE
0ERROR
import sys NEW_LINE class FastScanner : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin NEW_LINE self . buffer = [ ] NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT if not self . buffer : NEW_LINE INDENT self . buffer = self . input . readline ( ) . split ( ) NEW_LINE DEDENT return self . buffer . pop ( 0 ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT input = FastScanner ( ) NEW_LINE tc = input . nextInt ( ) NEW_LINE while tc > 0 : NEW_LINE INDENT n = input . nextInt ( ) NEW_LINE a = [ input . nextLong ( ) for _ in range ( n ) ] NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( count ) NEW_LINE tc -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def distinctSubString ( P , Q , K , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE sum += int ( Q [ pos ] ) NEW_LINE s += P [ j ] NEW_LINE if sum <= K : NEW_LINE INDENT S . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT P = " abcde " NEW_LINE Q = "12345678912345678912345678" NEW_LINE K = 5 NEW_LINE N = len ( P ) NEW_LINE print ( distinctSubString ( P , Q , K , N ) ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def makeEven ( string ) : NEW_LINE INDENT str = list ( string ) NEW_LINE n = len ( str ) NEW_LINE even = float ( ' inf ' ) NEW_LINE index = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( int ( str [ i ] ) % 2 == 0 ) : NEW_LINE INDENT even = int ( str [ i ] ) NEW_LINE index = i NEW_LINE DEDENT if ( even <= int ( str [ n - 1 ] ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( even == float ( ' inf ' ) ) : NEW_LINE INDENT return str NEW_LINE DEDENT GFG . swap ( str , index , n - 1 ) NEW_LINE return str NEW_LINE DEDENT def swap ( str , index1 , index2 ) : NEW_LINE INDENT temp = str [ index1 ] NEW_LINE str [ index1 ] = str [ index2 ] NEW_LINE str [ index2 ] = temp NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT str = "1356425" NEW_LINE print ( GFG . makeEven ( str ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , ( n // i ) + 1 ) : NEW_LINE INDENT div [ i * j ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE findDivisors ( n ) NEW_LINE DEDENT
` ` ` python NEW_LINE class ProB : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE ans = 0 NEW_LINE ss = " " NEW_LINE aa = [ ] NEW_LINE bb = [ ] NEW_LINE mm = [ 0 ] * 200005 NEW_LINE def main ( self , args ) : NEW_LINE INDENT in_data = input ( ) . split ( ) NEW_LINE self . ss = in_data [ 0 ] NEW_LINE self . aa = list ( self . ss ) NEW_LINE self . a = len ( self . ss ) NEW_LINE self . ss = in_data [ 1 ] NEW_LINE self . bb = list ( self . ss ) NEW_LINE self . b = len ( self . ss ) NEW_LINE for i in range ( 1 , self . b + 1 ) : NEW_LINE INDENT self . mm [ i ] = self . mm [ i - 1 ] + int ( self . bb [ i - 1 ] ) NEW_LINE DEDENT for i in range ( self . a ) : NEW_LINE INDENT if self . aa [ i ] == '0' : NEW_LINE INDENT self . ans += self . mm [ self . b - self . a + i + 1 ] - self . mm [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT self . ans += self . b - self . a + 1 - ( self . mm [ self . b - self . a + i + 1 ] - self . mm [ i ] ) NEW_LINE DEDENT DEDENT print ( self . ans ) NEW_LINE DEDENT DEDENT ProB ( ) . main ( None ) NEW_LINE ` ` ` NEW_LINE
MAX_CHAR = 256 NEW_LINE def printDistinct ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ n ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = ord ( str [ i ] ) NEW_LINE count [ x ] += 1 NEW_LINE if count [ x ] == 1 and x != ord ( ' ▁ ' ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if count [ x ] == 2 : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if index [ i ] != n : NEW_LINE INDENT print ( chr ( index [ i ] ) , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksforGeeks " NEW_LINE printDistinct ( str ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def calculate ( x , k , m ) : NEW_LINE INDENT result = x NEW_LINE k -= 1 NEW_LINE while k > 0 : NEW_LINE INDENT result = result ** x NEW_LINE if result > m : NEW_LINE INDENT result %= m NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 5 NEW_LINE k = 2 NEW_LINE m = 3 NEW_LINE print ( calculate ( x , k , m ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def converthenumber ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE res = " " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in [ '1' , '3' , '5' , '7' , '9' ] : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT if len ( res ) == 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if len ( res ) == 2 : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT n = 18720 NEW_LINE converthenumber ( n ) NEW_LINE ` ` ` NEW_LINE
import java . util . * ; NEW_LINE public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; List < String > chk = new ArrayList < > ( ) ; for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 + + ) { chk . add ( c1 + " " ) ; } for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 + + ) { for ( char c2 = ' a ' ; c2 <= ' z ' ; c2 + + ) { chk . add ( c1 + " " + c2 ) ; } } for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 + + ) { for ( char c2 = ' a ' ; c2 <= ' z ' ; c2 + + ) { for ( char c3 = ' a ' ; c3 <= ' z ' ; c3 + + ) { chk . add ( c1 + " " + c2 + " " + c3 ) ; } } } int t = sc . nextInt ( ) ; while ( t - - > 0 ) { int n = sc . nextInt ( ) ; String s = sc . next ( ) ; for ( String str : chk ) { if ( s . contains ( str ) ) continue ; System . out . println ( str ) ; break ; } } } public static boolean isPowerOfTen ( long input ) { if ( input % 10 != 0 | | input == 0 ) { return false ; } if ( input == 10 ) { return true ; } return isPowerOfTen ( input / 10 ) ; } static boolean isPrime ( long n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 | | n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 | | n % ( i + 2 ) == 0 ) return false ; return true ; } static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static long lcm ( long a , long b ) { return ( a / gcd ( a , b ) ) * b ; } } NEW_LINE
import sys NEW_LINE from io import StringIO NEW_LINE input_data = """ 5 STRNEWLINE 3 STRNEWLINE 1 ▁ 2 ▁ 3 STRNEWLINE 4 STRNEWLINE 4 ▁ 4 ▁ 4 ▁ 4 STRNEWLINE 2 STRNEWLINE 5 ▁ 5 STRNEWLINE 3 STRNEWLINE 1 ▁ 2 ▁ 3 STRNEWLINE 5 STRNEWLINE 1 ▁ 2 ▁ 2 ▁ 1 ▁ 1 STRNEWLINE """ NEW_LINE sys . stdin = StringIO ( input_data ) NEW_LINE class Reader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin NEW_LINE self . tokenizer = iter ( self . input . read ( ) . splitlines ( ) ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return next ( self . tokenizer ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def close ( self ) : NEW_LINE INDENT self . input . close ( ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT sc = Reader ( ) NEW_LINE out = sys . stdout NEW_LINE TT = sc . nextInt ( ) NEW_LINE while TT > 0 : NEW_LINE INDENT set = set ( ) NEW_LINE n = sc . nextInt ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT set . add ( sc . nextInt ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT out . write ( str ( max ( i + 1 , len ( set ) ) ) + " ▁ " ) NEW_LINE DEDENT TT -= 1 NEW_LINE DEDENT out . flush ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) // 2 NEW_LINE DEDENT def trace ( n , m ) : NEW_LINE INDENT an = 1 + ( n - 1 ) * ( m + 1 ) NEW_LINE rowmajorSum = sn ( n , an ) NEW_LINE an = 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE colmajorSum = sn ( n , an ) NEW_LINE return rowmajorSum + colmajorSum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE print ( trace ( N , M ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE field = [ list ( input ( ) ) for _ in range ( h ) ] NEW_LINE orbs = [ [ 0 ] * ( w + 1 ) for _ in range ( h + 1 ) ] NEW_LINE ingots = [ [ 0 ] * ( w + 1 ) for _ in range ( h + 1 ) ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w - 1 , - 1 , - 1 ) : NEW_LINE INDENT orbs [ i ] [ j ] = orbs [ i ] [ j + 1 ] NEW_LINE if field [ i ] [ j ] == ' O ' : NEW_LINE INDENT orbs [ i ] [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for j in range ( w ) : NEW_LINE INDENT for i in range ( h - 1 , - 1 , - 1 ) : NEW_LINE INDENT ingots [ i ] [ j ] = ingots [ i + 1 ] [ j ] NEW_LINE if field [ i ] [ j ] == ' I ' : NEW_LINE INDENT ingots [ i ] [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT total = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if field [ i ] [ j ] == ' J ' : NEW_LINE INDENT total += orbs [ i ] [ j ] * ingots [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( total ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if i % k == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( n // i ) % k == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( i * i == n ) and ( i % k == 0 ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 and i % k == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( GFG . countDivisors ( n , k ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y % 2 == 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if N < 6 : NEW_LINE INDENT temp = " " NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = temp + chr ( X + 48 ) NEW_LINE DEDENT res = int ( temp ) % M NEW_LINE return res NEW_LINE DEDENT if N % 2 == 0 : NEW_LINE INDENT half = GFG . findModuloByM ( X , N // 2 , M ) % M NEW_LINE res = ( half * GFG . power ( 10 , N // 2 , M ) + half ) % M NEW_LINE return res NEW_LINE DEDENT else : NEW_LINE INDENT half = GFG . findModuloByM ( X , N // 2 , M ) % M NEW_LINE res = ( half * GFG . power ( 10 , N // 2 + 1 , M ) + half * 10 + X ) % M NEW_LINE return res NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT X = 6 NEW_LINE N = 14 NEW_LINE M = 9 NEW_LINE print ( GFG . findModuloByM ( X , N , M ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE out = [ ] NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE p2 = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT p2 += ( int ( input ( ) ) % 2 + 1 ) % 2 NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE q2 = 0 NEW_LINE for _ in range ( m ) : NEW_LINE INDENT q2 += ( int ( input ( ) ) % 2 + 1 ) % 2 NEW_LINE DEDENT out . append ( p2 * q2 + ( n - p2 ) * ( m - q2 ) ) NEW_LINE DEDENT for o in out : NEW_LINE INDENT print ( o ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def findMaxDiff ( arr , n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE return 0 NEW_LINE DEDENT min_val = float ( ' inf ' ) NEW_LINE max_val = float ( ' - inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] - i ) > max_val : NEW_LINE INDENT max_val = arr [ i ] - i NEW_LINE DEDENT if ( arr [ i ] - i ) < min_val : NEW_LINE INDENT min_val = arr [ i ] - i NEW_LINE DEDENT DEDENT return ( max_val - min_val ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 9 , 15 , 4 , 12 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( self . findMaxDiff ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = [ list ( input ( ) ) for _ in range ( n ) ] NEW_LINE print ( solve ( arr , n ) ) NEW_LINE DEDENT def solve ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if arr [ i ] [ k ] == " . " : NEW_LINE INDENT if i + 2 < n and k + 1 < n and k - 1 >= 0 : NEW_LINE INDENT if arr [ i ] [ k ] == " . " and arr [ i + 1 ] [ k ] == " . " and arr [ i + 1 ] [ k - 1 ] == " . " and arr [ i + 1 ] [ k + 1 ] == " . " and arr [ i + 2 ] [ k ] == " . " : NEW_LINE INDENT arr [ i ] [ k ] = " # " NEW_LINE arr [ i + 1 ] [ k ] = " # " NEW_LINE arr [ i + 1 ] [ k - 1 ] = " # " NEW_LINE arr [ i + 1 ] [ k + 1 ] = " # " NEW_LINE arr [ i + 2 ] [ k ] = " # " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT DEDENT DEDENT return " YES " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE DEDENT
from sys import stdin NEW_LINE t = int ( stdin . readline ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( stdin . readline ( ) ) NEW_LINE a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE total_sum = sum ( a ) NEW_LINE if total_sum % n != 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT avg = total_sum // n NEW_LINE if avg in a : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
class GFG : NEW_LINE INDENT def isKthBitSet ( n , k ) : NEW_LINE INDENT if ( n >> ( k - 1 ) ) == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def setKthBit ( n , k ) : NEW_LINE INDENT return ( ( 1 << ( k - 1 ) ) | n ) NEW_LINE DEDENT def allBitsAreSet ( n ) : NEW_LINE INDENT if ( ( n + 1 ) & n ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def bitsAreInAltOrder ( n ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) NEW_LINE return GFG . allBitsAreSet ( num ) NEW_LINE DEDENT def bitsAreInAltPatrnInGivenRange ( n , l , r ) : NEW_LINE INDENT if GFG . isKthBitSet ( n , r ) : NEW_LINE INDENT num = n NEW_LINE left_shift = r NEW_LINE DEDENT else : NEW_LINE INDENT num = GFG . setKthBit ( n , ( r + 1 ) ) NEW_LINE left_shift = r + 1 NEW_LINE DEDENT num = num & ( ( 1 << left_shift ) - 1 ) NEW_LINE num = num >> ( l - 1 ) NEW_LINE return GFG . bitsAreInAltOrder ( num ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if GFG . bitsAreInAltPatrnInGivenRange ( n , l , r ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
import math NEW_LINE def factorial ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return factorial ( n ) // ( factorial ( n - r ) * factorial ( r ) ) NEW_LINE DEDENT def NumberOfWays ( n , x , y ) : NEW_LINE INDENT return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) NEW_LINE DEDENT n = 5 NEW_LINE x = 4 NEW_LINE y = 2 NEW_LINE print ( NumberOfWays ( n , x , y ) ) NEW_LINE
import java . util . Arrays NEW_LINE def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT result = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i <= n1 - 1 and j <= n2 - 1 : NEW_LINE INDENT if str1 [ i ] != str2 [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 [ i ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ " geeksforgeeks " , " geeks " , " geek " , " geezer " ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE N = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a . sort ( ) NEW_LINE total = 0 NEW_LINE for i in range ( N , 3 * N , 2 ) : NEW_LINE INDENT total += a [ i ] NEW_LINE DEDENT print ( total ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE a = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT a [ i ] = int ( input ( ) ) NEW_LINE DEDENT count = 0 NEW_LINE valid = True NEW_LINE current = 1 NEW_LINE while valid : NEW_LINE INDENT count += 1 NEW_LINE current = a [ current ] NEW_LINE if current == 2 : NEW_LINE INDENT valid = False NEW_LINE DEDENT if count == N : NEW_LINE INDENT count = 0 NEW_LINE valid = False NEW_LINE DEDENT DEDENT if count == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class p301 : NEW_LINE INDENT def main ( args ) : NEW_LINE INDENT print ( p301 ( ) . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return str ( a ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if arr [ low ] == arr [ high ] : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 ] * ( arr [ n - 1 ] + 1 ) NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( arr [ n - 1 ] + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT print ( " Element " , i , " occurs " , freq [ i ] , " times " ) NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE class p070 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT LIMIT = math . pow ( 10 , 7 ) NEW_LINE def run ( self ) : NEW_LINE INDENT minNumer = 1 NEW_LINE minDenom = 0 NEW_LINE totients = self . listTotients ( int ( self . LIMIT - 1 ) ) NEW_LINE for n in range ( 2 , len ( totients ) ) : NEW_LINE INDENT tot = totients [ n ] NEW_LINE if ( n * minDenom < minNumer * tot ) and self . hasSameDigits ( n , tot ) : NEW_LINE INDENT minNumer = n NEW_LINE minDenom = tot NEW_LINE DEDENT DEDENT if minDenom == 0 : NEW_LINE INDENT raise RuntimeError ( " Not ▁ found " ) NEW_LINE DEDENT return str ( minNumer ) NEW_LINE DEDENT def hasSameDigits ( self , x , y ) : NEW_LINE INDENT xdigits = list ( str ( x ) ) NEW_LINE ydigits = list ( str ( y ) ) NEW_LINE xdigits . sort ( ) NEW_LINE ydigits . sort ( ) NEW_LINE return xdigits == ydigits NEW_LINE DEDENT def listTotients ( self , n ) : NEW_LINE INDENT totients = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT totients [ i ] = i NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if totients [ i ] == i : NEW_LINE INDENT for j in range ( i , n + 1 , i ) : NEW_LINE INDENT totients [ j ] -= totients [ j ] // i NEW_LINE DEDENT DEDENT DEDENT return totients NEW_LINE DEDENT DEDENT p = p070 ( ) NEW_LINE p . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
import java NEW_LINE def intersection ( a , b , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if a [ i ] > b [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif b [ j ] > a [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 ] NEW_LINE b = [ 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE intersection ( a , b , n , m ) NEW_LINE DEDENT
import math NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log ( a [ i ] ) NEW_LINE DEDENT x = int ( math . exp ( sum / n ) ) NEW_LINE return x + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE DEDENT
class solution : NEW_LINE INDENT def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT if n < 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( lcm , arr [ i ] ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectSquare ( arr , n ) : NEW_LINE INDENT minPerfectSq = 0 NEW_LINE lcm = solution . lcmOfArray ( arr , n ) NEW_LINE minPerfectSq = int ( lcm ) NEW_LINE cnt = 0 NEW_LINE while lcm > 1 and lcm % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT if cnt % 2 != 0 : NEW_LINE INDENT minPerfectSq *= 2 NEW_LINE DEDENT i = 3 NEW_LINE while lcm > 1 : NEW_LINE INDENT cnt = 0 NEW_LINE while lcm % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= i NEW_LINE DEDENT if cnt % 2 != 0 : NEW_LINE INDENT minPerfectSq *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectSq NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( solution . minPerfectSquare ( arr , n ) ) NEW_LINE DEDENT DEDENT solution . main ( ) NEW_LINE
class cfg : NEW_LINE INDENT @ staticmethod NEW_LINE def subarrayCount ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE fast = 0 NEW_LINE slow = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] - arr [ i - 1 ] == 1 : NEW_LINE INDENT fast += 1 NEW_LINE DEDENT else : NEW_LINE INDENT length = fast - slow + 1 NEW_LINE result += length * ( length - 1 ) // 2 NEW_LINE fast = i NEW_LINE slow = i NEW_LINE DEDENT DEDENT if fast != slow : NEW_LINE INDENT length = fast - slow + 1 NEW_LINE result += length * ( length - 1 ) // 2 NEW_LINE DEDENT return result NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cfg . subarrayCount ( arr , n ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE flag = 0 NEW_LINE while n > 0 : NEW_LINE INDENT x = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT temp = n // 2 NEW_LINE if n % 4 == 0 and n > 8 : NEW_LINE INDENT temp = n - 1 NEW_LINE x += 1 NEW_LINE DEDENT n = temp NEW_LINE if flag == 0 : NEW_LINE INDENT flag = 1 NEW_LINE if x > 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += temp NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if flag == 0 : NEW_LINE INDENT n -= 1 NEW_LINE ans += 1 NEW_LINE flag = 1 NEW_LINE DEDENT else : NEW_LINE INDENT n -= 1 NEW_LINE flag = 0 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum_val = 0 NEW_LINE max_val = - 1000000 NEW_LINE min_val = 1000000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_val += a [ i ] NEW_LINE if max_val <= a [ i ] : NEW_LINE INDENT max_val = a [ i ] NEW_LINE DEDENT if min_val >= a [ i ] : NEW_LINE INDENT min_val = a [ i ] NEW_LINE DEDENT DEDENT print ( min_val , max_val , sum_val ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
MAX_CHARS = 256 NEW_LINE def findSubString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dist_count = 0 NEW_LINE visited = [ False ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not visited [ ord ( str [ i ] ) ] : NEW_LINE INDENT visited [ ord ( str [ i ] ) ] = True NEW_LINE dist_count += 1 NEW_LINE DEDENT DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = float ( ' inf ' ) NEW_LINE count = 0 NEW_LINE curr_count = [ 0 ] * MAX_CHARS NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count [ ord ( str [ j ] ) ] += 1 NEW_LINE if curr_count [ ord ( str [ j ] ) ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == dist_count : NEW_LINE INDENT while curr_count [ ord ( str [ start ] ) ] > 1 : NEW_LINE INDENT if curr_count [ ord ( str [ start ] ) ] > 1 : NEW_LINE INDENT curr_count [ ord ( str [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT return str [ start_index : start_index + min_len ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " aabcbcdbca " NEW_LINE print ( " Smallest ▁ window ▁ containing ▁ all ▁ distinct ▁ characters ▁ is : ▁ " + findSubString ( str ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT A = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE C = int ( input ( ) ) NEW_LINE D = int ( input ( ) ) NEW_LINE E = int ( input ( ) ) NEW_LINE F = int ( input ( ) ) NEW_LINE water = 0 NEW_LINE suger = 0 NEW_LINE watmax = 0 NEW_LINE sugmax = 0 NEW_LINE maxnodo = 100 * E / ( 100 + E ) NEW_LINE nodo = 0 NEW_LINE nodomax = 0 NEW_LINE for a in range ( 0 , F // 100 + 1 , A ) : NEW_LINE INDENT for b in range ( 0 , F // 100 + 1 , B ) : NEW_LINE INDENT for c in range ( 0 , F + 1 , C ) : NEW_LINE INDENT for d in range ( 0 , F + 1 , D ) : NEW_LINE INDENT water = 100 * a + 100 * b NEW_LINE suger = c + d NEW_LINE if water == 0 or water + suger > F : NEW_LINE INDENT break NEW_LINE DEDENT nodo = 100 * suger / ( water + suger ) NEW_LINE if nodo >= nodomax and nodo <= maxnodo : NEW_LINE INDENT watmax = water NEW_LINE sugmax = suger NEW_LINE nodomax = nodo NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( int ( watmax ) , int ( sugmax ) , int ( sugmax ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE before = None NEW_LINE while True : NEW_LINE INDENT input_str = input ( ) NEW_LINE if not input_str : NEW_LINE INDENT break NEW_LINE DEDENT str_list = input_str . split ( " , " ) NEW_LINE inner = [ int ( x ) for x in str_list ] NEW_LINE if before is None : NEW_LINE INDENT before = inner NEW_LINE DEDENT else : NEW_LINE INDENT tmp = [ 0 ] * len ( inner ) NEW_LINE for i in range ( len ( before ) ) : NEW_LINE INDENT if i < len ( tmp ) : NEW_LINE INDENT if tmp [ i ] < before [ i ] + inner [ i ] : NEW_LINE INDENT tmp [ i ] = before [ i ] + inner [ i ] NEW_LINE DEDENT DEDENT if len ( before ) > len ( tmp ) : NEW_LINE INDENT if ( i - 1 ) < len ( tmp ) and ( i - 1 ) >= 0 : NEW_LINE INDENT if tmp [ i - 1 ] < before [ i ] + inner [ i - 1 ] : NEW_LINE INDENT tmp [ i - 1 ] = before [ i ] + inner [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if ( i + 1 ) < len ( tmp ) : NEW_LINE INDENT if tmp [ i + 1 ] < before [ i ] + inner [ i + 1 ] : NEW_LINE INDENT tmp [ i + 1 ] = before [ i ] + inner [ i + 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT before = tmp NEW_LINE DEDENT DEDENT print ( before [ 0 ] ) NEW_LINE
0ERROR
import math NEW_LINE POWER = [ 1 , 10 , 100 , 1000 , 10000 , 100000 ] NEW_LINE def compare ( x1 , p1 , x2 , p2 ) : NEW_LINE INDENT if p1 == p2 : NEW_LINE INDENT direct_compare ( x1 , x2 ) NEW_LINE DEDENT else : NEW_LINE INDENT xx1 = x1 NEW_LINE xx2 = x2 NEW_LINE while xx1 % 10 == 0 : NEW_LINE INDENT xx1 /= 10 NEW_LINE p1 += 1 NEW_LINE DEDENT while xx2 % 10 == 0 : NEW_LINE INDENT xx2 /= 10 NEW_LINE p2 += 1 NEW_LINE DEDENT if p1 > p2 : NEW_LINE INDENT xx1 *= cached_power ( p1 - p2 ) NEW_LINE DEDENT elif p2 > p1 : NEW_LINE INDENT xx2 *= cached_power ( p2 - p1 ) NEW_LINE DEDENT direct_compare ( xx1 , xx2 ) NEW_LINE DEDENT DEDENT def cached_power ( p ) : NEW_LINE INDENT if p < 6 : NEW_LINE INDENT return POWER [ p ] NEW_LINE DEDENT else : NEW_LINE INDENT return math . pow ( 10 , p ) NEW_LINE DEDENT DEDENT def direct_compare ( x1 , x2 ) : NEW_LINE INDENT if x1 > x2 : NEW_LINE INDENT print ( " > " ) NEW_LINE DEDENT elif x2 > x1 : NEW_LINE INDENT print ( " < " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " = " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT no_of_comparison = int ( input ( ) ) NEW_LINE for i in range ( no_of_comparison ) : NEW_LINE INDENT x1 , p1 , x2 , p2 = map ( int , input ( ) . split ( ) ) NEW_LINE compare ( x1 , p1 , x2 , p2 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT arrs = [ ] NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrs . append ( input ( ) ) NEW_LINE DEDENT length = [ ] NEW_LINE index = 0 NEW_LINE returnDex = 0 NEW_LINE for tmp in arrs : NEW_LINE INDENT dexG = tmp . find ( " G " ) NEW_LINE dexS = tmp . find ( " S " ) NEW_LINE if dexG > dexS : NEW_LINE INDENT returnDex = - 1 NEW_LINE DEDENT length . append ( dexS - dexG ) NEW_LINE index += 1 NEW_LINE DEDENT length_set = set ( length ) NEW_LINE if returnDex == - 1 : NEW_LINE INDENT print ( returnDex ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( len ( length_set ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def search ( arr , n , x ) : NEW_LINE INDENT front = 0 NEW_LINE back = n - 1 NEW_LINE while front <= back : NEW_LINE INDENT if arr [ front ] == x or arr [ back ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ] NEW_LINE x = 130 NEW_LINE n = len ( arr ) NEW_LINE if GFG . search ( arr , n , x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countFreq ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if mp [ arr [ i ] ] != - 1 : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE GFG . countFreq ( arr , n ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def MinCostTree ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE st = [ float ( ' inf ' ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT while st [ - 1 ] <= arr [ i ] : NEW_LINE INDENT x = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE ans += x * min ( st [ - 1 ] , arr [ i ] ) NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 2 , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] * st [ i - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 5 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . MinCostTree ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE cache1 = [ 0 ] * 26 NEW_LINE cache2 = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cache1 [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE cache2 [ ord ( t [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT flag = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if cache1 [ i ] != cache2 [ i ] : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT s1 = list ( s ) NEW_LINE s2 = list ( t ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s1 [ i ] == s2 [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT pos = - 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if s1 [ j ] == s2 [ i ] : NEW_LINE INDENT pos = j NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( pos - 1 , i - 1 , - 1 ) : NEW_LINE INDENT l . append ( j ) NEW_LINE s1 [ j + 1 ] , s1 [ j ] = s1 [ j ] , s1 [ j + 1 ] NEW_LINE DEDENT s1 [ i ] = s2 [ i ] NEW_LINE DEDENT print ( len ( l ) ) NEW_LINE for x in l : NEW_LINE INDENT print ( x + 1 , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def findEquation ( a , b ) : NEW_LINE INDENT sum = ( a + b ) NEW_LINE product = ( a * b ) NEW_LINE print ( " x ^ 2 ▁ - ▁ ( " + str ( sum ) + " x ) ▁ + ▁ ( " + str ( product ) + " ) ▁ = ▁ 0" ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE GFG . findEquation ( a , b ) NEW_LINE DEDENT DEDENT
from math import pow NEW_LINE def circle_equation ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 NEW_LINE b = - 2 * y1 NEW_LINE c = pow ( r , 2 ) - pow ( x1 , 2 ) - pow ( y1 , 2 ) NEW_LINE print ( f " x ^ 2 ▁ + ▁ ( { a } x ) ▁ + ▁ y ^ 2 ▁ + ▁ ( { b } y ) ▁ = ▁ { c } . " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 , y1 , r = 2 , - 3 , 8 NEW_LINE circle_equation ( x1 , y1 , r ) NEW_LINE DEDENT
import itertools NEW_LINE def unique_combination ( l , s , K , local , A ) : NEW_LINE INDENT if s == K : NEW_LINE INDENT print ( " { " + " ▁ " . join ( map ( str , local ) ) + " } " ) NEW_LINE return NEW_LINE DEDENT for i in range ( l , len ( A ) ) : NEW_LINE INDENT if s + A [ i ] > K : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 1 and A [ i ] == A [ i - 1 ] and i > l : NEW_LINE INDENT continue NEW_LINE DEDENT local . append ( A [ i ] ) NEW_LINE unique_combination ( i + 1 , s + A [ i ] , K , local , A ) NEW_LINE local . pop ( ) NEW_LINE DEDENT DEDENT def Combination ( A , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE local = [ ] NEW_LINE unique_combination ( 0 , 0 , K , local , A ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 1 , 2 , 7 , 6 , 1 , 5 ] NEW_LINE A = arr NEW_LINE K = 8 NEW_LINE Combination ( A , K ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE l , r = 0 , n - 1 NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if x >= arr [ m ] : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT print ( l ) NEW_LINE DEDENT ` ` ` NEW_LINE
import re NEW_LINE def rep ( a , i , j ) : NEW_LINE INDENT chs = [ ] NEW_LINE for k in range ( len ( a ) ) : NEW_LINE INDENT if ' a ' <= a [ k ] <= ' z ' : NEW_LINE INDENT b = ord ( a [ k ] ) - 97 NEW_LINE chs . append ( chr ( ( b * i + j ) % 26 + 97 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT chs . append ( a [ k ] ) NEW_LINE DEDENT DEDENT return ' ' . join ( chs ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT builder = " " NEW_LINE n = int ( input ( ) ) NEW_LINE pattern = re . compile ( " that | this " ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT result = input ( ) NEW_LINE a = result NEW_LINE for i in range ( 1 , 26 , 2 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT a = rep ( result , i , j ) NEW_LINE if pattern . search ( a ) : NEW_LINE INDENT builder += a + ' \n ' NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( builder ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def findNature ( a , b , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return True if ( a & 1 ) == 1 else False NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return True if ( b & 1 ) == 1 else False NEW_LINE DEDENT if ( a & 1 ) == 0 : NEW_LINE INDENT if ( b & 1 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return n % 3 != 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) == 0 : NEW_LINE INDENT return ( n - 1 ) % 3 != 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n + 1 ) % 3 != 0 NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE n = 3 NEW_LINE if GFG . findNature ( a , b , n ) : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE import math NEW_LINE for line in sys . stdin : NEW_LINE INDENT a , b = map ( int , line . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( min ( abs ( b - math . hypot ( i , a - i ) ) for i in range ( 0 , a // 2 + 1 ) ) ) NEW_LINE DEDENT
0ERROR
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT question = input ( ) . strip ( ) NEW_LINE originalQ = question [ : - 1 ] . strip ( ) NEW_LINE ch = originalQ [ - 1 ] NEW_LINE vowels = [ " A " , " E " , " I " , " O " , " U " , " Y " ] NEW_LINE b = any ( ch . upper ( ) == e or ch . lower ( ) == e for e in vowels ) NEW_LINE print ( " YES " if b else " NO " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT mini = float ( ' inf ' ) NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT fir = i NEW_LINE sec = n // i NEW_LINE num1 = fir * k + sec NEW_LINE res = ( num1 // k ) * ( num1 % k ) NEW_LINE if res == n : NEW_LINE INDENT mini = min ( num1 , mini ) NEW_LINE DEDENT num2 = sec * k + fir NEW_LINE res = ( num2 // k ) * ( num2 % k ) NEW_LINE if res == n : NEW_LINE INDENT mini = min ( num2 , mini ) NEW_LINE DEDENT DEDENT DEDENT return mini NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE k = 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n = 5 NEW_LINE k = 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE DEDENT
import sys NEW_LINE def largest_circle ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE bff = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE status = [ - 2 ] * N NEW_LINE chain_length = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if bff [ bff [ i ] ] == i : NEW_LINE INDENT status [ i ] = - 1 NEW_LINE DEDENT DEDENT max_loop_size = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if status [ i ] != - 1 : NEW_LINE INDENT current = bff [ i ] NEW_LINE status [ i ] = i NEW_LINE steps = 1 NEW_LINE done = False NEW_LINE while not done : NEW_LINE INDENT if current == i : NEW_LINE INDENT if steps > max_loop_size : NEW_LINE INDENT max_loop_size = steps NEW_LINE DEDENT done = True NEW_LINE DEDENT elif status [ current ] == i : NEW_LINE INDENT done = True NEW_LINE DEDENT elif status [ current ] == - 1 : NEW_LINE INDENT if steps > chain_length [ current ] : NEW_LINE INDENT chain_length [ current ] = steps NEW_LINE DEDENT done = True NEW_LINE DEDENT else : NEW_LINE INDENT steps += 1 NEW_LINE status [ current ] = i NEW_LINE current = bff [ current ] NEW_LINE DEDENT DEDENT DEDENT DEDENT franken_circle = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if status [ i ] == - 1 : NEW_LINE INDENT franken_circle += ( chain_length [ i ] + 1 ) NEW_LINE DEDENT DEDENT return max ( franken_circle , max_loop_size ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT C = int ( input ( ) ) NEW_LINE for this_case in range ( 1 , C + 1 ) : NEW_LINE INDENT print ( " Case ▁ # % d : ▁ % d " % ( this_case , largest_circle ( ) ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class solution : NEW_LINE INDENT @ staticmethod NEW_LINE def SellingPrice ( CP , PP ) : NEW_LINE INDENT P_decimal = 1 + ( PP / 100 ) NEW_LINE res = P_decimal * CP NEW_LINE return res NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT C = 720 NEW_LINE P = 13 NEW_LINE print ( self . SellingPrice ( C , P ) ) NEW_LINE DEDENT DEDENT solution ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for j in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE p = [ 0 ] * ( n + 5 ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT p [ arr [ i ] ] = i NEW_LINE DEDENT p1 = p2 = p [ 1 ] NEW_LINE sys . stdout . write ( '1' ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = p [ i ] NEW_LINE if c > p2 : NEW_LINE INDENT p2 = c NEW_LINE DEDENT elif c < p1 : NEW_LINE INDENT p1 = c NEW_LINE DEDENT if ( p2 - p1 ) == i - 1 : NEW_LINE INDENT sys . stdout . write ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( '0' ) NEW_LINE DEDENT DEDENT sys . stdout . write ( ' \n ' ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def test ( b , n , s ) : NEW_LINE INDENT if b < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % b NEW_LINE n //= b NEW_LINE DEDENT return sum == s NEW_LINE DEDENT def lowerBound ( d , n ) : NEW_LINE INDENT left = 1 NEW_LINE right = n NEW_LINE logn = math . log ( n ) NEW_LINE while right - left > 1 : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE logm = ( d + 1 ) * math . log ( mid ) NEW_LINE if logm > logn : NEW_LINE INDENT right = mid NEW_LINE DEDENT else : NEW_LINE INDENT left = mid NEW_LINE DEDENT DEDENT return right NEW_LINE DEDENT n , s = map ( int , input ( ) . split ( ) ) NEW_LINE if n < s : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for d in range ( 39 , 1 , - 1 ) : NEW_LINE INDENT b = lowerBound ( d , n ) NEW_LINE while d * math . log ( b ) <= math . log ( n ) : NEW_LINE INDENT if test ( b , n , s ) : NEW_LINE INDENT print ( b ) NEW_LINE exit ( ) NEW_LINE DEDENT b += 1 NEW_LINE DEDENT DEDENT for a1 in range ( int ( math . sqrt ( n - s ) ) , 0 , - 1 ) : NEW_LINE INDENT if ( n - s ) % a1 == 0 : NEW_LINE INDENT b = ( n - s ) // a1 + 1 NEW_LINE a0 = n - a1 * b NEW_LINE if a0 >= 0 and a0 < b and a0 + a1 == s : NEW_LINE INDENT print ( b ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT if n == s : NEW_LINE INDENT print ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE import math NEW_LINE class B : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT m , b = map ( int , input ( ) . split ( ) ) NEW_LINE result = 0 NEW_LINE for x in range ( 1 , m * b + 1 ) : NEW_LINE INDENT y = int ( - 1.0 * x / m + b ) NEW_LINE result = max ( result , 1 * ( x + 1 ) * ( y ) * ( y + 1 ) / 2 + 1 * ( y + 1 ) * ( x ) * ( x + 1 ) / 2 ) NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT class MyScanner : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = sys . stdin NEW_LINE self . st = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st is None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = input ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT return input ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT B ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if m % n == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 5 NEW_LINE m = 10 NEW_LINE check ( n , m ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE cantidad = int ( input ( ) ) NEW_LINE solucion = [ ] NEW_LINE for i in range ( cantidad ) : NEW_LINE INDENT cantidadfor = int ( input ( ) ) NEW_LINE elementosS = input ( ) . split ( " ▁ " ) NEW_LINE elementos = [ int ( x ) for x in elementosS ] NEW_LINE for j in range ( cantidadfor ) : NEW_LINE INDENT centinela = False NEW_LINE for k in range ( cantidadfor - 1 , - 1 , - 1 ) : NEW_LINE INDENT if elementos [ j ] == elementos [ k ] and k - j >= 2 : NEW_LINE INDENT solucion . append ( " YES " ) NEW_LINE centinela = True NEW_LINE break NEW_LINE DEDENT DEDENT if centinela : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for i in range ( cantidad ) : NEW_LINE INDENT if solucion [ i ] == None : NEW_LINE INDENT solucion [ i ] = " NO " NEW_LINE DEDENT DEDENT for i in range ( cantidad ) : NEW_LINE INDENT print ( solucion [ i ] ) NEW_LINE DEDENT
import sys NEW_LINE a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE if a <= b : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE c = list ( s ) NEW_LINE ch = [ chr ( ord ( ' a ' ) + i ) for i in range ( 26 ) ] NEW_LINE for _ in range ( b ) : NEW_LINE INDENT m , n = input ( ) . split ( ) NEW_LINE mm , nn = m [ 0 ] , n [ 0 ] NEW_LINE flag = 1 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if ch [ j ] == mm and flag == 1 : NEW_LINE INDENT ch [ j ] = nn NEW_LINE flag = 0 NEW_LINE DEDENT if ch [ j ] == nn and flag == 1 : NEW_LINE INDENT ch [ j ] = mm NEW_LINE flag = 0 NEW_LINE DEDENT flag = 1 NEW_LINE DEDENT DEDENT for i in range ( a ) : NEW_LINE INDENT c [ i ] = ch [ ord ( c [ i ] ) - 97 ] NEW_LINE DEDENT print ( ' ' . join ( c ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def findNthOccur ( str , ch , N ) : NEW_LINE INDENT occur = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] == ch : NEW_LINE INDENT occur += 1 NEW_LINE DEDENT if occur == N : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT str = " geeks " NEW_LINE ch = ' e ' NEW_LINE N = 2 NEW_LINE print ( findNthOccur ( str , ch , N ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE sticks = [ 0 ] * 9 NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT sticks [ int ( input ( ) ) - 1 ] += 1 NEW_LINE DEDENT legs = False NEW_LINE headbody = False NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if sticks [ i ] >= 4 : NEW_LINE INDENT legs = True NEW_LINE DEDENT if sticks [ i ] >= 6 : NEW_LINE INDENT headbody = True NEW_LINE DEDENT if sticks [ i ] == 2 : NEW_LINE INDENT headbody = True NEW_LINE DEDENT DEDENT if legs and headbody : NEW_LINE INDENT print ( " Elephant " ) NEW_LINE DEDENT elif legs : NEW_LINE INDENT print ( " Bear " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Alien " ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE class p401 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . LIMIT = 1000000000000000 NEW_LINE self . MODULUS = pow ( 10 , 9 ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT splitCount = int ( math . sqrt ( self . LIMIT ) ) NEW_LINE splitCount = max ( splitCount // 3 , 1 ) NEW_LINE splitAt = int ( self . LIMIT / ( splitCount + 1 ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , splitAt + 1 ) : NEW_LINE INDENT count = self . LIMIT // i % self . MODULUS NEW_LINE term = ( i * i ) % self . MODULUS NEW_LINE term = ( term * count ) % self . MODULUS NEW_LINE sum = ( sum + term ) % self . MODULUS NEW_LINE DEDENT for i in range ( splitCount , 0 , - 1 ) : NEW_LINE INDENT start = self . LIMIT // ( i + 1 ) NEW_LINE end = self . LIMIT // i NEW_LINE sumSquares = self . sumSquaresMod ( end ) - self . sumSquaresMod ( start ) NEW_LINE sumSquares = ( sumSquares + self . MODULUS ) % self . MODULUS NEW_LINE sum = ( sum + i * sumSquares % self . MODULUS ) % self . MODULUS NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT def sumSquaresMod ( self , n ) : NEW_LINE INDENT MODULUS_BI = self . MODULUS NEW_LINE SIX_BI = 6 NEW_LINE x = n NEW_LINE y = x * ( x + 1 ) NEW_LINE y = y * ( x << 1 + 1 ) NEW_LINE y = y // SIX_BI NEW_LINE y = y % MODULUS_BI NEW_LINE return y NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k , z = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = 0 NEW_LINE for zz in range ( z + 1 ) : NEW_LINE INDENT dist = k - 2 * zz NEW_LINE if dist < 0 : NEW_LINE INDENT break NEW_LINE DEDENT max_val , score = 0 , 0 NEW_LINE for j in range ( dist + 1 ) : NEW_LINE INDENT if j < n - 1 : NEW_LINE INDENT max_val = max ( max_val , a [ j ] + a [ j + 1 ] ) NEW_LINE DEDENT score += a [ j ] NEW_LINE DEDENT res = max ( res , score + max_val * zz ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def main ( ) : NEW_LINE INDENT len = int ( input ( ) ) NEW_LINE a = [ 0 ] * len NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE flag = False NEW_LINE isTrue = False NEW_LINE for i in range ( len ) : NEW_LINE INDENT a [ i ] = int ( input ( ) ) NEW_LINE if a [ i ] != i + 1 and not flag : NEW_LINE INDENT l = i + 1 NEW_LINE flag = True NEW_LINE continue NEW_LINE DEDENT if a [ i ] != i + 1 and flag : NEW_LINE INDENT r = i + 1 NEW_LINE if a [ r - 1 ] - a [ r - 2 ] > 0 : NEW_LINE INDENT isTrue = True NEW_LINE DEDENT DEDENT DEDENT print ( str ( l ) + " ▁ " + str ( r ) if not isTrue else "0 ▁ 0" ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE b = [ [ [ 0 for _ in range ( 2 ) ] for _ in range ( 3 ) ] for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT for k in range ( 2 ) : NEW_LINE INDENT b [ i ] [ j ] [ k ] = int ( input ( ) ) * 60 + int ( input ( ) ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for p in range ( n ) : NEW_LINE INDENT if ( b [ p ] [ 0 ] [ 0 ] <= b [ i ] [ 0 ] [ 1 ] <= b [ p ] [ 0 ] [ 1 ] and b [ p ] [ 1 ] [ 0 ] <= b [ j ] [ 1 ] [ 1 ] <= b [ p ] [ 1 ] [ 1 ] and b [ p ] [ 2 ] [ 0 ] <= b [ k ] [ 2 ] [ 1 ] <= b [ p ] [ 2 ] [ 1 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , res ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . aoj1159 = self . AOJ1159 ( ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . aoj1159 . do_it ( ) NEW_LINE DEDENT class AOJ1159 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 0 NEW_LINE self . p = 0 NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT person = [ 0 ] * self . n NEW_LINE wan = self . p NEW_LINE ban = 0 NEW_LINE result = - 1 NEW_LINE while True : NEW_LINE INDENT if wan == 0 : NEW_LINE INDENT wan = person [ ban ] NEW_LINE person [ ban ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT wan -= 1 NEW_LINE person [ ban ] += 1 NEW_LINE DEDENT if person [ ban ] == self . p : NEW_LINE INDENT result = ban NEW_LINE break NEW_LINE DEDENT ban = ( ban + 1 ) % self . n NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT def do_it ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT self . n = int ( input ( ) ) NEW_LINE self . p = int ( input ( ) ) NEW_LINE if self . n + self . p == 0 : NEW_LINE INDENT break NEW_LINE DEDENT self . solve ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class Main : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT sc = MyScanner ( ) NEW_LINE n = sc . nextInt ( ) NEW_LINE q = sc . nextInt ( ) NEW_LINE a = [ 0 ] * n NEW_LINE a [ 0 ] = sc . nextInt ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = sc . nextInt ( ) NEW_LINE DEDENT pw = sys . stdout NEW_LINE for i in range ( q ) : NEW_LINE INDENT x = sc . nextLong ( ) NEW_LINE cnt = 0 NEW_LINE right = 0 NEW_LINE sum = 0 NEW_LINE left = 0 NEW_LINE while left < n : NEW_LINE INDENT while right < n and sum + a [ right ] <= x : NEW_LINE INDENT sum += a [ right ] NEW_LINE right += 1 NEW_LINE DEDENT cnt += right - left NEW_LINE if right == left : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= a [ left ] NEW_LINE DEDENT left += 1 NEW_LINE DEDENT pw . write ( str ( cnt ) + " \n " ) NEW_LINE DEDENT pw . flush ( ) NEW_LINE DEDENT DEDENT class MyScanner : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . reader = sys . stdin NEW_LINE self . tokenizer = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT while self . tokenizer is None or not self . tokenizer . hasMoreTokens ( ) : NEW_LINE INDENT self . tokenizer = self . reader . readline ( ) . split ( ) NEW_LINE DEDENT DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT return self . tokenizer . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . main ( sys . argv ) NEW_LINE DEDENT
` ` ` python NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE counter = 0 NEW_LINE if a < b : NEW_LINE INDENT counter = ( b - a ) // 10 NEW_LINE DEDENT elif a > b : NEW_LINE INDENT counter = ( a - b ) // 10 NEW_LINE DEDENT if a % 10 != b % 10 : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT print ( counter ) NEW_LINE DEDENT ` ` ` NEW_LINE
maxSize = int ( 1e5 + 5 ) NEW_LINE isFib = [ False ] * maxSize NEW_LINE prefix = [ 0 ] * maxSize NEW_LINE def digitSum ( num ) : NEW_LINE INDENT s = 0 NEW_LINE while num != 0 : NEW_LINE INDENT s = s + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return s NEW_LINE DEDENT def generateFibonacci ( ) : NEW_LINE INDENT global isFib NEW_LINE isFib = [ False ] * maxSize NEW_LINE prev , curr = 0 , 1 NEW_LINE isFib [ prev ] = isFib [ curr ] = True NEW_LINE while curr < maxSize : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp < maxSize : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev , curr = curr , temp NEW_LINE DEDENT DEDENT def precompute ( k ) : NEW_LINE INDENT generateFibonacci ( ) NEW_LINE for i in range ( 1 , maxSize ) : NEW_LINE INDENT sum = digitSum ( i ) NEW_LINE if isFib [ sum ] and sum % k == 0 : NEW_LINE INDENT prefix [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , maxSize ) : NEW_LINE INDENT prefix [ i ] = prefix [ i ] + prefix [ i - 1 ] NEW_LINE DEDENT DEDENT def performQueries ( k , q , query ) : NEW_LINE INDENT precompute ( k ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l , r = query [ i ] [ 0 ] , query [ i ] [ 1 ] NEW_LINE cnt = prefix [ r ] - prefix [ l - 1 ] NEW_LINE print ( cnt ) NEW_LINE DEDENT DEDENT query = [ [ 1 , 11 ] , [ 5 , 15 ] , [ 2 , 24 ] ] NEW_LINE k = 2 NEW_LINE q = len ( query ) NEW_LINE performQueries ( k , q , query ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT X = [ 0 , 0 , 0 ] NEW_LINE Y = [ 0 , 0 , 0 ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT X [ i ] = int ( input ( ) ) NEW_LINE Y [ i ] = int ( input ( ) ) NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if Y [ i ] == Y [ ( i + 1 ) % 3 ] and Y [ i ] > Y [ ( i + 2 ) % 3 ] : NEW_LINE INDENT answer += abs ( X [ ( i + 1 ) % 3 ] - X [ i ] ) NEW_LINE DEDENT DEDENT print ( answer ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def isPalindrome ( str ) : NEW_LINE INDENT len = len ( str ) NEW_LINE for i in range ( 0 , len // 2 ) : NEW_LINE INDENT if str [ i ] != str [ len - 1 - i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT sub = str ( N ) NEW_LINE res_str = " " NEW_LINE sum = 0 NEW_LINE while N > 0 : NEW_LINE INDENT digit = N % 10 NEW_LINE sum += digit NEW_LINE N = N // 10 NEW_LINE DEDENT while len ( res_str ) < sum : NEW_LINE INDENT res_str += sub NEW_LINE DEDENT if len ( res_str ) > sum : NEW_LINE INDENT res_str = res_str [ 0 : sum ] NEW_LINE DEDENT if GFG . isPalindrome ( res_str ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT N = 10101 NEW_LINE if GFG . createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
0ERROR
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def sum_even_and_even_index ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 5 , 6 , 12 , 1 , 18 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Sum ▁ of ▁ even ▁ numbers ▁ at ▁ even ▁ indices ▁ is " , sum_even_and_even_index ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE T = int ( input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT s = input ( ) NEW_LINE if len ( s ) == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE continue NEW_LINE DEDENT count = 1 NEW_LINE a = True NEW_LINE for j in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ j ] == s [ j + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if count == 1 : NEW_LINE INDENT a = False NEW_LINE break NEW_LINE DEDENT elif j == len ( s ) - 2 : NEW_LINE INDENT a = False NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE DEDENT DEDENT DEDENT if a : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def printDuplicates ( arr , n ) : NEW_LINE INDENT fl = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ arr [ i ] % n ] >= n : NEW_LINE INDENT if arr [ arr [ i ] % n ] < 2 * n : NEW_LINE INDENT print ( arr [ i ] % n , end = " ▁ " ) NEW_LINE fl = 1 NEW_LINE DEDENT DEDENT arr [ arr [ i ] % n ] += n NEW_LINE DEDENT if not ( fl > 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 6 , 3 , 1 , 3 , 6 , 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE GFG . printDuplicates ( arr , arr_size ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( 1.0 / ( n - i ) ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) / 3 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE DEDENT
def maxHandshake ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) / 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( maxHandshake ( n ) ) NEW_LINE DEDENT
def grayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( grayCode ( n ) ) NEW_LINE DEDENT
def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) / 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE print ( Max_Sum ( n ) ) NEW_LINE DEDENT
def possibleways ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 4 == 0 : NEW_LINE INDENT return n // 4 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 20 NEW_LINE print ( possibleways ( n ) ) NEW_LINE DEDENT
def CountSetBits ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n & 1 ) == 1 : NEW_LINE INDENT return 1 + CountSetBits ( n >> 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return CountSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 21 NEW_LINE print ( CountSetBits ( n ) ) NEW_LINE DEDENT
def sum ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( sum ( m , n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def SUM ( n , m ) : NEW_LINE INDENT if m == 1 : NEW_LINE INDENT return ( n * ( n + 1 ) // 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return ( sum * ( sum + 1 ) // 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( " SUM ( " + str ( n ) + " , ▁ " + str ( m ) + " ) : ▁ " + str ( SUM ( n , m ) ) ) NEW_LINE DEDENT
def maxLCM ( n ) : NEW_LINE INDENT return n * ( n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( maxLCM ( n ) ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
def cntWays ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) // 4 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 18 NEW_LINE print ( cntWays ( n ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def find_composite_nos ( n ) : NEW_LINE INDENT print ( 9 * n , 8 * n ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 4 NEW_LINE GFG . find_composite_nos ( n ) NEW_LINE DEDENT DEDENT
def findThirdDigit ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 if n & 1 > 0 else 6 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE print ( findThirdDigit ( n ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def countMaxIntersect ( n ) : NEW_LINE INDENT return ( n ) * ( n - 1 ) // 2 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n + 1 ) + sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE DEDENT
def highestPowerOf2 ( n ) : NEW_LINE INDENT return n & ( ~ ( n - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 48 NEW_LINE print ( highestPowerOf2 ( n ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 3 NEW_LINE print ( countIntersections ( n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE c = " None " NEW_LINE for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT if chr ( i ) not in s : NEW_LINE INDENT c = chr ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE if arr [ 0 ] == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT yes = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] % arr [ 0 ] != 0 : NEW_LINE INDENT yes = False NEW_LINE break NEW_LINE DEDENT DEDENT if yes : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE if 1200 > num : NEW_LINE INDENT print ( " ABC " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ARC " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE maxElementValue = int ( 10 ** 9 ) NEW_LINE def main ( ) : NEW_LINE INDENT elements = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE rightDistance = [ 0 ] * ( len ( elements ) + 1 ) NEW_LINE rightDistance [ - 1 ] = maxElementValue NEW_LINE leftDistance = [ 0 ] * ( len ( elements ) + 1 ) NEW_LINE leftDistance [ 0 ] = maxElementValue NEW_LINE for i in range ( len ( rightDistance ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT if elements [ i ] == 0 : NEW_LINE INDENT rightDistance [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT rightDistance [ i ] = rightDistance [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT for j in range ( 1 , len ( leftDistance ) ) : NEW_LINE INDENT if elements [ j - 1 ] == 0 : NEW_LINE INDENT leftDistance [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT leftDistance [ j ] = leftDistance [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( len ( elements ) ) : NEW_LINE INDENT print ( min ( rightDistance [ i ] , leftDistance [ i + 1 ] ) , end = " " ) NEW_LINE if i + 1 < len ( elements ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while x != 0 and y != 0 and z != 0 : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT x , y , z = 12 , 15 , 5 NEW_LINE print ( " Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ % d " % self . smallest ( x , y , z ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT c1 = int ( input ( ) ) NEW_LINE c5 = int ( input ( ) ) NEW_LINE c10 = int ( input ( ) ) NEW_LINE c50 = int ( input ( ) ) NEW_LINE c100 = int ( input ( ) ) NEW_LINE c500 = int ( input ( ) ) NEW_LINE if c1 + c5 * 5 + c10 * 10 + c50 * 50 + c100 * 100 + c500 * 500 < 1000 : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . st = None NEW_LINE self . br = sys . stdin NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT if self . st is None or not self . st . hasMoreTokens ( ) : NEW_LINE INDENT self . st = input ( ) . split ( ) NEW_LINE DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def hasNext ( self ) : NEW_LINE INDENT if self . st is not None and self . st . hasMoreTokens ( ) : NEW_LINE INDENT return True NEW_LINE DEDENT s = input ( ) NEW_LINE if s is None or s == " " : NEW_LINE INDENT return False NEW_LINE DEDENT self . st = s . split ( ) NEW_LINE return True NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT return input ( ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT in_ = FastReader ( ) NEW_LINE m = in_ . nextLong ( ) NEW_LINE R = in_ . nextLong ( ) NEW_LINE result = ( 2 + 2. * ( m - 1 ) * m * ( m + 1 ) / 3 / m / m - 2 * ( 2 - math . sqrt ( 2 ) ) + ( 2 - math . sqrt ( 2 ) ) * ( 2 * m + 2 * ( m - 1 ) ) / m / m ) * R NEW_LINE print ( " { : . 12f } " . format ( result ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE def countCubes ( a , b ) : NEW_LINE INDENT return int ( math . floor ( b ** ( 1 / 3 ) ) - math . ceil ( a ** ( 1 / 3 ) ) + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 7 NEW_LINE b = 28 NEW_LINE print ( " Count ▁ of ▁ cubes ▁ is " , countCubes ( a , b ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT D , N = map ( int , input ( ) . split ( ) ) NEW_LINE if D == 0 and N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ 0 ] * N NEW_LINE e = [ 0 ] * N NEW_LINE r = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT aa , ee , rr = map ( int , input ( ) . split ( ) ) NEW_LINE a [ i ] = aa NEW_LINE e [ i ] = ee NEW_LINE r [ i ] = rr NEW_LINE DEDENT dp = [ [ INF for _ in range ( 101 ) ] for _ in range ( D + 1 ) ] NEW_LINE dp [ D ] [ 0 ] = 0 NEW_LINE for i in range ( D , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 101 ) : NEW_LINE INDENT if dp [ i ] [ j ] == INF : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( N ) : NEW_LINE INDENT if j < r [ k ] : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ max ( 0 , i - a [ k ] ) ] [ min ( 100 , j + e [ k ] ) ] = min ( dp [ max ( 0 , i - a [ k ] ) ] [ min ( 100 , j + e [ k ] ) ] , dp [ i ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT ret = INF NEW_LINE for i in range ( 101 ) : NEW_LINE INDENT ret = min ( ret , dp [ 0 ] [ i ] ) NEW_LINE DEDENT print ( " NA " if ret == INF else ret ) NEW_LINE DEDENT DEDENT INF = 1 << 30 NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class p012 : NEW_LINE INDENT def main ( args ) : NEW_LINE INDENT print ( p012 ( ) . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT triangle = 0 NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT if ( 2147483647 - triangle ) < i : NEW_LINE INDENT raise ArithmeticError ( " Overflow " ) NEW_LINE DEDENT triangle += i NEW_LINE if self . countDivisors ( triangle ) > 500 : NEW_LINE INDENT return str ( triangle ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def countDivisors ( self , n ) : NEW_LINE INDENT count = 0 NEW_LINE end = int ( n ** 0.5 ) NEW_LINE i = 1 NEW_LINE while i < end : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT count += 2 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if end * end == n : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT
import sys NEW_LINE def findDelta ( a , b , c , d ) : NEW_LINE INDENT return ( b * c - a * d ) / ( d - c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c , d = 3 , 9 , 3 , 5 NEW_LINE print ( " \u0394X ▁ = ▁ " + str ( findDelta ( a , b , c , d ) ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if isPrime [ p ] : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT def findPrimePair ( n ) : NEW_LINE INDENT isPrime = [ False ] * ( n + 1 ) NEW_LINE GFG . SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if isPrime [ i ] and isPrime [ n - i ] : NEW_LINE INDENT print ( i , n - i ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 74 NEW_LINE findPrimePair ( n ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def replaceDigit ( x , d1 , d2 ) : NEW_LINE INDENT result = 0 NEW_LINE multiply = 1 NEW_LINE while x % 10 > 0 : NEW_LINE INDENT remainder = x % 10 NEW_LINE if remainder == d1 : NEW_LINE INDENT result = result + d2 * multiply NEW_LINE DEDENT else : NEW_LINE INDENT result = result + remainder * multiply NEW_LINE DEDENT multiply *= 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return result NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT x = 645 NEW_LINE d1 = 6 NEW_LINE d2 = 5 NEW_LINE print ( replaceDigit ( x , d1 , d2 ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def printPattern ( i , j , n ) : NEW_LINE INDENT if j >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i >= n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if j == i or j == n - 1 - i : NEW_LINE INDENT if i == n - 1 - j : NEW_LINE INDENT print ( " / " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " \\ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " * " ) NEW_LINE DEDENT if printPattern ( i , j + 1 , n ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class Test : NEW_LINE INDENT arr = [ 1 , 5 , 7 , - 1 , 5 ] NEW_LINE @ staticmethod NEW_LINE def getPairsCount ( n , sum ) : NEW_LINE INDENT hm = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in hm : NEW_LINE INDENT hm [ arr [ i ] ] = 0 NEW_LINE DEDENT hm [ arr [ i ] ] += 1 NEW_LINE DEDENT twice_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sum - arr [ i ] ) in hm : NEW_LINE INDENT twice_count += hm [ sum - arr [ i ] ] NEW_LINE DEDENT if sum - arr [ i ] == arr [ i ] : NEW_LINE INDENT twice_count -= 1 NEW_LINE DEDENT DEDENT return twice_count // 2 NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT sum = 6 NEW_LINE print ( " Count ▁ of ▁ pairs ▁ is " , Test . getPairsCount ( len ( Test . arr ) , sum ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import java . util . * ; NEW_LINE class GFG : NEW_LINE INDENT def Count_subarray ( arr , n ) : NEW_LINE INDENT subarray_sum = 0 NEW_LINE remaining_sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT subarray_sum = 0 NEW_LINE remaining_sum = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT subarray_sum += arr [ k ] NEW_LINE DEDENT for l in range ( 0 , i ) : NEW_LINE INDENT remaining_sum += arr [ l ] NEW_LINE DEDENT for l in range ( j + 1 , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] NEW_LINE DEDENT if subarray_sum > remaining_sum : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . Count_subarray ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE times = min ( a , b ) - 1 + n - max ( a , b ) NEW_LINE if times > x : NEW_LINE INDENT print ( n - 1 - ( times - x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE sum = 0 NEW_LINE a = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = int ( input ( ) ) NEW_LINE sum += tmp NEW_LINE if tmp % 10 != 0 : NEW_LINE INDENT a . append ( tmp ) NEW_LINE DEDENT DEDENT a . sort ( ) NEW_LINE i = 0 NEW_LINE while sum % 10 == 0 and i < len ( a ) : NEW_LINE INDENT sum -= a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT if sum % 10 == 0 : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in l : NEW_LINE INDENT l . append ( a [ i ] ) NEW_LINE DEDENT DEDENT ans = float ( ' inf ' ) NEW_LINE for j in range ( len ( l ) ) : NEW_LINE INDENT moves = 0 NEW_LINE big = l [ j ] NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] == big : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT moves += 1 NEW_LINE i += k NEW_LINE DEDENT ans = min ( moves , ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def findRepeatingNumber ( arr , n ) : NEW_LINE INDENT sq = int ( math . sqrt ( n ) ) NEW_LINE range = ( n // sq ) + 1 NEW_LINE count = [ 0 ] * range NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ( arr [ i ] - 1 ) // sq ] += 1 NEW_LINE DEDENT selected_block = range - 1 NEW_LINE for i in range ( range - 1 ) : NEW_LINE INDENT if count [ i ] > sq : NEW_LINE INDENT selected_block = i NEW_LINE break NEW_LINE DEDENT DEDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( selected_block * sq ) < arr [ i ] <= ( ( selected_block + 1 ) * sq ) : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE if m [ arr [ i ] ] == 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 , 5 , 4 ] NEW_LINE n = 5 NEW_LINE print ( " One ▁ of ▁ the ▁ numbers ▁ repeated ▁ in ▁ the ▁ array ▁ is : ▁ " + str ( findRepeatingNumber ( arr , n ) ) ) NEW_LINE
import math NEW_LINE def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT maxPrime = 2 NEW_LINE n >>= 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT maxPrime = i NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT return maxPrime NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE n = 25698751364526 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE class Beat : NEW_LINE INDENT def __init__ ( self , number ) : NEW_LINE INDENT self . number = number NEW_LINE DEDENT def getNumber ( self ) : NEW_LINE INDENT return self . number NEW_LINE DEDENT numberEven = 0 NEW_LINE numberOdd = 0 NEW_LINE def input ( self , number ) : NEW_LINE INDENT if number % 2 == 0 : NEW_LINE INDENT Beat . numberEven += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Beat . numberOdd += 1 NEW_LINE DEDENT DEDENT def printResult ( self ) : NEW_LINE INDENT print ( min ( Beat . numberEven , Beat . numberOdd ) ) NEW_LINE Beat . numberEven = 0 NEW_LINE Beat . numberOdd = 0 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT number = int ( input ( ) ) NEW_LINE instance = Beat ( number ) NEW_LINE for i in range ( instance . getNumber ( ) ) : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE for k in range ( num ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE instance . input ( n ) NEW_LINE DEDENT instance . printResult ( ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT s1 = input ( ) NEW_LINE ans = 0 NEW_LINE c1 = 0 NEW_LINE c0 = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] == '1' : NEW_LINE INDENT if c0 > 0 : NEW_LINE INDENT c0 -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if c1 > 0 : NEW_LINE INDENT c1 -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans * 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def pythagoreanTriplet ( n ) : NEW_LINE INDENT for i in range ( 1 , n // 3 + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n // 2 + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if i * i + j * j == k * k : NEW_LINE INDENT print ( i , " , " , j , " , " , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ Triplet " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE pythagoreanTriplet ( n ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE class GFG : NEW_LINE INDENT def countDigits ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return int ( math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = 33 NEW_LINE b = - 24 NEW_LINE print ( countDigits ( a , b ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import java . util . * ; NEW_LINE public class GFG { public static int indexOfFirstOne ( int [ ] arr , int low , int high ) { int mid = 0 ; while ( low <= high ) { mid = ( low + high ) // 2 if ( arr [ mid ] == 1 & & ( mid == 0 | | arr [ mid - 1 ] == 0 ) ) { break ; } else if ( arr [ mid ] == 1 ) { high = mid - 1 ; } else { low = mid + 1 ; } } return mid ; } public static int posOfFirstOne ( int [ ] arr ) { int l = 0 , h = 1 ; while ( arr [ h ] == 0 ) { l = h ; h = 2 * h ; } return indexOfFirstOne ( arr , l , h ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 0 , 0 , 1 , 1 , 1 , 1 } ; System . out . println ( " Index ▁ = ▁ " + posOfFirstOne ( arr ) ) ; } } NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin . readline NEW_LINE self . tokens = [ ] NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . tokens : NEW_LINE INDENT self . tokens = self . input ( ) . split ( ) NEW_LINE DEDENT return self . tokens . pop ( 0 ) NEW_LINE DEDENT def read_array ( self , n ) : NEW_LINE INDENT return [ self . next ( ) for _ in range ( n ) ] NEW_LINE DEDENT def next_int ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT fr = FastReader ( ) NEW_LINE n = fr . next_int ( ) NEW_LINE sum = 0 NEW_LINE total = 0 NEW_LINE i = 1 NEW_LINE if n == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT while n > 0 : NEW_LINE INDENT n -= 1 NEW_LINE if n > 0 : NEW_LINE INDENT if n >= 2 : NEW_LINE INDENT total += 1 NEW_LINE DEDENT n -= 2 NEW_LINE DEDENT total += 1 NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE from decimal import Decimal NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT num = 0 NEW_LINE sc = Scanner ( ) NEW_LINE d = None NEW_LINE while True : NEW_LINE INDENT num = sc . nextDouble ( ) NEW_LINE if num < 0 : NEW_LINE INDENT break NEW_LINE DEDENT d = Doctor ( num ) NEW_LINE if d . judge ( ) : NEW_LINE INDENT print ( d . getBD ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT class Doctor : NEW_LINE INDENT def __init__ ( self , num ) : NEW_LINE INDENT self . num = num NEW_LINE self . bd = " " NEW_LINE self . integers = int ( num ) NEW_LINE self . decimals = Decimal ( num - self . integers ) . quantize ( Decimal ( '1e - 4' ) ) NEW_LINE DEDENT def judge ( self ) : NEW_LINE INDENT if self . integers > 255 or self . decimals > Decimal ( '0.9375' ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def toBinaryDigits ( self ) : NEW_LINE INDENT tmp = " " NEW_LINE count = 1 NEW_LINE i = self . integers NEW_LINE while i > 0 : NEW_LINE INDENT tmp += str ( i % 2 ) NEW_LINE i //= 2 NEW_LINE DEDENT tmp = tmp [ : : - 1 ] NEW_LINE for i in range ( 8 - len ( tmp ) ) : NEW_LINE INDENT self . bd += "0" NEW_LINE DEDENT self . bd += tmp + " . " NEW_LINE while True : NEW_LINE INDENT if self . decimals == 0 : NEW_LINE INDENT self . bd += "0000" NEW_LINE break NEW_LINE DEDENT if count > 4 : NEW_LINE INDENT return False NEW_LINE DEDENT self . decimals *= 2 NEW_LINE if self . decimals >= 1 : NEW_LINE INDENT self . decimals -= 1 NEW_LINE self . bd += "1" NEW_LINE if self . decimals == 0 : NEW_LINE INDENT for i in range ( 4 - count ) : NEW_LINE INDENT self . bd += "0" NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . bd += "0" NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def getBD ( self ) : NEW_LINE INDENT if self . toBinaryDigits ( ) : NEW_LINE INDENT return self . bd NEW_LINE DEDENT return " NA " NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def digSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE rem = 0 NEW_LINE while n > 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE sum += rem NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def findX ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if i + GFG . digSum ( i ) == n : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 43 NEW_LINE print ( " x ▁ = ▁ " , GFG . findX ( n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT mod = int ( 10 ** 9 + 7 ) NEW_LINE def main ( self ) : NEW_LINE INDENT import sys NEW_LINE N = int ( input ( ) ) NEW_LINE a = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT a [ int ( input ( ) ) - 1 ] = i NEW_LINE DEDENT ans = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i != N - 1 and a [ i ] < a [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , cnt ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT ans = max ( ans , cnt ) NEW_LINE ans = N - ans NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE class Main : NEW_LINE INDENT def compute ( self ) : NEW_LINE INDENT for i in range ( 7 ) : NEW_LINE INDENT nHigh = int ( input ( ) ) NEW_LINE nLow = int ( input ( ) ) NEW_LINE print ( nHigh - nLow ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . compute ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT class pair : NEW_LINE INDENT def __init__ ( self , first , second ) : NEW_LINE INDENT self . first = first NEW_LINE self . second = second NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in q : NEW_LINE INDENT L , R = i . first , i . second NEW_LINE if L > R : NEW_LINE INDENT L , R = R , L NEW_LINE DEDENT if L != R and pref_xor [ R ] == pref_xor [ L - 1 ] : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def main ( arg ) : NEW_LINE INDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ GFG . pair ( 1 , 5 ) , GFG . pair ( 1 , 4 ) , GFG . pair ( 3 , 4 ) ] NEW_LINE GFG . performQueries ( Arr , q ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst . sort ( ) NEW_LINE c = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lst [ i ] >= c : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE R1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE M = int ( input ( ) ) NEW_LINE P1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE K = int ( input ( ) ) NEW_LINE P2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = int ( input ( ) ) NEW_LINE B = int ( input ( ) ) NEW_LINE maxR1 = max ( R1 ) NEW_LINE maxP1 = max ( P1 ) NEW_LINE minP2 = min ( P2 ) NEW_LINE r2 = math . sqrt ( maxR1 * maxR1 * ( B * maxP1 ) / ( A * minP2 + B * maxP1 ) ) NEW_LINE print ( r2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class HelloWorld : NEW_LINE INDENT def trapeziumPattern ( num ) : NEW_LINE INDENT firsthalf = 1 NEW_LINE secondhalf = ( num * num ) + 1 NEW_LINE numOfSpaces = 0 NEW_LINE for numOfLines in range ( num , 0 , - 1 ) : NEW_LINE INDENT for numOfSpacesCounter in range ( numOfSpaces , 0 , - 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for firstHalfCounter in range ( 1 , numOfLines + 1 ) : NEW_LINE INDENT if firstHalfCounter == numOfLines : NEW_LINE INDENT print ( ( firsthalf ) , end = " " ) NEW_LINE firsthalf += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( firsthalf ) + " * " , end = " " ) NEW_LINE firsthalf += 1 NEW_LINE DEDENT DEDENT for secondHalfCounter in range ( 1 , numOfLines + 1 ) : NEW_LINE INDENT print ( " * " + ( secondhalf ) , end = " " ) NEW_LINE secondhalf += 1 NEW_LINE DEDENT print ( ) NEW_LINE numOfSpaces += 2 NEW_LINE secondhalf = ( secondhalf - 1 ) - ( ( numOfLines - 1 ) * 2 ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT HelloWorld . trapeziumPattern ( 3 ) NEW_LINE DEDENT DEDENT
import numpy as np NEW_LINE def findPerm ( n , differences ) : NEW_LINE INDENT ans = [ 0 ] NEW_LINE x = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = differences [ i ] NEW_LINE x = x + diff NEW_LINE ans . append ( x ) NEW_LINE DEDENT anss = ans . copy ( ) NEW_LINE ans . sort ( ) NEW_LINE flag = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res = ans [ i ] - ans [ i - 1 ] NEW_LINE if res != 1 : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT mpp = { } NEW_LINE j = 1 NEW_LINE value_at_index = [ ] NEW_LINE for x1 in ans : NEW_LINE INDENT mpp [ x1 ] = j NEW_LINE j += 1 NEW_LINE DEDENT for x2 in anss : NEW_LINE INDENT value_at_index . append ( mpp [ x2 ] ) NEW_LINE DEDENT for x3 in value_at_index : NEW_LINE INDENT print ( x3 , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT differences = [ 2 , - 3 , 2 ] NEW_LINE n = len ( differences ) + 1 NEW_LINE findPerm ( n , differences ) NEW_LINE
import math NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n // i NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def printKAlmostPrimes ( k , n ) : NEW_LINE INDENT i = 1 NEW_LINE num = 2 NEW_LINE while i <= n : NEW_LINE INDENT if countPrimeFactors ( num ) == k : NEW_LINE INDENT print ( num , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT num += 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE k = 2 NEW_LINE print ( " First " , n , k , " - almost ▁ prime ▁ numbers : " ) NEW_LINE printKAlmostPrimes ( k , n ) NEW_LINE
class GFG : NEW_LINE INDENT def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 ] * 50 NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 29 NEW_LINE K = 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE solve ( N , K ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT self . run ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if x == 0 : NEW_LINE INDENT break NEW_LINE DEDENT sign = x > 0 NEW_LINE builder = [ ] NEW_LINE x = abs ( x ) NEW_LINE while x > 0 : NEW_LINE INDENT t = ( x % 10 ) NEW_LINE if not sign and t != 0 : NEW_LINE INDENT t = 10 - t NEW_LINE x += 10 NEW_LINE DEDENT builder . insert ( 0 , str ( t ) ) NEW_LINE sign = not sign NEW_LINE x //= 10 NEW_LINE DEDENT print ( ' ' . join ( builder ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def normal ( m , n ) : NEW_LINE INDENT N = ( abs ( m ) * abs ( n ) ) / math . sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) NEW_LINE return N NEW_LINE DEDENT m = - 5 NEW_LINE n = 3 NEW_LINE print ( normal ( m , n ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT str = input ( ) NEW_LINE num = str . split ( " ▁ " ) NEW_LINE n = float ( num [ 0 ] ) NEW_LINE h = float ( num [ 1 ] ) NEW_LINE for i in range ( 1 , int ( n ) ) : NEW_LINE INDENT ans = h * ( i / n ) ** 0.5 NEW_LINE sys . stdout . write ( " { : . 6f } ▁ " . format ( ans ) ) NEW_LINE if i == n - 1 : NEW_LINE INDENT sys . stdout . write ( " \n " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
def countBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n != 0 : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT i = 65 NEW_LINE print ( countBits ( i ) ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT h , w , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( h * w - ( h // a * a ) * ( w // b * b ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT sc = Scanner ( System . in ) NEW_LINE n = sc . nextInt ( ) NEW_LINE max_val = 0 NEW_LINE ans = 0 NEW_LINE l = [ ] NEW_LINE t = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t [ i ] = sc . nextInt ( ) NEW_LINE max_val = max ( max_val , t [ i ] ) NEW_LINE DEDENT for i in range ( 1 , max_val + 1 ) : NEW_LINE INDENT if max_val % i == 0 : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( l ) ) : NEW_LINE INDENT if l [ j ] >= t [ i ] : NEW_LINE INDENT ans += l [ j ] - t [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT arr2 = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr2 [ i ] = arr [ i ] % k NEW_LINE DEDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT current_length = 1 NEW_LINE j = i + 1 NEW_LINE while j < n : NEW_LINE INDENT if arr2 [ j ] == arr2 [ i ] : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT max_length = max ( max_length , current_length ) NEW_LINE i = j NEW_LINE DEDENT return max_length NEW_LINE DEDENT arr = [ 4 , 9 , 7 , 18 , 29 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 11 NEW_LINE print ( LongestSubarray ( arr , n , k ) ) NEW_LINE
import random NEW_LINE import sys NEW_LINE class FastScanner : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin . readline NEW_LINE self . tokens = [ ] NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . tokens : NEW_LINE INDENT self . tokens = self . input ( ) . split ( ) NEW_LINE DEDENT return self . tokens . pop ( 0 ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def readArray ( self , n ) : NEW_LINE INDENT return [ self . nextInt ( ) for _ in range ( n ) ] NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT fs = FastScanner ( ) NEW_LINE T = 1 NEW_LINE for _ in range ( T ) : NEW_LINE INDENT n = fs . nextLong ( ) NEW_LINE m = fs . nextLong ( ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if n - m > m - 1 : NEW_LINE INDENT print ( m + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m - 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' ▁ ' : NEW_LINE INDENT if hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT s = " the ▁ big ▁ dwarf ▁ only ▁ jumps " NEW_LINE n = len ( s ) NEW_LINE if GFG . isHeterogram ( s , n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
class p024 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT array = [ 0 ] * 10 NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT array [ i ] = i NEW_LINE DEDENT for i in range ( 999999 ) : NEW_LINE INDENT if not Library . nextPermutation ( array ) : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT DEDENT ans = " " NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT ans += str ( array [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if x > x1 and x < x2 and y > y1 and y < y2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = 0 , 0 , 10 , 8 NEW_LINE x , y = 1 , 5 NEW_LINE if self . FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT MX = 2001 NEW_LINE OFF = 1000 NEW_LINE class point : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def countPoints ( n , points ) : NEW_LINE INDENT minx = [ float ( ' inf ' ) ] * GFG . MX NEW_LINE miny = [ float ( ' inf ' ) ] * GFG . MX NEW_LINE maxx = [ - float ( ' inf ' ) ] * GFG . MX NEW_LINE maxy = [ - float ( ' inf ' ) ] * GFG . MX NEW_LINE for i in range ( n ) : NEW_LINE INDENT points [ i ] . x += GFG . OFF NEW_LINE points [ i ] . y += GFG . OFF NEW_LINE x = points [ i ] . x NEW_LINE y = points [ i ] . y NEW_LINE minx [ y ] = min ( minx [ y ] , x ) NEW_LINE maxx [ y ] = max ( maxx [ y ] , x ) NEW_LINE miny [ x ] = min ( miny [ x ] , y ) NEW_LINE maxy [ x ] = max ( maxy [ x ] , y ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = points [ i ] . x NEW_LINE y = points [ i ] . y NEW_LINE if minx [ y ] < x < maxx [ y ] and miny [ x ] < y < maxy [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT points = [ GFG . point ( 0 , 0 ) , GFG . point ( 0 , 1 ) , GFG . point ( 1 , 0 ) , GFG . point ( 0 , - 1 ) , GFG . point ( - 1 , 0 ) ] NEW_LINE n = len ( points ) NEW_LINE print ( GFG . countPoints ( n , points ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE
import sys NEW_LINE class Main : NEW_LINE INDENT def main ( self ) : NEW_LINE INDENT main = Main ( ) NEW_LINE main . solve ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT X , Y = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE Z = Y // X NEW_LINE answer = self . f ( Z ) + 1 NEW_LINE print ( answer ) NEW_LINE DEDENT def f ( self , Z ) : NEW_LINE INDENT t = 1 NEW_LINE result = 0 NEW_LINE while t < Z : NEW_LINE INDENT t *= 2 NEW_LINE result += 1 NEW_LINE DEDENT if t == Z : NEW_LINE INDENT return result NEW_LINE DEDENT return result - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main = Main ( ) NEW_LINE main . main ( ) NEW_LINE DEDENT
sticks = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] NEW_LINE def countSticks ( str , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt += sticks [ int ( str [ i ] ) ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT str = "56" NEW_LINE n = len ( str ) NEW_LINE print ( countSticks ( str , n ) ) NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE replaceNext = False NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if replaceNext : NEW_LINE INDENT a [ i ] = max ( a [ i - 1 ] , a [ i + 1 ] ) NEW_LINE ans += 1 NEW_LINE replaceNext = False NEW_LINE DEDENT if a [ i ] > a [ i - 1 ] and a [ i ] > a [ i + 1 ] : NEW_LINE INDENT replaceNext = True NEW_LINE DEDENT DEDENT if replaceNext : NEW_LINE INDENT a [ n - 1 ] = a [ n - 2 ] NEW_LINE ans += 1 NEW_LINE replaceNext = False NEW_LINE DEDENT print ( ans ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def command ( arr , a , b ) : NEW_LINE INDENT arr [ a ] ^= True NEW_LINE arr [ b + 1 ] ^= True NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT if arr [ k ] == True : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m = 5 , 3 NEW_LINE arr = [ False ] * ( n + 2 ) NEW_LINE GFG . command ( arr , 1 , 5 ) NEW_LINE GFG . command ( arr , 2 , 5 ) NEW_LINE GFG . command ( arr , 3 , 5 ) NEW_LINE GFG . process ( arr , n ) NEW_LINE GFG . result ( arr , n ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import java . util NEW_LINE def mostFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max_count = 1 NEW_LINE res = arr [ 0 ] NEW_LINE curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if curr_count > max_count : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if curr_count > max_count : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 1 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( mostFrequent ( arr , n ) ) NEW_LINE DEDENT
MAX = 26 NEW_LINE def maxLength ( str , len ) : NEW_LINE INDENT res = 0 NEW_LINE lastPos = [ - 1 ] * MAX NEW_LINE for i in range ( len ) : NEW_LINE INDENT C = ord ( str [ i ] ) - ord ( ' a ' ) NEW_LINE if lastPos [ C ] != - 1 : NEW_LINE INDENT res = max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) NEW_LINE DEDENT lastPos [ C ] = i NEW_LINE DEDENT return res NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE len = len ( str ) NEW_LINE print ( maxLength ( str , len ) ) NEW_LINE
class GFG : NEW_LINE INDENT MAX = 1000000 NEW_LINE @ staticmethod NEW_LINE def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 ] * GFG . MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 NEW_LINE DEDENT for j in range ( 1 , GFG . MAX ) : NEW_LINE INDENT if b [ j ] != 1 : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return float ( ' inf ' ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT k = 1 NEW_LINE arr = [ 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . ksmallest ( arr , n , k ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) > 0 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n + ( d * 13 ) ) NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT N = 2795 NEW_LINE if self . isDivisible ( N ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) > 0 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT N = 59173 NEW_LINE if self . isDivisible ( N ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) > 0 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT N = 1922 NEW_LINE if GFG . isDivisible ( N ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) > 0 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return n % 71 == 0 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5041 NEW_LINE if GFG . isDivisible ( N ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE def Odd_Sum ( n ) : NEW_LINE INDENT total = ( n + 1 ) // 2 NEW_LINE odd = total * total NEW_LINE return odd NEW_LINE DEDENT def Even_Sum ( n ) : NEW_LINE INDENT total = n // 2 NEW_LINE even = total * ( total + 1 ) NEW_LINE return even NEW_LINE DEDENT def sumLtoR ( L , R ) : NEW_LINE INDENT odd_sum = Odd_Sum ( R ) - Odd_Sum ( L - 1 ) NEW_LINE even_sum = Even_Sum ( R ) - Even_Sum ( L - 1 ) NEW_LINE return even_sum - odd_sum NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT L = 1 NEW_LINE R = 5 NEW_LINE print ( sumLtoR ( L , R ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : NEW_LINE INDENT for i in range ( lowQuant , upQuant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if lowCost <= ans <= upCost : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT lowCost = 14 NEW_LINE upCost = 30 NEW_LINE lowQuant = 5 NEW_LINE upQuant = 12 NEW_LINE r = 9 NEW_LINE if isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
` ` ` python NEW_LINE import math NEW_LINE def isPowerOfTwo ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return int ( math . ceil ( ( math . log ( n ) / math . log ( 2 ) ) ) ) == int ( math . floor ( ( math . log ( n ) / math . log ( 2 ) ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT if isPowerOfTwo ( 31 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT if isPowerOfTwo ( 64 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class p087 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = Library . listPrimes ( Library . sqrt ( LIMIT ) ) NEW_LINE sums = set ( [ 0 ] ) NEW_LINE for i in range ( 2 , 5 ) : NEW_LINE INDENT newsums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT q = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT q *= p NEW_LINE DEDENT if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT r = int ( q ) NEW_LINE for x in sums : NEW_LINE INDENT if x + r <= LIMIT : NEW_LINE INDENT newsums . add ( x + r ) NEW_LINE DEDENT DEDENT DEDENT sums = newsums NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
from collections import defaultdict NEW_LINE def longLenSub ( arr , n ) : NEW_LINE INDENT um = defaultdict ( int ) NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if arr [ i ] - 1 in um and len < um [ arr [ i ] - 1 ] : NEW_LINE INDENT len = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if arr [ i ] + 1 in um and len < um [ arr [ i ] + 1 ] : NEW_LINE INDENT len = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len + 1 NEW_LINE if longLen < um [ arr [ i ] ] : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Longest ▁ length ▁ subsequence ▁ = ▁ " + str ( longLenSub ( arr , n ) ) ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def maxDiff ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if curr_sum > 0 : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 80 , 2 , 6 , 3 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE line = input ( ) NEW_LINE MOD = 100000007 NEW_LINE def solve ( len , loop ) : NEW_LINE INDENT ret = 0 NEW_LINE dp = [ 0 ] * ( len + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , len + 1 ) : NEW_LINE INDENT for j in range ( 1 , min ( loop , i ) + 1 ) : NEW_LINE INDENT dp [ i ] += dp [ i - j ] NEW_LINE DEDENT dp [ i ] %= MOD NEW_LINE if ( len - i ) % loop == 0 : NEW_LINE INDENT ret += dp [ i ] NEW_LINE ret %= MOD NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT ans = 1 NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , len ( line ) ) : NEW_LINE INDENT if line [ i ] != line [ i - 1 ] : NEW_LINE INDENT ans *= solve ( i - prev , loop ( line [ prev ] ) ) NEW_LINE ans %= MOD NEW_LINE prev = i NEW_LINE DEDENT DEDENT ans *= solve ( len ( line ) - prev , loop ( line [ prev ] ) ) NEW_LINE ans %= MOD NEW_LINE return int ( ans ) NEW_LINE DEDENT def loop ( c ) : NEW_LINE INDENT return 3 if c == '8' or c == '0' else 5 NEW_LINE DEDENT while True : NEW_LINE INDENT line = input ( ) NEW_LINE if line == " # " : NEW_LINE INDENT break NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def countPairs ( n ) : NEW_LINE INDENT num = ( n // 2 ) + 1 NEW_LINE max_val = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if val == max_val : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE class Fast : NEW_LINE INDENT def sol ( self , br , pw ) : NEW_LINE INDENT s = br . readline ( ) . strip ( ) NEW_LINE cum = [ 0 ] * ( len ( s ) + 1 ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT cum [ i ] = cum [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT cum [ i ] = cum [ i - 1 ] NEW_LINE DEDENT DEDENT q = int ( br . readline ( ) . strip ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT l , r = map ( int , br . readline ( ) . split ( ) ) NEW_LINE pw . write ( str ( cum [ r - 1 ] - cum [ l - 2 ] ) + " \n " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT f = Fast ( ) NEW_LINE f . sol ( sys . stdin , sys . stdout ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n | m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT pow3 = [ 0 ] * ( n + 1 ) NEW_LINE pow3 [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pow3 [ i ] = pow3 [ i - 1 ] * 3 NEW_LINE DEDENT c = [ 0 ] * n NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE for _ in range ( a ) : NEW_LINE INDENT k = int ( input ( ) ) NEW_LINE c [ n - k ] = i NEW_LINE DEDENT DEDENT p = 0 NEW_LINE x = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT d = abs ( p - c [ i ] ) NEW_LINE x += pow3 [ i ] * d NEW_LINE if d == 1 : NEW_LINE INDENT p = 2 - p NEW_LINE DEDENT DEDENT y = pow3 [ n ] - 1 - x NEW_LINE if x > y : NEW_LINE INDENT x = y NEW_LINE DEDENT print ( - 1 if x > m else x ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT MAX = 100000 NEW_LINE @ staticmethod NEW_LINE def print_groups ( g1 , a , g2 , b ) : NEW_LINE INDENT for i in range ( a ) : NEW_LINE INDENT print ( g1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " and ▁ " , end = " " ) NEW_LINE for i in range ( b ) : NEW_LINE INDENT print ( g2 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT @ staticmethod NEW_LINE def checksum ( g1 , a , g2 , b ) : NEW_LINE INDENT x = sum ( g1 [ : a ] ) - sum ( g2 [ : b ] ) NEW_LINE return x == 0 NEW_LINE DEDENT @ staticmethod NEW_LINE def form_groups ( arr , x , g1 , a , g2 , b , n ) : NEW_LINE INDENT if x == n : NEW_LINE INDENT if GFG . checksum ( g1 , a , g2 , b ) : NEW_LINE INDENT GFG . print_groups ( g1 , a , g2 , b ) NEW_LINE DEDENT return NEW_LINE DEDENT g1 [ a ] = arr [ x ] NEW_LINE GFG . form_groups ( arr , x + 1 , g1 , a + 1 , g2 , b , n ) NEW_LINE g2 [ b ] = arr [ x ] NEW_LINE GFG . form_groups ( arr , x + 1 , g1 , a , g2 , b + 1 , n ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 9 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE g1 = [ 0 ] * GFG . MAX NEW_LINE g2 = [ 0 ] * GFG . MAX NEW_LINE GFG . form_groups ( arr , 0 , g1 , 0 , g2 , 0 , n ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE max_val = 0 NEW_LINE d = [ - 500 ] * ( n + 1 ) NEW_LINE d [ 0 ] = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if i - a [ j ] >= 0 and d [ i - a [ j ] ] != - 1 : NEW_LINE INDENT d [ i ] = max ( d [ i ] , d [ i - a [ j ] ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( d [ n ] ) NEW_LINE
import math NEW_LINE def maxSubseq ( vec , n ) : NEW_LINE INDENT suffix = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if vec [ i ] == 1 : NEW_LINE INDENT suffix += 1 NEW_LINE vec [ i ] = suffix NEW_LINE DEDENT DEDENT res = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if vec [ i ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if vec [ i ] > 0 : NEW_LINE INDENT res = max ( res , zero + vec [ i ] ) NEW_LINE DEDENT DEDENT return max ( res , zero ) NEW_LINE DEDENT input = [ 0 , 1 , 0 , 0 , 1 , 0 ] NEW_LINE n = len ( input ) NEW_LINE print ( maxSubseq ( input , n ) ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT R = 4 NEW_LINE C = 4 NEW_LINE @ staticmethod NEW_LINE def countPaths ( maze ) : NEW_LINE INDENT if maze [ 0 ] [ 0 ] == - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( GFG . R ) : NEW_LINE INDENT if maze [ i ] [ 0 ] == 0 : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , GFG . C ) : NEW_LINE INDENT if maze [ 0 ] [ i ] == 0 : NEW_LINE INDENT maze [ 0 ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , GFG . R ) : NEW_LINE INDENT for j in range ( 1 , GFG . C ) : NEW_LINE INDENT if maze [ i ] [ j ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if maze [ i - 1 ] [ j ] > 0 : NEW_LINE INDENT maze [ i ] [ j ] = maze [ i ] [ j ] + maze [ i - 1 ] [ j ] NEW_LINE DEDENT if maze [ i ] [ j - 1 ] > 0 : NEW_LINE INDENT maze [ i ] [ j ] = maze [ i ] [ j ] + maze [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maze [ GFG . R - 1 ] [ GFG . C - 1 ] if maze [ GFG . R - 1 ] [ GFG . C - 1 ] > 0 else 0 NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT maze = [ [ 0 , 0 , 0 , 0 ] , [ 0 , - 1 , 0 , 0 ] , [ - 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE print ( GFG . countPaths ( maze ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def isPrime ( N ) : NEW_LINE INDENT isPrime = True NEW_LINE arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] NEW_LINE if N < 2 : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT if N % 2 == 0 or N % 3 == 0 or N % 5 == 0 : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT for i in range ( 0 , int ( math . sqrt ( N ) ) , 30 ) : NEW_LINE INDENT for c in arr : NEW_LINE INDENT if c > math . sqrt ( N ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if N % ( c + i ) == 0 : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if not isPrime : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if isPrime : NEW_LINE INDENT print ( " Prime ▁ Number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Prime ▁ Number " ) NEW_LINE DEDENT DEDENT N = 121 NEW_LINE isPrime ( N ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x3 = x2 + ( y1 - y2 ) NEW_LINE y3 = y2 - ( x1 - x2 ) NEW_LINE x4 = x1 - ( y2 - y1 ) NEW_LINE y4 = y1 + ( x2 - x1 ) NEW_LINE print ( x3 , y3 , x4 , y4 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
def max ( x , y ) : NEW_LINE INDENT return x if x > y else y NEW_LINE DEDENT def lps ( seq , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 1 NEW_LINE DEDENT if seq [ i ] == seq [ j ] and i + 1 == j : NEW_LINE INDENT return 2 NEW_LINE DEDENT if seq [ i ] == seq [ j ] : NEW_LINE INDENT return lps ( seq , i + 1 , j - 1 ) + 2 NEW_LINE DEDENT return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is " , lps ( list ( seq ) , 0 , n - 1 ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def findLength ( str , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT l = i NEW_LINE r = i + 1 NEW_LINE lsum = 0 NEW_LINE rsum = 0 NEW_LINE while r < n and l >= 0 : NEW_LINE INDENT lsum += int ( str [ l ] ) NEW_LINE rsum += int ( str [ r ] ) NEW_LINE if lsum == rsum : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT str = "123123" NEW_LINE print ( " Length ▁ of ▁ the ▁ substring ▁ is " , GFG . findLength ( str , len ( str ) ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GfG : NEW_LINE INDENT def print ( self , a , n , ind ) : NEW_LINE INDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( a [ i % n ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = 6 NEW_LINE gfg = GfG ( ) NEW_LINE gfg . print ( a , n , 3 ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GfG : NEW_LINE INDENT def print ( self , a , n , ind ) : NEW_LINE INDENT b = [ None ] * ( 2 * n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = b [ n + i ] = a [ i ] NEW_LINE DEDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( self , argc ) : NEW_LINE INDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = 6 NEW_LINE self . print ( a , n , 3 ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE n , a , b , s = map ( str , sys . stdin . readline ( ) . split ( ) ) NEW_LINE n , a , b = int ( n ) , int ( a ) , int ( b ) NEW_LINE ans = a + b NEW_LINE flip = 1 if a > b else - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if s [ i ] == ' * ' : NEW_LINE INDENT flip = 1 if a > b else - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if flip == 1 : NEW_LINE INDENT a = 0 if a == 0 else a - 1 NEW_LINE DEDENT else : NEW_LINE INDENT b = 0 if b == 0 else b - 1 NEW_LINE DEDENT flip *= - 1 NEW_LINE DEDENT DEDENT print ( ans - a - b ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , i , d , c ) : NEW_LINE INDENT self . id = i NEW_LINE self . depth = d NEW_LINE self . contents = c NEW_LINE self . children = [ ] NEW_LINE DEDENT def findNode ( self , id ) : NEW_LINE INDENT if id == self . id : NEW_LINE INDENT return self NEW_LINE DEDENT for child in self . children : NEW_LINE INDENT target = child . findNode ( id ) NEW_LINE if target is not None : NEW_LINE INDENT return target NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def printContents ( self ) : NEW_LINE INDENT for i in range ( self . depth ) : NEW_LINE INDENT print ( ' . ' , end = ' ' ) NEW_LINE DEDENT print ( self . contents ) NEW_LINE for child in self . children : NEW_LINE INDENT child . printContents ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE id = int ( input ( ) ) NEW_LINE root = Node ( id + 1 , 0 , input ( ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT targetId = int ( input ( ) ) NEW_LINE parent = root . findNode ( targetId ) NEW_LINE parent . children . append ( Node ( id + 1 , parent . depth + 1 , input ( ) ) ) NEW_LINE DEDENT root . printContents ( ) NEW_LINE DEDENT
import java . io . * ; NEW_LINE import java . nio . Buffer ; NEW_LINE import java . sql . Array ; NEW_LINE import java . util . * ; NEW_LINE public class Main2 { static int v1 ; static int v2 ; static int t ; static int d ; static int [ ] [ ] dp ; public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; v1 = sc . nextInt ( ) ; v2 = sc . nextInt ( ) ; t = sc . nextInt ( ) ; d = sc . nextInt ( ) ; dp = new int [ t ] [ 1200 ] ; for ( int [ ] x : dp ) Arrays . fill ( x , - 1 ) ; int ans = - 1 ; if ( t == 2 ) System . out . println ( v1 + v2 ) ; else System . out . println ( v1 + v2 + calculate ( 1 , v1 , v1 ) ) ; } public static int calculate ( int currentTime , int currentSpeed , int prev ) { if ( currentSpeed < 0 ) return - ( int ) ( 1e8 ) ; if ( currentTime == t - 1 ) { if ( Math . abs ( currentSpeed - v2 ) <= d ) return 0 ; return - ( int ) ( 1e8 ) ; } if ( dp [ currentTime ] [ currentSpeed ] != - 1 ) { return dp [ currentTime ] [ currentSpeed ] ; } int bestAns = - ( int ) ( 1e8 ) ; for ( int i = 0 ; i <= d ; i + + ) { int ans = currentSpeed + i + calculate ( currentTime + 1 , currentSpeed + i , currentSpeed ) ; int ans2 = currentSpeed - i + calculate ( currentTime + 1 , currentSpeed - i , currentSpeed ) ; bestAns = Math . max ( bestAns , Math . max ( ans , ans2 ) ) ; } return dp [ currentTime ] [ currentSpeed ] = bestAns ; } } NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( input ( ) ) NEW_LINE b = list ( input ( ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j = n - 1 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if b [ j ] >= a [ i ] : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( j + 1 ) NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if b [ i ] > a [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( j ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT num = [ int ( input ( ) ) for _ in range ( 3 ) ] NEW_LINE num . sort ( ) NEW_LINE dis1 = num [ 2 ] - num [ 0 ] NEW_LINE dis2 = num [ 2 ] - num [ 1 ] NEW_LINE ans = 0 NEW_LINE if dis1 % 2 == 0 and dis2 % 2 == 0 : NEW_LINE INDENT ans = dis1 // 2 + dis2 // 2 NEW_LINE DEDENT elif dis1 % 2 != 0 and dis2 % 2 != 0 : NEW_LINE INDENT ans = dis1 // 2 + dis2 // 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = dis1 // 2 + dis2 // 2 + 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if j == 1 or i == j : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = ' ' ) NEW_LINE DEDENT bin ( 131 ) NEW_LINE print ( ) NEW_LINE bin ( 3 ) NEW_LINE
class p001 : NEW_LINE INDENT def main ( args ) : NEW_LINE INDENT print ( p001 ( ) . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1000 ) : NEW_LINE INDENT if i % 3 == 0 or i % 5 == 0 : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE str = input ( ) NEW_LINE s = " " NEW_LINE s1 = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] == ' n ' : NEW_LINE INDENT s += "1 ▁ " NEW_LINE DEDENT if str [ i ] == ' z ' : NEW_LINE INDENT s1 += "0 ▁ " NEW_LINE DEDENT DEDENT print ( s + s1 ) NEW_LINE
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT R , G = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( 2 * G ) - R ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
import math NEW_LINE def Circular ( n ) : NEW_LINE INDENT Result = 1 NEW_LINE while n > 0 : NEW_LINE INDENT Result = Result * n NEW_LINE n -= 1 NEW_LINE DEDENT return Result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( Circular ( n - 1 ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def productDiagonals ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= arr [ i ] [ i ] NEW_LINE product *= arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT product //= arr [ n // 2 ] [ n // 2 ] NEW_LINE DEDENT return product NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr1 = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 7 , 4 , 2 ] , [ 2 , 2 , 2 , 1 ] ] NEW_LINE print ( productDiagonals ( arr1 , 4 ) ) NEW_LINE arr2 = [ [ 2 , 1 , 2 , 1 , 2 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 2 , 1 , 2 , 1 , 2 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 2 , 1 , 2 , 1 , 2 ] ] NEW_LINE print ( productDiagonals ( arr2 , 5 ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import java . util . Scanner NEW_LINE import java . util . Arrays NEW_LINE class Main : NEW_LINE INDENT def run ( self ) : NEW_LINE INDENT sc = Scanner ( System . in ) NEW_LINE while True : NEW_LINE INDENT n = sc . nextInt ( ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT map = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ sc . nextInt ( ) ] += 1 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT ans = " - " NEW_LINE if map [ i ] != 0 : NEW_LINE INDENT ch = [ ' * ' ] * map [ i ] NEW_LINE ans = ' ' . join ( ch ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT DEDENT def main ( self , args ) : NEW_LINE INDENT m = Main ( ) NEW_LINE m . run ( ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT NO_OF_CHARS = 256 NEW_LINE @ staticmethod NEW_LINE def getSecondMostFreq ( str ) : NEW_LINE INDENT count = [ 0 ] * GFG . NO_OF_CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( GFG . NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] > count [ first ] : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif count [ i ] > count [ second ] and count [ i ] != count [ first ] : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return chr ( second ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE res = GFG . getSecondMostFreq ( str ) NEW_LINE if res != ' \0' : NEW_LINE INDENT print ( " Second ▁ most ▁ frequent ▁ char ▁ is ▁ " + res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ second ▁ most ▁ frequent ▁ character " ) NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE class Main : NEW_LINE INDENT def run ( self ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 4001 ) ] for j in range ( 5 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT for ii in range ( 1000 * i + 1 ) : NEW_LINE INDENT for iii in range ( max ( 0 , ii - 1000 ) , ii + 1 ) : NEW_LINE INDENT dp [ i ] [ ii ] += dp [ i - 1 ] [ iii ] NEW_LINE DEDENT DEDENT DEDENT for line in sys . stdin : NEW_LINE INDENT num = int ( line ) NEW_LINE print ( dp [ 4 ] [ num ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT
import java . util . Arrays NEW_LINE import java . util . Collections NEW_LINE def mySort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE Arrays . sort ( arr , 0 , n // 2 ) NEW_LINE Arrays . sort ( arr , n // 2 , n , Collections . reverseOrder ( ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 ] NEW_LINE mySort ( arr ) NEW_LINE print ( " Modified ▁ Array ▁ : ▁ { } " . format ( Arrays . toString ( arr ) ) ) NEW_LINE DEDENT
import java NEW_LINE def minflip ( arr1 , arr2 , arr3 , p , q , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] > 0 ) ^ ( arr2 [ i ] > 0 ) != ( arr3 [ i ] > 0 ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT return flip if flip <= p + q else - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr1 = [ 1 , 0 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 0 , 1 , 1 , 1 , 1 , 0 , 0 ] NEW_LINE arr3 = [ 1 , 1 , 1 , 1 , 0 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE p , q = 2 , 4 NEW_LINE print ( minflip ( arr1 , arr2 , arr3 , p , q , n ) ) NEW_LINE DEDENT
import math NEW_LINE def sum ( n ) : NEW_LINE INDENT s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i NEW_LINE DEDENT return s NEW_LINE DEDENT n = 5 NEW_LINE print ( " Sum ▁ is " , sum ( n ) ) NEW_LINE
from array import array NEW_LINE from collections import deque NEW_LINE def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = deque ( ) NEW_LINE oddArr = deque ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 != 1 : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr = sorted ( evenArr ) NEW_LINE oddArr = sorted ( oddArr , reverse = True ) NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = array ( ' i ' , [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] ) NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right = 0 NEW_LINE left = 0 NEW_LINE visited = [ False ] * n NEW_LINE while right < n : NEW_LINE INDENT while right < n and not visited [ arr [ right ] ] : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while left < right and ( right != n and visited [ arr [ right ] ] ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class TreeNode : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . val = rootData NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . trees = set ( ) NEW_LINE DEDENT def isSubtree ( self , s , t ) : NEW_LINE INDENT tree1 = self . preorder ( s , True ) NEW_LINE tree2 = self . preorder ( t , True ) NEW_LINE return tree1 . find ( tree2 ) >= 0 NEW_LINE DEDENT def preorder ( self , t , left ) : NEW_LINE INDENT if t is None : NEW_LINE INDENT if left : NEW_LINE INDENT return " lnull " NEW_LINE DEDENT else : NEW_LINE INDENT return " rnull " NEW_LINE DEDENT DEDENT return " # " + str ( t . val ) + " ▁ " + self . preorder ( t . left , True ) + " ▁ " + self . preorder ( t . right , False ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE root = TreeNode ( 3 ) NEW_LINE root . left = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 5 ) NEW_LINE root . left . left = TreeNode ( 1 ) NEW_LINE root . left . right = TreeNode ( 2 ) NEW_LINE subRoot = TreeNode ( 4 ) NEW_LINE subRoot . left = TreeNode ( 1 ) NEW_LINE subRoot . right = TreeNode ( 2 ) NEW_LINE out = sObj . isSubtree ( root , subRoot ) NEW_LINE print ( out ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT M = 1001 NEW_LINE MOD = 998244353 NEW_LINE dp = [ [ - 1 for i in range ( M ) ] for j in range ( M ) ] NEW_LINE @ staticmethod NEW_LINE def solve ( idx , diff , N , M , K ) : NEW_LINE INDENT if idx > N : NEW_LINE INDENT if diff == K : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if GFG . dp [ idx ] [ diff ] != - 1 : NEW_LINE INDENT return GFG . dp [ idx ] [ diff ] NEW_LINE DEDENT ans = GFG . solve ( idx + 1 , diff , N , M , K ) NEW_LINE ans += ( M - 1 ) * GFG . solve ( idx + 1 , diff + 1 , N , M , K ) NEW_LINE GFG . dp [ idx ] [ diff ] = ans % GFG . MOD NEW_LINE return GFG . dp [ idx ] [ diff ] NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE K = 0 NEW_LINE for i in range ( M + 1 ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT GFG . dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT print ( ( M * GFG . solve ( 2 , 0 , N , M , K ) ) ) NEW_LINE DEDENT DEDENT
class p222 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT self . sphereRadii = [ 0.0 ] * 21 NEW_LINE for i in range ( len ( self . sphereRadii ) ) : NEW_LINE INDENT self . sphereRadii [ i ] = ( i + 30 ) * 1000 NEW_LINE DEDENT self . minLength = [ [ 0.0 ] * ( 1 << len ( self . sphereRadii ) ) for _ in range ( len ( self . sphereRadii ) ) ] NEW_LINE min_val = float ( ' inf ' ) NEW_LINE for i in range ( len ( self . sphereRadii ) ) : NEW_LINE INDENT min_val = min ( self . findMinimumLength ( i , ( 1 << len ( self . sphereRadii ) ) - 1 ) + self . sphereRadii [ i ] , min_val ) NEW_LINE DEDENT return str ( round ( min_val ) ) NEW_LINE DEDENT def findMinimumLength ( self , currentSphereIndex , setOfSpheres ) : NEW_LINE INDENT if ( setOfSpheres & ( 1 << currentSphereIndex ) ) == 0 : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT if self . minLength [ currentSphereIndex ] [ setOfSpheres ] == 0 : NEW_LINE INDENT result = 0.0 NEW_LINE if bin ( setOfSpheres ) . count ( '1' ) == 1 : NEW_LINE INDENT result = self . sphereRadii [ currentSphereIndex ] NEW_LINE DEDENT else : NEW_LINE INDENT result = float ( ' inf ' ) NEW_LINE newSetOfSpheres = setOfSpheres ^ ( 1 << currentSphereIndex ) NEW_LINE for i in range ( len ( self . sphereRadii ) ) : NEW_LINE INDENT if ( newSetOfSpheres & ( 1 << i ) ) == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT temp = ( ( self . sphereRadii [ i ] + self . sphereRadii [ currentSphereIndex ] - 50000 ) * 200000 ) ** 0.5 NEW_LINE temp += self . findMinimumLength ( i , newSetOfSpheres ) NEW_LINE result = min ( temp , result ) NEW_LINE DEDENT DEDENT self . minLength [ currentSphereIndex ] [ setOfSpheres ] = result NEW_LINE DEDENT return self . minLength [ currentSphereIndex ] [ setOfSpheres ] NEW_LINE DEDENT DEDENT
import sys NEW_LINE def answer ( j ) : NEW_LINE INDENT if j : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT sides = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT sides [ i ] *= sides [ i ] NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT if sides [ i % 3 ] == sides [ ( i + 1 ) % 3 ] + sides [ ( i + 2 ) % 3 ] : NEW_LINE INDENT judge = True NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT judge = False NEW_LINE DEDENT DEDENT answer ( judge ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import java NEW_LINE def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT if N % 2 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , N , 2 ) : NEW_LINE INDENT res ^= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE DEDENT
import numpy as np NEW_LINE def getTotalXorOfSubarrayXors ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE N = len ( arr ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if freq % 2 == 1 : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = np . array ( [ 3 , 5 , 2 , 4 , 6 ] ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr ) ) NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT l , p , q = map ( float , input ( ) . split ( ) ) NEW_LINE print ( ( p * l ) / ( p + q ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE print ( abs ( arr [ n ] - arr [ n - 1 ] ) ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE cntp = [ 0 ] * 11 NEW_LINE cntn = [ 0 ] * 11 NEW_LINE cnt = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif a > 0 : NEW_LINE INDENT cntp [ a ] += 1 NEW_LINE DEDENT elif a < 0 : NEW_LINE INDENT cntn [ abs ( a ) ] += 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT res += cntp [ i ] * cntn [ i ] NEW_LINE DEDENT res += ( cnt * ( cnt - 1 ) ) // 2 NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class CF95A : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT super ( ) . __init__ ( sys . stdout , True ) NEW_LINE self . sc = sys . stdin NEW_LINE DEDENT def compare ( self , aa , i , bb , j , m ) : NEW_LINE INDENT while m > 0 : NEW_LINE INDENT a = aa [ i ] . upper ( ) NEW_LINE b = bb [ j ] . upper ( ) NEW_LINE if a != b : NEW_LINE INDENT return ord ( a ) - ord ( b ) NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE m -= 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = int ( self . sc . readline ( ) ) NEW_LINE ss = [ list ( self . sc . readline ( ) . strip ( ) ) for _ in range ( n ) ] NEW_LINE cc = list ( self . sc . readline ( ) . strip ( ) ) NEW_LINE m = len ( cc ) NEW_LINE c = self . sc . readline ( ) . strip ( ) NEW_LINE c_ = c . upper ( ) NEW_LINE a = ' b ' if c == ' a ' else ' a ' NEW_LINE a_ = a . upper ( ) NEW_LINE lucky = [ False ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT l = len ( ss [ i ] ) NEW_LINE if m - j >= l and self . compare ( cc , j , ss [ i ] , 0 , l ) == 0 : NEW_LINE INDENT for h in range ( l ) : NEW_LINE INDENT lucky [ j + h ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if lucky [ j ] : NEW_LINE INDENT if cc [ j ] . lower ( ) == c : NEW_LINE INDENT cc [ j ] = a_ if cc [ j ] . isupper ( ) else a NEW_LINE DEDENT else : NEW_LINE INDENT cc [ j ] = c_ if cc [ j ] . isupper ( ) else c NEW_LINE DEDENT DEDENT DEDENT print ( ' ' . join ( cc ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT o = CF95A ( ) NEW_LINE o . main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE a = int ( input ( ) ) NEW_LINE c = input ( ) NEW_LINE w = [ 0 ] * ( a + 1 ) NEW_LINE e = [ 0 ] * ( a + 1 ) NEW_LINE min_val = a NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT if c [ i - 1 ] == ' W ' : NEW_LINE INDENT w [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT e [ i ] += 1 NEW_LINE DEDENT w [ i ] += w [ i - 1 ] NEW_LINE e [ i ] += e [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT min_val = min ( min_val , w [ i - 1 ] + e [ a ] - e [ i ] ) NEW_LINE DEDENT print ( min_val ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE n = int ( input ( ) ) NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT num1 = int ( input ( ) ) NEW_LINE if num1 % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if even > odd : NEW_LINE INDENT print ( odd ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( even ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE class Main : NEW_LINE INDENT def doIt ( self ) : NEW_LINE INDENT MAX = 10000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE for i in range ( 3 , MAX + 1 , 2 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( MAX ) ) + 1 , 2 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT for j in range ( i * 3 , MAX + 1 , i * 2 ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT n = int ( input ( ) ) NEW_LINE while n != 0 : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT for i in range ( n , 12 , - 2 ) : NEW_LINE INDENT if prime [ i ] and prime [ i - 2 ] and prime [ i - 6 ] and prime [ i - 8 ] : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT obj = Main ( ) NEW_LINE obj . doIt ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT obj = Main ( ) NEW_LINE obj . doIt ( ) NEW_LINE DEDENT
import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = sys . stdin NEW_LINE self . st = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st is None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = self . br . readline ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT return self . br . readline ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT DEDENT scan = FastReader ( ) NEW_LINE def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE while t > 0 : NEW_LINE INDENT solve ( ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT t = scan . nextInt ( ) NEW_LINE arr = [ 0 ] * t NEW_LINE for i in range ( t ) : NEW_LINE INDENT arr [ i ] = scan . nextInt ( ) NEW_LINE DEDENT prevWinner = 0 NEW_LINE for i in range ( t ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT if prevWinner == 0 : NEW_LINE INDENT prevWinner = 2 NEW_LINE DEDENT DEDENT if prevWinner == 2 or prevWinner == 0 : NEW_LINE INDENT if ( arr [ i ] - 1 ) % 2 == 0 : NEW_LINE INDENT print ( 2 ) NEW_LINE prevWinner = 2 NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE prevWinner = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ i ] - 1 ) % 2 == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE prevWinner = 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE prevWinner = 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT main ( ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def powerOfTwo ( n ) : NEW_LINE INDENT return ( n & ( n - 1 ) ) == 0 NEW_LINE DEDENT @ staticmethod NEW_LINE def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return GFG . powerOfTwo ( n - 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = int ( "9" ) NEW_LINE if GFG . onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import numpy as np NEW_LINE def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( reverse = True ) NEW_LINE Y . sort ( reverse = True ) NEW_LINE hzntl = 1 NEW_LINE vert = 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if X [ i ] > Y [ j ] : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while i < m : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while j < n : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 6 NEW_LINE n = 4 NEW_LINE X = [ 2 , 1 , 3 , 1 , 4 ] NEW_LINE Y = [ 4 , 1 , 2 ] NEW_LINE print ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT count = 0 NEW_LINE p = G * L NEW_LINE for a in range ( 1 , L + 1 ) : NEW_LINE INDENT if ( p % a == 0 ) and gcd ( a , p // a ) == G : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT G = 2 NEW_LINE L = 12 NEW_LINE print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ " + str ( G ) , end = " " ) NEW_LINE print ( " ▁ & ▁ LCM ▁ " + str ( L ) , end = " " ) NEW_LINE print ( " ▁ = ▁ " + str ( countPairs ( G , L ) ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def multiply ( a , b ) : NEW_LINE INDENT mul = [ [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] = 0 NEW_LINE for k in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT a [ i ] [ j ] = mul [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def power ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE if n == 1 : NEW_LINE INDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] NEW_LINE DEDENT GFG . power ( F , n // 2 ) NEW_LINE GFG . multiply ( F , F ) NEW_LINE if n % 2 != 0 : NEW_LINE INDENT GFG . multiply ( F , M ) NEW_LINE DEDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] NEW_LINE DEDENT @ staticmethod NEW_LINE def findNthTerm ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE return GFG . power ( F , n - 2 ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT n = 5 NEW_LINE print ( " F ( 5 ) ▁ is " , GFG . findNthTerm ( n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def MinimumValue ( x , y ) : NEW_LINE INDENT if x > y : NEW_LINE INDENT temp = x NEW_LINE x = y NEW_LINE y = temp NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 123 NEW_LINE y = 13 NEW_LINE MinimumValue ( x , y ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def checkPossibility ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT brokenPoint = 0 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] > nums [ i + 1 ] : NEW_LINE INDENT brokenPoint += 1 NEW_LINE if brokenPoint >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] : NEW_LINE INDENT nums [ i ] = nums [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i + 1 ] = nums [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 4 , 2 , 3 ] NEW_LINE out = sObj . checkPossibility ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def check ( mid , array , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if array [ i ] > mid : NEW_LINE INDENT return False NEW_LINE DEDENT sum += array [ i ] NEW_LINE if sum > mid : NEW_LINE INDENT count += 1 NEW_LINE sum = array [ i ] NEW_LINE DEDENT DEDENT count += 1 NEW_LINE if count <= K : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def solve ( array , n , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT end += array [ i ] NEW_LINE DEDENT answer = 0 NEW_LINE while start <= end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if check ( mid , array , n , K ) : NEW_LINE INDENT answer = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT array = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( array ) NEW_LINE K = 3 NEW_LINE print ( solve ( array , n , K ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE M = 0 NEW_LINE memo = [ - 1 ] * ( 1 << 22 ) NEW_LINE def rec ( used , lst ) : NEW_LINE INDENT if len ( lst ) <= 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if memo [ used ] >= 0 : NEW_LINE INDENT return memo [ used ] NEW_LINE DEDENT ret = 99 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( used & ( 3 << ( 2 * i ) ) ) != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT on = [ ] NEW_LINE off = [ ] NEW_LINE for v in lst : NEW_LINE INDENT if ( v & ( 1 << i ) ) != 0 : NEW_LINE INDENT on . append ( v ) NEW_LINE DEDENT else : NEW_LINE INDENT off . append ( v ) NEW_LINE DEDENT DEDENT if not on or not off : NEW_LINE INDENT continue NEW_LINE DEDENT ret = min ( ret , max ( rec ( used | ( 1 << ( 2 * i ) ) , on ) , rec ( used | ( 2 << ( 2 * i ) ) , off ) ) ) NEW_LINE DEDENT memo [ used ] = ret + 1 NEW_LINE return ret + 1 NEW_LINE DEDENT while True : NEW_LINE INDENT M = int ( input ( ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE if M == 0 : NEW_LINE INDENT break NEW_LINE DEDENT lst = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT lst . append ( int ( input ( ) , 2 ) ) NEW_LINE DEDENT memo = [ - 1 ] * ( 1 << 22 ) NEW_LINE print ( rec ( 0 , lst ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def solve ( a , b ) : NEW_LINE INDENT return min ( compute_square_area ( a + a , b ) , compute_square_area ( a + b , max ( a , b ) ) , compute_square_area ( a , b + b ) ) NEW_LINE DEDENT def compute_square_area ( side1 , side2 ) : NEW_LINE INDENT size = max ( side1 , side2 ) NEW_LINE return size * size NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for tc in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( solve ( a , b ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def solve ( a , b , n ) : NEW_LINE INDENT ans = [ 0 ] * n NEW_LINE max_val = float ( ' - inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_val = max ( max_val , ( a [ i ] - b [ i ] ) ) NEW_LINE DEDENT if max_val < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] - max_val NEW_LINE if temp <= 0 : NEW_LINE INDENT ans [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = temp NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ans [ i ] != b [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if solve ( a , b , n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def even_or_odd ( N ) : NEW_LINE INDENT len = len ( N ) NEW_LINE if N [ len - 1 ] == '0' or N [ len - 1 ] == '2' or N [ len - 1 ] == '4' or N [ len - 1 ] == '6' : NEW_LINE INDENT return " Even " NEW_LINE DEDENT else : NEW_LINE INDENT return " Odd " NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = "735" NEW_LINE print ( even_or_odd ( N ) ) NEW_LINE DEDENT DEDENT
class Vector : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . A = [ 0 ] * 20 NEW_LINE self . length = 0 NEW_LINE DEDENT def add ( self , x ) : NEW_LINE INDENT if self . length == len ( self . A ) : NEW_LINE INDENT self . A += [ 0 ] * ( self . length * 2 ) NEW_LINE DEDENT self . A [ self . length ] = x NEW_LINE self . length += 1 NEW_LINE DEDENT def deleteBack ( self ) : NEW_LINE INDENT self . length -= 1 NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT result = " " NEW_LINE if self . length > 0 : NEW_LINE INDENT result += str ( self . A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , self . length ) : NEW_LINE INDENT result += " ▁ " + str ( self . A [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , q = map ( int , input ( ) . split ( ) ) NEW_LINE v = [ Vector ( ) for _ in range ( n ) ] NEW_LINE active = [ False ] * n NEW_LINE for _ in range ( q ) : NEW_LINE INDENT req , t = map ( int , input ( ) . split ( ) ) NEW_LINE if req == 0 : NEW_LINE INDENT if not active [ t ] : NEW_LINE INDENT v [ t ] = Vector ( ) NEW_LINE active [ t ] = True NEW_LINE DEDENT v [ t ] . add ( int ( input ( ) ) ) NEW_LINE DEDENT elif req == 1 : NEW_LINE INDENT if active [ t ] : NEW_LINE INDENT print ( v [ t ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ) NEW_LINE DEDENT DEDENT elif req == 2 : NEW_LINE INDENT active [ t ] = False NEW_LINE DEDENT DEDENT DEDENT
` ` ` python NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE k1 , k2 , w1 , w2 = 0 , 0 , 0 , 0 NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT w1 += 1 NEW_LINE k1 = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT w2 += 1 NEW_LINE k2 = i + 1 NEW_LINE DEDENT DEDENT print ( k1 if w1 == 1 else k2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) NEW_LINE sol = 0 NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + abs ( ord ( X [ i - 1 ] ) - ord ( Y [ i - 1 ] ) ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( count [ i ] - count [ j ] ) > K : NEW_LINE INDENT j += 1 NEW_LINE DEDENT sol = max ( sol , i - j ) NEW_LINE DEDENT return sol NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT N = 4 NEW_LINE X = " abcd " NEW_LINE Y = " bcde " NEW_LINE K = 3 NEW_LINE print ( GFG . solve ( X , Y , N , K ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
import math NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . INF = 1 << 28 NEW_LINE self . EPS = 1e-9 NEW_LINE self . n = 0 NEW_LINE self . m = 0 NEW_LINE self . a = [ ] NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT self . n = int ( input ( ) ) NEW_LINE self . m = int ( input ( ) ) NEW_LINE self . a = [ int ( input ( ) ) for _ in range ( self . m ) ] NEW_LINE self . solve ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT gcd = self . a [ 0 ] NEW_LINE for i in range ( 1 , self . m ) : NEW_LINE INDENT gcd = math . gcd ( gcd , self . a [ i ] ) NEW_LINE DEDENT print ( " Yes " if math . gcd ( gcd , self . n ) == 1 else " No " ) NEW_LINE DEDENT def gcd ( self , a , b ) : NEW_LINE INDENT return a if b == 0 else self . gcd ( b % a , a ) NEW_LINE DEDENT def println ( self , s ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT def print ( self , s ) : NEW_LINE INDENT print ( s , end = ' ' ) NEW_LINE DEDENT def debug ( self , * os ) : NEW_LINE INDENT print ( os , file = sys . stderr ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . run ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def isPrime ( n , i ) : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return True if n == 2 else False NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if i * i > n : NEW_LINE INDENT return True NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE if isPrime ( n , 2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minimumSum ( n ) : NEW_LINE INDENT if isPrime ( n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if isPrime ( n - 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT n = 27 NEW_LINE print ( minimumSum ( n ) ) NEW_LINE
import math NEW_LINE def isPrime ( x ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minimumCost ( n ) : NEW_LINE INDENT if isPrime ( n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % 2 == 1 and isPrime ( n - 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( minimumCost ( n ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def snoob ( x ) : NEW_LINE INDENT rightOne , nextHigherOneBit , rightOnesPattern , next = 0 , 0 , 0 , 0 NEW_LINE if x > 0 : NEW_LINE INDENT rightOne = x & - x NEW_LINE nextHigherOneBit = x + rightOne NEW_LINE rightOnesPattern = x ^ nextHigherOneBit NEW_LINE rightOnesPattern = ( rightOnesPattern ) // rightOne NEW_LINE rightOnesPattern >>= 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT x = 156 NEW_LINE print ( " Next ▁ higher ▁ number ▁ with ▁ same ▁ number ▁ of ▁ set ▁ bits ▁ is " , snoob ( x ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , int ( i ** 0.5 ) + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i / j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i / j NEW_LINE DEDENT DEDENT DEDENT sum = sum - i NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE result = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if count != 0 : NEW_LINE INDENT result = min ( result , count ) NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( GFG . getMinLength ( arr , n ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def getLevenstein ( input ) : NEW_LINE INDENT revInput = input [ : : - 1 ] NEW_LINE n = len ( input ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE dp [ i ] [ 0 ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if input [ i - 1 ] == revInput [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = float ( ' inf ' ) NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE res = min ( res , dp [ i ] [ j ] ) NEW_LINE if i < n : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT input = " myfirstgeekarticle " NEW_LINE print ( GFG . getLevenstein ( input ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE class p088 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . LIMIT = 12000 NEW_LINE self . minSumProduct = [ ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT self . minSumProduct = [ math . inf ] * ( self . LIMIT + 1 ) NEW_LINE for i in range ( 2 , self . LIMIT * 2 + 1 ) : NEW_LINE INDENT self . factorize ( i , i , i , 0 , 0 ) NEW_LINE DEDENT items = set ( self . minSumProduct [ 2 : ] ) NEW_LINE return str ( sum ( items ) ) NEW_LINE DEDENT def factorize ( self , n , remain , maxFactor , sum , terms ) : NEW_LINE INDENT if remain == 1 : NEW_LINE INDENT if sum > n : NEW_LINE INDENT raise AssertionError NEW_LINE DEDENT terms += n - sum NEW_LINE if terms <= self . LIMIT and n < self . minSumProduct [ terms ] : NEW_LINE INDENT self . minSumProduct [ terms ] = n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 2 , maxFactor + 1 ) : NEW_LINE INDENT if remain % i == 0 : NEW_LINE INDENT factor = i NEW_LINE self . factorize ( n , remain // factor , min ( factor , maxFactor ) , sum + factor , terms + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT p = p088 ( ) NEW_LINE p . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def modinv ( a , m ) : NEW_LINE INDENT b = m NEW_LINE u = 1 NEW_LINE v = 0 NEW_LINE while b > 0 : NEW_LINE INDENT t = a // b NEW_LINE a -= t * b NEW_LINE a , b = b , a NEW_LINE u -= t * v NEW_LINE u , v = v , u NEW_LINE DEDENT u %= m NEW_LINE if u < 0 : NEW_LINE INDENT u += m NEW_LINE DEDENT return u NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE sa = input ( ) . split ( " ▁ " ) NEW_LINE a = [ int ( x ) for x in sa ] NEW_LINE mod = 1000000007 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p = p * i % mod NEW_LINE DEDENT q = [ 0 ] * n NEW_LINE q [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT q [ i ] = ( q [ i - 1 ] + modinv ( i + 1 , mod ) ) % mod NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = q [ i ] + q [ n - i - 1 ] - 1 NEW_LINE val *= a [ i ] NEW_LINE val %= mod NEW_LINE val *= p NEW_LINE val %= mod NEW_LINE ans += val NEW_LINE ans %= mod NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from queue import Queue NEW_LINE def reverse_queue ( q ) : NEW_LINE INDENT stack = [ ] NEW_LINE while not q . empty ( ) : NEW_LINE INDENT stack . append ( q . get ( ) ) NEW_LINE DEDENT while stack : NEW_LINE INDENT q . put ( stack . pop ( ) ) NEW_LINE DEDENT return q NEW_LINE DEDENT def print_queue ( q ) : NEW_LINE INDENT while not q . empty ( ) : NEW_LINE INDENT print ( q . queue [ 0 ] , end = " ▁ " ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT queue = Queue ( ) NEW_LINE queue . put ( 56 ) NEW_LINE queue . put ( 27 ) NEW_LINE queue . put ( 30 ) NEW_LINE queue . put ( 45 ) NEW_LINE queue . put ( 85 ) NEW_LINE queue . put ( 92 ) NEW_LINE queue . put ( 58 ) NEW_LINE queue . put ( 80 ) NEW_LINE queue . put ( 90 ) NEW_LINE queue . put ( 100 ) NEW_LINE queue = reverse_queue ( queue ) NEW_LINE print_queue ( queue ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def findDiff ( arr , n ) : NEW_LINE INDENT min_val = MAX + 2 NEW_LINE max_val = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == True : NEW_LINE INDENT if arr [ i ] > max_val : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min_val : NEW_LINE INDENT min_val = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 if max_val == - 1 else ( max_val - min_val ) NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 4 NEW_LINE arr = [ 1 , 2 , 3 , 5 ] NEW_LINE res = findDiff ( arr , n ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( " No ▁ prime ▁ numbers " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Difference ▁ is " , res ) NEW_LINE DEDENT
import java . util . Scanner NEW_LINE import java . util . Arrays NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . inp = Scanner ( System . in ) NEW_LINE self . AOJ_GRL_2 ( ) NEW_LINE DEDENT class AOJ_GRL_2 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT self . V = self . inp . nextInt ( ) NEW_LINE self . cost = [ [ 0 for _ in range ( self . V ) ] for _ in range ( self . V ) ] NEW_LINE if self . V == 0 : NEW_LINE INDENT break NEW_LINE DEDENT n = self . inp . nextInt ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT input_arr = self . inp . next ( ) . split ( " , " ) NEW_LINE a = int ( input_arr [ 0 ] ) NEW_LINE b = int ( input_arr [ 1 ] ) NEW_LINE c = int ( input_arr [ 2 ] ) NEW_LINE self . cost [ a ] [ b ] = c NEW_LINE self . cost [ b ] [ a ] = c NEW_LINE DEDENT self . Prim ( 0 ) NEW_LINE print ( self . cnt ) NEW_LINE DEDENT DEDENT def Prim ( self , s ) : NEW_LINE INDENT self . d = [ float ( ' inf ' ) for _ in range ( self . V ) ] NEW_LINE self . used = [ False for _ in range ( self . V ) ] NEW_LINE self . INF = float ( ' inf ' ) NEW_LINE self . cnt = 0 NEW_LINE self . d [ s ] = 0 NEW_LINE while True : NEW_LINE INDENT v = - 1 NEW_LINE for u in range ( self . V ) : NEW_LINE INDENT if not self . used [ u ] and ( v == - 1 or self . d [ u ] < self . d [ v ] ) : NEW_LINE INDENT v = u NEW_LINE DEDENT DEDENT if v == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT self . used [ v ] = True NEW_LINE a = self . d [ v ] // 100 NEW_LINE if a > 0 : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT self . cnt += a NEW_LINE for k in range ( self . V ) : NEW_LINE INDENT if not self . used [ k ] and self . cost [ v ] [ k ] != 0 : NEW_LINE INDENT self . d [ k ] = min ( self . cost [ v ] [ k ] , self . d [ k ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) NEW_LINE DEDENT
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE s = " " NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s += str ( i ) NEW_LINE DEDENT print ( s [ n - 1 ] ) NEW_LINE
` ` ` python NEW_LINE def distinctSubString ( P , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = [ False ] * 26 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE if freq [ pos ] == True : NEW_LINE INDENT break NEW_LINE DEDENT freq [ pos ] = True NEW_LINE s += P [ j ] NEW_LINE S . add ( s ) NEW_LINE DEDENT DEDENT return len ( S ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = " abba " NEW_LINE N = len ( S ) NEW_LINE print ( distinctSubString ( S , N ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = 0 NEW_LINE if ( n - k ) % ( k - 1 ) == 0 : NEW_LINE INDENT x = ( n - k ) // ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = ( n - k ) // ( k - 1 ) + 1 NEW_LINE DEDENT print ( x + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
import itertools NEW_LINE def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = float ( ' inf ' ) NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT cnt = bin ( i ) . count ( '1' ) NEW_LINE if cnt == n - k : NEW_LINE INDENT temp = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i & ( 1 << j ) != 0 : NEW_LINE INDENT temp . append ( a [ j ] ) NEW_LINE DEDENT DEDENT maxDiff = float ( ' - inf ' ) NEW_LINE for j in range ( len ( temp ) - 1 ) : NEW_LINE INDENT maxDiff = max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) NEW_LINE DEDENT minDiff = min ( minDiff , maxDiff ) NEW_LINE DEDENT DEDENT return minDiff NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE a = [ 3 , 7 , 8 , 10 , 14 ] NEW_LINE print ( minimumAdjacentDifference ( a , n , k ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def difference ( arr , n ) : NEW_LINE INDENT largest = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if largest < arr [ i ] : NEW_LINE INDENT largest = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = largest - arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 10 , 5 , 9 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE GFG . difference ( arr , n ) NEW_LINE DEDENT DEDENT GFG . main ( [ ] ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class Count : NEW_LINE INDENT def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ A [ i ] % K ] += 1 NEW_LINE DEDENT sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) // 2 NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT if i != ( K - i ) : NEW_LINE INDENT sum += freq [ i ] * freq [ K - i ] NEW_LINE DEDENT DEDENT if K % 2 == 0 : NEW_LINE INDENT sum += ( freq [ K // 2 ] * ( freq [ K // 2 ] - 1 ) // 2 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = 6 NEW_LINE K = 4 NEW_LINE print ( Count . countKdivPairs ( A , n , K ) ) NEW_LINE DEDENT DEDENT Count . main ( None ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE while True : NEW_LINE INDENT S = [ input ( ) for _ in range ( 3 ) ] NEW_LINE if S [ 0 ] == "0" : NEW_LINE INDENT break NEW_LINE DEDENT f = True NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if S [ i ] [ 0 ] == S [ i ] [ 1 ] == S [ i ] [ 2 ] and S [ i ] [ 0 ] != ' + ' : NEW_LINE INDENT print ( S [ i ] [ 0 ] ) NEW_LINE f = False NEW_LINE break NEW_LINE DEDENT if S [ 0 ] [ i ] == S [ 1 ] [ i ] == S [ 2 ] [ i ] and S [ 0 ] [ i ] != ' + ' : NEW_LINE INDENT print ( S [ 0 ] [ i ] ) NEW_LINE f = False NEW_LINE break NEW_LINE DEDENT DEDENT if f and S [ 0 ] [ 0 ] == S [ 1 ] [ 1 ] == S [ 2 ] [ 2 ] and S [ 0 ] [ 0 ] != ' + ' : NEW_LINE INDENT print ( S [ 0 ] [ 0 ] ) NEW_LINE f = False NEW_LINE DEDENT if f and S [ 0 ] [ 2 ] == S [ 1 ] [ 1 ] == S [ 2 ] [ 0 ] and S [ 0 ] [ 2 ] != ' + ' : NEW_LINE INDENT print ( S [ 0 ] [ 2 ] ) NEW_LINE f = False NEW_LINE DEDENT if f : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class Binary : NEW_LINE INDENT @ staticmethod NEW_LINE def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if arr [ curr ] == 0 : NEW_LINE INDENT if curr - prev_prev_zero > max_count : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if n - prev_prev_zero > max_count : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Index ▁ of ▁ 0 ▁ to ▁ be ▁ replaced ▁ is " , self . maxOnesIndex ( arr , n ) ) NEW_LINE DEDENT DEDENT Binary ( ) . main ( ) NEW_LINE ` ` ` NEW_LINE
def minimumX ( n , k ) : NEW_LINE INDENT ans = float ( ' inf ' ) NEW_LINE for rem in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if n % rem == 0 : NEW_LINE INDENT ans = min ( ans , rem + ( n // rem ) * k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 4 , 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n , k = 5 , 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a %= mod NEW_LINE while b > 0 : NEW_LINE INDENT if b & 1 > 0 : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( 2 * a ) % mod NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a = 10123465234878998 NEW_LINE b = 65746311545646431 NEW_LINE m = 10005412336548794 NEW_LINE print ( self . moduloMultiplication ( a , b , m ) ) NEW_LINE DEDENT DEDENT GFG ( ) . main ( ) NEW_LINE
MAX = ord ( ' Z ' ) - ord ( ' A ' ) + 1 NEW_LINE n = 0 NEW_LINE inDeg = [ 0 ] * MAX NEW_LINE outDeg = [ 0 ] * MAX NEW_LINE vis = [ 0 ] * MAX NEW_LINE nei = [ [ 0 ] * MAX for _ in range ( MAX ) ] NEW_LINE def check ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if vis [ i ] != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( MAX ) : NEW_LINE INDENT if inDeg [ i ] != outDeg [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( k ) : NEW_LINE INDENT if vis [ k ] == 1 : NEW_LINE INDENT return NEW_LINE DEDENT vis [ k ] = 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if 0 < nei [ k ] [ i ] : NEW_LINE INDENT dfs ( i ) NEW_LINE DEDENT DEDENT DEDENT def run ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = 0 NEW_LINE inDeg = [ 0 ] * MAX NEW_LINE outDeg = [ 0 ] * MAX NEW_LINE vis = [ 0 ] * MAX NEW_LINE nei = [ [ 0 ] * MAX for _ in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = input ( ) NEW_LINE u = ord ( c [ 0 ] ) - ord ( ' a ' ) NEW_LINE v = ord ( c [ - 1 ] ) - ord ( ' a ' ) NEW_LINE outDeg [ u ] += 1 NEW_LINE inDeg [ v ] += 1 NEW_LINE nei [ u ] [ v ] = 1 NEW_LINE vis [ u ] = vis [ v ] = - 1 NEW_LINE s = u NEW_LINE DEDENT dfs ( s ) NEW_LINE if check ( ) : NEW_LINE INDENT print ( " OK " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NG " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT run ( ) NEW_LINE DEDENT
import sys NEW_LINE N = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE index = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if abs ( a [ index ] ) < abs ( a [ i ] ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT print ( 2 * N - 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( ( index + 1 ) , ( i + 1 ) ) NEW_LINE DEDENT if a [ index ] > 0 : NEW_LINE INDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT print ( ( i - 1 ) , i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( N - 1 , 0 , - 1 ) : NEW_LINE INDENT print ( ( i + 1 ) , i ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def checkPalindrome ( self , s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE length -= 1 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if s [ i ] != s [ length ] : NEW_LINE INDENT return False NEW_LINE DEDENT length -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def printSolution ( self , partitions ) : NEW_LINE INDENT for i in partitions : NEW_LINE INDENT for j in i : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def addStrings ( self , v , s , temp , index ) : NEW_LINE INDENT length = len ( s ) NEW_LINE current = list ( temp ) NEW_LINE if index == 0 : NEW_LINE INDENT temp . clear ( ) NEW_LINE DEDENT for i in range ( index , length ) : NEW_LINE INDENT substring = s [ index : i + 1 ] NEW_LINE if self . checkPalindrome ( substring ) : NEW_LINE INDENT temp . append ( substring ) NEW_LINE if i + 1 < length : NEW_LINE INDENT v = self . addStrings ( v , s , temp , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( list ( temp ) ) NEW_LINE DEDENT temp = list ( current ) NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT def partition ( self , s , v ) : NEW_LINE INDENT temp = [ ] NEW_LINE v = self . addStrings ( v , s , temp , 0 ) NEW_LINE self . printSolution ( v ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT s = " geeks " NEW_LINE partitions = [ ] NEW_LINE self . partition ( s , partitions ) NEW_LINE DEDENT DEDENT gfg = GFG ( ) NEW_LINE gfg . main ( ) NEW_LINE ` ` ` NEW_LINE
import math NEW_LINE M = 100000007 NEW_LINE def comb ( n , c ) : NEW_LINE INDENT b = 1 NEW_LINE for i in range ( c ) : NEW_LINE INDENT b = b * ( n - i ) // ( i + 1 ) NEW_LINE DEDENT return b % M NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT r , c , a1 , a2 , b1 , b2 = map ( int , input ( ) . split ( ) ) NEW_LINE x = abs ( a1 - b1 ) NEW_LINE y = abs ( a2 - b2 ) NEW_LINE x = min ( x , r - x ) NEW_LINE y = min ( y , c - y ) NEW_LINE z = 1 NEW_LINE if x == r - x : NEW_LINE INDENT z *= 2 NEW_LINE DEDENT if y == c - y : NEW_LINE INDENT z *= 2 NEW_LINE DEDENT print ( z * comb ( x + y , min ( x , y ) ) % M ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def findSubsequence ( arr , n , k ) : NEW_LINE INDENT M = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in M : NEW_LINE INDENT M [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT M [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT numCount = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT numCount [ i ] = 0 NEW_LINE DEDENT for key , value in M . items ( ) : NEW_LINE INDENT if key <= k : NEW_LINE INDENT i = 1 NEW_LINE while True : NEW_LINE INDENT if key * i > k : NEW_LINE INDENT break NEW_LINE DEDENT numCount [ key * i ] += value NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT lcm = 0 NEW_LINE length = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if numCount [ i ] > length : NEW_LINE INDENT length = numCount [ i ] NEW_LINE lcm = i NEW_LINE DEDENT DEDENT if lcm == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " LCM ▁ = ▁ " + str ( lcm ) + " , ▁ Length ▁ = ▁ " + str ( length ) ) NEW_LINE print ( " Indexes ▁ = ▁ " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lcm % arr [ i ] == 0 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = 14 NEW_LINE arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findSubsequence ( arr , n , k ) NEW_LINE DEDENT
` ` ` python NEW_LINE def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if b [ i ] % 2 == 1 : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , odd2 ) + min ( even1 , even2 ) NEW_LINE return pairs NEW_LINE DEDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 , even1 = 0 , 0 NEW_LINE odd2 , even2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if b [ i ] % 2 == 1 : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , even2 ) + min ( odd2 , even1 ) NEW_LINE return pairs NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE DEDENT DEDENT
class MaximumDiffrence : NEW_LINE INDENT def maxDiff ( self , arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE min_element = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if arr [ i ] - min_element > max_diff : NEW_LINE INDENT max_diff = arr [ i ] - min_element NEW_LINE DEDENT if arr [ i ] < min_element : NEW_LINE INDENT min_element = arr [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT maxdif = MaximumDiffrence ( ) NEW_LINE arr = [ 1 , 2 , 6 , 80 , 100 ] NEW_LINE size = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxdif . maxDiff ( arr , size ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 ] * ( k + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def findMax ( n ) : NEW_LINE INDENT return GFG . binomialCoeff ( n , n // 2 ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 5 NEW_LINE print ( GFG . findMax ( n ) ) NEW_LINE DEDENT DEDENT
MAX = 26 NEW_LINE def max_element ( freq ) : NEW_LINE INDENT max_ele = freq [ 0 ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if max_ele < freq [ i ] : NEW_LINE INDENT max_ele = freq [ i ] NEW_LINE DEDENT DEDENT return max_ele NEW_LINE DEDENT def minimumAddition ( str , len ) : NEW_LINE INDENT freq = [ 0 ] * MAX NEW_LINE for i in range ( len ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max_element ( freq ) NEW_LINE minAddition = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if freq [ i ] > 0 : NEW_LINE INDENT minAddition += abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT DEDENT return minAddition NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE len = len ( str ) NEW_LINE print ( minimumAddition ( str , len ) ) NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( input ( ) ) NEW_LINE b = list ( input ( ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if abs ( ord ( a [ i ] ) - ord ( b [ i ] ) ) > 5 : NEW_LINE INDENT sum += 10 - abs ( ord ( a [ i ] ) - ord ( b [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += abs ( ord ( a [ i ] ) - ord ( b [ i ] ) ) NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import math NEW_LINE MAX = 32 NEW_LINE pow2 = [ 0 ] * MAX NEW_LINE visited = [ False ] * MAX NEW_LINE ans = [ ] NEW_LINE def power_2 ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT pow2 [ i ] = ans NEW_LINE ans *= 2 NEW_LINE DEDENT DEDENT def countSetBits ( x ) : NEW_LINE INDENT setBits = 0 NEW_LINE while x != 0 : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE setBits += 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT def add ( num ) : NEW_LINE INDENT point = 0 NEW_LINE value = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if num % 2 == 1 : NEW_LINE INDENT value += ( 1 << i ) NEW_LINE DEDENT num //= 2 NEW_LINE DEDENT DEDENT ans . append ( value ) NEW_LINE DEDENT def solve ( n , k ) : NEW_LINE INDENT ans . append ( k ) NEW_LINE countk = countSetBits ( k ) NEW_LINE if pow ( 2 , countk ) < n : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( pow ( 2 , countk ) - 1 ) : NEW_LINE INDENT add ( i ) NEW_LINE count += 1 NEW_LINE if count == n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE k = 5 NEW_LINE power_2 ( ) NEW_LINE solve ( n , k ) NEW_LINE
class p027 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT bestNum = 0 NEW_LINE bestA = 0 NEW_LINE bestB = 0 NEW_LINE for a in range ( - 1000 , 1001 ) : NEW_LINE INDENT for b in range ( - 1000 , 1001 ) : NEW_LINE INDENT num = self . numberOfConsecutivePrimesGenerated ( a , b ) NEW_LINE if num > bestNum : NEW_LINE INDENT bestNum = num NEW_LINE bestA = a NEW_LINE bestB = b NEW_LINE DEDENT DEDENT DEDENT return str ( bestA * bestB ) NEW_LINE DEDENT def numberOfConsecutivePrimesGenerated ( self , a , b ) : NEW_LINE INDENT i = 0 NEW_LINE while True : NEW_LINE INDENT n = i * i + i * a + b NEW_LINE if n < 0 or not self . isPrime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def isPrime ( self , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT p = p027 ( ) NEW_LINE p . main ( [ ] ) NEW_LINE
import sys NEW_LINE class FastReader : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . br = sys . stdin NEW_LINE self . st = None NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . st is None or not self . st . hasMoreElements ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . st = self . br . readline ( ) . split ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT return self . st . nextToken ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return int ( self . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . next ( ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT return self . br . readline ( ) NEW_LINE DEDENT except IOError as e : NEW_LINE INDENT e . printStackTrace ( ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT obj = FastReader ( ) NEW_LINE tc = obj . nextInt ( ) NEW_LINE while tc != 0 : NEW_LINE INDENT n = obj . nextInt ( ) NEW_LINE k = obj . nextInt ( ) NEW_LINE if n > k : NEW_LINE INDENT print ( ( k * ( k + 1 ) ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT n -= 1 NEW_LINE n = ( n * ( n + 1 ) ) // 2 NEW_LINE n += 1 NEW_LINE print ( n ) NEW_LINE DEDENT tc -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE MAX = 100001 NEW_LINE isPrime = [ 0 ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT for p in range ( 2 , int ( math . sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if isPrime [ p ] == 0 : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT def findSubset ( a , n ) : NEW_LINE INDENT cnt1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT DEDENT if cnt1 > 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] != 1 and isPrime [ a [ i ] + 1 ] == 0 : NEW_LINE INDENT print ( cnt1 + 1 ) NEW_LINE for j in range ( cnt1 ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT print ( a [ i ] ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT DEDENT if cnt1 >= 2 : NEW_LINE INDENT print ( cnt1 ) NEW_LINE for i in range ( cnt1 ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if isPrime [ a [ i ] + a [ j ] ] == 0 : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( a [ i ] , a [ j ] ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE return - 1 NEW_LINE DEDENT sieve ( ) NEW_LINE A = [ 2 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE findSubset ( A , n ) NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( ) : NEW_LINE INDENT n , r , t , sum , pos = 0 , 0 , 0 , 0 , 0 NEW_LINE p = [ ] NEW_LINE water = [ ] NEW_LINE empty = [ ] NEW_LINE scan = input ( ) . split ( ) NEW_LINE n = int ( scan [ 0 ] ) NEW_LINE r = int ( scan [ 1 ] ) NEW_LINE t = int ( scan [ 2 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT p . append ( int ( input ( ) ) ) NEW_LINE DEDENT for i in range ( 1 , t + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT pos = ( p [ j ] * i % r ) NEW_LINE if i > 1 : NEW_LINE INDENT empty [ pos ] += 1 NEW_LINE DEDENT if water [ pos ] > 0 : NEW_LINE INDENT water [ pos ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT for j in range ( r ) : NEW_LINE INDENT if empty [ j ] > 0 : NEW_LINE INDENT water [ j ] += empty [ j ] NEW_LINE empty [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT DEDENT Main . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE input ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT c = list ( input ( ) ) NEW_LINE i = 0 NEW_LINE while i < len ( c ) - 6 : NEW_LINE INDENT if c [ i ] == ' H ' and c [ i + 1 ] == ' o ' and c [ i + 2 ] == ' s ' and c [ i + 3 ] == ' h ' and c [ i + 4 ] == ' i ' and c [ i + 5 ] == ' n ' and c [ i + 6 ] == ' o ' : NEW_LINE INDENT c [ i + 6 ] = ' a ' NEW_LINE i += 6 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( ' ' . join ( c ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = Main ( ) NEW_LINE m . main ( None ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class BinarySearch : NEW_LINE INDENT @ staticmethod NEW_LINE def count_rotations ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return 0 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return BinarySearch . count_rotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return BinarySearch . count_rotations ( arr , mid + 1 , high ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( BinarySearch . count_rotations ( arr , 0 , n - 1 ) ) NEW_LINE DEDENT DEDENT BinarySearch . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE i , req = 1 , 1 NEW_LINE while k - req >= 0 : NEW_LINE INDENT if k - req >= 0 : NEW_LINE INDENT k = k - req NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE if i % n != 0 : NEW_LINE INDENT req = i % n NEW_LINE DEDENT else : NEW_LINE INDENT req = n NEW_LINE DEDENT DEDENT print ( k ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
import numpy as np NEW_LINE def modularSum ( arr , n , m ) : NEW_LINE INDENT if n > m : NEW_LINE INDENT return True NEW_LINE DEDENT DP = np . full ( m , False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if DP [ 0 ] : NEW_LINE INDENT return True NEW_LINE DEDENT temp = np . full ( m , False ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT if DP [ j ] : NEW_LINE INDENT if not DP [ ( j + arr [ i ] ) % m ] : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if temp [ j ] : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE m = 5 NEW_LINE if modularSum ( arr , n , m ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT b , e , k = map ( int , input ( ) . split ( ) ) NEW_LINE res = 0 NEW_LINE for j in range ( b , e ) : NEW_LINE INDENT if a [ j ] == k : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE n , x = map ( int , input ( ) . split ( ) ) NEW_LINE arr = [ ] NEW_LINE totals = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT row = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . append ( row ) NEW_LINE totals [ 0 ] += row [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = min ( arr [ i - 1 ] [ j ] , arr [ i - 1 ] [ ( j - 1 + n ) % n ] ) NEW_LINE totals [ i ] += arr [ i ] [ j ] NEW_LINE DEDENT totals [ i ] += x * i NEW_LINE DEDENT totals . sort ( ) NEW_LINE print ( totals [ 0 ] ) NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE def solve ( A , y , x , dep , wid ) : NEW_LINE INDENT global max NEW_LINE if y + dep > d or x + wid > w : NEW_LINE INDENT return NEW_LINE DEDENT edgmin = 9 NEW_LINE lkmax = 0 NEW_LINE maxv = 0 NEW_LINE for i in range ( y , dep + y ) : NEW_LINE INDENT for j in range ( x , wid + x ) : NEW_LINE INDENT if i == y or i == dep + y - 1 or j == x or j == wid + x - 1 : NEW_LINE INDENT edgmin = min ( edgmin , A [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT lkmax = max ( lkmax , A [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if edgmin > lkmax : NEW_LINE INDENT for i in range ( y + 1 , dep + y - 1 ) : NEW_LINE INDENT for j in range ( x + 1 , x + wid - 1 ) : NEW_LINE INDENT maxv += edgmin - A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT max = max ( max , maxv ) NEW_LINE solve ( A , y , x , dep + 1 , wid ) NEW_LINE solve ( A , y , x , dep , wid + 1 ) NEW_LINE DEDENT max = 0 NEW_LINE d , w = map ( int , input ( ) . split ( ) ) NEW_LINE while True : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT break NEW_LINE DEDENT G = [ [ 0 for _ in range ( w ) ] for _ in range ( d ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT G [ i ] [ j ] = int ( input ( ) ) NEW_LINE DEDENT DEDENT for i in range ( d - 2 ) : NEW_LINE INDENT for j in range ( w - 2 ) : NEW_LINE INDENT solve ( G , i , j , 3 , 3 ) NEW_LINE DEDENT DEDENT print ( max ) NEW_LINE d , w = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( n ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT ans = [ 0 ] * n NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ans [ i ] == 0 : NEW_LINE INDENT ktimes = k * arr [ i ] NEW_LINE try : NEW_LINE INDENT index = arr . index ( ktimes ) NEW_LINE ans [ index ] = - 1 NEW_LINE DEDENT except ValueError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT ans1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ans [ i ] == 0 : NEW_LINE INDENT ans1 += 1 NEW_LINE DEDENT DEDENT print ( ans1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def sum ( k , n ) : NEW_LINE INDENT sum = int ( ( k ** ( n + 1 ) ) - ( ( k - 1 ) ** ( n + 1 ) ) ) NEW_LINE return sum NEW_LINE DEDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( sum ( K , n ) ) NEW_LINE
class GFG : NEW_LINE INDENT dp = [ [ [ 0 for i in range ( 162 ) ] for j in range ( 2 ) ] for k in range ( 18 ) ] NEW_LINE @ staticmethod NEW_LINE def solve ( i , tight , sum_so_far , Sum , number , length ) : NEW_LINE INDENT if i == length : NEW_LINE INDENT if sum_so_far == Sum : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = GFG . dp [ i ] [ 1 ] [ sum_so_far ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = 0 NEW_LINE for currdigit in range ( 10 ) : NEW_LINE INDENT if not tight and currdigit > int ( number [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT ntight = tight or currdigit < int ( number [ i ] ) NEW_LINE nsum_so_far = sum_so_far + currdigit NEW_LINE ans += GFG . solve ( i + 1 , ntight , nsum_so_far , Sum , number , length ) NEW_LINE DEDENT return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT count = 0 NEW_LINE Sum = 4 NEW_LINE number = "100" NEW_LINE for i in range ( 18 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT for k in range ( 162 ) : NEW_LINE INDENT GFG . dp [ i ] [ j ] [ k ] = - 1 NEW_LINE DEDENT DEDENT DEDENT print ( GFG . solve ( 0 , False , 0 , Sum , number , len ( number ) ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE class FriendsDecision : NEW_LINE INDENT count = 0 NEW_LINE def main ( self ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT entery = input ( ) NEW_LINE arr . append ( entery ) NEW_LINE self . decision ( entery ) NEW_LINE DEDENT print ( self . count ) NEW_LINE DEDENT def decision ( self , entery ) : NEW_LINE INDENT localct = 0 NEW_LINE inputs = entery . split ( " ▁ " ) NEW_LINE for i in range ( len ( inputs ) ) : NEW_LINE INDENT if inputs [ i ] == "1" : NEW_LINE INDENT localct += 1 NEW_LINE DEDENT DEDENT if localct > 1 : NEW_LINE INDENT self . count += 1 NEW_LINE DEDENT DEDENT DEDENT fd = FriendsDecision ( ) NEW_LINE fd . main ( ) NEW_LINE ` ` ` NEW_LINE
from collections import deque NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def evenOddLevelDifference ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = deque ( ) NEW_LINE q . append ( root ) NEW_LINE level = 0 NEW_LINE evenSum = 0 NEW_LINE oddSum = 0 NEW_LINE while len ( q ) != 0 : NEW_LINE INDENT size = len ( q ) NEW_LINE level += 1 NEW_LINE while size > 0 : NEW_LINE INDENT temp = q . popleft ( ) NEW_LINE if level % 2 == 0 : NEW_LINE INDENT evenSum += temp . data NEW_LINE DEDENT else : NEW_LINE INDENT oddSum += temp . data NEW_LINE DEDENT if temp . left is not None : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if temp . right is not None : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT size -= 1 NEW_LINE DEDENT DEDENT return ( oddSum - evenSum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT root = Node ( 5 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 6 ) NEW_LINE root . left . left = Node ( 1 ) NEW_LINE root . left . right = Node ( 4 ) NEW_LINE root . left . right . left = Node ( 3 ) NEW_LINE root . right . right = Node ( 8 ) NEW_LINE root . right . right . right = Node ( 9 ) NEW_LINE root . right . right . left = Node ( 7 ) NEW_LINE print ( " Difference ▁ between ▁ sums ▁ is " , evenOddLevelDifference ( root ) ) NEW_LINE DEDENT
import java NEW_LINE def countSubarrays ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE number = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number += ( count ) * ( count + 1 ) / 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if count != 0 : NEW_LINE INDENT number += ( count ) * ( count + 1 ) / 2 NEW_LINE DEDENT return number NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = [ 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 ] NEW_LINE n = len ( a ) NEW_LINE k = 5 NEW_LINE print ( countSubarrays ( a , n , k ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
from collections import defaultdict NEW_LINE def printLastOccurrence ( a , n ) : NEW_LINE INDENT map = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if map [ a [ i ] ] == i : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 5 , 5 , 1 , 6 , 1 ] NEW_LINE n = len ( a ) NEW_LINE printLastOccurrence ( a , n ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT up1 = 0 NEW_LINE up2 = 0 NEW_LINE k = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT k [ i ] = int ( input ( ) ) NEW_LINE if k [ i ] > 0 : NEW_LINE INDENT up1 += 1 NEW_LINE if k [ i ] >= 2 : NEW_LINE INDENT up2 += 1 NEW_LINE DEDENT DEDENT DEDENT if up2 == 0 : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( up1 + 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countPaths ( self , m , n ) : NEW_LINE INDENT if m == 1 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return self . countPaths ( m - 1 , n ) + self . countPaths ( m , n - 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = GFG ( ) NEW_LINE n , m = 5 , 5 NEW_LINE print ( g . countPaths ( n , m ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE
` ` ` python NEW_LINE class Solution : NEW_LINE INDENT @ staticmethod NEW_LINE def count_pairs ( arr ) : NEW_LINE INDENT count = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE print ( Solution . count_pairs ( arr ) ) NEW_LINE DEDENT DEDENT Solution . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT @ staticmethod NEW_LINE def coordinateCompression ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT index = 0 NEW_LINE mp = { } NEW_LINE for itr in s : NEW_LINE INDENT index += 1 NEW_LINE mp [ itr ] = index NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def query ( BIT , index , n ) : NEW_LINE INDENT ans = 0 NEW_LINE while index > 0 : NEW_LINE INDENT ans = max ( ans , BIT [ index ] ) NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def update ( BIT , index , n ) : NEW_LINE INDENT x = GFG . query ( BIT , index - 1 , n ) NEW_LINE value = x + 1 NEW_LINE while index <= n : NEW_LINE INDENT BIT [ index ] = max ( BIT [ index ] , value ) NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def findLISLength ( arr , n ) : NEW_LINE INDENT GFG . coordinateCompression ( arr , n ) NEW_LINE BIT = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT GFG . update ( BIT , arr [ i ] , n ) NEW_LINE DEDENT ans = GFG . query ( BIT , n , n ) NEW_LINE return ans NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 6 , 5 , 1 , 3 , 2 , 4 , 8 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE ans = GFG . findLISLength ( arr , n ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT Q = int ( input ( ) ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE schedule = [ ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT line = input ( ) . split ( ) NEW_LINE schedule . append ( [ int ( x ) for x in line ] ) NEW_LINE DEDENT check = False NEW_LINE for j in range ( 4 ) : NEW_LINE INDENT for k in range ( j + 1 , 5 ) : NEW_LINE INDENT day1count = 0 NEW_LINE day2count = 0 NEW_LINE bothcount = 0 NEW_LINE neither = 0 NEW_LINE for l in range ( len ( schedule ) ) : NEW_LINE INDENT if schedule [ l ] [ j ] == 0 and schedule [ l ] [ k ] == 0 : NEW_LINE INDENT neither += 1 NEW_LINE DEDENT if schedule [ l ] [ j ] == 1 and schedule [ l ] [ k ] == 0 : NEW_LINE INDENT day1count += 1 NEW_LINE DEDENT elif schedule [ l ] [ j ] == 0 and schedule [ l ] [ k ] == 1 : NEW_LINE INDENT day2count += 1 NEW_LINE DEDENT elif schedule [ l ] [ j ] == 1 and schedule [ l ] [ k ] == 1 : NEW_LINE INDENT bothcount += 1 NEW_LINE DEDENT DEDENT if neither > 0 : NEW_LINE INDENT continue NEW_LINE DEDENT elif day1count > len ( schedule ) / 2 or day2count > len ( schedule ) / 2 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT check = True NEW_LINE break NEW_LINE DEDENT DEDENT if check : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if check : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE class p164 : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CONSECUTIVE = 3 NEW_LINE MAX_SUM = 9 NEW_LINE ways = [ [ 0 ] * math . pow ( BASE , CONSECUTIVE ) for _ in range ( DIGITS + CONSECUTIVE + 1 ) ] NEW_LINE ways [ 0 ] [ 0 ] = 1 NEW_LINE for prefix in range ( 1 , len ( ways [ 0 ] ) ) : NEW_LINE INDENT ways [ 0 ] [ prefix ] = 0 NEW_LINE DEDENT for digits in range ( 1 , len ( ways ) ) : NEW_LINE INDENT for prefix in range ( len ( ways [ digits ] ) ) : NEW_LINE INDENT sum = 0 NEW_LINE if self . digitSum ( prefix ) <= MAX_SUM : NEW_LINE INDENT for nextDigit in range ( BASE ) : NEW_LINE INDENT sum += ways [ digits - 1 ] [ prefix % math . pow ( BASE , CONSECUTIVE - 1 ) * BASE + nextDigit ] NEW_LINE DEDENT DEDENT ways [ digits ] [ prefix ] = sum NEW_LINE DEDENT DEDENT return str ( ways [ DIGITS + CONSECUTIVE ] [ 0 ] - ways [ DIGITS + CONSECUTIVE - 1 ] [ 0 ] ) NEW_LINE DEDENT def digitSum ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT p = p164 ( ) NEW_LINE p . main ( ) NEW_LINE
` ` ` python NEW_LINE md = [ ] NEW_LINE def main ( ) : NEW_LINE INDENT l = [ None ] * 4 NEW_LINE l [ 0 ] = input ( ) NEW_LINE l [ 1 ] = input ( ) NEW_LINE l [ 2 ] = input ( ) NEW_LINE l [ 3 ] = input ( ) NEW_LINE f = False NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT a = l [ i ] [ j ] NEW_LINE if l [ i ] [ j + 1 ] == a : NEW_LINE INDENT if l [ i + 1 ] [ j ] == a or l [ i + 1 ] [ j + 1 ] == a : NEW_LINE INDENT f = True NEW_LINE break NEW_LINE DEDENT elif i > 0 and ( l [ i - 1 ] [ j ] == a or l [ i - 1 ] [ j + 1 ] == a ) : NEW_LINE INDENT f = True NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT f = False NEW_LINE DEDENT DEDENT if l [ 3 ] [ j ] == l [ 3 ] [ j + 1 ] and ( l [ 2 ] [ j ] == l [ 3 ] [ j ] or l [ 2 ] [ j + 1 ] == l [ 3 ] [ j + 1 ] ) : NEW_LINE INDENT f = True NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class Solution : NEW_LINE INDENT def isToeplitzMatrix ( self , matrix : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT for r in range ( 1 , len ( matrix ) ) : NEW_LINE INDENT for c in range ( 1 , len ( matrix [ 0 ] ) ) : NEW_LINE INDENT if matrix [ r - 1 ] [ c - 1 ] != matrix [ r ] [ c ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def main ( self , args : List [ str ] ) -> None : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE matrix = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 1 , 2 , 3 ] , [ 9 , 5 , 1 , 2 ] ] NEW_LINE out = sObj . isToeplitzMatrix ( matrix ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT
class p094 : NEW_LINE INDENT def main ( self , args ) : NEW_LINE INDENT print ( self . run ( ) ) NEW_LINE DEDENT LIMIT = pow ( 10 , 9 ) NEW_LINE def run ( self ) : NEW_LINE INDENT sum = 0 NEW_LINE s = 1 NEW_LINE while s * s <= ( self . LIMIT + 1 ) / 3 : NEW_LINE INDENT t = s - 2 NEW_LINE while t > 0 : NEW_LINE INDENT if self . gcd ( s , t ) == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * s - t * t ) / 2 NEW_LINE c = ( s * s + t * t ) / 2 NEW_LINE if a * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= self . LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT if a * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= self . LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT if b * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= self . LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT if b * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= self . LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT DEDENT t -= 2 NEW_LINE DEDENT s += 2 NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE class Main : NEW_LINE INDENT def solve ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT line = sys . stdin . readline ( ) . strip ( ) NEW_LINE if line == " " : NEW_LINE INDENT break NEW_LINE DEDENT N , T , L , B = map ( int , line . split ( ) ) NEW_LINE if N == 0 and T == 0 and L == 0 and B == 0 : NEW_LINE INDENT break NEW_LINE DEDENT square = [ 0 ] * ( N + 1 ) NEW_LINE for _ in range ( L ) : NEW_LINE INDENT square [ int ( sys . stdin . readline ( ) ) ] = 1 NEW_LINE DEDENT for _ in range ( B ) : NEW_LINE INDENT square [ int ( sys . stdin . readline ( ) ) ] = 2 NEW_LINE DEDENT dp = [ [ 0.0 ] * ( T + 1 ) for _ in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for j in range ( T ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for s in range ( 1 , 7 ) : NEW_LINE INDENT idx = 1 NEW_LINE num = i + s NEW_LINE if square [ i ] == 1 : NEW_LINE INDENT idx = 2 NEW_LINE DEDENT if i + s > N : NEW_LINE INDENT num = 2 * N - ( i + s ) NEW_LINE DEDENT if square [ num ] == 2 and j + idx <= T : NEW_LINE INDENT dp [ 0 ] [ j + idx ] += dp [ i ] [ j ] * 1.0 / 6 NEW_LINE DEDENT elif j + idx <= T : NEW_LINE INDENT dp [ num ] [ j + idx ] += dp [ i ] [ j ] * 1.0 / 6 NEW_LINE DEDENT DEDENT DEDENT DEDENT goal = sum ( dp [ N ] ) NEW_LINE print ( " { : . 6f } " . format ( goal ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main ( ) . solve ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = 0 NEW_LINE o = 0 NEW_LINE e = 0 NEW_LINE a = int ( input ( ) ) NEW_LINE for _ in range ( a ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE s += x NEW_LINE if x % 2 != 0 : NEW_LINE INDENT o += 1 NEW_LINE DEDENT else : NEW_LINE INDENT e += 1 NEW_LINE DEDENT DEDENT if s % 2 != 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT if o >= 1 and e >= 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) NEW_LINE if diff <= K : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff / K ) - 1 NEW_LINE DEDENT DEDENT return inser NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT H = [ 2 , 4 , 8 , 16 ] NEW_LINE K = 3 NEW_LINE n = len ( H ) NEW_LINE print ( minInsertions ( H , n , K ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def countWords ( str , len ) : NEW_LINE INDENT count = 1 NEW_LINE if len == 1 : NEW_LINE INDENT return count NEW_LINE DEDENT if str [ 0 ] == str [ 1 ] : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , len - 1 ) : NEW_LINE INDENT if str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if str [ len - 1 ] == str [ len - 2 ] : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abc " NEW_LINE len = len ( str ) NEW_LINE print ( countWords ( str , len ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE even = [ ] NEW_LINE odd = [ ] NEW_LINE for num in arr : NEW_LINE INDENT if num % 2 == 0 : NEW_LINE INDENT even . append ( num ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . append ( num ) NEW_LINE DEDENT DEDENT max_sum = sum ( even ) NEW_LINE odd . sort ( reverse = True ) NEW_LINE for i in range ( len ( odd ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT max_sum += odd [ i ] NEW_LINE DEDENT DEDENT print ( max_sum ) NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current , i = 1 , 1 NEW_LINE while current <= n : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE current = int ( i ** 2 ) NEW_LINE i += 1 NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if arr [ 0 ] > arr [ 1 ] : NEW_LINE INDENT max_val , second_max = arr [ 0 ] , arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT max_val , second_max = arr [ 1 ] , arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if arr [ i ] > max_val : NEW_LINE INDENT second_max = max_val NEW_LINE max_val = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second_max : NEW_LINE INDENT second_max = arr [ i ] NEW_LINE DEDENT DEDENT return max_val + second_max NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 NEW_LINE for square in perfectSquares : NEW_LINE INDENT temp = square - n NEW_LINE if temp > n and temp in nums : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def countPairs ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE max_val = GFG . maxPairSum ( arr ) NEW_LINE perfectSquares = GFG . getPerfectSquares ( max_val ) NEW_LINE nums = set ( arr ) NEW_LINE count = 0 NEW_LINE for num in arr : NEW_LINE INDENT count += GFG . countPairsWith ( num , perfectSquares , nums ) NEW_LINE DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 2 , 3 , 6 , 9 , 10 , 20 ] NEW_LINE print ( GFG . countPairs ( arr ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def findHypotenuse ( side1 , side2 ) : NEW_LINE INDENT h = math . sqrt ( ( side1 * side1 ) + ( side2 * side2 ) ) NEW_LINE return h NEW_LINE DEDENT side1 = 3 NEW_LINE side2 = 4 NEW_LINE print ( " % .2f " % findHypotenuse ( side1 , side2 ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE n = size - 2 NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) > 0 : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ ODD ▁ elements ▁ are " , x , " & " , y ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printTwoOdd ( arr , arr_size ) NEW_LINE DEDENT ` ` ` NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ar = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_val = 0 NEW_LINE min_val = 100000 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ar [ i ] < min_val : NEW_LINE INDENT min_val = ar [ i ] NEW_LINE x = i + 1 NEW_LINE DEDENT if ar [ i ] > max_val : NEW_LINE INDENT max_val = ar [ i ] NEW_LINE y = i + 1 NEW_LINE DEDENT DEDENT pos1 , pos2 = 1 , 1 NEW_LINE pos3 , pos4 = 1 , 1 NEW_LINE a , b , mm , total = 0 , 0 , 0 , 0 NEW_LINE pos1 = x NEW_LINE pos2 += n - x NEW_LINE if pos1 < pos2 : NEW_LINE INDENT a = pos1 NEW_LINE DEDENT else : NEW_LINE INDENT a = pos2 NEW_LINE DEDENT pos3 = y NEW_LINE pos4 += n - y NEW_LINE if pos3 < pos4 : NEW_LINE INDENT b = pos3 NEW_LINE DEDENT else : NEW_LINE INDENT b = pos4 NEW_LINE DEDENT div = abs ( y - x ) NEW_LINE if div < a or div < b : NEW_LINE INDENT mm = min ( a , b ) NEW_LINE total += mm + div NEW_LINE DEDENT else : NEW_LINE INDENT total += a + b NEW_LINE DEDENT print ( total ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
` ` ` python NEW_LINE import sys NEW_LINE class Main : NEW_LINE INDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT first = input ( ) NEW_LINE second = input ( ) NEW_LINE map = { " monday " : 1 , " tuesday " : 2 , " wednesday " : 3 , " thursday " : 4 , " friday " : 5 , " saturday " : 6 , " sunday " : 7 } NEW_LINE diff = 0 NEW_LINE if map [ second ] >= map [ first ] : NEW_LINE INDENT diff = map [ second ] - map [ first ] NEW_LINE DEDENT else : NEW_LINE INDENT diff = 7 - map [ first ] + map [ second ] NEW_LINE DEDENT ok = diff == 0 or diff == 2 or diff == 3 NEW_LINE print ( " YES " if ok else " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Main . main ( sys . argv ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE n = int ( input ( ) ) NEW_LINE f = False NEW_LINE s = False NEW_LINE ind = 0 NEW_LINE x = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x . append ( input ( ) ) NEW_LINE if not f : NEW_LINE INDENT if " OO " in x [ i ] : NEW_LINE INDENT f = True NEW_LINE ind = i NEW_LINE DEDENT DEDENT DEDENT if f : NEW_LINE INDENT print ( " YES " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i != ind : NEW_LINE INDENT print ( x [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if x [ i ] [ : 2 ] == " OO " : NEW_LINE INDENT print ( " + + " + x [ i ] [ 2 : ] ) NEW_LINE DEDENT elif x [ i ] [ 3 : ] == " OO " : NEW_LINE INDENT print ( x [ i ] [ : 3 ] + " + + " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def printList ( head ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE while True : NEW_LINE INDENT print ( temp . data , " - > " , end = " " ) NEW_LINE temp = temp . next NEW_LINE if temp == head : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( head . data ) NEW_LINE DEDENT @ staticmethod NEW_LINE def deleteK ( head_ref , k ) : NEW_LINE INDENT head = head_ref NEW_LINE if head is None : NEW_LINE INDENT return None NEW_LINE DEDENT curr = head NEW_LINE prev = None NEW_LINE while True : NEW_LINE INDENT if curr . next == head and curr == head : NEW_LINE INDENT break NEW_LINE DEDENT GFG . printList ( head ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE DEDENT if curr == head : NEW_LINE INDENT prev = head NEW_LINE while prev . next != head : NEW_LINE INDENT prev = prev . next NEW_LINE DEDENT head = curr . next NEW_LINE prev . next = head NEW_LINE head_ref = head NEW_LINE DEDENT elif curr . next == head : NEW_LINE INDENT prev . next = head NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = curr . next NEW_LINE DEDENT DEDENT return head NEW_LINE DEDENT @ staticmethod NEW_LINE def insertNode ( head_ref , x ) : NEW_LINE INDENT head = head_ref NEW_LINE temp = GFG . Node ( x ) NEW_LINE if head is None : NEW_LINE INDENT temp . next = temp NEW_LINE head_ref = temp NEW_LINE return head_ref NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = head NEW_LINE while temp1 . next != head : NEW_LINE INDENT temp1 = temp1 . next NEW_LINE DEDENT temp1 . next = temp NEW_LINE temp . next = head NEW_LINE DEDENT return head NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT head = None NEW_LINE head = GFG . insertNode ( head , 1 ) NEW_LINE head = GFG . insertNode ( head , 2 ) NEW_LINE head = GFG . insertNode ( head , 3 ) NEW_LINE head = GFG . insertNode ( head , 4 ) NEW_LINE head = GFG . insertNode ( head , 5 ) NEW_LINE head = GFG . insertNode ( head , 6 ) NEW_LINE head = GFG . insertNode ( head , 7 ) NEW_LINE head = GFG . insertNode ( head , 8 ) NEW_LINE head = GFG . insertNode ( head , 9 ) NEW_LINE k = 4 NEW_LINE head = GFG . deleteK ( head , k ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def steps ( cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT if x > 0 : NEW_LINE INDENT return abs ( ( n - cur ) // x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( ( cur - 1 ) // x ) NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] NEW_LINE stepct = min ( GFG . steps ( curx , x , n ) , GFG . steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE x = 1 NEW_LINE y = 1 NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] NEW_LINE print ( GFG . countSteps ( x , y , n , m , moves ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE md = [ ] NEW_LINE def main ( ) : NEW_LINE INDENT x1 = int ( input ( ) ) NEW_LINE x2 = int ( input ( ) ) NEW_LINE x3 = int ( input ( ) ) NEW_LINE point = min ( x1 , min ( x2 , x3 ) ) NEW_LINE if ( x1 > x2 and x1 < x3 ) or ( x1 > x3 and x1 < x2 ) : NEW_LINE INDENT point = x1 NEW_LINE DEDENT elif ( x1 > x2 and x2 > x3 ) or ( x2 < x3 and x2 > x1 ) : NEW_LINE INDENT point = x2 NEW_LINE DEDENT else : NEW_LINE INDENT point = x3 NEW_LINE DEDENT d = 0 NEW_LINE d = ( abs ( x1 - point ) + abs ( x2 - point ) + abs ( x3 - point ) ) NEW_LINE print ( d ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT ` ` ` NEW_LINE
class GFG : NEW_LINE INDENT def cntSubArr ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_gcd = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_gcd = __gcd ( curr_gcd , arr [ j ] ) NEW_LINE ans += 1 if curr_gcd == 1 else 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return __gcd ( b , a % b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cntSubArr ( arr , n ) ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def isVowel ( c ) : NEW_LINE INDENT if c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isVowelPrime ( str , n ) : NEW_LINE INDENT prime = [ True ] * n NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if isVowel ( str [ i ] ) and not prime [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE if isVowelPrime ( str , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT def minStepToDeleteString ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for length in range ( 1 , N + 1 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT j = i + length - 1 NEW_LINE if j < N : NEW_LINE INDENT if length == 1 : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if str [ i ] == str [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT for k in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if str [ i ] == str [ k ] : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ k - 1 ] + dp [ k + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT str = "2553432" NEW_LINE print ( minStepToDeleteString ( str ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE
limit = 10000000 NEW_LINE position = [ 0 ] * ( limit + 1 ) NEW_LINE def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if position [ i ] == 0 : NEW_LINE INDENT pos += 1 NEW_LINE position [ i ] = pos NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT sieve ( ) NEW_LINE n = 11 NEW_LINE print ( position [ n ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class GFG : NEW_LINE INDENT DP_s = 9 NEW_LINE @ staticmethod NEW_LINE def getNumMonotone ( len ) : NEW_LINE INDENT DP = [ [ 0 ] * GFG . DP_s for _ in range ( len ) ] NEW_LINE for i in range ( GFG . DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , len ) : NEW_LINE INDENT for j in range ( 1 , GFG . DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ len - 1 ] [ GFG . DP_s - 1 ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT print ( GFG . getNumMonotone ( 10 ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT DP_s = 9 NEW_LINE @ staticmethod NEW_LINE def getNumMonotone ( len ) : NEW_LINE INDENT DP = [ [ 0 ] * GFG . DP_s for _ in range ( len ) ] NEW_LINE for i in range ( GFG . DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , len ) : NEW_LINE INDENT for j in range ( 1 , GFG . DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ len - 1 ] [ GFG . DP_s - 1 ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT print ( GFG . getNumMonotone ( 10 ) ) NEW_LINE DEDENT DEDENT
class GFG : NEW_LINE INDENT def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE T = int ( input ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT R , C = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ list ( input ( ) ) for _ in range ( R ) ] NEW_LINE r = - 1 NEW_LINE c = - 1 NEW_LINE for rr in range ( R ) : NEW_LINE INDENT for cc in range ( C ) : NEW_LINE INDENT if A [ rr ] [ cc ] == ' R ' : NEW_LINE INDENT r = rr NEW_LINE c = cc NEW_LINE break NEW_LINE DEDENT DEDENT if r != - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ok = True NEW_LINE for rr in range ( r + 1 , R ) : NEW_LINE INDENT for cc in range ( c ) : NEW_LINE INDENT if A [ rr ] [ cc ] == ' R ' : NEW_LINE INDENT ok = False NEW_LINE DEDENT DEDENT DEDENT print ( " YES " if ok else " NO " ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE class Test : NEW_LINE INDENT PI = math . pi NEW_LINE @ staticmethod NEW_LINE def findArea ( r ) : NEW_LINE INDENT return Test . PI * math . pow ( r , 2 ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( args ) : NEW_LINE INDENT print ( " Area ▁ is " , Test . findArea ( 5 ) ) NEW_LINE DEDENT DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE from collections import deque NEW_LINE class DmwS : NEW_LINE INDENT below = [ ] NEW_LINE vis = [ ] NEW_LINE result = 0 NEW_LINE K = 0 NEW_LINE adj = [ ] NEW_LINE unis = [ ] NEW_LINE @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE DmwS . K = int ( input ( ) ) NEW_LINE DmwS . adj = [ deque ( ) for _ in range ( N ) ] NEW_LINE DmwS . unis = [ 0 ] * N NEW_LINE for _ in range ( 2 * DmwS . K ) : NEW_LINE INDENT town = int ( input ( ) ) - 1 NEW_LINE DmwS . unis [ town ] += 1 NEW_LINE DEDENT for _ in range ( N - 1 ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE x -= 1 NEW_LINE y -= 1 NEW_LINE DmwS . adj [ x ] . append ( y ) NEW_LINE DmwS . adj [ y ] . append ( x ) NEW_LINE DEDENT DmwS . below = [ 0 ] * N NEW_LINE DmwS . vis = [ False ] * N NEW_LINE DmwS . dfs ( 0 ) NEW_LINE print ( DmwS . result ) NEW_LINE DEDENT @ staticmethod NEW_LINE def dfs ( node ) : NEW_LINE INDENT DmwS . vis [ node ] = True NEW_LINE DmwS . below [ node ] = DmwS . unis [ node ] NEW_LINE for adj in DmwS . adj [ node ] : NEW_LINE INDENT if DmwS . vis [ adj ] : NEW_LINE INDENT continue NEW_LINE DEDENT DmwS . dfs ( adj ) NEW_LINE DmwS . below [ node ] += DmwS . below [ adj ] NEW_LINE DmwS . result += min ( DmwS . below [ adj ] , 2 * DmwS . K - DmwS . below [ adj ] ) NEW_LINE DEDENT DEDENT DEDENT ` ` ` NEW_LINE
import math NEW_LINE def nthTerm ( N ) : NEW_LINE INDENT return abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT X = 35 NEW_LINE print ( getHeight ( X ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT GFG . main ( None ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class KPaths : NEW_LINE INDENT V = 4 NEW_LINE def countwalks ( self , graph , u , v , k ) : NEW_LINE INDENT if k == 0 and u == v : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k == 1 and graph [ u ] [ v ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( self . V ) : NEW_LINE INDENT if graph [ u ] [ i ] == 1 : NEW_LINE INDENT count += self . countwalks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT graph = [ [ 0 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE u , v , k = 0 , 3 , 2 NEW_LINE p = KPaths ( ) NEW_LINE print ( p . countwalks ( graph , u , v , k ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE import math NEW_LINE def findDigits ( n , b ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE x = ( ( n * math . log10 ( n / M_E ) + math . log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( math . log10 ( b ) ) NEW_LINE return int ( x ) + 1 NEW_LINE DEDENT print ( findDigits ( 4 , 16 ) ) NEW_LINE print ( findDigits ( 5 , 8 ) ) NEW_LINE print ( findDigits ( 12 , 16 ) ) NEW_LINE print ( findDigits ( 19 , 13 ) ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class Main : NEW_LINE INDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT n , q = map ( int , input ( ) . split ( ) ) NEW_LINE Main . init ( n ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT query = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if query [ 0 ] == 0 : NEW_LINE INDENT Main . add ( query [ 1 ] , query [ 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Main . sum ( query [ 1 ] , query [ 2 ] ) ) NEW_LINE DEDENT DEDENT DEDENT @ staticmethod NEW_LINE def init ( n ) : NEW_LINE INDENT Main . size = 1 NEW_LINE while Main . size < n : NEW_LINE INDENT Main . size *= 2 NEW_LINE DEDENT Main . nodes = [ 0 ] * ( Main . size + 1 ) NEW_LINE DEDENT @ staticmethod NEW_LINE def add ( target , value ) : NEW_LINE INDENT while target < len ( Main . nodes ) : NEW_LINE INDENT Main . nodes [ target ] += value NEW_LINE target += target & ( - target ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def sum ( s , t ) : NEW_LINE INDENT return Main . sum ( t ) - Main . sum ( s - 1 ) NEW_LINE DEDENT @ staticmethod NEW_LINE def sum ( t ) : NEW_LINE INDENT res = 0 NEW_LINE while t > 0 : NEW_LINE INDENT res += Main . nodes [ t ] NEW_LINE t -= t & ( - t ) NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT Main . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE import sys NEW_LINE check = { } NEW_LINE def solve ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n / 2 in check : NEW_LINE INDENT a = check [ n / 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT a = solve ( n / 2 ) % 1000000007 NEW_LINE check [ n / 2 ] = a NEW_LINE DEDENT if n / 2 - 1 in check : NEW_LINE INDENT b = check [ n / 2 - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT b = solve ( n / 2 - 1 ) % 1000000007 NEW_LINE check [ n / 2 - 1 ] = b NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT return ( 2 * a + b ) % 1000000007 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * b + a ) % 1000000007 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = int ( sys . stdin . readline ( ) ) NEW_LINE print ( solve ( N ) ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE def Judge ( p , q , separate , now_pro , prev_deno ) : NEW_LINE INDENT count = 0 NEW_LINE if p == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if separate <= 0 : NEW_LINE INDENT return count NEW_LINE DEDENT deno = maxproduct // now_pro + 1 NEW_LINE while separate * q < p * deno : NEW_LINE INDENT deno -= 1 NEW_LINE DEDENT while p * deno >= q and prev_deno <= deno : NEW_LINE INDENT subtraction_deno = q * deno NEW_LINE subtraction_nume = p * deno - q NEW_LINE if now_pro * deno <= maxproduct : NEW_LINE INDENT count += Judge ( subtraction_nume , subtraction_deno , separate - 1 , now_pro * deno , deno ) NEW_LINE DEDENT deno -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT numerator = 0 NEW_LINE denominator = 0 NEW_LINE maxproduct = 0 NEW_LINE parts = 0 NEW_LINE while True : NEW_LINE INDENT numerator = int ( input ( ) ) NEW_LINE denominator = int ( input ( ) ) NEW_LINE maxproduct = int ( input ( ) ) NEW_LINE parts = int ( input ( ) ) NEW_LINE if parts == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE count += Judge ( numerator , denominator , parts , 1 , 0 ) NEW_LINE print ( count ) NEW_LINE DEDENT ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT s = " " NEW_LINE @ staticmethod NEW_LINE def reverse_string ( s ) : NEW_LINE INDENT arr = list ( s ) NEW_LINE for i in range ( len ( arr ) // 2 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ len ( arr ) - i - 1 ] NEW_LINE arr [ len ( arr ) - i - 1 ] = temp NEW_LINE DEDENT return ' ' . join ( arr ) NEW_LINE DEDENT @ staticmethod NEW_LINE def binary_conversion ( m ) : NEW_LINE INDENT global s NEW_LINE while m != 0 : NEW_LINE INDENT tmp = m % 2 NEW_LINE s += str ( tmp ) NEW_LINE m = int ( m / 2 ) NEW_LINE DEDENT s = GFG . reverse_string ( s ) NEW_LINE DEDENT @ staticmethod NEW_LINE def find_character ( n , m , i ) : NEW_LINE INDENT GFG . binary_conversion ( m ) NEW_LINE s1 = " " NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( len ( s ) ) : NEW_LINE INDENT if s [ y ] == '1' : NEW_LINE INDENT s1 += "10" NEW_LINE DEDENT else : NEW_LINE INDENT s1 += "01" NEW_LINE DEDENT DEDENT s = s1 NEW_LINE s1 = " " NEW_LINE DEDENT return int ( s [ i ] ) NEW_LINE DEDENT @ staticmethod NEW_LINE def main ( ) : NEW_LINE INDENT m , n , i = 5 , 2 , 8 NEW_LINE print ( GFG . find_character ( n , m , i ) ) NEW_LINE DEDENT DEDENT GFG . main ( ) NEW_LINE ` ` ` NEW_LINE
` ` ` python NEW_LINE class GFG : NEW_LINE INDENT def countSubsets ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE even_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT even_count = len ( us ) NEW_LINE return int ( 2 ** even_count - 1 ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 4 , 2 , 1 , 9 , 2 , 6 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Number ▁ of ▁ subsets ▁ = ▁ " + str ( GFG . countSubsets ( arr , n ) ) ) NEW_LINE DEDENT DEDENT GFG . main ( None ) NEW_LINE ` ` ` NEW_LINE
f = [ 0 ] * 1000 NEW_LINE def fib ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 or n == 2 : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return f [ n ] NEW_LINE DEDENT if f [ n ] != 0 : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = 0 NEW_LINE if n & 1 != 0 : NEW_LINE INDENT k = ( n + 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT if n & 1 != 0 : NEW_LINE INDENT f [ n ] = fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findLCMFibonacci ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) // fib ( gcd ( a , b ) ) NEW_LINE DEDENT a = 3 NEW_LINE b = 12 NEW_LINE print ( findLCMFibonacci ( a , b ) ) NEW_LINE
class GFG : NEW_LINE INDENT def findNumbers ( n , w ) : NEW_LINE INDENT x = 0 NEW_LINE sum = 0 NEW_LINE if w >= 0 and w <= 8 : NEW_LINE INDENT x = 9 - w NEW_LINE DEDENT elif w >= - 9 and w <= - 1 : NEW_LINE INDENT x = 10 + w NEW_LINE DEDENT sum = int ( 10 ** ( n - 2 ) ) NEW_LINE sum = x * sum NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE w = 4 NEW_LINE print ( findNumbers ( n , w ) ) NEW_LINE DEDENT DEDENT
` ` ` python NEW_LINE def findKthChar ( s , k ) : NEW_LINE INDENT i = 0 NEW_LINE total_len = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if s [ i ] . isalpha ( ) : NEW_LINE INDENT total_len += 1 NEW_LINE if total_len == k : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while i < len ( s ) and not s [ i ] . isalpha ( ) : NEW_LINE INDENT n = n * 10 + int ( s [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if k <= next_total_len : NEW_LINE INDENT pos = k % total_len NEW_LINE if pos == 0 : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT DEDENT return ' ▁ ' NEW_LINE DEDENT s = " ab2c3" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE ` ` ` NEW_LINE
import java . io . * ; NEW_LINE class GFG : NEW_LINE INDENT def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE return n * ( n + 1 ) / 2 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT s = " abcde " NEW_LINE print ( countNonEmptySubstr ( s ) ) NEW_LINE DEDENT DEDENT
