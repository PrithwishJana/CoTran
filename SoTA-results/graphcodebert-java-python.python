import sys NEW_LINE from itertools import product NEW_LINE def is_prime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT prime_list = [ ] NEW_LINE prime_list = [ ] NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list = [ ] NEW_LINE prime_list . append ( prime_list ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( False ) NEW_LINE prime_list . append ( prime_list ) NEW_LINE prime_list . append ( prime_list ) NEW_LINE prime_list . append ( prime_list ) NEW_LINE prime_list . append ( prime_list ) NEW_LINE prime_list . append ( prime_list ) NEW_LINE prime_list . append ( prime_list ) NEW_LINE prime_list . append ( prime_list ) NEW_LINE for prime_list in prime_list : NEW_LINE INDENT prime_list . append ( prime_list [ prime_list ] ) NEW_LINE DEDENT prime_list . append ( prime_list ) NEW_LINE for prime_list in prime_list : NEW_LINE INDENT prime_list . append ( prime_list [ prime_list
MAX_CHAR = 26 NEW_LINE def countFreq ( freq , freq , length ) : NEW_LINE INDENT count_odd = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT freq [ ord ( freq [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if ( len_odd ) % 2 != 0 ) : NEW_LINE INDENT if ( count_odd > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( count_odd != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def canPalindrome ( freq , freq , length ) : NEW_LINE INDENT odd_odd = 0 NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT freq += 1 NEW_LINE odd_odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_odd += 1 NEW_LINE odd_odd = odd_odd NEW_LINE return odd_odd NEW_LINE DEDENT DEDENT def findOddWithRemq ( freq , freq ) : NEW_LINE INDENT odd_odd = even_odd NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT even_odd += ( ord ( freq [ i ] ) ) NEW_LINE odd_odd = odd_odd NEW_LINE DEDENT DEDENT return odd_odd NEW_LINE DEDENT def findPalindrome ( freq , freq ) : NEW_LINE INDENT odd_odd = even_odd NEW_LINE if ( not ( not even_odd ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return odd_odd NEW_LINE DEDENT def findPalindrome ( freq , freq ) : NEW_LINE INDENT odd_odd = even_odd NEW_LINE if ( not ( not ( not even ) ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . real NEW_LINE DEDENT def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . real NEW_LINE DEDENT def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . imag * b . real NEW_LINE DEDENT def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . imag NEW_LINE DEDENT def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . real NEW_LINE DEDENT def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . imag - a . imag * b . imag NEW_LINE DEDENT def test ( ) : NEW_LINE INDENT if cross ( a , b ) < cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . imag - a . imag * b . imag NEW_LINE DEDENT else : NEW_LINE INDENT return a . real * b . imag - a . imag * b . imag NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE cross ( a , b , c , d ) NEW_LINE print ( cross ( a , b , c , d ) ) NEW_LINE DEDENT DEDENT
def counts ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 ] * ( 10 ** 9 ) NEW_LINE mod_sum = 0 NEW_LINE mod_sum = 0 NEW_LINE mod_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( number [ i ] - ord ( '0' ) ) : NEW_LINE INDENT continuous_sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_sum += d [ i ] NEW_LINE mod_sum += d [ mod_sum ] NEW_LINE mod_sum += d [ mod_sum ] NEW_LINE mod_sum -= d [ mod_sum ] NEW_LINE mod_sum -= d [ mod_sum ] NEW_LINE mod_sum -= mod_sum NEW_LINE mod_sum -= mod_sum NEW_LINE mod_sum -= mod_sum NEW_LINE DEDENT return mod_sum NEW_LINE DEDENT print ( counts ( "12192" ) ) NEW_LINE print ( counts ( "12" , "12" ) ) NEW_LINE
def fastPow ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = fastPow ( N , K // 2 ) NEW_LINE if ( K % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return N * temp * temp NEW_LINE DEDENT DEDENT N = 3 NEW_LINE K = 3 NEW_LINE print ( countWays ( N , K ) ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE c = [ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE c [ 0 ] = 1 NEW_LINE for i in range ( n ) : c [ i ] = c [ i ] [ i ] NEW_LINE for k in range ( 7 ) : c [ i ] = c [ i ] [ k ] NEW_LINE for i in range ( 7 ) : c [ i ] [ k ] = c [ i ] [ k ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 7 ) : NEW_LINE INDENT if c [ i ] [ j ] == 1 : c [ i ] [ j ] = c [ i ] [ j ] NEW_LINE else : c [ i ] [ j ] = c [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( * c [ 0 ] , sep = ' ' ) NEW_LINE DEDENT
MAX = 10000 ; NEW_LINE arr = [ True ] * ( MAX ) ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ True ] = True ; NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr [ p ] = False ; NEW_LINE DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT SieveOfEratosthenes ( ) ; NEW_LINE n = 31 ; NEW_LINE if ( isEqual ( n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
MAX = 1000000 ; NEW_LINE prime = [ True ] * ( MAX ) ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = True ; NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT product = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] ; NEW_LINE if ( product + 1 == n or product - 1 == n or product - 1 == n or product - 1 == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT SieveOfEratosthenes ( n ) ; NEW_LINE if ( isPrimorialPrime ( n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def mul_table ( N , i ) : NEW_LINE INDENT if ( i > 10 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( N , " * ▁ = ▁ * " , i + 1 ) NEW_LINE mul_table ( N , i + 1 ) NEW_LINE mul_table ( N , i + 1 ) NEW_LINE mul_table ( N , i + 1 ) NEW_LINE DEDENT N = 8 NEW_LINE mul_table ( N , 1 ) NEW_LINE mul_table ( N , i + 1 ) NEW_LINE
def closestNumber ( n , m ) : NEW_LINE INDENT q = n // m NEW_LINE n1 = m * q NEW_LINE n2 = m * q NEW_LINE n2 = m * ( q - 1 ) NEW_LINE if abs ( n - n2 ) < abs ( n - n2 ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT def closestNumber ( n , m ) : NEW_LINE INDENT q = n // m NEW_LINE if abs ( n - n1 ) < abs ( n - n2 ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return closestNumber ( n , m ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 13 NEW_LINE m = 4 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 8 NEW_LINE m = 6 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 8 NEW_LINE m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 8 NEW_LINE m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = 8 NEW_LINE n = 8 NEW_LINE m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = 8 NEW_LINE n = 18 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE n = 18 NEW_LINE m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE n = 18 NEW_LINE print ( closestNumber ( n , m ) NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE print ( n = 18 NEW_LINE m = 18 NEW_LINE n = 18 NEW_LINE m = 18 NEW_LINE print (
def solve ( arg , n ) : NEW_LINE INDENT if ( ( ( arg * n - 2 ) ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( arg * n ) / 180 NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT def solve ( arg , n ) : NEW_LINE INDENT ans = 1 NEW_LINE freq = ( arg * n ) // 180 NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ar = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ar , n ) ) NEW_LINE DEDENT
def compute_lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == s [ i ] : NEW_LINE INDENT lps [ i ] = lps [ i - 1 ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if len ( lps [ i ] ) : NEW_LINE INDENT lps [ i ] = lps [ i - 1 ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT def LongestSubstring ( s ) : NEW_LINE INDENT lps = compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if ( lps [ n - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( lps [ i ] == lps [ n - 1 ] ) : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE return NEW_LINE DEDENT DEDENT if ( lps [ n - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " fixprefixprefixix " NEW_LINE LongestSubstring ( s ) NEW_LINE DEDENT
import sys NEW_LINE def checkIfSmallRotated ( arr , n ) : NEW_LINE INDENT minEle = sys . maxsize ; NEW_LINE minEle = - 1 ; NEW_LINE minEle = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < minEle ) : NEW_LINE INDENT minEle = arr [ i ] ; NEW_LINE break ; NEW_LINE DEDENT flag = 1 ; NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT flag2 = 1 ; NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag2 = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag2 and ( arr [ n - 1 ] < arr [ minIndex - 1 ] ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 4 , 5 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE checkIfSmallRotated ( arr , n ) ; NEW_LINE DEDENT
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i + 1 ] - a [ i ] > 0 : NEW_LINE INDENT ans += 1 NEW_LINE a [ i + 1 ] = a [ i ] - a [ i ] + d NEW_LINE DEDENT else : NEW_LINE INDENT a [ i + 1 ] = a [ i ] - a [ i ] + d NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def checkPowerIsible ( num ) : NEW_LINE INDENT count = 0 NEW_LINE factor = [ 0 ] * ( num + 1 ) NEW_LINE factor [ 2 ] = count NEW_LINE if ( num % 2 == 0 ) : NEW_LINE INDENT while ( num % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE num //= 2 NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT factor [ i ] = count NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT factor [ num ] = count NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT factor [ num ] = count NEW_LINE DEDENT product = 1 NEW_LINE for i in range ( num ) : NEW_LINE INDENT if ( factor [ i ] > 0 ) : NEW_LINE INDENT product [ i ] = count * factor [ i ] * i NEW_LINE DEDENT DEDENT if ( product == float ) : NEW_LINE INDENT print ( " Power - a ▁ Power ▁ Power - " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Infinite ▁ P - > ▁ P - " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 12 NEW_LINE checkIsIsIsible ( 25 ) NEW_LINE DEDENT
s = input ( ) NEW_LINE x = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif s [ i ] == ' Z ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT if x == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Z ' ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = max ( a ) NEW_LINE m = max ( a ) NEW_LINE print ( m ) NEW_LINE DEDENT
def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num2 ) NEW_LINE if ( len1 == 0 or len2 == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 ] * len ( num2 ) NEW_LINE i = 0 NEW_LINE i = 0 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = num1 [ i ] NEW_LINE i = i NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT n2 = num2 [ i ] NEW_LINE sum = n2 [ i ] NEW_LINE sum = n1 [ i ] NEW_LINE sum = sum // 10 NEW_LINE i -= 1 NEW_LINE carry = sum // 10 NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT result [ i ] += carry NEW_LINE i -= 1 NEW_LINE carry = sum // 10 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT result [ i ] += carry % 10 NEW_LINE i -= 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while ( i >= 0 and result [ i ] == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 or result [ i ] == 0 ) : NEW_LINE INDENT result [ i ] += carry NEW_LINE i -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return " " NEW_LINE DEDENT return " " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = "12454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE if s >= sum ( l ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE l = n - 1 NEW_LINE r = s [ : k ] NEW_LINE l = r + 1 NEW_LINE r = s [ : : - 1 ] NEW_LINE if l > r : NEW_LINE INDENT print ( " L " , * r ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " L " , * r ) NEW_LINE DEDENT
def printDistSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for j in range ( 0 , sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , 3 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printDistSum ( arr , n ) NEW_LINE
def Subtrib ( a , b ) : NEW_LINE INDENT c = a + ( ~ b + 1 ) NEW_LINE return c NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE print ( Subtrib ( a , b ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a = ( n + 8 * 8 ) // 2 NEW_LINE b = ( n - 8 * 8 ) // 2 NEW_LINE if a < b : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT b . add ( a [ i ] ) NEW_LINE DEDENT DEDENT if len ( b ) == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def nextZero ( i , occurrences ) : NEW_LINE INDENT while ( i < len ( occurrences ) ) : NEW_LINE INDENT if ( occurrences [ i ] == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def getMod ( string , n ) : NEW_LINE INDENT n = len ( string ) NEW_LINE if ( n > 26 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = nextZero ( 0 ) NEW_LINE frequency = nextZero ( 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT frequency [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE frequency [ ord ( ch [ i ] ) ] = 1 NEW_LINE frequency [ ord ( ch [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE index = nextZero ( index + 1 , frequency ) NEW_LINE frequency [ index ] = 1 NEW_LINE DEDENT DEDENT return " " . join ( frequency ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE print ( getMod ( string ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT h , m = map ( int , input ( ) . split ( ) ) NEW_LINE h , m = map ( int , input ( ) . split ( ) ) NEW_LINE m = h * 10 + m NEW_LINE if h >= m : NEW_LINE INDENT print ( "0:0" ) NEW_LINE DEDENT else : NEW_LINE INDENT m = h // 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE m = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE h = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE h = h % 10 NEW_LINE m = h % 10 NEW_LINE h =
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mx = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] not in mx : NEW_LINE INDENT mx += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mx = max ( mx , mx // i ) NEW_LINE DEDENT DEDENT print ( mx ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def prime ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime ( i ) : NEW_LINE INDENT prime ( i ) NEW_LINE DEDENT DEDENT return prime ( n ) NEW_LINE DEDENT def prime ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return prime ( n ) NEW_LINE DEDENT DEDENT def prime ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return prime ( n ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE print ( prime ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT b [ i ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b [ i ] = i NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT print ( b [ i ] , end = " " ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dp = [ 1 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 1 ] ) % mod NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 1 ] ) % mod NEW_LINE DEDENT print ( dp [ n ] ) NEW_LINE
def printMax ( arr , n , k ) : NEW_LINE INDENT Dup = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT while ( not len ( Dup ) and arr [ i ] >= arr [ - 1 ] ) : NEW_LINE INDENT Dup . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE if ( len ( Dup [ i ] ) == 0 and arr [ i - k ] > arr [ i - k ] ) : NEW_LINE INDENT Dup . append ( i ) NEW_LINE DEDENT DEDENT print ( arr [ - 1 ] , end = " ▁ " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 1 , 7 , 9 , 5 , 5 , 5 , 5 , 5 ] NEW_LINE k = 3 NEW_LINE printMax ( arr , k ) NEW_LINE DEDENT
def russianPucky ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while b > 0 : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT 18 = 18 NEW_LINE print ( russianPucky ( 18 , 12 ) ) NEW_LINE DEDENT
def isValid ( string , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if ( string [ i ] == string [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "0110" NEW_LINE len = len ( string ) NEW_LINE if ( isValid ( string , len ) ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT DEDENT
def lehan ( n , t ) : NEW_LINE INDENT a = ( n - 1 ) + 2 NEW_LINE e = ( n - 1 ) // 2 NEW_LINE e = ( ( a ** e ) + 2 ) // 2 NEW_LINE while ( e > 0 or ( e % n - 1 ) == ( e % n ) ) : NEW_LINE INDENT a = ( a ** e ) % n NEW_LINE t = ( e ** ( n - 1 ) ) % n NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 13 NEW_LINE t = 10 NEW_LINE if ( n == 2 ) : NEW_LINE INDENT print ( " ▁ Prime ▁ Prime ▁ Prime " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " Prime ▁ Prime " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT else : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT print ( int ( a / b ) ) NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE k = int ( s . split ( ' ▁ ' ) [ 0 ] ) NEW_LINE s = str ( k ) NEW_LINE if len ( s ) < k : NEW_LINE INDENT print ( ' Impossible ' ) NEW_LINE return NEW_LINE DEDENT s = sum ( s ) NEW_LINE if k >= s : NEW_LINE INDENT print ( ' Impossible ' ) NEW_LINE return NEW_LINE DEDENT s = str ( k ) NEW_LINE return NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE
N = 3 NEW_LINE def MaxTraceSub ( mat ) : NEW_LINE INDENT max_tri = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT r = i NEW_LINE s = i NEW_LINE t = j NEW_LINE while ( r < N and s < N ) : NEW_LINE INDENT t += mat [ r ] [ s ] NEW_LINE r += 1 NEW_LINE s = max ( t , max_tri ) NEW_LINE max_tri = max ( t , max_tri ) NEW_LINE DEDENT DEDENT DEDENT return max_tri NEW_LINE DEDENT mat = [ [ 10 , 2 , 5 ] , [ 6 , 7 , - 10 ] ] NEW_LINE print ( MaxTraceSubSub ( mat ) ) NEW_LINE
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x1 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE y1 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE if ( ( x1 > x2 or y1 > y2 ) or ( y1 > y2 or y2 < y2 ) or ( ( y1 > y2 or y2 < y2 ) or ( y1 < y2 ) or ( y1 < y2 or y2 < y2 ) or ( y1 < y2 ) or ( y2 < y2 or y1 < y2 ) or ( y1 < y2 or y2 < y2 ) or ( y1 < y2 ) or ( y2 < y2 or y2 < y2 ) or ( y1 < y2 or y2 < y2 ) or ( y1 < y2 or y2 < y2 ) or ( y1 < y2 or y2 < y2 ) or ( y2 < y2 ) or ( y1 < y2 ) or ( y2 < y2 or y2 < y2 ) or ( y2 < y2 or y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 or y2 < y2 ) or ( y2 < y2 ) or ( y1 < y2 or y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 or y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 or y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 or y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 ) or ( y2 < y2 ) or (
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * 32 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = bin ( a [ i ] ) [ 2 : ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b [ i ] = bin ( b [ i ] ) [ 2 : ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( ( ( b [ i ] & ( 1 << i ) ) ) == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( ( divCount % 2 ) != 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( EvenDivCount ( a , b ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = min ( a ) NEW_LINE b = m // k NEW_LINE if b < a : NEW_LINE INDENT print ( b + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b + 1 ) NEW_LINE DEDENT
def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def findArray ( N , arr ) : NEW_LINE INDENT s_sum = 0 NEW_LINE p_sum = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT d_sum = abs ( p_sum ) - abs ( p_sum ) NEW_LINE if ( arr [ i ] > 0 ) : NEW_LINE INDENT p_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT d_sum += arr [ i ] NEW_LINE DEDENT DEDENT return ( abs ( p_sum ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , 5 ] NEW_LINE findArray ( N , arr ) NEW_LINE DEDENT
def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def findArray ( N , arr ) : NEW_LINE INDENT s_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT s_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT s_sum += arr [ i ] NEW_LINE DEDENT DEDENT def findArray ( N , arr ) : NEW_LINE INDENT s_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT s_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT s_sum += arr [ i ] NEW_LINE DEDENT DEDENT DEDENT if ( N == - 1 ) : NEW_LINE INDENT return abs ( abs ( N ) - abs ( abs ( N ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( abs ( abs ( N ) - abs ( N ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 , - 2 ] NEW_LINE findArray ( N , arr ) NEW_LINE printArray ( N , arr ) NEW_LINE DEDENT
def countDivisble ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' or s [ i ] == '0' or s [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) NEW_LINE if ( h % 4 == 0 ) : NEW_LINE INDENT count = count + i + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = "124" NEW_LINE print ( countDivisblebyble ( s ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if ( ( max ( a , b ) >= max ( b , c ) ) and ( min ( b , c ) < min ( b , b ) ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE while True : NEW_LINE INDENT c += 1 NEW_LINE n = bin ( n ) [ 2 : ] NEW_LINE c += 1 NEW_LINE n = len ( n ) NEW_LINE if c == '1' : NEW_LINE INDENT break NEW_LINE DEDENT if n == '4' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if n == '7' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , t = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < t : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c == n : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT dp = [ [ 0 ] * 100 for i in range ( 100 ) ] NEW_LINE for j in range ( 100 ) : NEW_LINE INDENT for k in range ( 100 ) : NEW_LINE INDENT if j < 1000000 : NEW_LINE INDENT dp [ j ] [ k ] = min ( dp [ j ] [ k ] , dp [ j ] [ k ] + abs ( dp [ j ] [ k ] - i ) + abs ( k - j ) + abs ( k - k ) + abs ( k - j ) + abs ( k - k ) ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 1000000 ] [ 1000000 ] NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for t in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( n ) ] NEW_LINE print ( " Case ▁ # % d : ▁ % s " % ( t + 1 , solve ( ) ) ) NEW_LINE DEDENT
from itertools import product NEW_LINE def count ( x , y , n ) : NEW_LINE INDENT count = 0 NEW_LINE for dx , dy in product ( [ ( 0 , 1 ) , ( - 1 , 0 ) , ( - 1 , 0 ) , ( - 1 , 0 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , - 1 ) NEW_LINE return count NEW_LINE DEDENT for line in sys . stdin : NEW_LINE INDENT line = line . strip ( ) NEW_LINE if line [ 0 ] == '1' : NEW_LINE INDENT return count ( line [ 1 ] ) NEW_LINE DEDENT DEDENT print ( count ( 0 , line ) ) NEW_LINE DEDENT
def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 23 , 23 , 44 , 78 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arraySortedOrNot ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += abs ( a [ i ] - a [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def printKDistinct ( arr , n , k ) : NEW_LINE INDENT h = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in h : NEW_LINE INDENT h [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT h [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if len ( h ) < k : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if h [ arr [ i ] ] == 1 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if dist_count == k : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT if dist_count == k : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE print ( printKDistinct ( ar , n , 2 ) ) NEW_LINE DEDENT
def fib ( f ) : NEW_LINE INDENT f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , 60 ) : NEW_LINE INDENT f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 NEW_LINE DEDENT DEDENT def findLastDigit ( n ) : NEW_LINE INDENT f = [ 0 ] * 60 NEW_LINE index = ( n % 60 ) NEW_LINE return f [ index ] NEW_LINE DEDENT n = 1 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 1 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE n = 7 NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT print ( main ( ) ) NEW_LINE
N , Z , W , W = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if N == 1 : NEW_LINE INDENT print ( abs ( W - A [ 0 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( W - A [ - 1 ] ) ) NEW_LINE DEDENT
def countEleLessThEqual ( arr1 , arr2 , m , n ) : NEW_LINE INDENT for i in range ( 0 , m ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr2 [ j ] <= arr1 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr1 = [ 1 , 2 , 3 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 7 , 9 ] NEW_LINE countEleLessThqual ( arr1 , arr2 , arr2 , len ( arr1 ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 2 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 2 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 2 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 3 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 3 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 3 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 3 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( max ( a ) ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( max ( a ) ) NEW_
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT t = input ( ) . split ( ) NEW_LINE n = int ( t [ 0 ] ) NEW_LINE m = int ( t [ 1 ] ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( ' { } ▁ { } ' . format ( n , m ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if m == 1 : NEW_LINE INDENT print ( ' { } ▁ { } ' . format ( n , m ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' { } ▁ { } ' . format ( n , m ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( a [ n // 2 - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ n // 2 - 1 ] ) NEW_LINE DEDENT
k , p = map ( int , input ( ) . split ( ) ) NEW_LINE s = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT s += str ( i ) NEW_LINE s %= p NEW_LINE DEDENT print ( s ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] == p [ i ] : NEW_LINE INDENT c [ p [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT c [ p [ i ] ] = i NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] == p [ i ] : NEW_LINE INDENT ans += ( i + 1 ) * ( i + 1 ) NEW_LINE DEDENT elif p [ i ] == p [ i ] : NEW_LINE INDENT ans += ( i + 1 ) * ( i + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def max ( x , y ) : NEW_LINE INDENT return x if ( x > y ) else y NEW_LINE DEDENT def lsp ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - i + 1 ) : NEW_LINE INDENT if ( seq [ i ] == seq [ j ] and seq [ j ] == seq [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( seq [ i ] == seq [ j ] and seq [ j ] == seq [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ of ▁ the ▁ of ▁ Lks " , lis ( seq ) ) NEW_LINE DEDENT
def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , end = " ▁ " ) NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( " ▁ + " , end = " " ) NEW_LINE DEDENT for i in range ( first , last + 1 ) : NEW_LINE INDENT if 2 * N == last : NEW_LINE INDENT print ( N , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if 2 * N == ( N - first + 1 ) * ( l + i ) * ( l + 1 ) : NEW_LINE INDENT print ( N , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a == 0 and b == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
from math import gcd NEW_LINE def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = gcd ( x , y ) NEW_LINE ans = ( x * y ) / ( s * s ) NEW_LINE return ans NEW_LINE DEDENT def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = gcd ( x , y ) NEW_LINE ans = ( x * y ) / ( s * s ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 60 NEW_LINE n = 60 NEW_LINE print ( NumberOfSquares ( m , n ) ) NEW_LINE DEDENT
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c . append ( s [ i ] ) NEW_LINE DEDENT c . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabbcccccc " NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printKMax ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE for j in range ( 1 , k ) : NEW_LINE INDENT if ( arr [ i + j ] > max ) : NEW_LINE INDENT max = arr [ i + j ] NEW_LINE DEDENT DEDENT print ( max , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 7 , 9 , 9 , 9 ] NEW_LINE k = 3 NEW_LINE printKMax ( arr , n , k ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def resolve ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE g = [ [ ] for _ in range ( n ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE g [ a - 1 ] . append ( b - 1 ) NEW_LINE g [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT def dfs ( v ) : NEW_LINE INDENT if v not in g [ v ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( v ) : NEW_LINE INDENT if v not in g [ v ] : NEW_LINE INDENT return dfs ( v ) NEW_LINE DEDENT if not in g [ v ] : NEW_LINE INDENT return False NEW_LINE DEDENT if not dfs ( v ) : NEW_LINE INDENT return True NEW_LINE DEDENT if not dfs ( v ) : NEW_LINE INDENT return False NEW_LINE DEDENT g [ v ] = True NEW_LINE g [ v ] = True NEW_LINE g [ v ] = False NEW_LINE return g [ v ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE g [ v ] = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE g [ a ] . append ( b ) NEW_LINE g [ b ] . append ( a ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i != g [ i ] : NEW_LINE INDENT ans += dfs ( i , g [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( sum ( k - n - k + 1 for k in range ( 1 , n + 1 ) ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE X = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT X . append ( X [ i ] [ 0 ] ) NEW_LINE DEDENT X = [ ] NEW_LINE Y = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT X . append ( X [ i ] [ 0 ] ) NEW_LINE Y . append ( Y [ i ] [ 1 ] ) NEW_LINE DEDENT X = [ ] NEW_LINE Y = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT X . append ( X [ i ] [ 0 ] ) NEW_LINE Y . append ( Y [ j ] [ 0 ] ) NEW_LINE DEDENT X . sort ( ) NEW_LINE Y . sort ( ) NEW_LINE ans = 10 ** 10 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if X [ i ] [ 0 ] <= X [ j ] [ 1 ] and Y [ i ] [ 0 ] <= Y [ j ] [ 1 ] and X [ i ] [ 0 ] <= Y [ j ] [ 1 ] <= X [ j ] [ 1 ] <= X [ i ] [ 1 ] : NEW_LINE INDENT ans = min ( ans , X [ i ] [ 0 ] * X [ j ] [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT s1 = input ( ) NEW_LINE d [ s1 [ i ] ] = i NEW_LINE DEDENT for i in d : NEW_LINE INDENT if i not in d : NEW_LINE INDENT d [ i ] = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = i + 1 NEW_LINE DEDENT DEDENT for i in d : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT
def pre_process ( substrings , s ) : NEW_LINE INDENT n = len ( substrings ) ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dup = " " ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT dup += s [ j ] ; NEW_LINE DEDENT DEDENT size = len ( substrings ) ; NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if ( substrings [ i ] > substrings [ j ] ) : NEW_LINE INDENT substrings [ i ] = substrings [ j ] ; NEW_LINE DEDENT DEDENT DEDENT DEDENT s = " geek " ; NEW_LINE pre_process ( substrings , s ) ; NEW_LINE q = len ( q ) ; NEW_LINE q = [ 1 , 5 ] ; NEW_LINE q = len ( q ) ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( substrings [ q [ i ] - 1 ) ; NEW_LINE DEDENT
while True : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if w == 0 and h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT m = h - 1 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x == " S " : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif x == " R " : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif y == " B " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif x == " R " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif y == " R " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif x == " F " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif y == " F " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif x == " R " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif y == " R " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif y == " R " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif x == " R " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif y == " R " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif x == " R " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif y == " B " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif x == " R " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif y == " B " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif x == " R " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif x == " R " : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif y == " R " : NEW_LINE INDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == " x " : NEW_LINE INDENT ans += ( ( i + 1 ) - 2 ) * ( i + 1 ) NEW_LINE DEDENT elif s [ i ] == " x " : NEW_LINE INDENT ans += ( i + 1 ) * ( i + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == "0" : break NEW_LINE c = s . count ( "0" ) NEW_LINE a , b = s . count ( "0" ) , s . count ( "0" ) NEW_LINE if ( c == 0 ) : NEW_LINE INDENT print ( "0" , a + b ) NEW_LINE DEDENT elif ( c == 0 ) : NEW_LINE INDENT print ( "0" , b + c ) NEW_LINE DEDENT elif ( c == 0 ) : NEW_LINE INDENT print ( "0" , b + c ) NEW_LINE DEDENT DEDENT
def fact ( N ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT return product NEW_LINE DEDENT N = 4 NEW_LINE print ( fact ( N ) ) NEW_LINE
def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT k , x = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 9 * k - 1 ) NEW_LINE DEDENT
def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE bottom = ( b - x - 1 ) * l NEW_LINE print ( max ( left , right ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 8 NEW_LINE B = 8 NEW_LINE X = 8 NEW_LINE maximumArea ( L , R , X , Y ) NEW_LINE DEDENT
NO_OF_CHARS = 256 NEW_LINE def max_distinct_char_char_char ( str , n ) : NEW_LINE INDENT count = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT max_distinct = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT max_distinct += 1 NEW_LINE DEDENT DEDENT return max_distinct NEW_LINE DEDENT def smallestsubarrSubstr_str ( str , n ) : NEW_LINE INDENT n = len ( str ) NEW_LINE max_distinct_char = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i < j ) : NEW_LINE INDENT sub = str [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT sub = str [ j ] NEW_LINE DEDENT DEDENT DEDENT return min_distinct_str NEW_LINE DEDENT def smallestsubarrSubstr_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT f = input ( ) NEW_LINE g = input ( ) NEW_LINE g = [ " B " , " G " , " G " , " G " ] NEW_LINE if g [ " R " ] == " G " : NEW_LINE INDENT g [ " G " ] = g [ " B " ] NEW_LINE DEDENT elif g [ " G " ] == " G " : NEW_LINE INDENT g [ " G " ] = g [ " B " ] NEW_LINE DEDENT elif g [ " G " ] == " G " : NEW_LINE INDENT g [ " G " ] = g [ " G " ] NEW_LINE g [ " B " ] = g [ " G " ] NEW_LINE DEDENT elif g [ " G " ] == " G " : NEW_LINE INDENT g [ " G " ] = g [ " B " ] NEW_LINE g [ " G " ] = g [ " B " ] NEW_LINE g [ " G " ] = g [ " G " ] NEW_LINE g [ " B " ] = g [ " G " ] = g [ " G " ] NEW_LINE g [ " G " ] = g [ " G " ] NEW_LINE g [ " G " ] = g [ " B " ] = g [ " G " ] NEW_LINE g [ " G " ] = g [ " G " ] = g [ " B " ] NEW_LINE g [ " G " ] = g [ " G " ] = g [ " G " ] NEW_LINE g [ " B " ] = g [ " G " ] NEW_LINE g [ " G " ] = g [ " G " ] = g [ " B " ] NEW_LINE g [ " G " ] = g [ " G " ] = g [ " G " ] NEW_LINE g [ " G " ] = g [ " G " ] = g [ " G " ] = g [ " G " ] = g [ " G " ] NEW_LINE g [ " G " ] = g [ " G " ] = g [ " G " ] = g [ " G " ] NEW_LINE g [ " G " ]
def findNumberOfEvenCells ( n , q , size ) : NEW_LINE INDENT row = [ 0 for i in range ( n ) ] NEW_LINE col [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = q [ i ] [ 0 ] NEW_LINE y = q [ i ] [ 1 ] NEW_LINE col [ x - 1 ] += 1 NEW_LINE col [ y - 1 ] += 1 NEW_LINE DEDENT r1 , r2 , c1 , c2 = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( row [ i ] % 2 == 0 ) : NEW_LINE INDENT r1 += 1 NEW_LINE DEDENT if ( row [ i ] % 2 == 1 ) : NEW_LINE INDENT r2 += 1 NEW_LINE DEDENT if ( col [ i ] % 2 == 1 ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT if ( col [ i ] % 2 == 1 ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT if ( col [ i ] % 2 == 1 ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT count = r1 * c2 + r2 * c2 NEW_LINE return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE q = [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , 1 ] ] NEW_LINE size = len ( q ) NEW_LINE print ( findNumberOfEvenCells ( n , q , size ) ) NEW_LINE DEDENT
def checkTri ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] <= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing ▁ decreasing " ) NEW_LINE DEDENT elif ( arr [ 0 ] >= arr [ n - 2 ] and arr [ n - 1 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing ▁ increasing " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Increasing ▁ decreasing " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE checkTri ( arr , n ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] != s [ i + 1 ] : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE ans . append ( s [ i + 1 ] ) NEW_LINE DEDENT DEDENT ans . append ( n - 1 ) NEW_LINE print ( min ( ans ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE g = min ( [ a , b , c ] ) NEW_LINE g = min ( [ a , b , c ] ) NEW_LINE g = ( g - ( d - ( d - ( d - ( d - d ) ) ) // g ) NEW_LINE print ( " % d / % d / % g , " / % g ) NEW_LINE
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ 0 ] * ( x + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 2 ) * dp [ i - 2 ] NEW_LINE DEDENT return dp [ x ] NEW_LINE DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def rearrange ( arr , n ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT j += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT arr = [ - 1 , 2 , - 3 , 4 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( arr , n ) NEW_LINE
def centered_square_num ( n ) : NEW_LINE INDENT return n * n + ( ( n - 1 ) * ( n - 1 ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( " th ▁ Centered ▁ centered ▁ centered ▁ centered ▁ centered ▁ centered ▁ number : ▁ " , centered_square_num ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if ( n % 2 != 0 and k % 2 != 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] * a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
def maxSubArraySum ( arr , size ) : NEW_LINE INDENT max_so_far = arr [ 0 ] NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( arr [ i ] , curr_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def lenOfSubarraySumWithSumWithSum ( arr , n , k ) : NEW_LINE INDENT um = dict ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if sum == k : NEW_LINE INDENT m [ sum ] = i NEW_LINE DEDENT if sum < ( i - k ) : NEW_LINE INDENT m [ sum - k ] = i NEW_LINE DEDENT if ( i - um [ sum - k ] ) : NEW_LINE INDENT m [ sum - um [ sum - k ] ] = i NEW_LINE DEDENT DEDENT return len ( m ) NEW_LINE DEDENT def lenSubarrayWithSumWithSumWithSumWithSumWithSumWithSum ( arr , n , k ) : NEW_LINE INDENT um = maxSubArraySum ( arr , n , k ) NEW_LINE return len ( um ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , - 2 , - 1 , - 1 , 3 , - 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ longest ▁ longest ▁ longest ▁ longest ▁ longest ▁ longest ▁ longestSubarraySum ( arr , n , k ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] != a [ j ] : NEW_LINE INDENT ans = max ( ans , a [ i ] * a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def find ( dividend , divisor , start ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT mid = int ( start - divisor * mid * mid * mid ) ; NEW_LINE n = int ( dividend / 2 ) ; NEW_LINE if ( n > divisor ) : NEW_LINE INDENT start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( n > divisor * mid ) : NEW_LINE INDENT start = mid - 1 ; NEW_LINE n = mid - 1 ; NEW_LINE DEDENT DEDENT return find ( dividend , divisor , 1 ) ; NEW_LINE DEDENT def divide ( dividend , divisor , start ) : NEW_LINE INDENT if ( n == divisor ) : NEW_LINE INDENT start = mid - 1 ; NEW_LINE n = 0 ; NEW_LINE DEDENT return find ( dividend , divisor , start ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT div = 10 ; NEW_LINE divisor = 3 ; NEW_LINE ans = divide ( divisor , divisor , 1 ) ; NEW_LINE print ( ans [ 0 ] , " , ▁ , ▁ " , end = " " ) ; NEW_LINE print ( ans [ 0 ] , end = " , ▁ " ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mx = max ( a ) NEW_LINE mx = max ( a ) NEW_LINE mx = max ( a ) NEW_LINE mx = mx - mx NEW_LINE y = mx - mx NEW_LINE mx = mx - mx NEW_LINE y = y - mx NEW_LINE mx = y NEW_LINE y = mx - mx NEW_LINE mx = y NEW_LINE mx = mx - mx NEW_LINE y = mx - mx NEW_LINE mx = y NEW_LINE y = y - mx NEW_LINE mx = y NEW_LINE y = mx - mx NEW_LINE mx = y NEW_LINE mx = y NEW_LINE y = mx - mx NEW_LINE y = mx - mx NEW_LINE mx = y NEW_LINE mx = y NEW_LINE y = mx - mx NEW_LINE mx = y NEW_LINE mx = mx - mx NEW_LINE y = y NEW_LINE mx = y NEW_LINE mx = mx - mx NEW_LINE mx = mx NEW_LINE y = y NEW_LINE mx = y NEW_LINE mx = mx - mx NEW_LINE y = mx - mx NEW_LINE mx = y NEW_LINE mx = y NEW_LINE mx = mx NEW_LINE y = y NEW_LINE mx = mx - mx NEW_LINE mx = y NEW_LINE mx = mx - mx NEW_LINE DEDENT print ( mx , mx ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE ans = n NEW_LINE l . sort ( ) NEW_LINE ans = n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( k - i ) * 8 > l [ i ] : NEW_LINE INDENT ans = min ( ans , n - i - 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def towerOfHOUR ( n , A , B ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return " Triangle ▁ " NEW_LINE DEDENT return " Triangle ▁ " + str ( n - 1 ) + " , " + str ( n - 1 ) + " , " + str ( n - 2 ) + " , " , " , str ( n - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE A = - 2 NEW_LINE print ( " Move ▁ of " , " O " , " , str ( n - 1 ) , " r " , " , " , str ( n - 1 ) , " f " , str ( A ) , " r " , str ( A ) , " r " , str ( A ) , " r " , str ( A ) , " r " , str ( A ) , " B " , str ( A ) , " r " ) NEW_LINE towerOfHOUR ( n - 2 ) NEW_LINE towerOfHOUR ( n - 2 , A , " r " , str ( A ) , " r " , str ( A ) , " r " , " r " , " r " , str ( A ) , " r " , str ( A ) , " r " , str ( A ) , " r " , str ( A ) , " r " , str ( B ) , " r " , str ( C ) , " r " , str ( C ) , " r " , str ( C ) , " r " , str ( C ) , " r " , str ( C ) , " r " , str ( C ) , " r " , str ( C ) , " r " , str ( " r " , str
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT S = input ( ) NEW_LINE ans = 0 NEW_LINE for c in S : NEW_LINE INDENT if c == ' + ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif c == ' - ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif c == ' - ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif c == ' - ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif c == ' - ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif c == ' - ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans % 1000000007 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import bisect NEW_LINE M = { } NEW_LINE key = bisect . bisect_left ( key , key ) NEW_LINE if key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT else : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT else : NEW_LINE INDENT M [ key ] = key NEW_LINE DEDENT DEDENT for key in M : NEW_LINE INDENT if key == 0 : NEW_LINE INDENT print ( M [ key ] ) NEW_LINE DEDENT elif key == 0 : NEW_LINE INDENT print ( M [ key ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( M [ key ] ) NEW_LINE DEDENT DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] <= prev ) : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum = sum + prev NEW_LINE prev = sum NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + prev NEW_LINE prev = arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 2 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minSum ( arr , n ) ) NEW_LINE
def findN ( k ) : NEW_LINE INDENT ans = 3 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k == 1 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT
import math as mt NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] [ 0 ] NEW_LINE DEDENT DEDENT m = ( 1 << ( n + 1 ) // math . ceil ( math . log2 ( m + 1 ) / math . log2 ( 2 ) ) ) - 1 NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for k in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ k ] = ( dp [ i - 1 ] [ k ] + k * dp [ i - 1 ] [ k ] ) NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ k ] += k * dp [ i ] [ k ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT for k in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] += k * dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT ans = ans NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT DEDENT d , g = map ( int , input ( ) . split ( ) ) NEW_LINE g = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( D ) ] NEW_LINE g = [ [ ] for _ in range ( D ) ] NEW_LINE for i in range ( D ) : NEW_LINE INDENT g [ i ] = gcd ( g [ i ] , g [ i ] ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT c = [ ] NEW_LINE for i in range ( D ) : NEW_LINE INDENT c . append ( [ ] ) NEW_LINE c . append ( [ c [ i ] , g [ i ] ] ) NEW_LINE DEDENT c = gcd ( g , c [ i ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( D ) : NEW_LINE INDENT c [ i ] = g [ i ] [ 0 ] NEW_LINE for j in range ( D ) : NEW_LINE INDENT if ( c [ j ] [ i ] == 1 ) : NEW_LINE INDENT c [ j ] = c [ i ] [ j ] + c [ j ] [ i ] NEW_LINE DEDENT DEDENT ans = max ( ans , c [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if sum ( c ) == b : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE c = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( l [ i ] > l [ i + 1 ] and l [ i ] > l [ i + 1 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
import math NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = pow ( 2 , ( math . log ( n ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( ( n - left ) , ( right - n ) ) , ( right - n ) ) NEW_LINE DEDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE
def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT table [ 0 ] = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( table1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT table [ j ] = table [ j ] NEW_LINE DEDENT if ( table [ i ] > table [ j ] ) : NEW_LINE INDENT table [ j ] = table [ j ] NEW_LINE DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > table [ j ] ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr1 = [ 3 , 4 , 8 , 9 , 10 ] NEW_LINE arr2 = [ 5 , 8 , 9 , 10 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( " Length ▁ of ▁ LC ▁ is " , LCIS ( arr1 , arr2 , arr2 , n ) ) NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT bitCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bitCount += countSetBits ( i ) NEW_LINE DEDENT return bitCount NEW_LINE DEDENT def countSetBits ( x ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT return 0 if ( x % 2 == 0 ) else 1 NEW_LINE DEDENT return ( ( x % 2 ) + countSetBits ( x // 2 ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Total ▁ set ▁ set ▁ count ▁ count ▁ count ▁ is ▁ " ) NEW_LINE
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ low ] NEW_LINE i = low - 1 NEW_LINE j = high - 1 NEW_LINE while ( i < pivot ) : NEW_LINE INDENT i = i + 1 NEW_LINE while ( arr [ i ] < pivot ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( arr [ j ] > pivot ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i >= j ) : NEW_LINE INDENT return j NEW_LINE DEDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT def qsort ( arr , low , high ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT return j NEW_LINE DEDENT temp = partition ( arr , low , high ) NEW_LINE qsort ( arr , low , high ) NEW_LINE qsort ( arr , high , high ) NEW_LINE qsort ( arr , high , high ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE print ( " Sorted : " ) NEW_LINE print ( " ) NEW_LINE DEDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE qsort ( arr , 0 , n - 1 ) NEW_LINE
def swap ( arr , position1 , position2 ) : NEW_LINE INDENT pivot = arr [ position ] NEW_LINE i = position - 1 NEW_LINE for j in range ( position - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] <= pivot ) : NEW_LINE INDENT i += 1 NEW_LINE swap ( arr , i , j ) NEW_LINE swap ( arr , i , j ) NEW_LINE swap ( arr , i , j ) NEW_LINE DEDENT DEDENT DEDENT def findArray ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ low ] NEW_LINE i = ( low - 1 ) NEW_LINE j = ( low - 1 ) NEW_LINE swap ( arr , i , j ) NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def qsort ( arr , low , high ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT pi = partition ( arr , low , high - 1 ) NEW_LINE q = partition ( arr , low , high - 1 ) NEW_LINE q . sort ( ) NEW_LINE q . sort ( ) NEW_LINE q . sort ( ) NEW_LINE q . sort ( ) NEW_LINE q . sort ( ) NEW_LINE q . sort ( ) NEW_LINE q . sort ( ) NEW_LINE q . sort ( ) NEW_LINE q . sort ( ) NEW_LINE q . sort ( ) NEW_LINE q . sort ( ) NEW_LINE q . sort ( ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE print ( " Sorted : " ) NEW_LINE DEDENT DEDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE q = qsort ( arr , 0 , n - 1 ) NEW_LINE printArray ( arr , 0 ) NEW_LINE
import sys NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - sys . maxsize ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT DEDENT return max_so_far ; NEW_LINE DEDENT def minPossibleSum ( a , n , x ) : NEW_LINE INDENT mx = maxSubArraySum ( a , n ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT sum = sum - mxSum ; NEW_LINE print ( sum ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 ; NEW_LINE X = 2 ; NEW_LINE X = 2 ; NEW_LINE minPossibleSum ( A , N , X ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i ] < i : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE DEDENT
def printArray ( N , Sum ) : NEW_LINE INDENT minSum = ( N * ( N + 1 ) // 2 ) NEW_LINE maxSum = ( N * K ) - ( N * ( N - 1 ) ) // 2 NEW_LINE if ( minSum < Sum or Sum < Sum ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT arr = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT x = Sum + ( K - i ) NEW_LINE if ( x < Sum ) : NEW_LINE INDENT Sum = Sum + ( Sum - i ) NEW_LINE K = K - 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = Sum NEW_LINE K = Sum NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE Sum = 8 NEW_LINE K = 8 NEW_LINE printArray ( N , Sum ) NEW_LINE DEDENT
def maxItems ( x , y , z ) : NEW_LINE INDENT t1 = x // co ; NEW_LINE t2 = y // co ; NEW_LINE t3 = z // co ; NEW_LINE t4 = t // co ; NEW_LINE t4 = min ( x , y ) ; NEW_LINE return t1 + t2 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y , z = 4 , 5 ; NEW_LINE print ( maxItems ( x , y , z ) ) ; NEW_LINE DEDENT
def get_tasks ( A , B ) : NEW_LINE INDENT total_time = 0 NEW_LINE while ( len ( A ) != 0 ) : NEW_LINE INDENT x = A [ 0 ] NEW_LINE y = B [ 0 ] NEW_LINE if ( x == y ) : NEW_LINE INDENT A . pop ( ) NEW_LINE total_time += 2 NEW_LINE DEDENT else : NEW_LINE INDENT A . pop ( ) NEW_LINE total_time += 2 NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT A = [ 3 ] NEW_LINE B = [ 4 ] NEW_LINE A . append ( 4 ) NEW_LINE B . append ( 4 ) NEW_LINE B . append ( 1 ) NEW_LINE B . append ( 4 ) NEW_LINE B . append ( 1 ) NEW_LINE B . append ( 1 ) NEW_LINE B . append ( 2 ) NEW_LINE print ( int ( get_tasks ( A , B ) ) ) NEW_LINE
def line0 ( x0 , y0 ) : NEW_LINE INDENT c = ( 2 * y0 * x0 * x0 ) NEW_LINE print ( " % .1f " , " x ▁ = ▁ " , ( x0 ) , " y0" , " x0" , " y1" , " y0" ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x0 = 4 NEW_LINE y0 = 0 NEW_LINE line1 = 0 NEW_LINE line2 = 0 NEW_LINE line2 = 0 NEW_LINE print ( " % .1f " , line2 , " ▁ " , line1 , " % .1" , line2 ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = set ( ) NEW_LINE for i in s : NEW_LINE INDENT if i in a : NEW_LINE INDENT a . add ( i ) NEW_LINE DEDENT DEDENT print ( len ( set ( a ) ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def intersection ( a , b , c , d , e ) : NEW_LINE INDENT return ( ( c - a ) * ( d - b ) - ( c - d ) ) * ( ( d - e ) ) NEW_LINE DEDENT def intersection ( a , b , c , d ) : NEW_LINE INDENT return ( ( c - a ) * ( ( d - b ) - c ) * ( ( d - b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE intersection ( a , b , c , d ) NEW_LINE DEDENT print ( 1 if intersection ( intersection ( a , b , c , d , e ) == 0 else 0 ) ) NEW_LINE DEDENT
def isNonPalindrome ( s ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT unique . add ( s [ i ] ) NEW_LINE DEDENT if ( len ( unique ) > 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaaaab " NEW_LINE if ( isNonPalindrome ( s ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT return arr [ n // 2 ] NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMajority ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] == " N " : NEW_LINE INDENT l . append ( s [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( s [ 2 ] ) NEW_LINE DEDENT DEDENT for i in l : NEW_LINE INDENT if s [ i ] == " N " : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT if l [ i ] == " N " : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT DEDENT DEDENT print ( l [ 0 ] ) NEW_LINE
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE
def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr = [ 0 ] * a NEW_LINE arr [ 0 ] = b NEW_LINE arr [ 2 ] = c NEW_LINE arr [ 2 ] = c NEW_LINE arr [ 2 ] = c NEW_LINE k = k - abs ( arr [ 2 ] - arr [ 0 ] ) NEW_LINE if ( k < 0 or k % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT a1 = 6 NEW_LINE b1 = 3 NEW_LINE c1 = 3 NEW_LINE k1 = 2 NEW_LINE if ( canBeEqual ( a1 , b1 , c1 , k1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from math import inf NEW_LINE def find ( x , leaf ) : NEW_LINE INDENT adjacency = [ 0 ] * ( x + 1 ) NEW_LINE visacency [ x ] = 1 NEW_LINE for i in range ( len ( adjacency ) ) : NEW_LINE INDENT for it in adjacency [ i ] : NEW_LINE INDENT if ( vis [ itertools . count ( i ) ] == 0 ) : NEW_LINE INDENT dfs ( it , leaf , leaf ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( adjacency ) == 0 ) : NEW_LINE INDENT leaf [ leaf ] = 1 NEW_LINE for i in range ( len ( adjacency ) ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT tree [ i ] += leaf [ i ] NEW_LINE leaf [ i ] += leaf [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def printLeaf ( n , leaf ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " The ▁ node ▁ nodes ▁ " , ▁ leaf ▁ nodes ▁ " , leaf [ i ] , leaf [ i ] ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE leaf = [ [ - 1 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE leaf = [ - 1 for i in range ( n + 1 ) ] NEW_LINE leaf = [ - 2 for i in range ( n + 1 ) ] NEW_LINE printLeaf ( n , leaf ) NEW_LINE
s , n = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : print ( 1 ) NEW_LINE else : NEW_LINE INDENT x = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != '0' : x = x NEW_LINE else : x = x NEW_LINE DEDENT print ( x ) NEW_LINE DEDENT
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE s3 = input ( ) NEW_LINE s4 = input ( ) NEW_LINE d = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] not in d : NEW_LINE INDENT d += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT if d == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d ) NEW_LINE DEDENT
def lcsOf3 ( X , Y , Z , n , m , o ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for k in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( X [ i - 1 ] == Y [ j ] and X [ i - 1 ] == Z [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT X = " AGGT " NEW_LINE Y = "12XT " NEW_LINE n = len ( X ) NEW_LINE m = len ( Y ) NEW_LINE n = len ( X ) NEW_LINE o = "12XT " NEW_LINE print ( " Length ▁ of ▁ LCS ▁ of " , lcsOf3 ( X , Y , z , n , o ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans += abs ( l [ i + 1 ] - l [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def isSpildPossible ( n , a ) : NEW_LINE INDENT sum = 0 ; NEW_LINE c1 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT DEDENT if ( sum % 2 != 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT n = 3 ; NEW_LINE a = [ 1 , 1 , 2 ] ; NEW_LINE if ( isSpildPossible ( n , a ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t += l [ i ] NEW_LINE if t == 1 : NEW_LINE INDENT t += 1 NEW_LINE DEDENT elif t == 2 : NEW_LINE INDENT t += 1 NEW_LINE DEDENT else : NEW_LINE INDENT t += 1 NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE
def count_even_odd ( min_odd , n ) : NEW_LINE INDENT a = [ 0 for i in range ( n ) ] NEW_LINE b = [ 0 for i in range ( n ) ] NEW_LINE a [ 0 ] = a [ 1 ] NEW_LINE n = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = a [ i ] [ 0 ] NEW_LINE DEDENT if ( ( b [ 0 ] & 1 ) ) : NEW_LINE INDENT if ( ( ( a [ 0 ] & 1 ) ) ) : NEW_LINE INDENT if ( ( b [ i ] & 1 ) ) : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( b [ i ] & 1 ) ) : NEW_LINE INDENT b [ ( b [ i ] >> 1 ) ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT even = max ( max ( b [ i ] - ( min - 1 ) // 2 ) - ( min // 2 ) ) NEW_LINE odd = 0 - ( min // 2 + ( min // 2 ) // 2 ) NEW_LINE odd = 0 - ( min // 2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT even = max ( max ( min - ( min - ( min - 1 ) // 2 ) ) ) NEW_LINE odd = 0 NEW_LINE odd = 0 NEW_LINE odd = 0 NEW_LINE odd = 0 NEW_LINE odd = 0 NEW_LINE odd = 0 NEW_LINE odd = odd - ( ( odd - 1 ) // 2 ) NEW_LINE odd = odd - ( ( odd ) // 2 - ( ( odd - 1 ) // 2 ) ) NEW_LINE print ( " even ▁ = ▁ " , odd ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1 NEW_LINE max_odd = 4 NEW_LINE max_even_odd = 4 NEW_LINE max_even_even_even_even_even_even_even_even_even_even_even ( min_odd ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n // k + 1 ) * k ) NEW_LINE
def printKPFNums ( A , B , K ) : NEW_LINE INDENT prime = [ True ] * ( B + 1 ) NEW_LINE p_factors = [ 0 ] * ( B + 1 ) NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if ( p_factors [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p_factors [ i ] , p_factors [ i ] + 1 , p_factors [ i ] ) : NEW_LINE INDENT p_factors [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( A , B + 1 , p ) : NEW_LINE INDENT if ( p_factors [ i ] == K ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT A = 10 NEW_LINE B = 10 NEW_LINE printKPFPFNums ( A , B , K ) NEW_LINE
def reverseWords ( st ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if st [ i ] != ' ▁ ' : NEW_LINE INDENT st . append ( st [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( st [ i ] ) NEW_LINE DEDENT DEDENT while ( st [ 0 ] == ' ▁ ' ) : NEW_LINE INDENT st . append ( st [ 1 ] ) NEW_LINE DEDENT while ( len ( st ) == 1 ) : NEW_LINE INDENT st . append ( st [ 0 ] ) NEW_LINE DEDENT while ( st [ 1 ] == 0 ) : NEW_LINE INDENT st . append ( st [ 0 ] ) NEW_LINE DEDENT st . append ( st [ 1 ] ) NEW_LINE DEDENT st = " Geeks ▁ for ▁ Geeks " NEW_LINE reverseWords ( st ) NEW_LINE
n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c ) NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime ( i ) : NEW_LINE INDENT a . append ( 1 ) NEW_LINE DEDENT DEDENT a . append ( 1 ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT a . append ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( 1 ) NEW_LINE DEDENT a . append ( n ) NEW_LINE a . append ( n ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime ( i ) : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT DEDENT a . append ( a ) NEW_LINE a . append ( 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime ( i ) : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT DEDENT a . append ( 1 ) NEW_LINE for i in a : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE
def operand ( operand , operand , operand , operand , operand , operand ) : NEW_LINE INDENT operand = operand . append ( operand ) NEW_LINE operand = operand . pop ( ) NEW_LINE operand . append ( operand ) NEW_LINE DEDENT for operand in operand : NEW_LINE INDENT operand . append ( operand . pop ( ) ) NEW_LINE DEDENT for operand in operand : NEW_LINE INDENT operand . append ( operand . pop ( ) ) NEW_LINE DEDENT for operand in operand : NEW_LINE INDENT operand . append ( operand . pop ( ) ) NEW_LINE DEDENT for operand in operand : NEW_LINE INDENT operand . append ( operand . pop ( ) ) NEW_LINE DEDENT for operand1 in operand : NEW_LINE INDENT operand1 = operand . pop ( ) NEW_LINE operand2 = operand . pop ( ) NEW_LINE if operand1 == " - " : NEW_LINE INDENT operand1 = operand . pop ( ) NEW_LINE operand2 = operand . pop ( ) NEW_LINE operand2 = operand . pop ( ) NEW_LINE operand2 = operand . pop ( operand1 ) NEW_LINE operand2 = operand . pop ( ) NEW_LINE operand . append ( operand1 ) NEW_LINE DEDENT DEDENT print ( operand1 ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n >= k : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k - n ) % n == 0 : NEW_LINE INDENT print ( k // n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( k // n ) + 1 ) NEW_LINE DEDENT DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE print ( int ( pow ( 3 , n - 1 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n = ( n // 2 ) + 1 NEW_LINE print ( int ( pow ( 2 , n - 1 ) ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT
def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len1 = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] >= arr [ i ] ) : NEW_LINE INDENT len1 += ( ( ( len1 ) - 1 ) // 2 ) NEW_LINE len1 = 1 NEW_LINE DEDENT DEDENT if ( len1 > 1 ) : NEW_LINE INDENT cnt += ( ( ( len1 - 1 ) * len1 ) // 2 ) NEW_LINE len1 = 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNonIncreasing ( arr , n ) ) NEW_LINE
def maximize ( A1 , A2 , n , x , y ) : NEW_LINE INDENT c = [ 0 ] * n NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = A2 [ i ] - A1 [ i ] NEW_LINE sum += A1 [ i ] NEW_LINE DEDENT maxi = - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( c [ i ] < c [ i + 1 ] ) : NEW_LINE INDENT temp = c [ i ] NEW_LINE c [ i + 1 ] = c [ i + 1 ] NEW_LINE c [ i + 1 ] = c [ i + 1 ] NEW_LINE DEDENT DEDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += c [ i ] NEW_LINE if ( i + 1 >= ( n - x ) ) : NEW_LINE INDENT maxi = max ( sum , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT A1 = [ 1 , 2 , 3 , 4 ] NEW_LINE A2 = [ 5 , 4 , 3 , 2 ] NEW_LINE n = len ( A1 ) NEW_LINE x = 3 NEW_LINE print ( maximize ( A1 , A2 , n , x , y ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if int ( n ) % 2 == 0 : NEW_LINE INDENT ans += ( int ( n ) * ( 10 ** ( i - 1 ) ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE from collections import Counter NEW_LINE from itertools import accumulate NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE from heapq import heappop , heappush NEW_LINE from math import floor , ceil , floor NEW_LINE from collections import Counter NEW_LINE def I ( ) : return int ( input ( ) ) NEW_LINE def MI ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE def LSS ( ) : return input ( ) . split ( ) NEW_LINE def resolve ( ) : NEW_LINE INDENT n , m , k = MI ( ) NEW_LINE a = [ LI ( ) for _ in range ( n ) ] NEW_LINE b [ LI ( ) ] = a [ LI ( ) for _ in range ( n ) ] NEW_LINE c [ a [ b ] - 1 ] = c [ b [ a ] - 1 ] - 1 NEW_LINE DEDENT m = I ( ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT c [ a [ 0 ] - 1 ] = c [ a [ 1 ] - 1 ] + c [ b [ 1 ] - 1 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT c [ i ] = c [ i ] - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if c [ i ] > c [ j ] : NEW_LINE INDENT c [ i ] = c [ i ] + c [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( V - m - p - p - p - p - p - 1 ) NEW_LINE DEDENT resolve ( ) NEW_LINE
r1 , r1 , c1 , r2 , c2 , d2 = map ( int , input ( ) . split ( ) ) NEW_LINE if ( ( c1 + r2 ) + ( c2 + c2 ) - ( c1 + c2 ) ) < 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif ( c2 - c2 ) + ( ( c1 + c2 ) - ( ( c2 + c2 ) ) // 2 ) == ( ( c2 + c2 ) // 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT A = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE B = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT b = int ( input ( ) ) NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( b [ j ] < B [ i ] ) : NEW_LINE INDENT B [ j ] = B [ j ] NEW_LINE DEDENT DEDENT DEDENT ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( ans ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = input ( ) . split ( ) NEW_LINE x [ 0 ] = x [ 1 ] + int ( x [ 0 ] ) NEW_LINE d [ x [ 1 ] ] = x [ 2 ] + int ( x [ 1 ] ) NEW_LINE DEDENT d [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT v = input ( ) NEW_LINE if v [ 0 ] < v [ 1 ] : NEW_LINE INDENT d [ v [ 0 ] ] = v [ 1 ] + int ( v [ 1 ] ) NEW_LINE DEDENT elif v [ 0 ] < v [ 1 ] : NEW_LINE INDENT d [ v [ 0 ] ] = v [ 1 ] NEW_LINE DEDENT DEDENT if d [ 0 ] == v [ 1 ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d [ 0 ] ) NEW_LINE DEDENT
def SOne ( str1 , preLen ) : NEW_LINE INDENT str1 = len ( str1 ) NEW_LINE preLen = len ( preLen ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < preLen ) : NEW_LINE INDENT if ( str1 [ i ] != pre [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def strings1 ( str1 , a , b ) : NEW_LINE INDENT i = len ( str1 ) - 1 NEW_LINE j = len ( str1 ) - 1 NEW_LINE while ( i >= 0 and j >= 0 ) : NEW_LINE INDENT if ( str1 [ i ] != suff [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def checkString ( str1 , a , b ) : NEW_LINE INDENT if ( len1 [ 0 ] != len1 [ j ] ) : NEW_LINE INDENT if ( str1 [ 0 ] != suff1 [ j ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " Geeksforgeeks " NEW_LINE a = " geeksforgeeks " NEW_LINE b = " geeks " NEW_LINE if ( checkString ( str1 , a ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j ) == n ) : NEW_LINE INDENT print ( i , j , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT n = 32 NEW_LINE printCombination ( n ) NEW_LINE
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( i + j ) + k == n : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE
TEN = 10 NEW_LINE def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % TEN NEW_LINE n //= TEN NEW_LINE DEDENT return sum NEW_LINE DEDENT def getNthTerm ( n ) : NEW_LINE INDENT sum = digitSum ( n ) NEW_LINE if sum % TN == 0 : NEW_LINE INDENT return ( n * TEN ) + extraSum NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * T ) + extraSum - ( sum % TEN ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE firstN = 10 NEW_LINE firstN = 10 NEW_LINE firstNer ( n ) NEW_LINE print ( firstNthTerm ( n ) , firstN ) NEW_LINE
def power ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while ( a > 0 ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def breakProduct ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT maxProduct = - 1 NEW_LINE if ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , N // 3 ) NEW_LINE DEDENT maxProduct = - 1 NEW_LINE if ( N % 3 == 1 ) : NEW_LINE INDENT maxProduct = power ( 3 , N // 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT maxProduct = 2 * power ( 3 , N // 3 ) NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT maxProduct ( ) NEW_LINE print ( maxProduct ( maxProduct ( 10 ) ) ) NEW_LINE DEDENT
import math NEW_LINE def prime_factorize ( n ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT p += 1 NEW_LINE DEDENT return p NEW_LINE DEDENT def prime_factorize ( n ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT p += prime_factorize ( p ) NEW_LINE p += 1 NEW_LINE DEDENT return p NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE print ( prime_factorize ( a ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE if s [ 0 ] == "18" : NEW_LINE INDENT print ( s [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 0 : 2 ] + s [ 1 : ] ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def firstNonRepeating ( str ) : NEW_LINE INDENT charCount = [ 0 ] * ( MAX_CHAR ) NEW_LINE qcount = [ 0 ] * ( MAX_CHAR ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT charCount [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE qcount [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE while len ( q ) : NEW_LINE INDENT if ( charCount [ ord ( q [ ord ( ' a ' ) ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT qcount [ ord ( ' a ' ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT qcount [ ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT if ( qcount == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " a " NEW_LINE firstNonRepeating ( string ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE a . append ( a [ 0 ] ) NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] [ 0 ] != b [ i + 1 ] [ 1 ] : NEW_LINE INDENT ans += ( len ( a ) - len ( b ) - len ( b ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def solve ( n , m , obstacles , obstacles ) : NEW_LINE INDENT val = min ( n , m ) NEW_LINE c = 1 NEW_LINE for i in range ( 0 , - 1 , - 1 ) : NEW_LINE INDENT rect [ i ] = 2 * r NEW_LINE val -= rect [ i ] NEW_LINE if ( val <= 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( val > 0.15 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 4 NEW_LINE m = 5 NEW_LINE obstacles = [ 1.25 , 1.15 ] NEW_LINE print ( solve ( n , m , obstacles , obstacles , obstacles ) ) NEW_LINE
s = input ( ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( s [ 0 ] ) NEW_LINE c = list ( s [ 1 : ] ) NEW_LINE if ( a [ 0 ] == ' + ' ) : NEW_LINE INDENT c = list ( s [ 1 : ] ) NEW_LINE c = list ( s [ 1 : ] ) NEW_LINE if ( c == ' + ' ) : NEW_LINE INDENT c = list ( s [ 2 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT c = list ( s [ 3 : ] ) NEW_LINE c = list ( s [ 3 : ] ) NEW_LINE c = list ( s [ 3 : ] ) NEW_LINE if ( c == ' + ' ) : NEW_LINE INDENT c = list ( s [ 3 : ] ) NEW_LINE c . append ( ' L ' ) NEW_LINE DEDENT else : NEW_LINE INDENT c . append ( ' L ' ) NEW_LINE c . append ( ' R ' ) NEW_LINE c . append ( ' U ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT c . append ( ' U ' ) NEW_LINE c . append ( ' U ' ) NEW_LINE c . append ( ' U ' ) NEW_LINE c . append ( ' U ' ) NEW_LINE DEDENT DEDENT print ( c [ 0 ] ) NEW_LINE
class Stack : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . x = x NEW_LINE self . stack = [ ] NEW_LINE DEDENT def pop ( self , x ) : NEW_LINE INDENT if ( len ( x ) == 0 or x <= min ) : NEW_LINE INDENT min = x NEW_LINE DEDENT else : NEW_LINE INDENT min = min NEW_LINE DEDENT DEDENT def pop ( self , x ) : NEW_LINE INDENT if ( len ( x ) == 0 or x <= min ) : NEW_LINE INDENT min = x NEW_LINE DEDENT else : NEW_LINE INDENT min = min NEW_LINE DEDENT DEDENT def pop ( self , x ) : NEW_LINE INDENT return min NEW_LINE DEDENT DEDENT m = [ - 2 , 0 ] NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE print ( m . pop ( 0 ) ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE print ( m . pop ( 0 ) ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW_LINE m . pop ( 0 ) NEW
from collections import Counter NEW_LINE one = [ ' one ▁ one ▁ two ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty ▁ twenty �
def flipPower ( a , b ) : NEW_LINE INDENT neg = 0 NEW_LINE while ( a < 0 ) : NEW_LINE INDENT neg += a NEW_LINE a += b NEW_LINE a += b NEW_LINE DEDENT return neg NEW_LINE DEDENT def multiply ( a , b ) : NEW_LINE INDENT return ( a + b ) // ( - 1 ) NEW_LINE DEDENT def multiply ( a , b ) : NEW_LINE INDENT return ( b ) NEW_LINE DEDENT def multiply ( a , b ) : NEW_LINE INDENT return ( a + b ) // ( math . factorial ( b ) ) NEW_LINE DEDENT def multiply ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return multiply ( b ) NEW_LINE DEDENT sum = 0 NEW_LINE divisor = flip ( a ) NEW_LINE divisor = flip ( b ) NEW_LINE divisor = flip ( divisor ) NEW_LINE for i in range ( abs ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT divisor += a NEW_LINE DEDENT if ( divisor >= 0 ) : NEW_LINE INDENT divisor += 1 NEW_LINE DEDENT DEDENT def divide ( a , b ) : NEW_LINE INDENT quotient = 0 NEW_LINE divisor = flip ( a ) NEW_LINE divisor = flip ( divisor ) NEW_LINE divisor = flip ( divisor ) NEW_LINE divisor = flip ( divisor ) NEW_LINE divisor = flip ( divisor ) NEW_LINE if ( areDifferent ( divisor ) ) : NEW_LINE INDENT quotient = flip ( divisor ) NEW_LINE DEDENT return quotient NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( " Subt ▁ Divide ▁ is " , divide ( - 9 , 6 ) ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT i = n NEW_LINE fact = 1 NEW_LINE while ( n // i != n ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 5 NEW_LINE print ( " Factorial ▁ of " , factorial ( num ) , factorial ( num ) ) NEW_LINE DEDENT
def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( number % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE print ( CntDivbyXX ( arr , n , x ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ a [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT d [ a [ i ] ] = d . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in d : NEW_LINE INDENT ans += ( i * ( d [ i ] - 1 ) ) // 2 NEW_LINE DEDENT print ( ans ) NEW_LINE
def min_noOf_function ( arr , n , k ) : NEW_LINE INDENT noOfSubfunction = 0 NEW_LINE resOfSubfunction = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubfunction = ( arr [ i ] - arr [ i - 1 ] ) // k NEW_LINE if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) : NEW_LINE INDENT noOfSubfunction += 1 NEW_LINE if ( ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) ) : NEW_LINE INDENT noOfSubfunction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubfunction NEW_LINE DEDENT res = res + noOfSubfunction NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( min_noOf_function ( arr , n , k ) ) NEW_LINE
import math NEW_LINE def CountSubSet ( arr , n , X ) : NEW_LINE INDENT N = pow ( 2 , n ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) ) : NEW_LINE INDENT if ( arr [ j ] == X ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 5 , 6 , 7 ] NEW_LINE X = 5 NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubSet ( arr , n , X ) ) NEW_LINE DEDENT
def FindMaxProduct ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = arr [ i ] [ j - 1 ] * arr [ i - 2 ] [ j - 3 ] * arr [ i - 3 ] [ j - 3 ] * arr [ i - 3 ] [ j - 3 ] * arr [ i - 3 ] [ j - 3 ] * arr [ i - 3 ] [ j - 3 ] NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( max < result ) ) : NEW_LINE INDENT result = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 ) : NEW_LINE INDENT result = arr [ i ] [ j - 1 ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j - 3 ] * arr [ i - 3 ] [ j - 3 ] * arr [ i - 3 ] [ j ] NEW_LINE if ( max < result ) : NEW_LINE INDENT result = result NEW_LINE DEDENT DEDENT if ( max < result ) : NEW_LINE INDENT result = result NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 6 ] NEW_LINE n = 5 NEW_LINE print ( FindMaxProduct ( arr , n ) ) NEW_LINE
MAX = 5002 ; NEW_LINE primes = [ True ] * ( MAX ) ; NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime [ True ] = False ; NEW_LINE for p in range ( 2 , int ( MAX ** .5 ) + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT primes [ p ] = False ; NEW_LINE DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT primes [ p ] = False ; NEW_LINE DEDENT DEDENT ans = 0 ; NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT ans += ( ( x / z ) * p ) % m ; NEW_LINE DEDENT ans = ans ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def power ( n , m ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT ans += ( ( n // z ) * m ) % m ; NEW_LINE DEDENT ans = mod ; NEW_LINE if ( ans == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT ans = mod ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) ; NEW_LINE n = 4 ; NEW_LINE m = 7 ; NEW_LINE print ( countWays ( n , m ) ) ; NEW_LINE DEDENT
def smallestIndexsum ( arr , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 and arr [ i ] % 2 == 1 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 6 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestIndexsum ( arr , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT t = input ( ) . split ( ) NEW_LINE m = int ( t [ 0 ] ) NEW_LINE m = int ( t [ 1 ] ) NEW_LINE if m < 0 : NEW_LINE INDENT print ( m - m ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m - m * 60 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
s = input ( ) NEW_LINE print ( sum ( [ ( i == ' Q ' and i == ' Q ' ) for i in range ( len ( s ) - 1 ) if s [ i ] == ' Q ' ) ] ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE from collections import defaultdict NEW_LINE from heapq import heappop , heappush NEW_LINE from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE from copy import deepcopy NEW_LINE from functools import lru_cache NEW_LINE @ lru_cache ( None ) NEW_LINE def LI ( ) : return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in input ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in input ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT n , k = LI ( ) NEW_LINE a = LI ( ) NEW_LINE l = a [ 0 ] NEW_LINE r = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= k : NEW_LINE INDENT l = i + 1 NEW_LINE r = i + 1 NEW_LINE if l < r : NEW_LINE INDENT r = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = i + 1 NEW_LINE DEDENT DEDENT l = 0 NEW_LINE r = n - 1 NEW_LINE while r - l > r : NEW_LINE INDENT if a [ r ] <= k : NEW_LINE INDENT l = r + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = r NEW_LINE DEDENT DEDENT l = r - 1 NEW_LINE DEDENT print ( l ) NEW_LINE return NEW_LINE DEDENT if __name__ == ' _ _ main
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += ( s // i ) * i NEW_LINE DEDENT print ( c ) NEW_LINE
import math as mt NEW_LINE def multiply ( x ) : NEW_LINE INDENT carry = 0 NEW_LINE size = len ( x ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT res = carry + x [ i ] * x [ i ] NEW_LINE carry = res // 10 NEW_LINE carry = res // 10 NEW_LINE DEDENT while ( carry != 0 ) : NEW_LINE INDENT v . append ( carry % 10 ) NEW_LINE carry = res // 10 NEW_LINE carry = res // 10 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 1 , size + 1 ) : NEW_LINE INDENT multiply ( i ) NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT multiply ( i , i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 1000 NEW_LINE print ( findSumDigits ( n ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE u = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE u [ i ] = s . count ( " U " ) NEW_LINE u [ i ] = s . count ( " U " ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT u [ i ] = s . count ( " U " ) NEW_LINE if u [ i ] == u [ i ] : NEW_LINE INDENT u [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT u [ i ] = u [ i ] + 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if u [ i ] == " R " : NEW_LINE INDENT u [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT u [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if u [ i ] == " R " : NEW_LINE INDENT u [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT u [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if u [ i ] == " R " : NEW_LINE INDENT u [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if u [ i ] == " R " : NEW_LINE INDENT u [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if u [ i ] == " R " : NEW_LINE INDENT u [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if u [ i ] == " R " : NEW_LINE INDENT u [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if u [ i ] ==
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE l = [ 0 ] * n NEW_LINE r = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r , w = map ( int , input ( ) . split ( ) ) NEW_LINE if l > r : NEW_LINE INDENT l [ r ] = w NEW_LINE DEDENT else : NEW_LINE INDENT l [ r ] = w NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT l , r , w = map ( int , input ( ) . split ( ) ) NEW_LINE if l == r : NEW_LINE INDENT print ( " ▁ " . join ( map ( str , l ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " . join ( map ( str , l ) ) ) ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mx = max ( l ) NEW_LINE mx = max ( l ) NEW_LINE mx = max ( l ) NEW_LINE mx = mx - mx NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( mx < l [ i ] ) : NEW_LINE INDENT mx = max ( mx , l [ i ] - mx ) NEW_LINE DEDENT else : NEW_LINE INDENT mx = max ( mx , l [ i ] - mx ) NEW_LINE DEDENT DEDENT print ( * mx ) NEW_LINE
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return pell ( 2 * pell ( n - 2 ) + pell ( n - 2 ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( pell ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE even = [ ] NEW_LINE for i in range ( 1 , n ** 2 + 1 ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT even . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT even . append ( i ) NEW_LINE DEDENT DEDENT odd = n * n // 2 NEW_LINE even = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT odd . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT even . append ( i ) NEW_LINE DEDENT DEDENT odd . append ( n // 2 ) NEW_LINE even . append ( n // 2 ) NEW_LINE odd . append ( n // 2 ) NEW_LINE for i in range ( 1 , odd + 1 ) : NEW_LINE INDENT even . append ( n // 2 ) NEW_LINE DEDENT odd . append ( n // 2 ) NEW_LINE odd . append ( n // 2 ) NEW_LINE print ( * even ) NEW_LINE
def printSmall ( arr , a , n ) : NEW_LINE INDENT copy_arr = [ 0 for i in range ( 0 , a ) ] NEW_LINE copy_arr . sort ( ) NEW_LINE for i in range ( 0 , a ) : NEW_LINE INDENT if ( bin_arr [ i ] > - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 7 , 3 , 7 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE printSmall ( arr , a , n ) NEW_LINE
def countNumbers ( n ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT count += ( pow ( 2 , k ) ) NEW_LINE k += 1 NEW_LINE DEDENT k += 1 NEW_LINE n = k + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 11 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > m : NEW_LINE INDENT m = a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m = a [ i ] NEW_LINE DEDENT DEDENT print ( m * k ) NEW_LINE
MAX = - 99999 NEW_LINE def __init__ ( x ) : NEW_LINE INDENT c = 0 NEW_LINE x = [ ] NEW_LINE for i in range ( 60 ) : NEW_LINE INDENT if ( ( x >> i ) & 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def dfs ( node , parent ) : NEW_LINE INDENT a = __init__ ( ) NEW_LINE if ( maximum < a [ node ] ) : NEW_LINE INDENT maximum = a NEW_LINE DEDENT elif ( maximum < a [ node ] ) : NEW_LINE INDENT maximum = a NEW_LINE DEDENT for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT if ( maximum < a [ node ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( graph [ node ] [ i ] , node ) NEW_LINE DEDENT for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT if ( maximum == a [ node [ i ] ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( graph [ node ] [ i ] , node ) NEW_LINE DEDENT DEDENT x = 15 NEW_LINE weight = [ [ 0 ] * 10 for i in range ( 100 ) ] NEW_LINE weight [ 1 ] = 6 NEW_LINE weight [ 2 ] = 6 NEW_LINE dfs ( 1 , 1 , 1 ) NEW_LINE print ( ans ) NEW_LINE
MAX = 26 ; NEW_LINE def updateFreq ( str , freq ) : NEW_LINE INDENT len1 = len ( strq ) ; NEW_LINE for i in range ( 0 , len1 ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT DEDENT def maxCount ( str , pq ) : NEW_LINE INDENT strq = [ 0 ] * MAX ; NEW_LINE updateFreqFreq = [ 0 ] * MAX ; NEW_LINE pqFreq [ 0 ] = 0 ; NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT if ( pqFreq [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( pqFreq [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT ans = min ( strq [ i ] // pq [ i ] ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " ; NEW_LINE pq = " geeksforgeeks " ; NEW_LINE print ( maxCount ( str ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( a [ i ] | b [ i ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
from sys import stdin , stdout NEW_LINE def main ( ) : NEW_LINE INDENT n , l , r , q , r = map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE W = [ int ( stdin . readline ( ) ) for i in range ( n ) ] NEW_LINE W = [ int ( stdin . readline ( ) ) for i in range ( n ) ] NEW_LINE W . sort ( ) NEW_LINE l , r , c , r = map ( int , stdin . readline ( ) . split ( ) ) NEW_LINE S = sum ( W ) NEW_LINE S = sum ( W ) NEW_LINE r -= l NEW_LINE S . reverse ( ) NEW_LINE ans = min ( ans , r * q + r * r + r - l + r - l + 1 ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def wasteWater ( V , M , N ) : NEW_LINE INDENT waste_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_min_
def maxSubStr ( str , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count0 = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT if ( count0 != count1 ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT DEDENT if ( count0 != count1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return cnt0 NEW_LINE DEDENT str = "011101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE x = max ( a , b ) NEW_LINE y = min ( b , c ) NEW_LINE z = min ( b , c ) NEW_LINE print ( x , y ) NEW_LINE
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , s ) : NEW_LINE INDENT sum += n NEW_LINE if ( sum == s ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT s = 15 NEW_LINE n = findS ( s ) NEW_LINE if ( n == - 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
import sys NEW_LINE def maximumAbsative ( arr , n ) : NEW_LINE INDENT mx = - sys . maxsize ; NEW_LINE mx = - - - 99999 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 and arr [ i - 1 ] != - 1 and arr [ i - 1 ] != - 1 ) : NEW_LINE INDENT mx = min ( mx , arr [ i - 1 ] ) ; NEW_LINE mx = max ( mx , arr [ i - 1 ] ) ; NEW_LINE DEDENT if ( i < n - 1 and arr [ i ] != - 1 ) : NEW_LINE INDENT mx = mx ; NEW_LINE mx = max ( mx , arr [ i + 1 ] ) ; NEW_LINE DEDENT DEDENT maximum_diff = ( mx + mx ) / 2 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) ; NEW_LINE if ( diff > max_diff ) : NEW_LINE INDENT mx = diff ; NEW_LINE DEDENT DEDENT maximum_diff = ( mx + mx ) / 2 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) ; NEW_LINE if ( diff > max_diff ) : NEW_LINE INDENT maximum_diff = diff NEW_LINE DEDENT DEDENT return maximum_diff ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 1 , - 1 , 11 , - 1 , - 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maximumAbsative ( arr , n ) ) ; NEW_LINE DEDENT
MOD = 1000000007 NEW_LINE def countStrings ( N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 9 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ j ] ) % MOD NEW_LINE dp [ i ] [ j ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) % MOD NEW_LINE dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ 1 ] ) % MOD NEW_LINE dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ] ) % MOD NEW_LINE dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE return ( dp [ i ] [ j ] + dp [ i ] [ j ] ) % MOD NEW_LINE DEDENT DEDENT N = 3 NEW_LINE print ( countStrings ( N ) ) NEW_LINE
def longest_subseq ( n , k , s ) : NEW_LINE INDENT dp = [ 0 ] * ( n ) NEW_LINE max_length = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE lower = max ( 0 , curr - k ) NEW_LINE for j in range ( lower , upper + k ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , max_length [ j ] + 1 ) NEW_LINE DEDENT max_length [ i ] = max ( dp [ i ] , max_length [ curr ] + 1 ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( dp [ i ] ) : NEW_LINE INDENT ans = max ( i , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE n = len ( s ) NEW_LINE k = 3 NEW_LINE print ( longest_subseq ( n , k , s ) ) NEW_LINE DEDENT
def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT l = 2147483648 NEW_LINE mx = - 9999999999999 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT l = l NEW_LINE DEDENT mx = max ( mx , lx ) NEW_LINE mx = max ( mx , len ( mx ) ) NEW_LINE DEDENT return mx NEW_LINE DEDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE
def minimumSubarrays ( ar , n ) : NEW_LINE INDENT se = [ ] ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( se [ i ] in se ) : NEW_LINE INDENT se . append ( ar [ i ] ) ; NEW_LINE se . append ( ar [ i ] ) ; NEW_LINE se . append ( ar [ i ] ) ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 3 , 4 , 4 , 4 ] ; NEW_LINE n = len ( ar ) ; NEW_LINE print ( minimumSubarrays ( ar , n ) ) ; NEW_LINE
def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = int ( s / 10 ) NEW_LINE freq [ r ] += 1 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor_sum = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor_sum = xor_sum ^ freq [ i ] NEW_LINE if ( xor_sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = 12223333 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += l [ i ] NEW_LINE if s <= m : NEW_LINE INDENT k += s // m NEW_LINE DEDENT else : NEW_LINE INDENT s = s - ( l [ i ] / m ) NEW_LINE DEDENT DEDENT print ( k , end = ' ▁ ' ) NEW_LINE print ( ) NEW_LINE
MAXN = 1000005 NEW_LINE even = [ 0 for i in range ( MAXN ) ] NEW_LINE even = [ 0 for i in range ( MAXN ) ] NEW_LINE def precompute ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 1 : NEW_LINE INDENT even [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT even [ i ] = even [ i ] + even [ i - 1 ] NEW_LINE odd [ i ] = even [ i - 1 ] + even [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT even [ i ] = even [ i - 1 ] + even [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT even [ i ] = even [ i - 1 ] + even [ i - 1 ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT L = even [ i ] [ 0 ] NEW_LINE R = q [ i ] [ 1 ] NEW_LINE if ( isOdd ( L , R - L + 1 ) ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 1 , 5 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE q = [ 0 , 2 , 7 , 6 ] NEW_LINE q = [ 1 , 2 , 7 , 6 ] NEW_LINE performQueries ( a , n , q , m ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( n % 7 == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( ( 1 , n // 7 ) + 1 ) : NEW_LINE INDENT if ( n % 7 == 0 ) : NEW_LINE INDENT print ( i , i , i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , n // 7 ) : NEW_LINE INDENT if ( ( n - i ) % 7 == 0 ) : NEW_LINE INDENT print ( i , i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
a , b , t1 , t2 = map ( int , input ( ) . split ( ) ) NEW_LINE t2 = ( 60 * a + b ) + ( 60 * a ) + ( 60 * b ) + ( 60 * a ) + ( 60 * b ) + t2 NEW_LINE print ( t1 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE c = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != a [ i ] : NEW_LINE INDENT b [ i ] = b [ i ] NEW_LINE c [ i ] = c [ i ] NEW_LINE DEDENT DEDENT if b [ 0 ] == c [ 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def times ( steps , n ) : NEW_LINE INDENT current_level = 0 NEW_LINE current_level = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT previous_level = current_level + steps [ i ] NEW_LINE if ( previous_level < 0 and current_level >= 0 and current_level >= 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT steps = [ 1 , - 1 , 0 , 0 , 1 , 1 , - 3 , - 3 ] NEW_LINE n = len ( steps ) NEW_LINE print ( times ( steps , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT d , m = map ( int , input ( ) . split ( ) ) NEW_LINE time = d * 30 + m NEW_LINE if time <= time : NEW_LINE INDENT print ( time - time ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( time - time ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x . append ( p [ i ] ) NEW_LINE DEDENT x = sum ( x ) NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT print ( " Danik " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Danik " ) NEW_LINE DEDENT
def smallest ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = " " NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT DEDENT ans = s [ 0 : l - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abcda " NEW_LINE print ( smallest ( s ) ) NEW_LINE DEDENT
A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if A == B : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 ; NEW_LINE min_num = sys . maxsize ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] ; NEW_LINE if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) ; NEW_LINE found = True ; NEW_LINE DEDENT if ( sum > k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) ; NEW_LINE found = True ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE if ( findMinNumber ( arr , n , k ) ) : NEW_LINE INDENT return min_num ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 5 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 5 ; NEW_LINE print ( FindMinNumber ( arr , n , k ) ) ; NEW_LINE DEDENT
s = str ( input ( ) ) NEW_LINE print ( sum ( [ i for i in range ( len ( s ) ) if s [ i ] == '0' ] ) ) NEW_LINE
def nthPalindrome ( n , k ) : NEW_LINE INDENT temp = ( k // 2 - 1 ) ( ( k // 2 - 1 ) ) NEW_LINE palindrome = ( pow ( 10 , temp - 1 ) ) NEW_LINE print ( " % d ▁ % d " % ( palindrome ) ) NEW_LINE DEDENT n = 6 NEW_LINE k = 5 NEW_LINE print ( " th ▁ palindrome ▁ of ▁ palindrome ▁ = " , n , " th ▁ = " , k , " d " ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE
import sys NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE write = lambda x : sys . stdout . write ( x + " \n " ) NEW_LINE N , X = map ( int , input ( ) . split ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE X = X * X + X NEW_LINE X = X * X + X NEW_LINE X = X * X + X NEW_LINE ans = X * X + X NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT X = X - X - i NEW_LINE X = X - X - i NEW_LINE X = X - X - X NEW_LINE X = X - X * X + X NEW_LINE X = X - X * X + X NEW_LINE ans = min ( X , X ) NEW_LINE DEDENT print ( ans ) NEW_LINE
MAX = 10000 NEW_LINE hash = [ 0 for i in range ( MAX ) ] NEW_LINE def minOperations ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ i ] % arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT hash [ arr [ j ] ] = 0 NEW_LINE DEDENT res += 1 NEW_LINE DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 6 , 2 , 7 , 43 , 24 , 48 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( sum ( min ( a , b ) - min ( c , d ) + 1 ) // 2 ) NEW_LINE
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for d in itertools . count ( d ) : NEW_LINE INDENT n = str ( d ) NEW_LINE for n in itertools . count ( n ) : NEW_LINE INDENT n = n % 10 NEW_LINE if n == d : NEW_LINE INDENT ans *= n NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return int ( pow ( 2 , c ) ) NEW_LINE DEDENT def countOfOddPairs ( n ) : NEW_LINE INDENT c = countSetBits ( n ) NEW_LINE return pow ( 2 , c ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddPairs ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT if a > x and b > y : NEW_LINE INDENT print ( ( x - a ) * b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( x - b ) * a ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if b > y : NEW_LINE INDENT if b > x : NEW_LINE INDENT print ( ( y - 1 ) * b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( x - 1 ) * b ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if b > y : NEW_LINE INDENT if b > x : NEW_LINE INDENT print ( ( x - 1 ) * b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( x - 1 ) * b ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ( y * b ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def minSwaps ( arr , n ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = [ ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT cycle = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] [ 0 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT cycle += 1 NEW_LINE cycle += 1 NEW_LINE cycle += 1 NEW_LINE cycle += 1 NEW_LINE DEDENT if ( cycle ) : NEW_LINE INDENT ans += ( cycle - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT a = [ 1 , 5 , 4 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( minSwaps ( a , n ) ) NEW_LINE
N = 1000005 NEW_LINE prime = [ True ] * N NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT for j in range ( i * 2 , N , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT def sumTriunqprimes ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT num = i NEW_LINE while num % pow == 0 : NEW_LINE INDENT num //= 10 NEW_LINE break NEW_LINE DEDENT power *= 10 NEW_LINE power *= 10 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 25 NEW_LINE sieve ( ) NEW_LINE print ( sumTriq ( n ) ) NEW_LINE DEDENT
def findWights ( X ) : NEW_LINE INDENT sum = 0 ; power = 0 ; NEW_LINE power = 3 ; NEW_LINE number = 3 ; NEW_LINE while ( sum < X ) : NEW_LINE INDENT sum = number - 1 ; NEW_LINE power *= 3 ; NEW_LINE number += 1 ; NEW_LINE number *= 3 ; NEW_LINE number = number ; NEW_LINE DEDENT ans = 1 ; NEW_LINE for i in range ( 1 , power + 1 ) : NEW_LINE INDENT print ( ans , end = " ▁ " ) ; NEW_LINE ans = ans * 3 ; NEW_LINE DEDENT DEDENT X = 2 ; NEW_LINE findWights ( X ) ; NEW_LINE
def addToArrayForm ( A , K ) : NEW_LINE INDENT v = [ ] ; NEW_LINE ans = 0 ; NEW_LINE rem = 0 ; NEW_LINE i = 0 ; NEW_LINE for i in range ( len ( A ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( mid > 9 ) : NEW_LINE INDENT rem = A [ i ] + rem % 10 ; NEW_LINE if ( rem > 9 ) : NEW_LINE INDENT rem = 1 ; NEW_LINE v . append ( rem % 10 ) ; NEW_LINE rem = 0 ; NEW_LINE rem = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 ; NEW_LINE rem = 0 ; NEW_LINE DEDENT DEDENT while ( k > 0 ) : NEW_LINE INDENT rem = k % 10 ; NEW_LINE if ( rem / 10 > 0 ) : NEW_LINE INDENT rem = 1 ; NEW_LINE rem = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 ; NEW_LINE DEDENT DEDENT for j in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans [ j ] = rem ; NEW_LINE DEDENT for j in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans [ j ] = rem ; NEW_LINE DEDENT for j in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans [ j ] = rem ; NEW_LINE DEDENT for j in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans [ j ] = v [ j ] ; NEW_LINE DEDENT for j in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans [ j ] = v [ j ] ; NEW_LINE DEDENT for j in range ( len ( v ) - 1 , - 1 ) : NEW_LINE INDENT ans [ j ] = v [ j ] ; NEW_LINE DEDENT for j in range ( len ( v ) ) : NEW_LINE INDENT ans [ j ] = v [ j ] ; NEW_LINE DEDENT for j in range ( len
def printPaths ( input , R , C , C , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT d = str ( input ( ) ) NEW_LINE print ( " { } ▁ " . format ( i , " d " ) ) NEW_LINE DEDENT DEDENT def dfs ( input , res , i , j , c , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT res = r + i NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( input , r , i + 1 , k , C , C ) NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = [ " a " , " d " , " e " ] NEW_LINE R = len ( input ) NEW_LINE printPaths ( input , R , C , C ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lst [ i ] [ 0 ] == ' R ' : NEW_LINE INDENT ans . append ( lst [ i ] [ 1 ] ) NEW_LINE DEDENT elif lst [ i ] [ 1 ] == ' L ' : NEW_LINE INDENT ans . append ( lst [ i ] [ 1 ] ) NEW_LINE DEDENT elif lst [ i ] [ 1 ] == ' R ' : NEW_LINE INDENT ans . append ( lst [ i ] [ 0 ] ) NEW_LINE DEDENT elif lst [ i ] [ 1 ] == ' L ' : NEW_LINE INDENT ans . append ( lst [ i ] [ 1 ] ) NEW_LINE DEDENT elif lst [ i ] [ 1 ] == ' R ' : NEW_LINE INDENT ans . append ( lst [ i ] [ 0 ] ) NEW_LINE DEDENT elif lst [ i ] [ 1 ] == ' L ' : NEW_LINE INDENT ans . append ( lst [ i ] [ 0 ] ) NEW_LINE DEDENT elif lst [ i ] [ 1 ] == ' R ' : NEW_LINE INDENT ans . append ( lst [ i ] [ 0 ] ) NEW_LINE DEDENT elif lst [ i ] [ 1 ] == ' R ' : NEW_LINE INDENT ans . append ( lst [ i ] [ 0 ] ) NEW_LINE DEDENT elif lst [ i ] [ 1 ] == ' R ' : NEW_LINE INDENT ans . append ( lst [ i ] [ 0 ] ) NEW_LINE DEDENT elif lst [ i ] [ 1 ] == ' L ' : NEW_LINE INDENT ans . append ( lst [ i ] [ 0 ] ) NEW_LINE DEDENT elif lst [ i ] [ 1 ] == ' R ' : NEW_LINE INDENT ans . append ( lst [ i ] [ 0 ] ) NEW_LINE DEDENT DEDENT print ( * ans , sep = ' ' ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a + b + c == a + b : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def computeCompute ( x , y , n ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT print ( " Infinite " ) NEW_LINE return NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT print ( " - " ) NEW_LINE return NEW_LINE DEDENT if ( ( x > 0 and y < 0 ) or ( x > 0 ) ) : NEW_LINE INDENT print ( " - " , end = " " ) NEW_LINE x = x - ( y * d ) NEW_LINE y = y - ( y * d ) NEW_LINE if ( x == 0 ) and ( y > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT x = x - ( y * d ) NEW_LINE d = x - ( y * d ) NEW_LINE d = x - ( y * d ) NEW_LINE if ( x == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT x = x - ( y * d ) NEW_LINE d = x - ( y * d ) NEW_LINE d = x - ( y * d ) NEW_LINE if ( i == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT x = x - ( y * d ) NEW_LINE d = x NEW_LINE DEDENT print ( " " . join ( d ) ) NEW_LINE DEDENT x = 22 NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def minPerfectCube ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return gcd ( arr , n ) NEW_LINE DEDENT def minPerfectCube ( arr , n ) : NEW_LINE INDENT minPerfectCube = arr [ 0 ] NEW_LINE minPerfectCube = 0 NEW_LINE cnt = 0 NEW_LINE cnt = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT if ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= 2 NEW_LINE DEDENT i = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectCube NEW_LINE DEDENT arr = [ 10 , 125 , 42 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectCube ( arr , n ) ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printVLevelLevel ( root , s , s ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE q . append ( root . left ) NEW_LINE q . append ( root . right ) NEW_LINE q . append ( root . right ) NEW_LINE s = [ ] NEW_LINE q . append ( root . left ) NEW_LINE q . append ( root . right ) NEW_LINE s . append ( root . left ) NEW_LINE q . append ( root . right ) NEW_LINE s . append ( root . right ) NEW_LINE if ( not s . left ) : NEW_LINE INDENT q . append ( root . right ) NEW_LINE q . append ( ( root . right ) ) NEW_LINE q . append ( ( root . right ) ) NEW_LINE DEDENT if ( not q . left ) : NEW_LINE INDENT print ( q . data , " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " \n ▁ Level ▁ of ▁ Binary ▁ Binary ▁ Binary ▁ is " ) NEW_LINE DEDENT DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 2 ) NEW_LINE root . right . left = Node ( 3 ) NEW_LINE printVLevel ( root , root . left , end = " ▁ " ) NEW_LINE
def closetSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT if ( i == 1 or i == rows ) : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT DEDENT def closetSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT if ( j == 1 or j == rows ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( " \n " ) NEW_LINE DEDENT DEDENT rowSquare ( rows ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( ' aab ' ) NEW_LINE DEDENT elif n % 4 == 2 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' b ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' b ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' b ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' b ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' b ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' ab ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' b ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' ab ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' ab ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' b ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' ab ' ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( ' ab ' ) NEW_LINE DED
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( [ a , b ] ) NEW_LINE DEDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT if dp [ i - 1 ] > dp [ j ] + l [ i - 1 ] : NEW_LINE INDENT dp [ i ] = dp [ j - 1 ] + l [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ j ] + l [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] ) NEW_LINE
a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE if x < a + b : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def findLargest ( arr , n ) : NEW_LINE INDENT gcd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( arr [ i ] , gcd ) ; NEW_LINE DEDENT return gcd ; NEW_LINE DEDENT arr = [ 3 , 6 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findLargest ( arr , n ) ) ; NEW_LINE
def findWinner ( n ) : NEW_LINE INDENT if ( ( n - 1 ) % 6 == 0 ) : NEW_LINE INDENT print ( " Second ▁ number ▁ of ▁ 6 ▁ frog " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Second ▁ poker ▁ number " ) NEW_LINE DEDENT DEDENT n = 7 NEW_LINE findWinner ( n ) NEW_LINE
def addEdge ( v , w ) : NEW_LINE INDENT adj [ v ] . append ( [ w ] ) NEW_LINE for i in range ( v ) : NEW_LINE INDENT adj [ v ] . append ( i ) NEW_LINE DEDENT DEDENT def BFS ( v , w ) : NEW_LINE INDENT visited = [ False ] * v NEW_LINE visited [ v ] = True NEW_LINE q = [ False ] * v NEW_LINE q . append ( True ) NEW_LINE while len ( q ) != 0 : NEW_LINE INDENT for n in q [ v ] : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def BFS ( v ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE q . append ( v ) NEW_LINE visited [ v ] = True NEW_LINE q . append ( v ) NEW_LINE DEDENT def BFS ( v ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE visited [ v ] = True NEW_LINE q . append ( v ) NEW_LINE visited [ v ] = True NEW_LINE q . append ( v ) NEW_LINE DEDENT def BFS ( v ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE q . append ( v ) NEW_LINE q . append ( v ) NEW_LINE q . append ( v ) NEW_LINE DEDENT def BFS ( v ) : NEW_LINE INDENT visited [ v ] = False NEW_LINE q . append ( v ) NEW_LINE q . append ( v ) NEW_LINE q . append ( v ) NEW_LINE DEDENT g = [ [ 0 ] for i in range ( 2 ) ] NEW_LINE g . append ( GFS ( 2 ) ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE
def addEdge ( v , w ) : NEW_LINE INDENT adj [ v ] . append ( [ w ] ) NEW_LINE for i in range ( v ) : NEW_LINE INDENT adj [ v ] . append ( i ) NEW_LINE DEDENT DEDENT def BFS ( v , w ) : NEW_LINE INDENT visited = [ False ] * v NEW_LINE visited [ v ] = True NEW_LINE q = [ False ] * v NEW_LINE q . append ( True ) NEW_LINE while len ( q ) != 0 : NEW_LINE INDENT for n in q [ v ] : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def BFS ( v ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE q . append ( v ) NEW_LINE visited [ v ] = True NEW_LINE q . append ( v ) NEW_LINE DEDENT def BFS ( v ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE visited [ v ] = True NEW_LINE q . append ( v ) NEW_LINE visited [ v ] = True NEW_LINE q . append ( v ) NEW_LINE DEDENT def BFS ( v ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE q . append ( v ) NEW_LINE q . append ( v ) NEW_LINE q . append ( v ) NEW_LINE DEDENT def BFS ( v ) : NEW_LINE INDENT visited [ v ] = False NEW_LINE q . append ( v ) NEW_LINE q . append ( v ) NEW_LINE q . append ( v ) NEW_LINE DEDENT g = [ [ 0 ] for i in range ( 2 ) ] NEW_LINE g . append ( GFS ( 2 ) ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE g . append ( g ) NEW_LINE
def getElements ( a , arr , n ) : NEW_LINE INDENT elements = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 2 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE a = 5 NEW_LINE getElements ( arr , arr , n ) NEW_LINE DEDENT
import sys NEW_LINE def get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def main ( ) : NEW_LINE INDENT T = get_string ( ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N , R , S , S = get_string ( ) NEW_LINE S = get_string ( ) NEW_LINE if S == " P " : NEW_LINE INDENT S = S NEW_LINE DEDENT else : NEW_LINE INDENT S = S NEW_LINE DEDENT if S == " P " : NEW_LINE INDENT S = S NEW_LINE DEDENT if S == " L " : NEW_LINE INDENT S = S NEW_LINE DEDENT if S == " R " : NEW_LINE INDENT S = S NEW_LINE DEDENT else : NEW_LINE INDENT S = S NEW_LINE DEDENT if S == " R " : NEW_LINE INDENT S = S NEW_LINE DEDENT if S == " R "
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def printRepeating ( arr , size ) : NEW_LINE INDENT S = 0 NEW_LINE P = 1 NEW_LINE for i in range ( size - 2 ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * ( N + 1 ) // 2 NEW_LINE DEDENT S = S - N * ( S - 4 * ( N + 1 ) / 2 ) NEW_LINE X = ( S - N * ( N + 1 ) / 2 ) NEW_LINE D = ( D - N * ( S - D ) / 2 ) NEW_LINE print ( " The ▁ two ▁ repeating ▁ are ▁ repeating ▁ are : " ) NEW_LINE print ( " The ▁ two ▁ repeating ▁ are : " ) NEW_LINE print ( " The ▁ two ▁ repeating ▁ are ▁ : " ) NEW_LINE print ( " The ▁ two ▁ are ▁ : " ) NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE printRepeating ( arr , n ) NEW_LINE
import math NEW_LINE def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def prime ( n ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT a . append ( n ) NEW_LINE return a NEW_LINE DEDENT def prime ( n ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT a . append ( n ) NEW_LINE a . append ( a ) NEW_LINE return a NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = prime ( n ) NEW_LINE print ( a [ 0 ] ) NEW_LINE DEDENT
import math NEW_LINE def distance ( x , y ) : NEW_LINE INDENT distance = math . sqrt ( ( x - y ) ** 2 + ( y - x ) ** 2 ) NEW_LINE distance = distance / ( distance ) NEW_LINE return distance / distance NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE distance = [ ] NEW_LINE distance . append ( [ distance [ i ] , distance [ i ] , distance [ i ] ) ] ) NEW_LINE distance . append ( distance [ - 1 ] , distance [ - 2 ] ) NEW_LINE distance . append ( distance [ - 2 * i ] , distance [ - 2 * i ] ) NEW_LINE DEDENT distance = [ [ distance [ i ] ] for i in range ( n ) ] NEW_LINE distance . sort ( ) NEW_LINE distance . sort ( ) NEW_LINE distance = distance [ - 1 ] [ 0 ] NEW_LINE distance . sort ( ) NEW_LINE distance . append ( distance [ - 1 ] [ 0 ] , distance [ - 2 ] [ 0 ] ) NEW_LINE distance . append ( distance [ - 1 ] [ 0 ] ) NEW_LINE distance . sort ( ) NEW_LINE distance . append ( distance [ - 1 ] [ 0 ] ) NEW_LINE distance . append ( distance [ - 2 ] [ 0 ] ) NEW_LINE distance . append ( distance [ - 2 ] [ 0 ] ) NEW_LINE distance . append ( distance [ - 1 ] [ 0 ] ) NEW_LINE distance . append ( distance [ - 2 ] [ 0 ] ) NEW_LINE distance . append ( distance [ - 1 ] [ 1 ] ) NEW_LINE distance . append ( distance [ - 2 ] [ 0 ] ) NEW_LINE distance . append ( distance [ - 2 ] [ 0 ] ) NEW_LINE distance . append ( distance [ - 1 ] [ 0 ] ) NEW_LINE distance . append ( distance [ - 2 ] [ - distance [ - 2 ] [ 0 ] ] ) NEW_LINE print ( distance [ - 2 ] [ distance [ - 2 ] ] ) NEW_LINE
while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " # " : break NEW_LINE ans = 0 NEW_LINE for i in s : NEW_LINE INDENT if i == " # " : ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == " S " and s [ i + 1 ] == " S " ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif ( s [ i ] == " S " and s [ i + 1 ] == " S " ) : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif ( s [ i ] == " S " and s [ i + 1 ] == " S " ) : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT if ( x == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i - 1 ] > a [ i ] : NEW_LINE INDENT ans = max ( ans , a [ i - 1 ] * a [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def FindLCM ( a , b ) : NEW_LINE INDENT return ( a * b ) // ( a ) NEW_LINE DEDENT def FindLCM ( a , b , a ) : NEW_LINE INDENT return ( a * b ) // ( ( a - 1 ) // b ) NEW_LINE DEDENT def findDivisors ( m , n , a , b ) : NEW_LINE INDENT lcm = FindLCM ( a , b ) NEW_LINE a_divisors = findLCM ( a , b ) NEW_LINE b_divisors = findLCM ( a , b ) NEW_LINE return a_divisors - b_divisors - ( m - 1 ) // lcm ) NEW_LINE DEDENT m = 3 NEW_LINE n = 11 NEW_LINE a = 11 NEW_LINE b = 6 NEW_LINE print ( range ( findDivisors ( m , n , a , b ) ) ) NEW_LINE
s = input ( ) NEW_LINE if " ? " in s or " ? " in s or " abc " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s " in s or " in s or " in s or " in s " in s or " in s or " in s or " in s or " in s " in s " in s or " in s " in s " in s " in s " in s " in s " in s " in s " in s " in s " in s " in s " in s " in s " in s " in s " in s " in s " ? " ) NEW_LINE print ( s ) NEW
import sys NEW_LINE def smallestKFreq ( a , n , k ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE DEDENT res = sys . maxsize NEW_LINE s = dict ( ) NEW_LINE for i in m : NEW_LINE INDENT if m [ i ] == k : NEW_LINE INDENT res = min ( res , temp ) NEW_LINE DEDENT DEDENT return res if ( res != float ( ' inf ' ) ) else - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 1 , 1 , 3 ] NEW_LINE k = 2 NEW_LINE print ( smallestKFreq ( arr , n , k ) ) NEW_LINE
def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = 64 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] < c ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabbbbddee " NEW_LINE if ( areVowels ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
from itertools import permutations NEW_LINE def func ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT a = [ 0 ] * ( n + 1 ) NEW_LINE b = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT a [ i ] = b [ i - a [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = a [ i - a [ i - a [ i ] ] NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ func ( n ) for n in range ( 1 , n + 1 ) ] NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n ) ] NEW_LINE dp [ 0 ] = func ( n ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - a [ i ] , dp [ i - a [ i - a [ i - a [ i ] ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - a [ i - a [ i - a [ i ] ] , dp [ i - a [ i - a [ i - a [ i - a [ i - a [ i - a [ i - a [ i - a [ i ] ] ] ] ] ) ) NEW_LINE DEDENT DEDENT print ( * dp [ n ] ) NEW_LINE DEDENT
def countOfNumbers ( str ) : NEW_LINE INDENT digit = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) ) or ( str [ i ] <= ' z ' ) ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT DEDENT return digit NEW_LINE DEDENT def countOfNumbers ( str ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] >= '0' and str [ i ] <= '9' ) : NEW_LINE INDENT number += 1 NEW_LINE DEDENT DEDENT return number NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeKS " NEW_LINE check = 0 NEW_LINE checkOfNumbers ( str ) NEW_LINE if ( countOfNumbers ( str ) == countOfNumbers ( str ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT try : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , X = map ( int , input ( ) . split ( ) ) NEW_LINE if ( X == 1 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( X == 2 * N - 1 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
MAX = 100001 NEW_LINE perfectDivisors = [ 0 ] * ( MAX ) ; NEW_LINE def precompute ( ) : NEW_LINE INDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT perfectDivisors [ j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT return perfectDivisors [ n ] ; NEW_LINE DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT return perfectDivisors [ n ] ; NEW_LINE DEDENT precomputeCount ( ) ; NEW_LINE n = 16 ; NEW_LINE print ( " Total ▁ perfect ▁ perfect ▁ divisors ▁ = " , n , " = countPerfectDivisors ( n ) ) ; NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( b ) * m ) NEW_LINE
n , t , e = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = e - e NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if t [ i ] * t [ i ] <= t [ i ] : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ans : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
def cal_dist ( h , r ) : NEW_LINE INDENT subt = ( h * r ) / 360 NEW_LINE_LINE_rem = ( ( subt - t ) * 60 ) / 360 NEW_LINE print ( int ( ( subt ) + " : " , int ( subt ) ) ) NEW_LINE DEDENT h = 20 NEW_LINE r = 150 NEW_LINE cal_dist ( h , r ) NEW_LINE
import math NEW_LINE def printRoots ( n ) : NEW_LINE INDENT theta = math . pi / n NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT real = math . sqrt ( k * theta ) NEW_LINE print ( " ▁ + + " ▁ - ▁ " , end = " ▁ " ) NEW_LINE if ( int ( imag ) >= 0 ) : NEW_LINE INDENT print ( " ▁ " , end = " ▁ " ) NEW_LINE DEDENT print ( " ▁ - ▁ " , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT n = 2 NEW_LINE printRoots ( n ) NEW_LINE
def findRect ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( " { } ▁ { } " , ▁ " , arr2 [ i ] , ▁ " , ▁ " , ▁ " , arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 4 , 5 , 6 ] NEW_LINE n = len ( arr1 ) NEW_LINE findRect ( arr1 , arr2 , n ) NEW_LINE
def no_of_ways ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count_left = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [ 0 ] ) : NEW_LINE INDENT count_left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ n - 1 ] ) : NEW_LINE INDENT count_left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ n - 1 ] ) : NEW_LINE INDENT return ( ( count_left + 1 ) * ( count_right + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( count_left + count_right + 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( no_of_ways ( s ) ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT def SumKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT c += arr [ i ] NEW_LINE if c % k == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE n = len ( S ) NEW_LINE SumKthPrimes ( arr , n , k ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT def SieveOfEratosthenes ( ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE solve ( arr , n , k ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE prime [ 0 ] = True NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = True NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def productOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == False : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT product *= arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( product ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n , k = 5 , 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 ] NEW_LINE productOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT
def findAllSequences ( diff , start , end ) : NEW_LINE INDENT if ( diff > ( end - start + 1 ) // 2 ) : NEW_LINE INDENT if ( diff > ( end - start + 1 ) // 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT if diff == 0 : NEW_LINE INDENT return NEW_LINE DEDENT return NEW_LINE DEDENT if ( diff > end ) : NEW_LINE INDENT if ( diff == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT return " " NEW_LINE DEDENT if ( diff > end ) : NEW_LINE INDENT if ( diff == 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT n = 2 NEW_LINE findAllSequences ( diff , 0 , n - 1 ) NEW_LINE
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= h : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = " ▁ > ▁ " ) NEW_LINE DEDENT DEDENT def addList ( node ) : NEW_LINE INDENT if ( node != None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + addList ( node . data ) NEW_LINE DEDENT def addList ( node ) : NEW_LINE INDENT cnt = node . data NEW_LINE if ( node != None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def addList ( node ) : NEW_LINE INDENT cnt = node . data NEW_LINE if ( cnt != None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( node != None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( node != None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = node - m NEW_LINE preList ( node . data ) NEW_LINE preList ( i ) NEW_LINE preList ( i ) NEW_LINE preList ( i ) NEW_LINE preList ( preList ( i ) ) NEW_LINE preList ( preList ( i ) ) NEW_LINE preList ( preList ( i ) NEW_LINE preList ( preList ( i ) ) NEW_LINE preList ( preList ( preList ( i ) ) NEW_LINE DEDENT def addList ( h , m ) : NEW_LINE INDENT i = 0 NEW_LINE preList ( h ) NEW_LINE preList ( i ) NEW_LINE preList ( preList ( i ) ) NEW_LINE preList ( preList ( i ) ) NEW_LINE preList ( preList ( preList ( i ) ) NEW_LINE preList ( preList ( preList ( i ) ) NEW_LINE preList ( preList ( i ) ) NEW_LINE DEDENT def updateList ( h , m ) : NEW_LINE INDENT i = m NEW_LINE preList
def maxSubStrings ( s , k ) : NEW_LINE INDENT maxSubStrings = 0 NEW_LINE n = len ( s ) NEW_LINE for c in range ( 0 , 26 ) : NEW_LINE INDENT ch = ord ( ' a ' ) NEW_LINE curr = 0 NEW_LINE curr = 0 NEW_LINE for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT if s [ i ] != ch : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE while ( i < n and s [ i ] == ch ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i < n and s [ i ] == ch ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT maxSubStr = max ( maxSubStrings , curr ) NEW_LINE DEDENT return maxSubStr NEW_LINE DEDENT s = " aaabbabbabbaaabb " NEW_LINE k = 2 NEW_LINE print ( maxSubStrings ( s , k ) ) NEW_LINE
def ansQueries ( prequeries , prefent , l , r , q ) : NEW_LINE INDENT if ( r - l + 1 ) % 2 == 0 : NEW_LINE INDENT print ( prequeries [ r ] ^ prequeries [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prequeries [ r ] ^ prequeries [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prequeries [ r - 1 ] ^ prequeries [ l - 1 ] ) NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i < q ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT prequeries [ i ] = ( prequeries [ i - 1 ] ^ prequeries [ i - 1 ] ) NEW_LINE prefqueries [ i ] = prequeries [ i - 1 ] ^ prequeries [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prequeries [ i ] = prequeries [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE prefqueries [ i ] = prequeries [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE l = len ( arr ) NEW_LINE r = len ( l ) NEW_LINE q = len ( q ) NEW_LINE ansQueries ( arr , n , l , r , q , q ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] <= a [ i + 1 ] : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = sum ( a [ : k ] ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT ans += a [ n // 2 ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE YesNo = lambda b : bool ( [ print ( ' Yes ' ) ] if b else print ( ' No ' ) ) NEW_LINE YESNO = lambda b : bool ( [ print ( ' YES ' ) ] if b else print ( ' NO ' ) ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE def main ( ) : NEW_LINE INDENT N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT query = input ( ) . split ( ) NEW_LINE if query [ 0 ] == 0 : NEW_LINE INDENT if query [ 0 ] == 0 : NEW_LINE INDENT if len ( query [ 1 ] ) == 0 : NEW_LINE INDENT print ( query [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( query [ 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( query [ 0 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def findMin ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT mVal = arr [ i ] - mVal NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT mVal = arr [ i ] - mVal NEW_LINE DEDENT if ( k % 2 == 0 ) : NEW_LINE INDENT return mVal - mVal NEW_LINE DEDENT else : NEW_LINE INDENT return mVal - arr [ i ] NEW_LINE DEDENT DEDENT def removeMinArray ( arr , n ) : NEW_LINE INDENT moveMinVal = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mValVal = mVal - mVal NEW_LINE DEDENT if ( k % 2 == 0 ) : NEW_LINE INDENT moveMinVal = mVal - arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT moveMinVal = mVal - arr [ i ] NEW_LINE DEDENT DEDENT def removeMinArray ( arr , n ) : NEW_LINE INDENT moveMinVal = max ( arr , n ) NEW_LINE DEDENT if ( k % 2 == 0 ) : NEW_LINE INDENT moveMinVal = moveMin ( arr , n ) NEW_LINE DEDENT else : NEW_LINE INDENT moveMinVal = moveMin ( arr , n ) NEW_LINE DEDENT printArray ( arr , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 10 , 12 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE findMinArray ( arr , n ) NEW_LINE removeMinArray ( arr , n ) NEW_LINE DEDENT
import math as mt NEW_LINE def find_Centimeter ( v ) : NEW_LINE INDENT ans = [ 0 for i in range ( 2 ) ] NEW_LINE n = len ( v ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = v [ i ] [ 0 ] NEW_LINE y = v [ i ] [ 1 ] NEW_LINE a = v [ i ] [ 0 ] NEW_LINE DEDENT vecArea = ( x0 * y ) - ( x0 * y ) NEW_LINE vecArea = ( x0 * y ) - ( x0 * y ) NEW_LINE ans [ 0 ] = ( x0 * vecArea ) / ( 6 * vecArea ) NEW_LINE ans [ 1 ] = ( x0 * vecArea ) / ( 6 * vecArea ) NEW_LINE ans [ 0 ] = ( x0 * vecArea ) / ( 6 * vecArea ) NEW_LINE return ans NEW_LINE DEDENT v = [ 1 , 2 ] NEW_LINE ans = find_Centimeter ( v ) NEW_LINE ans = find_Centimeter ( v ) NEW_LINE print ( ans [ 0 ] , ans [ 1 ] , "3f " , ans [ 1 ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] == ' l ' : s = s [ 1 : ] NEW_LINE elif s [ 0 ] == ' r ' : s = s [ 1 : ] NEW_LINE else : s [ 1 ] = s [ 2 : ] NEW_LINE DEDENT print ( s ) NEW_LINE
def minOperations ( ar , k ) : NEW_LINE INDENT ar . sort ( ) NEW_LINE ans = ( ar [ k - 1 ] - ar [ i ] ) * ( k - 1 ) NEW_LINE for i in range ( k , len ( ar ) ) : NEW_LINE INDENT ans = ans + ( k - 1 ) * ( ar [ i - 1 ] - ar [ i - 1 ] ) * ( ar [ i ] - ar [ i - 1 ] ) NEW_LINE ans = min ( ans , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ar = [ 3 , 1 , 9 , 100 ] NEW_LINE n = len ( ar ) NEW_LINE k = 3 NEW_LINE print ( minOperations ( ar , k ) ) NEW_LINE DEDENT
def charCheck ( input_char ) : NEW_LINE INDENT if ( ( input_char >= 65 and input_char <= 122 ) ) : NEW_LINE INDENT print ( " ▁ ASCII ▁ " , end = " " ) NEW_LINE DEDENT elif ( ( char_char >= 65 and ord ( char_char ) <= 122 ) ) : NEW_LINE INDENT print ( " ▁ ASCII ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT charCheck ( char_char ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] not in d : d [ a [ i ] ] = 1 NEW_LINE else : d [ a [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if d [ a [ i ] ] not in d : d [ a [ i ] ] = 1 NEW_LINE else : d [ a [ i ] ] = 1 NEW_LINE DEDENT print ( * d ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d [ a - 1 ] . append ( b - 1 ) NEW_LINE d [ b - 1 ] . append ( a - 1 ) NEW_LINE DEDENT dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ i ] = min ( dp [ i ] [ i ] + dp [ i - 1 ] [ i ] , dp [ i - 1 ] [ i ] + dp [ i - 1 ] [ i ] ) NEW_LINE DEDENT print ( dp [ n ] [ n ] ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] < 0 : NEW_LINE INDENT b [ i ] = b [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = b [ i ] NEW_LINE DEDENT DEDENT print ( * b ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( l [ i ] [ j ] == i ) : NEW_LINE INDENT d [ l [ i ] [ j ] ] = i NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT if ( d [ i ] [ j ] == i ) : NEW_LINE INDENT ans . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for i in ans : NEW_LINE INDENT print ( i , j ) NEW_LINE DEDENT
def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT cntX = 0 NEW_LINE cntY = 0 NEW_LINE for j in range ( i , n - 1 ) : NEW_LINE INDENT if ( arr [ j ] == x ) : NEW_LINE INDENT cntX += 1 NEW_LINE DEDENT elif ( arr [ j ] == y ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT if ( cntX == cntY ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = s . count ( '0' ) NEW_LINE b = s . count ( '0' ) NEW_LINE print ( max ( b , a - b ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ a [ i ] ] += 1 NEW_LINE DEDENT if d [ a [ 0 ] ] % 2 == 0 : NEW_LINE INDENT print ( " Anton " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Danik " ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countCount = 98 ; NEW_LINE targetCount = ( 1 ) : NEW_LINE INDENT targetCount = 0 ; NEW_LINE totalCount = 0 ; NEW_LINE for i in range ( 0 , len ( target ) - 2 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ i ] ) == 0 : NEW_LINE INDENT for j in range ( i + 1 , len ( target ) - 1 ) : NEW_LINE INDENT if targetCount % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT totalCount += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Total ▁ number ▁ of ▁ triplet ▁ = ▁ " , countCount ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT target = 98 ; NEW_LINE arr = [ 1 , 31 , 3 , 1 , 3 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( " Total ▁ number ▁ of ▁ triplet ▁ found ▁ of ▁ triplet ▁ found ▁ found ▁ found ▁ found ▁ found : ▁ " , countCount ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 1 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , n * a [ 0 ] ) NEW_LINE print ( 1 , n * a [ 0 ] ) NEW_LINE print ( 1 , n * a [ 0 ] ) NEW_LINE print ( 1 , n * a [ 0 ] ) NEW_LINE print ( 1 , n * a [ 0 ] ) NEW_LINE DEDENT
def finalNum ( arr , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = result * ( result , arr [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 9 , 6 , 36 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( finalNum ( arr , n ) ) ; NEW_LINE DEDENT
N = 1000 NEW_LINE def lastElement ( a , n ) : NEW_LINE INDENT q = [ ] NEW_LINE v = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT v . append ( a [ i ] | a [ i + 1 ] ) NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT while ( len ( v ) > 1 ) : NEW_LINE INDENT v . append ( a [ 0 ] | a [ i + 1 ] ) NEW_LINE for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT if ( steps % 2 == 1 ) : NEW_LINE INDENT v [ steps [ i ] ] = v [ steps - 1 ] [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT v [ steps [ steps - 1 ] ] = v [ i ] ^ v [ steps - 1 ] [ i ] NEW_LINE DEDENT DEDENT return v [ 0 ] NEW_LINE DEDENT a = [ 1 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE value = 2 NEW_LINE a [ 0 ] = 2 NEW_LINE print ( lastElement ( a , n ) ) NEW_LINE
def number_of_circle ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 * n + 6 ) // 6 NEW_LINE DEDENT n = 2 NEW_LINE print ( number_of_circle ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_of_circle ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_of_circle ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_of_circle ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_of_circle ( n ) ) NEW_LINE n = 25 NEW_LINE
def count_gcd ( s , g ) : NEW_LINE INDENT if s [ 0 ] == g : NEW_LINE INDENT return s [ 1 ] == g - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return s [ 0 ] == g - 1 NEW_LINE DEDENT DEDENT s = input ( ) NEW_LINE g = 0 NEW_LINE g = 0 NEW_LINE g = 0 NEW_LINE g = 0 NEW_LINE g = 1 NEW_LINE g = 0 NEW_LINE g = 1 NEW_LINE while g != - 1 : NEW_LINE INDENT if s [ g ] == ' p ' : g += 1 NEW_LINE if g == g : NEW_LINE INDENT g += 1 NEW_LINE g += 1 NEW_LINE DEDENT else : NEW_LINE INDENT g += 1 NEW_LINE g += 1 NEW_LINE g += 1 NEW_LINE DEDENT DEDENT print ( count_gcd ( g , g ) ) NEW_LINE
def pattern ( N ) : NEW_LINE INDENT i , k , space = 0 , 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT if i != row : NEW_LINE INDENT for k in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT if j != space : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT for j in range ( i , i , 1 ) : NEW_LINE INDENT if j != space : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT DEDENT N = 6 NEW_LINE pattern ( N ) NEW_LINE
def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) // 2 + k NEW_LINE high = ( n + 1 ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n , k = 5 , 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 7 , 7 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE
class TreeNode : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . val = rootData NEW_LINE self . right = None NEW_LINE self . right = None NEW_LINE self . root = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . rootData = TreeNode ( rootData ) NEW_LINE self . root = TreeNode ( rootData ) NEW_LINE self . root = TreeNode ( rootData ) NEW_LINE return self . root NEW_LINE DEDENT def pathSum ( root , target , target ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return root NEW_LINE DEDENT return self . rootData NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE tree = TreeNode ( - 3 ) NEW_LINE tree = TreeNode ( - 3 ) NEW_LINE tree . left = TreeNode ( - 3 ) NEW_LINE treeSum = 8 NEW_LINE rootSum = TreeNode ( 2 ) NEW_LINE treeSum . append ( TreeSum ) NEW_LINE treeSum . append ( TreeSum ) NEW_LINE treeSum . append ( TreeSum ) NEW_LINE treeSum . append ( TreeSum ) NEW_LINE treeSum . append ( TreeSum ) NEW_LINE treeSum . append ( TreeSum ) NEW_LINE DEDENT print ( sSum ) NEW_LINE
def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x_size = len ( arr ) NEW_LINE getmax ( arr , x_size ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( N ) : NEW_LINE INDENT result = ' ' NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT c = str ( i ) NEW_LINE if c == '1' : NEW_LINE INDENT result += '0' NEW_LINE DEDENT else : NEW_LINE INDENT result += str ( c ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT N = input ( ) NEW_LINE print ( ' Case ▁ # { } : ▁ { } ' . format ( i , solve ( N ) ) ) NEW_LINE DEDENT
import math NEW_LINE def prime_number ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT prime_number ( n ) NEW_LINE prime_number = prime_number ( n ) NEW_LINE prime_number_list = prime_number ( n ) NEW_LINE prime_number_list = prime_number ( prime_number ) NEW_LINE prime_number_list = prime_number ( prime_number ) NEW_LINE prime_number_list = prime_number ( prime_number ) NEW_LINE prime_number_list = prime_number ( prime_number ) NEW_LINE prime_number_list . extend ( prime_number ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number_list ) NEW_LINE prime_number_list . extend ( prime_number
def maxOR ( arr , n ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) NEW_LINE DEDENT DEDENT return maxVal NEW_LINE DEDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxOR ( arr , n ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def numPersonelsInSences ( self , S , S ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if S [ i ] in S : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE S = " aAA " NEW_LINE out = numPersonPeople ( S , S ) NEW_LINE print ( out ) NEW_LINE DEDENT
MAX = 100 NEW_LINE graph = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE d = [ 0 for i in range ( MAX ) ] NEW_LINE d = [ 0 for i in range ( MAX ) ] NEW_LINE d [ 0 ] = 0 NEW_LINE d [ 0 ] = 0 NEW_LINE d [ 0 ] = 0 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( graph [ i ] [ j ] == 0 ) : NEW_LINE INDENT d [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT def maxCliques ( i , j ) : NEW_LINE INDENT max_qu = 0 NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT if ( is_quique ( i + 1 ) ) : NEW_LINE INDENT max_quiques [ j ] [ i ] = max ( max_quiques [ j ] , max_quiques ( j , i + 1 ) ) NEW_LINE d [ j ] [ i ] += 1 NEW_LINE d [ j ] [ i ] += 1 NEW_LINE d [ j ] [ i ] += 1 NEW_LINE d [ j ] [ i ] += 1 NEW_LINE d [ j ] [ i ] += 1 NEW_LINE d [ j ] [ i ] += 1 NEW_LINE d [ j ] [ i ] += 1 NEW_LINE d [ j ] [ i ] [ j ] += 1 NEW_LINE d [ j ] [ i ] += 1 NEW_LINE d [ j ] [ i ] += 1 NEW_LINE d [ j ] [ i ] ] += 1 NEW_LINE d [ j [ i ] [ 0 ] ] += 1 NEW_LINE d [ j [ i ] [ 1 ] ] += 1 NEW_LINE d [ j [ i ] [ 1 ] ] += 1 NEW_LINE d [ j [ i ] [ 1 ] ] += 1 NEW_LINE d [ j [ i ] [ 1 ] ] += 1 NEW_LINE d [ j [ i ] [ 1 ] += 1 NEW_LINE d [ j [ i ] [ 1 ] ] [ d [ i ] ] += 1 NEW_LINE d [ j [ i ] [ 1
import math NEW_LINE def setBitNumber ( n ) : NEW_LINE INDENT k = int ( math . log ( n ) / math . log ( 2 ) ) NEW_LINE return int ( pow ( 2 , k ) ) NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE
m , s , f = map ( int , input ( ) . split ( ) ) NEW_LINE d = { } NEW_LINE for i in range ( m ) : NEW_LINE INDENT k , s = map ( int , input ( ) . split ( ) ) NEW_LINE d [ k ] = s NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT k , f = map ( int , input ( ) . split ( ) ) NEW_LINE d [ k ] . append ( k ) NEW_LINE DEDENT d [ k ] = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT k , v = map ( int , input ( ) . split ( ) ) NEW_LINE if k >= v : NEW_LINE INDENT d [ k ] = v NEW_LINE DEDENT else : NEW_LINE INDENT d [ k ] = v NEW_LINE DEDENT DEDENT ans = - 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if d [ i ] [ 0 ] < v : NEW_LINE INDENT ans = max ( ans , d [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def subsetPairWithK ( arr , N , K ) : NEW_LINE INDENT f = [ 0 ] * K NEW_LINE for i in range ( N ) : NEW_LINE INDENT f [ arr [ i ] % K ] += 1 NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT f [ K // 2 ] = min ( f [ K // 2 ] , 1 ) NEW_LINE DEDENT res = min ( f [ 0 ] , 1 ) NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT res += max ( f [ i ] , f [ K - i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 3 , 7 , 9 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( subsetPairWithK ( arr , N , K ) ) NEW_LINE
def f ( n , k ) : NEW_LINE INDENT return 9 * ( 10 ** ( n - 1 ) - 1 ) // k NEW_LINE DEDENT def f ( n , k ) : NEW_LINE INDENT return n * 9 + 9 * ( 10 ** ( n - 1 ) - k ) // k NEW_LINE DEDENT def f ( n , k , s ) : NEW_LINE INDENT return n * ( 10 ** ( n - 1 ) - k ) // k NEW_LINE DEDENT n , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE print ( f ( n , s ) ) NEW_LINE
def printRoots ( a , b , c ) : NEW_LINE INDENT print ( 1 , " , ▁ " , ▁ " , end = " " ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE c = - 5 NEW_LINE printRoots ( a , b , c ) NEW_LINE
from bisect import bisect_left , bisect_right , insort NEW_LINE memo = { } NEW_LINE def dp ( pos , fl , sr , bin , bin ) : NEW_LINE INDENT if ( pos == len ( bin ) ) : NEW_LINE INDENT return memo [ pos ] [ pos ] NEW_LINE DEDENT val = 0 NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT return val NEW_LINE DEDENT val = 0 NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT val = val + dp ( pos + 1 , fl ) NEW_LINE DEDENT elif ( val == '0' ) : NEW_LINE INDENT val = val + dp ( pos + 1 , fl ) NEW_LINE DEDENT elif ( val == '0' ) : NEW_LINE INDENT val = val + dp ( pos + 1 , fl ) NEW_LINE DEDENT elif ( val == '1' ) : NEW_LINE INDENT val += dp ( pos + 1 , fl ) NEW_LINE DEDENT else : NEW_LINE INDENT val += dp ( pos + 1 , fl ) NEW_LINE DEDENT return val NEW_LINE DEDENT def findIntegers ( n ) : NEW_LINE INDENT bin = " " NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT bin += "1" NEW_LINE n //= 2 NEW_LINE DEDENT else : NEW_LINE INDENT bin += "1" NEW_LINE n //= 2 NEW_LINE DEDENT DEDENT return bin ( bin ) [ n // 2 ] [ n // 2 ] NEW_LINE DEDENT def findIntegers ( n ) : NEW_LINE INDENT bin = " " NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT for j in range ( 0 , 2 ) : NEW_LINE INDENT bin = bin ( i ) NEW_LINE for j in range ( 0 , 2 ) : NEW_LINE INDENT bin [ j ] = bin [ j ] NEW_LINE DEDENT DEDENT return bin ( bin [ i ] [ j ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " :
N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if mat [ 0 ] [ 0 ] == 1 : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ 0 ] [ i ] == 1 : NEW_LINE INDENT dp [ 0 ] [ i ] = ( dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = ( dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ 0 ] == 1 : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ i - 1 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ j ] == 1 : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT mat = [ [ 1 , 1 , 1 , 1 ] , [ 0 , 1 , 1 , 1 ] , [ 1 , 0 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE print ( MaximumDecimalValue ( mat , 4 ) ) NEW_LINE
def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr < maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def findFibonacciPairPairPair ( n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE createHash ( hash , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i in hash . keys ( ) ) : NEW_LINE INDENT print ( i , " , ▁ " , n - i ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE findFibonacciPair ( N ) NEW_LINE DEDENT
def countgroups ( a , n ) : NEW_LINE INDENT xs = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT xs = xs ^ a [ i ] ; NEW_LINE DEDENT if ( xs == 0 ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT a = [ 1 , 2 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( countgroups ( a , n ) ) ; NEW_LINE
import sys NEW_LINE def maxLength ( s , n ) : NEW_LINE INDENT ans = - - - float ( ' inf ' ) NEW_LINE A = [ ] NEW_LINE L = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ord ( s [ j ] ) - ord ( ' a ' ) ) == i : NEW_LINE INDENT count += 1 NEW_LINE DEDENT freq . append ( count ) NEW_LINE DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( ord ( s [ j ] ) - ord ( ' a ' ) ) == i ) : NEW_LINE INDENT count += 1 NEW_LINE R . append ( 2 * freq [ j ] ) NEW_LINE DEDENT DEDENT max_len = sys . maxsize NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( A [ j ] <= R [ j - 1 ] ) : NEW_LINE INDENT max_len = ( 2 * freq [ j ] ) - j NEW_LINE DEDENT else : NEW_LINE INDENT l = j - 1 NEW_LINE r = j - 1 NEW_LINE DEDENT DEDENT ans = max ( ans , max_len ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ababbbabbbccb " NEW_LINE n = len ( s ) NEW_LINE print ( maxLength ( s , n ) ) NEW_LINE DEDENT
from collections import deque NEW_LINE N = 100005 NEW_LINE G = [ ] NEW_LINE def add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] . append ( y ) NEW_LINE gr [ y ] . append ( x ) NEW_LINE DEDENT def dfs ( x , y ) : NEW_LINE INDENT gr = [ ] NEW_LINE gr = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT gr [ i ] . append ( y ) NEW_LINE DEDENT DEDENT def dfs ( x , y ) : NEW_LINE INDENT color = deque ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( color [ i ] == - 1 ) : NEW_LINE INDENT dfs ( i , col ^ 1 ) NEW_LINE DEDENT DEDENT flip = True NEW_LINE dfs ( 1 , 1 ) NEW_LINE if ( flip [ x ] == 0 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( color [ i ] == 0 ) : NEW_LINE INDENT dfs ( i , col ^ 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT if ( color [ i ] == 0 ) : NEW_LINE INDENT dfs ( i , col ^ 1 ) NEW_LINE DEDENT DEDENT DEDENT def dfs_Edge ( n , m ) : NEW_LINE INDENT graph = [ ] NEW_LINE dfs ( 1 , 1 ) NEW_LINE if ( not visit [ i ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT dfs ( 1 , 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE m = 3 NEW_LINE dfs ( 1 , 2 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT DEDENT b . sort ( ) NEW_LINE for i in b : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT O , N , G = map ( int , input ( ) . split ( ) ) NEW_LINE X = sum ( O ) NEW_LINE print ( X - N * X ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def isPrime ( k ) : NEW_LINE INDENT if ( k <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def check ( num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def check ( num , b , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT ans = check ( i , k ) NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT a = 2019 NEW_LINE b = 6200 NEW_LINE k = 28200 NEW_LINE print ( findCount ( a , b , k ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n < k : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' ' NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT ans += ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT ans += ' a ' NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
maxn = 16 ; NEW_LINE arr = [ 0 for i in range ( maxn ) ] ; NEW_LINE def precompute ( ) : NEW_LINE INDENT dp [ 0 ] = - 1 ; NEW_LINE for i in range ( 1 , maxn ) : NEW_LINE INDENT dp [ i ] = - 1 ; NEW_LINE if ( i >= j and dp [ i - j ] != - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - j ] , dp [ i - j ] + 1 ) ; NEW_LINE DEDENT DEDENT return dp [ n - maxn ] ; NEW_LINE DEDENT def Maximum_Summoves ( dp , n ) : NEW_LINE INDENT if ( n < maxn ) : NEW_LINE INDENT return dp [ n ] ; NEW_LINE DEDENT else : NEW_LINE INDENT t = ( n - maxn ) // 4 ; NEW_LINE return tp [ n - 4 * t ] ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 ; NEW_LINE dp = precompute ( dp , n ) ; NEW_LINE print ( Maximum_Summoves ( dp , n ) ) ; NEW_LINE DEDENT
def countSquares ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) // 2 ) * ( 2 * n + 1 ) // 3 NEW_LINE DEDENT n = 3 NEW_LINE print ( " Count ▁ of ▁ squares ▁ is " , countSquares ( n ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ a [ i ] ] += a [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b [ i ] %= m NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] %= m NEW_LINE if b [ i ] >= 2 : NEW_LINE INDENT ans += b [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE def FindSubarray ( arr , n , k ) : NEW_LINE INDENT count_one = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_one += bin ( arr [ i ] ) NEW_LINE DEDENT sum = count_one [ 0 ] * ( n ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT if ( count_one [ 0 ] >= k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT ans = sys . maxsize - 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( k == count_one [ j ] ) : NEW_LINE INDENT ans += count_one [ i ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( sum + count_one [ i ] < k ) : NEW_LINE INDENT ans += count_one [ i ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( sum + count_one [ i ] == k ) : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( ans != float ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( FindSubarray ( arr , n , k ) ) NEW_LINE
def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( 2 * P * P * P * P ) / ( 100 * P * P - P * P ) NEW_LINE print ( " Loss ▁ = " , " % .3f " % ( L , " % .3f " % ( loss ) , " % .3f " % ( L ) ) ) NEW_LINE DEDENT SP = 13 NEW_LINE P = 13 NEW_LINE Loss ( SP , P ) NEW_LINE
n , m , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] == 1 : NEW_LINE INDENT t += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if l [ i ] == 2 : NEW_LINE INDENT t += 1 NEW_LINE DEDENT DEDENT DEDENT print ( min ( t , 2 * t ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 7 NEW_LINE ans = sum ( map ( int , str ( i ) ) for i in range ( 1 , LIMIT ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def next_number ( x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , LIMIT ) : NEW_LINE INDENT if x [ i ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE x = next_number ( x [ i ] ) NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def countStrings ( string , n ) : NEW_LINE INDENT distinct_char = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT distinct_char . add ( string [ i ] ) NEW_LINE DEDENT return fact ( distinct_char ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE n = len ( string ) NEW_LINE print ( countStrings ( string , n ) ) NEW_LINE DEDENT
M = 4 NEW_LINE N = 5 NEW_LINE def printCommonElements ( mat ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if mat [ mat [ i ] [ j ] ] == i : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if i == M - 1 : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if i == M - 1 : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT mat = [ [ 1 , 2 , 1 , 7 ] , [ 3 , 7 , 2 , 3 ] , [ 8 , 7 , 1 , 2 ] , [ 8 , 7 , 2 ] ] NEW_LINE printCommonElements ( mat ) NEW_LINE
n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE x . append ( a * b + b ) NEW_LINE y . append ( a * b ) NEW_LINE DEDENT x . sort ( ) NEW_LINE y . sort ( ) NEW_LINE if x [ 0 ] == y [ 0 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n , t = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , d = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( ( s - s ) / d ) NEW_LINE DEDENT l . sort ( ) NEW_LINE t = 1e9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] [ 0 ] < t : NEW_LINE INDENT t = l [ i ] [ 1 ] / d NEW_LINE t = t NEW_LINE DEDENT DEDENT print ( t + 1 ) NEW_LINE
def sum ( a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + a NEW_LINE a = a + d NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sum ( a , d , n ) ) NEW_LINE
def find3Numbers ( arr , n ) : NEW_LINE INDENT small = - 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( " No ▁ triplet ▁ exist " ) NEW_LINE return NEW_LINE DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT arr [ j ] = arr [ j ] NEW_LINE DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT arr [ j ] = arr [ j ] NEW_LINE DEDENT print ( " No ▁ of ▁ pair " , arr [ i ] , " ▁ " , arr [ i ] ) NEW_LINE DEDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE
def numberWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT print ( " Number ▁ of ▁ 3 ▁ divisors ▁ divisors ▁ : " , end = " " ) NEW_LINE for i in range ( 0 , int ( sqrt ( n ) ) ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT print ( i * i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT n = 9 NEW_LINE numberWith3Divisors ( n ) NEW_LINE
def findPairCount ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE rem = [ 0 ] * K NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem [ i ] = ( N - i ) // K + 1 NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ K // 2 ] - 1 ) ) // 2 NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K // 2 ] NEW_LINE DEDENT count += ( rem [ K // 2 ] * rem [ K // 2 ] ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * rem [ K // 2 ] ) // 2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 NEW_LINE K = 4 NEW_LINE print ( findPairCount ( N , K ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT L = sorted ( L ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT L . append ( int ( input ( ) ) ) NEW_LINE DEDENT L . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if L [ i ] > ans : NEW_LINE INDENT ans = L [ i ] - L [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ i ] : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import math as mt NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n < 6 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5.6 NEW_LINE fib = 5.6 NEW_LINE fib = 5.6 NEW_LINE while ( t < n ) : NEW_LINE INDENT fib = fib ( fib * PI ) NEW_LINE t = fib ( fib * PI ) NEW_LINE t = fib ( fib * PI ) NEW_LINE t = fib ( fib ) NEW_LINE DEDENT return fib NEW_LINE DEDENT n = 9 NEW_LINE print ( " th ▁ Fibonacci ▁ Number ▁ Number ▁ = ▁ " , fib ( n ) ) NEW_LINE
def kthSmallest ( n , k ) : NEW_LINE INDENT return ( 2 * k ) NEW_LINE DEDENT n = 8 NEW_LINE k = 4 NEW_LINE print ( kthSmallest ( n , k ) ) NEW_LINE
def printSumTriplet ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT substrSum = sum NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum += ( mat [ i ] [ j ] - mat [ i - k - 1 ] [ j ] ) NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum += ( mat [ i ] [ j ] - mat [ i - k - 1 ] [ i ] ) NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum += ( mat [ i ] [ j ] - mat [ i - k - 1 ] [ j ] ) NEW_LINE print ( sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 1 , 1 , 2 , 1 , 2 , 3 , 4 ] , [ 4 , 2 , 3 , 4 , 5 ] , [ 4 , 4 , 4 , 5 ] , [ 4 , 4 , 5 , 5 ] , [ 5 , 4 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumTriTriplet ( mat , k ) NEW_LINE
a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE if a * b == n : NEW_LINE INDENT print ( " No ▁ solution " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ solution " ) NEW_LINE DEDENT
def ncr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def totalWays ( X , Y , M , W ) : NEW_LINE INDENT return ( ncr ( M , X , Y ) * ncr ( W , Y ) ) NEW_LINE DEDENT X = 4 NEW_LINE Y = 3 NEW_LINE M = 6 NEW_LINE print ( totalWays ( X , Y , M , W ) ) NEW_LINE
def nextPower ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n & ( n - 1 ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT def removeElement ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = nextPower ( n ) NEW_LINE if ( n == a - 1 ) : NEW_LINE INDENT return 1 << 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 << count NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeElement ( n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE from collections import Counter NEW_LINE N , P = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if N == P == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if A [ 0 ] % 2 == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ** ( N - 1 ) ) NEW_LINE DEDENT DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT a = a % m ; NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( a * x ) % m == 1 : NEW_LINE INDENT return x ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT a = 3 ; m = 11 ; NEW_LINE print ( modInverse ( a , m ) ) ; NEW_LINE
def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sum += x % 10 ; NEW_LINE x = x // 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 and sumOfDigits ( i ) % 3 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT l = 1000 ; NEW_LINE r = 6000 ; NEW_LINE print ( countNumbers ( l , r ) ) ; NEW_LINE
import math NEW_LINE def findGreater ( a , b ) : NEW_LINE INDENT x = a * math . log ( b ) NEW_LINE y = b * math . log ( a ) NEW_LINE if ( y > x ) : NEW_LINE INDENT print ( " a ▁ b " , end = " ▁ " ) NEW_LINE DEDENT elif ( y < x ) : NEW_LINE INDENT print ( " b " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " b " ) NEW_LINE DEDENT DEDENT a = 3 NEW_LINE b = 5 NEW_LINE findGreater ( a , b , c ) NEW_LINE
def findAnswer ( str1 , str2 , n ) : NEW_LINE INDENT l = 0 ; r = 0 ; NEW_LINE ans = 2 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT l = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( r < l ) : NEW_LINE INDENT return 26 * ( n + 1 ) ; NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i - 1 ] ) : NEW_LINE INDENT ans -= 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i - 1 ] ) : NEW_LINE INDENT ans -= 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT str1 = "123 " ; NEW_LINE str2 = " ; NEW_LINE n = len ( str1 ) ; NEW_LINE print ( findAnswer ( str1 , str2 , n ) ) ; NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE l , r = x , y NEW_LINE l , r = x , y NEW_LINE if l <= r : NEW_LINE INDENT l , r = l , r NEW_LINE DEDENT else : NEW_LINE INDENT l , r = l , r NEW_LINE DEDENT DEDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE l , r = x , y NEW_LINE print ( l - r + 1 ) NEW_LINE DEDENT
def bitsInAltRotatedInRange ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) NEW_LINE prev = num & 1 NEW_LINE for i in range ( 1 , r - 1 ) : NEW_LINE INDENT curr = num & 1 NEW_LINE if curr == prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE num = num >> 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE if ( bitsInAltRangeInRotatedInRange ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ans <= k : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT b . append ( sum ( a ) ) NEW_LINE c . append ( sum ( b ) ) NEW_LINE d = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d . append ( [ a [ i ] [ i ] , b [ i ] ] ) NEW_LINE DEDENT d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( b ) ) NEW_LINE d . append ( sum ( d ) ) NEW_LINE d . append ( sum ( d ) ) NEW_LINE if d [ - 1 ] == sum ( d [ - 1 ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if k > l [ i ] : NEW_LINE INDENT s += l [ i ] NEW_LINE l [ i ] = l [ i ] + l [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT s += l [ i ] NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE print ( ' ▁ ' . join ( map ( str , s ) ) ) NEW_LINE
MAX = 1000000 NEW_LINE def maximumOccurElement ( L , R , n ) : NEW_LINE INDENT arr = [ 0 for i in range ( MAX ) ] NEW_LINE maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ L [ i ] ] += 1 NEW_LINE if ( R [ i ] > maxi ) : NEW_LINE INDENT maxi = R [ i ] NEW_LINE DEDENT DEDENT msum = arr [ 0 ] NEW_LINE indum = arr [ 0 ] NEW_LINE indum = 0 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE if ( msum < arr [ i ] ) : NEW_LINE INDENT msum = arr [ i ] NEW_LINE indum = i NEW_LINE DEDENT DEDENT return indum NEW_LINE DEDENT L = [ 1 , 4 , 8 , 13 , 20 ] NEW_LINE R = [ 15 , 8 , 12 , 20 ] NEW_LINE n = len ( L ) NEW_LINE print ( maximumOccurElement ( L , R , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( l [ i ] != l [ i + 1 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT elif m > n - 1 : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT
def func ( x ) : NEW_LINE INDENT return ( 1 / ( x * x ) ) / ( x * x ) NEW_LINE DEDENT def calculate ( lower_size , upper_size ) : NEW_LINE INDENT interval_size = ( upper_size - lower_size ) // segment_size NEW_LINE sum = func ( lower_size ) NEW_LINE sum = func ( lower_size ) NEW_LINE for i in range ( 1 , interval_size ) : NEW_LINE INDENT if ( i % 3 == 0 ) : NEW_LINE INDENT sum = sum + 2 * func ( lower_size + i * interval_size ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + 3 * func ( lower_size + i * interval_size ) NEW_LINE DEDENT DEDENT return ( 3 * interval_size // 8 ) * sum NEW_LINE DEDENT lower_size = 10 NEW_LINE upper_height = 1 NEW_LINE integral_val = calculate ( lower_size , upper_size ) NEW_LINE print ( integral_val ) NEW_LINE
N , K , X , Y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( N - K ) * X + ( N - K ) ) NEW_LINE
import math NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT x , h = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 0 and h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT x = x ** 2 + ( h / 2 ) ** 0.5 NEW_LINE print ( x + x * 4 + x * 4 ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
k = int ( input ( ) ) NEW_LINE s = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT s += str ( i ) NEW_LINE DEDENT print ( k ) NEW_LINE
MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX ) NEW_LINE def sieve ( ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printPrimeQueries ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if prime [ i ] and prime [ i + 2 ] and prime [ i ] : NEW_LINE INDENT print ( i , i + 6 , i + 6 ) NEW_LINE DEDENT DEDENT DEDENT n = 10 NEW_LINE printPrimeQueries ( n ) NEW_LINE
MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT x = " ABCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE d = { } NEW_LINE for i in s1 : NEW_LINE INDENT if i in d : d [ i ] += 1 NEW_LINE else : d [ i ] = 1 NEW_LINE DEDENT for i in d : NEW_LINE INDENT if i in d : d [ i ] += 1 NEW_LINE else : d [ i ] = 1 NEW_LINE DEDENT c = 0 NEW_LINE for i in d : NEW_LINE INDENT if i in d : d [ i ] += 1 NEW_LINE if i in d : d [ i ] -= 1 NEW_LINE else : d [ i ] -= 1 NEW_LINE DEDENT print ( len ( d ) , len ( d ) ) NEW_LINE
MAX = 1000 NEW_LINE sequence = [ 0 ] * MAX NEW_LINE def vowelEqual ( ) : NEW_LINE INDENT for i in range ( 0 , MAX - 1 , - 1 ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , MAX - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i + 1 ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] NEW_LINE DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT vec = 6 NEW_LINE print ( getNTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE DEDENT
MAX = 100000 ; NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) ; NEW_LINE def vowelEqualSequence ( ) : NEW_LINE INDENT for i in range ( 0 , MAX + 1 ) : NEW_LINE INDENT sequence [ i - 1 ] = 0 ; NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i + 1 ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCountEqualSequence ( n ) : NEW_LINE INDENT count = 1 ; NEW_LINE i = n - 1 ; NEW_LINE while ( sequence [ i + 1 ] != 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE i = i - sequence [ i ] ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE print ( getCountEqualSequence ( n ) ) ; NEW_LINE n = 11 ; NEW_LINE print ( getCount ( n ) ) ; NEW_LINE DEDENT
MAX = 100000 ; NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) ; NEW_LINE def vowelEqual ( ) : NEW_LINE INDENT for i in range ( 0 , MAX + 1 ) : NEW_LINE INDENT sequence [ i - 1 ] = 0 ; NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCountEqualSequence ( n ) : NEW_LINE INDENT nthTerm = sequence [ n - 1 ] ; NEW_LINE count = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( sequence [ i ] == nthTerm ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE print ( getCountEqualSequence ( n ) ) ; NEW_LINE n = 11 ; NEW_LINE print ( getCountEqual ( n ) ) ; NEW_LINE DEDENT
from math import gcd NEW_LINE def nthElement ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a , b - a ) NEW_LINE DEDENT return __gcd ( a , b ) NEW_LINE DEDENT def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) // gcd ( a , b ) NEW_LINE l = 1 NEW_LINE r = min ( a , b - a ) * n NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) // lcm // lcm ) NEW_LINE if ( val < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE
y = int ( input ( ) ) NEW_LINE if y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 or y % 400 == 0 ) : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE c = 0 NEW_LINE for i in s : NEW_LINE INDENT if i == ' W ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif i == ' W ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
from math import gcd NEW_LINE def findValue ( x , y , z ) : NEW_LINE INDENT g = gcd ( y , x ) NEW_LINE if ( a > b ) : NEW_LINE INDENT return a NEW_LINE DEDENT return ( x * gcd ( x , y , g ) / gcd ( x , g ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 30 NEW_LINE y = 40 NEW_LINE print ( findValue ( x , y , z ) ) NEW_LINE DEDENT
def foot ( a , b , c , d1 , c2 ) : NEW_LINE INDENT k = ( - a * x - b * y1 - c * c ) / ( a * a + b * c ) NEW_LINE x = a * k + b * k NEW_LINE y2 = b * k + c * c NEW_LINE z2 = b * k + c NEW_LINE z2 = c * k NEW_LINE print ( " x ▁ = ▁ " , y2 , " z2f " , z2 , " z2f " , y2 , z3 , " z3f " , z3 , " f4f " , z3f " , z3f " , z3f " , z3f " ] NEW_LINE print ( " x ▁ = ▁ " , y2 , " f2f " , z3 , z3 , " f3f " , z3f " , z3 , z4f " , z4f " ) NEW_LINE DEDENT a = 1 NEW_LINE b = - 2 NEW_LINE c = 0 NEW_LINE round ( a , b , c , d , 6 ) NEW_LINE
S = input ( ) NEW_LINE S = input ( ) NEW_LINE if S [ 0 ] == S [ - 1 ] and S [ - 1 ] == S [ - 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT minimum = sys . maxsize NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] - abs ( ar [ i - 1 ] - j ) ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinimumOps ( arr ) ) NEW_LINE
PI = 3.14159265 NEW_LINE def area_leaf ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 - 1 ) ) NEW_LINE DEDENT a = 7 NEW_LINE print ( area_leaf ( a ) ) NEW_LINE
def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( ( n // 2 ) - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) // 2 ) ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if ( n == 2 or m == 2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE n = 9 NEW_LINE check ( n , m ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT m , n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = sum ( a ) NEW_LINE if sum ( b ) / m >= n : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 ; NEW_LINE negative = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 ; NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT positive += 1 ; NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 ; NEW_LINE DEDENT DEDENT return ( positive * negative ) ; NEW_LINE DEDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( negProdSubArr ( arr , n ) ) ; NEW_LINE
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT def posProdSubArr ( arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) // 2 NEW_LINE cnt = negProdSubArr ( arr , n ) NEW_LINE return ( total - cnt ) NEW_LINE DEDENT arr = [ 5 , - 4 , - 3 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( posProdSubArr ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE k = n - 1 NEW_LINE if k < n : NEW_LINE INDENT print ( k + ( n - k ) // k ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( k + ( n - k ) // k ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT X , Y , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( X , Y ) : NEW_LINE INDENT if X % i == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return n - len ( LIS ) NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE
def print_max ( a , n , k ) : NEW_LINE INDENT max_upto = [ 0 ] * n NEW_LINE s = [ 0 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) and a [ - 1 ] < a [ i ] ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = i - 1 NEW_LINE s [ - 1 ] = i - 1 NEW_LINE DEDENT s [ - 1 ] = i - 1 NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT max_upto [ 0 ] = n - 1 NEW_LINE s [ 0 ] = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( s [ i ] < max_upto [ j ] ) : NEW_LINE INDENT while ( s [ j ] < max_upto [ j ] ) : NEW_LINE INDENT s [ j ] = i - 1 NEW_LINE DEDENT print ( s [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT DEDENT a = [ 9 , 7 , 2 , 4 , 6 , 8 , 2 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print_max ( a , n , k ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( int ( eulerlib . list ( eulerlib . list_pow ( eulerlib . list_pow ( eulerlib . list_pow ) ) ) for eulerlib . gulerlib . gulerlib . gulerlib . gulerlib . sqrt ( eulerlib . list_pow ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countSquinct ( w , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if w [ i ] == w [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == i : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT DEDENT return dist_count NEW_LINE DEDENT def countDistinct ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT print ( countSquinct ( arr , i , k ) ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 , 3 ] NEW_LINE k = 4 NEW_LINE countDistinct ( arr , n , k ) NEW_LINE
def evenNumSubstring ( string ) : NEW_LINE INDENT l = len ( string ) NEW_LINE count = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT temp = ord ( string [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT string = "1234" NEW_LINE print ( evenNumSubstring ( string ) ) NEW_LINE
max = 4 NEW_LINE max = 4 NEW_LINE def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def countWays ( index , cnt , dp , n , k ) : NEW_LINE INDENT if ( dp [ index ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , k ) NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt , dp , k ) NEW_LINE return dp [ index ] [ cnt ] NEW_LINE DEDENT n = 3 NEW_LINE m = 3 NEW_LINE k = 2 NEW_LINE dp = [ [ 0 for i in range ( max + 1 , n + 1 , k ) ] NEW_LINE print ( m * countWays ( 1 , 0 , dp , n , k , m , k ) ) NEW_LINE
from math import sqrt NEW_LINE def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + i NEW_LINE sum = sum + ( n // i ) NEW_LINE DEDENT DEDENT return sum - n NEW_LINE DEDENT def printAlqototot ( n ) : NEW_LINE INDENT print ( " ▁ " . join ( n ) ) NEW_LINE s = set ( ) NEW_LINE n = len ( s ) NEW_LINE s . sort ( ) NEW_LINE s . sort ( ) NEW_LINE print ( " Rimes ▁ with ▁ " , n , " ▁ " , s ) NEW_LINE DEDENT n = 12 NEW_LINE printAlqototototototot ( n ) NEW_LINE
n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( l [ i ] - 1 ) * ( l [ i ] - 1 ) > 0 : NEW_LINE INDENT l [ i ] = l [ i ] NEW_LINE DEDENT DEDENT print ( * l ) NEW_LINE
def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n // 2 + 1 ) : NEW_LINE INDENT swap ( arr [ i ] , ( n + ~ i + 1 ) + ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
def printSumSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE cnt = 0 NEW_LINE cnt = 0 NEW_LINE flag = True NEW_LINE sum = a NEW_LINE while ( cnt < N ) : NEW_LINE INDENT nextElement = a * 2 NEW_LINE sum += nextElement NEW_LINE flag = False NEW_LINE flag = False NEW_LINE DEDENT a = 8 NEW_LINE while ( cnt < N ) : NEW_LINE INDENT nextElement = a * 3 / 2 NEW_LINE sum = a * 3 / 2 NEW_LINE flag = False NEW_LINE flag = False NEW_LINE DEDENT a = nextElementSum ( 3 ) NEW_LINE cnt += 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 8 NEW_LINE printSumSumSum ( N ) NEW_LINE DEDENT
import math NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE if h % 2 == 0 : NEW_LINE INDENT print ( 1 , h // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , h // 2 ) NEW_LINE DEDENT DEDENT
import math NEW_LINE sieve = [ True ] * ( s + 1 ) NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = False NEW_LINE for i in range ( 2 , s + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , s + 1 , i ) : NEW_LINE INDENT if ( isPrime [ j ] ) : NEW_LINE INDENT for j in range ( i * i , s , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def minDifference ( L , R ) : NEW_LINE INDENT fst = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT fst = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( sst == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT def minDifference ( L , R ) : NEW_LINE INDENT diff = Sieve ( L ) NEW_LINE left = Sieve [ 0 ] NEW_LINE right = Sieve [ 1 ] NEW_LINE for i in range ( left , right + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT if ( i - s <= diff ) : NEW_LINE INDENT if ( i - s ) : NEW_LINE INDENT fst = i NEW_LINE diff = sst NEW_LINE diff = i NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT DEDENT sieve ( ) NEW_LINE L = 21 NEW_LINE R = 50 NEW_LINE print ( minDifference ( L , R ) ) NEW_LINE
def getMaxLength ( arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE preCnt = 0 NEW_LINE while ( start < n and arr [ start ] == 1 ) : NEW_LINE INDENT preCnt += 1 NEW_LINE start += 1 NEW_LINE DEDENT end = n - 1 NEW_LINE while ( end >= 0 and arr [ end ] == 1 ) : NEW_LINE INDENT midCnt += 1 NEW_LINE end -= 1 NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT return n NEW_LINE DEDENT midCnt = 0 NEW_LINE result = 0 NEW_LINE result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT midCnt += 1 NEW_LINE result = max ( result , midCnt ) NEW_LINE DEDENT else : NEW_LINE INDENT midCnt = 0 NEW_LINE result = max ( result , midCnt + suffCnt ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMaxLength ( arr , n ) ) NEW_LINE DEDENT
d , n = map ( int , input ( ) . split ( ) ) NEW_LINE ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ab [ i ] [ 0 ] <= ab [ i ] [ 1 ] and ab [ i ] [ 1 ] <= ab [ i - 1 ] [ 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j ] + ab [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( max ( dp ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if ( len ( s ) == 1 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] < s [ i - 1 ] ) : NEW_LINE INDENT print ( i + 1 , i + 2 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( i + 1 , i + 2 ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def sqroot ( s ) : NEW_LINE INDENT pSq = 0 NEW_LINE N = 0 NEW_LINE for i in range ( s , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , s , i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i NEW_LINE N = j NEW_LINE break NEW_LINE DEDENT DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT d = s - pSq NEW_LINE P = N + P NEW_LINE A = N - pSq NEW_LINE A = N + P NEW_LINE return int ( A ) NEW_LINE DEDENT num = 9.0 NEW_LINE sqroot = int ( sqroot ( num ) ) NEW_LINE print ( " Square ▁ root ▁ root ▁ = ▁ " , sqroot ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= b [ i ] : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT DEDENT print ( n - 1 ) NEW_LINE
import sys NEW_LINE def solve ( r , n ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , h = map ( int , input ( ) . split ( ) ) NEW_LINE ans . append ( [ x , y ] ) NEW_LINE DEDENT dp = [ [ - 1 ] * ( n + 1 ) for x , y in zip ( * [ iter ( r ) ] * 2 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT if dp [ i ] [ j ] > dp [ i - 1 ] [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = dp [ - 1 ] [ 0 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT if dp [ i ] [ j ] > dp [ i - 1 ] [ j ] : NEW_LINE INDENT ans = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( " % d : ▁ % d " % ( i , ans ) ) NEW_LINE DEDENT while True : NEW_LINE INDENT r = int ( input ( ) ) NEW_LINE if r == 0 : NEW_LINE INDENT break NEW_LINE DEDENT solve ( r , n ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = sorted ( a ) NEW_LINE c = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= b [ i ] : NEW_LINE INDENT c = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
import sys NEW_LINE f = sys . stdin NEW_LINE def solve ( n ) : NEW_LINE INDENT c = ' ' NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT c += n [ i ] NEW_LINE DEDENT c += ' ' . join ( c ) NEW_LINE return ' ' . join ( c ) NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( f . readline ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( solve ( n ) ) NEW_LINE DEDENT
def maxAlternatingSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ 0 ] * n NEW_LINE inc [ 0 ] = arr [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i ] ) : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ i ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ i ] < arr [ i ] and flag == 1 ) : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , inc [ i ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT result = - 10 ** 9 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( result < inc [ i ] and flag == 1 ) : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if ( result < dec [ i ] and dec [ i ] ) : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if ( result < dec [ i ] and dec [ i ] ) : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 8 , 2 , 3 , 5 , 7 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ sum ▁ = " , maxAlternatingSum ( arr , n ) ) NEW_LINE
def generateArr ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] & arr [ 1 ] NEW_LINE arr [ 0 ] = arr [ 1 ] & arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] & arr [ i + 1 ] NEW_LINE arr [ i ] = prev & arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev & arr [ n - 1 ] NEW_LINE return arr [ n - 1 ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] ^ arr [ 1 ] NEW_LINE arr [ 0 ] = arr [ 1 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] ^ arr [ i + 1 ] NEW_LINE prev = prev ^ arr [ i ] NEW_LINE prev = curr ^ arr [ i ] NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] + arr [ 1 ] NEW_LINE arr [ 0 ] = arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev + arr [ i + 1 ] NEW_LINE prev = prev + arr [ i ] NEW_LINE DEDENT arr [ n - 1 ] = prev + arr [ n - 1 ] NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT if ( i * k > j * j * j ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT A = 3 ; B = 2 ; C = 2 ; NEW_LINE print ( countTriplets ( A , B , C ) ) ; NEW_LINE
MAX = 100000 ; NEW_LINE prime = [ True ] * ( MAX + 1 ) ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def smallestPrime ( d ) : NEW_LINE INDENT l = pow ( 10 , d - 1 ) ; NEW_LINE r = pow ( 10 , d - 1 ) - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT def largestPrime ( d ) : NEW_LINE INDENT l = pow ( 10 , d - 1 ) ; NEW_LINE r = pow ( 10 , d - 1 ) ; NEW_LINE for i in range ( r , l , r + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT SieveOfEratosthenes ( ) ; NEW_LINE q = len ( q ) ; NEW_LINE q = len ( q ) ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( smallestPrime ( q [ i ] ) , largestPrime ( q [ i ] ) ) ; NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE dp = [ float ( " inf " ) ] * n NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ j - 1 ] + dp [ i - 1 ] * dp [ i - 1 ] ) NEW_LINE DEDENT DEDENT print ( dp [ m - 1 ] ) NEW_LINE
n , k , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
from sys import stdin NEW_LINE input = stdin . readline NEW_LINE n , m , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT d [ i ] = ( d [ i ] - 1 ) // a NEW_LINE DEDENT x = d [ 0 ] NEW_LINE y = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if d [ i ] == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = max ( 0 , ( d [ i ] - 1 ) // a ) NEW_LINE y = max ( 0 , ( d [ i ] - 1 ) // a ) NEW_LINE x = max ( 0 , ( d [ i ] - 1 ) // a ) NEW_LINE y = max ( 0 , ( d [ i ] - 1 ) // a ) NEW_LINE DEDENT DEDENT print ( y ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += ( a [ i ] - 1 ) * ( i - 1 ) // 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
s = input ( ) NEW_LINE a = [ 0 ] * 26 NEW_LINE b = [ 0 ] * 26 NEW_LINE for i in s : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT if a [ 0 ] % 2 == 1 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT
def reverse ( n ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while n != 0 : NEW_LINE INDENT rev = ( rev * 10 ) + ( n % 10 ) ; NEW_LINE n //= 10 ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def getSum ( n ) : NEW_LINE INDENT n = reverse ( n ) ; NEW_LINE sumOdd = 0 ; NEW_LINE sumOdd = 0 ; NEW_LINE while n != 0 : NEW_LINE INDENT if ( c % 2 == 0 ) : NEW_LINE INDENT sumOdd += n % 10 ; NEW_LINE DEDENT else : NEW_LINE INDENT sumOdd += n % 10 ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT n = int ( sumOdd ) ; NEW_LINE c = 1 ; NEW_LINE DEDENT print ( " Sum ▁ odd ▁ = " , sumEven ( sum ) ) ; NEW_LINE print ( " Sum ▁ odd ▁ = " , sumEven ( sumEven ) ) ; NEW_LINE DEDENT n = 447 ; NEW_LINE getSum ( n ) ; NEW_LINE
def compute ( row , height ) : NEW_LINE INDENT return ( row // height ) NEW_LINE DEDENT def row ( row , h ) : NEW_LINE INDENT return row // h NEW_LINE DEDENT def row ( l , w , h ) : NEW_LINE INDENT global row NEW_LINE row_no = ( 4 * a ) // l NEW_LINE if ( h < w ) : NEW_LINE INDENT row_no = row ( 4 * a ) NEW_LINE DEDENT else : NEW_LINE INDENT row_no = row ( row , w ) NEW_LINE DEDENT DEDENT def calculate ( l , w , h , h , a , h ) : NEW_LINE INDENT row_no = row ( 4 * a ) // l NEW_LINE calc ( row , w , h ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 50 NEW_LINE w = 20 NEW_LINE h = 140 NEW_LINE h = 140 NEW_LINE h = 140 NEW_LINE h = 140 NEW_LINE calculate ( l , w , h , h , h , h ) NEW_LINE DEDENT
bin = "010" ; NEW_LINE bin = " " ; NEW_LINE bin = [ "010" , "1" , "1" , "1" , "1" , "1" , "1" , "1" , "1" ] ; NEW_LINE count = 1 ; NEW_LINE def maxFreq ( s ) : NEW_LINE INDENT binary = " " ; NEW_LINE for i in range ( len ( bin ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT binary += bin [ ord ( bin [ i ] ) - ord ( '0' ) ] ; NEW_LINE DEDENT binary = binary [ 0 : - 1 ] ; NEW_LINE for i in range ( len ( bin ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if bin [ i ] == '0' : NEW_LINE INDENT count = max ( count , j - prev ) ; NEW_LINE prev = j ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT oct = "13" ; NEW_LINE print ( maxFreq ( oct ) ) ; NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' u ' or c == ' u ' or c == ' u ' ) NEW_LINE DEDENT def encryptString ( s ) : NEW_LINE INDENT c = [ 0 for i in range ( n ) ] NEW_LINE c [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT c [ i ] = c [ i - 1 ] + ( ( s [ i ] - ( s [ i - 1 ] ) ) ) NEW_LINE c [ i ] = c [ i - 1 ] + ( ( s [ i ] - c [ i - 1 ] ) ) * ( ( s [ i ] - c [ i - 1 ] ) ) NEW_LINE DEDENT ans = " " NEW_LINE prod = [ 0 for i in range ( k ) ] NEW_LINE prod = ( prod [ k - 1 ] * c [ k - 1 ] ) NEW_LINE for i in range ( k , len ( prod ) ) : NEW_LINE INDENT prod = ( prod [ i ] - prod [ i - k - 1 ] ) * ( prod [ i ] - c [ i - k ] ) NEW_LINE ans += str ( prod [ i ] - prod [ i - k ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " hello " NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT
def harmonicMean ( arr , freq , n ) : NEW_LINE INDENT sum = 0 NEW_LINE frequency_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( freq [ i ] / arr [ i ] ) NEW_LINE frequency_sum = frequency_sum + freq [ i ] NEW_LINE DEDENT return ( frequency_sum / sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = [ 13 , 14 , 15 , 7 , 7 ] NEW_LINE freq = [ 2 , 5 , 13 , 7 ] NEW_LINE n = len ( num ) NEW_LINE print ( harmonicMean ( num , freq , n ) ) NEW_LINE DEDENT
from math import ceil NEW_LINE def polyarea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a * a * n ) / ( 4 * n ) NEW_LINE return A NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( polyarea ( n , a ) ) NEW_LINE DEDENT
import math NEW_LINE def __gcd ( a , b ) : NEW_LINE INDENT return ( a / gcd ( a , b ) * b ) if ( a > b ) else a NEW_LINE DEDENT def lcm ( c ) : NEW_LINE INDENT return ( a / gcd ( a , b ) * b ) NEW_LINE DEDENT def getMinValue ( c ) : NEW_LINE INDENT ans = ( a / gcd ( c ) ) * b NEW_LINE for i in range ( 1 , int ( math . sqrt ( c ) ) + 1 ) : NEW_LINE INDENT if ( c % i == 0 and lcm ( i , c // i ) == c ) : NEW_LINE INDENT ans = min ( ans , max ( i , c // i ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT c = 6 NEW_LINE print ( getMinValue ( c ) ) NEW_LINE
def solve ( m , n , m , k ) : NEW_LINE INDENT d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d < m - i : NEW_LINE INDENT d = d NEW_LINE DEDENT if d < m - i : NEW_LINE INDENT d = m - i NEW_LINE DEDENT DEDENT return d NEW_LINE DEDENT m , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE while n != 0 and m == 0 : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE p = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE print ( solve ( m , n , m ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE from collections import Counter NEW_LINE from collections import defaultdict NEW_LINE from collections import Counter NEW_LINE from itertools import permutations NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE from heapq import heappop , heappush NEW_LINE from math import ceil , ceil NEW_LINE from copy import deepcopy NEW_LINE def I ( ) : return int ( input ( ) ) NEW_LINE def MI ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE def LIR ( n ) : return [ LI ( ) for _ in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for _ in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for _ in range ( n ) ] NEW_LINE def SRL ( n ) : return [ LS ( ) for _ in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for _ in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for _ in range ( n ) ] NEW_LINE mod = 1000000007 NEW_LINE inf = float ( " inf " ) NEW_LINE def solve ( ) : NEW_LINE INDENT n , m , r = MI ( ) NEW_LINE a = MI ( ) NEW_LINE b = MI ( ) NEW_LINE if a > 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if a > m : NEW_LINE INDENT if b > r : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT a *= - 1 NEW_LINE b *= - 1 NEW_LINE if b > r : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT a *= - 1 NEW_LINE b *= - 1 NEW_LINE if b > r : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT DEDENT
from math import log10 NEW_LINE def findIndex ( n ) : NEW_LINE INDENT fibo = 2.078778 NEW_LINE return fibo NEW_LINE DEDENT n = 21 NEW_LINE print ( findIndex ( n ) ) NEW_LINE
def isSmaller ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE if ( n1 < n2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n1 < n2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( str1 [ i ] < str2 [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findDiff ( str1 , str2 ) : NEW_LINE INDENT if ( isSmaller ( str1 , str2 ) ) : NEW_LINE INDENT t = str1 [ : : - 1 ] NEW_LINE str2 = t2 [ : : - 1 ] NEW_LINE carry = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sub = ( ord ( str1 [ i ] ) - ord ( '0' ) ) NEW_LINE if ( sub < 0 ) : NEW_LINE INDENT t = sub + 10 NEW_LINE carry = 1 NEW_LINE carry = 0 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE carry = 0 NEW_LINE carry = 0 NEW_LINE DEDENT DEDENT for i in range ( n1 ) : NEW_LINE INDENT sub = ( ord ( str1 [ i ] ) - ord ( '0' ) ) NEW_LINE if ( sub < 0 ) : NEW_LINE INDENT carry = 0 NEW_LINE carry = 0 NEW_LINE carry = 0 NEW_LINE carry = 0 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE carry = 0 NEW_LINE carry = 0 NEW_LINE DEDENT DEDENT for i in range ( n1 ) : NEW_LINE INDENT sub = ( ord ( str1 [ i ] ) - ord ( '0' ) ) NEW_LINE if ( sub < 0 ) : NEW_LINE INDENT carry = 0 NEW_LINE carry = 0 NEW_LINE carry = 0 NEW_LINE carry = 0 NEW_LINE carry = 0 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE carry = 0 NEW_LINE carry
def minSwaps ( s1 , s2 ) : NEW_LINE INDENT c0 = 0 ; NEW_LINE c0 = 0 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == '0' and s2 [ i ] == '0' ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT elif ( s1 [ i ] == '0' and s2 [ i ] == '0' ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT DEDENT ans = c // 2 ; NEW_LINE if ( c0 % 2 == 0 ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = "00001" ; NEW_LINE s2 = "1111" ; NEW_LINE ans = minSwaps ( s1 , s2 ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE * a = map ( int , input ( ) . split ( ) ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + a [ i ] NEW_LINE DEDENT print ( dp [ n ] - dp [ n ] ) NEW_LINE
s = input ( ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE for c in s : NEW_LINE INDENT if c . find ( ' ^ ' ) == 1 : NEW_LINE INDENT l += int ( c ) * ( l - 1 ) NEW_LINE r += int ( c ) * ( l - 1 ) NEW_LINE DEDENT DEDENT if l < r : NEW_LINE INDENT print ( " right " ) NEW_LINE DEDENT elif r == l : NEW_LINE INDENT print ( " right " ) NEW_LINE DEDENT elif r == l : NEW_LINE INDENT print ( " right " ) NEW_LINE DEDENT elif r == l : NEW_LINE INDENT print ( " right " ) NEW_LINE DEDENT elif r == l : NEW_LINE INDENT print ( " right " ) NEW_LINE DEDENT elif r == l : NEW_LINE INDENT print ( " right " ) NEW_LINE DEDENT elif r == l : NEW_LINE INDENT print ( " right " ) NEW_LINE DEDENT elif r == l : NEW_LINE INDENT print ( " right " ) NEW_LINE DEDENT
def idealSieve ( n ) : NEW_LINE INDENT prime = [ False for i in range ( n // 2 ) ] NEW_LINE for i in range ( 3 , n // 2 , 2 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT for j in range ( i * i , n , 2 * i ) : NEW_LINE INDENT prime [ j ] = True NEW_LINE DEDENT DEDENT DEDENT print ( "2 ▁ " , end = " " ) NEW_LINE for i in range ( 3 , n , 2 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT n = 100 NEW_LINE idealSieve ( n ) NEW_LINE
s = input ( ) NEW_LINE a = s . count ( " ABC " ) NEW_LINE b = s . count ( " C " ) NEW_LINE print ( a . lower ( ) ) NEW_LINE
def frequencyOfSmallest ( n , arr ) : NEW_LINE INDENT mn = arr [ 0 ] NEW_LINE freq = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < mn ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE freq = 1 NEW_LINE DEDENT elif ( arr [ i ] == mn ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 3 , 2 , 3 , 4 ] NEW_LINE print ( frequencyOfSmallest ( N , arr ) ) NEW_LINE DEDENT
def isSubArray ( A , B , n , m ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE if ( j == m ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT A = [ 2 , 3 , 5 , 1 , 1 , 2 ] NEW_LINE n = len ( A ) NEW_LINE B = [ 3 , 0 , 5 , 1 ] NEW_LINE m = len ( B ) NEW_LINE if ( isSubArray ( A , B , n , m ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += abs ( l [ i ] - l [ i - 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE
MOD = 10 ** 9 + 7 NEW_LINE N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE S = ' ACGT ' NEW_LINE def cmb ( n , S , T ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ret = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( S [ i ] == ' T ' ) : NEW_LINE INDENT ret += cmb ( i , n - 1 ) NEW_LINE DEDENT ret += cmb ( i , n - 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT print ( cmb ( N , S , MOD ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE a = [ ] NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ' , ' ) ) NEW_LINE a . append ( a ) NEW_LINE DEDENT print ( sum ( a ) // len ( a ) ) NEW_LINE print ( int ( sum ( a ) / len ( b ) ) ) NEW_LINE
MAX = 100 NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT def sumproductproduct ( n , k ) : NEW_LINE INDENT return binomialCoeff ( 2 * n , n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( sumproductproduct ( n , n , k ) ) NEW_LINE DEDENT
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE if s1 [ : : - 1 ] == s2 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ the ▁ s " ) NEW_LINE DEDENT
import math as mt NEW_LINE def pairCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( mt . ceil ( max_val + 1 ) ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( max_val + 1 ) ) ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( count * ( count - 1 ) ) // 2 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 7 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairCount ( arr , n ) ) NEW_LINE
import math as mt NEW_LINE def getPrime ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( mt . ceil ( mt . sqrt ( max_val + 1 ) ) ) ] NEW_LINE prime [ 2 ] = False NEW_LINE prime [ 2 ] = False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( max_val + 1 ) ) ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT maximum = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT arr = [ 2 , 10 , 15 , 7 , 7 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getPrime ( arr , n ) ) NEW_LINE
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( itertools . count ( 1 ) for i in itertools . count ( 1 ) , repeat = 2 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE
def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 6 , 100 , 5 , 9 , 9 , 100 , 100 , 100 , 100 , 100 , 100 , 100 , 100 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( A * B ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def nth_term ( a , b , n ) : NEW_LINE INDENT z = 0 ; NEW_LINE if ( n % 6 == 1 ) : NEW_LINE INDENT z = a ; NEW_LINE DEDENT elif ( n % 6 == 2 ) : NEW_LINE INDENT z = b ; NEW_LINE DEDENT elif ( n % 6 == 3 ) : NEW_LINE INDENT z = b - a ; NEW_LINE DEDENT if ( n % 6 == 0 ) : NEW_LINE INDENT z = - b ; NEW_LINE DEDENT if ( n % 6 == 0 ) : NEW_LINE INDENT z = - b ; NEW_LINE DEDENT return z ; NEW_LINE DEDENT a = 10 ; NEW_LINE b = 17 ; NEW_LINE print ( nth_term ( a , b , n ) ) ; NEW_LINE
def findSubSequence ( s , num ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT res += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT num = num >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def repeatedSum ( s , n ) : NEW_LINE INDENT n_sum = len ( s ) - 1 NEW_LINE c_sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT c_sum += findSubSequence ( s , i ) NEW_LINE DEDENT return c_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "123" NEW_LINE print ( repeatedSum ( s ) ) NEW_LINE DEDENT
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp1 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp1 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT a = [ 2 , 5 , 3 , 7 , 7 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE
def countMultiples ( n ) : NEW_LINE INDENT return n // 3 + n // 7 - n // 7 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( " Count ▁ = " , countMultiples ( 2 ) ) NEW_LINE DEDENT
SIZE = 26 NEW_LINE def subSubstring ( str1 , k ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE start = 0 NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ch = ord ( str1 [ i ] ) + 1 NEW_LINE if ( freq [ ord ( ch ) - ord ( ' a ' ) ] > k ) : NEW_LINE INDENT if ( freq [ ord ( ch ) - ord ( ' a ' ) ] > k ) : NEW_LINE INDENT if ( maxLen < ( i - ord ( ' a ' ) ) ) : NEW_LINE INDENT maxLen = i - start NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = "abbca " NEW_LINE k = 1 NEW_LINE print ( " Length ▁ = ▁ " , subSubstring ( str1 , k ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE x += x NEW_LINE y += y NEW_LINE if ( x + y ) % 500 == 0 : NEW_LINE INDENT x += x NEW_LINE y += 1 NEW_LINE DEDENT elif ( x + y ) % 500 == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT if ( y + x ) % 500 == 0 : NEW_LINE INDENT print ( ' A ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' B ' ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def toHex ( self , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return "0" NEW_LINE DEDENT res = " " NEW_LINE while n != 0 : NEW_LINE INDENT res = "0" + res [ n >> 4 ] "0" NEW_LINE n = n >> 4 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 26 NEW_LINE out = sObj . toHex ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k > ( n + 1 ) // 2 : NEW_LINE INDENT print ( " YES " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( " S " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " S " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( n + 1 ) // 2 == ( n + 1 ) // 2 ) : NEW_LINE INDENT print ( " S " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " S " , end = " " ) NEW_LINE DEDENT DEDENT print ( " \n " . join ( [ " S " , end ] ) ) NEW_LINE DEDENT
def longestString ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len ( str1 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + i ) : NEW_LINE INDENT result += chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT str1 = " geek " NEW_LINE str2 = " NEW_LINE longestString ( str1 , str2 ) NEW_LINE
def msb ( x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( x >> ( x + 1 ) ) : NEW_LINE INDENT ret += 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def xor ( x ) : NEW_LINE INDENT max_bit = msb ( x ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , max_bit + 1 ) : NEW_LINE INDENT if ( ( ( x & ( 1 << i ) ) ) & ( ( 1 << i ) ) ) : NEW_LINE INDENT if ( ( ( ( 1 << i ) ) & ( 1 << i ) ) ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT if ( ( ( ( 1 << i ) ) & 1 ) ) & 1 ) : NEW_LINE INDENT odd_c = ( odd_c ) // 2 NEW_LINE DEDENT if ( ( ( ( ( ( ( 1 << i ) ) ) ) & 1 ) ) ) : NEW_LINE INDENT odd_c = ( odd_c ) // 2 NEW_LINE DEDENT if ( odd_c ) & 1 ) : NEW_LINE INDENT odd_c = ( odd_c ) // 2 NEW_LINE DEDENT if ( odd_c ) : NEW_LINE INDENT odd_c += mul NEW_LINE DEDENT if ( odd_c % 2 == 1 ) : NEW_LINE INDENT odd_c += 1 NEW_LINE DEDENT DEDENT zero_cnt = zero_bit ( ( r - l + 1 ) // 2 ) NEW_LINE if ( odd_cnt % 2 == 1 ) : NEW_LINE INDENT zero_cnt += 1 NEW_LINE DEDENT if ( zero_cnt % 2 == 1 ) : NEW_LINE INDENT zero_cnt += 1 NEW_LINE DEDENT if ( zero_cnt % 2 == 1 ) : NEW_LINE INDENT zero_cnt += 1 NEW_LINE DEDENT if ( zero_cnt % 2 ) : NEW_LINE INDENT zero_cnt += 1 NEW_LINE DEDENT return zero_cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE
def q1 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE return q1 ( s , i + 1 ) NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( q , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q1 ( q , i + 1 ) NEW_LINE DEDENT if ( q1 == ( i + 1 ) ) : NEW_LINE INDENT q1 ( q , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( q , i + 1 ) NEW_LINE DEDENT DEDENT def q2 ( s , i ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( q , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( q , i + 1 ) NEW_LINE DEDENT DEDENT if ( q1 ( s , i ) ) : NEW_LINE INDENT q1 ( q , i + 1 ) NEW_LINE DEDENT if ( q1 ( s , i ) ) : NEW_LINE INDENT q2 ( q2 ( q1 , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( q2 , i + 1 ) NEW_LINE DEDENT if ( q2 ( q3 ( i , i ) ) ) : NEW_LINE INDENT q3 ( q3 ( q3 ( i , i + 1 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( q4 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abbaabb " NEW_LINE q4" = " abba "
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( a [ 0 ] , n + 1 ) : a [ j ] = 1 NEW_LINE for k in range ( a [ 1 : ] ) : a [ k + 1 ] += a [ k ] NEW_LINE print ( * a [ k ] ) NEW_LINE DEDENT
def findTime ( T , K ) : NEW_LINE INDENT minutes = ( ( int ) ( T [ 0 ] ) * 10 + ( int ( T [ 1 ] ) - ord ( '0' ) ) * 60 + ( ord ( T [ 3 ] ) - ord ( '0' ) ) ) NEW_LINE minutes += K NEW_LINE if ( minute < 10 ) : NEW_LINE INDENT print ( "0" + str ( minutes ) + " : " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" + str ( int ( minute ) ) + " : " ) NEW_LINE DEDENT DEDENT T = "21" NEW_LINE K = 43 NEW_LINE findTime ( T , K ) NEW_LINE
import sys NEW_LINE def maxProductSum ( str1 , m ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE maxProd = - sys . maxsize NEW_LINE maxSum = - sys . maxsize NEW_LINE for i in range ( n - m + 1 ) : NEW_LINE INDENT product = 1 NEW_LINE for j in range ( i , m + 1 ) : NEW_LINE INDENT product = product * ( ord ( str1 [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( str1 [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxProd = max ( maxProd , product ) NEW_LINE DEDENT print ( " Maximum ▁ Product ▁ = " , maxProductSum ) NEW_LINE m = 5 NEW_LINE maxProductSum ( str1 , m ) NEW_LINE
def minCost ( x , y , z ) : NEW_LINE INDENT if ( x < z ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y if ( x < z ) else z NEW_LINE DEDENT DEDENT def minCost ( cost , m , n ) : NEW_LINE INDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return cost [ m ] [ n ] + minCost ( minCost ( cost , m - 1 , n - 1 , n - 1 ) , minCost ( cost , m - 1 , n - 1 , n - 1 ) , minCost ( cost , m - 1 , n - 1 , m - 1 ) , minCost ( cost , m , n - 1 , n - 1 ) ) NEW_LINE DEDENT DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 5 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , n - 1 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE c = [ ] NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE c . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT if b [ i ] != b [ i + 1 ] : NEW_LINE INDENT ans += abs ( b [ i ] - b [ i + 1 ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def resolve ( ) : NEW_LINE INDENT n , q = map ( int , input ( ) . split ( ) ) NEW_LINE uf = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] NEW_LINE uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf ] ] ] ] ] ] ] ] ] ] ] ] for uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [ uf [
def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( i % M == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT A , B , M = 6 , 15 , 3 NEW_LINE print ( sumDivisibles ( A , B , M ) ) NEW_LINE
import math NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = math . log10 ( n ) NEW_LINE a = [ 0 ] * ( n + 2 ) NEW_LINE a [ 0 ] = 1 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + 9 NEW_LINE DEDENT p = int ( math . log10 ( n ) ) NEW_LINE msd = n // p NEW_LINE if ( msd > 4 ) : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + p + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + p + 1 NEW_LINE DEDENT DEDENT n = 328 NEW_LINE print ( " Count ▁ of ▁ numbers ▁ of ▁ 1 ▁ numbers ▁ is ▁ numbers ▁ is " , n , " is ▁ of ▁ 4 ▁ digits ▁ is " , countNumbersWith4 ( n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 or m == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT x = ( n - x ) % m NEW_LINE y = ( m - x ) % m NEW_LINE m = ( m - y ) % m NEW_LINE k = ( m - x ) % m NEW_LINE m = ( m - y ) % m NEW_LINE if k == 0 : NEW_LINE INDENT print ( m ) NEW_LINE DEDENT else : NEW_LINE INDENT k = m - x NEW_LINE m = k - y NEW_LINE print ( m % m ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import numpy as np NEW_LINE def findPostOrder ( preIndex , n , minval , maxval ) : NEW_LINE INDENT if ( preIndex [ 0 ] < minval or preIndex [ 0 ] > minval ) : NEW_LINE INDENT return NEW_LINE DEDENT val = preIndex [ 0 ] NEW_LINE preIndex = preIndex [ 0 ] NEW_LINE findIndex = preIndex . index ( preIndex ) NEW_LINE findIndexOrder ( preIndex , n , val , preIndex ) NEW_LINE findIndex = preIndex . index ( preIndex ) NEW_LINE findIndexOrder ( preIndex , n , val , preIndex , preIndex ) NEW_LINE print ( val , end = " ▁ " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT preIndex = [ 4 , 3 , 3 , 100 ] NEW_LINE n = len ( preIndex ) NEW_LINE findPostOrder ( preIndex , n , minval , preIndex ) NEW_LINE DEDENT
def countWays ( n , arr , k ) : NEW_LINE INDENT if ( k <= 0 or k >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT if ( len ( s ) <= k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return len ( s ) - k NEW_LINE DEDENT arr = [ 100 , 200 , 400 , 50 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( countWays ( arr , n , k ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = input ( ) NEW_LINE b = a . count ( "0" ) NEW_LINE c = a . count ( "0" ) NEW_LINE if len ( b ) < 8 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if len ( c ) < 8 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT print ( "0" * c ) NEW_LINE DEDENT DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT return ( ( flag - int ) ( math . sqrt ( sr ) ) ) == 0 ) NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT for j in range ( 1 , i * j * j * j * j ) : NEW_LINE INDENT if ( isPerfectSquare ( i - j * j * j * j * j * j * j ) ) : NEW_LINE INDENT flag += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 NEW_LINE print ( countPerfectSquare ( N ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = list ( input ( ) ) NEW_LINE c = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT c . append ( input ( ) ) NEW_LINE DEDENT c . sort ( ) NEW_LINE flag = True NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if w [ i ] [ 0 ] == c [ i + 1 ] [ 1 ] : NEW_LINE INDENT c [ i + 1 ] = c [ i ] [ 0 ] NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] + rem [ i ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT div = [ 8 , 3 ] NEW_LINE rem = [ 2 , 2 ] NEW_LINE N = len ( div ) NEW_LINE print ( findNum ( div , rem , N ) ) NEW_LINE
def segregate0and1 ( arr ) : NEW_LINE INDENT type0 = 0 NEW_LINE type0 = len ( arr ) - 1 NEW_LINE while type0 < type1 : NEW_LINE INDENT if arr [ type0 ] == 1 : NEW_LINE INDENT arr [ type1 ] = arr [ type1 ] + arr [ type0 ] NEW_LINE arr [ type0 ] = arr [ type1 ] - arr [ type0 ] NEW_LINE type0 += 1 NEW_LINE type1 -= 1 NEW_LINE type0 NEW_LINE type0 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 -= 1 NEW_LINE type0 NEW_LINE type0 -= 1 NEW_LINE type0 NEW_LINE type0 -= 1 NEW_LINE DEDENT DEDENT DEDENT array = [ 0 , 1 , 0 , 1 , 1 ] NEW_LINE segregate0and1 ( array ) NEW_LINE print ( " Array ▁ after ▁ segreg ▁ is ▁ " ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( len ( set ( a ) ) ) NEW_LINE
s1 , s2 = input ( ) , input ( ) NEW_LINE s1 = s1 [ 0 ] NEW_LINE s2 = s1 [ 1 ] NEW_LINE s2 = s1 [ 0 ] NEW_LINE s1 = s1 [ 1 ] NEW_LINE s2 = s1 [ 1 ] NEW_LINE s2 = s1 [ 1 ] NEW_LINE s2 = s2 [ 0 ] NEW_LINE s3 = s1 [ 1 ] NEW_LINE s3 = s1 [ 1 ] NEW_LINE s3 = s1 [ 0 ] NEW_LINE s3 = s1 [ 1 ] NEW_LINE s3 = s1 [ 0 ] NEW_LINE s3 = s2 [ 1 ] NEW_LINE s3 = s3 [ 1 ] NEW_LINE s3 = s3 [ 0 ] NEW_LINE s3 = s3 [ 1 ] NEW_LINE s3 = s3 [ 0 ] NEW_LINE s4 = s3 [ 0 ] NEW_LINE s4 = s3 [ 1 ] NEW_LINE s4 = s3 [ 0 ] NEW_LINE s4 = s4 [ 0 ] NEW_LINE s4 = s4 [ 1 ] NEW_LINE s4 = s4 [ 0 ] NEW_LINE s4 = s7 [ 1 ] NEW_LINE s4 = s7 [ 0 ] NEW_LINE s4 = s7 [ 1 ] NEW_LINE s7 = s7 [ 0 ] NEW_LINE s7 = s7 [ 1 ] NEW_LINE s7 = s7 [ 0 ] NEW_LINE s7 = s7 [ 1 ] NEW_LINE s7 = s7 [ 0 ] NEW_LINE s7 = s7 [ 1 ] NEW_LINE s7 = s7 [ 0 ] NEW_LINE s7 = s7 [ 1 ] NEW_LINE s7 = s7 [ 0 ] = s7 [ 1 ] NEW_LINE s7 = s7 [ 0 ] NEW_LINE s7 = s7 [ 0 ] = s7 [ 1 ] NEW_LINE s7 = s7 [ 0 ] = s7 [ 1 ] NEW_LINE s7 = s7 [ 0 ] NEW_LINE s7 = s7 [ 1 ] = s7 [ 1 ] NEW_LINE s7 = s7 [ 1 ] NEW_LINE s7 = s7 [ 0 ] NEW_LINE s7 = s7 [
H , W = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( H ) : NEW_LINE INDENT x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans += ( H - i ) * ( W - x ) * ( W - i ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE line . append ( line ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if line [ i ] [ j ] != line [ i ] [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT print ( " Yes " if not ( " No " ) else " No " ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = ( x & y ) + ( ( x & y ) ) NEW_LINE ans = " " NEW_LINE if ( x & y ) == 0 : NEW_LINE INDENT ans += "0" NEW_LINE DEDENT else : NEW_LINE INDENT ans += "0" NEW_LINE DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE x = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( x - 1 ) : NEW_LINE INDENT if i & 1 == x : NEW_LINE INDENT ans . append ( str ( i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( str ( i ) ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( ans ) ) NEW_LINE
N = int ( input ( ) ) NEW_LINE A = [ 0 for i in range ( N ) ] NEW_LINE C = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ i ] = input ( ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if A [ i ] == " M " : NEW_LINE INDENT C [ j ] += 1 NEW_LINE DEDENT elif A [ i ] == " C " : NEW_LINE INDENT C [ j ] += 1 NEW_LINE DEDENT elif A [ i ] == " C " : NEW_LINE INDENT C [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT print ( C [ N - 1 ] ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
a , b , c = input ( ) . split ( ) NEW_LINE for x in range ( int ( a ) ) : NEW_LINE INDENT if x [ 0 ] == ' + ' : NEW_LINE INDENT a += b NEW_LINE DEDENT elif x [ 1 ] == ' - ' : NEW_LINE INDENT b += c NEW_LINE DEDENT elif x [ 0 ] == ' - ' : NEW_LINE INDENT b += c NEW_LINE DEDENT DEDENT print ( a * b ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
MAX = 256 ; NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 ] * MAX ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) ] += 1 ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " ; NEW_LINE print ( countPairs ( s ) ) ; NEW_LINE DEDENT
prime = [ True ] * ( 100005 ) NEW_LINE def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sortedArray ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == True : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( reverse = True ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == False : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE arr = [ 100 , 100 , 100 , 100 , 1 ] NEW_LINE sortArray ( arr , n ) NEW_LINE DEDENT
from math import ceil NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( curr ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE curr = curr NEW_LINE DEDENT DEDENT def gcdFibonacciFreq ( arr , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE createHash ( hash , maxElement ) NEW_LINE m = dict ( ) NEW_LINE for i in m : NEW_LINE INDENT if arr [ i ] in m : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT gcd = 0 NEW_LINE for it in m : NEW_LINE INDENT if it == m [ it ] : NEW_LINE INDENT gcd = gcd ( gcd , it ) NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT arr = [ 5 , 3 , 6 , 6 , 5 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( gcdFibonacciFreq ( arr , n ) ) NEW_LINE
import math NEW_LINE def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.14 - math . sqrt ( 2 ) ) / 2.14 NEW_LINE area = ( 3.14 * R * R ) / 2.14 NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE print ( " ▁ Area ▁ of ▁ surr ▁ = " , find_Area ( a ) ) NEW_LINE DEDENT
def findQuaduples ( a , b , c , d , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] ^ b [ j ] ) == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT x = 3 NEW_LINE a = [ 0 , 1 , 0 ] NEW_LINE b = [ 2 , 1 ] NEW_LINE c = [ 2 , 1 ] NEW_LINE d = [ 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findQuaduples ( a , b , c , d , n ) ) NEW_LINE
def printSmallest ( l , r , n ) : NEW_LINE INDENT N = len ( l ) NEW_LINE H = [ [ 0 for i in range ( 26 ) ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT H [ i ] [ ord ( l [ i - 1 ] ) - ord ( ' a ' ) ] += H [ i ] [ ord ( ' a ' ) ] NEW_LINE DEDENT m = len ( q ) NEW_LINE for j in range ( 0 , N + 1 ) : NEW_LINE INDENT l = q [ j ] [ i ] NEW_LINE r = q [ j ] [ i ] NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT H [ i ] [ j ] += H [ i - 1 ] [ j ] NEW_LINE if ( sum >= n ) : NEW_LINE INDENT print ( ch , " a " , i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " fbcccc " NEW_LINE q = [ 2 , 4 , 6 , 7 ] NEW_LINE q = [ 1 , 6 , 6 ] NEW_LINE q = [ 1 , 6 , 8 ] NEW_LINE printSmallest ( s , q , q ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT ans += k * n NEW_LINE DEDENT else : NEW_LINE INDENT ans += k * n NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT print ( n // 3 + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n // 3 + 1 ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT s [ : i ] = s [ : i ] NEW_LINE DEDENT DEDENT print ( s [ : n ] ) NEW_LINE
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT v . sort ( ) NEW_LINE for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 4 , 8 , 9 , - 4 , - 9 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE printPairs ( arr , n ) NEW_LINE
def factfact ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factfact ( n - 2 ) NEW_LINE DEDENT print ( " ▁ fact ▁ fact ▁ is " , factfact ( 5 ) ) NEW_LINE
def isPalindrome ( string ) : NEW_LINE INDENT l = 0 ; NEW_LINE h = len ( string ) - 1 ; NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( string [ l ] != string [ h ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT h -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def minRemoval ( string ) : NEW_LINE INDENT if ( string [ 0 ] == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 2 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "0001001" ; NEW_LINE print ( minRemoval ( string ) ) ; NEW_LINE DEDENT
def sumSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumDigit = [ 0 ] * ( n ) NEW_LINE sumDigit [ 0 ] = int ( num [ 0 ] ) NEW_LINE res = sumDigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT num = num [ i ] NEW_LINE sumDigit [ i ] = ( i + 1 ) * num [ i - 1 ] NEW_LINE res += sumDigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT num = "1234" NEW_LINE print ( sumSubstrings ( num ) ) NEW_LINE
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * ( a // n ) * ( b // n ) NEW_LINE ans += ( a // n ) * ( b % n ) NEW_LINE return ans NEW_LINE DEDENT a , b , n = 5 , 13 , 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = eulerlib . list ( itertools . accumulate ( itertools . count ( 3 ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT ans = eulerlib . list ( itertools . product ( 3 , repeat = 3 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
c = [ 0 ] * 100 ; NEW_LINE def coef ( n ) : NEW_LINE INDENT c [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ 1 ] = - c [ 0 ] ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT c [ 1 ] = c [ j - 1 ] - c [ j ] ; NEW_LINE DEDENT DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT coef = [ 0 ] * 100 ; NEW_LINE c [ 0 ] -= 1 ; NEW_LINE c [ n ] -= 1 ; NEW_LINE i = n ; NEW_LINE while ( i > 0 and c [ i ] % n == 0 ) : NEW_LINE INDENT c [ i ] = c [ i - 1 ] - c [ i ] ; NEW_LINE i -= 1 ; NEW_LINE DEDENT DEDENT n = 37 ; NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Prime " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime " ) ; NEW_LINE DEDENT
import sys NEW_LINE def count_greater ( arr , n ) : NEW_LINE INDENT min = sys . maxsize ; NEW_LINE counter = 0 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > min ) : NEW_LINE INDENT counter += 1 ; NEW_LINE DEDENT if ( arr [ i ] <= min ) : NEW_LINE INDENT min = arr [ i ] ; NEW_LINE DEDENT DEDENT return counter ; NEW_LINE DEDENT arr = [ 3 , 2 , 1 , 2 , 4 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( count_greater ( arr , n ) ) ; NEW_LINE
n , x = map ( int , input ( ) . split ( ) ) NEW_LINE l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if x - l [ i ] >= 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( i + 1 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif y == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count == 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
while 1 : NEW_LINE INDENT t , d , l = map ( int , input ( ) . split ( ) ) NEW_LINE if t == 0 and d == 0 : break NEW_LINE a = [ int ( input ( ) ) for _ in range ( t ) ] NEW_LINE c = 0 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x <= l : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif x <= l : NEW_LINE INDENT if y <= l : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if y <= l : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def minimumSwaps ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT while ( arr [ i ] != i + 1 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ i ] NEW_LINE arr [ i ] = temp NEW_LINE count += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumSwaps ( arr , n ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT n = 500000 NEW_LINE prime = eulerlib . list_prime_list [ 0 ] NEW_LINE prime = eulerlib . list_prime_list [ 1 ] NEW_LINE prime = [ ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime . append ( i * i % mod ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT prime . append ( prime [ i ] * prime [ i ] % mod ) NEW_LINE DEDENT return prime NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findUniquePair ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE DEDENT set_bit_no = XOR & ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
n = int ( input ( ) ) NEW_LINE s = ' ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += input ( ) NEW_LINE DEDENT if n == 1 or s [ 0 ] == s [ - 1 ] : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT
import re NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT s = input ( ) NEW_LINE if ' @ ' in s : s = re . sub ( ' @ ' , ' @ ' ) [ 0 ] ) . split ( ' @ ' ) NEW_LINE print ( s [ 0 ] + ' @ ' ) NEW_LINE DEDENT except EOFError : break NEW_LINE DEDENT
def isMajority ( a , n ) : NEW_LINE INDENT mp = dict . fromkeys ( a , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if x >= n // 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT a = [ 2 , 3 , 9 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if isMajority ( a , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE from collections import namedtuple NEW_LINE def solve ( ) : NEW_LINE INDENT N , W = map ( int , input ( ) . split ( ) ) NEW_LINE * W , = map ( int , input ( ) . split ( ) ) NEW_LINE dp = [ [ 0 ] * ( W + 1 ) for _ in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for w , b in enumerate ( dp [ i + 1 ] , start = 1 ) : NEW_LINE INDENT if w <= b : NEW_LINE INDENT dp [ i + 1 ] [ w ] = max ( dp [ i ] [ w ] , dp [ i + 1 ] [ w ] + i * b ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ w ] = max ( dp [ i ] [ w ] , dp [ i + 1 ] [ w ] + i * b ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N ] [ W ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
import math NEW_LINE while 1 : NEW_LINE INDENT try : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT cos = math . sqrt ( N ) NEW_LINE cos = math . sqrt ( N * cos + cos ) NEW_LINE print ( cos ) NEW_LINE print ( cos ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
def printKMissing ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < n and arr [ i ] <= 0 ) : NEW_LINE INDENT if ( arr [ i ] != curr ) : NEW_LINE INDENT print ( curr , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE curr = 1 NEW_LINE curr = 1 NEW_LINE while ( i < k and i < n ) : NEW_LINE INDENT print ( curr , end = " ▁ " ) NEW_LINE curr += 1 NEW_LINE curr += 1 NEW_LINE curr += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printKMissing ( arr , n , k ) NEW_LINE DEDENT
def printNumbers ( a , n ) : NEW_LINE INDENT mpp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE for j in range ( 1 , int ( num ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( num % j == 0 ) : NEW_LINE INDENT if ( j != 1 ) : NEW_LINE INDENT if ( j != 1 ) : NEW_LINE INDENT if ( j != 1 ) : NEW_LINE INDENT if ( j // j in mpp [ num // j ] ) : NEW_LINE INDENT mpp [ num // j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ num // j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT maxi = 0 NEW_LINE for it in mpp : NEW_LINE INDENT if ( it // j ) : NEW_LINE INDENT if ( it // j ) : NEW_LINE INDENT if ( it // j in mpp ) : NEW_LINE INDENT if ( it // j in mpp . keys ( ) ) : NEW_LINE INDENT print ( it // j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT a = [ 10 , 10 , 10 , 10 , 40 , 40 ] NEW_LINE n = len ( a ) NEW_LINE printNumbers ( a , n ) NEW_LINE
s = input ( ) NEW_LINE s1 = s [ : : - 1 ] NEW_LINE s2 = s [ : : - 1 ] NEW_LINE s2 = s [ : : - 1 ] NEW_LINE s2 = s [ : - 1 ] NEW_LINE if len ( s ) == len ( s ) : NEW_LINE INDENT print ( " ( " ) " ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( s ) == len ( s ) : NEW_LINE INDENT print ( " ( " ) " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mx = max ( a ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == mx ) : NEW_LINE INDENT mx = a . index ( mx ) NEW_LINE DEDENT DEDENT print ( mx ) NEW_LINE
def checkIfStarts ( string ) : NEW_LINE INDENT if ( string [ 0 ] >= ' A ' and string [ 0 ] <= ' Z ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeksforGeeks " NEW_LINE check = " geeksforGeeks " NEW_LINE check ( string ) NEW_LINE DEDENT string = " geeksforGeeks " NEW_LINE check ( string ) NEW_LINE check ( string ) NEW_LINE check ( string ) NEW_LINE
def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( prev_avg * n + x ) / ( n + x ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) NEW_LINE print ( " average ▁ of ▁ n ▁ is " , end = " " ) NEW_LINE DEDENT DEDENT arr = [ 10 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE streamAvg ( arr , n ) NEW_LINE
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE primes = eulerlib . list_primes ( LIMIT ) NEW_LINE ans = sum ( primes ) NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , LIMIT ) : NEW_LINE INDENT sum += primes [ j ] NEW_LINE if sum > LIMIT and isprime [ sum ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if sum > LIMIT and isprime [ sum ] : NEW_LINE INDENT ans = sum NEW_LINE max = sum NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE lst = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lst [ i ] < lst [ j ] + 1 ) : NEW_LINE INDENT lst [ i ] = lst [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lst [ i ] + 1 ) : NEW_LINE INDENT max = lst [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 10 , 22 , 9 , 33 , 50 , 50 , 50 , 50 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ lst ▁ is " , lis ( arr , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( a * b + i ) % 10 == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT c += i NEW_LINE DEDENT DEDENT if ( c - ( 10 ** ( a - 1 ) ) ) ** ( b - 1 ) ** ( 1 / 10 ) == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def fix ( A ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT s . add ( A [ i ] ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if i in s : NEW_LINE INDENT A [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = - 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT A = [ - 1 , - 1 , 6 , 9 , 9 , 2 , - 1 , 2 , - 1 ] NEW_LINE print ( fix ( A ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + b + c + d ) - 2 * ( a + b + c + d ) ) NEW_LINE
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , data ) : NEW_LINE INDENT new_node . data = Node ( data ) NEW_LINE new_node . data = Node ( data ) NEW_LINE if ( head_ref == None ) : NEW_LINE INDENT head_ref . data = head_ref NEW_LINE return head_ref NEW_LINE DEDENT head_ref . prev = head_ref NEW_LINE return head_ref NEW_LINE DEDENT def makeOddNode ( head_ref , A ) : NEW_LINE INDENT ptr_ref = Node ( head_ref ) NEW_LINE i = 0 NEW_LINE while ( ptr != None ) : NEW_LINE INDENT next = ptr . next NEW_LINE if ( ptr % 2 == 0 ) : NEW_LINE INDENT ptr_ref = A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ptr = next NEW_LINE DEDENT return head_ref NEW_LINE DEDENT def makeOddNode ( head ) : NEW_LINE INDENT ptr = head NEW_LINE i = 0 NEW_LINE while ( ptr != None ) : NEW_LINE INDENT print ( head . data , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = [ 3 , 5 , 10 , 1 ] NEW_LINE A = [ 3 , 5 , 10 , 1 ] NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE head = push ( head , head ) NEW_LINE print ( " Original ▁ List : ▁ List : " ,
from collections import defaultdict NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE def S ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def IR ( n ) : NEW_LINE INDENT l = [ None for i in range ( n ) ] NEW_LINE for i in range ( n ) : l [ i ] = I ( ) NEW_LINE return l NEW_LINE DEDENT def LIR ( n ) : NEW_LINE INDENT l = [ None for i in range ( n ) ] NEW_LINE for i in range ( n ) : l [ i ] = LI ( ) NEW_LINE return l NEW_LINE DEDENT def SR ( n ) : NEW_LINE INDENT l = [ None for i in range ( n ) ] NEW_LINE for i in range ( n ) : l [ i ] = S ( ) NEW_LINE return l NEW_LINE DEDENT def LSR ( n ) : NEW_LINE INDENT l = [ None for i in range ( n ) ] NEW_LINE for i in range ( n ) : l [ i ] = SR ( ) NEW_LINE return l NEW_LINE DEDENT def LSR ( n ) : NEW_LINE INDENT l = [ None for i in range ( n ) ] NEW_LINE for i in range ( n ) : l [ i ] = SR ( i ) NEW_LINE return l NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n , s = LI ( ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
mod = 1000000007 NEW_LINE def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def fact ( n , r ) : NEW_LINE INDENT return fact ( fact ( n ) // ( fact ( fact ( r ) * fact ( n - r ) ) ) % mod ) NEW_LINE DEDENT def factorial ( a , n ) : NEW_LINE INDENT return fact ( fact ( a , n - 1 ) // fact ( fact ( n - r ) * fact ( n - 1 ) ) % mod ) NEW_LINE DEDENT def CountSubset ( arr , n ) : NEW_LINE INDENT ans = fact ( n - 1 ) // 2 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 - j NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT r = n - 1 - j NEW_LINE ans = ( ans + nCr ( l + r , l , l ) ) % mod NEW_LINE j = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubset ( arr , n ) ) NEW_LINE DEDENT
MAX = 1000001 NEW_LINE prime = [ 0 ] * ( MAX ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = 0 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( isPrime [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT if ( isPrime [ j ] == 1 ) : NEW_LINE INDENT prime [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE low = 1 NEW_LINE ans = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( prime - prime [ mid ] >= K ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT ans = N - ans + 1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 NEW_LINE K = 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT
def countOperations ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( ( i * i ) < n and ( n % i ) > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( ( i * i ) > n ) : NEW_LINE INDENT i = n NEW_LINE DEDENT return ( 1 + ( n - i ) // 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( countOperations ( n ) ) NEW_LINE
from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT S = input ( ) NEW_LINE Q = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if l == r - 1 : NEW_LINE INDENT print ( S [ r - 1 ] - S [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( S [ r - 1 ] - S [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( l , r * 2 ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE modulo = 1000000007 NEW_LINE nums = [ 1 ] * ( LIMIT // 2 ) NEW_LINE nums [ 0 ] = 1 NEW_LINE for i in range ( LIMIT // 2 ) : NEW_LINE INDENT if not prime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i + 1 , LIMIT // 2 , i - 1 , - 1 ) : NEW_LINE INDENT if prime [ j ] : NEW_LINE INDENT nums [ j ] = nums [ j - i ] + nums [ j - i ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ j ] = nums [ j - i - i ] NEW_LINE DEDENT DEDENT DEDENT return sum ( nums ) % modulo NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countOddNumber ( row_num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( row_num > 0 ) : NEW_LINE INDENT count += row_num & 1 NEW_LINE row_num >>= 1 NEW_LINE DEDENT return ( 1 << count ) NEW_LINE DEDENT def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( 0 , n ) : NEW_LINE INDENT print ( countOddNumber ( row_num ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 16 NEW_LINE gouldSequence ( n ) NEW_LINE
import math as mt NEW_LINE def findMin ( V , n ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= n ) : NEW_LINE INDENT V -= n NEW_LINE ans . append ( v ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 9 NEW_LINE print ( " F Minimum ▁ number ▁ of ▁ minimum ▁ difference ▁ of ▁ range ▁ of ▁ minimum ▁ difference ▁ of ▁ range ▁ : ▁ % d " % ( n , " ▁ difference ▁ of ▁ difference ▁ : ▁ % d " % ( n , " ▁ difference ▁ : ▁ % d " % ( n , " ▁ difference ▁ : " % ( n , " ▁ % d " % ( n , " ▁ difference ▁ : " % ( n , " ▁ difference ▁ % d " ) ) ) ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = str ( i ) NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT if str ( i ) [ : : - 1 ] != str ( i ) [ : : - 1 ] : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def count ( x ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] % x == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 NEW_LINE return ans NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE
def findEle ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == sum - arr [ i ] ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findEle ( arr , n ) ) NEW_LINE
def findExtraCharcter ( str1 , str2 ) : NEW_LINE INDENT m1 = [ 0 ] * 256 NEW_LINE for i in range ( 0 , 256 ) : NEW_LINE INDENT m1 [ ord ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , 256 ) : NEW_LINE INDENT m1 [ ord ( str1 [ i ] ) ] -= 1 NEW_LINE DEDENT for i in range ( 0 , len ( str1 ) ) : NEW_LINE INDENT if ( m1 [ i ] == 1 ) : NEW_LINE INDENT return ch ( chr ( i ) ) NEW_LINE DEDENT DEDENT return chr ( ord ( m1 [ i ] ) ) NEW_LINE DEDENT str1 = " abcd " NEW_LINE str2 = " ccd " NEW_LINE print ( findExtraCharctercter ( str1 , str2 ) ) NEW_LINE
import math NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT max_value = 0 NEW_LINE for i in range ( 101 ) : NEW_LINE INDENT x = i * i NEW_LINE y = math . ceil ( ( x ** 2 + 1 ) / 6 ) NEW_LINE if max_value < x : NEW_LINE INDENT max_value = x NEW_LINE DEDENT DEDENT print ( max_value ) NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : break NEW_LINE s = [ input ( ) for i in range ( n ) ] NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , t = input ( ) . split ( ) NEW_LINE s [ t ] = s [ t ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT s [ i ] , t = input ( ) , input ( ) NEW_LINE if not s [ i ] in c : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in a : NEW_LINE INDENT if i in d : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT for i in d . values ( ) : NEW_LINE INDENT if ( i in d ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
import sys NEW_LINE def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = - INT_MIN NEW_LINE max2 = INT_MIN NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( arr2 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( n2 ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE
import sys NEW_LINE def operations ( op , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE minVal = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT nVal += op [ i ] NEW_LINE minVal += abs ( minVal ) NEW_LINE if ( ( k + nVal ) <= 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if ( nVal >= 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT times = ( k - abs ( n ) ) // abs ( n ) NEW_LINE k = ( k - abs ( nVal ) ) // abs ( times [ 0 ] ) NEW_LINE count = ( times * n ) // abs ( times [ 0 ] ) NEW_LINE return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT op = [ - 60 , 65 , - 1 , - 1 ] NEW_LINE n = len ( op ) NEW_LINE k = 100000 NEW_LINE print ( operations ( op , n , k ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE pref = [ 0 ] * 100010 NEW_LINE def isPerfectCube ( x ) : NEW_LINE INDENT cr = sqrt ( x ) NEW_LINE if ( cr * cr == x ) : NEW_LINE INDENT return x NEW_LINE DEDENT return 0 NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT pref = [ 0 ] * ( 100010 ) NEW_LINE for i in range ( 1 , 100010 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) NEW_LINE DEDENT return pref [ DEDENT def printSum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] NEW_LINE printSum ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT compute ( ) NEW_LINE Q = 4 NEW_LINE arr = [ [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , 4 ] , [ 4 , 5 ] ] NEW_LINE printSum ( arr ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE from collections import deque NEW_LINE from collections import defaultdict NEW_LINE from heapq import heappop , heappush NEW_LINE from math import ceil , ceil , floor NEW_LINE from itertools import accumulate , permutations , combinations , product NEW_LINE from operator import itemgetter NEW_LINE from copy import deepcopy NEW_LINE from string import ascii_lowercase NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE from fractions import gcd NEW_LINE from heapq import heappush , heappop NEW_LINE def solution ( ) : NEW_LINE INDENT n , r , x = map ( int , input ( ) . split ( ) ) NEW_LINE arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , t , x = map ( int , input ( ) . split ( ) ) NEW_LINE arr [ d - 1 ] += t NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT t , x = arr [ i ] [ 0 ] , t NEW_LINE if t == x : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT t -= x NEW_LINE if t == 0 : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solution ( ) NEW_LINE DEDENT
def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( " th ▁ Centered ▁ Centered : " , centered_cube ( n ) ) NEW_LINE n = 10 NEW_LINE print ( " th ▁ Centered ▁ Centered : " , centered_cube ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = ' ' NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT ans += s [ i + 1 ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE i = N NEW_LINE while ( i > 0 ) : NEW_LINE INDENT nth += pow ( i , i ) NEW_LINE i -= 1 NEW_LINE DEDENT return nth NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isPower ( x , y ) : NEW_LINE INDENT if ( y == 1 ) : NEW_LINE INDENT return y == 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isPower ( x , y ) : NEW_LINE INDENT if ( isPower ( x , y ) ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 10 NEW_LINE y = 1 NEW_LINE while ( pow ( x , y ) ) : NEW_LINE INDENT pow = pow ( x , x ) NEW_LINE DEDENT print ( pow ( pow , 2 , 30 ) ) NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return y == 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT DEDENT def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return y == 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def isPower ( x , y ) : NEW_LINE INDENT if ( isPower ( x , y ) ) : NEW_LINE INDENT return y == 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT x = 1 NEW_LINE y = 1 NEW_LINE while ( power ( x , y ) ) : NEW_LINE INDENT pow = pow ( x , y ) NEW_LINE if ( pow == y ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT pow = pow ( pow ) NEW_LINE DEDENT DEDENT
def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE answer = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] NEW_LINE DEDENT return answer * ( 2 * k - 2 ) NEW_LINE DEDENT arr = [ 4 , 21 , 5 , 8 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( minimumValue ( arr , n , k ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , d , d = input ( ) . split ( ) NEW_LINE d [ s ] = d [ 0 ] + d [ 1 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT s , d = input ( ) . split ( ) NEW_LINE if s == ' l ' : NEW_LINE INDENT d [ s ] = d [ 2 ] + d [ s ] NEW_LINE DEDENT else : NEW_LINE INDENT d [ s ] = d [ 2 ] + d [ 1 ] NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d [ i ] == ' l ' : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT if d [ i ] == ' r ' : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) // 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def findLCM ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) / gcd ( arr [ i ] , lcm ) ; NEW_LINE DEDENT return lcm ; NEW_LINE DEDENT def countNumbers ( arr , n , l , r ) : NEW_LINE INDENT lcm = findLCM ( arr , n ) ; NEW_LINE count = ( r // lcm ) ; NEW_LINE count = ( r // lcm ) - ( ( l - 1 ) // lcm ) ; NEW_LINE return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 4 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE lcm = 10 ; NEW_LINE print ( countNumbers ( arr , n , l , r ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans [ 2 ] ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE c = a [ 0 ] * n NEW_LINE d = a [ - 1 ] * n NEW_LINE c = a [ - 1 ] * n NEW_LINE if ( c == d ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def MinDeletion ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in mp : NEW_LINE INDENT x = i NEW_LINE frequency = mp . get ( i , 0 ) + 1 NEW_LINE if x <= frequency : NEW_LINE INDENT ans += ( frequency - x ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( frequency - x ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT a = [ 2 , 3 , 2 , 3 , 4 , 4 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( MinDeletion ( a , n ) ) NEW_LINE
def startEnd ( start , end ) : NEW_LINE INDENT return startEnd ( start , end ) NEW_LINE DEDENT def startEnd ( start , end ) : NEW_LINE INDENT return startEnd ( start , end ) NEW_LINE DEDENT def startEnd ( start , end ) : NEW_LINE INDENT return startEnd ( start , end ) NEW_LINE DEDENT def startEnd ( start , end ) : NEW_LINE INDENT return startEnd ( start , end ) NEW_LINE DEDENT def startEnd ( start , endEnd ) : NEW_LINE INDENT return startEnd ( startEnd , endEnd ) NEW_LINE DEDENT def startEnd ( startEnd ) : NEW_LINE INDENT return startEnd ( startEnd ) NEW_LINE DEDENT def startEnd ( startEnd , endEnd ) : NEW_LINE INDENT return startEnd ( startEnd , endEnd ) NEW_LINE DEDENT def startEnd ( startEnd , endEnd ) : NEW_LINE INDENT return startEnd ( startEnd , endEnd ) NEW_LINE DEDENT def startEnd ( startEnd , endEnd ) : NEW_LINE INDENT return startEnd ( startEnd , endEnd ) NEW_LINE DEDENT def startEnd ( startEnd , endEnd ) : NEW_LINE INDENT return startEnd ( startEnd , endEnd ) NEW_LINE DEDENT def startEnd ( startEnd , endEnd ) : NEW_LINE INDENT return startEnd ( startEnd ( startEnd , endEnd ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT startEnd = 1234 NEW_LINE startEnd = endEnd ( startEnd ) NEW_LINE startEnd ( startEnd ( startEnd , endEnd ) ) NEW_LINE endEnd ( startEnd ( startEnd , endEnd ) ) NEW_LINE startEnd ( startEnd ( endEnd , endEnd ) ) NEW_LINE endEnd ( startEnd ( endEnd ( endEnd ( startEnd ) ) ) NEW_LINE endEnd ( endEnd ( endEnd ) ) NEW_LINE endEnd ( endEnd ( endEnd ( endEnd ) ) NEW_LINE endEnd ( endEnd ( endEnd ( endEnd ) ) ) NEW_LINE endEnd ( endEnd ( endEnd ( endEnd ) ) NEW_End ( endEnd ( endEnd (
def nondecdigits ( n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for x in range ( n , 0 , - 1 ) : NEW_LINE INDENT no = x ; NEW_LINE prev_dig = 11 ; NEW_LINE flag = 1 ; NEW_LINE while ( no != 0 ) : NEW_LINE INDENT if ( prev_dig < n % 10 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT prev_dig = n % 10 ; NEW_LINE n //= 10 ; NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return x ; NEW_LINE DEDENT n = 200 ; NEW_LINE print ( nondecdigits ( n ) ) ; NEW_LINE
x , y , z = map ( int , input ( ) . split ( ) ) NEW_LINE if x == y : NEW_LINE INDENT print ( x , y ) NEW_LINE DEDENT elif y == z : NEW_LINE INDENT print ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT if x == z : NEW_LINE INDENT print ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , x - z ) NEW_LINE DEDENT DEDENT
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = " Cainc " NEW_LINE if ( x - y ) > ( y - 2 ) : NEW_LINE INDENT ans = " Cainc " NEW_LINE DEDENT elif ( x - y ) > ( y - 2 ) : NEW_LINE INDENT ans = " Cainc " NEW_LINE DEDENT elif ( x - y ) < ( y - 2 ) : NEW_LINE INDENT ans = " Cainc " NEW_LINE DEDENT else : NEW_LINE INDENT ans = " Cainc " NEW_LINE DEDENT print ( ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT row = input ( ) NEW_LINE for j in row : NEW_LINE INDENT if j == " W " : NEW_LINE INDENT row [ j ] = " W " NEW_LINE DEDENT else : NEW_LINE INDENT row [ j ] = " W " NEW_LINE DEDENT DEDENT DEDENT for i in row : NEW_LINE INDENT print ( " W " if i % 2 == 0 else " B " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT m = 0 NEW_LINE DEDENT DEDENT DEDENT print ( m ) NEW_LINE
def countDistinctSubarray ( arr , n ) : NEW_LINE INDENT vis = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT vis [ arr [ i ] ] = 1 NEW_LINE DEDENT k = len ( vis ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( right < n and vis [ arr [ i ] ] == 1 ) : NEW_LINE INDENT vis [ arr [ i ] ] += 1 NEW_LINE if ( vis [ arr [ right ] ] == 1 ) : NEW_LINE INDENT vis [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT if ( vis [ arr [ left ] ] == 0 ) : NEW_LINE INDENT ans += ( n - 1 ) NEW_LINE DEDENT vis [ arr [ left ] ] -= 1 NEW_LINE if ( vis [ arr [ right ] ] == 0 ) : NEW_LINE INDENT ans += ( n - r + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 2 , 1 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinctSubarray ( arr , n ) ) NEW_LINE
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE max_ = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE max_ = max ( a , b + a ) NEW_LINE DEDENT print ( max_ ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def primeBitsInRange ( l , r ) : NEW_LINE INDENT tot_bit = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT tot_bit = bin ( i ) NEW_LINE if ( isPrime ( tot_bit ) ) : NEW_LINE INDENT count_bit += 1 NEW_LINE DEDENT DEDENT return count_bit NEW_LINE DEDENT l , r = 6 , 10 NEW_LINE print ( primeBitsInRange ( l , r ) ) NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) NEW_LINE if ( sum == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE
import queue NEW_LINE def reverseFirstKK ( k ) : NEW_LINE INDENT if ( len ( queue ) == 0 or k > len ( queue ) ) : NEW_LINE INDENT return NEW_LINE DEDENT stack . pop ( ) NEW_LINE DEDENT def reverseFirstKFirstK ( k ) : NEW_LINE INDENT if ( k <= 0 or k <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT stack . pop ( ) NEW_LINE stack . pop ( ) NEW_LINE stack . pop ( ) NEW_LINE while ( len ( stack ) != 0 ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE stack . pop ( ) NEW_LINE DEDENT while ( len ( stack ) != 0 ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE stack . pop ( ) NEW_LINE DEDENT stack . pop ( ) NEW_LINE return stack NEW_LINE DEDENT def reverseFirstKK ( k ) : NEW_LINE INDENT stack = [ ] NEW_LINE stack . append ( 100 ) NEW_LINE while ( len ( stack ) != 0 ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT for i in range ( len ( stack ) - 1 ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT DEDENT def reverseFirstKK ( k ) : NEW_LINE INDENT print ( stack ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = 5 NEW_LINE reverseFirstK ( k ) NEW_LINE k = 5 NEW_LINE reverseFirstK ( k ) NEW_LINE reverseFirstK ( k ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( a ) % 2 == 0 : NEW_LINE INDENT print ( ' mainvainr ' ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = 0 NEW_LINE for i in a : NEW_LINE INDENT sum += i NEW_LINE DEDENT if sum % 2 == 0 : NEW_LINE INDENT print ( ' mainvainr ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' error ' ) NEW_LINE DEDENT DEDENT DEDENT
def xorCalcc ( k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( ( k + 1 ) & k ) == 0 ) : NEW_LINE INDENT return k // 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT k = 31 NEW_LINE print ( xorCalcc ( k ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def isPerfectSquare ( self , n ) : NEW_LINE INDENT low = 1 NEW_LINE high = n NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if mid * mid == n : NEW_LINE INDENT return True NEW_LINE DEDENT elif mid * mid < n : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 16 NEW_LINE out = sObj . isPerfectSquare ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' Yes ' if a + b + c == a + b + c ) else ' No ' ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = sum ( a ) / n NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] == a [ i ] ) : NEW_LINE INDENT c . append ( i + 1 ) NEW_LINE DEDENT DEDENT print ( len ( c ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] == c [ i ] ) : NEW_LINE INDENT print ( i + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) . split ( ) ) NEW_LINE DEDENT s . sort ( key = lambda x : x [ 1 ] ) NEW_LINE s . sort ( key = lambda x : x [ 0 ] ) NEW_LINE s . sort ( key = lambda x : x [ 1 ] ) NEW_LINE s . sort ( key = lambda x : x [ 0 ] ) NEW_LINE s . sort ( key = lambda x : x [ 1 ] ) NEW_LINE s . sort ( key = lambda x : x [ 0 ] ) NEW_LINE s . sort ( key = lambda x : x [ 1 ] ) NEW_LINE s . sort ( key = lambda x : x [ 0 ] ) NEW_LINE s . sort ( key = lambda x : x [ 0 ] ) NEW_LINE s . sort ( key = lambda x : x [ 1 ] ) NEW_LINE s . sort ( key = lambda x : x [ 0 ] ) NEW_LINE s . sort ( key = lambda x : x [ 1 ] ) NEW_LINE s . sort ( key = lambda x : x [ 0 ] ) NEW_LINE s . sort ( key = lambda x : x [ 1 ] ) NEW_LINE s . sort ( key = lambda x : x [ 0 ] ) NEW_LINE print ( ' \n ' . join ( s ) ) NEW_LINE
def findElement ( arr , ranges , index , index ) : NEW_LINE INDENT for i in range ( rot ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT if ( index == left ) : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index = right - 1 NEW_LINE DEDENT DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE ranges = 2 NEW_LINE print ( findElement ( arr , ranges , index ) ) NEW_LINE
MAXN = 1000001 NEW_LINE spf = [ 0 ] * ( MAXN ) ; NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = i ; NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 ; NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT temp = spf [ x ] ; NEW_LINE while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] ; NEW_LINE if ( x % temp == 0 and hash [ temp ] > 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT while ( x % temp [ temp ] > 1 ) : NEW_LINE INDENT temp = x // temp [ temp ] ; NEW_LINE if ( x % temp [ temp ] > 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT def check ( x ) : NEW_LINE INDENT sieve ( ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( x % temp [ j ] > 0 and hash [ i ] > 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT def check ( x ) : NEW_LINE INDENT sieve ( ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT get ( i ) ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( check ( arr
def isExists ( a , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT if ( sum % 2 == 0 ) : NEW_LINE INDENT if ( freq [ a [ i ] ] != 0 ) : NEW_LINE INDENT if ( freq [ a [ i ] ] != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 5 , 1 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if ( isExists ( a , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE return area NEW_LINE DEDENT d1 = 4 NEW_LINE d2 = 6 NEW_LINE print ( " Area ▁ of ▁ K ▁ = ▁ " , areaOfKite ( d1 , d2 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ [ 0 ] * n for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] [ a [ i ] - 3 ] = " + " NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] [ a [ i ] - 3 ] = " + " NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT print ( " - " , end = " " ) NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT print ( " | " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " . " , end = " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if ( n & ( n - 1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def productEqual ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT prodOdd = 1 NEW_LINE prodOdd = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digitOdd *= digitOdd NEW_LINE prodOdd *= digitOdd NEW_LINE n //= 10 NEW_LINE prodOdd *= digitOdd NEW_LINE n //= 10 NEW_LINE DEDENT if ( productEqual == prodOdd ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 432424 NEW_LINE if ( productEqual ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE from itertools import product NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( n , k ) : NEW_LINE INDENT c = 0 NEW_LINE d = { '9' : '9' , '9' : '9' , '9' : '9' , '9' : '9' , '9' : '9' , '9' : '9' , '9' : '9' , '9' : '9' , '9' : '9' , '9' : '9' , '9' : '9' , '9' : '9' , '9' : '9' , '9' : '9' , '9' : '9' } NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE c += 1 NEW_LINE DEDENT print ( ' ' . join ( map ( str , solve ( n , k ) ) ) ) NEW_LINE DEDENT
def checkEEqual ( arr , n , l , r ) : NEW_LINE INDENT if ( arr [ r ] == 1 ) : NEW_LINE INDENT print ( " even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " even " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE checkEqual ( arr , n , 1 , 3 ) NEW_LINE
W , H , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if ( W - r ) + ( H - r ) <= W : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( W - r ) <= W - r : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( isPrime ( n % i ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minNumber ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( isPrime ( sum ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( sum ) NEW_LINE return num NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minNumber ( arr , n ) ) NEW_LINE DEDENT
import math as mt NEW_LINE def compositeProduct ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime [ 0 ] = 1 NEW_LINE prime [ 1 ] = 1 NEW_LINE prime [ 1 ] = 1 NEW_LINE prime [ 1 ] = 1 NEW_LINE prime [ 1 ] = 1 NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( max_val ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == 1 ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( compositeProduct ( arr , n ) ) NEW_LINE
while True : NEW_LINE INDENT try : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if a > b : NEW_LINE INDENT print ( a , b ) NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] == " mak " : NEW_LINE INDENT print ( s [ 1 ] ) NEW_LINE DEDENT elif s [ 0 ] == " mak " : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " FAMPAG " ) NEW_LINE DEDENT DEDENT
def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left [ 0 ] NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) NEW_LINE ans = ans + ( d * ( k + 1 ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 10 , 10 , 14 ] NEW_LINE q = 3 NEW_LINE q = 3 NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( findSum ( arr , n , q ) , end = " ▁ " ) NEW_LINE DEDENT
def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - i + 1 ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if ( int ( z ) == int ( z ) ) : NEW_LINE INDENT x = i / a NEW_LINE y = j / b NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT n = 10 NEW_LINE a = 5 NEW_LINE b = 3 NEW_LINE c = 3 NEW_LINE print ( maxResult ( n , a , b , c ) ) NEW_LINE
h , w = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( h ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i NEW_LINE DEDENT return ans NEW_LINE DEDENT def numberOfPossiblePalindrome ( string , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in string : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT m [ ord ( string [ i ] ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ ord ( string [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT k = 0 NEW_LINE num = 0 NEW_LINE for it in m : NEW_LINE INDENT if ( it % 2 == 0 ) : NEW_LINE INDENT num = ( it + fact ( f ) // 2 ) NEW_LINE k += 1 NEW_LINE DEDENT DEDENT if ( k != 0 ) : NEW_LINE INDENT num = fact ( num ) // fact ( fact ( f ) ) NEW_LINE DEDENT ans = num // k NEW_LINE if ( k != 0 ) : NEW_LINE INDENT ans = ans * k NEW_LINE DEDENT ans = num // k NEW_LINE if ( k != 0 ) : NEW_LINE INDENT ans = ans * k NEW_LINE DEDENT ans = ans * k NEW_LINE if ( k != 0 ) : NEW_LINE INDENT ans = ans * k NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " ababab " NEW_LINE n = len ( string ) NEW_LINE print ( numberOfPossible ( string , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= a [ i + 1 ] : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT elif a [ i ] <= a [ i + 1 ] : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def toggleLastMits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE n = toggleLastMits ( n , m ) NEW_LINE print ( n ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE for i in s : NEW_LINE INDENT if i == ' A ' : NEW_LINE INDENT if i == ' B ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif i == ' B ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if i == ' A ' : NEW_LINE INDENT if i == c + 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i == c + 1 : NEW_LINE INDENT if i == c + 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i == c + 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def first_substring ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE c = 0 ; NEW_LINE mp = dict ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' ▁ ' : NEW_LINE INDENT s [ c ] = s [ i ] ; NEW_LINE c += 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' # ' : NEW_LINE INDENT mp [ i ] = s [ i ] ; NEW_LINE c = i + 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' ▁ ' : NEW_LINE INDENT mp [ i ] = mp [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' ▁ ' : NEW_LINE INDENT mp [ i ] = mp [ i ] ; NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if s [ j ] == ' ▁ ' : NEW_LINE INDENT mp [ j ] = mp [ j ] ; NEW_LINE DEDENT DEDENT return ' ' . join ( mp ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " muts ▁ with ▁ to ▁ to ▁ at ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to ▁ to �
def countConsecutive ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 44522255255 NEW_LINE print ( countConsecutive ( n ) ) NEW_LINE
def findAngle ( n ) : NEW_LINE INDENT triangleAngle = ( n - 2 ) * 180 / n NEW_LINE print ( " Area ▁ angle : ▁ " , end = " " ) NEW_LINE print ( " " , end = " " ) NEW_LINE print ( " " , end = " ▁ " ) NEW_LINE DEDENT n = 10 NEW_LINE findAngle ( n ) NEW_LINE
import math NEW_LINE def nDigitPerfectSquares ( n ) : NEW_LINE INDENT smallest = math . sqrt ( pow ( 10 , n - 1 ) ) NEW_LINE print ( smallest , end = " ▁ " ) NEW_LINE print ( smallest , end = " ▁ " ) NEW_LINE DEDENT n = 4 NEW_LINE nDigitPerfectSquares ( n ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = input ( ) NEW_LINE l = a . count ( ' ) NEW_LINE if a [ 0 ] == ' ) ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT if a [ 0 ] == ' ) ' : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT a . append ( i ) NEW_LINE b . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( a ) ) NEW_LINE print ( ' ' . join ( b ) ) NEW_LINE
import math NEW_LINE def power ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT return p NEW_LINE DEDENT p = power ( 2 , n - 1 ) NEW_LINE if ( sum > k ) : NEW_LINE INDENT return p NEW_LINE DEDENT rem = power ( 2 , n - 1 ) NEW_LINE if ( sum + rem ) : NEW_LINE INDENT return p NEW_LINE DEDENT rem = power ( 2 , n - 1 ) - power ( 2 , n - 1 ) NEW_LINE if ( sum + rem > k ) : NEW_LINE INDENT return ( power ( 2 , n , k ) ) NEW_LINE DEDENT rem = power ( 2 , n - 1 ) - 1 NEW_LINE if ( sum + rem > k ) : NEW_LINE INDENT return ( sum ) NEW_LINE DEDENT rem = power ( 2 , n , k ) - 1 NEW_LINE if ( sum + rem > k ) : NEW_LINE INDENT return ( sum - rem ) NEW_LINE DEDENT rem = power ( 2 , n ) - subtract ( 2 , n , k ) - 1 NEW_LINE if ( sum <= k ) : NEW_LINE INDENT return ( total - subtract ) NEW_LINE DEDENT return ( total - subtract ) - subtract NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 7 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( countSubsequences ( arr , n , k ) ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def Inorder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT inorder ( root . left ) NEW_LINE print ( root . data , end = " ▁ " ) NEW_LINE inorder ( root . left , right ) NEW_LINE return inorder ( root . right , right ) NEW_LINE DEDENT def isSame ( root1 , root2 ) : NEW_LINE INDENT if ( root1 == root2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT inorder ( root1 , root2 ) NEW_LINE return inorder ( root1 , root2 ) NEW_LINE DEDENT def isSame ( root1 , root2 ) : NEW_LINE INDENT if ( root1 == root2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def isSame ( root1 , root2 ) : NEW_LINE INDENT if ( root1 == root2 and root2 == root2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( root1 == root2 and root2 == root2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if ( root1 == root2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT root1 = Node ( 3 ) NEW_LINE root1 = Node ( 3 ) NEW_LINE root2 = Node ( 3 ) NEW_LINE root1 . left = Node ( 2 ) NEW_LINE root2 . left . right = Node ( 2 ) NEW_LINE root1 . left . right . left = Node ( 2 ) NEW_LINE root2 . right . left . right = Node ( 2 ) NEW_LINE root1 . right . left . right . right . left . right = Node ( 3 ) NEW_LINE root2 . right . right . right . right . right . left . right = Node ( 2 ) NEW_LINE root1 . right . right . right . right .
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE o = 0 NEW_LINE o = 0 NEW_LINE o = 0 NEW_LINE o = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == " J " : o += 1 NEW_LINE o += 1 NEW_LINE o += o NEW_LINE o += o NEW_LINE o += o NEW_LINE o += o NEW_LINE DEDENT o = o = 0 NEW_LINE o = 0 NEW_LINE o = 0 NEW_LINE o = 0 NEW_LINE o = 0 NEW_LINE o = 0 NEW_LINE o = 0 NEW_LINE o = 0 NEW_LINE o = o = 0 NEW_LINE o = o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o + o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o + o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o = o NEW_LINE o
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE YesNo = lambda b : bool ( [ print ( ' Yes ' ) ] if b else print ( ' No ' ) ) NEW_LINE YESNO = lambda b : bool ( [ print ( ' YES ' ) ] if b else print ( ' NO ' ) ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE def main ( ) : NEW_LINE INDENT N = input ( ) NEW_LINE S = input ( ) NEW_LINE if S == ' S ' : NEW_LINE INDENT if S [ - 1 ] == ' S ' : NEW_LINE INDENT if S [ - 1 ] == ' S ' : NEW_LINE INDENT if S [ - 1 ] == ' S ' : NEW_LINE INDENT S = S [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT S [ - 1 ] = S [ - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if S [ - 1 ] == ' S ' : NEW_LINE INDENT S [ - 1 ] = S [ - 1 ] + S [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT S [ - 1 ] = S [ - 1 ] + S [ - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if S [ - 1 ] == ' S ' : NEW_LINE INDENT S [ - 1 ] = S [ - 1 ] + S [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT S [ - 1 ] = S [ - 1 ] + S [ - 1 ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if S [ - 1 ] == ' S ' : NEW_LINE INDENT S = S [ - 1 ] + S [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT S = S [ - 1 ] + S [ - 1 ] NEW_LINE DEDENT DEDENT if S [ - 1 ] == ' S ' : NEW_LINE INDENT S = S
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def add ( self , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def findlen ( head ) : NEW_LINE INDENT global count NEW_LINE n = len ( head ) NEW_LINE cnt = 0 NEW_LINE curr = 0 NEW_LINE while ( curr != n ) : NEW_LINE INDENT cnt += 1 NEW_LINE curr = curr NEW_LINE curr = curr NEW_LINE DEDENT return cnt NEW_LINE DEDENT def convertLen ( head ) : NEW_LINE INDENT l = [ ] NEW_LINE curr = 0 NEW_LINE i = 0 NEW_LINE while ( curr != len ( head ) ) : NEW_LINE INDENT curr += 1 NEW_LINE curr = curr . next NEW_LINE curr = curr . next NEW_LINE DEDENT return l NEW_LINE DEDENT def convertLen ( h ) : NEW_LINE INDENT l = len ( head ) NEW_LINE i = 0 NEW_LINE while ( cnt != 0 ) : NEW_LINE INDENT arr [ i ] = curr . next NEW_LINE curr = curr . next NEW_LINE DEDENT print ( " \n " . join ( arr ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT head = 1 NEW_LINE head = newLen ( ) NEW_LINE head = newLen ( 2 ) NEW_LINE head = newLen ( head ) NEW_LINE head = newLen ( head ) NEW_LINE head = newLen ( head ) NEW_LINE head = newLen ( head ) NEW_LINE head = newLen ( head ) NEW_LINE head = newLen ( head ) NEW_LINE head = newLen ( head ) NEW_LINE head = newLen ( head ) NEW_LINE head = newLen ( head ) NEW_LINE head = newLen ( head ) NEW_LINE head = newLen ( head ) NEW_
def nonDecimal ( n ) : NEW_LINE INDENT a = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j ] NEW_LINE DEDENT DEDENT return a [ n ] [ 0 ] NEW_LINE DEDENT n = 2 NEW_LINE print ( " Non - - - decreasing ▁ digits ▁ = " , noDecimal ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ a [ i ] ] = ( i + a [ i ] ) % n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if d [ a [ i ] ] == 0 : NEW_LINE INDENT d [ a [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ a [ i ] ] = ( i + a [ i ] ) % n NEW_LINE DEDENT DEDENT if d [ a [ i ] ] == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def minMoves ( self , nums ) : NEW_LINE INDENT if len ( nums ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT nums = sorted ( nums ) NEW_LINE ans = 0 NEW_LINE for nums in nums : NEW_LINE INDENT ans += nums - min ( nums ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 ] NEW_LINE out = sObj . minMoves ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( b - a ) % 2 == 0 : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT
def firstSetBit ( n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT n = 12 NEW_LINE print ( firstSetBit ( n ) ) NEW_LINE
MAX_CHAR = 256 NEW_LINE def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE firstIndice = [ 0 ] * ( MAX_CHAR ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT firstIndice [ ord ( str [ i ] ) ] = i NEW_LINE if ( firstIndice [ ord ( str [ i ] ) - 1 ] == - 1 ) : NEW_LINE INDENT firstIndice [ ord ( str [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - firstIndice - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT str = " abba " NEW_LINE print ( maximumChars ( str ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( [ a , b ] ) NEW_LINE DEDENT l . sort ( key = lambda x : x [ 1 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , l [ i ] [ 0 ] - l [ i ] [ 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def findArea ( a ) : NEW_LINE INDENT area = ( 5 * math . sqrt ( 3 ) * a * a ) NEW_LINE return area NEW_LINE DEDENT def findVolume ( a ) : NEW_LINE INDENT volume = ( 5 / 12 ) * a * a * a * a * a * a * a * a * a * a * a * a * a * a ) NEW_LINE return volume NEW_LINE DEDENT a = 5 NEW_LINE print ( " Area : " , findVolume ( a ) ) NEW_LINE
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT pYDEV = [ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE def calc_polyrecipe_polyquet ( a , b ) : NEW_LINE INDENT sum = sum ( a * b [ i ] for i in range ( 0 , len ( a ) ) ) NEW_LINE return sum ( sum ) / sum ( sum ) NEW_LINE DEDENT def sum ( sum ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT sum += calc_polyrecipe_polyquet ( sum , a [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def sum ( sum ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT sum += calc_polyp ( a [ i ] * a [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def Even * Even = 6 ; NEW_LINE Even = False ; NEW_LINE Even = N / 2 ; NEW_LINE Even = N - Even ; NEW_LINE print ( Even * Even ) ; NEW_LINE
def solve ( M , N , s ) : NEW_LINE INDENT if ( N % s == 0 ) : NEW_LINE INDENT N = N / s NEW_LINE DEDENT else : NEW_LINE INDENT N = ( N / s ) + 1 NEW_LINE DEDENT if ( M % s == 0 ) : NEW_LINE INDENT M = M / s NEW_LINE DEDENT else : NEW_LINE INDENT M = ( M / s ) + 1 NEW_LINE DEDENT return M * N NEW_LINE DEDENT N = 12 NEW_LINE M = 13 NEW_LINE s = 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT return b NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT return gcd ( b % a , a ) NEW_LINE DEDENT def countPairs ( a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( lcd ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE
a , b , c , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a + b + c + d ) == ( a + b + c ) or ( a + b + c + d ) == ( b + c + d ) or ( a + b + c + d ) == ( a + c + d ) or ( b + c + d ) == ( a + b + d ) or ( a + c + d ) == ( a + b + d ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def _opcnt ( number ) : NEW_LINE INDENT counter = 0 NEW_LINE while ( number ) : NEW_LINE INDENT if ( number % 2 == 1 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT number = number // 2 NEW_LINE DEDENT return counter NEW_LINE DEDENT def maximize ( a ) : NEW_LINE INDENT n = _opcnt ( a ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = res | ( 1 << ( 32 - i ) ) NEW_LINE DEDENT return abs ( res ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 1 NEW_LINE print ( maximize ( a ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if a [ i ] <= k : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE while a != b : NEW_LINE INDENT if a > b : NEW_LINE INDENT a -= 2 NEW_LINE b -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT a -= 2 NEW_LINE b -= 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def xorQueries ( self , arr , queries ) : NEW_LINE INDENT res = [ 0 ] * len ( queries ) NEW_LINE for i in range ( 1 , len ( queries ) ) : NEW_LINE INDENT arr [ i ] = queries [ i - 1 ] ^ arr [ i ] NEW_LINE res [ i ] = arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE queries = [ 1 , 3 , 4 , 8 ] NEW_LINE queries = [ [ 0 , 1 , 2 ] , [ 0 , 3 ] , [ 0 , 3 ] ] NEW_LINE queries = [ [ 0 , 1 , 2 ] , [ 0 , 3 ] , [ 0 , 3 ] ] NEW_LINE out = sObj . xorQueries ( queries ) NEW_LINE print ( out ) NEW_LINE DEDENT
def encodedChar ( string , k ) : NEW_LINE INDENT expanded = " " NEW_LINE temp = " " NEW_LINE freq = " " NEW_LINE freq = " " NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT temp += string [ i ] NEW_LINE DEDENT while ( i < len ( string ) and string [ i ] <= '0' ) : NEW_LINE INDENT temp += string [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( string ) and string [ i ] <= '0' ) : NEW_LINE INDENT freq = freq * 10 + string [ i ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 ) : NEW_LINE INDENT expanded = freq * 10 + string [ j ] NEW_LINE i += 1 NEW_LINE DEDENT if ( freq == 0 ) : NEW_LINE INDENT expanded += string [ k - 1 ] NEW_LINE DEDENT return expanded NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abcc" NEW_LINE k = 21 NEW_LINE print ( encodedChar ( str , k ) ) NEW_LINE DEDENT
def printPossible ( a , b , c ) : NEW_LINE INDENT if ( ( a + b ) % 2 != 0 or a + c < c ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT a = 2 NEW_LINE b = 4 NEW_LINE c = 2 NEW_LINE printPossible ( a , b , c ) NEW_LINE
def summation ( n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) // 2 NEW_LINE sign = 1 if ( n + 1 % 2 == 0 ) else - 1 NEW_LINE result_sum = sign * abs ( sign ) NEW_LINE return result_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2 NEW_LINE print ( summation ( N ) ) NEW_LINE DEDENT
def sortSquares ( arr , n ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE n = len ( arr ) NEW_LINE print ( " After ▁ sort ▁ " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ - 6 , - 3 , - 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " After ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
n , t = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if l [ i - 1 ] > 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = N NEW_LINE cnt = 0 NEW_LINE for a in A : NEW_LINE INDENT cnt += a NEW_LINE if cnt == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) - ( 4 * num ) - ( 4 * num ) NEW_LINE d = ( - b * num ) - ( 4 * num ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + ( 4 * num ) ) / ( 2 * a ) NEW_LINE root2 = ( - b * a ) / ( 2 * a ) NEW_LINE if ( root1 > 0 and ( root2 ) == root2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root1 > 0 and ( root2 ) == root2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT num = 55 NEW_LINE if ( isTriangular ( num ) ) : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ a ▁ is ▁ triangular ▁ number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ is ▁ is ▁ triangular ▁ number " ) NEW_LINE DEDENT
def printNumberWithDP ( k , d ) : NEW_LINE INDENT if ( d == 0 and k != 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d ) NEW_LINE k -= 1 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT k = 4 NEW_LINE d = 4 NEW_LINE printNumberWithDP ( k , d ) NEW_LINE
N = 3 NEW_LINE def rotateMatrix ( mat ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE rotateMatrix ( mat ) NEW_LINE
import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import fractions NEW_LINE import itertools NEW_LINE import copy NEW_LINE from collections import Counter NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( n // 500 * 500 ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE N = int ( next ( tokens ) ) NEW_LINE solve ( N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def getProduct ( n ) : NEW_LINE INDENT product = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 4513 NEW_LINE print ( getProduct ( n ) ) NEW_LINE
while True : NEW_LINE INDENT try : NEW_LINE INDENT b , c , g , b , c , s = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT g = b + c + g * 3 NEW_LINE g = c + g * 3 NEW_LINE g = c + g * 3 NEW_LINE g = c + g * 3 NEW_LINE g = c + g * 3 NEW_LINE g = c + g * 3 NEW_LINE g = c + g * 3 NEW_LINE g = c + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g + g * 3 NEW_LINE g = g * 3 NEW_LINE g = g * 3 NEW_LINE g = g * 3 NEW_LINE g = g * 3 NEW_LINE g = g * 3 NEW_LINE g = g * 3 NEW_LINE g = g * 3 NEW_LINE g = g * 3 NEW_LINE g =
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dp = [ [ 1 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ i ] = ( dp [ i - 1 ] [ i - 1 ] + dp [ i - 1 ] [ i - 1 ] ) % mod NEW_LINE DEDENT print ( ( dp [ n ] [ - 1 ] ) % mod ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
PI = 3.14159265 NEW_LINE def length_ropepe ( r ) : NEW_LINE INDENT return ( 2 * PI * r ) + 6 * r * r NEW_LINE DEDENT r = 7 NEW_LINE print ( length_rope ( r ) ) NEW_LINE
def reverseDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT rev_num = reverseDigits ( n ) NEW_LINE if ( rev_num == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 4562 NEW_LINE print ( " is ▁ a ▁ a ▁ Palindrome ▁ Palindrome ▁ number ▁ is ▁ " , n , " ▁ a ▁ Palindrome ▁ " , isPalindrome ( n ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def addStrings ( self , num1 , num2 ) : NEW_LINE INDENT s2 = str ( num2 ) NEW_LINE carry = 0 NEW_LINE for i in range ( len ( num1 ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT x = 0 NEW_LINE y = ord ( num1 [ i ] ) - ord ( '0' ) NEW_LINE if x < 0 or y < 0 : NEW_LINE INDENT x = 0 NEW_LINE y = int ( x1 [ i ] ) - ord ( '0' ) NEW_LINE carry = ( ( x + carry ) - ord ( '0' ) ) % 10 NEW_LINE carry = ( x + carry ) % 10 NEW_LINE carry = ( ( x + carry ) % 10 ) // 10 NEW_LINE carry = ( x + carry ) // 10 NEW_LINE carry = ( ( x + carry ) // 10 NEW_LINE carry = ( x + carry ) // 10 NEW_LINE carry = ( x + carry ) // 10 NEW_LINE carry = ( ( x + carry ) // 10 ) % 10 NEW_LINE carry = ( x + carry ) // 10 NEW_LINE carry = ( x + carry ) // 10 NEW_LINE carry = ( x + carry ) // 10 NEW_LINE DEDENT return carry NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE num1 = "11" NEW_LINE out = sObj . addStrings ( num1 , num2 ) NEW_LINE print ( out ) NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , int ( n ** .5 ) + 1 ) : NEW_LINE INDENT if n % i != 0 : NEW_LINE INDENT if i * i != n : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT DEDENT if sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( " The ▁ all ▁ all ▁ all ▁ all ▁ numbers ▁ is " ) NEW_LINE DEDENT
import math NEW_LINE def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT p = x * x NEW_LINE if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT y = 2 ** y NEW_LINE p = pow ( x , y ) NEW_LINE while ( p <= n and p <= 0 ) : NEW_LINE INDENT if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT y += 1 NEW_LINE p = pow ( x , y ) NEW_LINE p = pow ( x , y ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
from math import gcd NEW_LINE def findTwoNumbers ( sum , gcd , sum ) : NEW_LINE INDENT if ( gcd ( gcd , sum ) == gcd and sum != gcd ) : NEW_LINE INDENT print ( " a ▁ = ▁ " , str ( gcd ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " a ▁ = ▁ " , str ( sum ) ) NEW_LINE DEDENT DEDENT sum = 8 NEW_LINE gcd = 2 NEW_LINE findTwoNumbers ( sum , gcd ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for test in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE t = 1 NEW_LINE while t <= a : NEW_LINE INDENT t += 1 NEW_LINE if ( t <= a and b <= c ) : NEW_LINE INDENT t += 1 NEW_LINE DEDENT else : NEW_LINE INDENT t += 1 NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT
N , A , B , C , D = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( ( A * B , C * D ) // N , ( C * D ) // N , ( C * D ) // N ) ) NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = countSetBits ( arr [ i ] ) NEW_LINE if count in m . keys ( ) : NEW_LINE INDENT m [ count ] += 1 NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in m . keys ( ) : NEW_LINE INDENT value = m [ i ] NEW_LINE result += ( ( value * ( value - 1 ) ) // 2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 7 , 5 , 3 , 9 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( totalPairs ( arr , n ) ) NEW_LINE
def center_hexcagonal_cagonal_cagonal_cagonal_num ( n ) : NEW_LINE INDENT return 8 * n - 8 * n + 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( " th ▁ centered ▁ centered ▁ centered ▁ centered ▁ centered ▁ centered ▁ hex_hex_cagonal_num ( n ) ) NEW_LINE
Q , H , S , D , N = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( min ( Q * 4 , H , S ) + ( ( Q * 4 ) // 2 ) * D ) ) NEW_LINE
def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE product = R - L + 1 NEW_LINE factor = factor // 9 NEW_LINE rem = factor // 9 NEW_LINE for i in range ( R , R - rem ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( ( a + b + c ) * c + d ) * ( b + d ) ) NEW_LINE
def Solution ( A ) : NEW_LINE INDENT ans = 2 NEW_LINE n = len ( A ) NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT llap = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT llap [ i ] = 2 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k < n ) : NEW_LINE INDENT if ( A [ i ] + A [ k ] == 2 * A [ j ] ) : NEW_LINE INDENT llap [ k ] = max ( llap [ k ] + 1 , llap [ j ] ) NEW_LINE ans = max ( ans , llap [ k ] ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 9 , 4 , 7 , 10 ] NEW_LINE print ( Solution ( a ) ) NEW_LINE DEDENT
def minimumChanges ( arr , n , d ) : NEW_LINE INDENT maxFreq = - 1 NEW_LINE freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = arr [ i ] - ( i * d ) NEW_LINE if ( freq [ a0 ] > maxFreq ) : NEW_LINE INDENT freq [ a0 ] += 1 NEW_LINE DEDENT if ( freq [ a0 ] > maxFreq ) : NEW_LINE INDENT maxFreq [ a0 ] = freq [ a0 ] NEW_LINE DEDENT DEDENT return ( n - maxFreq ) NEW_LINE DEDENT n , d = 5 , 1 NEW_LINE arr = [ 1 , 3 , 3 , 4 ] NEW_LINE arr = [ 1 , 3 , 3 , 4 ] NEW_LINE print ( minimumChanges ( arr , n , d ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT l1 = sorted ( l ) NEW_LINE m = 1000000001 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] [ 0 ] < l [ i ] [ 1 ] and l [ i ] [ 2 ] < l [ i ] [ 2 ] : NEW_LINE INDENT m = l [ i ] [ 2 ] NEW_LINE DEDENT DEDENT print ( m + 1 ) NEW_LINE
def countPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( a [ i ] + y < b [ i ] ) : NEW_LINE INDENT if ( a [ i ] + y <= b [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 1 NEW_LINE y = 4 NEW_LINE a = [ 1 , 5 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( countPoints ( n , m , a , b , x , y ) ) NEW_LINE DEDENT
def multiplyWith3Point ( x ) : NEW_LINE INDENT return ( x << 1 ) + x NEW_LINE DEDENT x = 4 NEW_LINE print ( multiplyWith3Point ( x ) ) NEW_LINE
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += a [ i ] - a [ i ] NEW_LINE if s <= s : NEW_LINE INDENT ans = - 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ans <= s : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 NEW_LINE maxi = 1 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) NEW_LINE return maxi NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " cccddddeefeddede9" NEW_LINE print ( longestSubstring ( s ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE K = int ( input ( ) ) NEW_LINE N = K // N NEW_LINE A = [ 0 ] * N NEW_LINE B = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ i ] += 1 NEW_LINE DEDENT B . reverse ( ) NEW_LINE ans = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans [ i ] += B [ i ] NEW_LINE DEDENT print ( N ) NEW_LINE print ( ans [ : N ] ) NEW_LINE
def zeroUpto ( digits ) : NEW_LINE INDENT first = ( ( pow ( 10 , digits ) - 1 ) // 8 ) // 8 NEW_LINE second_zero = ( ( int ) ( ( pow ( 10 , digits ) - 1 ) / 8 ) ) // 8 NEW_LINE return ( first_zero - second_zero ) * ( first_zero - 1 ) // 8 NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT return ( int ( num ) - 48 ) * ( int ) ( num ) - 48 ) NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT return ( ( int ) ( num ) - 48 ) * ( int ( num ) - 48 ) NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT return ( num ) - 48 * ( int ) ( num ) NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT return ( num - 48 ) * ( int ( num ) - 1 ) NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT return ( num [ : len ( num ) - 1 ] - 1 ) NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE total = 0 NEW_LINE remaining = 0 NEW_LINE remaining = 0 NEW_LINE remaining = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT no = num * 10 + ( int ( num [ i ] ) - 1 ) * ( pow ( 10 , int ( num [ i ] ) - 1 ) ) NEW_LINE if i != 0 : NEW_LINE INDENT remaining = remaining + ( int ( num [ i ] ) - 1 ) * ( remaining - remaining - 1 ) ) NEW_LINE if i != 0 : NEW_LINE INDENT remaining = remaining + ( remaining - remaining - remaining - remaining - remaining - remaining - remaining - remaining - remaining - remaining - 1 ) NEW_LINE DEDENT remaining = remaining - remaining - remaining - remaining - remaining - remaining - remaining - remaining - remaining - remaining NEW_LINE DEDENT remaining = zero - remaining - remaining NEW_LINE return ans NEW_LINE DEDENT num = "107 ▁ of ▁ " , " , " , " , " , " , " , "
from math import sqrt NEW_LINE def circle ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = int ( sqrt ( 2 ) ) / 3 NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = ( 3.14 * pow ( r , 2 ) * h ) / 3 NEW_LINE return V NEW_LINE DEDENT a = 5 NEW_LINE print ( circle ( a ) ) NEW_LINE
def Prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( n ** .5 ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkSumPrime ( str ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT summ += abs ( ord ( str [ i - 1 ] ) - ord ( str [ i - 1 ] ) ) NEW_LINE DEDENT if ( Prime ( summ ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 142 NEW_LINE if ( checkSumPrime ( str ) ) : NEW_LINE INDENT print ( " Prime " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime " ) NEW_LINE DEDENT DEDENT
def sum ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return 1 / n NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT sum = sum ( 8 ) NEW_LINE print ( sum ( sum ( 8 ) ) ) NEW_LINE
def countElements ( p , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT elif ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT p = [ 2 , 5 , 1 , 3 , 4 ] ; NEW_LINE n = len ( p ) ; NEW_LINE print ( countElements ( p , n ) ) ; NEW_LINE
a , b = input ( ) . split ( ) NEW_LINE a = a [ 0 ] NEW_LINE b = b [ 1 ] NEW_LINE c = a [ 0 ] NEW_LINE d = b [ 1 ] NEW_LINE if a [ 0 ] > b [ 0 ] : NEW_LINE INDENT print ( " < " ) NEW_LINE DEDENT elif a [ 0 ] > b [ 0 ] : NEW_LINE INDENT print ( " = " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " = " ) NEW_LINE DEDENT
def findVolume ( l , b , h ) : NEW_LINE INDENT volume = ( l * b ) / 2 NEW_LINE return volume NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , b , h = 18 , 12 , 12 NEW_LINE print ( " Volume ▁ of ▁ triangular ▁ prism : ▁ " , findVolume ( l , b , h ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( i ) - 97 ] += 1 NEW_LINE DEDENT a . sort ( ) NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += min ( k , a [ i ] ) NEW_LINE DEDENT DEDENT print ( k * ( n - k ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT i = 143 NEW_LINE j = i * ( i + 1 ) // 2 NEW_LINE k = i * ( j - 1 ) // 2 NEW_LINE ans = min ( ans , k ) NEW_LINE if ( ans == str ( i ) ) : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT i = i * ( k - 1 ) // 2 NEW_LINE ans = min ( ans , k ) NEW_LINE while ( i <= n ) : NEW_LINE INDENT ans = min ( ans , k + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT if ( ans == str ( i ) ) : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT i = i * ( k - 1 ) // 2 NEW_LINE ans = min ( ans , k + 1 ) NEW_LINE if ( ans == str ( ans ) ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT i = i * ( k - 1 ) NEW_LINE if ( ans == str ( ans ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math as mt NEW_LINE def maxPrimefactorNumber ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr = [ False ] * ( N + 1 ) NEW_LINE res = 0 NEW_LINE res = 0 NEW_LINE for p in range ( 2 , int ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( arr [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , N , p ) : NEW_LINE INDENT arr [ i ] = True NEW_LINE DEDENT prod *= p NEW_LINE if ( prod > N ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 500 NEW_LINE print ( maxPrimefactorNumber ( N ) ) NEW_LINE DEDENT
import math as mt NEW_LINE def checkDivisors ( a ) : NEW_LINE INDENT m = a [ 0 ] NEW_LINE for i in range ( 0 , mt . ceil ( mt . sqrt ( a ) ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( x // i != i ) : NEW_LINE INDENT b . append ( x // i ) NEW_LINE if ( x // i != i ) : NEW_LINE INDENT b . append ( x // i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 6 , 6 , 4 , 8 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkDivisors ( arr , N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def subArray ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE subArray ( arr ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 6 == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = n // 6 - 1 NEW_LINE y = n // 6 - 1 NEW_LINE m = ( n // 6 ) * 2 + ( n // 6 - 1 ) * 2 NEW_LINE m = ( n // 6 - 1 ) * 2 NEW_LINE if m % 6 == 2 : NEW_LINE INDENT x = m NEW_LINE DEDENT else : NEW_LINE INDENT x = m NEW_LINE DEDENT DEDENT print ( x , y ) NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += ( arr [ i ] * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT
def findAnswer ( n , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n // 2 ) : NEW_LINE INDENT sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 53 , 28 , 143 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAnswer ( n , arr ) ) NEW_LINE
def findSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = arr [ 0 ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n ) ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getDepthLargest ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT q . append ( root ) NEW_LINE result = None NEW_LINE result = None NEW_LINE q . append ( root ) NEW_LINE result = None NEW_LINE while ( q . left ) : NEW_LINE INDENT temp = q . pop ( 0 ) NEW_LINE if ( temp . left and temp . right ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE if ( temp . left and temp . right ) : NEW_LINE INDENT result = temp . left NEW_LINE DEDENT DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . right . right = Node ( 6 ) NEW_LINE root . right . right = Node ( 7 ) NEW_LINE root . right . right . right . right = Node ( 6 ) NEW_LINE root . right . right . right = Node ( 6 ) NEW_LINE root . right . right . left . right = Node ( 6 ) NEW_LINE root . right . right . right . right . right . right . right = Node ( 6 ) NEW_LINE root . right . right . right . right . right . right = Node ( 6 ) NEW_LINE root . right . right . right . right . right = Node ( 6 ) NEW_LINE root . right . right . right . right . right . left = Node ( 7 ) NEW_LINE result = getDepthLargest ( root ) NEW_LINE if result != None : NEW_LINE INDENT print ( " No ▁ Left ▁ Left ▁ Left ▁ Left ▁ Left ▁ Left ▁ Left ▁ Left ▁ Left ▁ : ▁ left ▁ Left ▁ Left ▁ Left ▁ : ▁ right ▁
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getDepthestRight ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ None ] * ( root . left ) NEW_LINE result = None NEW_LINE result = None NEW_LINE while ( q [ 0 ] != None ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE if ( temp . right ) : NEW_LINE INDENT result = temp . right NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT DEDENT root = Node ( 2 ) NEW_LINE root . left = Node ( 3 ) NEW_LINE root . right = Node ( 5 ) NEW_LINE root . right . right = Node ( 6 ) NEW_LINE root . right . right = Node ( 7 ) NEW_LINE root . right . right . right = Node ( 7 ) NEW_LINE root . right . right . right . right . right = Node ( 7 ) NEW_LINE root . right . right . right . right . right . right . right = Node ( 6 ) NEW_LINE root . right . right . right . right . right . right = Node ( 7 ) NEW_LINE root . right . right . right = Node ( 7 ) NEW_LINE root . right . right . right . right = Node ( 6 ) NEW_LINE root . right . right . right . right . right = Node ( 6 ) NEW_LINE root . right . right . right . right . right . right = Node ( 7 ) NEW_LINE root . right . right . right . right . right = Node ( 7 ) NEW_LINE result = getDepthestRightRight ( root ) NEW_LINE if result != None : NEW_LINE INDENT print ( " No ▁ Right ▁ Left ▁ Left ▁ leaf ▁ leaf ▁ leaf ▁ leaf ▁
n = int ( input ( ) ) NEW_LINE print ( 2 if n == 1 else 2 ) NEW_LINE
from math import gcd NEW_LINE def printRatio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT temp = c NEW_LINE c = d NEW_LINE d = a NEW_LINE if ( a * c > a * d ) : NEW_LINE INDENT temp = c NEW_LINE DEDENT if ( a * c > a * d ) : NEW_LINE INDENT temp = c NEW_LINE DEDENT lcm = lcm // c NEW_LINE b = b // c NEW_LINE d = a * x NEW_LINE k = k // d NEW_LINE return ( b + d ) NEW_LINE DEDENT a , b , c = 4 , 3 , 2 NEW_LINE printRatio ( a , b , c , d ) NEW_LINE
def maxsum_SIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ sum ▁ : ▁ " , maxsum_SIS ( arr , n ) ) NEW_LINE
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % bCDCD ) NEW_LINE DEDENT def findMaxSumUtil ( arr , n ) : NEW_LINE INDENT finalGCD = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT finalGCD = GCD ( arr [ i ] , finalGCD ) NEW_LINE DEDENT return ( maxElement * n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 8 , 20 , 12 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT t = b % b NEW_LINE a = a % b NEW_LINE DEDENT return a NEW_LINE DEDENT def findMinDiff ( a , b , x , y ) : NEW_LINE INDENT g = gcd ( a , b ) NEW_LINE diff = abs ( x - y ) % g NEW_LINE return min ( diff , g - diff ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 20 NEW_LINE b = 52 NEW_LINE x = 5 NEW_LINE print ( findMinDiff ( a , b , x , y ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m , h = map ( int , input ( ) . split ( ) ) NEW_LINE x , y , n = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , w = map ( int , input ( ) . split ( ) ) NEW_LINE if x <= y <= w and y <= x and y <= w : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def divisibleby36 ( n ) : NEW_LINE INDENT if ( n == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT n1 = "00" + str ( n1 ) NEW_LINE l += 2 NEW_LINE DEDENT elif ( n % 3 == 2 ) : NEW_LINE INDENT n1 = "00" + str ( n1 [ ( n - 2 ) - 48 ] ) NEW_LINE l += 1 NEW_LINE DEDENT n = n NEW_LINE gsum = 0 NEW_LINE gsum = 0 NEW_LINE while ( l != 0 ) : NEW_LINE INDENT gvalue = ( n [ l - 1 ] - 48 ) * 100 + ( n [ l - 2 ] - 48 ) * 10 NEW_LINE gsum += ( int ) * 100 NEW_LINE gsum += ( int ) ( n [ l - 3 ] - 48 ) * 10 NEW_LINE gsum += gsum NEW_LINE DEDENT if ( gsum >= 1000 ) : NEW_LINE INDENT return ( int ) ( gsum % 37 ) * 100 NEW_LINE DEDENT else : NEW_LINE INDENT gsum += gum NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "89797979" NEW_LINE if ( divisibleby36 ( s ) ) : NEW_LINE INDENT print ( divisibleby36 ( s ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( divisibleby36 ( s ) ) ) NEW_LINE DEDENT DEDENT
n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if ( y - n + 1 ) * ( y - n + 1 ) // 2 < x : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT if ( X [ i ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT def findMinCost ( X , Y , cost , n ) : NEW_LINE INDENT m = len ( X ) NEW_LINE len_cs = lcs ( X , Y , m , n ) NEW_LINE len_cs = lcs ( m , Y , m , n ) NEW_LINE return costX * ( m - len_cs ) + cost * ( m - len_cs ) NEW_LINE DEDENT X = " ef " NEW_LINE Y = " gf " NEW_LINE print ( " Minimum ▁ Cost ▁ to ▁ 2 ▁ to ▁ 2 ▁ = ▁ " , findMinCost ( X , Y , m , n ) ) NEW_LINE
def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) // 2 NEW_LINE return base * ( base + 1 ) // 2 NEW_LINE DEDENT base = 8 NEW_LINE print ( numberOfSquares ( base ) ) NEW_LINE
import math NEW_LINE def rmsValue ( arr , n ) : NEW_LINE INDENT square = 0 NEW_LINE sum = 0 NEW_LINE root = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT square += pow ( arr [ i ] , 2 ) NEW_LINE DEDENT mean = ( square / ( n ) ) NEW_LINE root = ( square / ( n ) ) NEW_LINE root = round ( square ) NEW_LINE return root NEW_LINE DEDENT arr = [ 10 , 4 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( rmsValue ( arr , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE m , n = map ( int , input ( ) . split ( ) ) NEW_LINE P = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE P . sort ( ) NEW_LINE dp = [ float ( ' inf ' ) ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c , e = P [ i ] NEW_LINE for j in range ( c - e ) : NEW_LINE INDENT if ( j - e ) % c == 0 : NEW_LINE INDENT dp [ j ] = min ( dp [ j - e ] , dp [ j - e ] + e ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ j ] = max ( dp [ j - e ] , dp [ j - e ] + e ) NEW_LINE DEDENT DEDENT DEDENT print ( max ( dp ) ) NEW_LINE
import heapq NEW_LINE from collections import deque NEW_LINE from enum import Enum NEW_LINE import sys NEW_LINE import math NEW_LINE from _heapq import heappush , heappop NEW_LINE import copy NEW_LINE BIG_NUM = 2000000000 NEW_LINE HUGE_NUM = 99999999999999999 NEW_LINE MOD = 1000000007 NEW_LINE EPS = 0.000000001 NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE class Info : NEW_LINE INDENT def __init__ ( self , arg_list ) : NEW_LINE INDENT self . arg_list = arg_list NEW_LINE self . arg_list = arg_list NEW_LINE self . arg_list = arg_list NEW_LINE DEDENT def __lt__ ( self , arg_list ) : NEW_LINE INDENT self . arg_list = arg_list NEW_LINE self . arg_list = arg_list NEW_LINE self . arg_list = arg_list NEW_LINE self . arg_list = arg_list NEW_LINE self . arg_list = arg_list NEW_LINE self . arg_list = arg_list NEW_LINE DEDENT DEDENT def is_sort ( self , arg_list ) : NEW_LINE INDENT if self . arg_list [ arg_list ] == None : NEW_LINE INDENT return True NEW_LINE DEDENT arg_list = arg_list [ arg_list [ arg_list [ arg_list [ arg_list ] ] NEW_LINE return False NEW_LINE DEDENT def is_sort ( self , arg_list ) : NEW_LINE INDENT arg_list = arg_list [ arg_list [ arg_list [ arg_list [ arg_list [ arg_list [ arg_list [ arg_list ] ] ] for arg in arg_list ] ] NEW_LINE if arg_list [ arg_list [ arg_list ] ] == None : NEW_LINE INDENT return True NEW_LINE DEDENT arg_list . append ( arg_list [ arg_list [ arg_list [ arg_list [ arg_list [ arg_list [ arg_list [ arg_list [ arg_list [ arg_list ] ] ] ) NEW_LINE DEDENT DEDENT def is_sort ( self , arg_list )
def maxSum ( arr ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m1 = 0 NEW_LINE m2 = 0 NEW_LINE m2 = 0 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT if ( j // ( m1 ) == 0 ) : NEW_LINE INDENT m1 = max ( m1 , arr [ i ] [ j ] ) NEW_LINE m2 = max ( m1 , arr [ i ] [ j ] ) NEW_LINE DEDENT elif ( ( j // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m // ( m ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : NEW_LINE INDENT m2 = max ( m2 , arr [ i ] [ j ] ) + m3 NEW_LINE DEDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j ] ) + m3 NEW_LINE dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j ] ) + m3 NEW_LINE dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j ] ) NEW_LINE dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j ] ) + m3 NEW_LINE dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j ] ) NEW_LINE dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j ] , dp [ i ] [ j ] ) NEW_LINE dp [ i ] [ j ] = max ( dp [
def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = min ( x1 , x2 ) NEW_LINE x4 = min ( x2 , y3 ) NEW_LINE y6 = min ( x2 , y3 ) NEW_LINE if ( x5 > x4 or y5 > y6 ) : NEW_LINE INDENT print ( " No ▁ intersection ▁ intersection " , " , x2 , " , y2 , " ) NEW_LINE DEDENT x8 = 6 NEW_LINE y8 = 6 NEW_LINE print ( " ( " , x1 , y2 , " , " , y2 , " , " , " , y2 , " ) " ) NEW_LINE x8 = 6 NEW_LINE y8 = 6 NEW_LINE print ( " ( " , x8 , " , " , y1 , " , " , y2 , " ) " ) NEW_LINE x8 = 6 NEW_LINE y8 = 9 NEW_LINE print ( " ( " , x8 , " , " , y8 , " , " , " , y8 , " , " , " , " , y8 , " ) " ) NEW_LINE x8 = 6 NEW_LINE y8 = 9 NEW_LINE findPoints ( x8 , x8 , " , " , " , y1 , " ) " ) NEW_LINE x8 = 6 NEW_LINE findPoints ( x8 , x8 , " , " , " , " , " ) NEW_LINE x8 = 6 NEW_LINE findPoints ( x8 , x8 , " , " , " ) NEW_LINE x8 = 6 NEW_LINE findPoints ( x8 , y1 , " , " , " ) NEW_LINE x8 = 6 NEW_LINE findPoints ( x8 , " , " , " , " , " ) NEW_LINE x8 = 6 NEW_LINE findPoints ( x8 , x1 , " , " ) " ) NEW_LINE x8 = 6 NEW_LINE findPoints ( x8 , " , " , " , " , " ) NEW_LINE x8 = 6 NEW_LINE findPoints ( x8 , " , " , " , " , " , " ) " ) NEW_
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' x ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT print ( abs ( x - x ) // 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' x ' : NEW_LINE INDENT print ( x + x ) NEW_LINE break NEW_LINE DEDENT DEDENT
n , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT x = n - d NEW_LINE y = n - e NEW_LINE if x < 0 : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( y ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def knapSack ( W , valt , valt ) : NEW_LINE INDENT maxratio = - sys . maxsize NEW_LINE maxratio = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( val [ i ] / wt [ i ] ) > maxratioi : NEW_LINE INDENT maxratio = ( val [ i ] / wt [ i ] ) NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT return ( W * maxratioi ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT val = [ 14 , 27 , 44 , 9 ] NEW_LINE wt = [ 6 , 7 , 9 , 9 ] NEW_LINE n = len ( val ) NEW_LINE print ( knapSack ( W , val , val , n ) ) NEW_LINE DEDENT
def AlternateRearrange ( arr , n ) : NEW_LINE INDENT v1 = [ ] ; NEW_LINE v2 = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT v1 . append ( arr [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT index = 0 ; NEW_LINE i = 0 ; NEW_LINE j = 0 ; NEW_LINE flag = False ; NEW_LINE while ( index < n ) : NEW_LINE INDENT if ( flag == True ) : NEW_LINE INDENT arr [ index ] = v1 [ i ] ; NEW_LINE i += 1 ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( flag == True ) : NEW_LINE INDENT arr [ index ] = v2 ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = True ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE flag = False ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 9 , 8 , 10 , 10 , 10 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE AlternateRearrange ( arr , n ) ; NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a >= c and b >= c ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 ; NEW_LINE i = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = i ; NEW_LINE i += 1 ; NEW_LINE DEDENT return binaryNum ; NEW_LINE DEDENT def countFreq ( pat , q ) : NEW_LINE INDENT M = len ( pat ) ; NEW_LINE res = " " ; NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT for j in range ( 0 , M - 1 , - 1 ) : NEW_LINE INDENT if ( t [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT if ( j == pat [ i + j ] ) : NEW_LINE INDENT res += 1 ; NEW_LINE j = 0 ; NEW_LINE DEDENT DEDENT DEDENT return res ; NEW_LINE DEDENT def countOccurrence ( pat , pattern , pattern ) : NEW_LINE INDENT for i in range ( 0 , n - M + 1 ) : NEW_LINE INDENT binary = decToBinary ( arr [ i ] ) ; NEW_LINE print ( countFreq ( pattern , pattern , end = " ▁ " ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 10 , 7 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE pattern = "0" ; NEW_LINE findOccurrence ( arr , n , pattern ) ; NEW_LINE DEDENT
def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT x += ( arr [ i ] & 1 ) NEW_LINE DEDENT print ( min ( x , n - x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE makearrayequalarray ( arr , n ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def findKthLthLthLthL ( self , num ) : NEW_LINE INDENT n = len ( num ) - 1 NEW_LINE mid = len ( num ) - 1 NEW_LINE lo = 0 NEW_LINE hi = len ( num ) - 1 NEW_LINE while lo < hi : NEW_LINE INDENT mid = ( num [ lo ] > num [ lo ] ) NEW_LINE if num [ mid ] < num [ lo ] : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid + 1 NEW_LINE DEDENT DEDENT return num [ mid ] NEW_LINE DEDENT def findKthLthL ( self , num ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( num ) - 1 NEW_LINE while i < j : NEW_LINE INDENT while i < j and num [ j ] < num [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if num [ i ] < num [ j ] : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif num [ j ] > num [ j ] : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 3 , 2 , 1 , 5 , 6 ] NEW_LINE k = 2 NEW_LINE out = sObj . findKthLthLthL ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 NEW_LINE if ( temp % k == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return " NO " NEW_LINE DEDENT n = 98743434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343 ( n ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT k = n % 10 NEW_LINE sum += k NEW_LINE n //= 10 NEW_LINE DEDENT if ( temp % sum == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT return " NO " NEW_LINE DEDENT n = 123 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE
a = input ( ) NEW_LINE b = input ( ) NEW_LINE x = len ( a ) NEW_LINE y = len ( b ) NEW_LINE if x == y : NEW_LINE INDENT print ( " LOSE " ) NEW_LINE DEDENT elif x == y : NEW_LINE INDENT print ( " LOSE " ) NEW_LINE DEDENT elif x == y : NEW_LINE INDENT print ( " LOSE " ) NEW_LINE DEDENT elif x == y : NEW_LINE INDENT print ( " LOSE " ) NEW_LINE DEDENT elif x == y : NEW_LINE INDENT print ( " LOSE " ) NEW_LINE DEDENT elif x == y : NEW_LINE INDENT print ( " LOSE " ) NEW_LINE DEDENT elif x == y : NEW_LINE INDENT print ( " LOSE " ) NEW_LINE DEDENT elif x == y : NEW_LINE INDENT print ( " LOSE " ) NEW_LINE DEDENT elif x == y : NEW_LINE INDENT print ( " LOSE " ) NEW_LINE DEDENT elif x == y : NEW_LINE INDENT print ( " LOSE " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " LOSE " ) NEW_LINE DEDENT
def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , size + 1 ) : NEW_LINE INDENT totalSquare = ( l - size + 1 ) * ( b - size + 1 ) NEW_LINE area = totalSquare * size NEW_LINE totalArea += area NEW_LINE DEDENT return totalArea NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , b = 4 , 3 NEW_LINE print ( calculateAreaSum ( l , b ) ) NEW_LINE DEDENT
def arrange ( N ) : NEW_LINE INDENT if ( N == 1 or N == 3 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE return NEW_LINE DEDENT even = - 1 NEW_LINE odd = - 1 NEW_LINE even = - 1 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT even = N - 1 NEW_LINE even = N - 1 NEW_LINE even = N - 1 NEW_LINE DEDENT while ( odd >= 1 ) : NEW_LINE INDENT print ( even , end = " ▁ " ) NEW_LINE odd = even - 1 NEW_LINE even = even - 1 NEW_LINE DEDENT while ( odd >= 2 ) : NEW_LINE INDENT print ( odd , end = " ▁ " ) NEW_LINE even = even - 2 NEW_LINE odd = even - 2 NEW_LINE even = even - 2 NEW_LINE DEDENT while ( odd >= 2 ) : NEW_LINE INDENT print ( odd , end = " ▁ " ) NEW_LINE even = even - 2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE arrange ( N ) NEW_LINE DEDENT
import sys NEW_LINE def findMinEqualSums ( a , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE sum += a [ i ] NEW_LINE if ( abs ( sum - sum ) < min ) : NEW_LINE INDENT min = abs ( sum - sum ) NEW_LINE DEDENT if ( abs ( sum - sum ) < min ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 2 , 1 , 5 , 7 ] NEW_LINE N = len ( a ) NEW_LINE print ( findMinEqualSums ( a , N ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( n % 3 == 1 ) : NEW_LINE INDENT print ( "12" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "12" , end = " " ) NEW_LINE DEDENT print ( "2" , end = " " ) NEW_LINE DEDENT
def findIntimal ( a , N ) : NEW_LINE INDENT a . sort ( ) NEW_LINE points = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT points += a [ i ] * i NEW_LINE DEDENT return points NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEW_LINE N = len ( a ) NEW_LINE print ( findInt ( a , N ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = [ [ int ( i ) for i in input ( ) . split ( ) ] for _ in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT id , A [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT A . sort ( ) NEW_LINE B = [ id , A [ i ] [ 1 ] for i in range ( N ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] [ 0 ] == B [ i ] [ 0 ] : NEW_LINE INDENT ans += A [ i ] [ 1 ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( reverse = True ) NEW_LINE if ( n > m ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT l . sort ( reverse = True ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( l [ j ] + l [ j ] ) <= m : NEW_LINE INDENT l [ j ] = l [ j ] + l [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT l [ j ] = l [ j ] + l [ j ] NEW_LINE DEDENT DEDENT if ( l [ m - 1 ] + l [ m - 1 ] ) <= m : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def getPairs ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT for j in range ( 0 , len ( a ) ) : NEW_LINE INDENT if ( a [ i ] < a [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT a = [ 2 , 4 , 3 , 1 ] NEW_LINE print ( getPairs ( a ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if k == n : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT ans += '1' NEW_LINE DEDENT else : NEW_LINE INDENT ans += '0' NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a == b or c == d ) or ( a == b or c == d ) or ( a == b or c == d ) or ( a == b or c == d ) or ( a == b or c == d ) or ( a == b or c == d ) or ( a == b or c == d ) or ( a == b or c == d ) or ( a == b or c == d ) or ( a == b or c == d ) or ( a == b or c == d ) or ( a == b or c == d ) or ( a == c or d == d ) or ( a == b or a == c ) or ( b == c or a == d ) or ( a == c or a == b or c == d ) or ( a == c or a == d ) or ( b == c or a == d ) or ( a == b or c == d ) or ( a == c or a == d ) or ( b == c or a == d ) or ( b == c or a == d ) or ( a == c or a == d ) or ( b == c ) or ( a == d ) or ( b == c or a == d ) or ( a == c or a == d ) or ( b == c ) or ( a == c == d ) or ( a == c or a == d ) or ( a == d ) or ( b == c == d ) or ( a == c == d ) or ( b == d ) or ( a == c == d ) or ( a == c == d ) or ( a == c == d ) or ( a == d ) or ( a == c == d ) or ( a == d ) or ( b == d ) or ( a == d ) or ( a == b == d ) or ( a == c == d ) or ( a == c == d ) or ( a == d ) or ( a == c == d ) or ( a == c == d ) or ( a == d ) or ( a == d ) or ( a == c == d ) or ( a == d ) or ( a == d ) or ( a == c == d ) or ( a == d ) or a == c == d ) or ( a == d ) or ( a == d )
N = 10000 ; NEW_LINE MOD = 1000000007 ; NEW_LINE F = [ 2 ] * N ; NEW_LINE F [ 1 ] = 3 ; NEW_LINE F [ 2 ] = 3 ; NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; NEW_LINE DEDENT n = 8 ; NEW_LINE precompute ( ) ; NEW_LINE print ( F [ n ] ) ; NEW_LINE
import math NEW_LINE def solve ( n ) : NEW_LINE INDENT result = 0 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT result += n NEW_LINE i += i NEW_LINE DEDENT return result NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( n ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def CeilingIndex ( A , l , r , key ) : NEW_LINE INDENT while ( r - l > 1 ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( A [ 0 ] < key ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def LongestIncreasingSubsequence ( A , size ) : NEW_LINE INDENT tail = [ 0 for i in range ( size ) ] NEW_LINE length = 1 NEW_LINE length = 1 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT if ( A [ i ] < length ) : NEW_LINE INDENT tail [ 0 ] = A [ i ] NEW_LINE DEDENT elif ( A [ i ] > length ) : NEW_LINE INDENT tail [ 0 ] = A [ i ] NEW_LINE length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tail [ 0 ] = A [ i ] NEW_LINE DEDENT DEDENT return length NEW_LINE DEDENT A = [ 2 , 5 , 3 , 7 , 10 , 10 , 10 , 10 ] NEW_LINE n = len ( A ) NEW_LINE print ( " Length ▁ of ▁ Longest ▁ Increasing ▁ Increasing ▁ Subsequence ▁ is " , LongestIncreasingSubsequence ( A , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] > A [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE def compute_sequence ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not set ( set ( i ) ) == 60 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT def factorial_sequence ( n ) : NEW_LINE INDENT seen = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if seen . count ( i ) == 60 : NEW_LINE INDENT seen . add ( len ( n ) ) NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def rgbVisible ( height , BLACK , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( K + 1 ) ] NEW_LINE maximum = height [ K - 1 ] NEW_LINE arr [ K - 1 ] = 1 NEW_LINE for i in range ( K - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( height [ i ] > MAX ) : NEW_LINE INDENT maximum = height [ i ] NEW_LINE arr [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT maximum += 1 NEW_LINE arr [ i ] = 1 NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT height = [ 3 , 5 , 1 , 3 , 3 ] NEW_LINE K = len ( height ) NEW_LINE print ( rgbVisible ( height , 2 , K ) ) NEW_LINE
import math NEW_LINE def checkPowerPower ( n ) : NEW_LINE INDENT i = math . log ( n ) / math . log ( 8.000000 ) NEW_LINE return ( i - floor ( i ) < 0.00001 ) NEW_LINE DEDENT n = 65 NEW_LINE if ( checkPower ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a + b ) // 4 < a : NEW_LINE INDENT print ( ( a + b ) // 4 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( a + b ) // 4 ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT L = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT L . sort ( reverse = True ) NEW_LINE max = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT sum = L [ i ] + L [ i ] NEW_LINE if sum < max : NEW_LINE INDENT max = sum NEW_LINE DEDENT DEDENT print ( max ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l , r = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( ( l , r ) ) NEW_LINE DEDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] < r [ i ] : NEW_LINE INDENT mx = l [ i ] NEW_LINE mx = r [ i ] NEW_LINE DEDENT DEDENT print ( * mx ) NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT count = [ 0 for i in range ( n + 1 ) ] NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - m ] + count [ i - m ] NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT n = 7 NEW_LINE m = 4 NEW_LINE print ( " Number ▁ of ▁ ways ▁ = ▁ " , countWays ( n , m ) ) NEW_LINE
def print ( n ) : NEW_LINE INDENT print ( n + n // 2 ) NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE print ( n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE while True : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT ans = n % 2 NEW_LINE n //= 2 NEW_LINE DEDENT else : NEW_LINE INDENT n //= 2 NEW_LINE ans = n % 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
s = input ( ) NEW_LINE ans = " " NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == "0" : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT elif s [ i ] == "1" : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
from itertools import product NEW_LINE def solve ( A , B ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( A ) : NEW_LINE INDENT for j in range ( A ) : NEW_LINE INDENT if i + j == B : NEW_LINE INDENT continue NEW_LINE DEDENT if i + j == B : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if A == B == 0 : NEW_LINE INDENT return NEW_LINE DEDENT ans = solve ( A , B ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
MAX = 100 NEW_LINE def recur ( ind , cnt , a , last , n , a , b , dp ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ ind ] [ cnt ] != - 1 ) : NEW_LINE INDENT return - 1e9 NEW_LINE DEDENT if ( dp [ ind ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ cnt ] NEW_LINE DEDENT else : NEW_LINE INDENT return max ( max ( a [ ind ] [ cnt + 1 ] , recur ( a [ last ] , cnt + 1 , a [ cnt ] , i , cnt + 1 , a [ i ] ) ) ) NEW_LINE DEDENT DEDENT def recur ( a , b , cnt , dp , n , k , dp ) : NEW_LINE INDENT if ( cnt % 2 == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return max ( recur ( a [ last ] [ cnt ] , recur ( a [ last ] [ cnt + 1 ] , recur ( a [ last ] , cnt + 1 , cnt + 1 , a [ i ] ) ) + recur ( a [ last ] , cnt + 1 , cnt , dp , n , k ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 4 , 5 , 3 , 7 , 8 , 9 , 9 ] NEW_LINE n = len ( a ) NEW_LINE k = 4 NEW_LINE print ( recur ( 0 , 0 , 0 , n , a , 0 , k , dp ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] NEW_LINE c = [ 0 ] NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] != b [ i ] : NEW_LINE INDENT ans += b [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += c [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def equivalentBase4 ( bin ) : NEW_LINE INDENT bin = bin ( bin ( bin ) ) NEW_LINE if ( bin . '0' == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( bin ) == 0 ) : NEW_LINE INDENT bin = '0' + bin ( bin [ 0 : 2 ] ) NEW_LINE if ( len ( bin ) == 0 ) : NEW_LINE INDENT bin = '0' + bin ( bin [ 2 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT bin = bin [ 2 : ] NEW_LINE DEDENT DEDENT odd_sum = 0 NEW_LINE even_sum = 0 NEW_LINE for i in range ( 0 , len ( bin ) ) : NEW_LINE INDENT if ( isOddDigit != 0 ) : NEW_LINE INDENT odd_sum += equivalentBase ( bin [ i : i + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT even_sum += equivalentBase ( bin [ i : i + 2 ] ) NEW_LINE DEDENT DEDENT if ( abs ( odd_sum - even_sum ) % 5 == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT bin = "1000100101" NEW_LINE print ( isDivisibleBy5 ( bin ) ) NEW_LINE
import sys NEW_LINE from itertools import product NEW_LINE def solve ( ) : NEW_LINE INDENT d = { } NEW_LINE for line in sys . stdin : NEW_LINE INDENT for word in line . strip ( ) : NEW_LINE INDENT if word == '0' : NEW_LINE INDENT d [ word ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ word ] = 1 NEW_LINE DEDENT DEDENT DEDENT return d NEW_LINE DEDENT def solve ( line ) : NEW_LINE INDENT word = line . strip ( ) NEW_LINE n = " " NEW_LINE for word in line . strip ( ) : NEW_LINE INDENT if word == '0' : NEW_LINE INDENT word += '0' NEW_LINE DEDENT word = word . strip ( ) NEW_LINE DEDENT return word NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT line = sys . stdin . readline NEW_LINE for line in line . strip ( ) : NEW_LINE INDENT word = line . strip ( ) . split ( ) NEW_LINE n = int ( word ) NEW_LINE n = int ( word ) NEW_LINE DEDENT DEDENT for line in sys . stdin : NEW_LINE INDENT word = line . strip ( ) NEW_LINE n = word . strip ( ) NEW_LINE n = word . strip ( ) NEW_LINE n = len ( word ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT word = word [ i ] NEW_LINE n = word [ : i ] NEW_LINE DEDENT print ( word ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
a , b , c , d = input ( ) . split ( ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE c = int ( c ) NEW_LINE d = [ ] NEW_LINE for i in range ( a ) : NEW_LINE INDENT c = input ( ) NEW_LINE if c == " + " : NEW_LINE INDENT d . append ( ( c , d ) ) NEW_LINE DEDENT elif c == " - " : NEW_LINE INDENT d . append ( ( c , d ) ) NEW_LINE DEDENT elif c == " - " : NEW_LINE INDENT d . append ( ( c , d ) ) NEW_LINE DEDENT DEDENT print ( min ( d ) ) NEW_LINE
MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime [ True ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , p ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT primes [ p ] = False NEW_LINE DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] == False ) : NEW_LINE INDENT primes [ p ] = False NEW_LINE DEDENT DEDENT DEDENT def minimumSquareFreeDivisors ( N ) : NEW_LINE INDENT primes = [ ] NEW_LINE SieveOfEratosthenes ( primes ) NEW_LINE max_count = 0 NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT t = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT t = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT t += 1 NEW_LINE N //= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , max_count ) NEW_LINE DEDENT max_count = max ( max_count , max_count ) NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = max_count NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 24 NEW_LINE print ( " Minimum ▁ Number ▁ of ▁ Square ▁ Prime ▁ Prime ▁ Prime ▁ Prime ▁ Prime ▁ Prime ▁ Prime ▁ Prime ▁ Prime ▁ Prime ▁ is " , minimumSquareFree
x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( x - a - b ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( a ) == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k + 1 ) NEW_LINE DEDENT DEDENT
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT n = 7 NEW_LINE print ( " The ▁ number ▁ unittest ▁ unitt ▁ be ▁ unitt ▁ is ▁ : ▁ " , fun ( n ) ) NEW_LINE
def LongestFibSubseq ( A , n ) : NEW_LINE INDENT S = set ( ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S . add ( A [ i ] + A [ i ] ) NEW_LINE length = 3 NEW_LINE while ( y in S ) : NEW_LINE INDENT x = A [ y ] + A [ i ] NEW_LINE length = 3 NEW_LINE length = 3 NEW_LINE while ( y in S ) : NEW_LINE INDENT z = x + y NEW_LINE length = z NEW_LINE length = z NEW_LINE length = maxLen NEW_LINE length = maxLen NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT A = [ 1 , 2 , 3 , 4 , 5 , 7 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE
def countPairs ( a , b , n , m ) : NEW_LINE INDENT cnt = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT sum = a [ i ] + b [ j ] NEW_LINE if ( sum in cnt ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT a = [ 12 , 2 , 7 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 4 , 3 , 8 ] NEW_LINE m = len ( b ) NEW_LINE print ( countPairs ( a , b , n , m ) ) NEW_LINE
import math NEW_LINE def check ( arr , x , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = math . sqrt ( arr [ i ] ) ; NEW_LINE if ( int ( math . sqrt ( y ) ) == ceil ( math . sqrt ( y ) ) ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT DEDENT if ( sum % x == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 , 9 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( check ( arr , x , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
from collections import deque NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT q , * t = map ( int , input ( ) . split ( ) ) NEW_LINE if q == 0 : NEW_LINE INDENT a . append ( t ) NEW_LINE DEDENT elif q == 1 : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT elif q == 2 : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT DEDENT
def calculate_min_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE min_sum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT min_sum += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT return min_sum NEW_LINE DEDENT def calculate_max_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE max_sum = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT max_sum += abs ( a [ n - i ] - a [ i ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , - 10 , 20 , - 40 ] NEW_LINE n = len ( a ) NEW_LINE print ( " The ▁ minimum ▁ sum ▁ of ▁ pairs ▁ is " , calculate_max_sum ( a , n ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = set ( [ int ( a ) for a in input ( ) . split ( ) ] ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = set ( [ int ( a ) for a in input ( ) . split ( ) ] ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < b [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c == 0 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if a [ 0 ] % 2 == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if c == 0 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if a [ 0 ] % 2 == 0 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE if c == 0 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def isPalindrome ( s ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def ans ( s ) : NEW_LINE INDENT s2 = s NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT s2 [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE s2 [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT if ( len ( s ) <= 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 for i in range ( 25 ) ] NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( s2 [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] >= ord ( ' a ' ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " nolon " NEW_LINE print ( solve ( s ) ) NEW_LINE DEDENT
def count_numbers ( k , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( 2 ) ] NEW_LINE dp [ 1 ] [ 0 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT k = 10 NEW_LINE n = 3 NEW_LINE print ( count_numbers ( k , n ) ) NEW_LINE
def minCost ( n , arr , cost ) : NEW_LINE INDENT sum = 0 NEW_LINE totalCost = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT totalCost += cost * cost NEW_LINE arr [ n - 1 ] += sum NEW_LINE return totalCost NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE cost = 1 NEW_LINE print ( minCost ( n , arr , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = inpl ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT c , a = inpl ( ) NEW_LINE if c > a : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif c > a : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ i ] == " O " : c += 1 NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] + s [ i + 1 ] ) % 25 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE DEDENT DEDENT def insertOrder ( root , data ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return root NEW_LINE DEDENT if ( root == None ) : NEW_LINE INDENT root . left = insert ( root . left , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT def inOrder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return root NEW_LINE DEDENT inOrder ( root . left ) NEW_LINE print ( root . data , end = " ▁ " ) NEW_LINE inOrder ( root . left ) NEW_LINE inOrder ( root . right ) NEW_LINE inOrder ( root . right ) NEW_LINE inOrder ( root . right ) NEW_LINE inOrder ( root . right ) NEW_LINE inOrder ( root . right ) NEW_LINE inOrder ( root . left , inOrder ) NEW_LINEOrder ( inOrder ( root . right ) NEW_LINE inOrder ( inOrder ( root . right ) ) NEW_LINE inOrder ( inOrder ( root . right ) NEW_LINE inOrder ( inOrder ( inOrder ) ) NEW_LINE inOrder ( inOrder ( inOrder ) ) NEW_LINE inOrder ( inOrder ( inOrder ) NEW_LINE inOrder ( inOrder ( inOrder ) ) NEW_LINE inOrder ( inOrder ( inOrder ( inOrder ) ) NEW_LINE inOrder ( inOrder ( inOrder ) NEW_LINE inOrder ( inOrder ( inOrder ) ) NEW_LINE inOrder ( inOrder ( inOrder ) ) NEW_LINEOrder ( inOrder ( inOrder ) ) NEW_LINE inOrder ( inOrder ( inOrder ) NEW_LINE inOrder ( inOrder ( inOrder ) ) NEW_LINEOrder ( inOrder ( inOrder ( inOrder ) ) NEW_LINE inOrder ( inOrder ( inOrder ( inOrder ( inOrder ) ) ) NEW_LINEOrder ( inOrder ( inOrder ( inOrder ) ) ) NEW_LINE inOrder ( inOrder ( inOrder ( inOrder ( inOrder ) ) ) NEW_LINE inOrder ( inOrder ( inOrder
MAX_CHAR = 26 NEW_LINE def removeChars ( str , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT res = " " NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCST = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT if ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCST [ i ] [ j ] = LCST [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT LCST [ i ] [ j ] = LCST [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT X = " No " NEW_LINE Y = " NEW_LINE n = len ( X ) NEW_LINE print ( " Length ▁ of ▁ Longest ▁ Substrings ▁ Substrings ▁ is " , LCSieve ( X , Y , n ) ) NEW_LINE
def countOccurrences ( x , d ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 10 == d ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def maxOccurrences ( x , d ) : NEW_LINE INDENT if ( x < 0 ) : NEW_LINE INDENT x = - x NEW_LINE result = 0 NEW_LINE result = d NEW_LINE result = d NEW_LINE DEDENT return result NEW_LINE DEDENT x = 122345 NEW_LINE print ( " Max ▁ Occurrences ▁ digits ▁ is " , maxOccurrences ( x , d ) ) NEW_LINE
def printLogLongSumSubArr ( arr , n ) : NEW_LINE INDENT max = 1 NEW_LINE maxIndex = 0 NEW_LINE maxIndex = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT maxIndex = max + 1 NEW_LINE maxIndex = i - maxIndex NEW_LINE DEDENT elif ( maxIndex < len ) : NEW_LINE INDENT maxIndex = i - maxIndex NEW_LINE DEDENT DEDENT for i in range ( maxIndex + maxIndex ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 5 , 6 , 3 , 7 , 8 , 9 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE printLogLongIncSubArr ( arr , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT print ( n , * ans ) NEW_LINE
n , m , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE a . remove ( l ) NEW_LINE a . remove ( r ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] == a [ i ] : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def Max_Sum ( a , n ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = res + a [ i ] NEW_LINE res += a [ i ] NEW_LINE DEDENT ans = max ( ans , res ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ - 6 , 10 , - 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE ans = Max_Sum ( a , res ) NEW_LINE g = max ( ans , g ) NEW_LINE g = max ( ans , g ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT g = g - a [ i ] NEW_LINE ans = max ( ans , g + b [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ - 6 , 10 , - 3 , 10 , - 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( " Maximum ▁ sum : " , Max_Sum ( a , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if l > r : NEW_LINE INDENT print ( 2 * ( l - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( l - 1 ) * 2 ) NEW_LINE DEDENT DEDENT
def reverse ( str , x ) : NEW_LINE INDENT n = ( len ( str ) - x ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x - 1 , n ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x , n + 1 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT str = " geeksforgeeks " NEW_LINE x = 3 NEW_LINE reverse ( str , x ) NEW_LINE
def lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( n ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i ] and cl == cl ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT elif ( s [ i ] == s [ j ] and cl [ i ] [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE length = lps ( ) NEW_LINE print ( " Minimum ▁ number ▁ duplions ▁ = " , lps ( string ) ) NEW_LINE DEDENT
def bit_check ( n ) : NEW_LINE INDENT if ( n & ( n - 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 14 NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] <= a [ i + 1 ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE primes = eulerlib . sqrt ( LIMIT ) - 1 NEW_LINE ans = sum ( primes ) NEW_LINE for i in primes : NEW_LINE INDENT if primes [ i ] <= LIMIT : NEW_LINE INDENT ans += i - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += len ( primes ) - i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
M = 10 NEW_LINE dp = [ [ - 1 for i in range ( M ) ] for j in range ( 2 ) ] NEW_LINE def count ( pos , cnt , tight , tight , tight , tight , tight , tight , tight ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] NEW_LINE DEDENT if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = 9 NEW_LINE for dig in range ( tight ) : NEW_LINE INDENT currCnt = cnt + 1 NEW_LINE if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT currCnt += 1 NEW_LINE DEDENT currCnt -= 1 NEW_LINE if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT currCnt += 1 NEW_LINE DEDENT currCnt -= 1 NEW_LINE DEDENT ans += count ( pos + 1 , tight , tight , tight , tight ) NEW_LINE return ans NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT num = [ [ x for x in range ( 10 ) ] for x in range ( M ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT num . append ( x [ i ] [ x [ i ] ] ) NEW_LINE DEDENT DEDENT def solve ( x ) : NEW_LINE INDENT num = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT num . append ( x [ i ] [ i ] ) NEW_LINE DEDENT return num [ 0 ] [ x [ i ] [ x [ i ] for i in range ( M ) ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 11 NEW_LINE R = 100 NEW_LINE k = 2 NEW_LINE print ( solve ( R - 1 , 0 , 0 , 0 , 0 , 0 , num ) ) NEW
n = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE while ( n >= 10 ) : NEW_LINE INDENT c += ( 9 - ( n % 10 ) ) NEW_LINE n //= 10 NEW_LINE DEDENT print ( c ) NEW_LINE
def isPeak ( arr , n , i , j , i ) : NEW_LINE INDENT if ( i >= 0 and arr [ i ] < n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( j < n and arr [ i ] < n and arr [ j ] < n ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def printPeeks ( arr , n , num , i , j , i , j ) : NEW_LINE INDENT if ( j < n and arr [ j ] < num ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( j < n and arr [ j ] < num ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def printPeakTowers ( arr , n ) : NEW_LINE INDENT print ( " Triangle ▁ : ▁ " , end = " ▁ " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( isPeak ( arr , n , arr [ i ] , i - 1 , i - 1 , i , i + 1 ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT printPeeks ( " ) NEW_LINE DEDENT arr = [ 5 , 10 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printPeeks ( arr , n ) NEW_LINE
def index ( i ) : NEW_LINE INDENT return 1 + ( i >> 31 ) - ( - i >> 31 ) NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT s = [ " negative " , " positive " , " positive " ] NEW_LINE val = index ( n ) NEW_LINE print ( n , " positive " , s ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE check ( n ) NEW_LINE check ( n ) NEW_LINE DEDENT
def frequency ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = [ 0 , 5 , 5 , 4 ] NEW_LINE x = 5 NEW_LINE print ( frequency ( a , n , x ) ) NEW_LINE
def isNum balanced ( num ) : NEW_LINE INDENT num = abs ( num ) NEW_LINE s = num + " NEW_LINE h = num + " NEW_LINE if ( s <= num // 2 or h <= num ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( s <= num // 2 or h <= num ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isNum balanced ( N ) : NEW_LINE INDENT s = str ( N ) NEW_LINE h = set ( ) NEW_LINE if ( h <= len ( s ) // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT h . add ( h ) NEW_LINE h . add ( h ) NEW_LINE if ( h <= len ( s ) // 2 or h <= len ( s ) // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 1234590 NEW_LINE flag = isNum ( N ) NEW_LINE if ( flag ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isThreeDistinctFactors ( n ) : NEW_LINE INDENT sq = sqrt ( n ) NEW_LINE if ( isPrime ( sq ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def isThreeDistinctFactors ( n ) : NEW_LINE INDENT sq = 12.5 NEW_LINE if ( isPrimeFactors ( n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 12.68 NEW_LINE if ( isThreeDistinctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT n = 1 NEW_LINE d = eulerlib . zeros ( n ) NEW_LINE d = eulerlib . zeros ( n ) NEW_LINE ans = sum ( ( ( one // 3 for one in eulerlib . sqrt ( n ) ) ) for one in range ( n , - 1 , - 1 , - 1 ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def integral ( i ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT return 2 * ( i // 3 ) + d NEW_LINE DEDENT else : NEW_LINE INDENT return int ( i / 3 ) + d NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def LCM ( x , y , z ) : NEW_LINE INDENT ans = ( ( x * y ) / ( gcd ( x , y ) ) ) NEW_LINE return ( ( z * ans ) / ( gcd ( x , y ) ) ) NEW_LINE DEDENT def LCM ( n , x , y , z ) : NEW_LINE INDENT ans = ( ( x * y ) // ( gcd ( x , y ) ) ) NEW_LINE ndigitnumber = pow ( 10 , n - 1 ) NEW_LINE if ( remnumber < 0 ) : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT ndigitnumber = pow ( 10 , n - 1 ) NEW_LINE remnumber = n * ( 10 ** n - 1 ) NEW_LINE if ( remnumber < 0 ) : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT ndigitnumber = pow ( 10 , n - 1 , zeros ) NEW_LINE if ( ndigitnumber < 10 ) : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE res = findDivisible ( n , x , y , z ) NEW_LINE if ( res ) : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT
MAXN = 100001 NEW_LINE prime = [ True ] * ( MAXN ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( MAXN ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT prime [ p ] = False NEW_LINE DEDENT DEDENT DEDENT def common_prime ( a , b ) : NEW_LINE INDENT gcd = a * b NEW_LINE for i in range ( 2 , ( gcd + 1 ) , 1 ) : NEW_LINE INDENT if prime [ i ] and gcd % i == 0 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE a = 6 NEW_LINE b = 10 NEW_LINE common_prime ( a , b ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , l , p = map ( int , input ( ) . split ( ) ) NEW_LINE dp [ s ] = max ( dp [ s ] , dp [ l ] + p ) NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( s , l + 1 ) : NEW_LINE INDENT if dp [ i - 1 ] > dp [ j ] + p : NEW_LINE INDENT dp [ i ] = dp [ j - 1 ] + p NEW_LINE DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT print ( dp [ i ] ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE YesNo = lambda b : bool ( [ print ( ' Yes ' ) ] if b else print ( ' No ' ) ) NEW_LINE YESNO = lambda b : bool ( [ print ( ' Yes ' ) ] if b else print ( ' No ' ) ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE g1 = [ [ 0 ] * N for _ in range ( N - 1 ) ] NEW_LINE g2 = [ [ 0 ] * N for _ in range ( N - 1 ) ] NEW_LINE g2 [ 0 ] = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE g2 [ a ] [ b ] = g1 [ b ] [ a ] + g2 [ b ] NEW_LINE g2 [ b ] = g2 [ a ] [ b ] + g2 [ b ] NEW_LINE DEDENT ans = 2 * N NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if g1 [ i ] == g2 [ i ] : NEW_LINE INDENT ans = 2 * g2 [ i ] + g2 [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ list ( input ( ) ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] + a [ i ] [ j ] == '0' : NEW_LINE INDENT a [ i ] [ j ] = '0' + a [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE lst = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lst . append ( input ( ) ) NEW_LINE DEDENT lst1 = sorted ( lst , key = lambda x : x [ 1 ] ) NEW_LINE lst2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lst [ i ] [ 0 ] == lst [ i + 1 ] [ 0 ] : NEW_LINE INDENT lst2 . append ( lst1 [ i ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT lst2 . append ( lst2 [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if lst1 [ i ] [ 0 ] == lst2 [ i + 1 ] [ 0 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans , ans ) NEW_LINE
s = input ( ) NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] == " a " or s [ 1 ] == " e " : NEW_LINE INDENT print ( " WA " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " WA " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def solve ( N , L , L ) : NEW_LINE INDENT A = [ int ( x ) for x in L ] NEW_LINE for a in A : NEW_LINE INDENT A . remove ( a ) NEW_LINE DEDENT return A NEW_LINE DEDENT def solve ( N , L , L ) : NEW_LINE INDENT A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = solve ( N , L , A ) NEW_LINE return min ( ans , solve ( N , L , A ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for testcase in range ( 1 , T + 1 ) : NEW_LINE INDENT N , L = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = solve ( N , L , A ) NEW_LINE print ( " POSSIBLE " , main ( ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def maxAreaOfIsIslandOfIsland ( self , grid ) : NEW_LINE INDENT dr = [ [ 1 , 0 , 0 , 0 , - 1 , - 1 ] , [ - 1 , 0 , - 1 ] , [ - 1 , 0 , - 1 ] , [ - 1 , 0 , - 1 ] , [ - 1 , 0 , - 1 ] , [ - 1 , - 1 ] , [ 0 , - 1 , - 1 ] , [ 0 , 0 , - 1 ] , [ 0 , - 1 , - 1 ] , [ 0 , 1 , 0 ] ] NEW_LINE ans = 0 NEW_LINE for r in range ( 0 , len ( grid ) ) : NEW_LINE INDENT if ( grid [ r ] [ c ] == 1 ) : NEW_LINE INDENT for c in range ( 0 , len ( grid [ r ] ) ) : NEW_LINE INDENT node = grid [ r ] [ c ] NEW_LINE for k in range ( 0 , len ( grid [ r ] ) ) : NEW_LINE INDENT node = grid [ r ] [ 0 ] NEW_LINE for k in range ( 0 , len ( grid [ r ] ) ) : NEW_LINE INDENT node = grid [ r ] [ 0 ] NEW_LINE for k in range ( 0 , len ( grid [ r ] ) ) : NEW_LINE INDENT node = grid [ r ] [ 0 ] NEW_LINE for k in range ( 0 , len ( grid [ r ] ) ) : NEW_LINE INDENT node = node [ r ] [ 0 ] NEW_LINE for k in range ( 0 , len ( grid [ r ] ) ) : NEW_LINE INDENT node = grid [ r ] [ 0 ] NEW_LINE for k in range ( 0 , len ( grid [ r ] ) ) : NEW_LINE INDENT node = grid [ r ] [ 0 ] NEW_LINE node = node [ r ] [ 0 ] NEW_LINE if node < len ( grid [ r ] ) and node < len ( grid [ r ] ) and node < len ( grid [ r ] ) and node < len ( grid [ r ] ) : NEW_LINE INDENT node = node [ r ] [ 0 ] NEW_LINE node = node [ r ] [ 1 ] NEW_LINE node = node [ r ] [ 0 ] NEW_LINE DED
def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( pow ( x , 2 * n - 1 ) * ( pow ( x , n ) - 1 ) ) // ( x * y - 1 ) NEW_LINE sum2 = ( x * y * ( pow ( x , n ) - 1 ) ) // ( x * y - 1 ) NEW_LINE return sum1 + sum2 NEW_LINE DEDENT x , y , n = 2 , 2 , 2 NEW_LINE print ( sum ( x , y , n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum = 0 NEW_LINE sum = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) // 6 NEW_LINE return sum NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , data ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def deleteNonPrimeNodes ( head_ref ) : NEW_LINE INDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr = head_ref NEW_LINE while ( curr <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT curr . next = curr . next NEW_LINE curr = curr . next NEW_LINE curr = curr . next NEW_LINE curr . next = curr . next NEW_LINE curr = curr . next NEW_LINE DEDENT curr = curr . next NEW_LINE DEDENT return head_ref NEW_LINE DEDENT def deleteNonPrimeNodes ( head ) : NEW_LINE INDENT ptr = head NEW_LINE while ( curr . next != None ) : NEW_LINE INDENT if ( not isPrime ( curr ) ) : NEW_LINE INDENT ptr . next = curr . next NEW_LINE curr = curr . next NEW_LINE curr = curr . next NEW_LINE curr = curr . next NEW_LINE DEDENT else : NEW_LINE INDENT ptr = curr . next NEW_LINE curr .
import sys NEW_LINE input = sys . stdin . readline NEW_LINE from collections import defaultdict NEW_LINE from heapq import heappop , heappush NEW_LINE from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE from itertools import accumulate NEW_LINE from bisect import bisect_right , bisect_right NEW_LINE from operator import itemgetter NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def INT ( ) : return int ( input ( ) ) NEW_LINE def MAP ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def ZIP ( n ) : return zip ( * ( MAP ( ) for _ in range ( n ) ) ) NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N , M , L , R = MAP ( ) NEW_LINE dp = [ [ 0 ] * ( L + 1 ) for _ in range ( L ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( L ) : NEW_LINE INDENT for j in range ( L ) : NEW_LINE INDENT for k in range ( L ) : NEW_LINE INDENT if dp [ i ] [ j ] == dp [ i ] [ j ] + R : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + T NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( dp [ L ] [ R ] ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( x ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans += ( a [ x - 1 ] - 1 ) * ( a [ x - 1 ] - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import bisect NEW_LINE import copy NEW_LINE import decimal NEW_LINE import queue NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE ni = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def main ( ) : NEW_LINE INDENT h , w = ns ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT c = 0 NEW_LINE for c in range ( w ) : NEW_LINE INDENT if c == ' . ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , c - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def minReplacement ( str ) : NEW_LINE INDENT if len ( str ) > 26 : NEW_LINE INDENT return " IMPOSSIBLE " NEW_LINE DEDENT else : NEW_LINE INDENT hash = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT DEDENT print ( str ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " xxxyyyy " NEW_LINE minReplacement ( str ) NEW_LINE DEDENT
def longestSubseq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_
def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE for j in range ( i , N + 1 ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT sieveOfEratosthenes ( N , s ) NEW_LINE print ( " Product ▁ Power " , s ) NEW_LINE DEDENT N = 100 NEW_LINE sieveOfEratosthenes ( N ) NEW_LINE print ( " Factorial ▁ Power " , s ) NEW_LINE
import sys NEW_LINE def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( 10 ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ i ] [ n % 10 ] = 1 NEW_LINE DEDENT longest = - sys . maxsize NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] == 1 and hash [ i + 1 ] [ j ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 10 ) : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 11 , 22 , 33 , 56 , 63 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + b + c ) // 2 ) NEW_LINE DEDENT
def Divisors ( x ) : NEW_LINE INDENT c = 0 ; NEW_LINE v = [ ] ; NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT c += 1 ; NEW_LINE x //= 2 ; NEW_LINE DEDENT v . append ( c ) ; NEW_LINE c . append ( c ) ; NEW_LINE c . append ( x ) ; NEW_LINE c . append ( c ) ; NEW_LINE c . append ( c ) ; NEW_LINE DEDENT def MinOperations ( a , b ) : NEW_LINE INDENT va = Divisors ( a ) ; NEW_LINE c . append ( c ) ; NEW_LINE c . append ( a ) ; NEW_LINE return int ( c [ 0 ] - b [ 1 ] ) ; NEW_LINE DEDENT def MinOperations ( a , b ) : NEW_LINE INDENT va = Divisors ( a ) ; NEW_LINE if ( va [ 0 ] != b [ 1 ] ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT minOperations = ( va [ 0 ] - va [ 2 ] ) + abs ( va [ 2 ] - va [ 2 ] ) ; NEW_LINE return minOperations ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 14 ; b = 28 ; NEW_LINE print ( MinOperations ( a , b ) ) ; NEW_LINE DEDENT
N = 1000001 NEW_LINE def dfs ( v , v , v , v ) : NEW_LINE INDENT vis [ v ] = 1 NEW_LINE c = 0 NEW_LINE for i in v : NEW_LINE INDENT if ( vis [ i ] == 0 and i != b ) : NEW_LINE INDENT dfs ( i , v , v , vis ) NEW_LINE DEDENT DEDENT vis [ v ] = n - c NEW_LINE ans1 = n - c - 1 NEW_LINE ans2 = n - c - 1 NEW_LINE ans2 = n - c - 1 NEW_LINE ans2 = n - c - 1 NEW_LINE return ans1 * ans2 NEW_LINE DEDENT def Calculate ( v ) : NEW_LINE INDENT vis = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 5 , 5 ] , [ 6 , 5 ] ] NEW_LINE ans2 = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT v [ i ] = v [ i ] NEW_LINE DEDENT v = [ [ 1 , 2 ] , [ 3 , 4 ] , [ 6 , 5 ] ] NEW_LINE ans2 = n - c - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT v [ i ] = ans2 [ i ] + ans2 [ i ] NEW_LINE DEDENT DEDENT v = [ 1 , 2 ] , [ 3 , 4 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 6 , 6 ] , [ 6 , 6 ] ] NEW_LINE v = [ [ 1 , 2 , 5 ] , [ 6 , 7 ] , [ 6 , 7 ] ] NEW_LINE v = [ [ 1 , 4 , 6 ] , [ 6 , 6 ] , [ 6 , 7 ] ] NEW_LINE Calculate ( v ) NEW_LINE Calculate ( v , v , v ) NEW_LINE
n = input ( ) NEW_LINE if len ( n ) == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = 1 NEW_LINE for i in n : NEW_LINE INDENT if i == '9' : NEW_LINE INDENT x = ( int ( i ) * ( 10 ** ( i - 1 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT x = ( int ( i ) * ( i - 1 ) ) * ( 10 ** ( i - 1 ) ) NEW_LINE DEDENT x *= ( 10 ** ( i - 1 ) ) NEW_LINE DEDENT print ( x ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b // b + ( a - 1 ) // b ) NEW_LINE
from math import sqrt NEW_LINE def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisor ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE res = max ( res , getSum ( n // i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisor ( n ) ) NEW_LINE
l , r = map ( int , input ( ) . split ( ) ) NEW_LINE def f ( x ) : NEW_LINE INDENT if x <= r : NEW_LINE INDENT return 0 NEW_LINE DEDENT return x NEW_LINE DEDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = 10 NEW_LINE if l <= r : NEW_LINE INDENT print ( f ( l , r ) ) NEW_LINE DEDENT else : NEW_LINE INDENT m = ( l - r ) // 2 NEW_LINE print ( m * f ( l , m ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( * A ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = int ( math . sqrt ( x ) ) NEW_LINE return ( ( sr - sr ) == 0 ) NEW_LINE DEDENT def isProduct ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 2 , int ( sqrt ( num ) ) + 1 ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num //= i NEW_LINE cnt += 1 NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt == 2 NEW_LINE DEDENT def findNumbers ( N ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isProduct ( i ) and isPerfectSquare ( i ) ) : NEW_LINE INDENT vec . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( vec [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE findNumbers ( N ) NEW_LINE DEDENT
import sys NEW_LINE from collections import Counter NEW_LINE s = input ( ) NEW_LINE ans = " " NEW_LINE for c in s : NEW_LINE INDENT if c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_LINE INDENT ans += c NEW_LINE DEDENT elif c == "101" : NEW_
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = input ( ) NEW_LINE c = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT c += 1 NEW_LINE n = n // ( 10 + 1 ) NEW_LINE DEDENT print ( int ( n ) ) NEW_LINE DEDENT
def divSum ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , int ( n ** .5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def areEquivalent ( num1 , num2 ) : NEW_LINE INDENT return divSum ( num1 ) == divSum ( num2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num1 = 559 NEW_LINE num2 = 703 NEW_LINE if ( areEquivalent ( num1 , num2 ) ) : NEW_LINE INDENT print ( " Equivalent " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Equal " ) NEW_LINE DEDENT DEDENT
def findY ( x ) : NEW_LINE INDENT if ( x > 2 ) : NEW_LINE INDENT return x - 2 NEW_LINE DEDENT return x + 2 NEW_LINE DEDENT x = 5 NEW_LINE print ( findY ( x ) ) NEW_LINE
MOD = 1000000007 NEW_LINE def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( modFact ( n , m ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = min ( a ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < m : NEW_LINE INDENT m = a [ i ] NEW_LINE a [ i ] , a [ i ] = m , a [ i ] NEW_LINE DEDENT DEDENT ans . append ( m ) NEW_LINE print ( * ans ) NEW_LINE
import sys NEW_LINE import itertools NEW_LINE import math NEW_LINE import bisect NEW_LINE import copy NEW_LINE import heapq NEW_LINE import bisect NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import copy NEW_LINE import decimal NEW_LINE import queue NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 16 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE ni = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT w , h = ns ( ) NEW_LINE g = [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for _ in range ( h ) ] NEW_LINE g [ h ] [ w ] = 1 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if g [ i ] [ j ] == 1 : NEW_LINE INDENT g [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , h + 1 ) : NEW_LINE INDENT for j in range ( 1 , w + 1 ) : NEW_LINE INDENT if g [ i ] [ j ] == 1 : NEW_LINE INDENT g [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , h + 1 ) : NEW_LINE INDENT for j in range ( 1 , w + 1 ) : NEW_LINE INDENT if g [ i ] [ j ] == 1 : NEW_LINE INDENT g [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( sum ( g [ i ] [ j ] for i in g [ h ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] < a [ i ] : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT DEDENT print ( * b ) NEW_LINE
def circlearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) NEW_LINE return A NEW_LINE DEDENT a = 8 NEW_LINE b = 10 NEW_LINE print ( circlearea ( a , b ) ) NEW_LINE
def find ( arr , length , s ) : NEW_LINE INDENT for i in range ( 1 , length + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( ( ( i >> j ) & 1 ) & 1 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT DEDENT if ( sum == s ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT DEDENT return " NO " NEW_LINE DEDENT sum = 5 NEW_LINE array = [ - 1 , 2 , 4 ] NEW_LINE n = len ( array ) NEW_LINE find ( array , length , sum ) NEW_LINE
def K_String ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT string = " " NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT if ( freq [ i ] % k == 0 ) : NEW_LINE INDENT x = freq [ i ] // k NEW_LINE while ( x != 0 ) : NEW_LINE INDENT string += chr ( i + ord ( ' a ' ) ) NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT DEDENT return string NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabb " NEW_LINE k = 2 NEW_LINE print ( K_String ( s , k ) ) NEW_LINE DEDENT
import sys NEW_LINE from itertools import product NEW_LINE input = sys . stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT result = [ [ 0.0 ] * ( n + 1 ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = ( pow ( 2 , i ) - pow ( 2 , i ) ) NEW_LINE b = ( pow ( 2 , i - 1 ) - pow ( 2 , i ) ) / pow ( 2 , i ) ) NEW_LINE result [ i ] += b * ( pow ( 2 , i - 1 ) - a ) / pow ( 2 , i - 1 ) NEW_LINE DEDENT print ( result [ n ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ' . ' * b >= n : NEW_LINE INDENT c . append ( c [ i ] * ' . ' ) NEW_LINE DEDENT else : NEW_LINE INDENT c . append ( c [ i ] * ' . ' ) NEW_LINE DEDENT DEDENT print ( sum ( c ) ) NEW_LINE
import bisect NEW_LINE import heapq NEW_LINE import math NEW_LINE import random NEW_LINE import sys NEW_LINE from collections import Counter , defaultdict , deque NEW_LINE from decimal import ROUND_CEILING , ROUND_HALF_UP , Decimal NEW_LINE from functools import lru_cache , reduce NEW_LINE from itertools import combinations , combinations_with_replacement , product , permutations NEW_LINE from operator import add , mul , sub NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE def read_int ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def read_int_n ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def read_float ( ) : NEW_LINE INDENT return float ( input ( ) ) NEW_LINE DEDENT def read_float_n ( ) : NEW_LINE INDENT return list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE DEDENT def read_str ( ) : NEW_LINE INDENT return input ( ) . strip ( ) NEW_LINE DEDENT def read_str_n ( ) : NEW_LINE INDENT return input ( ) . strip ( ) NEW_LINE DEDENT def read_str_n ( ) : NEW_LINE INDENT return input ( ) . strip ( ) NEW_LINE DEDENT def error_print ( * args , ** kwargs ) : NEW_LINE INDENT print ( * args , file = sys . stderr , ** kwargs ) NEW_LINE DEDENT def mt ( f ) : NEW_LINE INDENT import time NEW_LINE def wrap ( * args , ** kwargs ) : NEW_LINE INDENT s = time . time ( ) NEW_LINE ret = f ( * args , ** kwargs ) NEW_LINE e = time . time ( ) NEW_LINE error_print ( e - s , ' sec ' ) NEW_LINE return ret NEW_LINE DEDENT return wrap NEW_LINE DEDENT @ mt NEW_LINE def slv ( N , A ) : NEW_LINE INDENT N = A + 7 NEW_LINE A = A + 7 NEW_LINE A = A + 7
while True : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and k == 0 : NEW_LINE INDENT break NEW_LINE DEDENT A = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT A [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT A [ i ] = A [ i ] - A [ i ] NEW_LINE DEDENT if A [ - 1 ] == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def maxFreq ( s , a , b ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE n = len ( s ) NEW_LINE if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE b = temp NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT if ( freq [ a ] >= freq [ b ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = 4 , 7 NEW_LINE s = "47744" NEW_LINE print ( maxFreq ( a , b , b ) ) NEW_LINE DEDENT
def maxZeros ( n ) : NEW_LINE INDENT if ( n == 0 or ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT b = 4 NEW_LINE setBit = 1 NEW_LINE for i in range ( 1 , b + 1 ) : NEW_LINE INDENT if ( n & setBit ) : NEW_LINE INDENT setBit = setBit << 1 NEW_LINE break NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE for j in range ( i + 1 , b + 1 ) : NEW_LINE INDENT if ( n & setBit ) == setBit : NEW_LINE INDENT setBit = setBit << 1 NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE if ( n & setBit ) : NEW_LINE INDENT setBit = setBit << 1 NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE for j in range ( i + 1 , b + 1 ) : NEW_LINE INDENT curBit = curBitBit << 1 NEW_LINE if ( n - setBit - setBit - 1 ) : NEW_LINE INDENT if ( curBit < ( curBit - setBit - 1 ) ) : NEW_LINE INDENT maxBit = curBit - prevBit - 1 NEW_LINE DEDENT setBit = curBit - prevBit NEW_LINE DEDENT setBit = curBit - setBit NEW_LINE DEDENT return maxBit NEW_LINE DEDENT n = 5 NEW_LINE print ( maxZeros ( n ) ) NEW_LINE
def sumPowers ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE num = 1 NEW_LINE while ( num <= n ) : NEW_LINE INDENT sum += num NEW_LINE num *= k NEW_LINE DEDENT return sum NEW_LINE DEDENT def getSum ( n , k ) : NEW_LINE INDENT pwr = sumPowers ( n , k ) NEW_LINE sumAllKK = ( n * ( n + 1 ) ) / 2 NEW_LINE return ( sumAllK ) NEW_LINE DEDENT n = 10 NEW_LINE k = 3 NEW_LINE print ( getSum ( n , k ) ) NEW_LINE
def XandYandZercept ( A , B , C , D ) : NEW_LINE INDENT res = Xor ( D ) NEW_LINE x = - D // C NEW_LINE y = - D // C NEW_LINE return res NEW_LINE DEDENT A = 2 NEW_LINE B = 5 NEW_LINE C = 7 NEW_LINE d = [ X , C , D ] NEW_LINE print ( XandYandZercept ( A , B , C , D ) ) NEW_LINE
def maxSum ( a , n ) : NEW_LINE INDENT l = [ ] NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += abs ( a [ i ] ) NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE l . append ( i ) NEW_LINE DEDENT DEDENT print ( " % d ▁ % d " % ( l ) , end = " ▁ " ) NEW_LINE for i in range ( 0 , len ( l ) ) : NEW_LINE INDENT print ( l [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE a = [ 1 , - 2 , - 3 , 4 ] NEW_LINE maxSum ( a , n ) NEW_LINE DEDENT
MAX = 1000 NEW_LINE def replaceStaces ( str ) : NEW_LINE INDENT space_count = 0 NEW_LINE i = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT space_count += 1 NEW_LINE DEDENT DEDENT length = i NEW_LINE while ( i - 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == ' ▁ ' ) : NEW_LINE INDENT space_count -= 1 NEW_LINE str [ i - 1 ] = ' ' NEW_LINE str [ i - 1 ] = ' ' NEW_LINE str [ i - 2 ] = ' ' NEW_LINE i -= 3 NEW_LINE DEDENT DEDENT i = i + ( len ( str ) - 1 ) NEW_LINE if ( i > MAX ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT i = i + ( len ( str ) - 1 ) NEW_LINE string = string [ : i ] NEW_LINE string = string [ : i + 1 ] NEW_LINE string = string [ i : i + 2 ] NEW_LINE string = string [ : i + 2 ] NEW_LINE string = string [ : i + 3 ] NEW_LINE string = string [ : i + 2 ] NEW_LINE string = string [ i : ] NEW_LINE string = string [ i : ] NEW_LINE string = string [ i : i + 3 ] NEW_LINE string = string [ i : i + 3 ] NEW_LINE string = string NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT string += string [ i ] NEW_LINE string += string [ i ] NEW_LINE string += string [ i ] NEW_LINE string += string [ i ] NEW_LINE string += string [ i ] NEW_LINE string += string [ i ] NEW_LINE i = i NEW_LINE DEDENT return string NEW_LINE DEDENT string = " M ▁ Smith ▁ " NEW_LINE string = " M ▁ " NEW_LINE string = string NEW_LINE string = string NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT string = string [ i ] NEW_LINE string = string [ i ]
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = ' ' NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT ans += '1' NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += '1' NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def check ( n ) : NEW_LINE INDENT m = n NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE if ( m % r != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def count ( l , r ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( check ( i ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT l = 10 NEW_LINE r = 20 NEW_LINE print ( count ( 10 , 20 ) ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ( a * 10 + 1 , ( b + 1 ) // 10 + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a * 10 + 1 , ( a + 1 ) // 10 + 1 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mx = 1000000000 NEW_LINE mx = 1000000000 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT mx = min ( mx , abs ( l [ i ] - l [ i - 1 ] ) ) NEW_LINE mx = min ( mx , abs ( l [ i - 1 ] - l [ i - 1 ] ) ) NEW_LINE DEDENT print ( mx ) NEW_LINE
s = input ( ) NEW_LINE if ( len ( s ) - 1 ) % 4 == 0 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif ( len ( s ) - 2 ) % 4 == 0 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT
k = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT l . append ( int ( s [ i ] ) ) NEW_LINE DEDENT l . sort ( ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT l [ i ] = ( 9 * l [ i ] ) NEW_LINE count += 1 NEW_LINE i += 1 NEW_LINE DEDENT print ( count ) NEW_LINE
n , k , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE if n == 1 : NEW_LINE INDENT print ( a * ( n - 1 ) // k ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += ( n // k ) * a NEW_LINE n //= k NEW_LINE if n % k == 0 : NEW_LINE INDENT ans += ( n // k ) * a NEW_LINE n //= k NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def digSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT n = 1234 NEW_LINE print ( digSum ( n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE dp = [ [ 0 ] * ( m + 1 ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - 1 ] + 2 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - 1 ] + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - 1 ] + 2 ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] ) NEW_LINE
def centered_hptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( " th ▁ Centered ▁ Centered ▁ centered ▁ centered ▁ number ▁ : ▁ " , centered_hagonal_num ( n ) ) NEW_LINE
def missingNum ( arr , n ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT list . append ( i ) NEW_LINE DEDENT minval = min ( list ) NEW_LINE xor = min ( list ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT xor ^= ( minval ) NEW_LINE minval += 1 NEW_LINE DEDENT return xor ^ minval NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 13 , 12 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( missingNum ( arr , n ) ) NEW_LINE DEDENT
def smallestPermute ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res . append ( chr ( 97 + i + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( chr ( 97 + i ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT res . append ( chr ( 97 + i ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 97 + i ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 97 + i ) NEW_LINE DEDENT DEDENT res [ n - 1 ] = chr ( 97 + n - 2 ) NEW_LINE res [ n - 1 ] = chr ( 97 + n - 1 ) NEW_LINE res [ n - 1 ] = chr ( 97 + n - 1 ) NEW_LINE res [ n - 1 ] = chr ( 97 + n - 1 ) NEW_LINE res [ n - 1 ] = chr ( 97 + n - 1 ) NEW_LINE res [ n - 1 ] = chr ( 97 + n - 2 ) NEW_LINE res [ n - 1 ] = chr ( n - 2 ) NEW_LINE res [ n - 1 ] = chr ( n - 1 ) NEW_LINE res [ n - 1 ] = chr ( n - 2 ) NEW_LINE res [ n - 1 ] = chr ( n - 1 ) NEW_LINE res [ n - 1 ] = chr ( res [ n - 1 ] ) NEW_LINE res [ n - 1 ] = chr ( res [ n - 1 ] ) NEW_LINE res [ n - 1 ] = chr ( n - 1 ) NEW_LINE res [ n - 1 ] = chr ( res [ n - 1 ] ) NEW_LINE return res [ n - 1 ] NEW_LINE DEDENT n = " " NEW_LINE for i in range (
def minOperations ( a , n , K ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] & K ) : NEW_LINE INDENT map [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT b = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] & K ) : NEW_LINE INDENT map [ b [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] != b [ i ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT K = 3 NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( minOperations ( a , n , K ) ) NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if w == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if ( i + j , i + j , j + k ) not in [ ( i + j , j + k , k + k ) ] : NEW_LINE INDENT if ( j + k , i + k ) not in [ ( i , j + k ) , ( j + k , k + k ) ] : NEW_LINE INDENT b = [ ( j + k , k + k ) ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( " { } ▁ { } " . format ( w , h , w ) ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( 360 - n ) % 360 == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def compute ( ) : NEW_LINE INDENT num_PROVEN_SIZE = 7 NEW_LINE denominator = 10 ** 9 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 10 ** 9 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = 0 NEW_LINE denominator = denominator * denominator NEW_LINE denominator = denominator * denominator NEW_LINE denominator = denominator * denominator * denominator NEW_LINE denominator = denominator * denominator * denominator * denominator NEW_LINE denominator = denominator * denominator * denominator * denominator NEW_LINE denominator = denominator * denominator NEW_LINE denominator = denominator * denominator * denominator NEW_LINE denominator = denominator * denominator * denominator NEW_LINE denominator = denominator * denominator * denominator NEW_LINE denominator = denominator * denominator NEW_LINE denominator = denominator * denominator * denominator * denominator NEW_LINE denominator =
def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE time = m * 60 + m * 60 NEW_LINE time = time * 60 + m * 60 + m * 60 NEW_LINE time = time // 60 NEW_LINE if time <= time : NEW_LINE INDENT print ( time // 60 , time % 60 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( time // 60 , time % 60 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( a , b * a + 1 , b * a + 1 ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == "0" : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , count ) NEW_LINE DEDENT
def findMaxValue ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT print ( " The ▁ array ▁ array ▁ of ▁ A ▁ are ▁ " , ▁ a ▁ elements ▁ " , end = " ▁ " ) NEW_LINE DEDENT if ( n < 4 ) : NEW_LINE INDENT print ( " The ▁ array ▁ of ▁ a ▁ 4" , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT a = [ 1 ] * ( n - 2 ) NEW_LINE b = [ 1 ] * ( n - 2 ) NEW_LINE a [ 1 ] = a [ 1 ] NEW_LINE b [ 1 ] = a [ 1 ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT a [ 1 ] = a [ 1 ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT a [ 1 ] = a [ 1 ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT a [ 1 ] = a [ 1 ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT a [ 1 ] = a [ 1 ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT a [ 1 ] = a [ 1 ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT a [ 1 ] = a [ 1 ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT a [ 1 ] = a [ 1 ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT a [ 1 ] = a [ 1 ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT a [ 1 ] = a [ 1 ] NEW_LINE DEDENT for i in range ( n
def centeredHexagonalSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( 3 * i * i * ( i - 1 ) + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE centeredHexagonalSeries ( n ) NEW_LINE
S = input ( ) NEW_LINE A = [ " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " , " ABC " ABC " , " ABC " , " ABC " , " ABC " , " ABC "
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( input ( ) ) NEW_LINE DEDENT l1 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] [ i ] == ' A ' : NEW_LINE INDENT l1 . append ( l [ i ] [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT l1 . append ( l [ i ] [ i ] ) NEW_LINE DEDENT DEDENT l2 . sort ( ) NEW_LINE l2 . sort ( ) NEW_LINE print ( ' ▁ ' . join ( l1 ) ) NEW_LINE
def diagonalMinMax ( mat ) : NEW_LINE INDENT n = len ( mat [ 0 ] [ 0 ] ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ n - 1 ] [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < principalMin ) : NEW_LINE INDENT principalMin = mat [ i ] [ j ] NEW_LINE DEDENT if ( mat [ i ] [ j ] > principalMin ) : NEW_LINE INDENT principalMin = mat [ i ] [ j ] NEW_LINE DEDENT if ( mat [ i ] [ j ] > principalMin ) : NEW_LINE INDENT secondaryMax = mat [ i ] [ j ] NEW_LINE DEDENT if ( mat [ i ] [ j ] > principalMin ) : NEW_LINE INDENT secondaryMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Diagonal ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ : " , secondaryMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ : " , secondaryMax ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ 1 , 2 , 4 , 5 , 10 ] NEW_LINE print ( " Principal ▁ Diagonal ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ : ▁ " , secondaryMax : ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element
def diagonalMinMax ( mat ) : NEW_LINE INDENT n = len ( mat [ 0 ] [ 0 ] ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ i ] < principalMin ) : NEW_LINE INDENT principalMin = mat [ i ] [ i ] NEW_LINE DEDENT if ( mat [ i ] [ i ] > secondaryMin ) : NEW_LINE INDENT principalMax = mat [ i ] [ n - i ] NEW_LINE DEDENT if ( mat [ n - 1 - i ] < secondaryMax ) : NEW_LINE INDENT secondaryMax = mat [ n - i - 1 ] [ i ] NEW_LINE DEDENT if ( mat [ n - 1 - i ] > secondaryMax ) : NEW_LINE INDENT secondaryMax = mat [ n - i - 1 - i ] [ i ] NEW_LINE DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Element ▁ Element ▁ Element ▁ Element : " , secondaryMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ : " , secondaryMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ : " , secondaryMax ) NEW_LINE print ( " Secondary ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ : ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁ Element ▁
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n , 1 , - 2 ) : NEW_LINE INDENT cnt += n NEW_LINE sum = sum // c NEW_LINE n = n - 2 NEW_LINE DEDENT return sum / cnt NEW_LINE DEDENT n = 10 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return int ( ( n + 1 ) / 2 ) NEW_LINE DEDENT return int ( ( n + 1 ) / 2 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE
def areElementsContiguous ( arr , n ) : NEW_LINE INDENT Sum = dict ( ) NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele > 0 : NEW_LINE INDENT curr_ele -= 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele > 0 : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT return ( count == ( len ( Sum ) ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if areElementsContiguous ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def getLeftMostOne ( zero ) : NEW_LINE INDENT if ( zero ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT zero = [ 0 ] * ( zero [ 0 ] + 1 ) NEW_LINE return 1 NEW_LINE DEDENT def getLeftMostOne ( one , one ) : NEW_LINE INDENT if ( zero [ 0 ] == one [ 0 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT one [ one [ 0 ] ] = one [ 1 ] NEW_LINE return one NEW_LINE DEDENT def getLeftMostOne ( one , one ) : NEW_LINE INDENT zero = [ ] NEW_LINE one . append ( one [ 0 ] ) NEW_LINE for i in range ( 0 , len ( one ) ) : NEW_LINE INDENT if ( one [ i ] == 0 ) : NEW_LINE INDENT zero . append ( one [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT one . append ( one [ i ] ) NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( 0 , len ( one ) ) : NEW_LINE INDENT if ( one [ i ] == 0 ) : NEW_LINE INDENT zero [ i ] = one [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT one [ i ] = one [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , q ) : NEW_LINE INDENT if ( one [ i ] == 0 ) : NEW_LINE INDENT zero [ i ] = one [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT one [ i ] = one [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , q ) : NEW_LINE INDENT print ( getLeftMostOne ( one , one [ i ] ) ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 1 , 1 ] NEW_LINE q = len ( q ) NEW_LINE q = len ( q ) NEW_LINE q = len ( q ) NEW_LINE q = len ( q ) NEW_LINE q = len ( q ) NEW_LINE q = len ( q ) NEW_LINE q = len ( q ) NEW_LINE performQueries ( q , q ) NEW_LINE
def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) NEW_LINE print ( val * ( - 1 ) , 0 ) NEW_LINE DEDENT x = 3 NEW_LINE y = 3 NEW_LINE Vertices ( x , y ) NEW_LINE
def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 ] * n NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i - 1 ] + P [ i - 1 ] NEW_LINE DEDENT S = set ( ) NEW_LINE sum = set ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT P [ i ] = 1 NEW_LINE div1 = i NEW_LINE DEDENT if ( S % i != 0 ) : NEW_LINE INDENT res = 0 NEW_LINE for j in range ( div1 , S // i + 1 , S // i ) : NEW_LINE INDENT if ( S % i != 0 or S % i != 1 ) : NEW_LINE INDENT res = 0 NEW_LINE break NEW_LINE DEDENT if ( S % i != 0 or S % i != S ) : NEW_LINE INDENT res = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( res & 1 != S ) : NEW_LINE INDENT res = 0 NEW_LINE for j in range ( S , S // i , S // i ) : NEW_LINE INDENT if ( S % j != 0 or S % i != S ) : NEW_LINE INDENT res = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( res & 1 != S ) : NEW_LINE INDENT res = res + 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( res & 1 ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE DEDENT
def originalArray ( greatest , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greatest [ i ] - i NEW_LINE arr [ k ] = temp [ k ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT originalArray ( originalArray , n ) NEW_LINE DEDENT
s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT c = input ( ) NEW_LINE if c [ 0 ] == c [ 1 ] : NEW_LINE INDENT ans += min ( len ( s ) , len ( s ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += min ( len ( s ) , len ( s ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import math as mt NEW_LINE def findRadius ( house , house ) : NEW_LINE INDENT house . sort ( reverse = True ) NEW_LINE result = - sys . maxsize NEW_LINE result = - sys . maxsize NEW_LINE for house in house : NEW_LINE INDENT index = house . index ( house ) NEW_LINE if index < 0 : NEW_LINE INDENT index = - floor ( house [ index - 1 ] - house [ index - 1 ] ) NEW_LINE DEDENT dist1 = house [ index - house [ index ] ] NEW_LINE dist2 = floor ( house [ index - 1 ] - house [ index - 1 ] ) NEW_LINE result2 = floor ( area [ index - 1 ] - house [ index - 1 ] ) NEW_LINE result2 = max ( result , dist2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE house = [ 1 , 2 , 3 ] NEW_LINE out = sObj . findRadius ( house , house ) NEW_LINE print ( out ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in eulerlib . is_prime_permutation ( i ) if not isprime_permutation ( i - 1 ) and not ( i % p and not isprime_permutation ( i - 1 ) % p ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def findLeaprepactoint_permutation ( n ) : NEW_LINE INDENT if n % 2 == 0 and not n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n % 5 == 0 and not n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return str ( n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE def checkRecursive ( num , x , k , n ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT r = int ( math . pow ( pow ( num , 1.0 / n ) / n ) ) NEW_LINE for i in range ( k + 1 , r + 1 ) : NEW_LINE INDENT a = x - pow ( i , n ) NEW_LINE if ( a >= 0.0 ) : NEW_LINE INDENT checkRecursive ( num , x - pow ( i , n ) , i , n ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( checkRecursive ( 10 , 0 , n ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE ans = " + " NEW_LINE if len ( s ) == 1 : NEW_LINE INDENT ans += " + " NEW_LINE DEDENT elif len ( s ) == 2 : NEW_LINE INDENT ans += " + " NEW_LINE DEDENT elif len ( s ) == 3 : NEW_LINE INDENT ans += " + " NEW_LINE DEDENT elif len ( s ) == 3 : NEW_LINE INDENT ans += " + " NEW_LINE DEDENT elif len ( s ) == 4 : NEW_LINE INDENT ans += " + " NEW_LINE DEDENT elif len ( s ) == 6 : NEW_LINE INDENT ans += " + " NEW_LINE DEDENT elif len ( s ) == 6 : NEW_LINE INDENT ans += " + " NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b . append ( a ) NEW_LINE DEDENT dp = [ [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i + a [ j ] [ 0 ] > dp [ i ] [ j ] + b [ i ] [ j ] > dp [ i + 1 ] [ j ] : NEW_LINE INDENT dp [ i + a [ j ] [ 0 ] = max ( dp [ i ] [ j ] , dp [ i + a [ i ] [ 1 ] + b [ j ] ) / 2 NEW_LINE DEDENT DEDENT DEDENT print ( * dp [ n ] ) NEW_LINE
n = input ( ) NEW_LINE n = len ( n ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT s = str ( n ) NEW_LINE if n % 10 == 9 : NEW_LINE INDENT s = s [ : n - 1 ] + 10 + str ( n // 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT s = s [ n - 1 : ] + str ( n // 10 ) NEW_LINE s [ n - 1 ] = s [ n - 1 : ] + str ( n // 10 ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = a + b NEW_LINE temp = a + b NEW_LINE if ( prime ( sum ) ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( prime ( sum ) ) : NEW_LINE INDENT temp += 2 NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE
def SquareSquares ( n , m , a ) : NEW_LINE INDENT return ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) NEW_LINE DEDENT n , m , a = 6 , 6 , 4 NEW_LINE print ( SquareSquares ( n , m , a ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a % b == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , i * b + 1 ) : NEW_LINE INDENT if ( j * j * j * j == i ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT a = 7 ; b = 30 ; NEW_LINE print ( " Count ▁ of ▁ Cube ▁ is " , countCubes ( a , b ) ) ; NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE w = Counter ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = Counter ( w ) NEW_LINE d = Counter ( w . values ( ) ) NEW_LINE if max ( d . values ( ) ) > 2 : NEW_LINE INDENT d [ max ( d . values ( ) ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ max ( d . values ( ) ) ] -= 1 NEW_LINE DEDENT ans = max ( d . values ( ) , max ( d . values ( ) ) , max ( d . values ( ) ) ) NEW_LINE print ( ans ) NEW_LINE
def SubStr ( str , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT print ( str [ i : j ] ) NEW_LINE DEDENT DEDENT DEDENT str = " abcd " NEW_LINE SubStr ( str , len ( str ) ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countPrimePosition ( arr ) : NEW_LINE INDENT c1 , c1 = 0 , 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 and isPrime ( i ) == 1 and isPrime ( i ) ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT if ( arr [ i ] == 1 and isPrime ( i ) ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ 1 ▁ = ▁ " , c1 ) NEW_LINE print ( " Number ▁ of ▁ 1 ▁ = ▁ " , c1 ) NEW_LINE DEDENT arr = [ 1 , 0 , 1 , 1 ] NEW_LINE countPrimePosition ( arr ) NEW_LINE
def angleexcount ( z ) : NEW_LINE INDENT print ( " The ▁ the ▁ the ▁ the ▁ the ▁ the ▁ the ▁ of ▁ the ▁ quadr " , z ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT z = 8 NEW_LINE angleexcount ( z ) NEW_LINE DEDENT
import sys NEW_LINE def printMinIndexChar ( str1 , p2 ) : NEW_LINE INDENT minIndex = sys . maxsize NEW_LINE m = len ( str1 ) NEW_LINE n = len ( str2 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( str1 [ i ] == str2 [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != sys . maxsize ) : NEW_LINE INDENT print ( " Minimum ▁ Index ▁ = ▁ " , str1 [ : minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Index ▁ = ▁ " , str1 [ : minIndex ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " geeks " NEW_LINE printMinIndexChar ( str1 , str2 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( a ) NEW_LINE DEDENT if min ( l ) < l . index ( min ( l ) ) : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT
def maxnumber ( n , k ) : NEW_LINE INDENT for j in range ( 0 , k ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 1 NEW_LINE while ( n / i ) : NEW_LINE INDENT temp = ( n / ( i * 10 ) ) * i + ( n % i ) NEW_LINE i *= 10 NEW_LINE DEDENT n = ans NEW_LINE DEDENT return n NEW_LINE DEDENT n = 6358 NEW_LINE k = 1 NEW_LINE print ( maxnumber ( n , k ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ a [ i ] % n ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] + b [ j ] == 1 : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if b [ i ] == 1 : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if b [ i ] == 1 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = A [ i ] + A [ i ] NEW_LINE if tmp > 0 : NEW_LINE INDENT ans += tmp NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def get_last_digit ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT return ans NEW_LINE DEDENT def get_last_digit ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += fac * i NEW_LINE ans += fac NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 1 NEW_LINE for N in range ( 1 , 10 ) : NEW_LINE INDENT print ( " For ▁ N ▁ = " , get_last_digit_digit ( N ) , " ▁ : ▁ " , get_last_digit_digit ( N ) ) NEW_LINE DEDENT
def binaryNumber ( binaryNumber ) : NEW_LINE INDENT binaryNumber = binaryNumber ( binaryNumber ) NEW_LINE return binaryNumber NEW_LINE DEDENT binaryNumber = "1001" NEW_LINE binaryNumber = binaryNumber ( binaryNumber ) NEW_LINE print ( binaryNumber ( binaryNumber ) ) NEW_LINE
def isPossible ( x , y , z ) : NEW_LINE INDENT a = x * x + y * y NEW_LINE if ( a == 1 and ( a ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 0.6666f NEW_LINE m = 0.5 NEW_LINE n = 0.5 NEW_LINE if ( isPossible ( l , m , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
MAX = 1000000 NEW_LINE fact = [ 1 ] * ( MAX + 1 ) NEW_LINE fact [ 0 ] = 1 NEW_LINE fact [ 0 ] = 1 NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( fact [ i - 1 ] % MOD ) * i % MOD NEW_LINE DEDENT def performQueries ( q ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += ( a [ i ] - a [ i - 1 ] ) * i NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] <= 0 : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ i ] , arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT x = abs ( arr [ i ] ) NEW_LINE if x - 1 < size and arr [ x - 1 ] > 0 : NEW_LINE INDENT arr [ x - 1 ] = - arr [ x - 1 ] NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE arr2 = [ 0 for i in range ( size ) ] NEW_LINE j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT arr2 [ i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( size ) : NEW_LINE INDENT arr2 [ j ] = arr [ i ] NEW_LINE DEDENT return findMissing ( arr2 , j ) NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT arr2 [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT return findMissing ( arr2 , j ) NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr2 , size ) NEW_LINE j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT arr2 [ j ] = arr2 [ i ] NEW_LINE j += 1 NEW_LINE DEDENT return findMissing ( arr2 , j ) NEW_LINE DEDENT arr_size = len ( arr2 ) NEW_LINE print ( " The ▁ smallest ▁ positive ▁ missing " , end = " " ) NEW_LINE
mod = 1000000007 NEW_LINE def digitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT temp = digitNumber ( ( ( n - 1 ) // 2 ) % mod ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT d = 3 NEW_LINE n = 3 NEW_LINE print ( countNumber ( n , d ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ - 1 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] + a [ i ] > b [ i ] : NEW_LINE INDENT b [ i ] = a [ i ] + b [ i ] NEW_LINE DEDENT DEDENT if b [ - 1 ] + a [ - 1 ] > b [ - 1 ] : NEW_LINE INDENT print ( - 1 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , 2 ) NEW_LINE DEDENT DEDENT
def convert12 ( str ) : NEW_LINE INDENT h1 , h2 = ord ( str [ 0 ] ) - ord ( '0' ) NEW_LINE h2 = int ( str [ 1 ] ) - ord ( '0' ) NEW_LINE if h1 < 12 : NEW_LINE INDENT Meridue = ' AM ' NEW_LINE DEDENT else : NEW_LINE INDENT Meridue = ' AM ' NEW_LINE DEDENT if h2 < 12 : NEW_LINE INDENT Meridue = ' AM ' NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Meridue = str [ 2 ] NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "7" NEW_LINE convert12 ( str ) NEW_LINE DEDENT
def check ( s , k ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ i % k ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( check ( a , i , i ) and check ( b , i ) and check ( b , i ) and check ( b , i ) and check ( b , i ) and check ( b , i ) and check ( b , i , i ) and check ( b , i ) and check ( b , i ) and check ( b , i , i ) and check ( b , i ) and check ( b , i , i ) and check ( b , i , i ) and check ( b , i , i ) ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT a = " xxXa " NEW_LINE b = " xxaxa " NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE
def printK ( a , wt , val , n ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT k = [ 0 ] * ( w + 1 ) ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( wt + 1 ) : NEW_LINE INDENT if ( i == 0 or wt [ i - 1 ] <= wt [ j ] ) : NEW_LINE INDENT k [ i ] = max ( k [ i - 1 ] + K [ i - 1 ] [ j ] , K [ i - 1 ] [ wt [ i - 1 ] ] [ wt [ i - 1 ] ] [ wt [ i - 1 ] ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT k [ i ] = k [ i - 1 ] [ wt [ i - 1 ] ] ; NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] ; NEW_LINE w = W ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( res == k ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) ; NEW_LINE w = w - w [ i - 1 ] [ wt [ i - 1 ] ] ; NEW_LINE w = w - w [ i - 1 ] [ wt [ i - 1 ] ] ; NEW_LINE w = w - w [ i - 1 ] [ wt [ i - 1 ] ] ; NEW_LINE w = w - w [ i - 1 ] [ wt [ i - 1 ] ] ; NEW_LINE w = w - w [ i - 1 ] [ wt [ i - 1 ] ] ; NEW_LINE w = w - w [ i - 1 ] [ wt [ i - 1 ] ] ; NEW_LINE w = w - w [ i - 1 ] ; NEW_LINE w = w - w [ i - 1 ] ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT w = [ 10 , 100 , 100 , 100 ] ; NEW_LINE w = 100 ; NEW_LINE n
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( x ) NEW_LINE DEDENT b = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT b . add ( a [ i ] ) NEW_LINE DEDENT DEDENT print ( sum ( b ) ) NEW_LINE
def indexSequences ( arr , n , k ) : NEW_LINE INDENT elements = [ 0 ] * ( n ) ; NEW_LINE index = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i ] = arr [ i ] ; NEW_LINE DEDENT if ( k < elements [ 0 ] ) : NEW_LINE INDENT print ( " Not ▁ found " ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( k < elements [ i ] ) : NEW_LINE INDENT elements [ i - 1 ] = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( j == 1 ) : NEW_LINE INDENT print ( " Not ▁ found " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ found " ) ; NEW_LINE DEDENT DEDENT arr = [ 6 , 7 , 8 , 9 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE index = indexSequences ( arr , n , k ) ; NEW_LINE
def larrPalindrome ( n ) : NEW_LINE INDENT upper_limit = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT upper_limit += 9 NEW_LINE DEDENT lower_limit = 1 + upper_limit // 10 NEW_LINE max_product = 0 NEW_LINE for i in range ( 1 , lower_limit ) : NEW_LINE INDENT for j in range ( i , lower_limit + 1 ) : NEW_LINE INDENT product = i * j NEW_LINE if ( product < max_product ) : NEW_LINE INDENT break NEW_LINE DEDENT number = i * j NEW_LINE number = number NEW_LINE DEDENT if ( product == reverse_product ) : NEW_LINE INDENT max_product = product NEW_LINE DEDENT number = product NEW_LINE DEDENT return max_product NEW_LINE DEDENT n = 2 NEW_LINE print ( larrigPalindrome ( n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = max ( A ) NEW_LINE m = max ( A ) NEW_LINE print ( m ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a > 0 and b > 0 ) : NEW_LINE INDENT if ( b > 0 and c > 0 ) : NEW_LINE INDENT if ( b > 0 and c > 0 ) : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT DEDENT elif ( b > 0 and c > 0 ) : NEW_LINE INDENT b -= 1 NEW_LINE DEDENT DEDENT print ( ( a + b + c ) // 2 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] > m : m = a [ i ] NEW_LINE if m < 0 : m = max ( m , a [ i ] - m ) NEW_LINE DEDENT print ( m ) NEW_LINE
def maximumXor ( arr , n ) : NEW_LINE INDENT sForward = [ ] NEW_LINE sForward . append ( - 1 ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( sForward [ i ] < arr [ sBack [ - 1 ] ] ) : NEW_LINE INDENT ans = max ( ans , arr [ sBack ( i + 1 ) ^ arr [ sBack ( sForward [ - 1 ] ^ arr [ sBackBack ( sForward ) ] ) ) NEW_LINE sBackward . append ( sBackward ) NEW_LINE DEDENT sBackward . append ( n - i - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 8 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maximumXor ( arr , n ) ) NEW_LINE
def decToHexi ( n ) : NEW_LINE INDENT hexaDigitNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = n % 16 ; NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaNum [ i ] = ( temp + 48 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT hexaNum [ i ] = ord ( temp ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT n = n // 16 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( hexaDeciNum [ j ] , end = " " ) ; NEW_LINE DEDENT DEDENT n = 2545 ; NEW_LINE decToHexi ( n ) ; NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp = [ 0 ] * ( 10 ** 9 + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ A [ i ] ] += 1 NEW_LINE DEDENT dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ A [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 1 ] NEW_LINE DEDENT print ( dp [ n ] ) NEW_LINE
while 1 : NEW_LINE INDENT r , c = map ( int , input ( ) . split ( ) ) NEW_LINE if r == 0 : break NEW_LINE s = input ( ) NEW_LINE s1 = [ 0 for i in range ( c ) ] NEW_LINE s2 = [ 0 for i in range ( r ) ] NEW_LINE for i in range ( r ) : NEW_LINE INDENT s1 [ i ] = input ( ) NEW_LINE s2 [ i ] = s1 [ i ] . count ( " _ " ) NEW_LINE DEDENT s2 = [ 0 for i in range ( r ) ] NEW_LINE for i in range ( r ) : NEW_LINE INDENT c = s1 [ i ] . count ( " _ " ) NEW_LINE s2 [ i ] = s2 [ i ] . count ( " _ " ) NEW_LINE s3 [ i ] = c NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT c = s1 [ i ] . count ( " _ " ) NEW_LINE if c == 0 : NEW_LINE INDENT ans += abs ( s1 [ i ] - s2 [ i ] ) + abs ( s2 [ i ] - s2 [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if N == 1 : NEW_LINE INDENT print ( ' Alice ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ▁ War ' ) NEW_LINE DEDENT
def extractMaximum ( str ) : NEW_LINE INDENT num = 0 NEW_LINE res = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT num = num * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE res = max ( res , num ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "100100100144" NEW_LINE print ( extractMaximum ( str ) ) NEW_LINE DEDENT
max = 5000 NEW_LINE def find_Indices ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * ( max ) NEW_LINE index = [ 0 ] * ( max ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ k ] NEW_LINE DEDENT ans = - ( ( 1e9 ) ) NEW_LINE index_2 = - 1e15 NEW_LINE index_2 = - 1e15 NEW_LINE for l in range ( n ) : NEW_LINE INDENT index = 0 NEW_LINE vmin = ( 1e15 ) NEW_LINE if ( sum [ lmin ] < vmin ) : NEW_LINE INDENT ans = sum [ lmin ] - vmin NEW_LINE index_2 = index NEW_LINE index_2 = index NEW_LINE index_3 = index NEW_LINE index_3 = index NEW_LINE index_3 = index NEW_LINE index_3 = index NEW_LINE index_3 = index NEW_LINE index_3 = index NEW_LINE index_3 = index NEW_LINE index_3 = index NEW_LINE index_3 = index NEW_LINE index_3 = index NEW_LINE index_3 = index NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_3 NEW_LINE index_3 = index_
def printElements ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , 3 , 1 , 5 , 8 , 9 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE printElements ( arr , n ) NEW_LINE
def value ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ar [ i ] NEW_LINE DEDENT if sum % n == 0 : NEW_LINE INDENT return sum // n NEW_LINE DEDENT else : NEW_LINE INDENT A = sum // n NEW_LINE B = sum // n NEW_LINE ValueB = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ValueA += ( ar [ i ] - A [ i ] ) * ( ar [ i ] - B [ i ] ) NEW_LINE ValueB += ( ar [ i ] - B [ i ] ) * ( ar [ i ] - B [ i ] ) NEW_LINE DEDENT if ValueA < ValueB : NEW_LINE INDENT return A NEW_LINE DEDENT DEDENT return B NEW_LINE DEDENT n = 7 NEW_LINE arr = [ 6 , 9 , 1 , 6 , 7 ] NEW_LINE print ( value ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , l = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] & b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
s = input ( ) NEW_LINE l = len ( s ) NEW_LINE if l % 2 == 0 : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l - 1 ) NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 19 NEW_LINE for curr in range ( n , 0 , - 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for x in range ( curr , 0 , - 1 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT DEDENT print ( findNth ( 5 ) ) NEW_LINE
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 1 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE while x > 0 : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x / 10 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT DEDENT print ( findNth ( 5 ) ) NEW_LINE
def countNumber ( N , S ) : NEW_LINE INDENT countElements = 0 NEW_LINE currSum = 0 NEW_LINE while ( currSum <= S ) : NEW_LINE INDENT currSum += N NEW_LINE N -= 1 NEW_LINE DEDENT return countElements NEW_LINE DEDENT N = 5 NEW_LINE S = 11 NEW_LINE count = countNumber ( N , S ) NEW_LINE print ( count ) NEW_LINE
def strmatch ( str , pattern , pattern ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return ( n == 0 ) NEW_LINE DEDENT lookup = [ [ 0 for i in range ( m + 1 ) ] for j in range ( 1 , m + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( pattern [ i - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ i - 1 ] == ' * ' or pattern [ j - 1 ] == pattern [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return lookup [ n ] [ m ] NEW_LINE DEDENT str = " abaaab " NEW_LINE pattern = " * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * " NEW_LINE if ( strmatch ( str , pattern , pattern , pattern ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE from math import sqrt NEW_LINE def prime ( n ) : NEW_LINE INDENT a , b = n , m NEW_LINE while n != 0 : NEW_LINE INDENT a , b = n , a % b NEW_LINE n = n // a NEW_LINE DEDENT return a NEW_LINE DEDENT def prime ( n ) : NEW_LINE INDENT a , b = n , m NEW_LINE while True : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if a % b == 0 : NEW_LINE INDENT a //= b NEW_LINE DEDENT else : NEW_LINE INDENT a //= b NEW_LINE DEDENT DEDENT return prime ( a ) NEW_LINE DEDENT def prime_factorize ( n ) : NEW_LINE INDENT prime_factorize = prime_factorize ( n ) NEW_LINE prime_factorize = prime_factorize ( n ) NEW_LINE prime_factorize = prime_factorize ( n ) NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_
def nCr ( n , r ) : NEW_LINE INDENT fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT ans = fac [ n - r ] / ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = nCr ( n + k - 1 , k - 1 ) NEW_LINE print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if abs ( a [ i ] - a [ i + 1 ] ) < abs ( a [ i ] - a [ i + 1 ] ) : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powGCD ( a , n , b ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a = a * a NEW_LINE DEDENT return gcd ( a , b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 5 NEW_LINE n = 2 NEW_LINE print ( powGCD ( a , n , b ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ a [ i ] ] = d . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT d [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT d [ a [ i ] ] += d [ a [ i ] ] NEW_LINE DEDENT print ( * d ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in s : NEW_LINE INDENT if i == '8' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def sumSumDigit ( n , b ) : NEW_LINE INDENT unitDigit = 0 ; NEW_LINE sumDigit = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b ; NEW_LINE sumDigit += unitDigit ; NEW_LINE n = n // b ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 50 ; NEW_LINE b = 2 ; NEW_LINE print ( sumDigit ( n , b ) ) ; NEW_LINE
import math NEW_LINE def printLargestDivisible ( n , a ) : NEW_LINE INDENT c0 = 0 ; NEW_LINE c0 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT c0 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c0 += 1 ; NEW_LINE DEDENT DEDENT c0 = math . floor ( c0 / 9 ) * 9 ; NEW_LINE if ( c0 == 0 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( c0 ) : NEW_LINE INDENT print ( "0" , end = " " ) ; NEW_LINE DEDENT for i in range ( c0 ) : NEW_LINE INDENT print ( "0" , end = " " ) ; NEW_LINE DEDENT for i in range ( c0 ) : NEW_LINE INDENT print ( "0" , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT a = [ 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE printLargestDivisible ( n , a ) ; NEW_LINE
def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT if ( i + j + k + k == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE
def numberOfMinutes ( S , S1 ) : NEW_LINE INDENT Min = ( ( S - S1 ) // floor ( S1 ) ) * 60 NEW_LINE return Min NEW_LINE DEDENT S = 30 NEW_LINE S1 = 10 NEW_LINE print ( numberOfMinutes ( S , S1 ) , " ▁ " , end = " " ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n < m : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT m -= 1 NEW_LINE b . sort ( reverse = True ) NEW_LINE d = b [ 0 ] - b [ 0 ] + 1 NEW_LINE d = b [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT d += b [ i ] - b [ i - 1 ] NEW_LINE DEDENT print ( d ) NEW_LINE DEDENT
import math NEW_LINE def oneComplement ( n ) : NEW_LINE INDENT number_of_bits = int ( math . floor ( math . log ( n ) ) / math . log ( 2 ) ) NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ n NEW_LINE DEDENT n = 22 NEW_LINE print ( oneComplement ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT w , h , n = map ( int , input ( ) . split ( ) ) NEW_LINE while n % 2 == 0 : NEW_LINE INDENT if h % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT else : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT DEDENT if n >= ( h - 1 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( " ( " , ( 2 * x2 - x1 ) ) , end = " , " , " , ▁ " ) NEW_LINE DEDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 1 NEW_LINE y2 = 1 NEW_LINE findPoint ( x1 , y2 , x2 , y2 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( x ) NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT b . append ( y ) NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT ans . append ( ans [ i ] - 1 ) NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT ans . append ( ans [ i ] - 1 ) NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT ans . append ( ans [ i ] - 1 ) NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT ans . append ( ans [ i ] - 1 ) NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT ans . append ( ans [ i ] - 1 ) NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT ans . append ( ans [ i ] - 1 ) NEW_LINE DEDENT print ( * ans , sep = ' \n ' ) NEW_LINE
def modify ( x , y ) : NEW_LINE INDENT while ( x >= 0 or y == 0 ) : NEW_LINE INDENT x = x % ( 2 * x ) NEW_LINE DEDENT elif ( x >= 2 * y ) : NEW_LINE INDENT y = x % ( 2 * x ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 2 NEW_LINE y = 2 NEW_LINE print ( " X ▁ = ▁ " , x , " , ▁ = " , y ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . add ( a [ i ] - a [ i ] ) NEW_LINE DEDENT b = set ( b ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT b . add ( b [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT b . add ( b ) NEW_LINE c = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += b [ i ] NEW_LINE b . add ( b [ i ] - b [ i - 1 ] ) NEW_LINE DEDENT print ( c ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] != b [ i + 1 ] ) : NEW_LINE INDENT print ( i + 1 , i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
mod2 = 1000000007 NEW_LINE def modulo2 ( num ) : NEW_LINE INDENT res = 0 NEW_LINE for i in num : NEW_LINE INDENT res = ( res * 10 + ord ( num [ i ] ) - ord ( '0' ) ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT def findSum ( L , R ) : NEW_LINE INDENT a = modulo2 ( R ) NEW_LINE b = modulo2 ( R ) NEW_LINE l = ( ( a * ( b - 1 ) ) ) % modulo2 NEW_LINE r = ( b * ( r - 1 ) ) % modulo2 NEW_LINE if ( r < 0 ) : NEW_LINE INDENT return ( r + modulo2 ) % modulo2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( r % modulo2 ( r * ( b - 1 ) ) % modulo2 ) % modulo2 NEW_LINE DEDENT DEDENT L = " 888147483647472384 ) NEW_LINE R = "897932384626433147483647" NEW_LINE print ( findSum ( L , R ) ) NEW_LINE
def unsort ( l , r , a , k ) : NEW_LINE INDENT if ( k < 1 or l + r == r ) : NEW_LINE INDENT return NEW_LINE DEDENT mid = ( l + r ) // 2 NEW_LINE mid = ( l + r ) // 2 NEW_LINE a [ mid - 1 ] = a [ mid - 1 ] NEW_LINE a [ mid - 1 ] = a [ mid - 1 ] NEW_LINE uniq ( mid , mid , a , k ) NEW_LINE uniq ( mid , a , a , k ) NEW_LINE uniq ( mid , a , k ) NEW_LINE uniq ( mid , a , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = i + 1 NEW_LINE DEDENT DEDENT def arrayWithOccacts ( n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( " NO ▁ solution " ) NEW_LINE return NEW_LINE DEDENT a = [ 0 for i in range ( n ) ] NEW_LINE a [ 0 ] = 1 NEW_LINE uniq ( 0 , n , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = i + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE k = 10 NEW_LINE array = 17 NEW_LINE array = [ 0 for i in range ( n ) ] NEW_LINE array = unsortFlacts ( n , k , a , k ) NEW_LINE
import math NEW_LINE def mean ( mid , freq , n ) : NEW_LINE INDENT sum = 0 NEW_LINE freqSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + mid [ i ] * freq [ i ] NEW_LINE freqSum = freqSum + freqSum NEW_LINE DEDENT return sum / freq NEW_LINE DEDENT def median ( lower_limit , upper_limit , n ) : NEW_LINE INDENT mid = [ 0 for i in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mid [ i ] = ( lower [ i ] + upper_limit [ i ] ) / 2 NEW_LINE sum = sum + freq [ i ] * mid [ i ] NEW_LINE freqSum = freqSum + freq [ i ] * mid [ i ] NEW_LINE freqSum = freqSum + freqSum NEW_LINE DEDENT DEDENT def groupedS ( lower , upper_limit , n ) : NEW_LINE INDENT mid = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mid = ( lower_limit - upper_limit ) / 2 NEW_LINE sum = sum + freq [ i ] * mid [ i ] NEW_LINE freqSum = freqSum + freq [ i ] * mid [ i ] NEW_LINE freqSum = freqSum + freqSum NEW_LINE DEDENT return sum NEW_LINE DEDENT lower_limit = [ 50 , 70 , 81 , 81 , 81 , 81 ] NEW_LINE upper = [ 9 , 70 , 81 , 81 , 98 ] NEW_LINE n = len ( lower ) NEW_LINE print ( groupedS ( lower , upper_limit , upper_limit , n ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE
def rectanglearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( rectanglearea ( a , b ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n < a * b : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def getsum ( x ) : NEW_LINE INDENT return ( x * ( x + 1 ) / 2 ) / 2 NEW_LINE DEDENT def countJumps ( n ) : NEW_LINE INDENT n = abs ( n ) NEW_LINE ans = 0 NEW_LINE while ( reversum ( n ) < n or ( reversum ( ans ) - n ) & 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 9 NEW_LINE print ( countJumps ( n ) ) NEW_LINE
MAX = 10 NEW_LINE def lcs ( dp , arr1 , arr2 , n , m , k ) : NEW_LINE INDENT if ( k < 0 or k < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = max ( lcs ( dp , arr1 , arr2 , n - 1 , arr2 , m - 1 , k ) , lcs ( dp , arr2 , n - 1 , arr2 , m - 1 , k - 1 , k ) ) NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = max ( ans , 1 + lcs ( dp , arr1 , arr2 , arr2 , n - 1 , arr2 , arr2 , n - 1 , arr2 , m - 1 , k - 1 , k - 1 ) ) NEW_LINE if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , arr2 , arr2 , n - 1 , arr2 , arr2 , m - 1 , k - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 1 NEW_LINE arr1 = [ 1 , 2 , 3 , 4 ] NEW_LINE arr2 = [ 5 , 3 , 4 , 4 ] NEW_LINE arr2 = [ 5 , 3 , 4 , 4 ] NEW_LINE n = len ( arr2 ) NEW_LINE m = len ( arr2 ) NEW_LINE dp2 = [ 5 , 3 , 1 ] NEW_LINE dp2 = [ 5 , 3 , 4 ] NEW_LINE print ( lcs ( dp1 , arr2 , n , m , k ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , d , x = map ( int , input ( ) . split ( ) ) NEW_LINE print ( sum ( ( d + ( n - 1 ) / n ) / n ) / n ) NEW_LINE
def reverseOrder ( n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE for p in range ( n ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( n , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2 ; NEW_LINE print ( " No ▁ number ▁ in ▁ reverse ▁ " ) ; NEW_LINE if ( reverseOrder ( N ) ) : NEW_LINE INDENT reverseOrder ( N ) ; NEW_LINE DEDENT else : NEW_LINE INDENT reverseOrder ( N ) ; NEW_LINE DEDENT DEDENT
def pattern ( min_groups , p_len ) : NEW_LINE INDENT p_len = p_len - 1 NEW_LINE x = 1 NEW_LINE for i in range ( p_len ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE for j in range ( p_len ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for k in range ( p_len ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for k in range ( p_len ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for k in range ( p_len ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT min_groups = 1 NEW_LINE pattern ( min_groups , p_len ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE mx , mx , ny = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE a , b = int ( a ) , int ( b ) NEW_LINE mx = max ( mx , mx ) NEW_LINE mx = max ( mx , mx ) NEW_LINE mx = max ( mx , mx ) NEW_LINE DEDENT print ( 2 * mx ) NEW_LINE
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE
from math import sqrt NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return int ( sqrt ( phi ) ) / 2.0 NEW_LINE DEDENT def calculateFibonacci ( l , r ) : NEW_LINE INDENT sum = fib ( r ) - fib ( l + 1 ) / 2 NEW_LINE return sum NEW_LINE DEDENT def sumFibonacci ( l , r ) : NEW_LINE INDENT l = ( k * ( r - 1 ) ) // 2 NEW_LINE r = l + k NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = 3 NEW_LINE print ( sumFibonacci ( k ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return int ( sqrt ( phi ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( phi ( i ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE
from math import sqrt NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return int ( pow ( phi , n ) - fib ( 5 ) / sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , r = 4 , 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE DEDENT
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE s [ l - 1 ] , s [ r - 1 ] = s [ l - 1 ] , s [ r - 1 ] NEW_LINE DEDENT print ( * s , sep = ' ' ) NEW_LINE
def compareStrings ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( str1 ) and str2 [ i ] == str2 [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( str1 [ i ] > str2 [ i ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def searchStrings ( str1 , str2 , str2 , n ) : NEW_LINE INDENT if ( first > last and str2 [ 0 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( last + first ) // 2 NEW_LINE if ( mid <= last and n <= last ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT def searchStrings ( str1 , str2 , str2 ) : NEW_LINE INDENT if ( str1 > last and str2 > last ) : NEW_LINE INDENT left = mid - 1 NEW_LINE right = mid + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( left <= right and right > last ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( right <= right and not ( str1 < right and str2 < last ) ) : NEW_LINE INDENT return searchStr ( str1 , str2 , str2 ) NEW_LINE DEDENT if ( left <= right and right > last ) : NEW_LINE INDENT return searchStr ( str1 , str2 , str2 ) NEW_LINE DEDENT right = mid - 1 NEW_LINE DEDENT if ( compareStrings ( str1 , str2 [ mid ] , str2 [ right ] ) ) : NEW_LINE INDENT return searchStrings ( str1 , str2 [ left ] , str2 [ right ] ) NEW_LINE DEDENT return searchStrings ( str1 , str2 [ mid ] , str2 [ mid ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = " for " , " , " q " , " q " , " q " , "
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = str ( a ) NEW_LINE d = str ( b ) NEW_LINE ans = ' ' NEW_LINE for i in range ( len ( c ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT ans += c [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += d [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x = x1 - x2 NEW_LINE y = y1 - y2 NEW_LINE z = x1 + y2 - y1 NEW_LINE print ( 3 ) NEW_LINE print ( 3 ) NEW_LINE print ( 3 ) NEW_LINE print ( 3 ) NEW_LINE print ( 3 ) NEW_LINE print ( 3 ) NEW_LINE print ( 3 ) NEW_LINE print ( 3 ) NEW_LINE print ( 3 ) NEW_LINE print ( 3 ) NEW_LINE print ( 3 ) NEW_LINE print ( 3 ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = sorted ( s ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] not in a : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def sumAP ( n , d ) : NEW_LINE INDENT n //= d NEW_LINE return ( n * ( 1 + n ) * d // 2 ) NEW_LINE DEDENT def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE return sumAP ( n , 2 ) NEW_LINE DEDENT n = 20 NEW_LINE print ( sumMultiples ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE lst = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE lst . append ( x ) NEW_LINE DEDENT sum = sum - lst [ : n ] NEW_LINE sum = sum - sum NEW_LINE if sum <= sum : NEW_LINE INDENT print ( " OK " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NG " ) NEW_LINE DEDENT DEDENT
def fact ( num ) : NEW_LINE INDENT fact = 1 NEW_LINE while ( num > 1 ) : NEW_LINE INDENT fact *= num NEW_LINE num -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT return fact ( 2 * n ) // ( factorial ( n ) * factorial ( n - 1 ) ) NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT return fact ( 2 * n - 1 ) // ( factorial ( n ) ) NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 ] NEW_LINE k = catalan ( n ) NEW_LINE catalan ( n ) NEW_LINE catalan ( salan ) NEW_LINE print ( int ( totalalan ( salan ) , end = " ▁ " ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if abs ( a - b ) == abs ( a - b ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a % 2 != b % 2 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( b - a ) % 2 ) NEW_LINE DEDENT DEDENT
def countWays ( n , arr , length ) : NEW_LINE INDENT count = [ 0 for i in range ( n + 1 ) ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in range ( 0 , length + 1 ) : NEW_LINE INDENT if ( i - arr [ j ] >= 0 ) : NEW_LINE INDENT no_ways += count [ i - arr [ j ] ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countWays ( arr , n , length ) ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT times = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT times . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT times . sort ( reverse = True ) NEW_LINE sumTime = sum ( times [ : len ( times ) - times [ 0 ] ) NEW_LINE if sumTime >= times [ : - 1 ] : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a == b and c == a ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( b == c and c == b ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( a == b and c == a ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in l : NEW_LINE INDENT if i <= d : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , key ) NEW_LINE DEDENT return binarySearch ( arr , ( mid - 1 ) , key NEW_LINE DEDENT arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 10 NEW_LINE print ( " Index : " , binarySearch ( arr , 0 , n , k ) ) NEW_LINE
def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE Xor = Xor ^ arr [ i ] NEW_LINE DEDENT if Sum == Xor : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT arr = [ 6 , 3 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE equal_xor_sum ( arr , n ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if x [ 0 ] == 1 : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT
def findPairs ( arr , n ) : NEW_LINE INDENT cntEven = 0 NEW_LINE cntOdd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 NEW_LINE DEDENT DEDENT evenPairs = 0 NEW_LINE evenPairs = 0 NEW_LINE evenPairs = 0 NEW_LINE evenPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE oddPairs = 0 NEW_LINE print ( " Odd ▁ pairs ▁ = ▁ pairs ▁ = ▁ = ▁ " , evenPairs ) NEW_LINE printPairs NEW_LINE
import sys NEW_LINE def minBottbeRange ( houses , towers ) : NEW_LINE INDENT n , m = len ( houses ) ; NEW_LINE leftT = - sys . maxsize ; NEW_LINE right = 0 ; NEW_LINE k = 0 ; NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( houses [ j ] < right ) : NEW_LINE INDENT left = houses [ j ] - left ; NEW_LINE right = right ; NEW_LINE DEDENT else : NEW_LINE INDENT left = houses [ j ] - houses [ j ] ; NEW_LINE right = right ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT left = houses [ k ] ; NEW_LINE j = 0 ; NEW_LINE k = 0 ; NEW_LINE while ( j < n - 1 ) : NEW_LINE INDENT if ( k < m ) : NEW_LINE INDENT k += 1 ; NEW_LINE right = k ; NEW_LINE DEDENT else : NEW_LINE INDENT right = k ; NEW_LINE DEDENT DEDENT if ( k < m - 1 ) : NEW_LINE INDENT k += 1 ; NEW_LINE right = k ; NEW_LINE DEDENT else : NEW_LINE INDENT right = sys . maxsize ; NEW_LINE DEDENT DEDENT return min ; NEW_LINE DEDENT a = [ 12 , 13 , 11 , 80 ] ; NEW_LINE b = [ 4 , 6 , 80 ] ; NEW_LINE print ( minBottbeRange ( a , b ) ) ; NEW_LINE
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num / divisor ) ) NEW_LINE DEDENT print ( getRemainder ( 100 , 7 ) ) NEW_LINE
n , m , z = map ( int , input ( ) . split ( ) ) NEW_LINE print ( sum ( z == z for z in range ( 1 , n + 1 ) ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( m , k ) : NEW_LINE INDENT w = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT w [ i ] += w [ i ] NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT w [ i ] += w [ i - 1 ] NEW_LINE DEDENT ans = m NEW_LINE while ans > 0 : NEW_LINE INDENT ans = max ( ans , w [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( m , k ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , w = map ( int , input ( ) . split ( ) ) NEW_LINE w = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT v , w = map ( int , input ( ) . split ( ) ) NEW_LINE s += v * w NEW_LINE w . append ( v ) NEW_LINE DEDENT w = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if w [ i ] / w [ i ] >= w [ i ] : NEW_LINE INDENT w += w [ i ] / w [ i ] NEW_LINE DEDENT DEDENT print ( sum ( w ) ) NEW_LINE
def getOne ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos_bit = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT twos_bit = twos_bit | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ thos_bit NEW_LINE DEDENT return ones NEW_LINE DEDENT arr = [ 3 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ element ▁ is " , getOne ( arr , n ) ) NEW_LINE
def maxdiff ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( freq [ arr [ i ] ] > freq [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ j ] ) NEW_LINE DEDENT elif ( freq [ arr [ i ] ] < arr [ j ] ) and ( freq [ arr [ i ] ] < arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 1 , 3 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxdiff ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < 0 : NEW_LINE INDENT b [ i ] = 0 NEW_LINE DEDENT if b [ i ] < 0 : NEW_LINE INDENT b [ i ] = 0 NEW_LINE DEDENT if b [ i ] < 0 : NEW_LINE INDENT b [ i ] = 0 NEW_LINE DEDENT DEDENT if b [ i ] < 0 : NEW_LINE INDENT ans += b [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def makeAP ( arr , n ) : NEW_LINE INDENT common_term = arr [ 2 ] - arr [ 1 ] NEW_LINE if ( n == 3 ) : NEW_LINE INDENT common_term = arr [ 1 ] - arr [ 1 ] NEW_LINE common_term = arr [ 1 ] - arr [ 0 ] NEW_LINE common_term = arr [ 1 ] - arr [ 2 ] NEW_LINE common_term = arr [ 1 ] - arr [ 2 ] NEW_LINE DEDENT elif ( ( ( arr [ 1 ] - arr [ 2 ] ) == ( arr [ 2 ] - arr [ 1 ] ) ) : NEW_LINE INDENT common_term = arr [ 1 ] - arr [ 0 ] NEW_LINE common_term = arr [ 1 ] - common_term NEW_LINE DEDENT elif ( ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 2 ] - arr [ 1 ] ) ) ) : NEW_LINE INDENT common_term = arr [ 1 ] - arr [ 1 ] NEW_LINE common_term = arr [ 2 ] - common_term NEW_LINE DEDENT else : NEW_LINE INDENT common_term = ( arr [ 2 ] - arr [ 0 ] ) // 3 NEW_LINE common_term = ( ( arr [ 3 ] - arr [ 1 ] ) // 3 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( make_term , i * common_term ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( countPairs ( n ) ) ; NEW_LINE
def countPairs ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT n = 15 ; NEW_LINE print ( countPairs ( n ) ) ; NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def longestPalindrome ( self , s ) : NEW_LINE INDENT count = [ 0 ] * 256 NEW_LINE for c in s : NEW_LINE INDENT count [ c ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for v in count . items ( ) : NEW_LINE INDENT ans += v // 2 * 2 NEW_LINE if v % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE sObj = " abccccdd " NEW_LINE out = sObj . longestPalindrome " NEW_LINE print ( out ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalanays ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return catalanalan ( n // 2 ) NEW_LINE DEDENT def catalanays ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return catalanays ( n // 2 ) NEW_LINE DEDENT def findWays ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return catalanays ( n // 2 ) NEW_LINE DEDENT n = 6 NEW_LINE print ( " Total ▁ possible ▁ of ▁ " , n , " is " , findalanays ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE l . append ( s ) NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if l [ i ] [ j ] == ' X ' : NEW_LINE INDENT ans . append ( l [ i ] [ j ] ) NEW_LINE DEDENT DEDENT if l [ 0 ] [ j ] == ' X ' : NEW_LINE INDENT ans . append ( l [ 1 ] [ j ] ) NEW_LINE DEDENT DEDENT print ( ' x ' * ans ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def resolve ( ) : NEW_LINE INDENT P , T , A , B , T = map ( int , input ( ) . split ( ) ) NEW_LINE def resolve ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = A - B NEW_LINE B = A - A * T NEW_LINE C = A - B * T NEW_LINE B = A - B * T NEW_LINE C = A - B * T NEW_LINE if C == A : NEW_LINE INDENT return False NEW_LINE DEDENT if C == B : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT print ( " YES " ) NEW_LINE DEDENT resolve ( ) NEW_LINE
def isSumPairsOfTwo ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT n = 10 NEW_LINE if ( isSumPairsOfTwo ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT s = list ( ) NEW_LINE if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT x = s [ - 1 ] NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . pop ( ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE print ( countNumber ( n ) ) NEW_LINE
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for i in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] / ( 2 * N - 1 ) / ( 2 * N - 1 ) NEW_LINE DEDENT cost = [ [ 1 , 2 ] , 3 ] , [ 6 , 5 , 9 ] ] NEW_LINE print ( maxAverageOfPath ( cost , 3 ) ) NEW_LINE
MAX = 1000000 NEW_LINE sieve_Prime = [ 0 ] * ( MAX + 4 ) NEW_LINE sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( sieve_Prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if ( sieve_Prime [ j ] == 0 ) : NEW_LINE INDENT sieve_Prime [ j ] += 1 NEW_LINE sieve_Prime [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def print ( " Count ▁ = ▁ " , sieve_Prime [ n ] ) : NEW_LINE INDENT for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( sieve_Prime [ i ] == 0 ) : NEW_LINE INDENT sieve_Prime [ j ] += 1 NEW_LINE sieve_Prime [ i ] += 1 NEW_LINE DEDENT DEDENT print ( " Count ▁ = ▁ " , sieve_Prime [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = ▁ " , sieve_Prime [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = ▁ " , sieve_Prime [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = ▁ " , sieve_Prime [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = " , sieve_Prime [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = " , sieve_Prime [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = " , sieve_Prime [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = " , sieve_Prime [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = " , sieve_Prime [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = " , print (
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , k , t , u , v , t = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE t = [ 0 ] * n NEW_LINE t [ 0 ] = t [ 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ i ] = min ( d [ i ] , t [ i ] + t [ i ] ) / v NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d [ i ] > t [ i ] : NEW_LINE INDENT ans += t [ i ] - t [ i ] / v NEW_LINE t [ i ] = min ( d [ i ] , t [ i ] + t [ i ] ) / v NEW_LINE DEDENT else : NEW_LINE INDENT ans += t [ i ] / v [ i ] NEW_LINE t [ i ] = min ( d [ i ] , t [ i ] + t [ i ] / v ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE prefix = [ 0 ] * ( n ) NEW_LINE suffix [ 0 ] = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev [ i - 1 ] = prefix [ i - 1 ] NEW_LINE if ( prefix [ i - 1 ] == 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev + ( prev [ i - 1 ] ) NEW_LINE DEDENT DEDENT suffix [ n - 1 ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prefix [ i ] = prev [ i - 1 ] NEW_LINE DEDENT suffix [ n - 1 ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prefix [ i ] += ( prev [ i - 1 ] + 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i - 1 ] ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev [ i - 1 ] + 1 ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ababa " NEW_LINE print ( waysToSplit ( s ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT Trees = [ [ 0 for i in range ( T ) ] for i in range ( Trees ) ] NEW_LINE for i in range ( 1 , Trees + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if j < i : NEW_LINE INDENT trees [ i ] [ j ] = trees [ i - 1 ] [ j - 1 ] * i NEW_LINE if j > 0 : NEW_LINE INDENT trees [ i ] [ j ] = trees [ i - 1 ] [ j - 1 ] * i NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = sum ( ans ) / len ( ans ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in d : NEW_LINE INDENT d [ a [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT m = max ( d . values ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d [ i ] == 1 : NEW_LINE INDENT print ( i , m ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( m ) NEW_LINE
def merge ( m , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = arr [ i ] NEW_LINE for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( j != 0 and arr [ j ] > arr [ i ] ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE DEDENT if ( j != m - 1 or arr [ i ] > arr [ i ] ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ i ] NEW_LINE DEDENT DEDENT if j != m - 2 or arr [ i ] > arr [ i ] : NEW_LINE INDENT arr [ j + 1 ] = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT def merge ( m , n ) : NEW_LINE INDENT merge ( m , n ) NEW_LINE print ( " After ▁ Array ▁ : ▁ " , merge ( m , n ) ) NEW_LINE print ( " After ▁ Array ▁ : ▁ " , merge ( m , n ) ) NEW_LINE DEDENT merge ( arr , n ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def sameRemainder ( a , b , c ) : NEW_LINE INDENT a1 = ( b - a ) NEW_LINE b1 = ( c - b ) ( c1 ) NEW_LINE return gcd ( a1 , gcd ( b1 , g1 ) ) NEW_LINE DEDENT a = 62 NEW_LINE b = 132 NEW_LINE c = 132 NEW_LINE print ( sameRemainder ( a , b , c ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( min ( a + b , c - a ) + d ) - ( d + c - b ) ) NEW_LINE
dp = [ [ 0 for i in range ( 51 ) ] for j in range ( 51 ) ] NEW_LINE def countWays ( n , part , next ) : NEW_LINE INDENT if ( n <= 0 and n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ next ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ next ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( next ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , part - 1 , i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT ans = 0 NEW_LINE for j in range ( 0 , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , part - 1 , i , j ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n , 4 ) ) NEW_LINE
def find_k ( a , b ) : NEW_LINE INDENT if ( ( a + b ) % 2 == 0 ) : NEW_LINE INDENT return ( ( a + b ) // 2 ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT a = 2 NEW_LINE b = 16 NEW_LINE print ( find_k ( a , b ) ) NEW_LINE
N = 101 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE x = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 0 , y + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT x [ i ] [ j ] += ( ( x [ i - 1 ] * 10 + 4 * x [ j - 1 ] [ k - 1 ] * 10 + 4 * x [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT x [ i ] [ j ] += ( ( x [ i - 1 ] [ j - 1 ] * 10 + 4 * x [ i - 1 ] [ j - 1 ] ) % mod ) % mod NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT x [ i ] [ j ] += ( ( x [ i - 1 ] [ j - 1 ] * 10 + 6 * x [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT DEDENT if ( k > 0 ) : NEW_LINE INDENT ans += ( ( x [ i ] [ j - 1 ] * 10 + 6 * x [ i - 1 ] [ j - 1 ] ) * ( x [ i ] [ j - 1 ] * 10 + 6 * x [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT x = 1 NEW_LINE y = 1 NEW_LINE z = 1 NEW_LINE print ( getSum ( x , y , z ) ) NEW_LINE
def isValidString ( str ) : NEW_LINE INDENT freq = [ 0 ] * ( len ( str ) ) NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT freq1 = 0 NEW_LINE freq1 = 0 NEW_LINE count_freq1 = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT freq1 += 1 NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( freq [ j ] == 0 ) : NEW_LINE INDENT if ( freq1 == freq1 ) : NEW_LINE INDENT count_freq1 += 1 NEW_LINE freq2 += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( freq1 == 0 and freq1 > 1 ) : NEW_LINE INDENT count_freq2 += 1 NEW_LINE freq2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isValidString ( str ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abcba " NEW_LINE if ( isValidString ( str ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE if ( len ( s ) % 2 != 0 ) : NEW_LINE INDENT print ( " a " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( s ) % 2 != 0 ) : NEW_LINE INDENT print ( " b " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " a " , end = " " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT
def findMinimumSubsequences ( A , B ) : NEW_LINE INDENT numberOfSubstrings = 1 NEW_LINE sizeOfB = len ( A ) NEW_LINE inf = 1000000 NEW_LINE d = [ [ 0 for i in range ( size ) ] for i in range ( sizeOfB ) ] NEW_LINE for i in range ( 0 , sizeOfB ) : NEW_LINE INDENT for j in range ( 0 , sizeOfB ) : NEW_LINE INDENT next [ i ] [ j ] = i NEW_LINE DEDENT DEDENT for i in range ( 0 , sizeOfB ) : NEW_LINE INDENT for j in range ( 0 , sizeOfB ) : NEW_LINE INDENT if ( next [ i ] [ j ] == inf ) : NEW_LINE INDENT next [ i ] [ j ] = next [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , sizeOfB ) : NEW_LINE INDENT for j in range ( 0 , sizeOfB ) : NEW_LINE INDENT if ( next [ i ] [ j ] == inf ) : NEW_LINE INDENT numberOfSubstrings = - 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT pos = 0 NEW_LINE i = 0 NEW_LINE while ( i < sizeOfB ) : NEW_LINE INDENT if ( pos [ A [ i ] [ pos ] ] == inf ) : NEW_LINE INDENT numberOfSubstrings = - 1 NEW_LINE i = next [ i ] [ pos + 1 ] = next [ i ] [ pos + 1 ] NEW_LINE i = next [ i ] [ pos + 1 ] NEW_LINE i = next NEW_LINE DEDENT elif ( pos [ A [ i ] [ pos ] ] == inf ) : NEW_LINE INDENT numberOfSubstrings += 1 NEW_LINE i = next [ i ] [ pos ] = next NEW_LINE i = next NEW_LINE DEDENT else : NEW_LINE INDENT numberOfSubstrings += 1 NEW_LINE i = next NEW_LINE DEDENT DEDENT return numberOfSubstrings NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = " a " NEW_LINE B = " aceab " NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = [ ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT a . append ( [ abs ( i - h ) + abs ( i - h ) + abs ( i - h ) + abs ( i - h ) ] ) NEW_LINE DEDENT ans . append ( " \n " . join ( map ( str , ans ) ) ) NEW_LINE DEDENT for i in range ( t ) : NEW_LINE INDENT print ( " \n " . join ( map ( str , ans ) ) ) NEW_LINE DEDENT
def FindRank ( arr , length ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT k = k + 1 NEW_LINE DEDENT print ( k , end = " ▁ " ) NEW_LINE DEDENT print ( " ▁ " , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 8 , 16 , 16 , 64 , 64 ] NEW_LINE Len = len ( arr ) NEW_LINE FindRank ( arr , length ) NEW_LINE
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE ans = 10 ** 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if h [ i ] > b [ 0 ] : NEW_LINE INDENT ans = min ( ans , i + h [ 1 ] // a [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( product / 10 ) : NEW_LINE INDENT product = product // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n , k = 15 , 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT m , n = map ( int , line . split ( ) ) NEW_LINE if m < n : m = n NEW_LINE print ( m ) NEW_LINE DEDENT
s = input ( ) NEW_LINE a = [ 0 ] * 26 NEW_LINE for i in s : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT b = 0 NEW_LINE for i in a : NEW_LINE INDENT if i in b : NEW_LINE INDENT b += i NEW_LINE DEDENT DEDENT print ( b // 2 ) NEW_LINE
def complement ( n ) : NEW_LINE INDENT len = 0 NEW_LINE temp = n NEW_LINE while ( True ) : NEW_LINE INDENT len += 1 NEW_LINE temp = num // 10 NEW_LINE if ( abs ( temp ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT num = temp NEW_LINE comp = pow ( 10 , len ) - num NEW_LINE return comp NEW_LINE DEDENT print ( complement ( 4 ) ) NEW_LINE print ( complement ( 456 ) ) NEW_LINE
def countUnsetBits ( n ) : NEW_LINE INDENT x = n ; NEW_LINE n |= n >> 1 ; NEW_LINE n |= n >> 2 ; NEW_LINE n |= n >> 4 ; NEW_LINE n |= n >> 16 ; NEW_LINE return ( n & n ) ; NEW_LINE DEDENT n = 17 ; NEW_LINE print ( countUnsetBits ( n ) ) ; NEW_LINE
def minOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE result = 0 NEW_LINE freq = [ 0 for i in range ( 1000001 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x ] += 1 NEW_LINE DEDENT maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT for j in range ( i * 2 , maxi + i , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE result += 1 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( 2 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = ( M - 2 ) NEW_LINE dp [ 1 ] [ 0 ] = ( M - 2 ) * ( M - 2 ) NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) * ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( M - 1 ) * ( M - 1 ) NEW_LINE dp [ i ] [ 1 ] = ( M - 1 ) * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , M , X = 4 , 3 , 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE DEDENT
def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE c = 4 NEW_LINE print ( getMinNum ( a , b , c ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' I ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif s [ i ] == ' I ' : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , p = map ( int , input ( ) . split ( ) ) NEW_LINE s += d * p NEW_LINE s -= p NEW_LINE if m <= 0 : NEW_LINE INDENT s -= p NEW_LINE m -= p NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
import heapq NEW_LINE from collections import deque NEW_LINE from enum import Enum NEW_LINE import sys NEW_LINE import math NEW_LINE from _heapq import heappush , heappop NEW_LINE import copy NEW_LINE BIG_NUM = 2000000000 NEW_LINE HUGE_NUM = 99999999999999999 NEW_LINE MOD = 1000000007 NEW_LINE EPS = 0.000000001 NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE SIZE = 105 NEW_LINE table = [ 0 ] * SIZE NEW_LINE table [ 0 ] = 0 NEW_LINE table [ 0 ] = 0 NEW_LINE table [ 1 ] = 0 NEW_LINE for i in range ( 1 , SIZE ) : NEW_LINE INDENT table [ i ] += table [ i - 1 ] NEW_LINE table [ i ] += table [ i - 1 ] NEW_LINE table [ i ] += table [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , SIZE ) : NEW_LINE INDENT table [ i ] += table [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , SIZE ) : NEW_LINE INDENT table [ i ] += table [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , SIZE ) : NEW_LINE INDENT table [ i ] += table [ i - 1 ] NEW_LINE DEDENT for i in range ( SIZE ) : NEW_LINE INDENT table [ i ] -= table [ i - 1 ] NEW_LINE DEDENT print ( max ( table ) ) NEW_LINE
def countWays ( arr , n ) : NEW_LINE INDENT count = [ 0 for i in range ( n + 1 ) ] NEW_LINE count [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( i >= arr [ j ] ) : NEW_LINE INDENT count [ i ] += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT DEDENT return count [ N ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 7 NEW_LINE print ( " Total ▁ number ▁ of ▁ ways ▁ = " , countWays ( N ) ) NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return numberOfWays ( x - 1 ) * numberOfWays ( x - 2 ) NEW_LINE DEDENT DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def countFreq ( a , n ) : NEW_LINE INDENT hm = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] += 1 NEW_LINE if ( hm [ a [ i ] ] != 0 ) : NEW_LINE INDENT print ( a [ i ] , " - > > > > " , " - > > > " ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT a = [ 1 , 3 , 2 , 4 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE
def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False NEW_LINE possibleA = 0 NEW_LINE possibleB = 0 NEW_LINE possibleB = 0 NEW_LINE possibleB = 0 NEW_LINE possibleB = 0 NEW_LINE if ( numbers inNumbers ) : NEW_LINE INDENT flag = False NEW_LINE possibleB = L - L + 1 NEW_LINE possibleB = L - L + 1 NEW_LINE possibleB = L + 1 NEW_LINE possibleB = L + 1 NEW_LINE possibleB = L + 1 NEW_LINE possibleB = L + 1 NEW_LINE possibleB = L + 1 NEW_LINE possibleB = L + 1 NEW_LINE possibleB = L + 1 NEW_LINE possibleB = L + 1 NEW_LINE possibleB = L + 1 NEW_LINE possibleB = L + 1 NEW_LINE if ( possibleB > 1 ) : NEW_LINE INDENT flagA = possibleB NEW_LINE possibleB = L NEW_LINE possibleB = L + 1 NEW_LINE possibleB = L + 1 NEW_LINE possibleB = L + 1 NEW_LINE possibleB = L + 1 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT print ( " ( " , possibleB , " , ▁ possible ▁ possible ▁ possible ▁ possible ▁ possible ▁ possible ▁ between ▁ possible ▁ possible ▁ between ▁ between ▁ between ▁ between ▁ between " , L , " , " , " , " , " , possibleB ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ possible ▁ possible ▁ possible ▁ possible ▁ possible ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between ▁ between �
def convert ( ch ) : NEW_LINE INDENT s = " abcdefghijklmnopqrstuvwxyz " NEW_LINE return s NEW_LINE DEDENT ch = " qwertyuiopqrstuvwxyz " NEW_LINE str1 = " qwertyuiopqrstuvwxyz " NEW_LINE str2 = " ewertyuiopqrstuvwxyz " NEW_LINE print ( convert ( str1 , str2 ) ) NEW_LINE
def generateNumber ( count , a , n , k ) : NEW_LINE INDENT if ( count == k ) : NEW_LINE INDENT set . add ( num ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , a [ i ] , k ) NEW_LINE DEDENT DEDENT def printDistinct ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , k ) NEW_LINE print ( " The ▁ " , end = " ▁ " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , a [ i ] , a [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 8 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE printDistinct ( k , a , n , k ) NEW_LINE DEDENT
def product ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT prod *= ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT def findNumber ( l , r ) : NEW_LINE INDENT b = str ( r ) NEW_LINE ans = r NEW_LINE for i in range ( 0 , len ( r ) ) : NEW_LINE INDENT if ( b [ i ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT curr [ i ] = ord ( '0' ) + ( ord ( '0' ) - ord ( '0' ) ) NEW_LINE for j in range ( i + 1 , len ( r ) ) : NEW_LINE INDENT curr [ j ] = ord ( '0' ) NEW_LINE DEDENT for j in range ( i + 1 , len ( curr [ j ] ) ) : NEW_LINE INDENT curr [ j ] = ord ( '0' ) NEW_LINE DEDENT if ( num >= l and product ( curr [ j ] ) < product ( ord ( '0' ) ) ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 1 NEW_LINE r = 10 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE l = 62 NEW_LINE r = 62 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE DEDENT
MAX = 100005 ; NEW_LINE isPrime [ 1 ] = True ; NEW_LINE def sieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime [ 1 ] = True ; NEW_LINE for i in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( not isPrime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = True ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 ; NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( isPrime [ num ] ) : NEW_LINE INDENT return num ; NEW_LINE DEDENT num = num + 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT DEDENT return num ; NEW_LINE DEDENT def minNumber ( n ) : NEW_LINE INDENT sieveOfEratosthenes ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT if ( isPrime ( sum ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT num = findPrime ( sum ) ; NEW_LINE return num ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( minNumber ( arr , n ) ) ; NEW_LINE DEDENT
MAX = 25 NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * MAX NEW_LINE sum_bit = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rem = arr [ i ] NEW_LINE f = 0 NEW_LINE f = 0 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 NEW_LINE if rem == 1 : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE if rem == 1 : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f = f NEW_LINE DEDENT DEDENT max_bit = max ( max_bit , f ) NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = pow ( 2 , d ) NEW_LINE if ( bits_count [ d ] > n // 2 ) : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ? ' or s [ i ] == ' ? ' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == 0 ) : NEW_LINE INDENT print ( ' Impossible ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( int ( i ) ) NEW_LINE b . append ( a [ - 1 ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE ans = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] != i + 1 : NEW_LINE INDENT ans [ b [ i ] ] = i + 1 NEW_LINE b [ i ] = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ b [ i ] ] = i + 1 NEW_LINE b [ i ] = i + 1 NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT ans += b [ j ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def findMaximumNum ( arr , n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE
import sys NEW_LINE f = sys . stdin NEW_LINE for _ in range ( int ( f . readline ( ) ) ) : NEW_LINE INDENT s = f . readline ( ) . split ( ) NEW_LINE if s [ 0 ] == ' p ' : NEW_LINE INDENT s [ 1 ] , s [ 2 ] = s [ 3 ] , s [ 4 ] NEW_LINE DEDENT else : NEW_LINE INDENT s [ 2 ] , s [ 4 ] = s [ 5 ] , s [ 5 ] NEW_LINE DEDENT DEDENT for _ in range ( int ( f . readline ( ) ) ) : NEW_LINE INDENT s = f . readline ( ) . strip ( ) NEW_LINE print ( s [ s [ 0 ] ] + s [ 1 ] ) NEW_LINE DEDENT
import math as mt NEW_LINE def solve ( A , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 10000 ) ] for i in range ( n ) ] NEW_LINE sum = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if ( j - A [ i - 1 ] <= sum and j - A [ i - 1 ] >= sum and j - A [ i - 1 ] >= sum ) : NEW_LINE INDENT dp [ i ] [ j ] = sum NEW_LINE if ( j - A [ i - 1 ] >= sum and j - A [ i - 1 ] >= sum ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j - A [ i - 1 ] ] , dp [ i - 1 ] [ j - A [ i - 1 ] ] + 1 ) NEW_LINE DEDENT if ( j + A [ i - 1 ] >= sum and j + A [ i - 1 ] != float ( ' inf ' ) ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT flag = flag ^ mt NEW_LINE DEDENT flag = flag ^ mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt . mt .
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT x1 , y1 , x2 , y2 , x3 , y4 = map ( float , line . split ( ) ) NEW_LINE a = ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 NEW_LINE b = ( x2 - x3 ) ** 2 + ( y3 - y4 ) ** 2 NEW_LINE c = ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 NEW_LINE if c >= 0.0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT s = " " NEW_LINE for i in input ( ) . split ( ) : NEW_LINE INDENT s += " Buzz " NEW_LINE DEDENT DEDENT print ( s [ : m ] ) NEW_LINE DEDENT
def initialize ( l ) : NEW_LINE INDENT l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE DEDENT
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( sum ( a - c ) // 2 for a in range ( a - b + 1 ) ) NEW_LINE
def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if b [ i ] != 0 : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT x = floor ( a [ i ] / mul ) NEW_LINE print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b [ n - 1 - 1 ] : NEW_LINE INDENT b [ i ] , b [ n - 1 - 1 ] = b [ n - 1 - i - 1 ] , b [ n - 1 - i - 1 ] NEW_LINE DEDENT DEDENT print ( a [ n - 2 ] ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' > ' or s [ i ] == ' > ' or s [ i ] == ' > ' or s [ i ] == ' < ' : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE while ( c < n ) : NEW_LINE INDENT if ( c == '1' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
import math NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def solves ( ) : NEW_LINE INDENT v , t , f = _input ( ) NEW_LINE l = v / _input ( ) NEW_LINE c = v / _input ( ) NEW_LINE print ( c + 1 ) NEW_LINE DEDENT t = 1 NEW_LINE t = t * v NEW_LINE solves ( ) NEW_LINE
a , b = map ( int , input ( ) . split ( ' : ' ) ) NEW_LINE c = str ( a ) NEW_LINE d = str ( b ) NEW_LINE h = str ( c ) NEW_LINE m = str ( h ) NEW_LINE h = str ( h ) NEW_LINE m = str ( m ) NEW_LINE h = str ( h ) NEW_LINE m = str ( m ) NEW_LINE h = str ( h ) NEW_LINE m = str ( m ) NEW_LINE print ( m + m ) NEW_LINE
def longestAlternatingSubarray ( a , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] * a [ i - 1 ] < 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE longest = max ( longest , cnt ) NEW_LINE longest = max ( longest , cnt ) NEW_LINE DEDENT DEDENT return longest NEW_LINE DEDENT a = [ - 5 , - 1 , - 1 , - 2 , - 3 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestAlternatingSubarray ( a , n ) ) NEW_LINE
import math NEW_LINE def checkTriOfTriangle ( a , b , c ) : NEW_LINE INDENT sqa = math . pow ( b , 2 ) NEW_LINE sqb = pow ( c , 2 ) NEW_LINE sqc = pow ( c , 2 ) NEW_LINE if sqa == sqb or sqb == sqb : NEW_LINE INDENT print ( " Right - - dodos ▁ Triangle ▁ Triangle " ) NEW_LINE DEDENT elif sqb > sqb : NEW_LINE INDENT print ( " Right - dodos ▁ Triangle ▁ Triangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd ▁ Triangle ▁ Triangle " ) NEW_LINE DEDENT DEDENT a = 2 NEW_LINE b = 2 NEW_LINE c = 2 NEW_LINE checkTriangle ( a , b , c ) NEW_LINE
max = 100 NEW_LINE def countSubsequence ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' G ' ) : NEW_LINE INDENT cnt += C NEW_LINE DEDENT elif ( s [ i ] == ' G ' ) : NEW_LINE INDENT cnt += C NEW_LINE C += cnt NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT s = " GFGFGG " NEW_LINE n = len ( s ) NEW_LINE countSubsequence ( s , n ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x , y , h = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] > 0 : NEW_LINE INDENT x . append ( abs ( x [ j ] - x [ j ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT x . append ( abs ( x [ j ] - x [ j ] ) ) NEW_LINE DEDENT DEDENT if len ( x ) == 1 : NEW_LINE INDENT print ( * x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT largest = c . ct ( n ) NEW_LINE n -= ( largest * largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT n = 150 NEW_LINE print ( countSteps ( n ) ) NEW_LINE
import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import fractions NEW_LINE import heapq NEW_LINE import collections NEW_LINE import copy NEW_LINE import heapq NEW_LINE import itertools NEW_LINE import copy NEW_LINE import decimal NEW_LINE import queue NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 16 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE YesNo = lambda b : bool ( [ print ( ' YES ' ) ] if b else print ( ' NO ' ) ) NEW_LINE YESNO = lambda b : bool ( [ print ( ' YES ' ) ] if b else print ( ' NO ' ) ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE def main ( ) : NEW_LINE INDENT t = input ( ) . split ( ) NEW_LINE t . sort ( ) NEW_LINE for _ in range ( 3 ) : NEW_LINE INDENT t . sort ( ) NEW_LINE print ( t [ 0 ] , t [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x , y = w . count ( max ( w ) ) , w . count ( max ( w ) ) NEW_LINE print ( x , y * w ) NEW_LINE
def find_count ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bin ( i ) . count ( '1' ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = a [ i ] + a [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] - a [ i - 1 ] > 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " YES " if a [ - 1 ] % n == 0 else " NO " ) NEW_LINE
def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 - 1 ) * ( N % 10 - 1 ) , maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT N = 388 ; NEW_LINE print ( maxProd ( N ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( input ( ) ) NEW_LINE DEDENT l . append ( len ( l ) ) NEW_LINE ans = 0 NEW_LINE for i in l : NEW_LINE INDENT ans = max ( ans , len ( i ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
import math NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x , y = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE x . append ( ( x ** 2 + y ** 2 ) ** 0.5 ) NEW_LINE y . append ( ( x ** 2 + y ** 2 ) ** 0.5 ) NEW_LINE DEDENT print ( sum ( x ** 2 for x in x ) ) NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count //= i NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE
def reduceString ( s , l ) : NEW_LINE INDENT count = 1 NEW_LINE steps = 0 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT steps += ( count // 2 ) NEW_LINE count = 1 NEW_LINE DEDENT steps += count // 2 NEW_LINE DEDENT steps += count // 2 NEW_LINE return steps NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE l = len ( s ) NEW_LINE print ( reduceString ( s , l ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a + b ) // 2 == ( b + 1 ) // 2 : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( a + b ) // 2 == ( b + 1 ) // 2 : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT DEDENT
x , y , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( len ( [ i for i in range ( a + 1 , y + 1 ) if i <= b ] ) ) NEW_LINE for i in range ( a + 1 , b + 1 ) : NEW_LINE INDENT print ( i , i ) NEW_LINE DEDENT
mod = 1000000007 ; NEW_LINE def mul ( a , b ) : NEW_LINE INDENT return ( ( ( a % mod ) * ( b % mod ) ) * ( b % mod ) ) % mod ; NEW_LINE DEDENT def calculate_factors ( n ) : NEW_LINE INDENT ans = 1 ; NEW_LINE cnt = 1 ; NEW_LINE ans = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE n = n // 2 ; NEW_LINE DEDENT if ( cnt % 2 == 1 ) : NEW_LINE INDENT ans = mul ( n ) ; NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE n = n // i ; NEW_LINE DEDENT if ( cnt % 2 == 1 ) : NEW_LINE INDENT ans = mul ( ans , ( cnt + 1 ) ) ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = mul ( 2 ) ; NEW_LINE DEDENT return ans % mod ; NEW_LINE DEDENT n = 16244353 ; NEW_LINE mod = 176424 ; NEW_LINE print ( calculate_factors ( n ) ) ; NEW_LINE
s = input ( ) NEW_LINE print ( s . replace ( " + " , " - " ) ) NEW_LINE
def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT arr = [ 2 , 1 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxAbsDiff ( arr , n ) ) NEW_LINE
while 1 : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b == c == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = [ 0 ] * ( a + b + c ) NEW_LINE s [ a + b + c ] = [ b + c ] = c NEW_LINE s [ a + b + c ] = [ b + c ] = c NEW_LINE DEDENT for i in range ( 1 , int ( input ( ) ) ) : NEW_LINE INDENT s [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , int ( input ( ) ) ) : NEW_LINE INDENT s [ i ] = s [ i - 1 ] + s [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , int ( input ( ) ) ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT
def minRemove ( a , b , n , m ) : NEW_LINE INDENT countA = dict ( ) NEW_LINE countB = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( countA [ i ] in countA . keys ( ) ) : NEW_LINE INDENT countB [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countB [ b [ i ] ] = 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE s = set ( ) NEW_LINE for x in s : NEW_LINE INDENT if ( countB [ x ] in countB . keys ( ) ) : NEW_LINE INDENT res += min ( countB [ x ] , countA [ x ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 8 ] NEW_LINE b = [ 2 , 3 , 4 , 8 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( minRemove ( a , b , n , m ) ) NEW_LINE
M = 20 NEW_LINE dp = [ [ [ 0 for i in range ( M ) ] for j in range ( M ) ] for i in range ( M ) ] NEW_LINE def count ( pos , first , last , tight , tight , tight , tight , tight , tight , tight , tight , tight , tight , tight , tight , tight ) : NEW_LINE INDENT if ( pos == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] NEW_LINE DEDENT if ( pos == 0 ) : NEW_LINE INDENT return dp [ pos ] [ tight ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = 9 NEW_LINE for dig in range ( 0 , limit + 1 ) : NEW_LINE INDENT currFirst = 1 if ( curr == 0 and dig == 0 ) else 1 NEW_LINE if ( currFirst == 0 and dig == 0 ) : NEW_LINE INDENT currFirst = dig NEW_LINE DEDENT currFirst = currFirst NEW_LINE DEDENT ans += count ( pos + 1 , currFight , tight , tight , tight ) NEW_LINE DEDENT dp [ pos ] [ tight ] [ tight ] = ans NEW_LINE return count ( 0 , 0 , tight , tight , tight , tight ) NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT num = [ [ ] for i in range ( M ) ] NEW_LINE while ( x ) : NEW_LINE INDENT num . append ( x [ 0 ] ) NEW_LINE x [ 0 ] = 1 NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT num . append ( x [ i ] ) NEW_LINE DEDENT return count ( 0 , 0 , - 1 , - 1 , 1 , - 1 , 1 , - 1 , - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 2 NEW_LINE R = 60 NEW_LINE print ( solve ( R ) - solve ( L - 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , [ L ] ) ) NEW_
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] == 1 : NEW_LINE INDENT ans *= ( i - l [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans *= ( i - l [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import math NEW_LINE def bit ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x // 2 ) : NEW_LINE INDENT x //= 2 NEW_LINE ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def b ( d , x ) : NEW_LINE INDENT if ( bit ( x // 2 ) <= bit ( x // 2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def b ( n ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( math . sqrt ( n ) ) NEW_LINE while ( l < r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( check ( m , n ) ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT if ( not b ) : NEW_LINE INDENT return l NEW_LINE DEDENT else : NEW_LINE INDENT return l NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( b ( n ) ) NEW_LINE
def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ 0 ] * ( n ) NEW_LINE s1 = " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s2 = " " NEW_LINE s2 = " " NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 += s [ i ] NEW_LINE DEDENT s1 = " " NEW_LINE s2 = " " NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 += s [ i ] NEW_LINE DEDENT return dp [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaaa " NEW_LINE n = len ( s ) NEW_LINE print ( minimalSteps ( s , n ) // 2 ) NEW_LINE DEDENT
def checkUtil ( n , dig , base , base ) : NEW_LINE INDENT if ( dig == 1 and n < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and n >= base ) : NEW_LINE INDENT return checkUtil ( n / base , base , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 32 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT return ; NEW_LINE DEDENT def findMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] ; NEW_LINE while ( i < j ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT return maxVal ; NEW_LINE DEDENT def findMax ( arr , i , j ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return arr [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT pArr [ i ] = gmax ( arr , i + 1 ) ; NEW_LINE pArr [ i ] = gmax ( arr , i + 1 ) ; NEW_LINE return ; NEW_LINE DEDENT def findMax ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return arr [ 0 ] ; NEW_LINE DEDENT pArr [ 0 ] = gmax ( arr , 1 ) ; NEW_LINE pArr [ 0 ] = gmax ( arr , n - 1 ) ; NEW_LINE pArr [ n - 1 ] = gmax ( arr , 0 , n - 1 ) ; NEW_LINE return arr ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findMax ( arr , n ) ; NEW_LINE printArray ( arr , n ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT ans = max ( ans , s [ i ] - s [ i ] ) NEW_LINE DEDENT elif s [ i ] == ' B ' : NEW_LINE INDENT ans = max ( ans , s [ i ] - s [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE p = ( a - c ) / ( b - a ) NEW_LINE q = ( b - c ) / ( b - a ) NEW_LINE if q == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def nthXorFib ( n , a , b ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( a ^ b ) NEW_LINE DEDENT return nthXorFib ( n % 3 , a , b ) NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE n = 10 NEW_LINE print ( nthXorFib ( n , a , b ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) . split ( ) ) NEW_LINE b . append ( a [ 0 ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] == a [ i ] [ 1 ] : NEW_LINE INDENT b += 1 NEW_LINE DEDENT elif a [ i ] [ 0 ] == a [ i ] [ 1 ] : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT print ( b , 1 ) NEW_LINE
import math as mt NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.70477 * a NEW_LINE A = 0.70477 * pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT def SNCototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototot
n = int ( input ( ) ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT print ( 2 ** n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ** n ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = pow ( 10 , d ) - 1 NEW_LINE primeieve ( prime , maxVal + 1 ) NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT d = 3 NEW_LINE print ( sumPrime ( d ) ) NEW_LINE
import math NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = int ( math . sqrt ( 2 ) ) - 1 NEW_LINE prime = [ True ] * ( maxVal + 1 ) NEW_LINE sieve ( prime , maxVal + 1 ) NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT d = 8 NEW_LINE print ( sumPrime ( d ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( reverse = True ) NEW_LINE i = 0 NEW_LINE count = 0 NEW_LINE while i < n : NEW_LINE INDENT if k / ( k / ( k - l [ i ] ) ) >= k : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT d1 , d2 = map ( int , input ( ) . split ( ) ) NEW_LINE d2 = d1 [ 0 ] NEW_LINE d2 = d2 [ 1 ] NEW_LINE d3 = d3 [ 2 ] NEW_LINE d3 = d3 [ 3 ] NEW_LINE d3 = d3 [ 4 ] NEW_LINE d3 = d3 [ 4 ] NEW_LINE d3 = d3 [ 4 ] NEW_LINE d3 = d3 [ 4 ] NEW_LINE d3 = d3 [ 4 ] NEW_LINE d3 = d3 [ 4 ] NEW_LINE d3 = d3 [ 4 ] NEW_LINE d3 = d3 [ 4 ] NEW_LINE d3 = d3 [ 5 ] NEW_LINE d3 = d3 [ 6 ] NEW_LINE d3 = d3 [ 6 ] NEW_LINE d3 = d3 [ 6 ] NEW_LINE d3 = d3 [ 6 ] NEW_LINE d3 = d3 [ 6 ] NEW_LINE d3 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d4 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d3 [ 6 ] NEW_LINE d4 = d4 [ 6 ] NEW_LINE d4 = d4 [ 6 ] NEW_LINE d4 = d4 [ 6 ] NEW
def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE
def countMaxContiguous ( arr , n ) : NEW_LINE INDENT current_max = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT current_max = 0 NEW_LINE max_so_far = max ( current_max , max_so_far ) NEW_LINE max_so_far = max ( current_max , max_so_far ) NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 4 , 3 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countMaxContiguous ( arr , n ) ) NEW_LINE
import math NEW_LINE def cube ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( h * r * r ) / ( math . sqrt ( 2 ) * r ) NEW_LINE return a NEW_LINE DEDENT h = 5 NEW_LINE r = 6 NEW_LINE print ( cube ( h , r ) ) NEW_LINE
def pattern ( rows_no ) : NEW_LINE INDENT for i in range ( 1 , rows_no + 1 ) : NEW_LINE INDENT for k in range ( 1 , rows_no + 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " ▁ " ) NEW_LINE for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT print ( " ▁ " ) NEW_LINE DEDENT DEDENT rows_no = 7 NEW_LINE pattern ( rows_no - 1 ) NEW_LINE pattern ( rows_no - 1 ) NEW_LINE
n = input ( ) NEW_LINE if n [ 0 ] == '1' : NEW_LINE INDENT print ( int ( n [ 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if n [ i ] != '1' : NEW_LINE INDENT print ( int ( n [ i ] ) + int ( n [ i - 1 ] ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def check_digits ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( check_digits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE DEDENT
def check_digits ( n ) : NEW_LINE INDENT while ( n != 0 ) : NEW_LINE INDENT if ( n % 10 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( check_digits ( i ) != 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE DEDENT
def triangular_series ( n ) : NEW_LINE INDENT i = 1 NEW_LINE j = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( k , end = " ▁ " ) NEW_LINE j = j + 1 NEW_LINE k = k + j NEW_LINE DEDENT DEDENT n = 5 NEW_LINE triangular_series ( n ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ a [ i ] - 1 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += d [ i ] * d [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 ; f2 = 1 ; NEW_LINE f3 = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i != 0 ) : NEW_LINE INDENT f3 = f1 + f2 ; NEW_LINE f3 = f3 ; NEW_LINE f3 = f3 ; NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n * i ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE k = 4 ; NEW_LINE print ( " Position ▁ of ▁ n ▁ of ▁ n ▁ of ▁ k ▁ in ▁ Fibonacci ▁ is " , findPosition ( k ) ) ; NEW_LINE DEDENT
s = input ( ) NEW_LINE a = [ 0 ] * 26 NEW_LINE b = [ 0 ] * 26 NEW_LINE for i in s : NEW_LINE INDENT if i not in a : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT DEDENT if len ( a ) % 2 == 0 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( a ) % 2 == 0 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT DEDENT
def countMinimumMoves ( arr , n , k ) : NEW_LINE INDENT for i in range ( k - 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE K = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( countMinimumMoves ( arr , n , K ) ) NEW_LINE
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def powerGCD ( a , b , n ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , n ) NEW_LINE DEDENT DEDENT def powerGCD ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , n ) NEW_LINE DEDENT a = 5 NEW_LINE b = 4 NEW_LINE n = 2 NEW_LINE print ( powerGCD ( a , b , n , n ) ) NEW_LINE
T , S , Q = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( T * T ) // Q ) NEW_LINE
n = int ( input ( ) ) NEW_LINE print ( ( n - 2 ) ** 3 ) NEW_LINE
def countIdenticalRows ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , len ( mat ) ) : NEW_LINE INDENT hs = set ( mat [ i ] [ 0 ] ) NEW_LINE for j in range ( 0 , len ( mat [ i ] ) ) : NEW_LINE INDENT hs . add ( mat [ i ] [ j ] ) NEW_LINE DEDENT if len ( hs ) == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT mat = [ [ 1 , 1 , 2 ] , [ 1 , 2 , 3 ] , [ 5 , 5 , 5 ] ] NEW_LINE print ( countIdenticalRows ( mat ) ) NEW_LINE
def createSorted ( a , n ) : NEW_LINE INDENT b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not len ( b ) : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( b [ - 1 ] ) NEW_LINE DEDENT DEDENT def createSorted ( a , n ) : NEW_LINE INDENT b . append ( n ) NEW_LINE pos = 0 NEW_LINE pos = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( n - start ) // 2 NEW_LINE if b [ mid ] == a [ pos ] : NEW_LINE INDENT pos = end - 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT pos = start NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE if start > end : NEW_LINE INDENT pos = start NEW_LINE b [ i ] = end - 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 5 , 4 , 8 ] NEW_LINE n = len ( a ) NEW_LINE createSorted ( a , n ) NEW_LINE DEDENT
def countTotalDistinct ( str ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE for j in range ( i , len ( str ) ) : NEW_LINE INDENT temp = temp + str [ j ] NEW_LINE if ( temp in temp ) : NEW_LINE INDENT temp = temp + str [ j ] NEW_LINE cnt += len ( temp ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " ABCA " NEW_LINE print ( countTotalDistinct ( str ) ) NEW_LINE DEDENT
import math NEW_LINE def firstDigit ( n ) : NEW_LINE INDENT digits = math . log ( n ) NEW_LINE n = int ( math . log ( n ) ) NEW_LINE return n NEW_LINE DEDENT def firstDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT n = 98562 NEW_LINE print ( firstDigit ( n ) , lastDigit ( n ) ) NEW_LINE
def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( " Array ▁ leading ▁ zeros ▁ not " ) NEW_LINE return NEW_LINE DEDENT b = [ a [ i + i ] for i in range ( n - i ) ] NEW_LINE for i in range ( n - i ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT for i in range ( n - i ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ 0 , 0 , 1 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE removeZeros ( a , n ) NEW_LINE
def find_maxm ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for x in mp : NEW_LINE INDENT value = mp . get ( x , 0 ) + 1 NEW_LINE if value == freq : NEW_LINE INDENT ans = max ( ans , value ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_maxm ( arr , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = sorted ( a ) NEW_LINE c = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] += 1 NEW_LINE DEDENT b = sorted ( b ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] > c [ i ] : NEW_LINE INDENT b [ i ] = c [ i ] NEW_LINE DEDENT DEDENT print ( b [ n ] ) NEW_LINE
def sumOfDigits ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT ans += x % 10 NEW_LINE x //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sum ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( ans * 10 + 9 ) : NEW_LINE INDENT ans = ans * 10 + 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 35 NEW_LINE print ( sumDigits ( N ) ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT elif a > b
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a - c ) + ( b - c ) > 0 : NEW_LINE INDENT print ( ( c + d ) + ( b - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( c + d - 1 ) + ( b - c ) - 1 ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i - 1 ] - a [ i ] <= 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " YES " if a [ i - 1 ] - a [ i ] <= 1 else " NO " ) NEW_LINE DEDENT
def cal_in ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE denominator = n * ( 3.378.378.378.378.378.378.0 ) NEW_LINE xval = n * ( 3.142 / 180.0 ) NEW_LINE i = 1 NEW_LINE xval = n * i NEW_LINE i = 1 NEW_LINE xval = n * i NEW_LINE i = 1 NEW_LINE while ( denominator <= denominator ) : NEW_LINE INDENT denominator = 2 * i * i NEW_LINE xval = - xval NEW_LINE xval = - xval NEW_LINE DEDENT print ( int ( sinval ) ) NEW_LINE DEDENT n = 90 NEW_LINE cal_in ( n ) NEW_LINE cal_in ( n ) NEW_LINE
def multiply ( arr , 2 , 3 , 4 , 6 ) : NEW_LINE INDENT pro = 1 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT pro = pro * arr [ i ] NEW_LINE DEDENT return pro NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 6 ] NEW_LINE print ( multiply ( arr , 2 ) ) NEW_LINE
import bisect NEW_LINE def main ( ) : NEW_LINE INDENT q = int ( input ( ) ) NEW_LINE count = [ 0 for i in range ( q ) ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT query = input ( ) . split ( ) NEW_LINE if query [ 0 ] == '0' : NEW_LINE INDENT count [ query [ 1 ] ] = 1 NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT count [ query [ 1 ] ] = 1 NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT count [ query [ 1 ] ] = 0 NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT count [ query [ 1 ] ] = 0 NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT count [ query [ 1 ] ] = 0 NEW_LINE DEDENT elif query [ 0 ] == '3' : NEW_LINE INDENT count [ query [ 1 ] ] = 0 NEW_LINE DEDENT elif query [ 1 ] == '3' : NEW_LINE INDENT count [ query [ 1 ] ] = 0 NEW_LINE DEDENT elif query [ 2 ] == '6' : NEW_LINE INDENT count [ query [ 1 ] ] = 1 NEW_LINE DEDENT elif query [ 2 ] == '7' : NEW_LINE INDENT count [ query [ 2 ] ] = 0 NEW_LINE DEDENT elif query [ 1 ] == '6' : NEW_LINE INDENT count [ query [ 2 ] ] = 0 NEW_LINE DEDENT elif query [ 2 ] == '7' : NEW_LINE INDENT count [ query [ 1 ] ] = 0 NEW_LINE DEDENT elif query [ 1 ] == '6' : NEW_LINE INDENT count [ query [ 2 ] ] = 0 NEW_LINE DEDENT elif query [ 1 ] == '6' : NEW_LINE INDENT count [ query [ 1 ] ] = 0 NEW_LINE DEDENT elif query [ 2 ] == '6' : NEW_LINE INDENT count [ query [ 1 ] ] = 0 NEW_LINE DEDENT elif query [ 1 ] == '
def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT includ = arr [ 0 ] NEW_LINE exclist = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT exclist = ( exclist ) NEW_LINE exclist = exclist NEW_LINE exclist = exclist NEW_LINE DEDENT return exclist NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' C ' : NEW_LINE INDENT ans += ( ( s [ i ] == ' C ' ) ) * ( ( s [ i ] == ' C ' ) ) ) // 2 NEW_LINE DEDENT elif s [ i ] == ' C ' : NEW_LINE INDENT ans += ( ( ( s [ i ] == ' C ' ) ) * ( ( s [ i ] == ' C ' ) ) ) // 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def findMinIndex ( arr , low , high ) : NEW_LINE INDENT if ( high == low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( mid < high and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid < low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return findMinIndex ( arr , mid , mid - 1 , high - 1 ) NEW_LINE DEDENT return findMinIndex ( arr , mid , high - 1 , x ) + 1 NEW_LINE DEDENT def binaryLessLessThan ( arr , n , x ) : NEW_LINE INDENT min_index = findMinIndex ( arr , mid + 1 , n - 1 , x ) NEW_LINE if ( x <= arr [ mid ] ) : NEW_LINE INDENT return ( binaryMinIndex ( arr , mid , x ) + 1 - min_index + 1 ) NEW_LINE DEDENT return n NEW_LINE DEDENT def countEleLessThan ( arr , n , x ) : NEW_LINE INDENT min_index = findMinIndex ( arr , 0 , n - 1 , x ) + 1 NEW_LINE if ( x <= arr [ min_index - 1 ] ) : NEW_LINE INDENT return ( binary_index + 1 - min_index + 1 - min_index ) + 1 NEW_LINE DEDENT return n NEW_LINE DEDENT def countEleLessLessThan ( arr , n , x ) : NEW_LINE INDENT min_index = findMinIndex ( arr , 0 , n - 1 , x ) + 1 NEW_LINE if ( x <= arr [ min_index - 1 ] ) : NEW_LINE INDENT return ( n - min_index + binary_index ( arr , 0 , n - 1 , x ) + 1 - min_index + 1 - min_index ) NEW_LINE DEDENT return n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 10 , 15 , 2 , 5 , 5 ] NEW_LINE n = len
def f ( x , y ) : NEW_LINE INDENT v = y + f ( x , y ) NEW_LINE return v NEW_LINE DEDENT def perform ( x , y , h ) : NEW_LINE INDENT v = y + f ( x , y ) NEW_LINE return v NEW_LINE DEDENT def perform ( x , y , h ) : NEW_LINE INDENT e = 0.00001 NEW_LINE y = y + f ( x , y ) NEW_LINE return y NEW_LINE DEDENT def perform ( x , y , x , y ) : NEW_LINE INDENT for i in range ( x , y ) : NEW_LINE INDENT x1 = x + f ( x , y ) NEW_LINE y1 = y + f ( x , y ) NEW_LINE y = x + f ( x , y , h ) NEW_LINE x = x + f ( x , y , h ) NEW_LINE y = y + f ( x , y , x ) NEW_LINE x = x NEW_LINE y = y NEW_LINE DEDENT return y NEW_LINE DEDENT x = 0 NEW_LINE y = 1 NEW_LINE print Final ( x , y , " ▁ of ▁ x ▁ = " , " , findLast ( x , y , x , y ) ) NEW_LINE
def D_Pattern ( n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( j == 1 or i == n - 1 or j == n - 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT print ( " " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 9 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 9 NEW_LINE DEDENT
def kthString ( n , k ) : NEW_LINE INDENT total = 0 NEW_LINE i = 1 NEW_LINE while ( total < k ) : NEW_LINE INDENT total = total + n - i NEW_LINE i += 1 NEW_LINE DEDENT first_point = i - ( total - n + 1 ) NEW_LINE second_point = k - ( total - n + 1 ) NEW_LINE while ( second_point > 1 ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE second_point -= 1 NEW_LINE DEDENT print ( " x " , end = " " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE second_point -= 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE k = 7 NEW_LINE k = 7 NEW_LINE k = 7 NEW_LINE kthString ( n , k ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j - 1 ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT def count_subarrays ( N ) : NEW_LINE INDENT count = binomialCoeff ( 2 * N - 1 , N ) NEW_LINE return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE print ( count_subarrays ( N ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def productNonUnicates ( self , nums ) : NEW_LINE INDENT res = [ 0 ] * nums [ 0 ] NEW_LINE res [ 0 ] = 1 NEW_LINE for i in range ( 1 , nums [ 1 ] ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] * nums [ i - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 , 4 ] NEW_LINE out = sObj . productNonUnicates ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def getSmallestAndLargest ( s , k ) : NEW_LINE INDENT currStr = s [ 0 : k ] NEW_LINE lexMin = currStr NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT currStr = currStr [ 1 : i ] + s [ i : ] NEW_LINE if ( lexMax < currStr ) : NEW_LINE INDENT lexMax = currStr NEW_LINE DEDENT if ( lexMax < currStr ) : NEW_LINE INDENT lexMax = currStr NEW_LINE DEDENT DEDENT print ( lexMin ) NEW_LINE print ( lexMinAndLargest ( str , k ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksForGeeks " NEW_LINE k = 3 NEW_LINE getSmallestLargest ( str , k ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] < b [ i ] : NEW_LINE INDENT b [ i ] = b [ i ] NEW_LINE DEDENT DEDENT print ( * b ) NEW_LINE
INT_BITS = 32 NEW_LINE def maxSubarrayXOR ( set , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( INT_BITS - 1 ) : NEW_LINE INDENT maxIndENT maxIndENT maxIndENT maxIndENT maxIndENT maxIndENT maxIndENT if ( set [ i ] & ( 1 << i ) ) ) : NEW_LINE INDENT maxIndENT maxIndENT maxIndENT maxIndENT maxIndENT maxIndENT maxIndENT maxIndENT maxIndENT maxIndENT maxIndENT maxIndENT DEDENT DEDENT if ( maxIndENT return False ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = set [ index ] NEW_LINE set [ index ] = set [ maxIndENT temp [ maxIndENT if ( set [ index ] & ( 1 << i ) ) ] NEW_LINE set [ maxIndENT temp [ maxIndENT set [ index ] ] = set [ maxInd ] ^ set [ maxInd ] ) NEW_LINE set [ maxInd ] = temp [ maxInd ] ^ set [ maxInd ] NEW_LINE set [ maxInd ] = temp [ maxInd ] NEW_LINE set [ maxInd ] = temp [ maxInd ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res ^= set [ i ] NEW_LINE DEDENT res = res ^ set [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT set = [ 9 , 8 , 5 ] NEW_LINE n = len ( set ) NEW_LINE print ( " Max ▁ subset ▁ XOR ▁ is " ) NEW_LINE print ( " Max ▁ XOR ▁ is " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = l . count ( 0 ) NEW_LINE k = l . count ( 1 ) NEW_LINE m = l . count ( 1 ) NEW_LINE print ( m , m ) NEW_LINE
def minAbsSumPair ( arr , n ) : NEW_LINE INDENT sum_sum = 0 NEW_LINE min_sum = 0 NEW_LINE min_sum = n - 1 NEW_LINE min_sum = n - 1 NEW_LINE min_r = n - 1 NEW_LINE min_sum = n - 1 NEW_LINE if ( sum_sum < 0 ) : NEW_LINE INDENT min_sum = arr [ 0 ] NEW_LINE min_sum = arr [ 1 ] NEW_LINE min_sum = arr [ 1 ] NEW_LINE min_sum = n - 1 NEW_LINE DEDENT if ( sum_sum < 0 ) : NEW_LINE INDENT min_sum = arr [ 0 ] NEW_LINE min_sum = arr [ 1 ] NEW_LINE min_sum = arr [ 1 ] NEW_LINE min_sum = min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE if ( min_sum < 0 ) : NEW_LINE INDENT min_sum = arr [ 0 ] NEW_LINE min_sum = arr [ 1 ] NEW_LINE min_sum = arr [ 1 ] NEW_LINE min_sum = arr [ 0 ] NEW_LINE min_sum = arr [ 1 ] NEW_LINE DEDENT if ( min_sum < 0 ) : NEW_LINE INDENT min_sum = arr [ 0 ] NEW_LINE min_sum = arr [ 1 ] NEW_LINE min_sum = arr [ 0 ] NEW_LINE min_sum = arr [ 1 ] NEW_LINE min_sum = arr [ 1 ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ fractions ▁ is " , arr [ min_sum ] , arr [ min_sum ] , arr [ min_sum ] ) NEW_LINE DEDENT arr = [ 1 , 6 , - 9 , - 9 , 85 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE arr = [ 1 , 6 , 85 , 85 , 85 , 85 ] NEW_LINE minAbsSumPairSumPair ( arr , n ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def firstUniqChar ( self , s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE out = sObj . firstUniqChar ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT
def checkStackPermutation ( ip , op ) : NEW_LINE INDENT input = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT input . append ( ip [ i ] ) NEW_LINE DEDENT output = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT output . append ( op [ i ] ) NEW_LINE if ( ele == output [ - 1 ] ) : NEW_LINE INDENT output . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT output . append ( op [ 0 ] ) NEW_LINE DEDENT DEDENT return ( output ) NEW_LINE DEDENT def checkStackPermutation ( op , op , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ele = op [ i ] NEW_LINE if ( ele == output [ - 1 ] ) : NEW_LINE INDENT temp . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT temp . pop ( ) NEW_LINE DEDENT DEDENT return ( temp [ 0 ] == output [ - 1 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = [ 1 , 2 , 3 ] NEW_LINE output = [ 2 , 1 , 3 ] NEW_LINE n = len ( output ) NEW_LINE if ( checkStackmutation ( input , output , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
S = input ( ) NEW_LINE T = input ( ) NEW_LINE N = len ( S ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if S [ i ] != S [ i + 1 ] : NEW_LINE INDENT N [ i ] = N [ i + 1 ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if S [ i ] != T [ i ] : NEW_LINE INDENT N [ i ] = N [ i ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if S [ i ] != T [ i ] : NEW_LINE INDENT N [ i ] = N [ i ] NEW_LINE DEDENT DEDENT if N [ 0 ] != T [ 1 ] : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 10 == d ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 30 NEW_LINE d = 3 NEW_LINE print ( getSum ( n , d ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT st , n , m , n = map ( int , input ( ) . split ( ) ) NEW_LINE st = st - 1 NEW_LINE if st > st and st > st : NEW_LINE INDENT st = st - st NEW_LINE DEDENT elif st > st : NEW_LINE INDENT st = st - st NEW_LINE DEDENT else : NEW_LINE INDENT st = st NEW_LINE DEDENT DEDENT if st > st : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( st , n , st ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( a - c , b - a + 1 ) ) NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 10 NEW_LINE K = 2 NEW_LINE print ( findSum ( N , K ) ) NEW_LINE
import math NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if math . gcd ( n , 2 * n ) == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 + math . gcd ( n , 2 * n ) ) NEW_LINE DEDENT DEDENT
PI = 3.14159 ; NEW_LINE def find_area ( r , d ) : NEW_LINE INDENT R = d / PI ; NEW_LINE R = int ( math . pow ( R , 2 ) ) ; NEW_LINE area = PI * pow ( R , 2 ) ; NEW_LINE return area ; NEW_LINE DEDENT r = 4 ; NEW_LINE print ( find_area ( r , d ) ) ; NEW_LINE
def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( s % n ) : NEW_LINE INDENT return s / n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return s / n NEW_LINE DEDENT DEDENT n = 5 NEW_LINE s = 11 NEW_LINE print ( minimumNumbers ( n , s ) ) NEW_LINE
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while ( start < mid ) : NEW_LINE INDENT prod = arr [ start ] * arr [ start ] * arr [ mid ] NEW_LINE if ( prod > m ) : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE m = 1 NEW_LINE print ( countTriplets ( arr , n , m ) ) NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isVow ( ch ) : NEW_LINE INDENT for i in range ( 1 , len ( ch ) ) : NEW_LINE INDENT if ( not isVow ( ch ) and isVow ( ch [ i - 1 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( ch ) - 1 ) : NEW_LINE INDENT if ( isVow ( ch [ i ] ) and isVow ( ch [ i - 1 ] ) and isVowel ( ch [ i - 1 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " acaba " NEW_LINE n = len ( string ) NEW_LINE if ( isVowels ( string , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT n = 6 NEW_LINE print ( countWays ( n ) ) NEW_LINE
import math NEW_LINE def evaluate ( m , n ) : NEW_LINE INDENT ans = 0.0 NEW_LINE for i in range ( m , 0 , - 1 ) : NEW_LINE INDENT ans += ( pow ( i / m , n ) - pow ( ( ( i - 1 ) / m , n ) ) * i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT m = 6 NEW_LINE n = 3 NEW_LINE print ( evaluate ( m , n ) ) NEW_LINE
defProdOfPrimes ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE for p in range ( 2 , int ( n ** .5 ) + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT prod = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT prod *= i NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT n = 10 NEW_LINE print ( PrdOfPrimes ( n ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = sum ( [ i - 3 for i in range ( 1 , 10000 + 7 ) if i == 0 or i == 0 or i == 1 or i == 1 or i == 0 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 0 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 0 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 0 or i == 1 or i == 1 or i == 1 or i == 1 or i == 1 or i == 2 or i == 1 or i == 1 or i == 0 or i == 1 or i == 1 or i == 1 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 4 or i == 6 or i == 4 or i == 6 or i == 4 or i == 6 or i == 4 or i == 6 or i == 7 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE def countLeapYears ( d , m , y ) : NEW_LINE INDENT year = d . get ( y ) NEW_LINE if ( d <= 2 ) : NEW_LINE INDENT year -= 1 NEW_LINE DEDENT return year // 4 - year // 4 NEW_LINE DEDENT def countLeap ( d1 , d2 ) : NEW_LINE INDENT n1 = d2 - d NEW_LINE if ( d <= 2 ) : NEW_LINE INDENT return n1 - year // 4 NEW_LINE DEDENT n1 = d2 * ( d1 + d2 ) NEW_LINE n2 = d3 * ( d2 - 1 ) NEW_LINE return ( n2 - n1 ) NEW_LINE DEDENT def getDifference ( d1 , d2 ) : NEW_LINE INDENT n1 = d2 NEW_LINE n2 = d3 * ( d3 - 1 ) NEW_LINE return ( n1 - n1 ) NEW_LINE DEDENT d1 = [ 1 , 2 , 2 , 4 , d2 ] NEW_LINE d2 = [ 1 , 2 , 3 , 4 , d3 ] NEW_LINE n2 = len ( d2 ) NEW_LINE print ( " Difference ▁ between ▁ two ▁ two ▁ two ▁ is " , getDifference ( d1 , d2 ) ) NEW_LINE
def generateNumbers ( n , num ) : NEW_LINE INDENT if ( n > 0 and num < n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( num < n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( num * 10 + a > n ) : NEW_LINE INDENT generateNumbers ( n , num * 10 + a , a ) NEW_LINE DEDENT generateNumbers ( n , num * 10 + a , a ) NEW_LINE print ( " The ▁ numbers ▁ are : ▁ " , end = " " ) NEW_LINE print ( " The ▁ numbers ▁ are : ▁ " , end = " " ) NEW_LINE print ( " The ▁ numbers ▁ are : ▁ " , end = " " ) NEW_LINE print ( " The ▁ numbers ▁ are : ▁ " ) NEW_LINE DEDENT n = 10 NEW_LINE generateNumbers ( n ) NEW_LINE
n , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE x = ( k * k ) / 100 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x * k ) % 100 != 0 : NEW_LINE INDENT x += t NEW_LINE DEDENT else : NEW_LINE INDENT x += k NEW_LINE DEDENT DEDENT print ( * x ) NEW_LINE
while True : NEW_LINE INDENT n , q = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT m = [ 0 ] * 1000000 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT m [ 0 ] += 1 NEW_LINE DEDENT for _ in range ( 1000000 ) : NEW_LINE INDENT m [ 0 ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT m [ i ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT m [ i ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT m [ i ] += 1 NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT m [ i ] += DEDENT print ( m [ i ] ) NEW_LINE DEDENT
def getOddOccurrence ( ar , ar_size ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( ar_size ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT ar = [ 2 , 3 , 5 , 5 , 2 , 5 , 2 , 4 , 2 , 2 , 3 , 4 , 2 , 2 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE print ( getOddOccurrence ( ar , n ) ) NEW_LINE
def isKthBitSet ( x , k ) : NEW_LINE INDENT res = ( ( x & ( 1 << ( k - 1 ) ) ) ) NEW_LINE return res NEW_LINE DEDENT def isKthBitSet ( x , k ) : NEW_LINE INDENT res = ( ( x & ( 1 << ( k - 1 ) ) ) ) * 8 NEW_LINE return res NEW_LINE DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 << ( ( x << ( k - 1 ) ) ) NEW_LINE r = ( ( x , l ) ) * 8 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSetSet ( x , l ) != isKthBitSetSet ( x , r ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT x = 1 << 15 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] == True ) : NEW_LINE INDENT for i in range ( 2 * i , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] == True ) : NEW_LINE INDENT for j in range ( 2 * i , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE SieveOfEratosthenes ( n , isPrimeOfEratosthenes ( n , isPrime [ x ] ) ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT x = n / i NEW_LINE if ( isPrime [ x ] and x != i and x != i ) : NEW_LINE INDENT print ( i , x ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 39 NEW_LINE findPrimePair ( n ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT return b NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , " , " , " , " , " , ▁ = " , g ) " , " , gcd ( a , b ) ) NEW_LINE a = gcd ( a , b ) NEW_LINE print ( " GCD ( " , " , " , " , " , " , " , " , " , " , g ) " ) NEW_LINE a = gcd ( a , b ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT return b NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , " , " , " , " , " , ▁ = " , g ) " , " , gcd ( a , b ) ) NEW_LINE a = gcd ( a , b ) NEW_LINE print ( " GCD ( " , " , " , " , " , " , " , " , " , " , g ) " ) NEW_LINE a = gcd ( a , b ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT SIZE_SIZE = 10 NEW_LINE TIZE_LENGTH = 10 NEW_LINE for n in range ( 3 , SIZE_LENGTH + 1 ) : NEW_LINE INDENT for m in range ( 2 , SIZE_LENGTH + 1 ) : NEW_LINE INDENT TIZE = n * n - m NEW_LINE if TIZE > SIZE_LENGTH : NEW_LINE INDENT break NEW_LINE DEDENT TIZE_LENGTH = ( N - 2 ) * ( SIZE_LENGTH + 1 ) NEW_LINE for t in range ( 2 , TIZE_LENGTH + 1 ) : NEW_LINE INDENT TIZE = n * n - 2 NEW_LINE if TIZE > SIZE_LENGTH : NEW_LINE INDENT break NEW_LINE DEDENT TIZE_LENGTH += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = s . count ( '0' ) NEW_LINE b = s . count ( '0' ) NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT
def maxZeros ( N ) : NEW_LINE INDENT maxm = - 1 NEW_LINE cnt = 0 NEW_LINE while ( N ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE N >>= 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxm = max ( maxm , cnt ) NEW_LINE N >>= 1 NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 14 NEW_LINE print ( maxZeros ( N ) ) NEW_LINE DEDENT
def getLongestSeq ( a , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE maxLen = 0 NEW_LINE currLen = 0 NEW_LINE currLen = 0 NEW_LINE currLen = 0 NEW_LINE currLen = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if ( a [ k ] > 0 ) : NEW_LINE INDENT currLen += 1 NEW_LINE if ( currLen > currLen ) : NEW_LINE INDENT currLen = currLen NEW_LINE currLen = k NEW_LINE DEDENT currLen = currLen NEW_LINE DEDENT currLen = 0 NEW_LINE DEDENT if ( maxLen > 0 ) : NEW_LINE INDENT print ( " Index ▁ of ▁ Length ▁ Length ▁ Length ▁ : ▁ " , currLen ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Length ▁ Length ▁ Length ▁ Length ▁ : ▁ " , maxLen ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , - 3 , 3 , 4 , - 6 , 2 , 5 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE getLongestSeq ( arr , n ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . right = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def construct ( arr , i , j , m , n ) : NEW_LINE INDENT if ( i > n - 1 or j > m - 1 ) : NEW_LINE INDENT return None NEW_LINE DEDENT temp = arr [ i ] [ j ] NEW_LINE right = construct ( arr , i + 1 , j + 1 , m , n ) NEW_LINE return temp NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT Rp = [ [ 1 , 2 ] , [ 4 , 5 ] , [ 7 , 8 ] ] NEW_LINE while ( Rp ) : NEW_LINE INDENT Rp . append ( Rp . data ) NEW_LINE R = construct ( arr , i + 1 , j , m ) NEW_LINE DEDENT DEDENT def display ( head ) : NEW_LINE INDENT Rp . append ( [ 1 , 2 ] ) NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT R = [ 1 , 2 ] , [ 4 , 5 ] NEW_LINE for i in range ( len ( Rp ) ) : NEW_LINE INDENT R = Dp [ i ] [ i ] NEW_LINE while ( Rp ) : NEW_LINE INDENT Rp [ Rp [ i ] ] = Rp [ i ] [ j ] NEW_LINE R = Rp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 5 ] , [ 4 , 5 , 9 ] NEW_LINE m = 3 NEW_LINE n = 3 NEW_LINE n = 3 NEW_LINE print display ( arr , 0 , n , m ) NEW_LINE DEDENT
import math NEW_LINE def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def prime ( n ) : NEW_LINE INDENT prime_factor = [ ] NEW_LINE prime_factor . append ( 1 ) NEW_LINE prime_factor . append ( 2 ) NEW_LINE prime_factor . append ( 0 ) NEW_LINE prime_factor . append ( 1 ) NEW_LINE prime_factor . append ( 2 ) NEW_LINE prime_factor . append ( 0 ) NEW_LINE prime_factor . append ( 1 ) NEW_LINE prime_factor . append ( 2 ) NEW_LINE prime_factor . append ( 1 ) NEW_LINE prime_factor . append ( 2 ) NEW_LINE DEDENT prime_factorize ( prime_factor ) NEW_LINE prime_factorize = prime_factorize ( prime_factor ) NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize NEW_LINE prime_factorize = prime_factorize
def findNthTerm ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT ans = ( N // 2 + ( N // 2 ) * 6 + ( N // 2 ) * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N // 2 ) * 6 + ( N // 2 ) * 6 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT
def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( a == b and c == d ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( a == b and c == d ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( a == b and c == d ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( a == c and c == d ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 4 NEW_LINE if ( isRectangle ( a , b , c , d ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def discreteLogarime ( a , b , m ) : NEW_LINE INDENT n = ( math . sqrt ( n ) + 1 ) NEW_LINE one = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( value [ i ] == 0 ) : NEW_LINE INDENT value = i NEW_LINE DEDENT cur = ( cur * a ) % m NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i NEW_LINE if ( value [ cur ] < m ) : NEW_LINE INDENT value [ cur ] = i NEW_LINE DEDENT cur = ( cur * a - i ) % m NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ( value [ cur ] * n - i ) NEW_LINE DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT DEDENT a = 2 NEW_LINE b = 3 NEW_LINE m = 7 NEW_LINE print ( discreteLogarime ( a , b , m ) ) NEW_LINE
def FindMinimumCost ( ind , a , n , k ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT dp [ ind ] = ans NEW_LINE return dp [ ind ] NEW_LINE DEDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE
from math import gcd NEW_LINE def Probability ( sum , t ) : NEW_LINE INDENT mutual = 0 NEW_LINE total = 0 NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT for j in range ( 1 , 6 ) : NEW_LINE INDENT if ( i + j ) == sum : NEW_LINE INDENT mutual += 1 NEW_LINE DEDENT DEDENT DEDENT gcd = gcd ( total , t ) NEW_LINE probability = 0 NEW_LINE probability = gcd ( probability , total ) NEW_LINE probability = probability / gcd ( probability , total ) NEW_LINE probability = probability / gcd NEW_LINE probability = probability / gcd NEW_LINE probability = probability / gcd NEW_LINE probability = probability / gcd NEW_LINE probability = probability / gcd NEW_LINE probability = probability / gcd NEW_LINE probability = probability / gcd NEW_LINE probability = probability / gcd NEW_LINE probability = probability / gcd NEW_LINE return probability NEW_LINE DEDENT sum = 7 NEW_LINE print ( " / " , Probability ( sum , times ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE K , N = map ( int , input ( ) . split ( ) ) NEW_LINE mod = 998244353 NEW_LINE def make_factors ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n < 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n < 3 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return ( ( mod - 2 ) * mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( mod - 2 ) * mod ) % mod NEW_LINE DEDENT DEDENT def make_factors ( n , k ) : NEW_LINE INDENT if k < n : NEW_LINE INDENT return ( ( k - n // 2 ) * ( k - n // 2 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n // 2 ) * ( k - n // 2 ) ) % mod NEW_LINE DEDENT DEDENT fact = make_factors ( K + 1 ) NEW_LINE fact = [ [ 1 ] * ( fact [ - 1 ] + 1 ) ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT fact [ i ] [ 0 ] = fact [ i - 1 ] [ i ] * fact [ i - 1 ] * fact [ i - 1 ] [ i - 1 ] * fact [ i - 1 ] [ i - 1 ] NEW_LINE fact [ i ] [ i ] = fact [ i - 1 ] * fact [ i - 1 ] [ i - 1 ] * fact [ i - 1 ] NEW_LINE fact [ i
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE if a == " J " : NEW_LINE INDENT ans += a NEW_LINE DEDENT else : NEW_LINE INDENT ans += b NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == num1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i >= n - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT j = n - 1 NEW_LINE while j >= i : NEW_LINE INDENT if arr [ j ] == num2 : NEW_LINE INDENT break NEW_LINE DEDENT if j == i : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 9 , 9 , 9 , 9 ] NEW_LINE n1 = len ( arr ) NEW_LINE num2 = 4 NEW_LINE print ( getCount ( arr , n1 , num2 , num2 ) ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE a . sort ( ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i + 1 ] - a [ i ] > a [ i + 1 ] - a [ i ] : NEW_LINE INDENT ans = min ( ans , a [ i ] - a [ i + 1 ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE setBits = [ 0 ] * ( n + 1 ) NEW_LINE setBits [ 1 ] = 0 NEW_LINE setBits [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 6 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def largestGCDSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubsetSubset
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE ans = sum ( 2 ** eulerlib . count ( 2 ** eulerlib . count ( 2 ) ) for eulerlib . count ( 2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT ans = compute ( ) NEW_LINE for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT if num % i == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT arr [ 0 ] = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 5 , 1 , 3 , 4 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE
def findDecimalArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( sum - arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 5 , 1 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE findDecimalArray ( arr , N ) NEW_LINE
def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE
def findMinDifference ( arr , n ) : NEW_LINE INDENT secondMax = ( arr [ 0 ] ) NEW_LINE secondMax = ( arr [ 1 ] ) NEW_LINE maxMin = arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ 1 ] ) : NEW_LINE INDENT secondMax = max ( arr [ i ] , arr [ i ] ) NEW_LINE DEDENT elif ( arr [ i ] < secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT DEDENT diff = max ( max - secondMax - secondMin ) NEW_LINE return diff NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinDifference ( arr , n ) ) NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE def primeFactors ( n ) : NEW_LINE INDENT factors = set ( ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT factors . add ( i ) NEW_LINE n //= i NEW_LINE DEDENT DEDENT return factors NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT factors . add ( i ) NEW_LINE DEDENT for i in factors : NEW_LINE INDENT if primeFactors ( i ) : NEW_LINE INDENT factors . add ( i ) NEW_LINE DEDENT DEDENT if len ( factors ) == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE c = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE c . sort ( ) NEW_LINE c . sort ( ) NEW_LINE c . sort ( ) NEW_LINE if len ( c ) == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if c [ i ] == c [ i + 1 ] : NEW_LINE INDENT print ( c [ i ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c [ i ] , end = " " ) NEW_LINE c [ i + 1 ] = c [ i + 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def fact ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * fact ( n - 1 ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT return fact ( n - 1 ) * fact ( n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 5 NEW_LINE print ( " Factorial ▁ of ▁ " , num , " is " , fact ( num ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , d , x = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( d + 1 ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if d [ i ] < dp [ i ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j ] + dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ x ] [ n ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE l . sort ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT q , r = map ( int , input ( ) . split ( ) ) NEW_LINE if q == 1 : NEW_LINE INDENT l [ r ] = r NEW_LINE DEDENT else : NEW_LINE INDENT l [ r ] = r NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT t , l [ i ] = l [ i ] + l [ i - 1 ] NEW_LINE if t == 1 : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT DEDENT
def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE if ( ( len ( st ) - st [ i ] ) % 2 == 0 ) : NEW_LINE INDENT return ( ( int ( st [ i ] ) / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( int ( st [ i ] ) / 2 ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT return ( int ( st [ 0 ] ) / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( int ( st [ 1 ] ) / 2 ) NEW_LINE DEDENT DEDENT a = [ 1 , 4 , 4 , 7 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE
import math NEW_LINE def findX ( n , k ) : NEW_LINE INDENT r = math . sqrt ( k ) + 1 NEW_LINE m = int ( math . sqrt ( k ) + 1 ) NEW_LINE for i in range ( 2 , m + 1 ) : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT i = k NEW_LINE DEDENT for k in range ( 2 , n + 1 ) : NEW_LINE INDENT k = k / i NEW_LINE u = min ( r , u ) NEW_LINE DEDENT DEDENT if ( v > 0 ) : NEW_LINE INDENT t = n NEW_LINE while ( t > 0 ) : NEW_LINE INDENT t = t // i NEW_LINE u = min ( r , u // v ) NEW_LINE r = min ( r , u // v ) NEW_LINE r = min ( r , u // v ) NEW_LINE r = min ( r , u // v ) NEW_LINE r = min ( r , u // v ) NEW_LINE DEDENT r = min ( r , u // v ) NEW_LINE DEDENT return r NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( findX ( n , k ) ) NEW_LINE
def PartsIncircr ( a , b , x , y ) : NEW_LINE INDENT if ( x - y + b <= 0 and x + b <= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT defBottleInr ( a , b , x , y ) : NEW_LINE INDENT if ( x - y + b >= 0 and x + b >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a , b , x , y = 2 , 2 , 5 NEW_LINE if ( PartsIncircr ( a , b , x , y ) ) : NEW_LINE INDENT print ( " There ▁ of ▁ p ▁ doesn ' t ▁ doesn ' that ▁ doesn ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " There ▁ at ▁ at ▁ at ▁ at ▁ on ▁ at ▁ at ▁ at ▁ rigle " ) NEW_LINE DEDENT
N = 1000 NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT size = ( 2 * N ) + 1 NEW_LINE freq = [ 0 for i in range ( size ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x + N ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT ans += ( ( freq [ i ] - 1 ) * ( freq [ ( i + j ) // 2 ) ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 4 , 2 , 5 , 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE
def getAvg ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE return ( ( sum ) / x ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( arr [ i ] ) NEW_LINE print ( " average ▁ of ▁ % ▁ is " , i , " is ▁ " , int ( avg ) ) NEW_LINE DEDENT DEDENT arr = [ 10 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE streamAvg ( arr , n ) NEW_LINE
MAX = 10000 ; NEW_LINE sieve = [ True ] * ( MAX ) ; NEW_LINE prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT product = 1 ; NEW_LINE for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT product = product * p ; NEW_LINE s [ p ] = False ; NEW_LINE DEDENT DEDENT DEDENT def isEqual ( n ) : NEW_LINE INDENT if ( n == True ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT SieveOfEratosthenes ( ) ; NEW_LINE if ( isEqual ( n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT n = 31 ; NEW_LINE if ( isEqual ( n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
n , b = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT b . append ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( b [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT DEDENT print ( sum ( b ) ) NEW_LINE
def maxOperations ( str ) : NEW_LINE INDENT i , gk , gk = gk , gk NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' k ' ) : NEW_LINE INDENT gk += 1 NEW_LINE DEDENT elif ( str [ i ] == ' s ' ) : NEW_LINE INDENT gk -= 1 NEW_LINE gk += 1 NEW_LINE DEDENT DEDENT return gk NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = " gggks " NEW_LINE print ( maxOperations ( a ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE print ( len ( a ) - ( a [ 0 ] - a [ - 1 ] ) + 1 ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE m , n = map ( int , input ( ) . split ( ) ) NEW_LINE g = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE g [ a ] . append ( b ) NEW_LINE g [ b ] . append ( a ) NEW_LINE DEDENT def dfs ( x , y ) : NEW_LINE INDENT if g [ x ] == 1 : NEW_LINE INDENT return x NEW_LINE DEDENT if g [ y ] == 1 : NEW_LINE INDENT return g [ y ] NEW_LINE DEDENT g [ x ] = g [ y ] NEW_LINE return g [ x ] == g [ y ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE g [ x ] . append ( y ) NEW_LINE g [ y ] . append ( i ) NEW_LINE g [ x ] . append ( y ) NEW_LINE g [ y ] . append ( i ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if dfs ( i , 0 , i ) : NEW_LINE INDENT ans += dfs ( i , g [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def kthSmallest ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT arr = [ 12 , 3 , 5 , 7 , 19 , 19 ] NEW_LINE k = 2 NEW_LINE print ( " Kth ▁ smallest ▁ element ▁ is " , kthSmallest ( arr , k ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] == a [ i + 1 ] : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE DEDENT DEDENT print ( * a ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT start , end = eulerlib . list_array ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( end ) : NEW_LINE INDENT if not prime [ i ] : NEW_LINE INDENT ans += sum ( 2 ** i ** ( len ( i ) - 1 ) ** 2 ** ( len ( i ) - 1 ) ** 2 ** ( len ( i ) - 1 ) ** 2 ** ( len ( i ) - 1 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from math import radians , sin , cos , radians NEW_LINE def distance ( lat1 , lat2 , lst2 ) : NEW_LINE INDENT lst1 = lat1 - lst2 NEW_LINE lst2 = lat2 - lst2 NEW_LINE dlin = ( lst1 - lst2 ) * ( sin ( lat1 / 2 ) * cos ( lat2 / 2 ) * cos ( lat2 / 2 ) ) NEW_LINE dlin = 6378.5 NEW_LINE return ( dlin * rlin ) NEW_LINE DEDENT def distance ( lat1 , lat2 , lst2 ) : NEW_LINE INDENT lst1 = ( lst2 ) NEW_LINE dlin = ( lst2 ) NEW_LINE dlin = ( lst2 ) NEW_LINE lst2 = ( lst2 ) * cos ( lat1 ) NEW_LINE rst2 = ( lst2 ) * cos ( lat2 ) NEW_LINE return ( c * rlin ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT lat1 = 53 NEW_LINE lst2 = - 1.5 NEW_LINE lst2 = - 1.5 NEW_LINE lst2 = 6.5 NEW_LINE print ( distance ( lat1 , lst2 , lst2 , lst2 , lst2 ) , " K . " , " M M M M M . " , " M . 6.5 ) NEW_LINE DEDENT
def centeredOcta ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 2 * n * n + 3 ) // 3 NEW_LINE DEDENT n = 3 NEW_LINE print ( centeredOcta ( n ) ) NEW_LINE n = 9 NEW_LINE print ( centeredOcta ( n ) ) NEW_LINE n = 9 NEW_LINE print ( centeredOcta ( n ) ) NEW_LINE n = 9 NEW_LINE print ( centeredOcta ( n ) ) NEW_LINE n = 9 NEW_LINE print ( centeredOcta ( n ) ) NEW_LINE
from collections import Counter NEW_LINE n , m , p = map ( int , input ( ) . split ( ) ) NEW_LINE d = Counter ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ i ] = 0 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT d [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if d [ i ] : NEW_LINE INDENT ans . append ( i * ( - 1 ) ) NEW_LINE DEDENT DEDENT print ( min ( ans ) ) NEW_LINE
import sys NEW_LINE def sumDivPrime ( A ) : NEW_LINE INDENT max_val = - 1 NEW_LINE prime [ 0 ] = False NEW_LINE for i in range ( 0 , len ( A ) ) : NEW_LINE INDENT if ( A [ i ] == A [ i ] ) : NEW_LINE INDENT max_val = A [ i ] NEW_LINE DEDENT DEDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT prime [ p ] = False NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for p in range ( 0 , n ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT sum += A [ p ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ A [ i ] ] : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ A [ i ] ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE SumDivPrime ( A ) NEW_LINE DEDENT
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( arr [ i % n ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE k = 2 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE k = 2 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE k = 4 NEW_LINE rightRotate ( arr , n , k ) NEW_LINE k = 4 NEW_LINE rightRotate ( arr , n , k ) NEW_LINE k = 4 NEW_LINE rightRotate ( arr , n , k ) NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE rightRotate ( arr , n , k ) NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE rightRotate ( arr , n , k ) NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE rightRotate ( arr , n , k ) NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE rightRotate ( arr , n , k ) NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE rightRotate ( arr , n , k ) NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k ( k ) NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k ( k ) NEW_LINE k = 4 NEW_LINE k = 4 NEW_LINE k ( k ) NEW_LINE k ( k = 4 ) NEW
def closestMultiple ( n , x ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return x NEW_LINE DEDENT n = n + x // 2 NEW_LINE return n NEW_LINE DEDENT n = 56287287 NEW_LINE x = 27287287 NEW_LINE print ( closestMultiple ( n , x ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE sum = 0 NEW_LINE for j in s : NEW_LINE INDENT sum += int ( j ) NEW_LINE DEDENT if sum % 3 != 0 : NEW_LINE INDENT print ( " red " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " red " ) NEW_LINE DEDENT DEDENT
import numpy as np NEW_LINE dp = np . zeros ( ( 9 , 8 ) ) NEW_LINE def minimumNumberOfDigits ( a , b ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( dp [ a ] [ b ] != - 1 ) : NEW_LINE INDENT return dp [ a ] [ b ] NEW_LINE DEDENT if ( dp [ a ] [ b ] != - 1 ) : NEW_LINE INDENT return dp [ a - 1 ] [ b - ( a * i ) ] NEW_LINE DEDENT ans = 101 NEW_LINE for i in range ( 9 , 9 ) : NEW_LINE INDENT k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) NEW_LINE if ( k != - 1 ) : NEW_LINE INDENT ans = min ( ans , k + 1 ) NEW_LINE DEDENT DEDENT dp [ a - 1 ] [ b - ( i * i * i ) ] = ans NEW_LINE if ( k == - 1 or k > 100 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , 9 ) : NEW_LINE INDENT if ( ( dp [ a - i * i * i ) + ( dp [ a - i * i * i ] [ b - ( i * i * i * i ) + dp [ a - ( a - i * i * i * i * i * i ) ] == dp [ a - i * i * i * i * i * i ] ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT a = 18 NEW_LINE b = 152 NEW_LINE printSmallestNumber ( a , b ) NEW_LINE
N = 5005 NEW_LINE def Add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] [ y ] = 1 NEW_LINE gr [ y ] [ x ] = x NEW_LINE gr [ y ] [ x ] = x NEW_LINE DEDENT def Add_edge ( v , p ) : NEW_LINE INDENT d = [ ] NEW_LINE gr [ v ] . append ( p ) NEW_LINE for i in range ( len ( gr ) ) : NEW_LINE INDENT if ( i != p ) : NEW_LINE INDENT d [ i ] . append ( d [ i ] [ k - 1 ] * d [ i ] [ k - 1 ] ) NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT d += d [ j ] [ k - 1 ] * d [ j ] [ k - j ] NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT d += d [ j ] [ k - j ] * d [ j ] [ k - 1 ] NEW_LINE DEDENT DEDENT return d NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE print ( ans ) NEW_LINE
def findSubsequence ( arr , n ) : NEW_LINE INDENT len = 1 NEW_LINE cnt = [ 0 ] * 10 NEW_LINE cnt [ 0 ] = 0 NEW_LINE curr = [ 0 ] * 10 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i % 10 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE locMax [ i ] = 1 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 NEW_LINE tmp = tmp // 10 NEW_LINE DEDENT for d in range ( 0 , 10 ) : NEW_LINE INDENT if ( cnt [ d ] == 1 ) : NEW_LINE INDENT dp [ d ] += 1 NEW_LINE locMax [ d ] = locMax [ d ] NEW_LINE DEDENT DEDENT DEDENT return len NEW_LINE DEDENT arr = [ 1 , 12 , 44 , 33 , 98 , 98 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( b ) - len ( a ) ) NEW_LINE DEDENT
def totalPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT def countPairs ( G , L ) : NEW_LINE INDENT if ( L % G != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT div = L / GCDFactors ( G , L ) NEW_LINE return ( 1 << divFactors ( div ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT G = 2 NEW_LINE print ( " Total ▁ pairs ▁ = ▁ " , countPairs ( G , L ) ) NEW_LINE DEDENT
def calculate_sum ( a , N ) : NEW_LINE INDENT m = N // a NEW_LINE sum = m * ( m + 1 ) // 2 NEW_LINE return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE N = 49 NEW_LINE print ( " Sum ▁ of ▁ multiple ▁ of ▁ multiple ▁ = " , calculate_sum ( a , N ) , " u " , calculate_sum ( a , N ) ) NEW_LINE DEDENT
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) . split ( ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE l = [ ] NEW_LINE for i in s : NEW_LINE INDENT if i [ 0 ] * k >= 100 : NEW_LINE INDENT l . append ( i [ 1 ] * k / 100 ) NEW_LINE DEDENT DEDENT print ( len ( l ) ) NEW_LINE for i in l : NEW_LINE INDENT print ( i [ 0 ] , l [ i [ 1 ] ] * k / 100 ) NEW_LINE DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT
def next ( arr , target ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( arr ) - 1 NEW_LINE ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if arr [ mid ] <= target : NEW_LINE INDENT start = mid + 1 NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 5 , 8 ] NEW_LINE print ( next ( arr , 8 ) ) NEW_LINE
word = [ " zero " , " one " , " two " , " three " , " six " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " , " seven " ] NEW_LINE while ( n ) : NEW_LINE INDENT digits = [ digits - 1 ] NEW_LINE n = digit - 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT print ( word [ digits ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , k , m = map ( int , input ( ) . split ( ) ) NEW_LINE w = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( w ) NEW_LINE b = sum ( w ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT b += w [ i ] NEW_LINE DEDENT print ( b / n ) NEW_LINE
def solve ( a , b ) : NEW_LINE INDENT l = len ( a ) NEW_LINE min = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == ' + ' or b [ i ] == ' + ' or a [ i ] != b [ i ] ) : NEW_LINE INDENT min += 1 NEW_LINE DEDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT min += 1 NEW_LINE DEDENT DEDENT print ( min + max ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " a + c " NEW_LINE s2 = " + + + " NEW_LINE solve ( s1 , s2 ) NEW_LINE DEDENT
def TotalWays ( n , s , k ) : NEW_LINE INDENT dp = [ 0 ] * ( n - 1 ) NEW_LINE dp [ s - 1 ] = 1 NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i , k ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT n , k = 5 , 2 NEW_LINE print ( TotalWays ( n , k ) ) NEW_LINE
def countEvenOdd ( n ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 NEW_LINE if ( rem % 2 == 0 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT print ( " Even ▁ count ▁ count ▁ : " , even_count ) NEW_LINE if ( even_count % 2 != 0 ) : NEW_LINE INDENT print ( " Even ▁ count ▁ count ▁ count ▁ : " , even_count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even ▁ count ▁ count ▁ count ▁ : " , odd_count ) NEW_LINE DEDENT DEDENT n = 23 NEW_LINE t = countEvenOdd ( n ) NEW_LINE if ( evenEvenOdd ( n ) ) : NEW_LINE INDENT print ( " Even ▁ count ▁ count ▁ count ▁ : " , even_count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def solve ( ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT c , d = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( c ) NEW_LINE DEDENT B = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT B . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT B . sort ( reverse = True ) NEW_LINE dp = [ [ INF ] * 10 for _ in range ( 10 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT for j in range ( K ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i ] + B [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( K ) : NEW_LINE INDENT for j in range ( K ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - 1 ] + B [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ K - 1 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def findmin ( p , n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] <= 0 : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif p [ i ] >= 0 : NEW_LINE INDENT b += 1 NEW_LINE DEDENT elif p [ i ] >= 0 : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT return min ( min ( a , b , d ) , min ( c , d ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT p = [ 1 , 1 , 2 , - 1 ] NEW_LINE n = len ( p ) NEW_LINE print ( findmin ( p , n ) ) NEW_LINE DEDENT
import math as mt NEW_LINE def maxGCD ( N , P ) : NEW_LINE INDENT ans = 1 NEW_LINE prime_factors = dict ( ) NEW_LINE for i in range ( 2 , P ) : NEW_LINE INDENT while ( P % i == 0 ) : NEW_LINE INDENT if ( prime_factors [ i ] ) : NEW_LINE INDENT prime_factors [ i ] = prime_factors [ i ] + 1 NEW_LINE DEDENT P //= i NEW_LINE DEDENT DEDENT if ( P != 1 ) : NEW_LINE INDENT if ( prime_factors [ P ] == None ) : NEW_LINE INDENT prime_factors [ P ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime_factors [ P ] = ( prime_factors [ P ] / N ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 3 NEW_LINE P = 24 NEW_LINE print ( maxGCD ( N , P ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE m = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if i >> j & 1 == 1 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c == 0 : NEW_LINE INDENT ans . append ( str ( i ) + " ▁ " . join ( str ( j ) for i in c ) ) NEW_LINE DEDENT DEDENT print ( " { } : " . format ( i ) , " ▁ " . join ( str ( i ) for i in ans ) ) ) NEW_LINE
def primeFactorize ( countPrime , primeFactorial ) : NEW_LINE INDENT if ( countOfPfilefilefilefile ) : NEW_LINE INDENT print ( curPrime , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT for i in range ( 2 , int ( countPrimefilefilefilefilefile ) + 1 ) : NEW_LINE INDENT if ( count % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n //= i NEW_LINE DEDENT DEDENT DEDENT if ( n > 1 ) : NEW_LINE INDENT return primeFactorize NEW_LINE DEDENT DEDENT def generateDivisors ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE curDivisors = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT curDivisors += 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n //= i NEW_LINE curDivisors += 1 NEW_LINE DEDENT curDivisors += 1 NEW_LINE DEDENT DEDENT if ( n > 1 ) : NEW_LINE INDENT arr . append ( n ) NEW_LINE DEDENT return arr NEW_LINE DEDENT n = 6 NEW_LINE generateDivisors ( n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ 0 ] * 1000001 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l [ a - 1 ] = b NEW_LINE l [ b - 1 ] += 1 NEW_LINE DEDENT print ( n - max ( l ) ) NEW_LINE
def largestPalinSub ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == mx ) : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( largestPalinSubSub ( s ) ) NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE s = list ( input ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE s [ i ] = c NEW_LINE DEDENT DEDENT print ( ' ' . join ( s ) ) NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = max ( a ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT m = a [ i ] // 2 NEW_LINE DEDENT DEDENT m = max ( m , m ) NEW_LINE print ( m ) NEW_LINE
def initializeDiffArray ( A , D , D , x ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D [ 0 ] = A [ 0 ] NEW_LINE D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE D [ i ] -= x NEW_LINE DEDENT def printArray ( A , D , D , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE D [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT printArray ( A , D , end = " ▁ " ) NEW_LINE DEDENT DEDENT A = [ 10 , 5 , 2 , 4 , 1 ] NEW_LINE n = len ( A ) NEW_LINE d = [ 10 , 5 , 2 , 4 ] NEW_LINE initializeDiffArray ( A , D , D , D , 1 ) NEW_LINE printArray ( A , D , D , [ 1 , 2 , 2 , 2 , 1 ] ) NEW_LINE
def findMaxSquares ( arr , key , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE merge_in_acc = 1 NEW_LINE max_in_acc = arr [ 0 ] NEW_LINE t = arr [ 0 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] <= key ) : NEW_LINE INDENT max_in_acc = t . index ( key ) NEW_LINE t = arr [ i ] NEW_LINE t = arr [ i ] NEW_LINE t = arr [ i ] NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ of ▁ trials ▁ = ▁ " , max_in_acc ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 10 , 10 , 10 ] NEW_LINE findMaxSquares ( arr , key , n ) NEW_LINE DEDENT
def l_i ( s ) : NEW_LINE INDENT l_i = len ( s ) NEW_LINE l_i = [ 0 ] * ( l_i + 1 ) NEW_LINE for i in range ( l_i ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT l_i [ i ] = l_i [ i + 1 ] NEW_LINE l_i [ i ] = l_i [ i ] NEW_LINE DEDENT DEDENT return l_i [ : i ] NEW_LINE DEDENT while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " # " : NEW_LINE INDENT break NEW_LINE DEDENT s = s . l_i ( ) NEW_LINE t = s . r_i ( t ) NEW_LINE l_i = len ( s ) NEW_LINE m = len ( t ) NEW_LINE for i in range ( l_i ) : NEW_LINE INDENT if s [ i ] == t [ i + 1 ] : NEW_LINE INDENT m = s [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT m = s [ i + 1 ] NEW_LINE DEDENT DEDENT print ( m ) NEW_LINE DEDENT
def calcFraction ( n , r ) : NEW_LINE INDENT finalDigominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i - mx , i - mx ) NEW_LINE finalominator = ( finalominator * denominator ) / denominator NEW_LINE DEDENT return finalominator NEW_LINE DEDENT n = 6 NEW_LINE r = 2 NEW_LINE print ( "1 / " , calcFraction ( n , r ) ) NEW_LINE
from math import sqrt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE if ( sr * sr == x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT n = 7 NEW_LINE k = 2 NEW_LINE isPerfectSquare ( n + k ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = Counter ( a ) NEW_LINE c = Counter ( b ) NEW_LINE for i , v in enumerate ( a ) : NEW_LINE INDENT if v % 2 == 1 : NEW_LINE INDENT if v % 2 == 1 : NEW_LINE INDENT c [ i ] = [ ] NEW_LINE DEDENT else : NEW_LINE INDENT c [ i ] . append ( i ) NEW_LINE DEDENT DEDENT DEDENT print ( sum ( c ) // 2 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE flag = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] != a [ i + 1 ] and a [ i + 2 ] != a [ i + 2 ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : break NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT a [ i ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans if ans else - 1 ) NEW_LINE DEDENT
def isDivisible ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( S [ n - 1 ] != '0' and S [ n - 1 ] != '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 0 , len ( S ) ) : NEW_LINE INDENT sum += S [ i ] NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT S = "64444647477244353244353244353244353244353244353244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244244
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( range ( 1 , eulerlib . sqrt ( 10 ** 6 ) ) for eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ) ) ) ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def find_square ( limit ) : NEW_LINE INDENT sum_square = sum ( find_square ) NEW_LINE if sum_square == - 1 : NEW_LINE INDENT return sum_square NEW_LINE DEDENT sum_square = sum ( find_square ) NEW_LINE if sum_square == - 1 : NEW_LINE INDENT return str ( sum_square ) NEW_LINE DEDENT sum_square = sum ( find_square ) NEW_LINE for a in range ( 1 , int ( sqrt ( limit ) ) + 1 ) : NEW_LINE INDENT for b in range ( 1 , int ( sqrt ( limit ) ) + 1 ) : NEW_LINE INDENT if ( ( a + b ) % 2 == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT sum_square = sum ( find_square ( a + b ) // 2 ) NEW_LINE if sum_square == sum_square : NEW_LINE INDENT return str ( sum_square ) NEW_LINE DEDENT sum_square = sum ( sum_square ) NEW_LINE for c in range ( 1 , int ( sqrt ( y ) ) + 1 ) : NEW_LINE INDENT if ( ( sum_square - b ) % 2 == 0 ) : NEW_LINE INDENT return str ( sum_square ) NEW_LINE DEDENT sum_square = sum_square NEW_LINE for c in range ( 1 , int ( sqrt ( y ) + 1 ) + 1 ) : NEW_LINE INDENT if ( ( sum_square - b ) % 2 == 0 ) : NEW_LINE INDENT sum_square = sum_square NEW_LINE DEDENT DEDENT sum_square = sum_square NEW_LINE for c in range ( int ( sqrt ( y ) + 1 ) + 1 ) : NEW_LINE INDENT if sum_square > sum_square + b : NEW
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' or c == ' u ' ) NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT countVowels = 0 NEW_LINE ans = " " NEW_LINE for l in range ( 0 , n - k + 1 ) : NEW_LINE INDENT countVowels = 0 NEW_LINE for r in range ( l + 1 , n + 1 ) : NEW_LINE INDENT if isVowel ( s [ r ] ) : NEW_LINE INDENT countVowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countVowels += 1 NEW_LINE DEDENT DEDENT ans += str ( countVowels * countVowels ) NEW_LINE DEDENT return ans NEW_LINE DEDENT s = " hello " NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE printString ( s , n , k ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return a * b // gcd ( a , b ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return a * b // gcd ( a , b ) NEW_LINE DEDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE T = list ( input ( ) ) NEW_LINE T = list ( input ( ) ) NEW_LINE T = lcm ( T , T ) NEW_LINE if T [ 0 ] == T [ 1 ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( T [ 0 ] ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ 0 ] * ( n + 2 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if ( x <= 9 ) : NEW_LINE INDENT d [ y ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ x - 1 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 2 ) : NEW_LINE INDENT for j in range ( 1 , n + 2 ) : NEW_LINE INDENT if ( d [ i ] [ j ] == 9 ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 2 ) : NEW_LINE INDENT for j in range ( 1 , n + 2 ) : NEW_LINE INDENT if ( d [ i ] [ j ] == 9 ) : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE c = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = input ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if c [ i ] [ j ] == 1 : c [ i ] [ j ] = 1 NEW_LINE else : c [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if c [ i ] [ j ] == 1 : c [ i ] [ j ] = c [ i ] [ j ] + 1 NEW_LINE else : c [ i ] [ j ] = c [ i ] [ j ] + 1 NEW_LINE if c [ i ] [ j ] == 1 : c [ i ] [ j ] = 1 NEW_LINE else : c [ i ] [ j ] = c [ i ] [ j ] NEW_LINE DEDENT DEDENT ans = max ( ans , c [ 0 ] [ 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n * n * n * n * n * n ) + ( 10 * n * n * n ) - n ) // 30 NEW_LINE DEDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE
def maxLengthSubSub ( arr , n ) : NEW_LINE INDENT max_val = 0 NEW_LINE start = 0 NEW_LINE start = 0 NEW_LINE start = 0 NEW_LINE start = 0 NEW_LINE start = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = 0 NEW_LINE if ( arr [ i ] - 1 ) : NEW_LINE INDENT temp = temp NEW_LINE DEDENT if ( arr [ i ] - 1 ) : NEW_LINE INDENT temp = max ( temp , temp ) NEW_LINE DEDENT if ( temp > max_val ) : NEW_LINE INDENT max_val = temp NEW_LINE DEDENT temp += 1 NEW_LINE if ( temp > max_val ) : NEW_LINE INDENT max_val = temp NEW_LINE DEDENT DEDENT return max_val NEW_LINE DEDENT arr = [ 2 , 5 , 6 , 7 , 6 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ length ▁ length ▁ subsequence ▁ subsequence ▁ = " , maxLengthSubSubSub ( arr , n ) ) NEW_LINE
def rearrange ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] == 0 or n % 2 == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT currindex = ( n - 1 ) // 2 NEW_LINE while ( currindex > 0 ) : NEW_LINE INDENT count = currindex + 1 NEW_LINE arr [ currindex + 1 ] = arr [ currindex + 1 ] NEW_LINE currindex = currindex + 1 NEW_LINE DEDENT currindex = int ( currindex ) NEW_LINE return arr [ currindex ] NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 2 , 4 , 6 ] NEW_LINE rearrange ( arr , n ) NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
import sys NEW_LINE from heapq import heappush , heappop NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( n , k , edge ) : NEW_LINE INDENT d = [ INF ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if c == 0 : NEW_LINE INDENT edge [ c ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT d [ c ] = 0 NEW_LINE DEDENT DEDENT def dfs ( i , edge ) : NEW_LINE INDENT if edge [ i ] < edge [ i ] : NEW_LINE INDENT edge [ i ] = edge [ i ] + edge [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT edge [ i ] [ j ] = edge [ i ] [ j ] + edge [ i ] [ j ] NEW_LINE DEDENT DEDENT return dfs ( 0 , 0 , - 1 ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and k == 0 : NEW_LINE INDENT break NEW_LINE DEDENT edge = [ [ ] for i in range ( n ) ] NEW_LINE edge [ n ] = edge [ n ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT edge [ i ] . append ( edge [ i ] [ n ] ) NEW_LINE DEDENT for i in edge [ i ] : NEW_LINE INDENT edge [ i ] . append ( edge [ i ] [ n ] ) NEW_LINE DEDENT DEDENT for i in edge [ 1 : ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def countCharacter ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ch >= ' a ' or ch <= ' z ' or ch <= ' u ' or ch <= ' u ' or ch <= ' u ' ) : NEW_LINE INDENT chuum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT print ( " Vowels : " , " u ' , ch ) NEW_LINE print ( " Vowels : " , " vowels : " , " u " , ch ) NEW_LINE print ( " Vowels : " , ch ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeks ▁ geeks " , " geeks " , " geeks " NEW_LINE countCharacter ( str ) NEW_LINE DEDENT
def increaseInVol ( l , b , h ) : NEW_LINE INDENT percentInc = ( 1 + ( l / 100 ) * ( b / 100 ) ) * ( 1 + ( h / 100 ) ) NEW_LINE percentageInc -= 1 NEW_LINE return percentageInc NEW_LINE DEDENT l , b , h = 5 , 20 , 10 NEW_LINE print ( increaseInVol ( l , b , h ) , " % " % " % " % ( int ( increaseInVol ( l , b , h ) ) ) ) NEW_LINE
def MaxTotalRectangle ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] - a [ i + 1 ] ) and ( flag ) ) : NEW_LINE INDENT flag = True NEW_LINE flag = False NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 10 , 10 , 10 , 10 , 10 , 10 , 9 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxTotalRectangle ( a , n ) ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def insert ( head , data ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT last = head NEW_LINE head = head NEW_LINE head = head NEW_LINE head = head NEW_LINE return head NEW_LINE DEDENT def insertEnd ( head , data ) : NEW_LINE INDENT last = head NEW_LINE last = head NEW_LINE head = head NEW_LINE last = head NEW_LINE head = head NEW_LINE return head NEW_LINE DEDENT def reverse ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT last = head NEW_LINE last = head NEW_LINE last = head NEW_LINE last = head NEW_LINE return head NEW_LINE DEDENT def reverse ( head ) : NEW_LINE INDENT last = head NEW_LINE last = head NEW_LINE last = head NEW_LINE last = head NEW_LINE last = head NEW_LINE last = head NEW_LINE while ( cur != last ) : NEW_LINE INDENT prev = cur NEW_LINE last = last NEW_LINE last = last NEW_LINE last = last NEW_LINE cur = last NEW_LINE last = last NEW_LINE DEDENT last = head NEW_LINE return head NEW_LINE DEDENT def reverse ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT last = head NEW_LINE last = head NEW_LINE last = last NEW_LINE while ( cur != last ) : NEW_LINE INDENT cur = curr . next NEW_LINE last = curr . next NEW_LINE last = last NEW_LINE last = last NEW_LINE last = last NEW_LINE last = last NEW_LINE DEDENT DEDENT def reverse ( head ) : NEW_LINE INDENT temp = head NEW_LINE last = head NEW_LINE while ( temp != head ) : NEW_LINE INDENT temp = curr . next NEW_LINE temp = temp NEW_LINE last = temp NEW_LINE last = temp NEW_LINE
def lastFiveDigits ( n ) : NEW_LINE INDENT n = ( ( n // 10000 + ( n % 10 ) * 1000 + ( n % 10 ) * 100 ) ( n % 10 ) * 100 + ( n // 10 ) * 100 ) % 10 NEW_LINE ans = 1 NEW_LINE for i in range ( 0 , 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT n = 12345 NEW_LINE lastFiveDigits ( n ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( i ** ( 10 ** 9 ) for i in range ( 1 , 10 ** 9 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def sqrt ( x ) : NEW_LINE INDENT y = int ( math . sqrt ( x ) ) NEW_LINE return str ( y ) NEW_LINE DEDENT def sqrt ( x ) : NEW_LINE INDENT y = int ( math . sqrt ( x ) ) NEW_LINE return int ( sqrt ( x ) ) NEW_LINE DEDENT def sqrt ( x ) : NEW_LINE INDENT return sqrt ( x ) NEW_LINE DEDENT def sqrt ( x ) : NEW_LINE INDENT return int ( sqrt ( x ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def evaluate ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( " No ▁ Part ▁ Exg " ) NEW_LINE DEDENT else : NEW_LINE INDENT v = 1 * n // 4 NEW_LINE print ( v , " ▁ Exg " , end = " ▁ " ) NEW_LINE print ( v + 1 , end = " ▁ " ) NEW_LINE print ( v + 1 , end = " ▁ " ) NEW_LINE print ( v + 1 , end = " ▁ " ) NEW_LINE print ( v + 1 , end = " ▁ " ) NEW_LINE print ( v + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 22 NEW_LINE evaluate ( n ) NEW_LINE DEDENT
a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE print ( b // x + 1 ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findNumber ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == ans ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findNumber ( arr , n ) ) NEW_LINE
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rem = A [ i ] % K NEW_LINE if ( rem != 0 ) : NEW_LINE INDENT ans += freq [ K - rem ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += freq [ 0 ] NEW_LINE DEDENT freq [ 0 ] += 1 NEW_LINE freq [ 0 ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT A = [ 2 , 2 , 1 , 7 , 5 ] NEW_LINE n = len ( A ) NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE
a , b , c = map ( int , input ( ) . split ( " , " ) ) NEW_LINE print ( a , b , c ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] != A [ i ] : NEW_LINE INDENT ans = max ( ans , N - i - 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 ; NEW_LINE hash_valid = [ 0 ] * ( n + 1 ) ; NEW_LINE hash_valid [ 0 ] = 1 ; NEW_LINE hash_valid [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT difference += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT difference += hash [ - 1 ] ; NEW_LINE hash_valid [ - 1 ] += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 8 , 1 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( " Total ▁ Number ▁ of ▁ Even ▁ Odd ▁ Odd ▁ - Even " , countSubarrays ( arr , n ) ) ; NEW_LINE
SIZE = 26 NEW_LINE def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT
def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] ) % 2 == 1 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " ; NEW_LINE n = len ( str ) ; NEW_LINE printChar ( str , n ) ; NEW_LINE DEDENT
def countGreater ( arr , n , k ) : NEW_LINE INDENT l = 0 ; r = n - 1 ; NEW_LINE leftGreater = n - 1 ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) // 2 ; NEW_LINE if ( arr [ m ] > k ) : NEW_LINE INDENT leftGreater = m ; NEW_LINE r = m - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 ; NEW_LINE r = m + 1 ; NEW_LINE DEDENT DEDENT return ( n - leftGreater ) ; NEW_LINE DEDENT arr = [ 3 , 3 , 4 , 7 , 7 , 7 , 13 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 7 ; NEW_LINE print ( countGreater ( arr , n , k ) ) ; NEW_LINE
H , W = map ( int , input ( ) . split ( ) ) NEW_LINE if W == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp = [ [ 0 for i in range ( H ) ] for j in range ( W ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , H ) : NEW_LINE INDENT for j in range ( 1 , W ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , H ) : NEW_LINE INDENT for j in range ( 1 , W ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT print ( ( dp [ H - 1 ] [ W - 1 ] ) % 1000000007 ) NEW_LINE DEDENT
import math NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( " NO " , " b " ) NEW_LINE return NEW_LINE DEDENT a = ( N + math . sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - math . sqrt ( val ) ) / 2.0 NEW_LINE print ( " a ▁ = ▁ " , b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 70.0 ( ) NEW_LINE findAandB ( N ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE max_x = x NEW_LINE min_x = y NEW_LINE min_x = y NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x > y : NEW_LINE INDENT min_x = x NEW_LINE DEDENT if y > min_x : NEW_LINE INDENT min_x = y NEW_LINE DEDENT DEDENT if min_x < x : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] == ' X ' : NEW_LINE INDENT a . append ( a [ i ] ) NEW_LINE DEDENT DEDENT if len ( a ) == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
MOD = 10 ** 9 + 7 NEW_LINE def main ( ) : NEW_LINE INDENT MOD = 10 ** 9 + 7 NEW_LINE S = input ( ) NEW_LINE N = len ( S ) NEW_LINE dp = [ [ 0 ] * ( N + 1 ) for _ in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if S [ i ] == S [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if S [ i ] == S [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N ] [ N ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE c += 1 NEW_LINE n //= 2 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c ) NEW_LINE DEDENT DEDENT
def minIncrementForUnique ( A ) : NEW_LINE INDENT mpp = dict ( ) NEW_LINE for i in A : NEW_LINE INDENT mpp [ i ] += 1 NEW_LINE DEDENT return mpp NEW_LINE DEDENT def minIncrementForUnique ( A ) : NEW_LINE INDENT mpp = dict ( ) NEW_LINE ans = 0 NEW_LINE for x in mpp : NEW_LINE INDENT if ( mpp [ x ] >= 2 ) : NEW_LINE INDENT mpp [ x * ( mpp [ x ] - 1 ) ] = 1 NEW_LINE DEDENT elif ( len ( mpp ) > 0 and ( len ( mpp ) == 0 ) ) : NEW_LINE INDENT ans += x - me [ - 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT A = [ 3 , 2 , 1 , 2 , 7 , 7 ] NEW_LINE print ( minIncrementForUnique ( A ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n % 2 == 1 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT
MOD = 10 ** 9 + 7 NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( 13 ) ] for y in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT n = ord ( s [ i ] ) - ord ( ' ? ' ) NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT n = j NEW_LINE DEDENT for k in range ( 0 , 10 ) : NEW_LINE INDENT n = ( ( 10 * k + n ) % MOD ) % MOD NEW_LINE dp [ i + 1 ] [ k ] % MOD NEW_LINE dp [ i + 1 ] [ k ] %= MOD NEW_LINE dp [ i + 1 ] [ k ] %= MOD NEW_LINE dp [ i + 1 ] [ k ] %= MOD NEW_LINE DEDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return dp [ n ] [ 5 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "444" NEW_LINE n = len ( s ) NEW_LINE print ( modulo_13 ( s , n ) ) NEW_LINE DEDENT
def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b / c NEW_LINE y = b / d NEW_LINE k = ( c * d ) / d NEW_LINE k = ( c * k ) / k NEW_LINE return b - a + 1 - ( a - 1 ) / k NEW_LINE DEDENT def countNums ( a , b , c , d ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a - 1 - ( a * d ) / k NEW_LINE DEDENT return b - a + 1 - ( a * d ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c , d = 10 , 50 , 6 NEW_LINE print ( countNums ( a , b , c , d ) ) NEW_LINE DEDENT
import math NEW_LINE def printSubstrings ( n ) : NEW_LINE INDENT s = math . log10 ( n , s ) + 0.5 NEW_LINE d = int ( math . log10 ( n , s ) + 0.5 ) NEW_LINE k = d NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( n // d ) NEW_LINE d = int ( d / 10 ) NEW_LINE d = int ( d / 10 ) NEW_LINE DEDENT n = n % k NEW_LINE k = k // 10 NEW_LINE DEDENT n = 123 NEW_LINE printSubstrings ( n ) NEW_LINE
def NthCharacter ( n ) : NEW_LINE INDENT s = " " NEW_LINE c = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( c < 10 ) : NEW_LINE INDENT s += str ( c ) NEW_LINE c = c NEW_LINE while ( d > 0 ) : NEW_LINE INDENT s += str ( d % 10 ) NEW_LINE c //= 10 NEW_LINE DEDENT DEDENT s += str ( s ) NEW_LINE s += " " NEW_LINE DEDENT return s [ n - 1 ] NEW_LINE DEDENT n = 11 NEW_LINE print ( NthCharacter ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m , d = map ( int , input ( ) . split ( ) ) NEW_LINE t -= 1 NEW_LINE if ( n % 3 == 0 ) : NEW_LINE INDENT t -= 1 NEW_LINE DEDENT print ( t ) NEW_LINE DEDENT
def check_prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n , 1 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countPrimeFrequent ( s ) : NEW_LINE INDENT count = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( check_prime ( s [ i ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( check_prime ( s [ i ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( countPrimeFrequent ( s ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = n - 1 NEW_LINE j = m - 1 NEW_LINE k = 0 NEW_LINE while i < n - 1 and j < m : NEW_LINE INDENT if b [ i ] > a [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT print ( k + i ) NEW_LINE
def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 0 ] * ( n + 2 ) NEW_LINE catalan [ 0 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += catalan [ j - 1 ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalanDP ( i ) , end = " ▁ " ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 1.0 NEW_LINE def factorial ( n ) : NEW_LINE INDENT tot -= 1 NEW_LINE den = 1.0 NEW_LINE den = ( ( tot * ( N - 1 ) ) // den ) NEW_LINE if ( tot < TARGET ) : NEW_LINE INDENT return str ( sum ( ( den * den ) - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE x , y = 0 , 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' U ' : x += 1 NEW_LINE elif c == ' R ' : y += 1 NEW_LINE elif c == ' D ' : x += 1 NEW_LINE elif c == ' D ' : y += 1 NEW_LINE else : x -= 1 NEW_LINE DEDENT if x == 0 : print ( ' OK ' ) NEW_LINE else : print ( ' NG ' ) NEW_LINE
from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPossible ( n ) : NEW_LINE INDENT if ( isPrime ( n ) and isPrime ( n - 2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 13 NEW_LINE if ( isPossible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countDictPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res // ( n + 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Number ▁ of ▁ Dyk ▁ is ▁ " , countDictPaths ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n <= 30 or n <= 30 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE g = min ( a ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT g = g % g NEW_LINE if g : NEW_LINE INDENT g = g NEW_LINE DEDENT DEDENT print ( g ) NEW_LINE
n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = n - ( i + 1 ) // 4 NEW_LINE if c % 2 == 0 : NEW_LINE INDENT ans = max ( ans , c ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT a = 6 NEW_LINE print ( pentdiagonal ( a ) ) NEW_LINE
def hexDiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.73 * a NEW_LINE return d NEW_LINE DEDENT a = 9 NEW_LINE print ( hexDiagonal ( a ) ) NEW_LINE
def translate ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( j < l - 1 ) : NEW_LINE INDENT if ( str [ j ] == ' A ' and str [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j = j + 2 NEW_LINE continue NEW_LINE DEDENT str [ i ] = str [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( j == len - 1 ) - 1 ) : NEW_LINE INDENT str [ i ] = str [ j ] NEW_LINE str [ i + 1 ] = str [ j ] NEW_LINE DEDENT str [ i ] = ' ▁ ' . join ( str ) NEW_LINE str [ i + 1 ] = ' ▁ ' . join ( str ) NEW_LINE str [ i + 1 ] = ' ▁ ' . join ( str ) NEW_LINE str [ i + 1 ] = ' ▁ ' . join ( str ) NEW_LINE str [ i + 1 ] = ' ▁ ' . join ( str ) NEW_LINE str [ i + 1 ] = ' ▁ ' . join ( str ) NEW_LINE str [ i + 1 ] = ' ▁ ' . join ( str ) NEW_LINE str [ i + 1 ] = ' ▁ ' . join ( str ) NEW_LINE str [ i + 1 ] = ' ▁ ' . join ( str ) NEW_LINE str [ i + 1 ] = ' ▁ ' . join ( str ) NEW_LINE str [ i + 1 ] = ' ▁ ' . join ( str ) NEW_LINE str [ i + 1 ] = ' ▁ ' . join ( str ) NEW_LINE print ( " The ▁ string ▁ is ▁ " ) NEW_LINE DEDENT str = " hircGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
def delete ( string ) : NEW_LINE INDENT for i in range ( 1 , len ( string ) ) : NEW_LINE INDENT if ( string [ i - 1 ] == ' A ' and string [ i ] == ' B ' ) : NEW_LINE INDENT string [ i ] = ' C ' NEW_LINE for j in range ( i , len ( string ) - 1 ) : NEW_LINE INDENT string [ j ] = string [ j + 1 ] NEW_LINE DEDENT string [ j ] = string [ j + 1 ] NEW_LINE DEDENT DEDENT return string NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " hircABABGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 2000 NEW_LINE count = 2 NEW_LINE ans = str ( eulerlib . is_prime ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt + 1 ) ) ) ) ) ) ) ) NEW_LINE if ( ans == TARGET ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT if ( ans == TARGET ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT if ( ans == TARGET ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT if ( ans == TARGET ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT if ( ans == TARGET ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT if ( ans == TARGET ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT if ( ans == TARGET ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT if ( ans == TARGET ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT if ( ans == TARGET ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT if ( ans == TARGET ) : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT for j in range ( b ) : NEW_LINE INDENT if i * j + j * i == b : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE
def Digits ( n ) : NEW_LINE INDENT largest = 0 NEW_LINE smallest = 9 NEW_LINE while n != 0 : NEW_LINE INDENT r = n % 10 NEW_LINE largest = max ( r , smallest ) NEW_LINE n = n // 10 NEW_LINE DEDENT print ( largest , " Digit " ) NEW_LINE DEDENT n = 46 NEW_LINE Digits ( n ) NEW_LINE
def solve ( d1 , d2 ) : NEW_LINE INDENT maxx = max ( d1 , d2 ) NEW_LINE sum = ( d1 + d2 ) / 2 NEW_LINE if ( 2 * maxx > sum or sum % 2 == 1 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT x1 = d1 + d2 NEW_LINE x3 = ( d1 + d2 - d1 ) / 2 NEW_LINE y3 = ( d2 + d3 - d3 ) / 2 NEW_LINE print ( " ( " , x1 , " , " , x2 , " , " , y3 , " , " , x3 , " , " , y3 , " , " , y3 , " , ▁ ( " , x3 , " , " ) " , ( x3 , " , " , y3 ) " ) " ) NEW_LINE DEDENT d1 = 3 NEW_LINE d2 = 0 NEW_LINE d3 = d1 + d2 NEW_LINE d3 = ( d1 + d2 ) / 2 NEW_LINE solve ( d1 , d2 , d3 ) NEW_LINE
MAX_CHAR = 26 NEW_LINE def performBases ( k , n , str ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 6 NEW_LINE k = 3 NEW_LINE if ( performBases ( k , n , str ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = s . count ( " M " ) NEW_LINE if ( a . count ( " M " ) / 2 ) == a . count ( " M " ) or ( a . count ( " M " ) / 2 ) == a . count ( " M " ) or ( a . count ( " M " ) / 2 ) == a . count ( " M " ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
a , b , c , d = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( [ ' no ' , ' yes ' ] [ a == b and c == d ] [ a == c and d == c + d ] [ a == c + d ] [ a == c + d ] [ a == c + d ] [ b == c + d ] [ a == c + d ] [ a + d ] ) NEW_LINE
R = 4 NEW_LINE C = 4 NEW_LINE def first ( arr , low , high ) : NEW_LINE INDENT if ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == 0 or arr [ mid - 1 ] == 0 ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return first ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def rowWithRows ( mat , low , min_index ) : NEW_LINE INDENT max_Zeroes = 0 NEW_LINE min_Zeroes = - sys . maxsize NEW_LINE for i in range ( R ) : NEW_LINE INDENT index = first ( mat [ i ] , ( 0 , ( C - 1 ) ) ) NEW_LINE cntZeroes = index ( mat [ i ] , ( C - 1 ) ) NEW_LINE if ( index == - 1 ) : NEW_LINE INDENT minZeroes = CntZeroes NEW_LINE max_Zeroes = index NEW_LINE DEDENT if ( max_Zeroes ) : NEW_LINE INDENT min_Zeroes = C NEW_LINE min_Zeroes = index NEW_LINE DEDENT if ( max_Zeroes ) : NEW_LINE INDENT min_Zeroes = C NEW_LINE min_Zeroes = i NEW_LINE DEDENT if ( max_Zeroes ) : NEW_LINE INDENT min_Zeroes = i NEW_LINE min_Zeroes = i NEW_LINE DEDENT if ( max_Zeroes ) : NEW_LINE INDENT min_Zeroes = C NEW_LINE min_Zeroes = i NEW_LINE DEDENT DEDENT print ( " Row ▁ with ▁ 0 ▁ : " , max_Zeroes ) NEW_LINE print ( " Row ▁ 0" , max_Zeroes : " , max_Zeroes : " , max_Zeroes : " , max_Zeroes ) NEW_LINE print ( " Row ▁ 0" , max_Zeroes : " , max_Zeroes ) NEW_LINE
def bitAtGivenSetSetSet ( n , k ) : NEW_LINE INDENT new_num = n >> ( k - 1 ) NEW_LINE return ( new_num & 1 ) NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( bitAtGivenSetSet ( n , k ) == 1 ) : NEW_LINE INDENT print ( " Set " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Unset " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE g = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT g += 1 NEW_LINE DEDENT elif ( s [ i ] == ' C ' ) : NEW_LINE INDENT g += 1 NEW_LINE DEDENT DEDENT print ( g ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = list ( input ( ) ) NEW_LINE b = list ( input ( ) ) NEW_LINE c = list ( input ( ) ) NEW_LINE d = [ 0 ] * 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 9 ) : NEW_LINE INDENT if i % 3 == j // 3 : NEW_LINE INDENT d [ i ] = d [ j ] + d [ i - 1 ] + d [ j - 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = d [ j - 3 ] + d [ i - 3 ] + d [ j - 3 ] + d [ i - 3 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , 9 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if i % 3 == j // 4 : NEW_LINE INDENT d [ i ] = d [ i - 3 ] + d [ i - 3 ] + d [ i - 3 ] + d [ i - 3 ] + d [ i - 3 ] + d [ i - 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT d [ i - 3 ] = d [ i - 1 ] + d [ i - 3 ] + d [ i - 3 ] + d [ i - 3 ] + d [ i - 3 ] + d [ i - 3 ] + d [ i - 3 ] + d [ i - 3 ] NEW_LINE DEDENT DEDENT DEDENT print ( " % .8f " % ( d [ 0 ] ) ) NEW_LINE DEDENT
l , r = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT if i * i <= l : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ans * 2 <= k : NEW_LINE INDENT ans *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans *= 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def arePermutations ( a , b , n , m ) : NEW_LINE INDENT sum1 = 0 ; sum2 = 0 ; NEW_LINE mul2 = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 += a [ i ] ; NEW_LINE mul2 *= a [ i ] ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT sum2 += b [ i ] ; NEW_LINE mul2 *= b [ i ] ; NEW_LINE DEDENT return ( ( sum1 == sum2 ) and ( mul2 == mul2 ) ) ; NEW_LINE DEDENT a = [ 1 , 3 , 2 ] ; NEW_LINE b = [ 3 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( arePermutations ( a , b , n , m ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def findAndPrintChars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 0 , len ( str1 ) ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 0 , len ( present ) ) : NEW_LINE INDENT if ( present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 or present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 2 NEW_LINE DEDENT DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( present [ i ] == 1 or present [ i ] == 2 ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string1 = " carrays " NEW_LINE findAndPrintUncommonChars ( string1 , string2 ) NEW_LINE DEDENT
def isIn ( circle_x , circle_y , r , x , y ) : NEW_LINE INDENT if ( ( x - circle_x ) * ( x - circle_y ) + ( y - circle_y ) * r ) <= 360 * r * rad * rad * rad ; NEW_LINE return False ; NEW_LINE DEDENT x = 1 ; NEW_LINE y = 1 ; NEW_LINE circle_x = 1 ; NEW_LINE circle_y = 1 ; NEW_LINE circle_x = 1 ; NEW_LINE if ( isIn ( circle_x , circle_y , circle_y , x , y ) ) : NEW_LINE INDENT print ( " Over " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Infinite " ) ; NEW_LINE DEDENT
def minSum ( arr , n , x ) : NEW_LINE INDENT sum = 0 NEW_LINE largestDivisible = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < minimumDivisible ) : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT if ( largestDivisible == minimumDivisible ) : NEW_LINE INDENT return sum NEW_LINE DEDENT sumAfterOperation = sum - minimumDivisible + ( largestDivisible // x ) + ( largestDivisible // x ) NEW_LINE return min ( sumAfterOperation ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( minSum ( arr , n , x ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT nth = 2 * ( ( n * n ) - n ) NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( 2 * n * n ) - n NEW_LINE DEDENT return nth NEW_LINE DEDENT n = 5 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 25 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 250000007 NEW_LINE n = 1000000007 NEW_LINE n = 25 NEW_LINE n = 25 NEW_LINE n = 25 NEW_LINE n = 1000000007 NEW_LINE n = 1000000007 NEW_LINE n = 1000000007 NEW_LINE n = 1000000007 NEW_LINE n = 1000000007 NEW_LINE n = 1000000007 NEW_LINE n = 1000000007 NEW_LINE n = 1000000007
from collections import deque NEW_LINE import sys NEW_LINE input = sys . stdin . readline NEW_LINE Q = int ( input ( ) ) NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT command , * command = input ( ) . split ( ) NEW_LINE if command == "0" : NEW_LINE INDENT if command == "0" : NEW_LINE INDENT if command == "0" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "1" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_LINE DEDENT elif command == "2" : NEW_LINE INDENT Q = int ( command ) NEW_
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i : i ] == s [ : : - 1 ] : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT a . append ( a ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if a [ i : i ] == s [ i : k ] : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT print ( a [ : k ] ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printInorder ( node ) : NEW_LINE INDENT if node == None : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( node . left ) NEW_LINE printInorder ( node . right ) NEW_LINE printInorder ( node . left , node . right ) NEW_LINE DEDENT def printInorder ( nodeIndex , pIndex , limit ) : NEW_LINE INDENT if ( nodeIndex == s ) : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( nodeIndex , pIndex , limit ) NEW_LINE printInorder ( pIndex , pIndex , limit ) NEW_LINE DEDENT def cInorder ( pIndex , pIndex , cIndex ) : NEW_LINE INDENT if ( pIndex == s ) : NEW_LINE INDENT return NEW_LINE DEDENT return NEW_LINE DEDENT def cInorder ( pIndex , pIndex , cIndex ) : NEW_LINE INDENT if ( pIndex == c ) : NEW_LINE INDENT return NEW_LINE DEDENT res = cInorder ( pIndex , pIndex , cIndex ) NEW_LINE if ( l == h ) : NEW_LINE INDENT return NEW_LINE DEDENT res = cInorder ( pIndex , pIndex , cIndex - 1 , cIndex - 1 , sIndex - 1 , cIndex - 1 , sIndex - 1 , cIndex - 1 , sIndex - 1 ) NEW_LINE if ( res == cInorder ( pIndex ) ) : NEW_LINE INDENT return NEW_LINE DEDENT res = cInorder ( pIndex , pIndex + 1 , cIndex - 1 , sIndex - 1 , cIndex - 1 , sIndex - 1 , sIndex - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def cInorder ( pIndex , pIndex , pIndex , pIndex ) : NEW_LINE INDENT if ( pIndex == pIndex ) : NEW_LINE INDENT return cInorder ( pIndex , pIndex , pIndex - 1 , pIndex - 1 , pIndex -
from collections import defaultdict NEW_LINE no_of_CHARS = 256 NEW_LINE def findSubstring ( str , pat_of_CHARS ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( str ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( " No ▁ such ▁ such ▁ such ▁ such ▁ such ▁ such ▁ such ▁ exist " ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , len1 ) : NEW_LINE INDENT if ( len1 [ i ] < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( len1 [ i ] < 0 ) : NEW_LINE INDENT if ( len1 [ i ] < len1 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ( len1 [ i ] < len1 [ i ] ) and ( len1 [ i ] < 0 ) ) : NEW_LINE INDENT if ( len1 [ i ] < len1 [ i ] ) : NEW_LINE INDENT len1 [ i ] = len1 [ i ] NEW_LINE DEDENT DEDENT DEDENT if ( len1 [ i ] < len1 [ i ] ) : NEW_LINE INDENT if ( len1 [ i ] < len1 [ i ] ) : NEW_LINE INDENT len1 [ i ] = len1 [ i ] NEW_LINE DEDENT DEDENT DEDENT if ( len1 [ 0 ] > len2 [ 1 ] ) : NEW_LINE INDENT return " No ▁ such ▁ such ▁ such ▁ such ▁ such ▁ such ▁ exist " NEW_LINE DEDENT if ( len1 [ 0 ] ) > len2 [ 1 ] ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT if ( len1 [ 0 ] ) > len2 [ 1 ] : NEW_LINE INDENT return " No ▁ such ▁ such ▁ such ▁ such ▁ " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = 256 NEW_LINE print ( findSubstring ( str1 , str2 ) ) NEW_LINE DEDENT
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT a , b , c , d = map ( int , line . split ( ) ) NEW_LINE if ( ( a - c ) * ( b - a ) * ( a - b ) * ( a - c ) * ( b - c ) * ( a - c ) * ( b - c ) ) > 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) . split ( ) ) NEW_LINE DEDENT if ( len ( a ) > m ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
MAX = 100005 NEW_LINE def addPrimes ( n ) : NEW_LINE INDENT n = 3 NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE v = addPrimes ( n ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 NEW_LINE a = a // 10 NEW_LINE if ( flag == 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = sum + v [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_prime ( n ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE s = sum ( a ) NEW_LINE s += b NEW_LINE c += d NEW_LINE print ( s + a - b ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 15 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] <= l [ i ] : NEW_LINE INDENT ans = min ( ans , ( l [ i ] + 15 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , ( l [ i ] - 15 ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import math as mt NEW_LINE def memo ( index , evenSum , oddSum , oddSum , oddSum , oddSum , tightSum , tightSum , tightSum , tightSum , tightSum ) : NEW_LINE INDENT if ( indexSum > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def memo ( index , evenSum , oddSum , oddSum , oddSum , oddSum , tightSum , tightSum , tightSum , tightSum , tightSum , tightSum , tightSum , tightSum ) : NEW_LINE INDENT if ( ( evenSum > 0 ) ) : NEW_LINE INDENT return dp [ indexSum ] [ tightSum ] [ tightSum ] NEW_LINE DEDENT if ( tightSum > 0 ) : NEW_LINE INDENT return dp [ indexSum ] [ tightSum ] [ tightSum ] NEW_LINE DEDENT limit = int ( math . sqrt ( indexSum ) ) NEW_LINE ans = 0 NEW_LINE for d in range ( limit ) : NEW_LINE INDENT currT = n // 10 NEW_LINE if ( d == vSum ) : NEW_LINE INDENT currTt = tightSum NEW_LINE DEDENT else : NEW_LINE INDENT ans += memo ( index + 1 , evenSum + dSum - 1 , evenSum + dSum - 1 , evenSum - 1 , evenSum ) NEW_LINE DEDENT DEDENT dp [ index ] [ tightSum ] [ tightSum ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 2 NEW_LINE R = 10 NEW_LINE print ( CountNum ( R ) - Count ( L - 1 , 0 , 0 , 1 ) ) NEW_LINE DEDENT
def check ( x , y , z ) : NEW_LINE INDENT if x == y : return False NEW_LINE if x == z : return True NEW_LINE if x == z : return True NEW_LINE if y == z : return False NEW_LINE if x == z : return True NEW_LINE if x == z : return False NEW_LINE if check ( x , y , z ) : return True NEW_LINE if check ( x , y , z ) : return False NEW_LINE if check ( y , z , z ) : return True NEW_LINE if check ( x , y , z , z ) : return True NEW_LINE if check ( x , y , z , z ) : return False NEW_LINE if check ( x , y , z , z ) : return True NEW_LINE if check ( y , z , z , z ) : return False NEW_LINE if check ( x , y , z , z ) : return True NEW_LINE if check ( x , y , z , z , z ) : return True NEW_LINE if check ( z , z , z , z , z ) : return False NEW_LINE if check ( z , z , z , z , z ) : return True NEW_LINE if check ( z , z , z , z , z , z ) : return True NEW_LINE if check ( z , z , z , z , z ) : return True NEW_LINE if check ( z , z , z , z , z , z ) : return True NEW_LINE if check ( z , z , z , z , z , z , z ) : return True NEW_LINE if check ( z , z , z , z ) : return False NEW_LINE if check ( z , z , z , z , z ) : return True NEW_LINE if check ( z , z , z , z , z ) : return True NEW_LINE if check ( z , z , z , z , z , z ) : return True NEW_LINE if check ( z , z , z , z , z , z ) : return True NEW_LINE if check ( z , z , z , z ) : return True NEW_LINE if check ( z , z , z , z , z ) : return True NEW_LINE print ( ' Yes ' ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] > b [ i - 1 ] : NEW_LINE INDENT b [ i ] = b [ i - 1 ] + a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = b [ i - 1 ] + a [ i - 1 ] NEW_LINE DEDENT DEDENT if b [ - 1 ] == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * b ) NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT compute ( ) NEW_LINE DEDENT
def search ( arr , x ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 ] NEW_LINE x = 10 NEW_LINE result = search ( arr , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ index " , result ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ is ▁ present ▁ index " , result ) NEW_LINE DEDENT
n , c = map ( int , input ( ) . split ( ) ) NEW_LINE p = [ 0 ] * n NEW_LINE p [ 0 ] = p [ 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE p [ i ] = b NEW_LINE p [ i ] = a NEW_LINE DEDENT t = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT t += p [ i + 1 ] NEW_LINE t += p [ i ] NEW_LINE t += p [ i + 1 ] NEW_LINE DEDENT print ( max ( t ) ) NEW_LINE
def toggleBitsFromL ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( ( 1 << ( l - 1 ) ) - 1 ) - 1 ) NEW_LINE return ( n & num ) NEW_LINE DEDENT def unsetBitsInL ( n , l , r ) : NEW_LINE INDENT num = ( 1 << ( 4 << ( l - 1 ) ) ) - 1 NEW_LINE num = toggleBitsFromL ( num , l , r ) NEW_LINE return ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE print ( unsetBitsInL ( n , l , r ) ) NEW_LINE
def MinStep ( a , n ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT elif ( a [ i ] < 0 ) : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT else : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT DEDENT if ( negative % 2 == 0 ) : NEW_LINE INDENT negative = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT if ( negative > 0 ) : NEW_LINE INDENT negative = step + zero NEW_LINE DEDENT DEDENT if ( negative % 2 == 0 ) : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT DEDENT return step NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 0 , - 2 , - 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( MinStep ( a , n ) ) NEW_LINE DEDENT
n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( s [ 0 ] == s [ - 1 ] ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( s [ - 1 ] ) - int ( s [ - 1 ] ) ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE print ( a [ - 1 ] + a [ - 2 ] ) NEW_LINE DEDENT
from math import gcd NEW_LINE def noOfSquares ( x1 , y1 , x2 ) : NEW_LINE INDENT dx = abs ( x2 - x1 ) NEW_LINE dy = abs ( y2 - x1 ) NEW_LINE ans = ( dx + dy - y1 ) NEW_LINE print ( ans ) NEW_LINE DEDENT x1 = 1 NEW_LINE y1 = 1 NEW_LINE x2 = 4 NEW_LINE y2 = 3 NEW_LINE noOfSquares ( x1 , y2 , x2 , y2 ) NEW_LINE
def get_maximum ( s , a ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] - ord ( '0' ) < a [ ord ( '0' ) - ord ( '0' ) ] ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n and ( ord ( s [ j ] ) - ord ( '0' ) ) <= a [ ord ( s [ j ] ) - ord ( '0' ) ) : NEW_LINE INDENT s [ j ] = chr ( ord ( '0' ) + a [ ord ( s [ j ] ) - ord ( '0' ) ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "13" NEW_LINE a = [ 0 , 1 , 2 , 5 , 6 , 6 , 6 , 6 , 6 , 6 , 6 ] NEW_LINE print ( get_maximum ( s , a ) ) NEW_LINE DEDENT
MAX_DIGITS = 20 NEW_LINE def isOctal ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n % 10 >= 8 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 10 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divide = 8 NEW_LINE octal = [ 0 for i in range ( MAX_DIGITS ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT octal [ i ] = n % divide [ i ] NEW_LINE n = n // divide [ i ] NEW_LINE DEDENT for j in range ( i - 1 , j + 1 ) : NEW_LINE INDENT if ( octal [ j ] != octal [ k ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT for j in range ( i - 1 , j + 1 ) : NEW_LINE INDENT if ( octal [ j ] != octal [ k ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 97 NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != '4' : NEW_LINE INDENT a += int ( s [ i ] ) NEW_LINE DEDENT elif s [ i ] == '7' : NEW_LINE INDENT b += int ( s [ i ] ) NEW_LINE DEDENT DEDENT if a == 0 or b == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def binarySearch ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT midValue = int ( ( low + high ) / 2 ) NEW_LINE if ( midValue == arr [ mid ] ) : NEW_LINE INDENT return midValue NEW_LINE DEDENT leftIndex = ( mid - 1 ) // 2 NEW_LINE rightIndex = ( mid - 1 ) // 2 NEW_LINE if ( leftIndex >= 0 ) : NEW_LINE INDENT return leftIndex NEW_LINE DEDENT rightIndex = ( midIndex + 1 , midIndex ) NEW_LINE rightIndex = binarySearch ( arr , leftIndex , midIndex ) NEW_LINE rightIndex = binarySearch ( arr , rightIndex , midIndex ) NEW_LINE return rightIndex NEW_LINE DEDENT arr1 = [ - 10 , - 5 , 3 , 2 , 1 , 10 , 10 , 10 , 10 ] NEW_LINE print ( " Infinite ▁ Point ▁ is ▁ is ▁ is " , binarySearch ( arr1 , 0 , arr1 , arr1 , arr2 ) ) NEW_LINE print ( " Infinite ▁ is ▁ is ▁ is " , binarySearch ( arr1 , 0 , arr1 , rightIndex ) ) NEW_LINE
MAX = 10000 ; NEW_LINE prodDigitProduct = [ 0 ] * ( MAX ) ; NEW_LINE def getDigitProductProduct ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT prod = ( x % 10 ) * getDigitProduct [ x ] ; NEW_LINE return ( prodDigitProduct [ x // 10 ] ) * prod ; NEW_LINE DEDENT def findSieve ( n ) : NEW_LINE INDENT res = [ ] ; NEW_LINE for i in range ( 1 , n // 2 ) : NEW_LINE INDENT if ( i * prod [ i ] == n ) : NEW_LINE INDENT res . append ( i ) ; NEW_LINE DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( " NO ▁ exist ▁ " ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( 0 , n // 2 ) : NEW_LINE INDENT if ( i * prod [ i ] == n ) : NEW_LINE INDENT res [ i ] = i ; NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 16 ; NEW_LINE findSieve ( n ) ; NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 + 7 NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT X [ i ] = X [ i + K - 1 ] NEW_LINE DEDENT ans = 10 ** 9 + 7 NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT X [ i ] = X [ i + K - 1 ] NEW_LINE DEDENT print ( ans ) NEW_LINE
def diff ( n , mid ) : NEW_LINE INDENT if ( n > ( mid * mid * mid * mid ) ) : NEW_LINE INDENT return ( n - ( mid * mid * mid ) ) - n NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( mid * mid ) - n ) NEW_LINE DEDENT DEDENT def complexRoot ( n ) : NEW_LINE INDENT start = 0 NEW_LINE e = n NEW_LINE e = n NEW_LINE while ( True ) : NEW_LINE INDENT mid = ( start + e ) // 2 NEW_LINE if ( ( int ( e * mid * mid * mid ) ) > e ) : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT if ( int ( e ) ) : NEW_LINE INDENT end = diff ( n , mid * mid ) NEW_LINE if ( int ( int ) * mid ) > n ) : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT print ( " Cum ▁ root ▁ of ▁ " , int ( n ) , " is ▁ of ▁ " , int ( " , " is " , int ( n ) ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT b [ i ] = b [ i ] NEW_LINE DEDENT DEDENT m = max ( b ) NEW_LINE b . sort ( ) NEW_LINE print ( m , b [ m - 1 ] ) NEW_LINE
def inv ( a , m ) : NEW_LINE INDENT m0 = m ; NEW_LINE x = 0 ; NEW_LINE while ( a > 1 ) : NEW_LINE INDENT q = a // m ; NEW_LINE m = m ; NEW_LINE t = t ; NEW_LINE a = t ; NEW_LINE t = t ; NEW_LINE x = t ; NEW_LINE t = x ; NEW_LINE x = t ; NEW_LINE DEDENT if ( x < 0 ) : NEW_LINE INDENT x = x ; NEW_LINE m = x ; NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT p = prod / num [ i ] ; NEW_LINE result += rem ( rem / num [ i ] ) * inv ( p , x ) * inv ( p , p ) * inv [ i ] * inv ( p , x ) ) ; NEW_LINE DEDENT DEDENT return result % x ; NEW_LINE DEDENT num = [ 3 , 4 , 1 ] ; NEW_LINE rem = [ 2 , 3 , 1 ] ; NEW_LINE k = len ( num ) ; NEW_LINE print ( " x ▁ is " , find ( num , rem ) ) ; NEW_LINE
def compare ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT DEDENT maxOR = arr [ 0 ] NEW_LINE countOR = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( maxOR | arr [ i ] ) > maxOR ) : NEW_LINE INDENT maxOR = maxOR | arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxOR ( arr , n ) ) NEW_LINE
def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) // 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE
def alquotSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 12 NEW_LINE print ( alquotSum ( n ) ) NEW_LINE
def pentagon_pyramid ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) / 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramid_pyramid ( n ) ) ) NEW_LINE
def fifthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i * i * i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( fifthPowerSum ( n ) ) NEW_LINE
def squaresum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE
def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) // 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE
def sumSumSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( sumSumSeries ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def fourthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE
def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT print ( squareSum ( 8 ) ) NEW_LINE
def AvgSquareSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum / n NEW_LINE DEDENT n = 2 NEW_LINE print ( AvgSquareN ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def solve ( n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT remainder = n % base NEW_LINE sum += remainder NEW_LINE n = n // base NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumsOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for base in range ( 2 , n // 2 ) : NEW_LINE INDENT sum += solve ( n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT n = 8 NEW_LINE SumsOfDigits ( n ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT M = 10001 NEW_LINE p = [ 0 ] * M NEW_LINE p [ 0 ] = p [ 1 ] = p [ 0 ] = p [ 1 ] NEW_LINE for i in range ( 2 , M + 1 ) : NEW_LINE INDENT if i % i == 0 : NEW_LINE INDENT p [ i ] = 0 NEW_LINE DEDENT DEDENT write ( " % d \n " % M [ 0 ] ) NEW_LINE return 0 NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( readline ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT solve ( n ) NEW_LINE DEDENT
import sys NEW_LINE print ( int ( math . pow ( 4 , 15 ) ) ) NEW_LINE
import math as mt NEW_LINE def optimalSearchTree ( freq , freq , n ) : NEW_LINE INDENT cost = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cost [ i ] [ i ] = freq [ i ] [ i ] NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT for j in range ( i + L - 1 ) : NEW_LINE INDENT c = ( cost [ i ] [ j ] + ( cost [ i ] [ j ] ) ) NEW_LINE if ( c < cost [ i ] [ j ] ) : NEW_LINE INDENT cost [ i ] [ j ] = c NEW_LINE DEDENT DEDENT DEDENT DEDENT return cost [ 0 ] [ n - 1 ] NEW_LINE DEDENT def sum ( freq , freq , n ) : NEW_LINE INDENT s = 0 NEW_LINE for k in range ( n + 1 ) : NEW_LINE INDENT if ( freq [ k ] > cost [ k ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT s += freq [ k ] [ k ] NEW_LINE if ( s < cost ) : NEW_LINE INDENT continue NEW_LINE DEDENT s += freq [ k ] [ j ] NEW_LINE if ( s < cost ) : NEW_LINE INDENT continue NEW_LINE DEDENT s += freq [ k ] [ j ] NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT freq = [ 10 , 12 , 20 ] NEW_LINE freq = [ 34 , 8 , 50 ] NEW_LINE n = len ( freq ) NEW_LINE print ( " Cost ▁ of ▁ Optimal ▁ BST ▁ BST ▁ is " , optimalSearchTree ( freq , freq , n ) ) NEW_LINE DEDENT
def get ( x , y , z ) : NEW_LINE INDENT if ( x > z ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) // y NEW_LINE return div * div NEW_LINE DEDENT x , y , z = 1 , 5 , 8 NEW_LINE print ( get ( x , y , z ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] ) : NEW_LINE INDENT ans += abs ( a [ i - 1 ] - a [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( int ( binomialCoeff ( n , k ) ) ) NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def vowelPow2 ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) and isVowel ( s [ i + 1 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abaabbia " NEW_LINE n = len ( s ) NEW_LINE print ( vowelPow2 ( s , n ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , h = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE c = [ 0 ] * ( h + 1 ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT c [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT for _ in range ( n ) : NEW_LINE INDENT c [ 0 ] = c [ 0 ] + 1 NEW_LINE DEDENT for _ in range ( n ) : NEW_LINE INDENT c [ 0 ] = c [ 1 ] + 1 NEW_LINE DEDENT for i in range ( h ) : NEW_LINE INDENT for j in range ( 1 , w - h + 1 ) : NEW_LINE INDENT c [ i ] [ j ] += c [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( max ( c ) ) NEW_LINE DEDENT
def isSubstring ( s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT if ( s2 [ i + M ] != s1 [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == M ) : NEW_LINE INDENT return i NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " geeksforgeeks " NEW_LINE s2 = " geeksforgeeks " NEW_LINE res = isSubstring ( s1 , s2 ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not ▁ present " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ present " ) NEW_LINE DEDENT DEDENT
def angleOncconcFunc ( angle ) : NEW_LINE INDENT return ( z / 2 ) NEW_LINE DEDENT angle = 65 NEW_LINE z = angleOncFunc ( angle ) NEW_LINE print ( " The ▁ angle ▁ is " , z , " degrees " ) NEW_LINE
def countSubarray1 ( a , n ) : NEW_LINE INDENT count1 = 0 NEW_LINE number1 = 0 NEW_LINE number1 = 0 NEW_LINE number1 = 0 NEW_LINE number1 = 0 NEW_LINE number2 = 0 NEW_LINE number1 = 0 NEW_LINE number1 = 0 NEW_LINE number2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT number1 += ( count1 + ( count1 + 1 ) // 2 ) NEW_LINE count1 = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT number1 += ( count1 + ( count1 + 1 ) // 2 ) NEW_LINE count1 = 0 NEW_LINE DEDENT DEDENT if ( count1 > 0 ) : NEW_LINE INDENT number1 += ( count1 + ( count1 + 1 ) // 2 ) NEW_LINE count1 = 0 NEW_LINE DEDENT if ( count1 > 0 ) : NEW_LINE INDENT number1 += ( count1 + ( count1 + 1 ) // 2 ) NEW_LINE count2 = 0 NEW_LINE DEDENT print ( " Count ▁ of ▁ 1 ▁ of ▁ 1 ▁ with ▁ 1 ▁ with ▁ 1 ▁ with ▁ 1 ▁ with ▁ 1 ▁ 1 ▁ with ▁ 1 ▁ with ▁ 1 ▁ : " , number1 ) NEW_LINE print ( " Count ▁ of ▁ 1 ▁ with ▁ 1 ▁ with ▁ 1 ▁ with ▁ 1 ▁ : " , number1 ) NEW_LINE print ( " Count ▁ of ▁ 1 ▁ with ▁ 1 ▁ : " , number1 ) NEW_LINE DEDENT a = [ 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countSubarray1 ( a , n ) NEW_LINE
def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 and flag == 1 ) : NEW_LINE INDENT while ( x != 1 and flag != 3 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 3 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT N = 10 NEW_LINE printNumbers ( N ) NEW_LINE
def printPermutation ( n , k ) : NEW_LINE INDENT mx = n ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( mx , end = " ▁ " ) ; NEW_LINE m -= 1 ; NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 ; NEW_LINE K = 3 ; NEW_LINE if ( K > - 1 ) : NEW_LINE INDENT printPermutation ( N , K ) ; NEW_LINE DEDENT else : NEW_LINE INDENT printPermutation ( N , K ) ; NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT l . sort ( ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while i < n : NEW_LINE INDENT if l [ i ] < l [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT print ( k ) NEW_LINE
def check ( s1 , s2 ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT mp [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if mp [ s2 [ i ] ] > 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " geeksforgeeks " NEW_LINE s2 = " geeks " NEW_LINE if ( check ( s1 , s2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE m = ( a + b ) * n NEW_LINE m = ( a + b ) * n NEW_LINE if m >= ( c + d ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE
N = 3 NEW_LINE def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT tri = [ [ 1 , 0 , 0 ] , [ 4 , 8 , 3 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( maxPathSum ( tri , 2 , 3 ) ) NEW_LINE
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , ( n - 2 ) // 2 + 1 ) : NEW_LINE INDENT if ( arr [ 2 * i + 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 90 , 15 , 10 , 7 , 7 , 7 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isHeap ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isHeap ( arr , i , n ) : NEW_LINE INDENT if ( i > ( n - 2 ) // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ 2 * i + 2 ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 90 , 15 , 10 , 7 , 7 , 7 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isHeap ( arr , 0 , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
x , y , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = map ( int , input ( ) . split ( ) ) NEW_LINE if ( ( b - a ) * ( b - a ) ) == ( ( b - b ) * ( c - b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE def findMinDel ( arr , n ) : NEW_LINE INDENT min_num = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_num ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return n - cnt ; NEW_LINE DEDENT arr = [ 3 , 3 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findMinDel ( arr , n ) ) ; NEW_LINE
def count ( x , y ) : NEW_LINE INDENT ans = 0 NEW_LINE m = dict ( ) NEW_LINE while ( x % y != 0 ) : NEW_LINE INDENT x = x % y NEW_LINE if ( x in m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT m [ x ] = 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT res = count ( 1 , 2 ) NEW_LINE res = count ( 1 , 2 ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " INF " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " INF " ) NEW_LINE DEDENT
def isPossibleToDivisible ( arr , n ) : NEW_LINE INDENT remainder = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 NEW_LINE DEDENT return ( remainder == 0 ) NEW_LINE DEDENT arr = [ 40 , 50 , 90 ] NEW_LINE n = 3 NEW_LINE if ( isPossibleToDivisible ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for a in A : NEW_LINE INDENT d [ a ] = a NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT d [ a ] . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT d [ a ] = i NEW_LINE DEDENT DEDENT ans += d [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if d [ i ] == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def printCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , a + 1 ) : NEW_LINE INDENT if j * j * j == i : NEW_LINE INDENT print ( j * j * j , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT a = 1 NEW_LINE b = 100 NEW_LINE printCubes ( a , b ) NEW_LINE printCubes ( a , b ) NEW_LINE
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT n = 6 NEW_LINE d = 4 NEW_LINE print ( " % ▁ modulo ▁ " % d " % ( d , d , " is " % d , getModulo ( n , d ) ) ) NEW_LINE
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = n - 1000000000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if l [ i ] + d <= l [ j ] : NEW_LINE INDENT ans = max ( ans , i - l [ j ] + d ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
s = input ( ) NEW_LINE n = len ( s ) NEW_LINE c = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == ' f ' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( s [ i ] == ' f ' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT print ( ( ( c + 1 ) // 4 ) * ( 10 ** ( len ( s ) - 1 ) ) ) NEW_LINE DEDENT elif ( c == 1 ) : NEW_LINE INDENT print ( ( ( c + 1 ) // 4 ) * ( 10 ** ( len ( s ) - 1 ) ) ) NEW_LINE DEDENT elif ( c == 1 ) : NEW_LINE INDENT print ( ( ( c + 1 ) // 4 ) * ( 10 ** ( len ( s ) - 1 ) // 4 ) ) NEW_LINE DEDENT elif ( c == 1 ) : NEW_LINE INDENT print ( ( ( c + 1 ) // 4 ) * ( 10 ** ( len ( s ) - 1 ) // 4 ) ) NEW_LINE DEDENT elif ( c == 2 ) : NEW_LINE INDENT print ( ( c + 1 ) * ( 10 ** ( len ( s ) - 1 ) // 4 ) ) NEW_LINE DEDENT elif ( c == 4 ) : NEW_LINE INDENT print ( ( c + 1 ) * ( 10 ** ( len ( s ) - 1 ) // 4 ) ) NEW_LINE DEDENT elif ( c == 4 ) : NEW_LINE INDENT print ( ( c + 1 ) * ( 10 ** ( len ( s ) - 1 ) // 4 ) ) NEW_LINE DEDENT elif ( c == 4 ) : NEW_LINE INDENT print ( ( c + 1 ) * ( 10 ** ( len ( s ) - 1 ) ) ) NEW_LINE DEDENT elif ( c == 4 ) : NEW_LINE INDENT print ( c + 1 ) NEW_LINE DEDENT elif ( c == 4 ) : NEW_LINE INDENT print ( c + 1 ) NEW_LINE DEDENT elif ( c == 4 ) : NEW_LINE INDENT print ( c + 1 )
from math import sqrt NEW_LINE def isPerfectCube ( x ) : NEW_LINE INDENT crr = sqrt ( x ) NEW_LINE return ( crr * crr == x ) NEW_LINE DEDENT def canPerfectCube ( N , K ) : NEW_LINE INDENT if ( isPerfectCube ( N + K ) or isPerfectCube ( N - K ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 7 NEW_LINE K = 1 NEW_LINE canPerfectCube ( N , K ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE YesNo = lambda b : bool ( [ print ( ' Yes ' ) ] if b else print ( ' No ' ) ) NEW_LINE YESNO = lambda b : bool ( [ print ( ' YES ' ) ] if b else print ( ' NO ' ) ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE t = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if S [ i ] == t [ i ] : NEW_LINE INDENT ans += len ( S [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += len ( S [ i ] ) * 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def addEdge ( v , w ) : NEW_LINE INDENT adj [ v ] . append ( v ) NEW_LINE for i in range ( v ) : NEW_LINE INDENT adj [ i ] . append ( w ) NEW_LINE DEDENT DEDENT def addEdge ( v , v ) : NEW_LINE INDENT visited = [ True ] * v NEW_LINE print ( v , end = " ▁ " ) NEW_LINE DEDENT def DFS ( v , visited ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE for i in range ( v ) : NEW_LINE INDENT if not visited [ v ] : NEW_LINE INDENT DFS ( v , visited , i ) NEW_LINE DEDENT DEDENT DEDENT def DFS ( v , visited ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE print ( " Found ▁ Secondary ▁ Secondary ▁ Triple ▁ is " ) NEW_LINE DEDENT v = [ 1 ] * v NEW_LINE graph = [ [ 0 ] * v for i in range ( v ) ] NEW_LINE graph [ v [ 1 ] ] = [ 1 ] * v NEW_LINE graph [ v [ 2 ] ] = [ 2 ] NEW_LINE graph [ v [ 2 ] ] = [ 2 ] NEW_LINE graph [ v [ 2 ] ] = [ 3 ] NEW_LINE graph [ v [ 2 ] ] = [ 2 ] NEW_LINE graph [ v [ 2 ] ] = [ 3 ] NEW_LINE graph [ v [ 2 ] ] = [ 3 ] NEW_LINE DFS ( v , graph ) NEW_LINE
def countDigits ( val , arr ) : NEW_LINE INDENT while ( val > 0 ) : NEW_LINE INDENT digit = val % 10 NEW_LINE arr [ digit ] += 1 NEW_LINE val = val // 10 NEW_LINE DEDENT return val NEW_LINE DEDENT def countFrequency ( x , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val = pow ( x , i ) NEW_LINE countDigits ( val , freq ) NEW_LINE DEDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT val = pow ( x , i ) NEW_LINE countDigits ( val , freq ) NEW_LINE DEDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT print ( freq [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT x = 10 NEW_LINE n = 3 NEW_LINE countFrequency ( x , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = ' YES ' NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] != a [ i + 1 ] : NEW_LINE INDENT ans = ' NO ' NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 2 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT print ( n - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - 2 ) // 2 ) NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ' O ▁ that ▁ a ▁ b ' ) NEW_LINE
def linearCheck ( ar , arr ) : NEW_LINE INDENT for i in range ( 0 , len ( ar ) ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ar [ i ] [ j ] != arr [ j ] ) : NEW_LINE INDENT return i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 0 , 1 , 1 , 2 ] , [ 10 , 9 , 4 ] , [ 40 , 40 , 80 ] , [ 40 , 40 , 80 ] , [ 81 , 40 , 80 ] ] NEW_LINE row = [ 10 , 9 , 40 , 80 ] NEW_LINE print ( linearCheck ( mat , row ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) / n NEW_LINE if s % n == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s // n ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE V = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE V = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE V . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT m = V [ i ] NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT if V [ j ] > V [ i ] : NEW_LINE INDENT m = V [ j ] NEW_LINE ans = max ( ans , m + 1 - i ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 7 * pow ( n , 2 ) - 7 * n + 7 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 5 * pow ( n , 2 ) - 5 * n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) + 2 * n + 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 3 ) + pow ( n , 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) - n - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) - 2 * n + 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + n - 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( " - " ) NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( " - " ) NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( " - " ) NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( " - " ) NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( " - " ) NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( " - " ) NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( " - " ) NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( " - " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - " ) NEW_LINE DEDENT
s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE s1 = input ( ) NEW_LINE s2 = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT s1 . append ( s1 [ : i + 1 ] ) NEW_LINE DEDENT s2 . sort ( ) NEW_LINE print ( min ( s1 ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def fib ( self , N ) : NEW_LINE INDENT memo [ N ] = 1 NEW_LINE return memo [ N ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE N = 2 NEW_LINE out = sObj . fib ( N ) NEW_LINE print ( out ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = s . count ( ' a ' ) NEW_LINE b = s . count ( ' b ' ) NEW_LINE c = s . count ( ' a ' ) NEW_LINE b = s . count ( ' b ' ) NEW_LINE c = s . count ( ' c ' ) NEW_LINE if ( b == 0 ) : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' b ' ) : NEW_LINE INDENT c += s [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT c -= s [ i ] NEW_LINE b -= s [ i ] NEW_LINE DEDENT DEDENT print ( ' ' . join ( c ) ) NEW_LINE DEDENT DEDENT
PI = 3.142 ; NEW_LINE PI = 3.142 ; NEW_LINE def cosXSieveSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180 ) ; NEW_LINE res = 1 ; NEW_LINE fact = 1 ; NEW_LINE fact = 1 ; NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * ( 2 * i - 1 ) * x ; NEW_LINE fact = fact * x ; NEW_LINE res = res + sign * x ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT x = 50 ; NEW_LINE print ( cosXSieveSum ( x , 5 ) * 100000 ) ; NEW_LINE
def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( N * ( N + 1 ) / 4 ) - ( S + 1 ) / 2 ) NEW_LINE return i NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) - ( ( S + 1 ) / 2 ) NEW_LINE if ( i - S ) : NEW_LINE INDENT print ( " No : " , " , i , " , ( i + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No : " , i , " , ( i + 1 ) ) NEW_LINE DEDENT DEDENT N = 4 NEW_LINE S = 3 NEW_LINE findNumber ( N , S ) NEW_LINE
def multipleOfThree ( K , dig ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = ( dig0 + dig ) % 10 NEW_LINE sum = dig + dig NEW_LINE if ( K == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT sum += temp NEW_LINE sum += temp NEW_LINE DEDENT def multipleOfThree ( K , dig ) : NEW_LINE INDENT sum += temp NEW_LINE rem = ( K - 3 ) // 4 NEW_LINE rem += 10 NEW_LINE sum += temp NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT K = 5 NEW_LINE dig = 3 NEW_LINE dig = ( K - 3 ) // 4 NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT K = 5 NEW_LINE dig = 3 NEW_LINE if ( multipleOfThree ( K , dig ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE if sum ( b ) < sum ( b ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def countOcc ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( s ) - 3 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( i , len ( s ) - 4 ) : NEW_LINE INDENT if ( s [ j ] == ' c ' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( c == 1 and l == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( c == 1 and l == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " clapcc " NEW_LINE print ( countOcc ( s ) ) NEW_LINE DEDENT
def countSteps ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return x / y NEW_LINE DEDENT return x / y + countSteps ( y , x % y ) NEW_LINE DEDENT x , y = 100 , 19 NEW_LINE print ( countSteps ( x , y ) ) NEW_LINE
from math import sqrt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isPerfectSquareNum ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( n + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 3 NEW_LINE if ( isPerfectSquare ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
PI = 3.14159265 NEW_LINE def area_inscribed ( P , B , H ) : NEW_LINE INDENT return ( ( P + B - H ) * ( P + B - H ) * ( PI - H ) ) NEW_LINE DEDENT P , B , H = 3 , 4 , 5 NEW_LINE print ( area_inscribed ( P , B , H ) ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE c = [ 0 ] * 256 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT c [ 0 ] , c [ 1 ] = input ( ) . split ( ) NEW_LINE c [ c [ 0 ] ] = c [ 1 ] = c [ 0 ] NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT c [ i ] = input ( ) . split ( ) NEW_LINE DEDENT for i in c : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def getCount ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = n - 1 - upperBound ( v , n , v [ i ] - 1 ) NEW_LINE if ( tmp >= array [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def getCount ( v , value , value ) : NEW_LINE INDENT low = 0 NEW_LINE high = length NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( value >= array [ mid ] ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE v = [ 1 , 2 , 3 , 4 ] NEW_LINE print ( getCount ( v , n ) ) NEW_LINE DEDENT
def trailing_two ( N ) : NEW_LINE INDENT count_of_two = 0 ; NEW_LINE count_of_two = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT val = i ; NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val //= 2 ; NEW_LINE count_of_two += i ; NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) ; NEW_LINE return ans ; NEW_LINE DEDENT N = 12 ; NEW_LINE print ( trailing_two ( N ) ) ; NEW_LINE
def removeZero ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if ( n % 10 != 0 ) : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def isEqual ( a , b ) : NEW_LINE INDENT if ( removeZero ( a ) + removeZero ( b ) == removeZero ( removeZero ( a + b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 105 NEW_LINE b = 105 NEW_LINE if ( isEqual ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE N = int ( readline ( ) ) NEW_LINE P = [ None ] * N NEW_LINE def solve ( ) : NEW_LINE INDENT N = int ( readline ( ) ) NEW_LINE if N == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if P [ 0 ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if P [ 0 ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if P [ 0 ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if P [ 0 ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if P [ 0 ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if P [ 0 ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if P [ 1 ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if P [ 0 ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if P [ 1 ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if P [ 0 ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if P [ 1 ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = readline ( ) NEW_LINE S = [ ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT s = readline ( ) . split ( ) NEW_LINE if s [ 0 ] == " A " : NEW_LINE INDENT S [ s [ 1 ] - 1 ] = S [ s [ 1 ] - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT S [ s [ 1 ] - 1 ] = S [ s [ 2 ] - 1 NEW_LINE DEDENT DEDENT print ( sum ( S ) % P ) NEW_LINE return NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE print ( a [ n // 2 ] ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + b // 2 ) + ( b // 2 ) * 2 // 2 , ( a + b // 2 ) * 2 ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE k = n - n % m NEW_LINE a = k // m NEW_LINE b = k - n % m NEW_LINE print ( * b ) NEW_LINE
def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE arr2 = [ 0 for i in range ( 7 ) ] NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = bin ( s1 [ i ] ) NEW_LINE arr2 [ set_bits ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = bin ( s2 [ i ] ) NEW_LINE arr2 = bin ( arr2 [ i ] * arr2 [ i ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " geeks " NEW_LINE s2 = " geeks " NEW_LINE print ( totalPairs ( s1 , s2 ) ) NEW_LINE DEDENT
def countSubSeq ( i , sum , cnt , a , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( sum == 0 and cnt > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE ans += countSubSeq ( i + 1 , sum , cnt , a [ i ] , cnt + 1 , cnt + 1 , a [ i ] ) NEW_LINE return ans NEW_LINE DEDENT a = [ - 1 , 2 , - 2 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubSeq ( 0 , 0 , 0 , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = ( n - 1 ) // 2 NEW_LINE b = ( n - 1 ) // 2 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT a = a [ i : i ] + s [ i + 1 : ] NEW_LINE b = b NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b = a [ i : i + 1 ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( * b , sep = ' ' ) NEW_LINE
a , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT c += ( i ** a ) * ( i ** b ) NEW_LINE DEDENT print ( c ) NEW_LINE
def pivot_index ( arr , n , key ) : NEW_LINE INDENT pivot = find_index ( arr , 0 , n - 1 , key ) NEW_LINE if pivot == - 1 : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key - 1 , key ) NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key - 1 ) NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key - 1 ) NEW_LINE DEDENT mid = ( int ) ( ( ( mid + 1 ) / 2 , n - 1 , key ) ) NEW_LINE if arr [ mid ] >= arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , mid , mid - 1 , key ) NEW_LINE DEDENT if arr [ mid ] >= arr [ mid - 1 ] : NEW_LINE INDENT return binarySearch ( arr , mid , ( mid + 1 ) , arr [ mid - 1 ] ) NEW_LINE DEDENT return binarySearch ( arr , mid - 1 , ( mid - 1 ) , arr [ mid - 1 ] ) NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( mid == low and arr [ mid ] >= arr [ mid - 1 ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , ( mid - 1 ) , ( mid - 1 ) ) NEW_LINE DEDENT if ( arr [ low ] >= arr [ mid - 1 ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , ( mid - 1 ) , ( mid - 1 ) ) NEW_LINE DEDENT return binarySearch ( arr , ( mid - 1 ) , ( ( mid - 1 ) , ( mid - 1 ) , ( mid - 1 ) , ( mid - 1 ) ) ) NEW_LINE DEDENT arr1 = [ 5 , 6 , 8 , 10 , 10 , 10 , 9 ] NEW_LINE n = len ( arr1 ) NEW_LINE print (
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dp = [ [ 1 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT DEDENT print ( dp [ n ] [ n ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] == 0 : NEW_LINE INDENT ans . append ( i ) NEW_LINE ans . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for i in ans : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( ( int ( input ( ) ) ) ) NEW_LINE DEDENT d = [ [ 0 ] * n for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == ' # ' : NEW_LINE INDENT d [ i ] [ j ] = ' # ' NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ' ' . join ( ' ' . join ( d [ i ] ) ) ) NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , eulerlib . count ( 1 << i ) , 1 << i ) for i in range ( 1 , eulerlib . sqrt ( 1 << i ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_integer_array_list ( a , b ) : NEW_LINE INDENT if a == b : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return 1 NEW_LINE DEDENT if a == b or a == b : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b or a == b == c : NEW_LINE INDENT return 1 NEW_LINE DEDENT if a == b or a == c : NEW_LINE INDENT return 1 NEW_LINE DEDENT if a == b or a == c : NEW_LINE INDENT return 1 NEW_LINE DEDENT if a == c : NEW_LINE INDENT return 1 NEW_LINE DEDENT if a == c : NEW_LINE INDENT return 1 NEW_LINE DEDENT if a == c : NEW_LINE INDENT return 1 NEW_LINE DEDENT if is_integer_array_list ( a ) or is_integer_array_array_list ( a , b ) or is_integer_array_list ( b ) or is_integer_array_array ( a , b ) or is_integer_array ( b ) or is_integer_array ( a , b ) or isinteger_array_array ( b ) or isinteger_array_array ( a , b ) or isinteger_array_array ( b , c ) or isinteger_array_array ( a , b ) or isinteger_array_array ( b , c ) or isinteger_array ( b , c ) or isinteger_array ( b , c ) or isinteger_array ( a , b ) or isinteger_array ( b , c ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d [ a [ 0 ] - 1 ] = a [ 1 ] - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT d [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT d [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if d [ i ] [ j ] == 1 : NEW_LINE INDENT print ( * d [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * d [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ input ( ) for i in range ( n ) ] NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if s [ i ] [ j ] == ' f ' : c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
s = input ( ) NEW_LINE st = [ ] NEW_LINE st . append ( s [ 0 ] ) NEW_LINE st . append ( st [ 1 ] ) NEW_LINE st . append ( st [ 0 ] ) NEW_LINE st . append ( st [ 1 ] ) NEW_LINE st . append ( st [ 0 ] ) NEW_LINE st . append ( st [ 0 ] ) NEW_LINE st . append ( st [ 1 ] ) NEW_LINE st . append ( st [ 0 ] ) NEW_LINE st . append ( st [ 1 ] ) NEW_LINE st . append ( st [ 0 ] ) NEW_LINE st . append ( st [ 1 ] ) NEW_LINE st . append ( st [ 0 ] ) NEW_LINE st . append ( st [ 1 ] ) NEW_LINE st . append ( st [ 1 ] ) NEW_LINE st . append ( st [ 0 ] ) NEW_LINE st . append ( st [ 1 ] ) NEW_LINE st . append ( st [ 1 ] ) NEW_LINE st . append ( st [ 2 ] ) NEW_LINE st . append ( st [ 1 ] ) NEW_LINE st . append ( st [ 2 ] ) NEW_LINE st . append ( st [ 3 ] ) NEW_LINE st . append ( st [ 3 ] ) NEW_LINE st . append ( st [ 4 ] ) NEW_LINE st . append ( st [ 4 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st . append ( st [ 6 ] ) NEW_LINE st
from collections import defaultdict NEW_LINE def dfs ( G , v ) : NEW_LINE INDENT global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global n NEW_LINE global g [ n ] = [ ] NEW_LINE global g [ n ] NEW_LINE global g [ n ] = [ ] NEW_LINE g [ n ] = [ ] NEW_LINE g [ g [ n ] ] = [ g [ n ] ] NEW_LINE g [ g [ n ] ] = [ g [ n ] ] NEW_LINE g [ g [ n ] ] = [ g [ g [ n ] ] ] NEW_LINE g [ n ] . append ( g [ n ] ) NEW_LINE g [ g [ n ] ] . append ( g [ g [ n ] ] ) NEW_LINE g [ n ] . append ( g [ g [ n ] ] ) NEW_LINE g [ n ] . append ( g
MAX = 100 NEW_LINE def countBILLains ( a , n ) : NEW_LINE INDENT A = [ [ 0 for i in range ( n + 2 ) ] for j in range ( n + 2 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT for j in range ( n + 2 ) : NEW_LINE INDENT if ( ( i == 0 or j == n + 1 ) or ( i == n + 1 ) or ( j == n + 1 ) ) : NEW_LINE INDENT A [ i ] [ j ] = A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 2 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE n = 3 NEW_LINE print ( countBILLains ( a , n ) ) NEW_LINE DEDENT
N = 100005 NEW_LINE d = [ 0 for i in range ( N ) ] NEW_LINE pre = [ 0 for i in range ( N ) ] NEW_LINE pre = [ 0 for i in range ( N ) ] NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT d [ i ] = 0 NEW_LINE DEDENT DEDENT pre [ i ] = ans NEW_LINE pre [ i ] = ans NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE pre [ i ] = ans NEW_LINE DEDENT DEDENT print ( pre_Divisors ( n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m : NEW_LINE INDENT l . append ( ( n + m ) ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( n + m ) NEW_LINE DEDENT DEDENT l . reverse ( ) NEW_LINE ans = " LOVALLE " NEW_LINE if m : NEW_LINE INDENT print ( " LOOPLE " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " LOVALLE " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
import math NEW_LINE def area_of_sharp_polygon ( n , length ) : NEW_LINE INDENT P = ( n * n ) / ( 2 * math . tan ( ( ( ( 180 / n ) * 3.14 ) * 3.14 ) ) ) NEW_LINE area = ( P * 3.14159 ) / 2 NEW_LINE return area NEW_LINE DEDENT n = 6 NEW_LINE length = 10 NEW_LINE print ( area_of_polygon ( n , length ) ) NEW_LINE
MAX = 256 ; NEW_LINE def lastNonRepeating ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * ( MAX ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ch = ord ( str [ i ] ) ; NEW_LINE if ( freq [ ch ] == 1 ) : NEW_LINE INDENT return " " ; NEW_LINE DEDENT DEDENT return " - 1" ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksForGeeks " ; NEW_LINE n = len ( str ) ; NEW_LINE print ( lastNonRepeated ( str , n ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT b . sort ( ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c ) NEW_LINE DEDENT
def y ( x ) : NEW_LINE INDENT return ( 1 / ( x + x ) ) / ( 1 + x ( 1 + x ) / n ) NEW_LINE DEDENT def FourLEMoval ( a , b ) : NEW_LINE INDENT n = 4 / ( ( b - a ) + 12 * ( a + b ) + 12 * ( a + b ) + 12 * ( a + b ) ) NEW_LINE sum = sum + 12 * ( a + b ) * 2 * ( a + 4 * b ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " f " ) NEW_LINE DEDENT
MAXM = 300M ; NEW_LINE maxM = 300 ; NEW_LINE dp = [ [ [ 0 for i in range ( MAXM ) ] for i in range ( MAXM ) ] for i in range ( MAXM ) ] ; NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( v [ curr ] [ curr ] == m ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr ) ; NEW_LINE r = findLen ( arr , i + 1 , curr & arr [ i ] [ curr ] , curr & arr [ i ] [ curr ] , r + 1 ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 3 ; NEW_LINE ans = findLen ( arr , 0 , ( ( 1 << ( ( ( 1 << 8 ) - 1 ) ) ) , n , m ) ; NEW_LINE if ( ans == - 1 ) ) : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT DEDENT
MAX = 20 NEW_LINE maxM = 64 NEW_LINE dp = [ [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ curr ] == m ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE l = findLen ( arr , i + 1 , curr , n ) NEW_LINE r = findLen ( arr , i + 1 , curr , n ) NEW_LINE dp [ i ] [ curr ] [ curr ] = l NEW_LINE dp [ i ] [ curr ] = l NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = l NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE ans = findLen ( arr , 0 , 0 , n , m ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE from heapq import heappush , heappop NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def S ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def IR ( n ) : NEW_LINE INDENT l = [ None for i in range ( n ) ] NEW_LINE for i in range ( n ) : l [ i ] = I ( ) NEW_LINE for i in range ( n - 1 ) : l [ i ] = LI ( ) NEW_LINE for i in range ( n - 1 ) : l [ i ] = LI ( ) NEW_LINE for i in range ( n - 1 ) : l [ i ] [ i ] = I ( ) NEW_LINE l [ i ] [ i ] = l [ i ] [ 0 ] + l [ i + 1 ] [ i ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = I ( ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT l = [ LI ( ) for i in range ( n ) ] NEW_LINE l [ - 1 ] [ i ] = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT l [ i ] [ i ] = LI ( ) NEW_LINE l [ i ] [ i ] = l [ i + 1 ] [ i ] + l [ i ] [ i + 1 ] NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT l [ i ] [ j ] = l [ i ] [ j ] + l [ i ] [ j ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += 2 * l [ i ] [ i
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if N [ i ] == '3' : NEW_LINE INDENT ans += 3 * ( N [ i ] - 1 ) + 3 * ( N [ i + 1 ] - 1 ) NEW_LINE DEDENT elif N [ i ] == '7' : NEW_LINE INDENT ans += 3 * ( N [ i ] - 1 ) + 3 * ( N [ i + 1 ] - 1 ) NEW_LINE DEDENT elif N [ i ] == '7' : NEW_LINE INDENT ans += 3 * ( N [ i ] - 1 ) + 6 * ( N [ i + 1 ] - 1 ) NEW_LINE DEDENT elif N [ i ] == '7' : NEW_LINE INDENT ans += 3 * ( N [ i ] - 1 ) + 6 * ( N [ i + 1 ] - 1 ) + 6 * ( N [ i + 1 ] - 1 ) NEW_LINE DEDENT elif N [ i ] == '7' : NEW_LINE INDENT ans += 5 * ( N [ i ] - 1 ) + 6 * ( N [ i + 1 ] - 1 ) + 6 * ( N [ i ] - 1 ) NEW_LINE DEDENT elif N [ i ] == '7' : NEW_LINE INDENT ans += 6 * ( N [ i ] - 1 ) + 6 * ( N [ i + 1 ] - 1 ) + 6 * ( N [ i + 1 ] - 1 ) + 6 * ( N [ i ] - 1 ) ) NEW_LINE DEDENT elif N [ i ] == '7' : NEW_LINE INDENT ans += 6 * ( N [ i + 1 ] - 1 ) + 6 * ( N [ i + 1 ] - 1 ) NEW_LINE DEDENT elif N [ i ] == '7' : NEW_LINE INDENT ans += 5 * ( N [ i + 1 ] - 1 ) + 6 * ( N [ i + 1 ] - 1 ) + 6 * ( N [ i + 1 ] - 1 ) + 6 * ( N [ i + 1 ] - 1
import sys NEW_LINE def minDiff ( arr , n , k ) : NEW_LINE INDENT result = sys . maxsize ; NEW_LINE arr . sort ( ) ; NEW_LINE for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT arr = [ 10 , 100 , 200 , 200 , 1000 , 20 , 30 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 3 ; NEW_LINE print ( minDiff ( arr , n , k ) ) ; NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n < 10 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT l . sort ( ) NEW_LINE if l [ 0 ] < l [ 1 ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( i + 1 ) NEW_LINE DEDENT
def Mean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT return sum / n NEW_LINE DEDENT def meanAbsiation ( arr , n ) : NEW_LINE INDENT absSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT absSum = abs ( arr [ i ] - Mean ( arr [ i ] ) ) NEW_LINE DEDENT return absSum / n NEW_LINE DEDENT arr = [ 10 , 15 , 17 , 19 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( meanAbsiation ( arr , n ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** eulerlib . list_primes ( 1001 ) NEW_LINE primes = eulerlib . list_primes ( 1001 ) NEW_LINE primes = [ 0 ] * ( LIMIT ) NEW_LINE primes [ 0 ] = primes [ 1 ] = primes [ 0 ] = primes [ 1 ] = primes [ 0 ] = primes [ 0 ] = primes [ 1 ] = primes [ 0 ] = primes [ 1 ] = primes [ 0 ] = primes [ 0 ] = primes [ 1 ] = primes [ 0 ] = primes [ 1 ] = primes [ 0 ] = primes [ 1 ] = primes [ 0 ] = primes [ 1 ] = primes [ 0 ] = primes [ 1 ] = primes [ 0 ] = primes [ 1 ] = primes [ 0 ] = primes [ 1 ] = primes [ 0 ] ) NEW_LINE return sum ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE def maximumXOR ( n , l , r ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( math . floor ( math . log ( 2 ) / math . log ( 2 ) ) ) : NEW_LINE INDENT if ( ( x + ( 1 << i ) - 1 ) / 2 ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( x ^ ( 1 << i ) - 1 ) <= r ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT DEDENT return n ^ x NEW_LINE DEDENT n = 7 NEW_LINE l = 2 ; r = 23 NEW_LINE print ( " The ▁ output ▁ is " , maximumXOR ( n , l , r ) ) NEW_LINE
import math NEW_LINE def maxPrimefactorNumNum ( N ) : NEW_LINE INDENT arr = [ False for i in range ( N + 5 ) ] NEW_LINE for i in range ( 3 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( arr [ i ] != False ) : NEW_LINE INDENT for j in range ( i * i , N , i ) : NEW_LINE INDENT arr [ j ] = True NEW_LINE DEDENT DEDENT DEDENT prime . append ( prime ) NEW_LINE prime . append ( prime ) NEW_LINE ans = 1 NEW_LINE while ( ans * prime <= N and prime [ i ] <= N and prime [ i ] <= N ) : NEW_LINE INDENT ans *= prime [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 40 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE DEDENT
def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = bin ( n ) [ : : - 1 ] NEW_LINE bit1 = bin ( n ) [ : : - 1 ] NEW_LINE zero = 0 NEW_LINE for i in range ( 0 , 64 ) : NEW_LINE INDENT if ( bit [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( a + b , 2 * c + a , 3 * b , 3 * c ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def distinctSubstring ( P , Q , K , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = P [ j ] - ord ( ' a ' ) NEW_LINE sum += P [ j ] NEW_LINE if ( sum <= K ) : NEW_LINE INDENT S . add ( S [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT P = " abcde " NEW_LINE Q = "123454567845678456784567889" NEW_LINE K = 5 NEW_LINE print ( distinctSubstring ( P , Q , K , N ) ) NEW_LINE
def makeEven ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE even = sys . maxsize NEW_LINE even = sys . maxsize NEW_LINE index = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ( ord ( string [ i ] ) - ord ( '0' ) ) % 2 == 0 ) : NEW_LINE INDENT even = ( ord ( string [ i ] ) - ord ( '0' ) ) NEW_LINE index = i NEW_LINE DEDENT if ( even <= ( ord ( string [ n - 1 ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( even <= ( ord ( string [ n - 1 ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT return str NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "13642525" NEW_LINE print ( makeEven ( string ) ) NEW_LINE DEDENT
def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i * j + 1 , 1 ) : NEW_LINE INDENT div [ i * j ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE findDivisors ( n ) NEW_LINE
s = input ( ) NEW_LINE t = input ( ) NEW_LINE s1 = s [ : : - 1 ] NEW_LINE s2 = s [ : : - 1 ] NEW_LINE s2 = s [ : : - 1 ] NEW_LINE s2 = s [ : : - 1 ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] == '0' : NEW_LINE INDENT ans += ( ( t1 [ i ] == '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( t1 [ i ] == '0' ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
MAX_CHAR = 256 NEW_LINE def printDistinct ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * ( MAX_CHAR ) NEW_LINE index = [ 0 ] * ( MAX_CHAR ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] = n NEW_LINE index [ i ] = n NEW_LINE if ( count [ x ] == ' ▁ ' and x != ' ▁ ' ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = str [ i ] NEW_LINE count [ x ] = count [ x ] NEW_LINE if ( count [ x ] == 2 and x != 2 ) : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksforGeeks " NEW_LINE printDistinct ( str ) NEW_LINE DEDENT
def calculate ( x , k , m ) : NEW_LINE INDENT result = x NEW_LINE k -= 1 NEW_LINE while ( k > m ) : NEW_LINE INDENT result = result * pow ( result , x ) NEW_LINE if ( result > m ) : NEW_LINE INDENT result = result % m NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT x = 5 NEW_LINE k = 2 NEW_LINE m = 3 NEW_LINE print ( calculate ( x , k , m ) ) NEW_LINE
def converthenumber ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE res = " " NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' or s [ i ] == '5' or s [ i ] == '5' ) : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def converthenumber ( n ) : NEW_LINE INDENT converthenumbers = [ ] NEW_LINE for i in range ( 0 , len ( convertumber ( n ) ) ) : NEW_LINE INDENT if ( converthenumbers [ i ] == '5' or convertumber ( n ) == '5' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( convertumber ) == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 18720umber ( n ) NEW_LINE converthenumbers ( n ) NEW_LINE converthenumbers ( n ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] in l ) : NEW_LINE INDENT l . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( s [ i ] ) NEW_LINE DEDENT DEDENT for i in l : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = set ( a ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b : NEW_LINE INDENT b . add ( i ) NEW_LINE DEDENT DEDENT print ( * b ) NEW_LINE DEDENT
def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) * ( m + 1 ) ) // 2 NEW_LINE DEDENT def trace ( n , m ) : NEW_LINE INDENT ans = sn ( n , an ) NEW_LINE anVal = sn ( n , anVal ) NEW_LINE return rowVal + ( n , anVal ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE print ( trace ( N , M ) ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import collections NEW_LINE import bisect NEW_LINE import copy NEW_LINE import heapq NEW_LINE import decimal NEW_LINE import queue NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 16 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE ni = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE ns = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT h , w = ns ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT c = 0 NEW_LINE for j in range ( w ) : NEW_LINE INDENT if c [ i ] == ' J ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if j == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if c [ i ] == ' O ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT ans += c NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math as mt NEW_LINE def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( ( ( n // i ) == 0 ) ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT DEDENT DEDENT if ( ( i * i == n ) and ( i % k == 0 ) ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE
def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and i % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT n = 12 ; NEW_LINE k = 3 ; NEW_LINE print ( countDivisors ( n , k ) ) ; NEW_LINE
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x + 48 ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findModByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = " " NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = temp + ch ( ord ( X ) ) ( ord ( X ) ) NEW_LINE DEDENT res = ( power ( X , N // 2 , M ) ) % p NEW_LINE res = ( half * power ( 10 , N // 2 , M ) ) % p NEW_LINE res = ( halfModByM ( X , N // 2 , M ) + X ) % p NEW_LINE return res NEW_LINE DEDENT X = 6 NEW_LINE N = 14 NEW_LINE print ( findModByM ( X , N , M ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = sum ( a ) NEW_LINE d = sum ( b ) NEW_LINE print ( ( ( n - c ) * ( n - d ) + ( ( n - c ) ) * ( n - b ) ) NEW_LINE DEDENT
import sys NEW_LINE def findMaxDiff ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid ▁ " ) NEW_LINE return 0 NEW_LINE DEDENT m_val = min ( arr [ 0 ] , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] - i > m_val ) : NEW_LINE INDENT m_val = arr [ i ] - i NEW_LINE DEDENT if ( ( ( arr [ i ] - i ) < m_val ) ) : NEW_LINE INDENT m_val = arr [ i ] - i NEW_LINE DEDENT DEDENT return ( m_val - m_val ) NEW_LINE DEDENT arr = [ 9 , 10 , 4 , 10 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxDiff ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == ' # ' and a [ i ] [ j ] == ' # ' : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( ' YES ' ) NEW_LINE
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT count [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j - 1 ] + count [ i ] [ j ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE if s % n != 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def isKthBit ( n , k ) : NEW_LINE INDENT return ( ( ( n >> ( k - 1 ) ) & 1 ) ) NEW_LINE DEDENT def setBits ( n , k ) : NEW_LINE INDENT return ( ( ( 1 << ( k - 1 ) ) ) & n ) NEW_LINE DEDENT def allBitsAreSetRange ( n , k ) : NEW_LINE INDENT return allBits ( n , k ) NEW_LINE DEDENT def bitsAreInRangeInRange ( n , k , r ) : NEW_LINE INDENT if ( ( n + 1 ) & n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT num = n ^ ( ( 1 << ( k + 1 ) ) ) NEW_LINE left_bit = r & ( 1 << ( r - 1 ) ) NEW_LINE return bits & ( ( 1 << ( l - 1 ) - 1 ) - 1 ) NEW_LINE DEDENT DEDENT def bitsAreInRangeRangeRangeRange ( n , l , r ) : NEW_LINE INDENT num = n ^ ( 1 << ( r ) - 1 ) NEW_LINE if ( isKInRangeRange ( n , r ) ) : NEW_LINE INDENT num = n & ( 1 << ( r + 1 ) - 1 ) NEW_LINE left_bit = num & ( ( 1 << ( r + 1 ) - 1 ) ) NEW_LINE return bitsAreInRange ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE DEDENT n = 18 NEW_LINE l = 1 NEW_LINE r = n & ( 1 << ( l - 1 ) ) NEW_LINE return bitsAreInRangeRangeRange ( n , r ) NEW_LINE DEDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if ( bitsAreInRangeRangeRangeInRangeRangeRangeInRangeRangeRangeRangeInRangeRangeRangeInRangeRangeRangeRangeRangeInRangeRangeRangeRangeRangeRange ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) // ( fact ( n - 1 ) * fact ( fact ( n - 1 ) // fact ( fact ( n - r ) ) * fact ( n - 1 ) ) ) NEW_LINE DEDENT def NumberOfWays ( n , x , y ) : NEW_LINE INDENT return nCr ( 2 * n - x , n - y ) * factorial ( n - x - y ) * factorial ( n - y ) * factorial ( n - x ) * factorial ( n - y ) * factorial ( n - x ) * factorial ( n - y ) * factorial ( n - x ) * factorial ( n - y ) NEW_LINE DEDENT n = 5 NEW_LINE x = 2 NEW_LINE print ( NumberOfWays ( n , x , y ) ) NEW_LINE
def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT result = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE for i in range ( 0 , n1 - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 [ i ] NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ " geeksforgeeks " , " geeks " , " geeks " , " geeks " ] NEW_LINE n = len ( arr ) NEW_LINE print ( commonPrefix ( arr , n ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE from collections import Counter , deque NEW_LINE from collections import defaultdict NEW_LINE from itertools import combinations , permutations , accumulate , groupby , product NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE from heapq import heapify , heappop , heappush NEW_LINE from math import floor , ceil , floor NEW_LINE from operator import itemgetter NEW_LINE def I ( ) : return int ( input ( ) ) NEW_LINE def MI ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE def LS ( ) : return list ( input ( ) . split ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def IR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE mod = 1000000007 NEW_LINE n = I ( ) NEW_LINE a = list ( LI ( ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if w [ - 1 ] == 2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if w [ i ] == 2 : NEW_LINE INDENT print ( i - 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT if w [ i - 1 ] == 2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( w [ i - 1 ] + 1 ) NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT a = a + b NEW_LINE b = b NEW_LINE a = a + b NEW_LINE DEDENT return str ( a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ low ] += high NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( low + high - low + 1 ) // 2 NEW_LINE findFrequencyUtil ( arr , mid + 1 , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , freq ) NEW_LINE for i in range ( 0 , arr [ n - 1 ] + 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( " Element ▁ " , i , " ▁ " , findFrequency ( arr , 0 , i + 1 , freq ) , " ▁ " , findFrequencyUtil ( arr , 0 , mid + 1 , freq ) ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 8 , 9 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , 0 , n - 1 , freq ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE ans = eulerlib . list_t ( LIMIT - 1 ) NEW_LINE for n in range ( 2 , LIMIT - 1 ) : NEW_LINE INDENT tot_len = eulerlib . array ( tot_len ) NEW_LINE if not ( n ** tot_len - 1 ) : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def s_str ( ) : NEW_LINE INDENT tot_len = eulerlib . array ( tot_len ) NEW_LINE tot_len = eulerlib . array ( tot_len ) NEW_LINE if tot_len * tot_len < eulerlib . array ( tot_len ) : NEW_LINE INDENT return tot_len NEW_LINE DEDENT return tot_len NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def intersection ( a , b , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( a [ i ] > b [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( b [ j ] > a [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT a = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE intersection ( a , b , n , m ) NEW_LINE
import math NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += math . log ( a [ i ] ) ; NEW_LINE DEDENT x = math . ceil ( sum / n ) ; NEW_LINE return x + 1 ; NEW_LINE DEDENT a = [ 3 , 2 , 1 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( findMin ( a , n ) ) ; NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def minPerfectSq ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return gcd ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE DEDENT def minPerfectSq ( arr , n ) : NEW_LINE INDENT minPerfectSq = lcmOfSq ( arr , n ) NEW_LINE minPerfectSq = lcmOfSq ( arr , n ) NEW_LINE cnt = 0 NEW_LINE while ( cnt > 1 and cnt % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT if ( cnt % 2 != 0 ) : NEW_LINE INDENT minPerfectSqq *= 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( lcm > 1 and lcm % 2 != 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectSq NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectSq ( arr , n ) ) NEW_LINE
def subarrayCount ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE safe = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] == 1 ) : NEW_LINE INDENT safe += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = safe + 1 NEW_LINE result = i - safe + 1 NEW_LINE DEDENT DEDENT if ( safe != safe ) : NEW_LINE INDENT len = safe - safe + ( len - 1 ) // 2 NEW_LINE result = i NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( subarrayCount ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( n // 2 + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 2 NEW_LINE c = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n -= ( n + 1 ) // 2 NEW_LINE c += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE m = s * m NEW_LINE print ( m , s ) NEW_LINE
MAX_CHARS = 256 NEW_LINE MAX_CHARS = 256 NEW_LINE def findSubStr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE visited = [ False for i in range ( MAX_CHARS ) ] NEW_LINE visited = [ False for i in range ( MAX_CHARS ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if visited [ ord ( str [ i ] ) ] == False : NEW_LINE INDENT visited [ ord ( str [ i ] ) ] = True NEW_LINE DEDENT DEDENT start = 0 NEW_LINE min_len = - 1 NEW_LINE min_len = - 1 NEW_LINE count_len = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count = 0 NEW_LINE if curr_count [ ord ( str [ j ] ) ] == True : NEW_LINE INDENT count_len += 1 NEW_LINE DEDENT if count_len > max_len : NEW_LINE INDENT min_len = count_len NEW_LINE start += 1 NEW_LINE DEDENT DEDENT return str [ start ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " aabbbcbcba " NEW_LINE print ( " Smallest ▁ window ▁ all ▁ found ▁ all ▁ found " , findSubStr ( str ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE def main ( ) : NEW_LINE INDENT for i in range ( 100 ) : NEW_LINE INDENT for j in range ( 100 ) : NEW_LINE INDENT for k in range ( 100 ) : NEW_LINE INDENT for k in range ( 100 ) : NEW_LINE INDENT for k in range ( 100 ) : NEW_LINE INDENT for k in range ( 100 * i , 100 ) : NEW_LINE INDENT for k in range ( 100 * i + k ) : NEW_LINE INDENT for k in range ( 100 * i , 100 * k + k ) : NEW_LINE INDENT if k * ( 100 + k * j ) + k * ( 100 + k * i ) + k * ( 100 + k * i ) + k * ( 100 + k * i ) + k * ( 100 + k * i ) > d : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( * d , sep = ' \n ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( lst ) : NEW_LINE INDENT result = [ ] NEW_LINE for line in sys . stdin : NEW_LINE INDENT x = line . split ( " , " ) NEW_LINE result . append ( x ) NEW_LINE DEDENT result . sort ( ) NEW_LINE return result [ 0 ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT lst = input ( ) . strip ( " , " ) NEW_LINE result = solve ( lst ) NEW_LINE print ( result ) NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT even = 0 ; NEW_LINE odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT print ( even * ( n - 1 ) ) ; NEW_LINE print ( odd * ( n - 1 ) ) ; NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE countPairs ( arr , n ) ; NEW_LINE
import math NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x1 , x2 , x2 , x3 , x4 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if x1 > x2 : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif x1 > x2 : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif x1 > x2 : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( input ( ) ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT s . add ( input ( ) ) NEW_LINE if ( s [ i ] == ' S ' ) : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT DEDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT print ( len ( s ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( len ( s ) ) NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT front = 0 ; NEW_LINE b = n - 1 ; NEW_LINE while ( front <= b ) : NEW_LINE INDENT if ( arr [ front ] == x or arr [ back ] == x ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT front += 1 ; NEW_LINE b -= 1 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 20 , 80 , 30 , 40 , 100 , 100 , 100 ] ; NEW_LINE x = 130 ; NEW_LINE if ( search ( arr , n , x ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def countFreq ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if mp [ arr [ i ] ] != - 1 : NEW_LINE INDENT print ( arr [ i ] , - 1 ) NEW_LINE mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 10 , 10 , 10 , 10 , 10 , 10 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE
import sys NEW_LINE def MinCostTree ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE st . append ( sys . maxsize ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( st ) - 1 ) : NEW_LINE INDENT x = st [ len ( st ) - 1 ] NEW_LINE st . pop ( ) NEW_LINE st . pop ( ) NEW_LINE ans += x * min ( st [ len ( st ) - 1 ] , arr [ i ] ) NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 2 , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] * st [ i - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MinCost ( arr , n ) ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE YesNo = lambda b : bool ( [ print ( ' Yes ' ) ] if b else print ( ' No ' ) ) NEW_LINE YESNO = lambda b : bool ( [ print ( ' YES ' ) ] if b else print ( ' NO ' ) ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE t = input ( ) NEW_LINE t1 = input ( ) NEW_LINE t2 = input ( ) NEW_LINE t2 = input ( ) NEW_LINE t2 = input ( ) NEW_LINE t1 = input ( ) NEW_LINE t2 = input ( ) NEW_LINE t1 = input ( ) NEW_LINE t2 = input ( ) NEW_LINE t2 = input ( ) NEW_LINE t1 = t1 . find ( t1 , t2 ) NEW_LINE t2 = t2 . find ( t2 , t2 ) NEW_LINE t2 = t1 . find ( t1 , t2 ) NEW_LINE t2 = t2 . find ( t2 , t3 ) NEW_LINE t3 = t1 . find ( t1 , t2 ) NEW_LINE t3 = t3 . find ( t3 , t3 ) NEW_LINE if t3 == t3 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( t1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def findEquation ( a , b ) : NEW_LINE INDENT sum = ( a + b ) NEW_LINE product = ( a * b ) ( a + b ) NEW_LINE print ( " x ▁ = ▁ " , findEquation ( a , b ) , " + " , ▁ ( " , product ) ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE findEquation ( a , b ) NEW_LINE
def circle_equation ( x1 , y1 , r1 ) : NEW_LINE INDENT a = - 2 * x1 - ( x1 * x1 ) - ( y1 * x1 ) NEW_LINE c = ( r * r1 ) - ( x1 * x1 ) - ( y1 * x1 ) NEW_LINE print ( " x ^ ( x ^ 2 ) + " , " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 , y1 = 2 , - 3 NEW_LINE circle_equation ( x1 , y1 , x2 ) NEW_LINE DEDENT
def unique_combination ( l , sum , K , A , K , A , A , K ) : NEW_LINE INDENT if ( sum == K ) : NEW_LINE INDENT print ( " { } ▁ " . format ( l ) , end = " " ) NEW_LINE for i in range ( 0 , len ( A ) ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT print ( " , end = " " ) NEW_LINE DEDENT if ( i != len ( A ) - 1 ) : NEW_LINE INDENT print ( " , end = " " ) NEW_LINE DEDENT if ( i != len ( A ) - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i != len ( A ) - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( sum + A [ i ] > K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i != len ( A ) - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT l = A [ 0 ] NEW_LINE A [ 0 ] = A [ len ( A ) - 1 ] NEW_LINE A [ 0 ] = A [ len ( A ) - 1 ] NEW_LINE A [ 0 ] = A [ len ( A ) - 1 ] NEW_LINE DEDENT def unique_combination ( A , K , A , K , A , K , A ) : NEW_LINE INDENT if ( A + A [ i ] == K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = A [ 0 ] NEW_LINE A [ i ] = A [ i ] NEW_LINE A [ i ] = A [ i - 1 ] NEW_LINE A [ i ] = A [ i ] NEW_LINE A [ i ] = A [ i ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = [ 10 , 1 , 7 , 7 , 1 , 5 , 5 ] NEW_LINE A = [ 10 , 1 , 7 , 6 ] NEW_LINE K = unique_combination ( 0 , K , A , K , A , K , A , A ) NEW_LINE unique_combination ( 0 , K , A ,
import sys NEW_LINE input = sys . stdin . readline NEW_LINE from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT c = Counter ( a ) NEW_LINE if c [ c [ c [ c [ c [ c [ c ] ] ] ] ] == c [ c [ c [ c [ c [ c [ c [ c ] ] ] ] ] ] : NEW_LINE INDENT print ( c [ c [ c [ c [ c [ c [ c [ c [ c [ c ] ] ] ] ] ] ] + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c [ c [ c [ c [ c [ c [ c [ c [ c [ c [ c [ c ] ] ] ] ] ] ] ] ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( 1 , 26 ) : NEW_LINE INDENT if s [ i ] in ' that ' : NEW_LINE INDENT a . append ( s [ i : i ] ) NEW_LINE DEDENT DEDENT a . sort ( ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] in a : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def findNature ( a , b , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return True if ( a & 1 ) else False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return True if ( b & 1 ) else False NEW_LINE DEDENT if ( ( a & 1 ) == 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n - 1 ) % 3 != 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return ( ( n + 1 ) % 3 != 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) % 3 != 0 ) NEW_LINE DEDENT DEDENT DEDENT a = 2 NEW_LINE b = 4 NEW_LINE n = 3 NEW_LINE if ( findNature ( a , b , n ) ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT
while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : break NEW_LINE mx = b - a NEW_LINE for i in range ( 0 , a - 1 ) : NEW_LINE INDENT mx = abs ( mx - i ) NEW_LINE mx = abs ( mx - mx ) NEW_LINE mx = abs ( mx - mx ) NEW_LINE DEDENT print ( mx ) NEW_LINE DEDENT
def max_sum ( a , n ) : NEW_LINE INDENT dp = [ 0 ] * ( n ) NEW_LINE if n == 1 : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE dp [ 0 ] = max ( a [ 1 ] , dp [ 0 ] ) NEW_LINE dp [ 1 ] = max ( a [ 0 ] , a [ 0 ] ) NEW_LINE dp [ 2 ] = max ( a [ 1 ] , a [ 0 ] ) NEW_LINE dp [ 2 ] = max ( a [ 1 ] , a [ 0 ] ) NEW_LINE DEDENT return dp [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , - 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( max_sum ( arr , n ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE if " A " in s or " E " in s or " E " in s or " E " in s or " E " in s or " E " in s or " I " in s or " E " in s or " I " in s or " O " in s or " in s or " O " in s or " in s or " O " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s or " in s in s ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
import sys NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT mini = sys . maxsize ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT fir = i ; NEW_LINE sec = n / i ; NEW_LINE res = ( sec // k + sec ) * ( sec // k ) * ( sec // k ) ; NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num , mini ) ; NEW_LINE DEDENT DEDENT DEDENT return mini ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 ; k = 6 ; NEW_LINE print ( minimumX ( n , k ) ) ; NEW_LINE n = 6 ; NEW_LINE k = 6 ; NEW_LINE print ( minimumX ( n , k ) ) ; NEW_LINE DEDENT
import sys NEW_LINE def get_ints ( ) : return map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def get_string ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N = get_string ( ) NEW_LINE F = get_string ( ) NEW_LINE F = set ( ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT F . add_string ( ) NEW_LINE DEDENT DEDENT for case in range ( 1 , T + 1 ) : NEW_LINE INDENT if F [ case ] == 0 : NEW_LINE INDENT print ( " Case ▁ # % d : ▁ % s " % ( case , case , " % ( case , case , " % case ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Case ▁ # % d " % ( case , case , case , " % case , case ) ) ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE
def sellingPrice ( CP , P ) : NEW_LINE INDENT P_dec = 1 + ( P // 100 ) NEW_LINE res = P_dec * CP NEW_LINE return res NEW_LINE DEDENT C = 12 NEW_LINE P = 13 NEW_LINE print ( sellingPrice ( C , P ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ a [ i ] - a [ i ] ] = a [ i ] NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] < b [ i ] ) : NEW_LINE INDENT b [ i ] = b [ i ] NEW_LINE DEDENT DEDENT print ( '1' ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE from collections import defaultdict NEW_LINE from heapq import heappop , heappush NEW_LINE from math import ceil , ceil , floor NEW_LINE def I ( ) : return int ( input ( ) ) NEW_LINE def MI ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def LI_ ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def LF ( ) : return list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE def LS ( ) : return list ( input ( ) . split ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def IR ( n ) : return [ I ( ) for i in range ( n ) ] NEW_LINE def LIR ( n ) : return [ LI ( ) for i in range ( n ) ] NEW_LINE def SR ( n ) : return [ S ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE def LSR ( n ) : return [ LS ( ) for i in range ( n ) ] NEW_LINE mod = 1000000007 NEW_LINE inf = float ( " inf " ) NEW_LINE n , s = MI ( ) NEW_LINE if n < s : NEW_LINE INDENT print ( - 1 ) NEW_LINE quit ( ) NEW_LINE DEDENT if n < s : NEW_LINE INDENT print ( - 1 ) NEW_LINE quit ( ) NEW_LINE DEDENT for i in range ( 1 , 10 ** 6 + 1 ) : NEW_LINE INDENT if n - s >= i : NEW_LINE INDENT print ( i ) NEW_LINE quit ( ) NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE def f ( x , y ) : NEW_LINE INDENT return x * y // ( - 1 ) * y // ( x + 1 ) NEW_LINE DEDENT print ( f ( x , y ) ) NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE m = 10 NEW_LINE check ( n , m ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] == a [ j ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( a - b , a - b ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] in s : NEW_LINE INDENT s [ 1 ] = s [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT s [ 1 ] = s [ 0 ] NEW_LINE DEDENT DEDENT print ( ' ' . join ( s ) ) NEW_LINE
def findNthOccur ( str , ch , N ) : NEW_LINE INDENT occur = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT occur += 1 NEW_LINE DEDENT if ( occur == N ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT str = " geeks " NEW_LINE ch = " e " NEW_LINE N = 2 NEW_LINE print ( findNthOccur ( str , ch , N ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if a in b : NEW_LINE INDENT print ( " Anton " ) NEW_LINE DEDENT elif a in b : NEW_LINE INDENT print ( " Danik " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Friendship " ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE count = eulerlib . sqrt ( LIMIT ) NEW_LINE ans = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT count = LIMIT // i NEW_LINE ans = ( LIMIT - ( i + 1 ) * count ) % mod NEW_LINE ans = ( ans + count ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT def comb_search ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = ( LIMIT - i + 1 ) // ( i + 1 ) NEW_LINE ans += comb ( i * count , i ) NEW_LINE ans %= mod NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k , z = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( k - 2 * i ) % 2 == 0 : NEW_LINE INDENT ans = max ( ans , a [ i ] + a [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , a [ i ] + a [ i + 1 ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i + 1 ] - a [ i ] ) > ( b [ i + 1 ] - a [ i ] ) : NEW_LINE INDENT b . append ( i + 1 ) NEW_LINE c = i NEW_LINE DEDENT DEDENT if ( a [ - 1 ] == b [ - 2 ] and a [ - 1 ] == b [ - 2 ] ) : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( a [ - 1 ] == b [ 0 ] and a [ - 1 ] == b [ - 2 ] ) : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE B = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT B . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT C = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for k in range ( N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if C [ i ] [ j ] <= C [ k ] [ k ] and C [ i ] [ j ] <= C [ k ] [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from collections import Counter NEW_LINE while 1 : NEW_LINE INDENT n , p = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT p = a [ i ] NEW_LINE if p == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT a [ p ] += 1 NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = a [ i ] + a [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if b [ i ] > a [ i ] : NEW_LINE INDENT b [ i ] = b [ i ] - a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = a [ i ] - b [ i ] NEW_LINE DEDENT DEDENT for i in range ( q ) : NEW_LINE INDENT c = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if b [ i ] > a [ j ] : NEW_LINE INDENT c += b [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT c += b [ i ] NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( b > a ) : NEW_LINE INDENT print ( ( b - a ) // 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( b - a ) // 10 ) + 1 ) NEW_LINE DEDENT DEDENT
from math import ceil NEW_LINE maxSize = 100e5 NEW_LINE prefix = [ 0 ] * ( maxSize + 5 ) NEW_LINE prefix [ 0 ] = 1 NEW_LINE prefix [ 1 ] = 1 NEW_LINE def generateFibonacci ( num ) : NEW_LINE INDENT global prefix NEW_LINE global prefix NEW_LINE global prefix NEW_LINE global prefix NEW_LINE global prefix NEW_LINE while ( num ) : NEW_LINE INDENT temp = sum + prev NEW_LINE if ( temp < maxSize ) : NEW_LINE INDENT temp = temp + prev NEW_LINE DEDENT prev = num NEW_LINE DEDENT return prefix [ i ] NEW_LINE DEDENT def generateFibonacci ( k ) : NEW_LINE INDENT generateFib ( i ) NEW_LINE for i in range ( 1 , maxSize ) : NEW_LINE INDENT sum = digit + prev [ i ] NEW_LINE if ( isFib [ sum ] ) : NEW_LINE INDENT prefix [ i ] += 1 NEW_LINE DEDENT prev = prefix [ i ] + prefix [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , maxSize ) : NEW_LINE INDENT sum = digitSum ( i ) NEW_LINE if ( isFib [ sum ] and sum % k == 0 ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , maxSize ) : NEW_LINE INDENT prefix [ i ] = prefix [ i ] + prefix [ i - 1 ] NEW_LINE DEDENT DEDENT def performQueries ( k , q , q ) : NEW_LINE INDENT prefix [ q ] = prefix [ q ] - prefix [ q - 1 ] NEW_LINE for i in range ( 1 , q ) : NEW_LINE INDENT prefix [ i ] = prefix [ i ] - prefix [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , q ) : NEW_LINE INDENT prefix [ i ] = prefix [ i ] - prefix [ i - 1 ] NEW_LINE DEDENT DEDENT q = 2 NEW_LINE q = 2 NEW_LINE q = 2 NEW_LINE q = 2 NEW_LINE q = 2 NEW_LINE for q in q : NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if ( a [ i ] > b [ i + 1 ] and b [ i ] < b [ i + 1 ] ) : NEW_LINE INDENT ans += abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def isPalindrome ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE for i in range ( l // 2 ) : NEW_LINE INDENT if ( str [ i ] != str [ l - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT sub = " " NEW_LINE res = " " NEW_LINE sum = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT digit = N % 10 NEW_LINE sum += digit NEW_LINE N = N // 10 NEW_LINE DEDENT while ( len ( res ) > sum ) : NEW_LINE INDENT res += sub NEW_LINE DEDENT if ( len ( res ) > sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 101 NEW_LINE if ( createStringAndPalindrome ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT l = list ( input ( ) . split ( ) ) NEW_LINE l . sort ( ) NEW_LINE l . reverse ( ) NEW_LINE if l [ 0 ] == l [ 1 ] : NEW_LINE INDENT print ( " H " , l [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " D " , l [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
def sum_even_index ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 5 , 6 , 12 , 1 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Sum ▁ of ▁ even ▁ even ▁ even ▁ numbers ▁ is " , sum_even_index ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT a . append ( s [ i ] ) NEW_LINE DEDENT DEDENT if a . count ( s [ - 1 ] ) == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT fl = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % n ) >= 2 * n : NEW_LINE INDENT if ( arr [ i ] % n ) : NEW_LINE INDENT print ( arr [ i ] % n , end = " ▁ " ) ; NEW_LINE f = 1 ; NEW_LINE DEDENT DEDENT if ( f > 0 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT DEDENT if ( fl > 0 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT DEDENT arr = [ 1 , 6 , 3 , 6 , 6 ] ; NEW_LINE arr_size = len ( arr ) ; NEW_LINE printDuplicates ( arr , arr_size ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( 1 / ( n - i ) ) NEW_LINE DEDENT print ( res ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) // 3 NEW_LINE DEDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE
def maxhand ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT n = 10 NEW_LINE print ( maxhand ( n ) ) NEW_LINE
def grayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( grayCode ( n ) ) NEW_LINE
def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) / 2 NEW_LINE DEDENT n = 8 NEW_LINE print ( Max_Sum ( n ) ) NEW_LINE
def possibleways ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( n % 4 == 0 ) : NEW_LINE INDENT return n / 4 - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 ; NEW_LINE DEDENT DEDENT n = 20 ; NEW_LINE print ( possibleways ( n ) ) ; NEW_LINE
def CountSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( n & 1 ) == 1 ) : NEW_LINE INDENT return 1 + CountSetBits ( n >> 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return CountSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT n = 21 NEW_LINE print ( CountSetBits ( n ) ) NEW_LINE
def sum ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m + 4 NEW_LINE DEDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( sum ( m , n ) ) NEW_LINE
def SUM ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) // 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) // 2 NEW_LINE return sum * ( sum + ( sum + 1 ) // 2 ) NEW_LINE DEDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( " SUM ( " , n , " , ▁ , " , SUM ( n , m ) ) " , " , SUM ( n , m ) ) NEW_LINE
def maxLCM ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( maxLCM ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) * ( n + 2 ) ) // 12 NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def cntWays ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) // 4 NEW_LINE DEDENT DEDENT n = 18 NEW_LINE print ( cntWays ( n ) ) NEW_LINE
def find_composite ( n ) : NEW_LINE INDENT print ( 9 * n ) NEW_LINE DEDENT n = 4 NEW_LINE find_composite ( n ) NEW_LINE
def find3Digit ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 6 if ( n & 1 ) else 6 NEW_LINE DEDENT n = 7 NEW_LINE print ( find3Digit ( n ) ) NEW_LINE
def countMaxIntersection ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) / 2 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( countMaxIntersection ( n ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n + 1 ) + sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE
def highestPowerPower ( n ) : NEW_LINE INDENT return ( n & ( ~ ( ~ ( ~ ( ~ ( n - 1 ) ) ) ) ) ) NEW_LINE DEDENT n = 48 NEW_LINE print ( highestPower ( n ) ) NEW_LINE
def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) / 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntersections ( n ) ) NEW_LINE
s = input ( ) NEW_LINE if " a " in s or " b " in s or " c " in s : NEW_LINE INDENT print ( " Not " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if len ( a ) == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] % a [ 0 ] != 0 : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
R = int ( input ( ) ) NEW_LINE if R < 1200 : NEW_LINE INDENT print ( " ABC " ) NEW_LINE DEDENT elif R < 1200 : NEW_LINE INDENT print ( " ARC " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ARC " ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if w [ i ] == 0 : NEW_LINE INDENT ans . append ( w [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( w [ i ] ) NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans . append ( ans [ i ] ) NEW_LINE DEDENT print ( " ▁ " . join ( ans ) ) NEW_LINE
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x != 0 and y != 0 ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT x , y , z = 12 , 15 , 5 NEW_LINE print ( " Minimum ▁ of ▁ 3 ▁ is " , smallest ( x , y , z ) ) NEW_LINE
c = [ int ( input ( ) ) for _ in range ( 5 ) ] NEW_LINE c [ 5 , 5 , 10 , 5 , 5 , 5 ] NEW_LINE c [ 7 , 10 , 10 , 10 ] = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if c [ 5 ] + c [ 5 ] >= 10 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT
import math NEW_LINE def solution ( m , r ) : NEW_LINE INDENT result = ( 2 * m * ( m - 1 ) ** 0.5 ) ** 0.5 NEW_LINE return result NEW_LINE DEDENT m , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( solution ( m , r ) ) NEW_LINE
def countCubes ( a , b ) : NEW_LINE INDENT return ( floor ( b ** ( a ) ) - ceil ( b ** ( a ) ) + 1 ) NEW_LINE DEDENT a = 7 NEW_LINE b = 28 NEW_LINE print ( " Count ▁ of ▁ cube ▁ is " , countCubes ( a , b ) ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def solve ( d , n ) : NEW_LINE INDENT dp = [ [ INF ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT a , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE a -= e NEW_LINE b -= e NEW_LINE if not ( b <= e ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT dp = [ [ - 1 ] * n for _ in range ( n ) ] NEW_LINE if dp [ 0 ] [ 0 ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for line in sys . stdin : NEW_LINE INDENT a , b , e , f = map ( int , line . split ( ) ) NEW_LINE a -= b NEW_LINE b -= e NEW_LINE if not ( fp [ 0 ] [ a ] ) : NEW_LINE INDENT print ( ' NA ' ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT result = 0 NEW_LINE for i in itertools . count ( 1 ) : NEW_LINE INDENT if i ** 2 < eulerlib . count ( 1 ) : NEW_LINE INDENT result += i ** 2 NEW_LINE DEDENT DEDENT if result > 5000000 : NEW_LINE INDENT return str ( result ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findDiff ( a , b , c , d ) : NEW_LINE INDENT return ( b * c - a * d ) / ( d - a * c ) NEW_LINE DEDENT a = 3 NEW_LINE b = 3 NEW_LINE c = 3 NEW_LINE d = 5 NEW_LINE print ( " \n " , findDiff ( a , b , c , d ) ) NEW_LINE
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def findPrimePair ( n , isPrimeOfEratosthenes ( n ) : NEW_LINE INDENT isPrime [ n ] = False NEW_LINE SieveOfEratosthenes ( n , isPrimeOfEratosthenes ( n , isPrime [ n - i ] ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPrime [ i ] and isPrime [ n - i ] ) : NEW_LINE INDENT print ( i , n - i ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT n = 7 NEW_LINE findPrimePair ( n , isPrimePair ( n , isPrimePair ( n , isPrimePair ( n , isPrime ) ) ) NEW_LINE
def replaceDigit ( x , d1 , d2 ) : NEW_LINE INDENT result = 0 NEW_LINE multiply = 1 NEW_LINE while ( x % 10 ) : NEW_LINE INDENT remainder = x % 10 NEW_LINE if ( remainder == d1 ) : NEW_LINE INDENT result = result + remainder * multiply * multiply NEW_LINE DEDENT multiply * multiply NEW_LINE DEDENT return result NEW_LINE DEDENT x = 645 NEW_LINE d1 = 6 NEW_LINE d2 = 6 NEW_LINE print ( replaceDigit ( x , d1 , d2 ) ) NEW_LINE
def printPattern ( i , j , n ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT if ( i == j or j == n - 1 ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT print ( " / " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " / " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " / " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " / " , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT
def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in hm . keys ( ) : NEW_LINE INDENT hm [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT dup_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hm [ i ] in hm . keys ( ) ) : NEW_LINE INDENT dup_count += hm [ sum - arr [ i ] ] NEW_LINE DEDENT if ( sum - arr [ i ] == arr [ i ] ) : NEW_LINE INDENT dup_count -= 1 NEW_LINE DEDENT DEDENT return dup_count // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sum = 6 NEW_LINE print ( " Count ▁ of ▁ pairs ▁ is " , getPairsCount ( sum ) ) NEW_LINE DEDENT
def Count_subarray ( arr , n ) : NEW_LINE INDENT subarray = 0 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT subarray_sum = 0 ; NEW_LINE remaining_sum = 0 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT subarray_sum += arr [ k ] ; NEW_LINE DEDENT for l in range ( i , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Count_subarray ( arr , n ) ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( x + b ) <= a : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - 1 + x - 1 + n - x ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE if ( s % 10 != 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( s % 10 != 0 ) : NEW_LINE INDENT s = s - a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT s = s - a [ i ] NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = min ( a ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] == a [ k ] : NEW_LINE INDENT ans = min ( ans , len ( a ) - k + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import math NEW_LINE def findRepeatingNumber ( arr , n ) : NEW_LINE INDENT q = int ( math . sqrt ( n ) ) + 1 NEW_LINE count = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT m = dict ( ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( ( count [ i ] > q ) and ( arr [ i ] > q ) ) : NEW_LINE INDENT m [ arr [ i ] ] = i NEW_LINE break NEW_LINE DEDENT DEDENT m . sort ( ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( ( ( ( number [ i ] ) < ( ( ( number [ i ] ) ) * q ) ) ) ) : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE if ( ( m [ i ] <= ( ( ( number [ i ] + 1 ) * q ) ) ) ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 , 5 , 4 ] NEW_LINE n = 5 NEW_LINE print ( " One ▁ of ▁ numbers ▁ of ▁ repeated ▁ of ▁ repeated ▁ of ▁ repeated ▁ is " , findRepeatingNumber ( arr , n ) ) NEW_LINE DEDENT
import math NEW_LINE def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT maxPrime = 2 NEW_LINE n >>= 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maxPrime = i NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT return maxPrime NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE n = 25.666635 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( even > odd ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( even , even ) ) NEW_LINE DEDENT DEDENT
s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT ans += 2 * ( len ( s ) - i - 1 ) NEW_LINE DEDENT elif s [ i ] == '1' : NEW_LINE INDENT ans += 2 * ( len ( s ) - i - 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def pythiggment ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * j ) : NEW_LINE INDENT print ( i , " , " , " , " , j , " , " , " , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 10 NEW_LINE pythigiggment ( n ) NEW_LINE
import math NEW_LINE def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . log10 ( abs ( a ) + math . log10 ( b ) ) + 1 NEW_LINE DEDENT a = 33 NEW_LINE b = - 24 NEW_LINE print ( countDigits ( a , b ) ) NEW_LINE
def indexOfFirstOne ( arr , low , high ) : NEW_LINE INDENT mid = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] == 1 and ( mid == 0 or arr [ mid - 1 ] == 0 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( arr [ mid ] == 1 and arr [ mid - 1 ] == 0 ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return indexOfFirstOne ( arr , l , h ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 0 , 0 , 1 , 1 , 1 ] NEW_LINE h = 1 NEW_LINE print ( " Index ▁ = ▁ " , indexOfFirstOneOne ( arr , h , h ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE print ( ( n // 2 + 1 ) * ( n // 2 - 1 ) // 2 + n // 2 ) NEW_LINE
import sys NEW_LINE from itertools import product NEW_LINE from collections import deque NEW_LINE def solve ( n ) : NEW_LINE INDENT ans = " " NEW_LINE while n > 0 : NEW_LINE INDENT n = n % 256 NEW_LINE ans += " " NEW_LINE n //= 256 NEW_LINE DEDENT if ans == 0 : NEW_LINE INDENT return " NA " NEW_LINE DEDENT ans = " " NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT ans += "0" NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( n ) NEW_LINE if ans : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE rem = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 ; NEW_LINE sum += rem ; NEW_LINE n //= 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def findX ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( i + digSum ( i ) == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT n = 43 ; NEW_LINE print ( " x ▁ = ▁ " , findX ( n ) ) ; NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = N - A . count ( A [ 0 ] ) NEW_LINE cnt = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if A [ i ] == A [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT ans = max ( ans , cnt ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a - b + c ) NEW_LINE
def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for q in range ( q ) : NEW_LINE INDENT L = int ( input ( ) ) NEW_LINE R = int ( input ( ) ) NEW_LINE if ( L != R and pref_xor [ R ] == pref_xor [ R ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 1 , 2 , 1 ] NEW_LINE q = [ 1 , 2 , 2 , 1 ] NEW_LINE q = [ 1 , 2 , 2 ] NEW_LINE performQueries ( A , q ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( l [ i ] >= i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
from math import ceil NEW_LINE n = int ( input ( ) ) NEW_LINE a1 , a2 , b2 = map ( int , input ( ) . split ( ) ) NEW_LINE p1 , p2 = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE p = q [ 0 ] NEW_LINE q = q [ 1 ] NEW_LINE p = q [ 0 ] NEW_LINE q = q [ 1 ] NEW_LINE r = q [ 1 ] NEW_LINE p = q [ 2 ] NEW_LINE q = q [ 2 ] NEW_LINE r = q [ 2 ] NEW_LINE q = q [ 2 ] NEW_LINE r = q [ 2 ] NEW_LINE k = q [ 2 ] NEW_LINE p = q [ 2 ] NEW_LINE q = q [ 2 ] NEW_LINE r = q [ 2 ] NEW_LINE q = q [ 2 ] NEW_LINE r = q [ 2 ] NEW_LINE k = q [ 2 ] NEW_LINE r = q [ 2 ] NEW_LINE k = q [ 3 ] NEW_LINE p = q [ 3 ] NEW_LINE q = q [ 2 ] NEW_LINE r = q [ 2 ] NEW_LINE q = q [ 3 ] NEW_LINE r = q [ 3 ] NEW_LINE k = q [ 3 ] NEW_LINE r = q [ 3 ] NEW_LINE k = r [ 4 ] NEW_LINE p = q [ 3 ] NEW_LINE q = q [ 3 ] NEW_LINE r = q [ 4 ] NEW_LINE q = q [ 4 ] NEW_LINE r = q [ 4 ] NEW_LINE q = q [ 4 ] NEW_LINE r = q [ 2 ] NEW_LINE q = q [ 2 ] NEW_LINE r = q [ 2 ] NEW_LINE q = q [ 3 ] NEW_LINE r = q [ 4 ] NEW_LINE q = q [ 2 ] NEW_LINE q = q [ 4 ] NEW_LINE r = q [ 4 ] NEW_LINE q = q [ 2 ] NEW_LINE r = q [
def trapeziumPattern ( num ) : NEW_LINE INDENT firsthalf = 1 NEW_LINE secondhalf = ( num * num ) + 1 NEW_LINE numOfMiddle = 0 NEW_LINE for num in range ( numOfMiddle ) : NEW_LINE INDENT print ( f " ▁ " , end = " " ) NEW_LINE DEDENT for num in range ( 1 , numOfMiddle ) : NEW_LINE INDENT print ( f " ▁ " , end = " " ) NEW_LINE DEDENT for halfCounter in range ( 1 , numOfMiddle ) : NEW_LINE INDENT if ( halfhalf == numOfMiddle ) : NEW_LINE INDENT print ( f " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( f " * " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT trapeziumPattern ( 3 ) NEW_LINE num = trapeziumPattern ( 3 ) NEW_LINE print ( " * " , end = " " ) NEW_LINE numOfMiddleSquare = ( ( int ) ( numOfMiddleSquare ) - ( ( int ( n ) - 1 ) * 2 ) ) NEW_LINE print ( numOfMiddleSquare ) NEW_LINE numOfMiddleSquare = ( ( int ( ( ( n ) - 1 ) * 2 ) ) - ( ( ( int ( numOfSquare ) * 2 ) ) ) - ( ( int ( ( n - 1 ) * 2 ) ) ) NEW_LINE numOfMiddleSquare = ( ( int ( ( ( n - 1 ) * 2 ) ) - ( ( ( int ( ( n - 1 ) * 2 ) ) ) * 2 ) ) NEW_LINE numOfMiddleSquare = ( ( int ( ( ( n - 1 ) * 2 ) ) ) - ( ( int ( ( n - 1 ) * 2 ) ) ) NEW_LINE numOfMiddleSquare = ( int ( ( ( ( n - 1 ) * 2 ) ) ) - ( ( int ( ( ( n - 1 ) * 2 ) ) ) ) ) NEW_LINE numOfSquare = ( ( int ( ( ( n - 1 ) * 2 ) ) - ( ( ( int ( ( n ) ) * 2 ) ) ) ) NEW_LINE numOfSquare
def findPerm ( n , changes ) : NEW_LINE INDENT ans = [ 0 ] * n NEW_LINE ans . sort ( ) NEW_LINE ans = [ 0 ] * n NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT diff = changes [ i ] + diff NEW_LINE ans . append ( x ) NEW_LINE DEDENT ans = - 1 NEW_LINE for i in ans : NEW_LINE INDENT ans . append ( ans [ i ] - ans [ i - 1 ] ) NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT ans = [ ] NEW_LINE j = 1 NEW_LINE for i in ans : NEW_LINE INDENT res . append ( i ) NEW_LINE j += 1 NEW_LINE DEDENT for i in ans : NEW_LINE INDENT m = ans [ i ] NEW_LINE j += 1 NEW_LINE DEDENT print ( * m ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT findPerm ( 2 ) NEW_LINE DEDENT
import math NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n / i NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return ( count ) NEW_LINE DEDENT def printKPrimes ( k , n ) : NEW_LINE INDENT for num in range ( 1 , n + 1 ) : NEW_LINE INDENT if countPrimeFactors ( num ) == k : NEW_LINE INDENT print ( num , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE k = 2 NEW_LINE printKPrimes ( k , " ▁ " , n , " - prime ▁ numbers ▁ numbers ▁ : ▁ " , k , " - prime ▁ numbers ▁ : ▁ " , k , " - numbers ▁ numbers : ▁ " , k ) NEW_LINE DEDENT
def solve ( N , K ) : NEW_LINE INDENT composite = [ 0 ] * ( 50 ) NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT if ( j >= i ) : NEW_LINE INDENT composite [ j ] += composite [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return composite [ N ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 28 NEW_LINE K = 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( n ) : NEW_LINE INDENT x = abs ( n [ 0 ] ) NEW_LINE while len ( x ) > 0 : NEW_LINE INDENT x = x [ - 1 ] NEW_LINE DEDENT while len ( x ) > 1 : NEW_LINE INDENT x = x [ - 1 ] NEW_LINE DEDENT return x NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT x = str ( n ) NEW_LINE while len ( x ) > 0 : NEW_LINE INDENT x = str ( x [ 0 ] ) NEW_LINE DEDENT if len ( x ) == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT x = abs ( x ) NEW_LINE while len ( x ) > 1 : NEW_LINE INDENT x = x [ - 1 ] NEW_LINE if x [ - 1 ] == 0 : NEW_LINE INDENT x = x [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT x = x [ - 1 ] NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT while True : NEW_LINE INDENT n = input ( ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT solve ( n ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def normal ( m , n ) : NEW_LINE INDENT N = ( int ) ( sqrt ( abs ( m ) * abs ( n ) ) / sqrt ( abs ( n ) * abs ( n ) + abs ( n ) ) ) NEW_LINE return N NEW_LINE DEDENT m = - 5 NEW_LINE n = 3 NEW_LINE print ( int ( normal ( m , n ) ) ) NEW_LINE
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = h / n NEW_LINE print ( x , end = ' ▁ ' ) NEW_LINE DEDENT
def countBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT i = 65 NEW_LINE print ( countBits ( i ) ) NEW_LINE
H , W , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( H // A ) * ( W // A ) - ( H // A ) * B ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT a , b = b , a % b NEW_LINE DEDENT return a NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] % c [ 0 ] == 0 : NEW_LINE INDENT c . append ( i ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] % c [ 0 ] == 0 : NEW_LINE INDENT ans += c [ i ] - a [ i - 1 ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT arr2 = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr2 [ i ] = arr [ i ] % k NEW_LINE DEDENT max_length = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_length = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr2 [ j ] == arr2 [ i ] ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max_length = max ( max_length , current_length ) NEW_LINE i = j NEW_LINE j = j NEW_LINE DEDENT return max_length NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 9 , 7 , 18 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE k = 11 NEW_LINE print ( LongestSubarray ( arr , n , k ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT print ( m + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m - 1 ) NEW_LINE DEDENT
def isHeterSum ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != ' ▁ ' ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " test ▁ big ▁ with ▁ full ▁ with ▁ full ▁ of ▁ full ▁ complement ▁ of " ) ; NEW_LINE n = len ( s ) ; NEW_LINE if ( isHeterSum ( s , n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO ▁ of ▁ Digig ▁ complement ▁ of ▁ all ▁ with ▁ all ▁ is " ) ; NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT ans = " " NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT ans += str ( i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def FindPoint ( x1 , y1 , x2 , y2 , x2 , y2 ) : NEW_LINE INDENT if ( x > x1 and x < y2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 8 NEW_LINE y2 = 8 NEW_LINE if ( FindPoint ( x1 , y1 , x2 , y2 , x2 , y2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import numpy as np NEW_LINE EPS = 10000 ; NEW_LINE def countPoints ( n , points ) : NEW_LINE INDENT minx = np . zeros ( ( n + 1 ) , sys . maxsize ) ; NEW_LINE minx = np . zeros ( ( n + 1 ) , np . int ) ; NEW_LINE maxy = np . zeros ( ( n + 1 ) , np . int ) ; NEW_LINE maxy = np . zeros ( ( n + 1 ) , np . int ) ; NEW_LINE maxy = np . zeros ( ( n + 1 ) , np . int ) ; NEW_LINE xy = np . zeros ( ( n + 1 ) , np . int ) ; NEW_LINE maxx = np . zeros ( ( ( n + 1 ) , axis = np . int ) ) ; NEW_LINE maxy = np . zeros ( ( ( - 1 , - 1 ) , x ) ) ; NEW_LINE maxy = np . zeros ( ( ( - 1 , - 1 ) , x ) ; NEW_LINE maxy = np . zeros ( ( ( - 1 , - 1 ) , x ) ) ; NEW_LINE maxy = np . zeros ( ( ( - 1 , - 1 ) , ( - 1 , - 1 ) , x ) ; NEW_LINE maxy = np . zeros ( ( ( - 1 , - 1 ) , x ) ) ; NEW_LINE return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT points = [ 0 , 0 , 1 ] ; NEW_LINE n = len ( points ) ; NEW_LINE print ( countPoints ( n , points ) ) ; NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT X , Y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 1 NEW_LINE while X > 0 : NEW_LINE INDENT X *= 2 NEW_LINE ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
sticks = [ 6 , 2 , 5 , 5 , 5 , 7 , 6 , 7 , 7 , 6 , 7 , 7 ] NEW_LINE n = len ( st ) NEW_LINE print ( countSticks ( st , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i - 1 ] < a [ i ] : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE a [ i ] , a [ i - 1 ] = a [ i ] , a [ i - 1 ] NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE print ( * ans ) NEW_LINE DEDENT
def compute ( arr , n ) : NEW_LINE INDENT arr [ 0 ] ^= 1 NEW_LINE arr [ 0 ] ^= 1 NEW_LINE DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT result = result ( arr , 1 ) NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT if arr [ k ] == 1 : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result [ k ] NEW_LINE DEDENT DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT result ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE compute ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = arr [ 0 ] NEW_LINE res = arr [ 0 ] NEW_LINE curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count += 1 NEW_LINE res = arr [ i ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 1 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( mostFrequent ( arr , n ) ) NEW_LINE DEDENT
MAX = 26 ; NEW_LINE def maxLength ( string , length ) : NEW_LINE INDENT res = 0 ; NEW_LINE lastPos = [ - 1 ] * MAX ; NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT lastPos [ i ] = - ord ( ' a ' ) ; NEW_LINE if ( lastPos [ CPos ] != - 1 ) : NEW_LINE INDENT res = max ( res , len ( string ) - ( i - lastPos [ CPos ] - 1 ) ) ; NEW_LINE DEDENT lastPos [ CPos ] = i ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " ; NEW_LINE len = len ( string ) ; NEW_LINE print ( maxLength ( string , len ) ) ; NEW_LINE DEDENT
MAX = 1000000 NEW_LINE def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 NEW_LINE DEDENT for j in range ( 1 , MAX ) : NEW_LINE INDENT if ( b [ j ] != 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k != 1 ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 1 NEW_LINE arr = [ 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ksmallest ( arr , n , k ) ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT d = n % 10 NEW_LINE while ( n // 10 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT N = 2795 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT d = n % 10 NEW_LINE while ( n // 10 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return ( n % 44 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 59 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT d = n % 10 NEW_LINE while ( d // 10 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n = abs ( d - ( d * 3 ) ) NEW_LINE n = n % 3 NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 22 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT d = n % 10 NEW_LINE while ( ( n // 10 ) <= 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n = abs ( d ) NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return ( n % 71 == 0 ) NEW_LINE DEDENT N = 50 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def Odd_Sum ( n ) : NEW_LINE INDENT total = ( n + 1 ) // 2 NEW_LINE even = total * ( n - 1 ) NEW_LINE return even NEW_LINE DEDENT def Sum_sum ( n ) : NEW_LINE INDENT odd = ( n + 1 ) // 2 NEW_LINE even = odd * ( n - 1 ) NEW_LINE even = even_sum ( L - 1 ) NEW_LINE return even_sum ( even ) NEW_LINE DEDENT L = 1 NEW_LINE R = 5 NEW_LINE print ( Sum_sum ( R , R ) ) NEW_LINE
def isRatioPossible ( low , upCost , downCost , downCap , upCap , downCap , upCap , upCap , upCap , upCap , upCap ) : NEW_LINE INDENT for i in range ( upCap + 1 , downCap ) : NEW_LINE INDENT if ( low <= upCapCost and ans <= upCap ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT lowCost = 14 NEW_LINE upCost = 30 NEW_LINE upCap = 5 NEW_LINE upCap = 5 NEW_LINE if ( isRatioPossible ( lowCost , upCap , upCap , upCap ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( math . ceil ( ( math . log ( n ) / math . log ( 2 ) ) ) == ( math . ceil ( math . log ( n ) / math . log ( 2 ) ) ) ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000 NEW_LINE primes = eulerlib . list_primes ( LIMIT ) NEW_LINE ans = sum ( primes ) NEW_LINE for i in primes : NEW_LINE INDENT q = 1 NEW_LINE for p in primes : NEW_LINE INDENT q = 1 NEW_LINE for q in primes : NEW_LINE INDENT q = q * p NEW_LINE if q <= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if q + q <= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT q = q * q NEW_LINE for x in primes : NEW_LINE INDENT q = q * p NEW_LINE if q <= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT r = q * q NEW_LINE for x in primes : NEW_LINE INDENT if x + r <= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT r = q * q NEW_LINE for x in primes : NEW_LINE INDENT if x + r <= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT r = r + r NEW_LINE for x in primes : NEW_LINE INDENT if x + r <= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT r = r + r NEW_LINE x = sum ( r ) NEW_LINE for x in r : NEW_LINE INDENT if x + r <= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT r = x + r NEW_LINE x = sum ( r ) NEW_LINE for x in r : NEW_LINE INDENT if x + r <= LIMIT : NEW_LINE INDENT x = x + r NEW_LINE DEDENT DEDENT r = sum ( r ) NEW_LINE x = sum ( r ) NEW_LINE x = sum ( r ) NEW_LINE DEDENT DEDENT ans = ans + sum ( ans ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def longestLenSub ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT len1 = 0 NEW_LINE if ( um [ i ] - 1 in um and um [ i ] - 1 in um ) : NEW_LINE INDENT len1 = um [ i ] - 1 NEW_LINE if ( len1 < um [ i ] + 1 ) : NEW_LINE INDENT len1 = um [ i ] NEW_LINE DEDENT if ( len1 < um [ i ] + 1 ) : NEW_LINE INDENT len1 = um [ i ] NEW_LINE DEDENT um [ i ] = len1 NEW_LINE if ( len1 < um [ i ] + 1 ) : NEW_LINE INDENT len1 = um [ i ] NEW_LINE DEDENT um [ i ] = len1 NEW_LINE if ( len1 < um [ i ] ) : NEW_LINE INDENT len1 = um [ i ] NEW_LINE DEDENT um [ i ] = um [ i ] NEW_LINE if ( len1 < um [ i ] ) : NEW_LINE INDENT len1 = um [ i ] NEW_LINE DEDENT DEDENT return len1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Longest ▁ length ▁ subsequence ▁ subsequence ▁ = " , longestLenSub ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE
def maxDiff ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = diff NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if ( curr_sum > 0 ) : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT arr = [ 80 , 2 , 6 , 3 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , n ) ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT MOD = 10 ** 9 + 7 NEW_LINE N = len ( readline ( ) ) NEW_LINE S = [ 0 ] * N NEW_LINE dp = [ 0 ] * N NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if S [ i ] == ' # ' : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 1 ] ) % MOD NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if S [ i ] == ' # ' : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 1 ] ) % MOD NEW_LINE DEDENT DEDENT write ( " % MOD ) NEW_LINE return 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT S = readline ( ) NEW_LINE N = len ( S ) NEW_LINE if S == ' # ' : NEW_LINE INDENT return solve ( ) NEW_LINE DEDENT else : NEW_LINE INDENT write ( " % MOD ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT num = ( ( n // 2 ) + 1 ) ; NEW_LINE max = n % num ; NEW_LINE count = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n ; NEW_LINE if ( val == max ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( countPairs ( n ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if l == r : NEW_LINE INDENT print ( s [ l - 1 ] - s [ r - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ r - 1 ] - s [ l - 1 ] ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT c = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT c [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT c [ n ] = c [ 0 ] = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT c [ i ] = c [ i - 1 ] - c [ i ] NEW_LINE DEDENT ans = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if c [ i ] - c [ i - 1 ] > 1 : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans if ans else - 1 ) NEW_LINE DEDENT
MAX = 100000 ; NEW_LINE def print ( g1 , g2 , g2 , n ) : NEW_LINE INDENT for i in range ( 0 , A ) : NEW_LINE INDENT print ( g1 [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( " a ▁ " ) ; NEW_LINE for i in range ( 0 , B ) : NEW_LINE INDENT print ( g1 [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT def check ( g , g , g , g , n ) : NEW_LINE INDENT for i in range ( 0 , A ) : NEW_LINE INDENT for j in range ( 0 , A ) : NEW_LINE INDENT if ( g - g [ i ] , g [ j ] ) : NEW_LINE INDENT print ( g1 [ g ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT g = [ 0 ] * ( g + 1 ) ; NEW_LINE g = [ 0 ] * ( g + 1 ) ; NEW_LINE find ( g1 , g , g , g + 1 , g + 1 , g + 1 ) ; NEW_LINE g . sort ( reverse = True ) ; NEW_LINE find ( g , g , g , g , n ) ; NEW_LINE g . sort ( reverse = True ) ; NEW_LINE g = g ; NEW_LINE find ( g , g , g , g , n ) ; NEW_LINE g = find ( g , g , g , g , g + 1 , g + 1 , g + 1 ) ; NEW_LINE find ( g , g , g , g , g , n ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT d [ i + a ] = max ( d [ i ] , d [ i + b ] + 1 ) NEW_LINE DEDENT print ( d [ n ] ) NEW_LINE
def maxSubseq ( vec , n ) : NEW_LINE INDENT suffix = 0 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( vec [ i ] == 1 ) : NEW_LINE INDENT suffix += 1 ; NEW_LINE DEDENT DEDENT res = 0 ; NEW_LINE zero = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vec [ i ] == 0 ) : NEW_LINE INDENT zero += 1 ; NEW_LINE DEDENT if ( vec [ i ] > 0 ) : NEW_LINE INDENT res = max ( res , zero + vec [ i ] ) ; NEW_LINE DEDENT DEDENT return max ( res , zero + vec [ i ] ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = [ 0 , 1 , 0 , 1 , 1 ] ; NEW_LINE n = len ( input ) ; NEW_LINE print ( maxSubseq ( input , n ) ) ; NEW_LINE DEDENT
R = 4 NEW_LINE C = 4 NEW_LINE def countPaths ( maze ) : NEW_LINE INDENT if ( maze [ 0 ] [ 0 ] == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT if ( maze [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , C ) : NEW_LINE INDENT if ( maze [ i - 1 ] [ 0 ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , C ) : NEW_LINE INDENT if ( maze [ i - 1 ] [ j ] > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( maze [ i ] [ j ] > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( maze [ i - 1 ] [ j ] > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( maze [ i ] [ j ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i - 1 ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( maze [ R - 1 ] [ j ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( maze [ R - 1 ] [ C - 1 ] [ C - 1 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT matrix = [ [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 ] ] NEW_LINE print ( countPaths ( matrix ) ) NEW_LINE DEDENT
from math import sqrt , ceil , sqrt , gcd , gcd NEW_LINE def isPrime ( N ) : NEW_LINE INDENT isPrime = True NEW_LINE arr = [ 7 , 11 , 13 , 19 , 23 , 23 , 29 , 31 , 23 , 29 , 31 ] NEW_LINE if ( N < 2 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT for i in range ( 0 , sqrt ( N ) ) : NEW_LINE INDENT if ( N % ( ceil ( N ) ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if ( N % ( ceil ( N / ( c + i ) ) ) == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( isPrime ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( isPrime ) : NEW_LINE INDENT print ( " Prime ▁ Number ▁ Number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Prime ▁ Number ▁ Prime ▁ Number " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 121 NEW_LINE isPrime ( N ) NEW_LINE DEDENT
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x1 , y1 = map ( int , input ( ) . split ( ) ) NEW_LINE y1 , y1 = x1 + y1 - x2 , y2 - y1 NEW_LINE print ( x1 , y1 , y2 ) NEW_LINE
def max ( x , y ) : NEW_LINE INDENT if ( x == y ) : NEW_LINE INDENT return x NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( x == z ) and i + 1 == j ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( x [ i ] == x ) and i + 1 == j ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return max ( lps ( l , i + 1 , j - 1 ) , lps ( lps ( i , j - 1 ) , lps ( i + 1 , j - 1 ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ the ▁ of ▁ the ▁ LEEKS " , " is ▁ of " , lps ( seq ) ) NEW_LINE DEDENT
def findLength ( str , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT l = i NEW_LINE r = i + 1 NEW_LINE lsum = 0 NEW_LINE rsum = 0 NEW_LINE while ( r < n and lsum < 0 ) : NEW_LINE INDENT lsum += ord ( str [ r ] ) - ord ( '0' ) NEW_LINE rsum += ord ( '0' ) NEW_LINE if ( lsum == rsum ) : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT lsum = rsum NEW_LINE rsum = rsum NEW_LINE DEDENT lsum = rsum NEW_LINE rsum = rsum NEW_LINE DEDENT return ans NEW_LINE DEDENT str = "123" NEW_LINE print ( " Length ▁ of ▁ the ▁ substring ▁ is " , findLength ( str , str ) ) NEW_LINE
def print ( a , n , ind ) : NEW_LINE INDENT for i in range ( ind , n + 1 ) : NEW_LINE INDENT print ( a [ i % n ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ " A " , " B " , " C " , " D " , " E " ] NEW_LINE n = 6 NEW_LINE print ( a , n ) NEW_LINE
def print ( a , n , ind ) : NEW_LINE INDENT b = [ 0 ] * ( 2 * n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ n ] = b [ n + i ] NEW_LINE DEDENT for i in range ( ind ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ " A " , " B " , " C " , " D " ] NEW_LINE n = 6 NEW_LINE print ( a , n , 3 ) NEW_LINE
n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE if a > b : NEW_LINE INDENT ans += b - a NEW_LINE DEDENT else : NEW_LINE INDENT ans += a - b NEW_LINE DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE input = sys . stdin . readline NEW_LINE from collections import Counter NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE d = defaultdict ( list ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE d [ x ] . append ( y ) NEW_LINE d [ y ] . append ( x ) NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT d [ i ] . append ( i ) NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT d [ i ] . append ( d [ i ] ) NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT d [ i ] . append ( d [ i ] ) NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( " " . join ( d [ i ] ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE V , V , T , D = map ( int , input ( ) . split ( ) ) NEW_LINE if V == 2 : NEW_LINE INDENT print ( V + V ) NEW_LINE exit ( ) NEW_LINE DEDENT if V == 2 : NEW_LINE INDENT print ( V + V ) NEW_LINE exit ( ) NEW_LINE DEDENT if V == 2 : NEW_LINE INDENT print ( V + V ) NEW_LINE exit ( ) NEW_LINE DEDENT if V == 2 : NEW_LINE INDENT print ( V + V ) NEW_LINE exit ( ) NEW_LINE DEDENT if V == 2 : NEW_LINE INDENT print ( V + V ) NEW_LINE exit ( ) NEW_LINE DEDENT if V == 2 : NEW_LINE INDENT print ( V + V ) NEW_LINE exit ( ) NEW_LINE DEDENT if V == 2 : NEW_LINE INDENT print ( V + V ) NEW_LINE exit ( ) NEW_LINE DEDENT if V == 2 : NEW_LINE INDENT print ( V + V ) NEW_LINE exit ( ) NEW_LINE DEDENT if V == 2 : NEW_LINE INDENT print ( V + V ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( V + V ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = sorted ( input ( ) ) NEW_LINE b = sorted ( input ( ) ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE k = 0 NEW_LINE while i < n and j < k : NEW_LINE INDENT if a [ i ] < b [ j ] : NEW_LINE INDENT k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT print ( k ) NEW_LINE
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE a , b , c = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ( a - b + c - a + c + 1 ) // 2 ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( * range ( n ) ) NEW_LINE DEDENT
def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 ) NEW_LINE DEDENT bin ( 13 ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1000 ) if i % 3 == 0 or i % 5 == 0 or i % 5 == 0 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE l = [ ] NEW_LINE for i in s : NEW_LINE INDENT if i == ' n ' : NEW_LINE INDENT l . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( 1 ) NEW_LINE DEDENT DEDENT l . sort ( ) NEW_LINE l . reverse ( ) NEW_LINE print ( * l ) NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT r , g = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE print ( r * 2 - r ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def Circular ( n ) : NEW_LINE INDENT Result = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT Result = Result * n NEW_LINE n -= 1 NEW_LINE DEDENT return Result NEW_LINE DEDENT n = 4 NEW_LINE print ( Circular ( n - 1 ) ) NEW_LINE
def productDiagonal ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] [ i ] NEW_LINE product = product * arr [ n - i - 1 ] [ n - i - 1 ] NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT product = product / arr [ n // 2 ] [ n // 2 ] NEW_LINE DEDENT return product NEW_LINE DEDENT arr1 = [ 1 , 2 , 3 , 7 , 1 , 2 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 2 , 2 , 1 , 2 , 2 ] , [ 2 , 2 , 1 , 2 , 2 ] , [ 2 , 2 , 1 , 2 , 2 ] , [ 2 , 2 , 1 , 2 , 2 ] , [ 2 , 2 , 1 , 2 , 1 , 2 ] , [ 2 , 2 , 2 , 1 , 2 ] , [ 2 , 2 , 2 , 2 , 1 ] ] NEW_LINE print ( productDiagonal ( arr1 , 4 ) ) NEW_LINE
import sys NEW_LINE def solve ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = int ( input ( ) ) NEW_LINE if c . count ( c ) == 1 : NEW_LINE INDENT ans . append ( ' - ' * ( c . count ( c . count ( c . count ( c . count ( c . count ( c . count ( c . count ( c . count ( '1' ) ) ) ) ) ) ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( ' - ' * ( c . count ( '1' ) ) ) NEW_LINE DEDENT DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( n ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
NO_OF_CHARS = 256 NEW_LINE def getSecondMostFrequency ( str ) : NEW_LINE INDENT count = [ 0 for i in range ( NO_OF_CHARS ) ] NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( 0 , NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] > count [ 1 ] and count [ i ] != count [ 1 ] ) : NEW_LINE INDENT second = i NEW_LINE first = i NEW_LINE DEDENT elif ( count [ i ] > count [ 1 ] and count [ i ] != count [ 1 ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return second NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE res = getSecondMostFrequency ( str ) NEW_LINE if ( res != " \n " ) : NEW_LINE INDENT print ( " No ▁ most ▁ frequent ▁ frequent ▁ frequency ▁ frequency ▁ Frequency " , res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ most ▁ frequent ▁ frequency ▁ Frequency " , res ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT C = [ 0 ] * 5 NEW_LINE C [ 0 ] = C [ 1 ] NEW_LINE dp = [ 0 ] * 5 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT for j in range ( i + 1 , i + 1 ) : NEW_LINE INDENT C [ i ] += C [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , 5 ) : NEW_LINE INDENT dp [ i ] += C [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , 5 ) : NEW_LINE INDENT dp [ i ] += dp [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , 5 ) : NEW_LINE INDENT dp [ i ] += dp [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , 5 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , 5 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 1 ] NEW_LINE DEDENT print ( dp [ 4 ] ) NEW_LINE DEDENT solve ( ) NEW_LINE
def mySort ( arr , n ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE sort . sort ( reverse = True ) NEW_LINE for i in range ( n // 2 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ n - 1 ] ) : NEW_LINE INDENT sort . reverse ( True ) NEW_LINE DEDENT DEDENT arr . sort ( reverse = True ) NEW_LINE print ( " Modified ▁ Array ▁ : " ) NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 2 , 9 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 ] NEW_LINE mySort ( arr , n ) NEW_LINE
def minflip ( arr1 , arr2 , p , q , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] > 0 or arr2 [ i ] > 0 ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT return flip if ( flip <= p + q ) else - 1 NEW_LINE DEDENT arr1 = [ 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE p = 2 NEW_LINE q = 2 NEW_LINE print ( minflip ( arr1 , arr2 , arr3 , p , q , q , n ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i NEW_LINE DEDENT return s NEW_LINE DEDENT n = 5 NEW_LINE print ( " Sum ▁ is " , sum ( n ) ) NEW_LINE
def bitonicGivenRange ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr . append ( n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 != 1 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE for j in range ( 0 , len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE DEDENT for j in range ( 0 , len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE DEDENT for i in range ( 0 , len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE DEDENT for j in range ( 0 , len ( evenArr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 6 , 7 , 7 , 7 , 2 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGivenRange ( arr , n ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE right = 0 ; NEW_LINE left = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT count += ( right - left ) ; NEW_LINE visited [ arr [ i ] ] = 1 ; NEW_LINE DEDENT while ( left < right and right != n and visited [ right ] ) : NEW_LINE INDENT count += ( right - left ) ; NEW_LINE right += 1 ; NEW_LINE right += 1 ; NEW_LINE DEDENT while ( left < right and visited [ right ] ) : NEW_LINE INDENT visited [ arr [ right ] ] = 0 ; NEW_LINE left += 1 ; NEW_LINE right += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPairs ( arr , n ) ) ; NEW_LINE DEDENT
class TreeNode : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . val = rootData NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def preorder ( self , t , left , right ) : NEW_LINE INDENT if t not in t : NEW_LINE INDENT return None NEW_LINE DEDENT self . right = preorder ( t ) NEW_LINE return self . preorder ( t , left , right ) NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def preorder ( self , t , left , right ) : NEW_LINE INDENT if t not in t : NEW_LINE INDENT return " r " NEW_LINE DEDENT return " r " NEW_LINE DEDENT def preorder ( t , left , right ) : NEW_LINE INDENT if t not in t : NEW_LINE INDENT return " r " NEW_LINE DEDENT return preorder ( t [ left ] , t [ right ] ) NEW_LINE DEDENT if t . left in t : NEW_LINE INDENT return " l " NEW_LINE DEDENT return preorder ( t [ left ] , t [ right ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE root = TreeNode ( 3 ) NEW_LINE root . left = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 4 ) NEW_LINE root . left = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 4 ) NEW_LINE root . preorder ( root , root ) NEW_LINE print ( root . preorder ( root , root , root ) ) NEW_LINE DED
M = 1001 NEW_LINE mod = 998244353 NEW_LINE def solve ( idx , diff , N , M , M , K ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ idx ] [ diff ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ diff ] NEW_LINE DEDENT ans = solve ( idx + 1 , diff , N , M , K ) NEW_LINE ans += ( M - 1 ) * solve ( M - 1 , N , M , K ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE K = 998244353 NEW_LINE ans = solve ( 2 , 0 , N , K , M , K ) NEW_LINE print ( M * ans % MOD ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT triRadius = [ i + 30 for i in range ( 20 ) ] NEW_LINE for i in range ( 0 , len ( triRadius ) ) : NEW_LINE INDENT triRadius [ i ] = ( i + 30 ) * 1000 NEW_LINE DEDENT minLength = 10 ** 9 NEW_LINE minLength = 10 ** 9 NEW_LINE for i in range ( 0 , len ( triRadius ) ) : NEW_LINE INDENT if triRadius [ i ] & ( 1 << i ) : NEW_LINE INDENT minLength = triRadius [ i ] + triRadius [ i ] NEW_LINE DEDENT DEDENT return min ( minLength , minLength ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ ] NEW_LINE for j in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ j ] == a [ j - 1 ] : NEW_LINE INDENT c . append ( a [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT c . append ( b [ j - 1 ] + a [ j - 2 ] ) NEW_LINE DEDENT DEDENT if c [ 0 ] == a [ 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def getTotalXorSubarrayXors ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT res ^= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorSubarrayXors ( arr , N ) ) NEW_LINE
def getTotalXorSubarrayXORXORXORXOR ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORX
l , p , q = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( p + q ) / ( p + q ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] > a [ j ] : NEW_LINE INDENT ans = j NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ 0 ] * 11 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT c [ a [ i ] ] += 1 NEW_LINE DEDENT elif ( a [ i ] < 0 ) : NEW_LINE INDENT c [ a [ i ] ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 11 ) : NEW_LINE INDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT ans += ( ( a [ i ] < 0 ) * ( a [ i ] > 0 ) ) NEW_LINE DEDENT elif ( a [ i ] < 0 ) : NEW_LINE INDENT ans += ( a [ i ] * ( a [ i ] - 1 ) ) // 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT s1 = " abcdefghijklmnopqrstuvwxyz " NEW_LINE s2 = " abcdefghijklmnopqrstuvwxyz " NEW_LINE s1 = s [ i ] NEW_LINE s2 = s [ i ] NEW_LINE s2 = s [ i ] NEW_LINE s2 = s [ i ] NEW_LINE s2 = s [ i ] NEW_LINE s3 = s [ i ] NEW_LINE s3 = s [ i ] NEW_LINE s3 = s [ i ] NEW_LINE s3 = s [ i ] NEW_LINE s4 = s [ i ] NEW_LINE s4 = s [ i ] NEW_LINE s4 = s [ i ] NEW_LINE s4 = s [ i ] NEW_LINE s4 = s [ i ] NEW_LINE s4 = s [ i ] NEW_LINE s4 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_LINE s7 = s [ i ] NEW_
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE cnt = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' W ' : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE DEDENT DEDENT cnt [ 0 ] = cnt [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' W ' : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE DEDENT DEDENT print ( min ( cnt ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE for i in a : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if odd > even : NEW_LINE INDENT print ( odd ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( even ) NEW_LINE DEDENT
import sys NEW_LINE from itertools import product NEW_LINE def is_prime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n // 2 , - 1 , - 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n // 2 , - 1 , - 1 ) : NEW_LINE INDENT if is_prime ( i ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT DEDENT def is_prime ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT DEDENT def is_prime ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return n // 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n // 2 + 1 NEW_LINE DEDENT DEDENT def is_prime ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return n // 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n // 2 + 1 NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE is_prime ( n ) NEW_LINE is_prime ( n ) NEW
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT
def powerOfTwo ( n ) : NEW_LINE INDENT return ( ( n & n - 1 ) == 0 ) NEW_LINE DEDENT def possibleFirstAndLastAre ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return powerOfTwo ( n - 1 ) NEW_LINE DEDENT n = 8 NEW_LINE if ( possibleFirstAndLastAreSet ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minimumCostOfNatural ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( ) NEW_LINE hz = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * Y [ j ] NEW_LINE hz += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hz NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT total += X [ i ] * hz NEW_LINE DEDENT total += total * hz NEW_LINE return total NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 6 NEW_LINE n = 4 NEW_LINE X = [ 4 , 1 , 1 ] NEW_LINE print ( minimumCostOfNatural ( X , Y , m , n - 1 , n - 1 ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT count = 0 NEW_LINE p = G * L NEW_LINE for a in range ( 1 , L + 1 ) : NEW_LINE INDENT if ( ( p % a == 0 ) and gcd ( a , p // a ) == G ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT G = 2 NEW_LINE print ( " Total ▁ possible ▁ pairs ▁ = ▁ " , countPairs ( G , L ) ) NEW_LINE print ( " Total ▁ pairs ▁ = ▁ " , countPairs ( G , L ) ) NEW_LINE
def multiply ( a , b ) : NEW_LINE INDENT mul = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] = 0 NEW_LINE for k in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ k ] += mul [ i ] [ k ] * b [ k ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] += mul [ i ] [ j ] [ k ] NEW_LINE DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT M [ i ] [ 0 ] = mul [ i ] [ 1 ] NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT a [ i ] [ j ] = mul [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def power ( F ) : NEW_LINE INDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] , [ 0 , 1 ] ] NEW_LINE if n % 2 != 0 : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT power ( F , N - 2 ) NEW_LINE return power ( F , M - 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( " F ( " , find ( 5 ) ) , find ( F ( n ) ) ) NEW_LINE
def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT temp = x NEW_LINE x = y NEW_LINE y = temp NEW_LINE DEDENT a = 1 NEW_LINE b = x - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT x = 10 NEW_LINE Y = 10 NEW_LINE MinimumValue ( x , y ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def checkPossible ( self , nums ) : NEW_LINE INDENT oddPoint = 0 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] > nums [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT if i - 1 >= 0 or nums [ i - 1 ] <= nums [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT if i - 1 >= 0 or nums [ i - 1 ] <= nums [ i + 1 ] : NEW_LINE INDENT nums [ i ] = nums [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i ] = nums [ i + 1 ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 4 , 2 , 3 ] NEW_LINE out = sObj . checkPossible ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def check ( mid , array , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( array [ i ] > mid ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += array [ i ] NEW_LINE if ( sum > mid ) : NEW_LINE INDENT count += 1 NEW_LINE sum = array [ i ] NEW_LINE sum = array [ i ] NEW_LINE DEDENT DEDENT count += 1 NEW_LINE if ( count <= K ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def solve ( array , n , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT end += array [ i ] NEW_LINE if ( check ( mid , array , array , n , K ) ) : NEW_LINE INDENT answer = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid - 1 NEW_LINE end = mid - 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT array = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( array ) NEW_LINE K = 3 NEW_LINE print ( solve ( array , n , K ) ) NEW_LINE
import sys NEW_LINE from itertools import product NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( m , n ) : NEW_LINE INDENT a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if a [ 0 ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) ] NEW_LINE for a in a : NEW_LINE INDENT b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE dp [ b [ i ] ] = 1 NEW_LINE DEDENT ans = 0 NEW_LINE def dfs ( x , y , x , dp ) : NEW_LINE INDENT if dp [ x ] < y : NEW_LINE INDENT if dp [ y ] < 0 : NEW_LINE INDENT dp [ y ] = y NEW_LINE DEDENT if dp [ y ] < 0 : NEW_LINE INDENT dp [ y ] = y NEW_LINE DEDENT DEDENT ans = dp [ y ] NEW_LINE return ans NEW_LINE DEDENT ans = solve ( m , n , m ) NEW_LINE if ans : NEW_LINE INDENT print ( dfs ( m , n , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a + b ) ** 2 > ( a + b ) ** 2 : NEW_LINE INDENT print ( ( a + b ) ** 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = ' YES ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] - a [ i ] > b [ i ] : NEW_LINE INDENT ans = ' NO ' NEW_LINE break NEW_LINE DEDENT DEDENT if ans == ' YES ' : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) NEW_LINE if ( N [ - 1 ] == '0' or N [ - 1 ] == '0' or N [ - 1 ] == '0' ) : NEW_LINE INDENT return ( " Even " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Even " , end = " " ) NEW_LINE DEDENT DEDENT N = "7" NEW_LINE print ( even_or_odd ( N ) ) NEW_LINE
from collections import deque NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE v = deque ( ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT query = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if query [ 0 ] == 0 : NEW_LINE INDENT v . append ( query [ 1 ] ) NEW_LINE DEDENT elif query [ 0 ] == 1 : NEW_LINE INDENT v . append ( query [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( query [ 1 ] ) NEW_LINE DEDENT DEDENT for _ in range ( q ) : NEW_LINE INDENT query = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if query [ 0 ] == 0 : NEW_LINE INDENT v . popleft ( ) NEW_LINE print ( v ) NEW_LINE DEDENT elif query [ 1 ] == 1 : NEW_LINE INDENT v . pop ( ) NEW_LINE DEDENT elif query [ 0 ] == 2 : NEW_LINE INDENT v . pop ( ) NEW_LINE print ( v ) NEW_LINE DEDENT else : NEW_LINE INDENT v . pop ( ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if odd == 1 : NEW_LINE INDENT print ( even ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( even ) NEW_LINE DEDENT
def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + abs ( X [ i - 1 ] - Y [ i - 1 ] ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( count [ i ] - count [ j - 1 ] > K ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return max ( ans , i - j ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE Y = " abcd " NEW_LINE print ( solve ( X , Y , N , K ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE g = gcd ( a , m ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT g = g % i NEW_LINE DEDENT if g == 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPrime ( n , i ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT n = 15 NEW_LINE if ( isPrime ( n , 2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minimumSum ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT n = 27 NEW_LINE print ( minimumSum ( n ) ) NEW_LINE
def isPrime ( x ) : NEW_LINE INDENT for i in range ( 2 , int ( x ** .5 ) + 1 ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minimumCost ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 1 and isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( n % 2 == 0 and isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT n = 6 NEW_LINE print ( minimumCost ( n ) ) NEW_LINE
def snoOven ( x ) : NEW_LINE INDENT rightOne = x & - x NEW_LINE nextOne = x ^ nextOne NEW_LINE nextOne = x ^ nextOne NEW_LINE if ( x > 0 ) : NEW_LINE INDENT rightOne = x + nextOne NEW_LINE rightOne = x ^ nextOne NEW_LINE DEDENT return nextOne NEW_LINE DEDENT x = 156 NEW_LINE print ( " Next ▁ of ▁ set ▁ set ▁ with ▁ set ▁ with ▁ set ▁ bits ▁ is ▁ " , snOne ) NEW_LINE
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , int ( 1 / j ) + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i / j == j ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i / j NEW_LINE DEDENT DEDENT DEDENT sum = sum - i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE
import sys NEW_LINE def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE result = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinLength ( arr , n ) ) NEW_LINE
def getLevensenven ( input ) : NEW_LINE INDENT rev = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE n = len ( input ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( input [ i - 1 ] == rev [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = min ( res , dp [ i ] [ i ] ) NEW_LINE if ( i > 0 ) : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ i ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = " myvengeek " NEW_LINE print ( getLevensen ( input ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 120000 NEW_LINE LIMIT = 120000 NEW_LINE def factorize ( n , k ) : NEW_LINE INDENT factors = [ ] NEW_LINE for i in range ( 2 , LIMIT * 2 ) : NEW_LINE INDENT factors . append ( i ) NEW_LINE factors . append ( min ( k , i , k ) ) NEW_LINE DEDENT DEDENT def factorize ( n , k , sum ) : NEW_LINE INDENT if sum ( factors [ k ] ) <= n : NEW_LINE INDENT if sum ( factors [ k ] ) <= n : NEW_LINE INDENT return n NEW_LINE DEDENT factors [ k ] = n NEW_LINE if sum ( factors [ k ] ) <= sum ) : NEW_LINE INDENT factors [ k ] = n NEW_LINE factors [ k ] = n NEW_LINE DEDENT DEDENT return sum ( factors ) NEW_LINE DEDENT def factorize ( n , k ) : NEW_LINE INDENT factors = set ( ) NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT factors . add ( n , i ) NEW_LINE factors . add ( i ) NEW_LINE DEDENT DEDENT def factorize ( n , k , sum ) : NEW_LINE INDENT if sum ( factors ) <= n : NEW_LINE INDENT return n NEW_LINE DEDENT factors . add ( n ) NEW_LINE return sum ( factors ) NEW_LINE DEDENT def factorize ( n , sum ) : NEW_LINE INDENT factors = set ( ) NEW_LINE for i in factors : NEW_LINE INDENT if sum ( n ) <= sum ( factors ) : NEW_LINE INDENT factors . add ( i ) NEW_LINE factors . add ( sum ( factors [ i ] ) , sum ( factors [ i ] ) ) NEW_LINE factors . add ( sum ( factors [ i ] ) ) NEW_LINE DEDENT DEDENT return sum ( factors ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N = int ( input ( ) ) NEW_LINE A = A [ 0 ] NEW_LINE M = 10 ** 9 + 7 NEW_LINE inv = [ 0 ] * ( N + 1 ) NEW_LINE inv [ 0 ] = M NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT inv [ i ] = inv [ i - 1 ] * inv [ i - 1 ] % MOD NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT inv [ i ] = inv [ i - 1 ] * inv [ i ] % MOD NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT inv [ i ] = inv [ i ] * inv [ i ] % MOD NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT inv [ i ] = inv [ i ] * inv [ i ] % MOD NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT inv [ i ] = inv [ i ] * inv [ i ] % MOD NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT inv [ i ] = inv [ i ] * inv [ i ] % MOD NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += inv [ i ] * inv [ i ] % MOD NEW_LINE inv [ i ] %= MOD NEW_LINE DEDENT print ( ans % MOD ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def reverseQueue ( q ) : NEW_LINE INDENT while len ( q ) > 0 : NEW_LINE INDENT print ( q [ - 1 ] , end = " ▁ " ) NEW_LINE q . pop ( ) NEW_LINE DEDENT DEDENT q = [ 100 , 100 , 100 , 100 , 100 , 100 , 100 , 100 ] NEW_LINE q . reverse ( ) NEW_LINE q . reverse ( ) NEW_LINE
MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findDiff ( arr , n ) : NEW_LINE INDENT min = MAX + 2 NEW_LINE max = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return max if ( max == - 1 ) else ( max - min ) NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 4 NEW_LINE arr = [ 1 , 2 , 3 , 5 ] NEW_LINE res = findDiff ( arr , n ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( " No ▁ prime ▁ numbers " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Impossible ▁ is " , res ) NEW_LINE DEDENT
from heapq import heappush , heappop NEW_LINE def main ( ) : NEW_LINE INDENT V = int ( input ( ) ) NEW_LINE while V : NEW_LINE INDENT V = [ [ 0 for i in range ( V ) ] for i in range ( V ) ] NEW_LINE if V [ V [ i ] [ 0 ] == 0 : NEW_LINE INDENT V [ i ] [ 1 ] = V [ i ] [ 1 ] // 100 NEW_LINE DEDENT else : NEW_LINE INDENT V [ i ] [ V [ i ] // 100 ] = V [ i ] [ 1 ] // 100 NEW_LINE V [ i ] [ V [ i ] ] = V [ i ] [ V [ i ] // 100 ] NEW_LINE DEDENT DEDENT V = [ [ INF for i in range ( V ) ] for i in range ( V ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT v , u , v = map ( int , input ( ) . split ( " , " ) ) NEW_LINE if v == V [ i ] : NEW_LINE INDENT V [ v ] [ v ] = V [ i ] [ v ] // 100 NEW_LINE DEDENT else : NEW_LINE INDENT V [ v ] [ v ] = V [ i ] [ v ] // 100 NEW_LINE DEDENT DEDENT V = [ [ INF for i in range ( V ) ] for i in range ( V ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT v , u , v = map ( int , input ( ) . split ( " , " ) ) NEW_LINE V [ v ] [ v ] = V [ v ] [ v ] // 100 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT if V [ i ] [ j ] == V [ i ] [ j ] : NEW_LINE INDENT V [ i ] [ j ] = V [ i ] // 100 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE print ( n * ( n // ( 1 + 1 ) ) ) NEW_LINE
def distinctSubstring ( P , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = [ False ] * ( ord ( P [ i ] ) - ord ( ' a ' ) ) NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = P [ j ] - ord ( ' a ' ) NEW_LINE S . add ( pos ) NEW_LINE S . add ( S [ j ] ) NEW_LINE S . add ( S [ j ] ) NEW_LINE S . add ( S [ j ] ) NEW_LINE S . add ( S [ j ] ) NEW_LINE DEDENT DEDENT return len ( S ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = " abba " NEW_LINE N = len ( S ) NEW_LINE print ( distinctSubstring ( S , N ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( n - k ) % ( k - 1 ) == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - k ) // ( k - 1 ) + 1 ) NEW_LINE DEDENT
import sys NEW_LINE def minimumAdjacentDifferenceDifference ( a , n , k ) : NEW_LINE INDENT minDiff = sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cnt = bin ( i ) . count ( '1' ) NEW_LINE if ( cnt == n - k ) : NEW_LINE INDENT temp = [ ] NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT temp . append ( a [ j ] ) NEW_LINE DEDENT DEDENT maxDiff = max ( minDiff , temp [ 0 ] - temp [ j ] ) NEW_LINE DEDENT minDiff = min ( minDiff , maxDiff ) NEW_LINE DEDENT return minDiff NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE a = [ 3 , 7 , 8 , 10 ] NEW_LINE print ( minimumAdjacentDifference ( a , n , k ) ) NEW_LINE DEDENT
def difference ( arr , n ) : NEW_LINE INDENT largest = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( largest < arr [ i ] ) : NEW_LINE INDENT largest = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = largest - arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 10 , 5 , 9 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE difference ( arr , n ) NEW_LINE
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * ( K ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ A [ i ] % K ] += 1 ; NEW_LINE DEDENT sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ; NEW_LINE for i in range ( 1 , ( K // 2 ) + 1 ) : NEW_LINE INDENT sum += ( freq [ i ] * freq [ K // 2 ] - 1 ) // 2 ; NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT sum += ( freq [ K // 2 ] * ( freq [ K // 2 ] - 1 ) // 2 ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT A = [ 2 , 2 , 1 , 7 , 5 ] ; NEW_LINE n = len ( A ) ; NEW_LINE K = 4 ; NEW_LINE print ( countKdivPairs ( A , n , K ) ) ; NEW_LINE
while True : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE if a == "0" : NEW_LINE INDENT break NEW_LINE DEDENT c = input ( ) NEW_LINE if a == "0" : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT DEDENT
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_index = 0 NEW_LINE prev_index_zero = - 1 NEW_LINE prev_index_zero = - 1 NEW_LINE prev_index_zero = - 1 NEW_LINE prev_index = - 1 NEW_LINE prev_index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT if ( cur_index - prev_index ) > prev_index : NEW_LINE INDENT max_index = prev_index NEW_LINE prev_index = prev_index NEW_LINE prev_index = prev_index NEW_LINE prev_index = prev_index NEW_LINE prev_index = prev_index NEW_LINE prev_index = prev_index NEW_LINE prev_index = prev_index NEW_LINE prev_index = prev_index NEW_LINE DEDENT prev_index = prev_index NEW_LINE prev_index = prev_index NEW_LINE DEDENT prev_index = prev_index NEW_LINE prev_index = prev_index NEW_LINE DEDENT if ( n - prev_index > max_index ) : NEW_LINE INDENT max_index = prev_index NEW_LINE DEDENT return max_index NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Index ▁ of ▁ 0 ▁ to ▁ is ▁ " , maxOnesIndex ( arr , n ) ) NEW_LINE
import sys NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for rem in range ( k - 1 , - 1 ) : NEW_LINE INDENT if ( n % rem == 0 ) : NEW_LINE INDENT ans = min ( ans , rem + ( n // rem ) * k ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT n = 4 ; k = 6 ; NEW_LINE print ( minimumX ( n , k ) ) ; NEW_LINE n = 6 ; NEW_LINE k = 6 ; NEW_LINE print ( minimumX ( n , k ) ) ; NEW_LINE
def moduloFactorial ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a %= mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( ( b & 1 ) ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a >>= 1 NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT a = 1014545484548483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648483648484836484836484836484836484836484848364848364848483648483648483648483648483648484836484848484848484848364
from collections import defaultdict NEW_LINE def dfs ( s ) : NEW_LINE INDENT visited = [ False ] * ( N + 1 ) NEW_LINE visited [ s ] = True NEW_LINE for c in s : NEW_LINE INDENT if c not in visited [ c ] : NEW_LINE INDENT visited [ c ] = True NEW_LINE DEDENT DEDENT return visited NEW_LINE DEDENT def solve ( N , S ) : NEW_LINE INDENT visited [ s ] = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT visited [ i ] = True NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if visited [ i ] : NEW_LINE INDENT if visited [ i ] : NEW_LINE INDENT visited [ i ] = True NEW_LINE DEDENT DEDENT DEDENT return visited NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( N , S ) NEW_LINE if ans == - 1 : NEW_LINE INDENT print ( " NG " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NG " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < b [ i ] : NEW_LINE INDENT b . append ( i + 1 ) NEW_LINE b . append ( i + 1 ) NEW_LINE DEDENT DEDENT b . sort ( ) NEW_LINE print ( len ( b ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( b [ i ] , b [ i - 1 ] ) NEW_LINE DEDENT
def checkPalindrome ( str ) : NEW_LINE INDENT len = len ( str ) NEW_LINE len1 = len ( str ) NEW_LINE for i in range ( 0 , len1 ) : NEW_LINE INDENT if ( str [ i ] != str [ len1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT len1 = len ( str1 ) NEW_LINE for i in range ( 0 , len1 ) : NEW_LINE INDENT print ( str1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findDiffings ( v , s , p , i ) : NEW_LINE INDENT l = [ ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT s = str [ i ] + s [ i ] NEW_LINE if ( ( len1 ) == l ) : NEW_LINE INDENT v . append ( s ) NEW_LINE if ( i + 1 < l ) : NEW_LINE INDENT v . append ( s ) NEW_LINE if ( i + 1 < l ) : NEW_LINE INDENT v . append ( s ) NEW_LINE DEDENT v . append ( v ) NEW_LINE DEDENT DEDENT DEDENT return v NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeks " NEW_LINE v = " geeks " NEW_LINE v = " geeks " NEW_LINE printSolution ( v ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE r , c1 , c2 , r1 , c2 = map ( int , input ( ) . split ( ) ) NEW_LINE def fact ( n , r , p1 , p2 ) : NEW_LINE INDENT return fact ( n * fact ( n - r1 ) ) // fact ( fact ( n - r1 ) ) NEW_LINE DEDENT def fact ( n , r , p1 , p2 ) : NEW_LINE INDENT return fact ( n * fact ( n - r1 ) // fact ( fact ( n - r1 ) ) NEW_LINE DEDENT def fact ( n , r1 , p2 , p2 , p2 , p3 ) : NEW_LINE INDENT if ( n - r1 ) % p == 0 : NEW_LINE INDENT return fact ( n * fact ( n - r1 ) // p1 , p2 ) % p NEW_LINE DEDENT else : NEW_LINE INDENT return fact ( fact ( n - r1 , p2 , p2 ) % p1 NEW_LINE DEDENT DEDENT r1 , r2 , p2 = map ( int , input ( ) . split ( ) ) NEW_LINE if r1 == r2 - r1 + c2 == r2 + c1 + c2 NEW_LINE if ( r1 == r2 + c1 ) : NEW_LINE INDENT print ( fact ( fact ( r1 + r2 , p1 , p2 ) ) % p ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( fact ( fact ( r1 + r1 , p2 , p2 ) % p ) ) NEW_LINE DEDENT
def findSubsequence ( arr , n , k ) : NEW_LINE INDENT M = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT M [ arr [ i ] ] += 1 NEW_LINE DEDENT numCount = dict ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] <= k ) : NEW_LINE INDENT for j in range ( 1 , i + 1 , k ) : NEW_LINE INDENT if ( arr [ i ] * i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT numCount = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( numCount [ i ] <= k ) : NEW_LINE INDENT length = numCount [ i ] NEW_LINE lcm = i NEW_LINE while ( lcm [ lcm ] <= length ) : NEW_LINE INDENT length = numCount [ lcm ] NEW_LINE lcm = i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( lcm == 0 ) : NEW_LINE INDENT print ( " LCM ▁ = " , lcm ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " LCM ▁ = " , lcm ) NEW_LINE DEDENT DEDENT n = len ( arr ) NEW_LINE k = 16 NEW_LINE size = 0 NEW_LINE length = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( numCount [ i ] == length ) : NEW_LINE INDENT length = numCount [ i ] NEW_LINE length = i NEW_LINE DEDENT else : NEW_LINE INDENT length = i NEW_LINE length = i NEW_LINE for j in range ( 1 , length + 1 ) : NEW_LINE INDENT if ( length [ j ] == length ) : NEW_LINE INDENT length = num NEW_LINE length = i NEW_LINE DEDENT DEDENT if ( length == 0 ) : NEW_LINE INDENT print ( " LCM ▁ = " , length , length , " ,
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , odd2 ) + min ( even1 , even2 ) NEW_LINE return pairs NEW_LINE DEDENT a = [ 9 , 14 , 6 , 7 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even2 = 0 NEW_LINE even2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , even2 ) + min ( odd2 , even1 ) NEW_LINE return pairs NEW_LINE DEDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE
def maxDiff ( arr , arr_size ) : NEW_LINE INDENT max_element = arr [ 0 ] - arr [ 0 ] NEW_LINE min_element = arr [ 0 ] - arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] - min_element > max_element ) : NEW_LINE INDENT max_element = arr [ i ] - min_element NEW_LINE DEDENT if ( arr [ i ] < min_element ) : NEW_LINE INDENT min_element = arr [ i ] - min_element NEW_LINE DEDENT DEDENT return max_element NEW_LINE DEDENT max = [ 1 , 2 , 6 , 80 ] NEW_LINE max = len ( maxDiff ( arr , max ) ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , max ) ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( findMax ( n , k ) ) NEW_LINE DEDENT
MAX = 26 ; NEW_LINE def minimumAddition ( freq , len ) : NEW_LINE INDENT max_ele = freq [ 0 ] ; NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT if ( max_ele < freq [ i ] ) : NEW_LINE INDENT max_ele = freq [ i ] ; NEW_LINE DEDENT DEDENT return max_ele ; NEW_LINE DEDENT def minimumAddition ( string , length ) : NEW_LINE INDENT freq = [ 0 ] * MAX ; NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT maxAddition = max ( freq ) ; NEW_LINE minAddition = 0 ; NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT minAddition += abs ( maxFreq [ i ] - freq [ i ] ) ; NEW_LINE DEDENT DEDENT return minAddition ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " ; NEW_LINE len = len ( string ) ; NEW_LINE print ( minimumAddition ( string , len ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if abs ( s [ i ] - s [ i ] ) > 5 : NEW_LINE INDENT l . append ( abs ( s [ i ] - s [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( abs ( s [ i ] - s [ i ] ) ) NEW_LINE DEDENT DEDENT print ( sum ( l ) ) NEW_LINE
MAX = 32 ; NEW_LINE def power_2 ( x ) : NEW_LINE INDENT set2 = [ x for x in x ] ; NEW_LINE ans = set2 ; NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x & ( x - 1 ) ; NEW_LINE set1 . add ( x ) ; NEW_LINE DEDENT return set1 ; NEW_LINE DEDENT def add ( num ) : NEW_LINE INDENT set2 = [ ] ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( num & ( x - 1 ) ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT set2 . add ( x ) ; NEW_LINE DEDENT DEDENT DEDENT def add ( num ) : NEW_LINE INDENT set2 = 0 ; NEW_LINE value = 0 ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( num % 2 == 1 ) : NEW_LINE INDENT value += ( 1 << i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( num % 2 ) : NEW_LINE INDENT value += ( 1 << i ) ; NEW_LINE DEDENT DEDENT DEDENT ans = add ( value ) ; NEW_LINE if ( pow2 [ count ] < n ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE return ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT add ( i ) ; NEW_LINE DEDENT DEDENT n = 3 ; NEW_LINE k = 5 ; NEW_LINE power_2 ( n , k ) ; NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = eulerlib . setrecursionlimit ( 10000 ) NEW_LINE for a in eulerlib . count_primes ( a ) : NEW_LINE INDENT for b in range ( - a + 1 , b + 1 ) : NEW_LINE INDENT num = num * a + b NEW_LINE if num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < 0 or num < eulerlib . add_primes ) NEW_LINE return str ( num ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k > n : NEW_LINE INDENT print ( ( k * ( n - k ) + 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( k * ( k + 1 ) ) // 2 ) NEW_LINE DEDENT DEDENT
MAX = 100001 NEW_LINE isPrime = [ 0 ] * ( MAX ) NEW_LINE def sieve ( ) : NEW_LINE INDENT p = [ 0 ] * ( MAX ) NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( isPrime [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT def findSubset ( a , n ) : NEW_LINE INDENT cnt1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT DEDENT if ( cnt1 > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] != 1 ) ) : NEW_LINE INDENT print ( cnt1 + 1 , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if ( cnt1 > 2 ) : NEW_LINE INDENT print ( cnt1 + 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] != 1 ) ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 100001 NEW_LINE findSubset ( a , n ) NEW_LINE DEDENT
n , r , t = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p = [ 0 ] * r NEW_LINE for i in range ( n ) : NEW_LINE INDENT p [ i ] = p [ i ] NEW_LINE DEDENT p [ i ] = 1 NEW_LINE for j in range ( 1 , r ) : NEW_LINE INDENT if p [ j ] > 0 : NEW_LINE INDENT p [ j ] += p [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT p [ j ] += p [ j ] NEW_LINE DEDENT DEDENT print ( sum ( p ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE if len ( s ) > 0 : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE DEDENT elif len ( s ) == 4 : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 1 ] ) NEW_LINE DEDENT DEDENT
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high == low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid == low and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid < low and arr [ mid + 1 ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) NEW_LINE DEDENT if ( arr [ high ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return countRotations ( arr , low , high - 1 , high ) NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , 0 , n - 1 ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k > n : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT m = ( k - n ) % n NEW_LINE if m < n : NEW_LINE INDENT print ( m ) NEW_LINE DEDENT else : NEW_LINE INDENT m = n NEW_LINE n = m NEW_LINE if m < n : NEW_LINE INDENT m = n NEW_LINE DEDENT else : NEW_LINE INDENT m = n NEW_LINE DEDENT print ( m ) NEW_LINE DEDENT DEDENT
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ i ] == 1 ) : NEW_LINE INDENT DP [ i ] = 1 NEW_LINE DEDENT DEDENT DP [ 0 ] = 1 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == 1 ) : NEW_LINE INDENT DP [ j ] = 1 NEW_LINE DEDENT DEDENT DP [ 0 ] = 1 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == 1 ) : NEW_LINE INDENT DP [ j ] = 1 NEW_LINE DEDENT DEDENT DP [ 0 ] = 1 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == 1 ) : NEW_LINE INDENT DP [ j ] = 1 NEW_LINE DEDENT DEDENT DP [ arr [ i ] % m ] = 1 NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT arr = [ 1 , 7 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE m = 5 NEW_LINE if ( modularSum ( arr , n , m ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT b , e , k = map ( int , input ( ) . split ( ) ) NEW_LINE if a [ b - 1 ] == k : NEW_LINE INDENT print ( len ( a ) ) NEW_LINE DEDENT DEDENT DEDENT
n , x = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] [ 0 ] < l [ i ] [ 1 ] : NEW_LINE INDENT ans += i * ( l [ i ] [ 0 ] - l [ i - 1 ] [ 0 ] ) NEW_LINE l [ i ] [ 0 ] = l [ i - 1 ] [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += i * ( l [ i ] [ 0 ] - 1 ) NEW_LINE l [ i ] [ 1 ] = l [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import heapq NEW_LINE from collections import deque NEW_LINE from enum import Enum NEW_LINE import sys NEW_LINE import math NEW_LINE from _heapq import heappush , heappop NEW_LINE import copy NEW_LINE BIG_NUM = 2000000000 NEW_LINE HUGE_NUM = 99999999999999999 NEW_LINE MOD = 1000000007 NEW_LINE EPS = 0.000000001 NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE MAX = 1000000007 NEW_LINE def solve ( ) : NEW_LINE INDENT dp = [ [ 0 ] * D for _ in range ( D ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( D ) : NEW_LINE INDENT for j in range ( D ) : NEW_LINE INDENT for k in range ( D ) : NEW_LINE INDENT for l in range ( D ) : NEW_LINE INDENT for l in range ( D ) : NEW_LINE INDENT if i == l + 1 or j == k + l - 1 or k == l + 1 or k == l + 1 or k == l + 1 : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT def solve ( ) : NEW_LINE INDENT dp = [ [ 0 ] * ( D + 1 ) for _ in range ( D + 1 ) ] NEW_LINE for i in range ( D + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 0 NEW_LINE for j in range ( D + 1 ) : NEW_LINE INDENT for k in range ( D + 1 ) : NEW_LINE INDENT for l in range ( D + 1 , D + 1 ) : NEW_LINE INDENT for l in range ( D + 1 , D + 1 ) : NEW_LINE INDENT for l in range ( D + 1 , D + 1 ) : NEW_LINE INDENT for l in range ( D + 1 , D + 1 ) : NEW_LINE INDENT for l in range ( D + 1 , D + 1 ) : NEW_LINE INDENT for l in range ( D + 1 , D +
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT a . sort ( ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def sum ( k , n ) : NEW_LINE INDENT sum = ( pow ( k , n + 1 , n + 1 ) - pow ( k - 1 , n + 1 ) ) NEW_LINE return sum NEW_LINE DEDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( sum ( K , n ) ) NEW_LINE
def solve ( i , tight ) : NEW_LINE INDENT if ( i == len ( q ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = dp [ i ] [ tight ] NEW_LINE if ( i == tight ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = dp [ i ] [ tight ] NEW_LINE if ( tight == 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = dp [ i ] [ tight ] NEW_LINE ndp = sum ( dp [ i ] [ 1 ] for i in range ( ndp ) ) NEW_LINE if ( tight == - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = 0 NEW_LINE ndp = sum ( dp [ i ] [ ndp ] for i in range ( ndp ) ) NEW_LINE ndp = sum ( dp [ i ] [ ndp ] for i in range ( ndp ) ) NEW_LINE ndp = sum ( dp [ i ] [ ndp ] for i in range ( ndp ) ) NEW_LINE ans += solve ( i + 1 , ndp , ndp ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT count = 0 NEW_LINE sum = 4 NEW_LINE print ( solve ( 0 , 0 , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( input ( ) ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( l [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE DEDENT DEDENT def evenOddLevel ( root ) : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE oddSum = 0 NEW_LINE oddSum = 0 NEW_LINE oddSum = 0 NEW_LINE oddSum = 0 NEW_LINE oddSum = 0 NEW_LINE oddSum = 0 NEW_LINE oddSum = 0 NEW_LINE oddSum = 0 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT size = q [ 0 ] NEW_LINE if ( level % 2 == 0 ) : NEW_LINE INDENT evenSum += tempSum NEW_LINE DEDENT else : NEW_LINE INDENT oddSum += tempSum NEW_LINE DEDENT if ( tempSum ) : NEW_LINE INDENT evenSum += tempSum NEW_LINE oddSum += tempSum NEW_LINE DEDENT else : NEW_LINE INDENT oddSum += tempSum NEW_LINE DEDENT DEDENT return oddSum - evenSum NEW_LINE DEDENT root = Node ( 2 ) NEW_LINE root . left = Node ( 1 ) NEW_LINE root . right = Node ( 1 ) NEW_LINE root . right = Node ( 1 ) NEW_LINE root . right . left = Node ( 2 ) NEW_LINE root . right . right = Node ( 3 ) NEW_LINE root . right . right = Node ( 3 ) NEW_LINE root . right . right = Node ( 3 ) NEW_LINE root . right . right . right . left = Node ( 7 ) NEW_LINE root . right . right . right . right . right . right . right = Node ( 7 ) NEW_LINE root . right . right . right . right . right = Node ( 7 ) NEW_LINE print ( " Difference ▁ of ▁ sum ▁ is " , evenSum ( root ) ) NEW_LINE
def countSubarrays ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE number = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number += ( count + 1 ) * ( count + 1 ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count != 0 ) : NEW_LINE INDENT number += ( count + 1 ) * ( count + 1 ) // 2 NEW_LINE DEDENT return number NEW_LINE DEDENT a = [ 3 , 4 , 5 , 6 , 7 , 10 ] NEW_LINE n = len ( a ) NEW_LINE k = 5 NEW_LINE print ( countSubarrays ( a , n , k ) ) NEW_LINE
def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE
def printLastOccurrence ( a , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if map [ a [ i ] ] == i : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT a = [ 1 , 5 , 5 , 1 , 6 , 1 ] NEW_LINE n = len ( a ) NEW_LINE printLastOccurrence ( a , n ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if int ( input ( ) ) == 1 : NEW_LINE INDENT if int ( input ( ) ) == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count == 0 : print ( " NA " ) NEW_LINE else : print ( " NA " ) NEW_LINE DEDENT DEDENT
def countPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return countPaths ( m - 1 , n - 1 ) + countPaths ( m , n - 1 ) NEW_LINE DEDENT n = 5 NEW_LINE m = 5 NEW_LINE print ( countPaths ( n , m ) ) NEW_LINE
def sum ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sum ( a , d , n ) ) NEW_LINE
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 0 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE
def coordinateCompression ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE m = dict ( ) NEW_LINE for i in s : NEW_LINE INDENT index [ arr [ i ] ] = i NEW_LINE DEDENT index = 0 NEW_LINE for i in s : NEW_LINE INDENT index += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT index += 1 NEW_LINE m [ i ] = m . index ( index [ i ] ) NEW_LINE DEDENT return s NEW_LINE DEDENT def update ( bitCompression , index , n ) : NEW_LINE INDENT x = query ( index - 1 ) NEW_LINE value = x + 1 NEW_LINE value = x + 1 NEW_LINE while index <= n : NEW_LINE INDENT BIT [ index ] = max ( BIT [ index ] , value ) NEW_LINE index -= index & ( - index & ( - index ) - index ) NEW_LINE index -= index & ( - index & ( - index & ( - index ) - index ) ) NEW_LINE index += index & ( - index & ( - index & ( - index ) - index ) ) NEW_LINE index += index & ( - index & ( - index & ( - index ) - index ) ) NEW_LINE index += index & ( - index & ( - index & ( - index ) ) ) NEW_LINE DEDENT ans = query ( index ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 5 , 1 , 2 , 8 , 7 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE ans = find ( arr , n ) NEW_LINE print ( ans ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE b = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] == 1 : NEW_LINE INDENT b [ i ] [ 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] [ 1 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] == 1 : NEW_LINE INDENT b [ i ] [ 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] [ 1 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if b [ i ] [ 0 ] == 1 : NEW_LINE INDENT b [ i ] [ 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] [ 1 ] += 1 NEW_LINE DEDENT DEDENT if b [ i ] [ 0 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 3 NEW_LINE MAX_SITS = 3 NEW_LINE ans = sum ( [ 0 for i in range ( DIGITS + 1 ) ] for i in range ( DIGITS + 1 ) ] ) NEW_LINE ans = sum ( ans [ : 2 ] ) NEW_LINE def digitSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if digitSum ( i ) : NEW_LINE INDENT ans += n NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE def main ( ) : NEW_LINE INDENT S = input ( ) NEW_LINE S = input ( ) NEW_LINE S = input ( ) NEW_LINE if S [ 0 ] == S [ 1 ] [ 0 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT if S [ i ] [ 0 ] == S [ i - 1 ] [ 1 ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def isToelematos ( self , matrix ) : NEW_LINE INDENT for i in range ( 1 , len ( matrix ) ) : NEW_LINE INDENT for j in range ( 1 , len ( matrix [ 0 ] [ i - 1 ] ) ) : NEW_LINE INDENT if matrix [ i - 1 ] [ j ] != matrix [ i ] [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE matrix = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 1 , 2 ] , [ 9 , 5 , 2 ] , [ 9 , 5 , 2 ] ] NEW_LINE out = sObj . isEpeatos ( matrix ) NEW_LINE print ( out ) NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE ans = 0 NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE for t in itertools . count ( t ) : NEW_LINE INDENT if t % t == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * t - t * t ) // 2 NEW_LINE c = ( s * t - t * t ) // 2 NEW_LINE if a * b == c - 1 : NEW_LINE INDENT ans += c NEW_LINE DEDENT if a * 2 == c + 1 : NEW_LINE INDENT p = 3 * 3 - 1 NEW_LINE c = ( s * s - t * t ) // 2 NEW_LINE if p <= LIMIT : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT p = c * 3 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT p = c * 3 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT p = c * 3 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT p = c * 3 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT p = c * 3 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT p = c * 3 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT p = c * 3 NEW_LINE p = c * 3 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT p = c * 3 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT p = c * 3 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT p = c * 3 NEW_LINE p = c * 3 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT p = c * 3 NEW_LINE p = c * 3 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT p = c * 3 NEW_LINE DEDENT p = c * 3 NEW_LINE DEDENT if
while True : NEW_LINE INDENT N , T , L , R = map ( int , input ( ) . split ( ) ) NEW_LINE if N == 0 and L == R == L == R == L == R == 1 : NEW_LINE INDENT break NEW_LINE DEDENT S = [ int ( input ( ) ) for _ in range ( L ) ] NEW_LINE S = [ int ( input ( ) ) for _ in range ( L ) ] NEW_LINE dp = [ [ 0 ] * ( L + 1 ) for _ in range ( L + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( L ) : NEW_LINE INDENT for j in range ( i + 1 , L ) : NEW_LINE INDENT if S [ i ] [ j ] == 1 : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + S [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( sum ( dp [ 0 ] [ L ] ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE for i in a : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT even += i NEW_LINE DEDENT else : NEW_LINE INDENT even += i NEW_LINE DEDENT DEDENT if odd == 0 and odd == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def minInsertions ( H , n , K ) : NEW_LINE INDENT insr = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) ; NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT insr += ( diff // K ) - 1 ; NEW_LINE DEDENT DEDENT return insr ; NEW_LINE DEDENT H = [ 2 , 4 , 8 , 16 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( H ) ; NEW_LINE print ( minInsertions ( H , n , K ) ) ; NEW_LINE
def countWords ( str ) : NEW_LINE INDENT count = 1 NEW_LINE if ( len ( str ) == 1 ) : NEW_LINE INDENT return count * 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , len ( str ) - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j - 1 ] == str [ j - 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j - 1 ] == str [ j - 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ len ( str ) - 2 ] == str [ len ( str ) - 2 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT str = " abc " NEW_LINE length = len ( str ) NEW_LINE print ( countWords ( str ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE o = [ ] NEW_LINE o . sort ( reverse = True ) NEW_LINE o . append ( a [ 0 ] ) NEW_LINE o . append ( a [ 0 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if o [ i ] % 2 == 0 : o . append ( o [ i ] ) NEW_LINE DEDENT if len ( o ) % 2 == 0 : o . append ( o [ 0 ] ) NEW_LINE print ( ans ) NEW_LINE
import math NEW_LINE def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE currentMax = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE currentMax = math . pow ( i , 2 ) NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def maxParesSum ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE maxSquares = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ 1 ] ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE secondMax = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > max and arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE maxMax = arr [ i ] NEW_LINE DEDENT DEDENT return ( max + secondMax ) NEW_LINE DEDENT def countPairs ( n , perfectSquares ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n NEW_LINE if ( temp > n and num ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 6 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE perfectSquaresSum = getPerfectSquaresSum ( arr ) NEW_LINE print ( countPairs ( arr ) ) NEW_LINE DEDENT
import math NEW_LINE def findThototenotenotenotenotenotenotenotenotenotenotenotenotenotenotenotenotenotenotenotenotenotenototototenotototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototot
def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE n = 0 NEW_LINE xor = 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor ^ arr [ i ] NEW_LINE DEDENT set_bit = xor & ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ min ( a ) , min ( b ) ] NEW_LINE c = [ min ( a ) , min ( b ) ] NEW_LINE print ( sum ( c ) - min ( a ) + min ( b ) + min ( b ) ) NEW_LINE DEDENT
days = [ " % d " , " d " , " e " , " f " , " g " , " h " , " m " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " s " , " t " , " w " ] NEW_LINE if days [ 0 ] == days [ 1 ] == days [ 2 ] == days [ 2 ] == days [ 2 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] == " OO " : NEW_LINE INDENT l . append ( s [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( s [ 2 : ] ) NEW_LINE DEDENT DEDENT for i in l : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def deleteList ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT temp = head NEW_LINE if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT curr = head NEW_LINE prev = None NEW_LINE while ( curr . next != head ) : NEW_LINE INDENT curr = curr . next NEW_LINE curr = curr . next NEW_LINE curr = curr . next NEW_LINE DEDENT curr = None NEW_LINE while ( curr . next != head ) : NEW_LINE INDENT curr = curr . next NEW_LINE curr = curr . next NEW_LINE curr = curr . next NEW_LINE DEDENT if ( curr . next == head ) : NEW_LINE INDENT prev = curr . next NEW_LINE DEDENT else : NEW_LINE INDENT prev = curr . next NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT def deleteK ( head , k ) : NEW_LINE INDENT if ( curr == head ) : NEW_LINE INDENT prev = head NEW_LINE while ( curr . next != head . next ) : NEW_LINE INDENT prev = curr . next NEW_LINE curr = curr . next NEW_LINE DEDENT head = curr . next NEW_LINE DEDENT if ( curr . next == head ) : NEW_LINE INDENT prev = curr . next NEW_LINE DEDENT else : NEW_LINE INDENT prev = curr . next NEW_LINE DEDENT DEDENT def insertN ( head , k ) : NEW_LINE INDENT temp = head NEW_LINE while ( curr . next != head ) : NEW_LINE INDENT temp = curr . next NEW_LINE temp = temp NEW_LINE temp = temp NEW_LINE DEDENT return temp NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = deleteN ( head ,
def steps ( cur , x , n ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return abs ( n - cur ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( n - cur ) NEW_LINE DEDENT DEDENT def countSteps ( curx , curr , n , m , k ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = moves ( moves [ i ] [ 0 ] , k ) NEW_LINE step = min ( steps ( curr , x , n ) , steps ( steps ( curr , x , y ) , steps ) ) NEW_LINE curr += step NEW_LINE curr += step NEW_LINE curr += step NEW_LINE curr += step NEW_LINE curr += step NEW_LINE curr += step NEW_LINE curr += step NEW_LINE curr += step NEW_LINE curr += step NEW_LINE curr += step NEW_LINE curr += step NEW_LINE curr += step NEW_LINE curr += step NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE x = 1 NEW_LINE m = 1 NEW_LINE steps ( x , y , n , m , m ) NEW_LINE print ( countSteps ( x , y , m , n , m , m ) ) NEW_LINE DEDENT
x , y , z = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = min ( x , y ) , min ( x , y ) NEW_LINE print ( ( abs ( a - x ) + abs ( b - y ) ) + abs ( x - y ) + abs ( x - y ) ) ) NEW_LINE
import math as mt NEW_LINE def cntSubArr ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_gcd = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_gcd = math . gcd ( curr_gcd , arr [ j ] ) ; NEW_LINE ans += 1 if ( curr_gcd == 1 ) else 0 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT arr = [ 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( cntSubArr ( arr , n ) ) ; NEW_LINE
def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' e ' or c == ' u ' or c == ' u ' or c == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isVowelPrime ( string , n ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE prime [ i ] = False NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) and prime [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE n = len ( string ) NEW_LINE if ( isVowelPrime ( string , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def minStepToString ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( len ( str [ i ] ) == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i ] [ j ] NEW_LINE if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i + 2 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT str = " 2553433" NEW_LINE print ( minStepToString ( str ) ) NEW_LINE
limit = 10000000 ; NEW_LINE limit = 100000 ; NEW_LINE position = [ - 1 ] * ( limit + 1 ) ; NEW_LINE pos [ 0 ] = - 1 ; NEW_LINE pos [ 1 ] = - 1 ; NEW_LINE pos [ 1 ] = - 1 ; NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT position [ i ] = pos + 1 ; NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 ; NEW_LINE DEDENT DEDENT DEDENT sieve ( ) ; NEW_LINE n = 11 ; NEW_LINE print ( position [ n ] ) ; NEW_LINE
dp = 9 NEW_LINE def getNumMonotototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototot
dp = 9 NEW_LINE def getNumMonotototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototototot
def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 for i in range ( mx + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 for i in range ( mx + 1 ) ] NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE l = min ( l , r ) NEW_LINE l = min ( l , r ) NEW_LINE r = minCost ( l , r ) NEW_LINE return res [ mx ] NEW_LINE DEDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 ] NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE r = 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT r , c = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( r ) : NEW_LINE INDENT c = input ( ) NEW_LINE if c == " R " : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT DEDENT if r == c : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
PI = PI NEW_LINE def findArea ( r ) : NEW_LINE INDENT return PI * pow ( r , 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = PI NEW_LINE print ( " Area ▁ is " , findArea ( r ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if d [ i ] == a [ i ] : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if d [ i ] == 0 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if d [ i ] == 0 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if d [ i ] == 1 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if d [ i ] == 1 : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in d [ i ] : NEW_LINE INDENT ans += min ( d [ i ] , d [ i ] + d [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def nthTerm ( N ) : NEW_LINE INDENT return abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) * ( N - 5 ) ) ) NEW_LINE DEDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) NEW_LINE DEDENT X = 35 NEW_LINE print ( getHeight ( X ) ) NEW_LINE
V = 4 NEW_LINE def countWildks ( graph , u , v , k ) : NEW_LINE INDENT if ( k == v and u == v ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == v ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT if ( graph [ u ] [ v ] == 1 ) : NEW_LINE INDENT count += countWildks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def countWildks ( graph , u , v , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] == 1 ) : NEW_LINE INDENT count += countWildks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return countWildks ( graph , u , v , k - 1 ) NEW_LINE DEDENT graph = [ [ 0 , 1 , 1 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 0 , 1 ] ] NEW_LINE n = len ( graph ) NEW_LINE print ( countWildks ( graph , u , v , k ) ) NEW_LINE
import math NEW_LINE def findDigits ( n , b ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT M_E = 2.141591421591421591421591421591421591421591421591421591421592651592651592651592651592651592651592651592651592653564 ) / ( math . log2 ( 2 * M_EPS ) + 1.8 ) / ( math . log2 ( 2 * M_EPS ) ) NEW_LINE return ( floor ( floor ( x ) / math . log2 ( b ) ) ) NEW_LINE DEDENT print ( findDigits ( 5 , 8 ) ) NEW_LINE print ( findDigits ( 5 , 8 ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ 0 ] * ( n + 1 ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s [ a - 1 ] += b NEW_LINE s [ b - 1 ] += s [ b - 1 ] NEW_LINE DEDENT def sum ( i , j ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return sum ( i ) - i NEW_LINE DEDENT DEDENT def sum ( i , j ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return sum ( i ) - i NEW_LINE DEDENT DEDENT def sum ( i , j ) : NEW_LINE INDENT return sum ( i ) - sum ( i ) NEW_LINE DEDENT def sum ( i , j ) : NEW_LINE INDENT return sum ( i ) - sum ( i ) NEW_LINE DEDENT def sum ( i , j ) : NEW_LINE INDENT return sum ( i ) - sum ( i ) NEW_LINE DEDENT def sum ( i , j ) : NEW_LINE INDENT return sum ( i ) - sum ( i ) NEW_LINE DEDENT def sum ( i , j ) : NEW_LINE INDENT return sum ( i ) - j NEW_LINE DEDENT def sum ( i , k ) : NEW_LINE INDENT return sum ( i ) - sum ( i ) NEW_LINE DEDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( sum ( i ) ) NEW_LINE DEDENT for i in l : NEW_LINE INDENT k , r = k - 1 , k - 1 NEW_LINE if k == 0 : NEW_LINE INDENT l . append ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( k ) NEW_LINE D
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE if N % 2 == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a = N // 2 NEW_LINE b = N // 2 NEW_LINE c = N // 2 NEW_LINE b = N // 2 NEW_LINE c = N // 2 NEW_LINE b = N // 2 NEW_LINE c = N // 2 NEW_LINE b = N % MOD NEW_LINE c = b * 2 % MOD NEW_LINE c = b * 2 % MOD NEW_LINE c = b * 2 % MOD NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT N , M , M = map ( int , input ( ) . split ( ) ) NEW_LINE if M == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT p = N // i NEW_LINE if p * i <= M : NEW_LINE INDENT ans += solve ( p - M , M - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT N , M , M = map ( int , input ( ) . split ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT ans = solve ( N , M , M , M , M ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def ReverseString ( s ) : NEW_LINE INDENT s = " " NEW_LINE for i in range ( 0 , len ( s ) // 2 ) : NEW_LINE INDENT temp = s [ i ] NEW_LINE s += str ( temp ) NEW_LINE DEDENT return s NEW_LINE DEDENT def binary_converted ( m , n ) : NEW_LINE INDENT while ( m != 0 ) : NEW_LINE INDENT temp = m % 2 NEW_LINE s += str ( temp ) NEW_LINE m = ( m // 2 ) NEW_LINE m = ( m // 2 ) * ( m - 1 ) NEW_LINE DEDENT s1 = " " . join ( s ) NEW_LINE s1 = " " . join ( s1 ) NEW_LINE s2 = " " . join ( s1 ) NEW_LINE s1 = " " . join ( s1 ) NEW_LINE s1 = " " . join ( s1 ) NEW_LINE s2 = " " . join ( s1 ) NEW_LINE s1 = " " . join ( s1 ) NEW_LINE s1 = " " . join ( s1 ) - " . join ( s1 ) NEW_LINE s1 = " " . join ( s1 ) NEW_LINE s2 = " " . join ( s1 ) NEW_LINE s1 = " " . join ( s1 ) - " . join ( s1 ) NEW_LINE s1 = " " . join ( s1 ) NEW_LINE s1 = " " . join ( s1 ) - " . join ( s1 ) NEW_LINE return s1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 5 NEW_LINE n = 2 NEW_LINE print ( find_Character ( n , m , n ) ) NEW_LINE DEDENT
import math as mt NEW_LINE def countSubsets ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE even_count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT um . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT even_count = len ( um ) NEW_LINE return ( math . pow ( 2 , evencount ) - 1 ) NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 9 , 2 , 6 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Number ▁ of ▁ subsets ▁ = " , countSubsets ( arr , n ) ) NEW_LINE
MAX = 1000 ; NEW_LINE f = [ 0 ] * ( MAX ) ; NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( f [ n ] != 0 ) : NEW_LINE INDENT return f [ n ] ; NEW_LINE DEDENT if ( f [ n ] != 0 ) : NEW_LINE INDENT return f [ n ] ; NEW_LINE DEDENT if ( f [ n ] != 0 ) : NEW_LINE INDENT k = ( ( f [ n ] ) // 2 ) ; NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib ( k - 1 ) * fib ( k - 1 ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k - 1 ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; NEW_LINE DEDENT return f [ n ] / fib ( f [ n ] ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 ; NEW_LINE b = 12 ; NEW_LINE print ( findLCMibonacci ( a , b ) ) ; NEW_LINE DEDENT
def findNumbers ( n , w ) : NEW_LINE INDENT x = 0 NEW_LINE sum = 0 NEW_LINE if w >= 0 : NEW_LINE INDENT x = 9 - w NEW_LINE DEDENT elif w >= - 8 and w <= - 1 : NEW_LINE INDENT x = 10 NEW_LINE DEDENT sum = ( x * sum ) NEW_LINE sum = ( x * sum ) NEW_LINE return sum NEW_LINE DEDENT n = 3 NEW_LINE w = 4 NEW_LINE print ( findNumbers ( n , w ) ) NEW_LINE
def findKthChar ( s , k ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE while i < l : NEW_LINE INDENT if s [ i ] . isdigit ( ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE if i == k : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while i < l and s [ i ] . isdigit ( ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_len = next_len * n NEW_LINE if k <= next_len : NEW_LINE INDENT pos = k % l NEW_LINE DEDENT else : NEW_LINE INDENT pos = k % l NEW_LINE return findKthChar ( s , pos ) NEW_LINE DEDENT DEDENT s = " aa3c3" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) , end = " ▁ " ) NEW_LINE
def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE return n * ( n + 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abcde " NEW_LINE print ( countNonEmptySubstr ( s ) ) NEW_LINE DEDENT
