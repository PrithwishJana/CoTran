def import import sys , primes , re , primes , primes , limit NEW_LINE from itertools import isPrime , isPrime NEW_LINE from io import BytesIO NEW_LINE import random NEW_LINE import sys NEW_LINE import os NEW_LINE from random import randrange NEW_LINE from itertools import isPrime , isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime , isPrime NEW_LINE from random import random NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . primes = [ ] NEW_LINE DEDENT def __call__ ( self ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT n = int ( self . primes . get ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if self . primes [ n ] : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT begin = - 1 NEW_LINE end = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if self . primes [ i ] : NEW_LINE INDENT begin = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n + 1 , 2000000 ) : NEW_LINE INDENT if self . primes [ i ] : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( end - begin ) NEW_LINE DEDENT DEDENT def prime ( self ) : NEW_LINE INDENT self . primes = [ ] NEW_LINE self . isPrime = isPrime NEW_LINE limit = int ( random ( ) . randrange ( 2 , limit ) ) NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if self . primes [ i ] == False : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i * 2 , N + 1 , i ) : NEW_LINE INDENT self . primes [ j ] = False NEW_LINE DEDENT DEDENT DEDENT def isPrime ( self ) : NEW_LINE INDENT return isPrime NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE def countFreq ( data , freq , len ) : NEW_LINE INDENT for i in range ( len ) : NEW_LINE INDENT freq [ data [ i ] - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT def canMakePalindrome ( freq , len ) : NEW_LINE INDENT count_odd = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if freq [ i ] % 2 != 0 : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT if len % 2 == 0 : NEW_LINE INDENT if count_odd > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if count_odd != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def findOddAndRemoveItsFreq ( freq ) : NEW_LINE INDENT odd_str = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if freq [ i ] % 2 != 0 : NEW_LINE INDENT freq [ i ] -= 1 NEW_LINE odd_str = odd_str + chr ( i + ord ( ' a ' ) ) NEW_LINE return odd_str NEW_LINE DEDENT DEDENT return odd_str NEW_LINE DEDENT def findPalindromicString ( data ) : NEW_LINE INDENT data = data . replace ( " " , " " ) NEW_LINE freq = [ ] NEW_LINE countFreq ( data , freq , len ) NEW_LINE if not canMakePalindrome ( freq , len ) : NEW_LINE INDENT return " No ▁ Palindromic ▁ String " NEW_LINE DEDENT odd_str , rear_str = findOddAndRemoveItsFreq ( freq ) NEW_LINE front_str , rear_str = " " , " ▁ " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT temp = " " NEW_LINE if freq [ i ] != 0 : NEW_LINE INDENT ch = chr ( i + ord ( ' a ' ) ) NEW_LINE for j in range ( 1 , freq [ i ] // 2 + 1 ) : NEW_LINE INDENT temp = temp + ch NEW_LINE DEDENT front_str = front_str + temp NEW_LINE rear_str = temp + rear_str NEW_LINE DEDENT DEDENT return ( front_str + odd_str + rear_str ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT data = " malayalam " NEW_LINE print ( findPalindromicString ( data ) ) NEW_LINE DEDENT DEDENT
def import _pylab NEW_LINE import pylab NEW_LINE import matplotlib . pylab as plt NEW_LINE import matplotlib . pylab as plt NEW_LINE import matplotlib . cm as cm NEW_LINE import matplotlib . pylab as plt NEW_LINE import matplotlib . pylab as plt NEW_LINE import matplotlib . pylab as plt NEW_LINE import matplotlib . pylab as plt NEW_LINE import matplotlib . pylab as plt NEW_LINE import matplotlib . pylab as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . pylab as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . specshow NEW_LINE import matplotlib . examples as examples NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . specshow NEW_LINE import matplotlib . examples as examples NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . specshow NEW_LINE import matplotlib . examples as examples NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . specshow NEW_LINE import matplotlib . examples as examples NEW_LINE import matplotlib . specshow NEW_LINE import matplotlib . examples as specshow NEW_LINE import matplotlib . examples as examples NEW_LINE import matplotlib . specshow NEW_LINE import matplotlib . examples as specshow NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . specshow NEW_LINE import matplotlib . pyplot as plt NEW_LINE plt . show ( ) NEW_LINE q = len ( plt . examples ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT plt . subplot ( 1 , 2 , i + 1 ) NEW_LINE plt . imshow ( plt . gcf ( ) . get_figwidth ( ) , cmap = ' gray ' ) NEW_LINE plt . show ( ) NEW_LINE DEDENT
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 1 ] * 9 NEW_LINE result = 0 NEW_LINE mod_sum , continuous_zero = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ord ( number [ i ] ) - ord ( '0' ) == 0 : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += ord ( number [ i ] ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE DEDENT return result NEW_LINE DEDENT
def _fast_pow ( N , K ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = N NEW_LINE self . K = K NEW_LINE DEDENT def power ( self , n ) : NEW_LINE INDENT if n == 0 : return 1 NEW_LINE temp = random . randint ( 0 , n // 2 ) NEW_LINE if n % 2 == 0 : return temp ** 2 NEW_LINE else : return N * temp ** 2 NEW_LINE DEDENT def count_ways ( self , n ) : NEW_LINE INDENT return K * fast_pow ( self . K - 1 , n - 1 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT N , K = 3 , 3 NEW_LINE print ( count_ways ( self , n ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE sc = Scanner ( ) NEW_LINE s = [ [ 0 , 1 , 1 , 1 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 0 , 1 , 1 , 0 ] , [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 0 , 0 , 1 , 1 , 0 ] , [ 1 , 1 , 0 , 1 , 1 , 0 , 1 ] , [ 1 , 1 , 1 , 1 , 1 , 0 , 1 ] , [ 0 , 1 , 0 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 0 , 1 , 1 , 1 , 1 ] ] NEW_LINE for n in repeat ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE if n == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT while n : NEW_LINE INDENT m = sc . next ( ) NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT print ( ( a [ i ] ^ s [ m ] [ i ] ) + ( ' \n ' if i == 6 else ' ' ) , end = ' ' ) NEW_LINE DEDENT a = s [ m ] [ : n ] NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 10000 NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 10000 NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT prime = [ True for i in range ( self . MAX ) ] NEW_LINE for p in range ( 2 * self . MAX ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , self . MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , self . MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( self , n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while product < n : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if product + 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT self . SieveOfEratosthenes = GFG ( ) NEW_LINE n = 31 NEW_LINE if isEuclid ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = 42 NEW_LINE if isEuclid ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def import _ZZ NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 1000000 NEW_LINE self . arr = [ ] NEW_LINE self . prime = [ False for i in range ( self . MAX ) ] NEW_LINE DEDENT def SieveOfEratosthenes ( self ) : NEW_LINE INDENT for i in range ( self . MAX ) : NEW_LINE INDENT self . prime [ i ] = True NEW_LINE DEDENT for p in range ( 2 * self . MAX ) : NEW_LINE INDENT if self . prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , self . MAX , p ) : NEW_LINE INDENT self . prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , self . MAX ) : NEW_LINE INDENT if self . prime [ p ] : NEW_LINE INDENT self . arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( self , n ) : NEW_LINE INDENT if not self . prime [ n ] : NEW_LINE INDENT return False NEW_LINE DEDENT product = 1 NEW_LINE i = 0 NEW_LINE while product < n : NEW_LINE INDENT product = product * self . arr [ i ] NEW_LINE if product + 1 == n or product - 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . SieveOfEratosthenes ( ) NEW_LINE self . n = 31 NEW_LINE if isPrimorialPrime ( self . n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT if N > 10 : NEW_LINE INDENT return NEW_LINE DEDENT print ( " % d ▁ * ▁ % d ▁ = ▁ % d " % ( N , i , N * i ) ) NEW_LINE return NEW_LINE DEDENT
def close_to_n_divisible_m ( n , m ) : NEW_LINE INDENT q = n // m NEW_LINE n1 = m * q NEW_LINE n2 = ( m * ( q + 1 ) ) if ( n * m ) > 0 else ( m * ( q - 1 ) ) NEW_LINE if abs ( n - n1 ) < abs ( n - n2 ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT
def GFG ( ang , n ) : NEW_LINE INDENT if ( ang * n ) > ( 180 * ( n - 2 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ang * n ) % 180 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) / 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT
def GFG ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ ] NEW_LINE s = s [ 0 : ] NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == s [ len ( s ) : ] : NEW_LINE INDENT s += s [ i : ] NEW_LINE lps . append ( s [ i : ] ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if s [ i ] != s [ - 1 ] : NEW_LINE INDENT s = s [ i : ] NEW_LINE DEDENT else : NEW_LINE INDENT lps . append ( 0 ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT class Longestsubstring ( forms . UniquenessSubs ) : NEW_LINE INDENT lps = compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if lps [ n - 1 ] == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if lps [ i ] == lps [ n - 1 ] : NEW_LINE INDENT print ( s [ : i ] ) NEW_LINE return NEW_LINE DEDENT DEDENT if lps [ lps [ n - 1 ] - 1 ] == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ : lps [ lps [ n - 1 ] - 1 ] ] ) NEW_LINE DEDENT DEDENT
def check_if_sort_rotated ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE from scipy . ndimage import binary_structure NEW_LINE min_ele = binary_structure . max NEW_LINE max_ele = binary_structure . min NEW_LINE min_index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < min_ele : NEW_LINE INDENT min_ele = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT flag1 = True NEW_LINE for i in range ( 1 , min_index ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag1 = False NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = True NEW_LINE for i in range ( min_index + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag2 = False NEW_LINE break NEW_LINE DEDENT DEDENT if min_index == 0 : NEW_LINE INDENT sys . stdout . write ( " NO " ) NEW_LINE return NEW_LINE DEDENT if flag1 and flag2 and ( arr [ n - 1 ] < arr [ min_index - 1 ] ) : NEW_LINE INDENT sys . stdout . write ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( " NO " ) NEW_LINE DEDENT DEDENT
def import import os NEW_LINE class IS ( object ) : NEW_LINE INDENT def runapp ( self ) : NEW_LINE INDENT with open ( " . . / . . / data / " , " r " ) as f : NEW_LINE INDENT n = f . read ( ) NEW_LINE DEDENT DEDENT def runapp ( self ) : NEW_LINE INDENT with open ( " . . / data / " , " r " ) as f : NEW_LINE INDENT n = f . read ( ) NEW_LINE DEDENT DEDENT def runapp ( self ) : NEW_LINE INDENT with open ( " . . / data / " , " r " ) as f : NEW_LINE INDENT n = f . read ( ) NEW_LINE DEDENT DEDENT def runapp ( self ) : NEW_LINE INDENT with open ( " . . / data / " , " r " ) as f : NEW_LINE INDENT n = f . read ( ) NEW_LINE DEDENT DEDENT def runapp ( self ) : NEW_LINE INDENT for x in range ( n ) : NEW_LINE INDENT sequence = [ x for x in range ( n ) ] NEW_LINE step = 0 NEW_LINE store = 0 NEW_LINE for y in range ( n - 1 ) : NEW_LINE INDENT while sequence [ y + 1 ] <= sequence [ y ] : NEW_LINE INDENT diff = sequence [ y + 1 ] - sequence [ y ] NEW_LINE if sequence [ y + 1 ] == sequence [ y ] : NEW_LINE INDENT sequence [ y + 1 ] = sequence [ y + 1 ] + d NEW_LINE step = step + 1 NEW_LINE DEDENT else : NEW_LINE INDENT diff = - diff NEW_LINE store = ( diff / d ) + 1 NEW_LINE step = step + store NEW_LINE sequence [ y + 1 ] = sequence [ y + 1 ] + ( d * store ) NEW_LINE DEDENT DEDENT DEDENT DEDENT sys . stdout . write ( " % d " % step ) NEW_LINE DEDENT DEDENT
def check_if_power_isolated ( num ) : NEW_LINE INDENT input = num NEW_LINE count = 0 NEW_LINE factor = [ ] NEW_LINE if num % 2 == 0 : NEW_LINE INDENT while num % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE num /= 2 NEW_LINE DEDENT factor . append ( count ) NEW_LINE DEDENT for i in range ( 3 , 2 * num , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while num % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE num /= i NEW_LINE DEDENT if count > 0 : NEW_LINE INDENT factor . append ( count ) NEW_LINE DEDENT DEDENT if num > 1 : NEW_LINE INDENT factor . append ( 1 ) NEW_LINE DEDENT product = 1 NEW_LINE for i in range ( num + 1 ) : NEW_LINE INDENT if factor [ i ] > 0 : NEW_LINE INDENT product = product * factor [ i ] ** i NEW_LINE DEDENT DEDENT if product == input : NEW_LINE INDENT sys . stdout . write ( " Power - isolated ▁ Integer \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( " Not ▁ a ▁ Power - isolated ▁ Integer \n " ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from string import printable NEW_LINE sc = Scanner ( ) NEW_LINE s = sc . next ( ) NEW_LINE s = [ ] NEW_LINE for c in s : NEW_LINE INDENT if len ( s ) % 2 == 0 and s [ c ] == ' A ' or len ( s ) % 2 == 1 and s [ c ] == ' Z ' : NEW_LINE INDENT s . append ( c ) NEW_LINE DEDENT DEDENT s /= 2 NEW_LINE if len ( s ) == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT s = [ " AZ " ] * len ( s ) NEW_LINE print ( " " . join ( s ) ) NEW_LINE DEDENT DEDENT
def import import sys , StringIO , getopt , r765A NEW_LINE class R765A ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdin = sys . stdin NEW_LINE readline = sys . stdin . readline ( ) NEW_LINE readline . strip ( ) NEW_LINE t = int ( readline . strip ( ) ) NEW_LINE while t : NEW_LINE INDENT readline . strip ( ) NEW_LINE n = int ( readline . strip ( ) ) NEW_LINE arr = [ ] NEW_LINE readline . strip ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( int ( readline . strip ( ) ) ) NEW_LINE DEDENT self . solve ( arr ) NEW_LINE DEDENT DEDENT class Diff ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . prev = None NEW_LINE DEDENT def solve ( self , arr ) : NEW_LINE INDENT self . max = - 1 NEW_LINE self . dict = { } NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] in self . dict : NEW_LINE INDENT diff , prev , count = self . dict [ arr [ i ] ] NEW_LINE if count > self . max : NEW_LINE INDENT self . max = count NEW_LINE DEDENT diff . prev = i NEW_LINE DEDENT else : NEW_LINE INDENT diff = Diff ( ) NEW_LINE diff . prev = i NEW_LINE self . dict [ arr [ i ] ] = diff NEW_LINE DEDENT DEDENT print ( self . max ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if not len1 or not len2 : NEW_LINE INDENT return '0' NEW_LINE DEDENT result = [ 0 ] * ( len1 + len2 ) NEW_LINE i_n1 = 0 NEW_LINE i_n2 = 0 NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = num1 [ i ] - '0' NEW_LINE i_n2 = 0 NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = num2 [ j ] - '0' NEW_LINE sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry NEW_LINE carry = sum / 10 NEW_LINE result [ i_n1 + i_n2 ] = sum % 10 NEW_LINE i_n2 += 1 NEW_LINE DEDENT if carry : NEW_LINE INDENT result [ i_n1 + i_n2 ] += carry NEW_LINE DEDENT i_n1 += 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while i >= 0 and result [ i ] == 0 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if i == - 1 : NEW_LINE INDENT return '0' NEW_LINE DEDENT s = " " NEW_LINE while i >= 0 : NEW_LINE INDENT s += ( result [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' n ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from nltk . corpus import brown NEW_LINE from nltk . util import get_scanner NEW_LINE sc = get_scanner ( ) NEW_LINE n , k = len ( brown . words ( ) ) , len ( brown . words ( ) ) NEW_LINE a = brown . words ( ) NEW_LINE if k > n / 2 : NEW_LINE INDENT while k < n : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE k += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while k > 1 : NEW_LINE INDENT print ( " LEFT " ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT if k == 1 : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT print ( " PRINT ▁ " + a [ i ] ) NEW_LINE if ( i + 1 ) < len ( a ) : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( " PRINT ▁ " + a [ i ] ) NEW_LINE if ( i - 1 ) >= 0 : NEW_LINE INDENT print ( " LEFT " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_gf_dist_sum ( ) : NEW_LINE INDENT import numpy as np NEW_LINE from scipy . sparse import csc_matrix NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE from scipy . sparse . linalg import eigs NEW_LINE arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( eigs ) NEW_LINE eigs = eigs [ 0 ] NEW_LINE eigs [ 1 ] = eigs [ 1 ] NEW_LINE eigs [ 2 ] = eigs [ 2 ] NEW_LINE eigs [ 3 ] = eigs [ 3 ] NEW_LINE eigs [ 4 ] = eigs [ 4 ] NEW_LINE eigs [ 5 ] = eigs [ 5 ] NEW_LINE eigs [ 6 ] = eigs [ 6 ] NEW_LINE eigs [ 7 ] = eigs [ 7 ] NEW_LINE eigs [ 8 ] = eigs [ 8 ] NEW_LINE eigs [ 9 ] = eigs [ 9 ] NEW_LINE eigs [ 10 ] = eigs [ 10 ] NEW_LINE eigs [ 11 ] = eigs [ 11 ] NEW_LINE eigs [ 12 ] = eigs [ 12 ] NEW_LINE eigs [ 13 ] = eigs [ 13 ] NEW_LINE eigs [ 14 ] = eigs [ 14 ] NEW_LINE eigs [ 15 ] = eigs [ 15 ] NEW_LINE eigs [ 15 ] = eigs [ 16 ] NEW_LINE eigs [ 15 ] = eigs [ 15 ] NEW_LINE eigs [ 16 ] = eigs [ 16 ] NEW_LINE eigs [ 15 ] = eigs [ 16 ] NEW_LINE eigs [ 16 ] = eigs [ 17 ] NEW_LINE eigs [ 18 ] = eigs [ 18 ] NEW_LINE eigs [ 15 ] = eigs [ 19 ] NEW_LINE eigs [ 18 ] = eigs [ 18 ] NEW_LINE eigs [ 18 ] = eigs [ 18 ] NEW_LINE eigs [ 18 ] = eigs [ 19 ] NEW_LINE eigs [ 18 ] = eigs [ 18 ] NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT class Subtract ( object ) : NEW_LINE INDENT def __init__ ( self , a , b ) : NEW_LINE INDENT self . a = a + ( ~ b + 1 ) NEW_LINE DEDENT def doit ( self ) : NEW_LINE INDENT a , b = 2 , 3 NEW_LINE print ( Subtract ( a , b ) ) NEW_LINE a , b = 9 , 7 NEW_LINE print ( Subtract ( a , b ) ) NEW_LINE DEDENT DEDENT return Subtract ( ) NEW_LINE DEDENT
def import import os , sys NEW_LINE from math import sqrt , sin , cos , sqrt NEW_LINE class InfiniteSequence ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stream = sys . stdin NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE n1 = int ( self . stream . read ( ) ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . read ( 1 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . read ( 1 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . read ( 1 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . read ( 1 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . read ( 1 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . read ( 1 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . read ( 1 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . read ( 1 ) NEW_LINE self . stream . seek ( 0 ) NEW_LINE self . stream . read ( 1 ) NEW_LINE DEDENT DEDENT
def import _codeforces NEW_LINE class Codeforces ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT sc = _codeforces . get ( self . name ) NEW_LINE n = sc . count ( ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( sc . randint ( 0 , n ) ) NEW_LINE arr . append ( arr [ - 1 ] ) NEW_LINE DEDENT lt = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == arr [ arr [ arr [ i ] ] ] : NEW_LINE INDENT lt = True NEW_LINE break NEW_LINE DEDENT DEDENT if lt : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( i , occurrences ) : NEW_LINE INDENT while i < len ( occurrences ) : NEW_LINE INDENT if occurrences [ i ] == 0 : return i NEW_LINE i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def getModifiedString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if n > 26 : return ' - 1' NEW_LINE ch = str . replace ( ' ' , ' ' ) NEW_LINE i , occurrences = [ ] , [ 0 ] * 26 NEW_LINE for c in ch : occurrences [ c - ' a ' ] += 1 NEW_LINE index = nextZero ( 0 , occurrences ) NEW_LINE for c in ch : NEW_LINE INDENT if occurrences [ c - ' a ' ] > 1 : NEW_LINE INDENT occurrences [ c - ' a ' ] -= 1 NEW_LINE ch [ c ] = chr ( ord ( ' a ' ) + index ) NEW_LINE occurrences [ index ] = 1 NEW_LINE index = nextZero ( index + 1 , occurrences ) NEW_LINE DEDENT DEDENT return str ( ch ) NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT str = ' geeksforgeeks ' NEW_LINE print ( getModifiedString ( str ) ) NEW_LINE DEDENT
def import _planet NEW_LINE class _planet ( ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdin = sys . stdin NEW_LINE self . n_c = self . stdin . read ( ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT stdin . close ( ) NEW_LINE self . n_c = self . stdin . read ( ) NEW_LINE for loop in range ( self . n_c ) : NEW_LINE INDENT hr , min = self . stdin . read ( ) . split ( ' : ' ) NEW_LINE tok = self . stdin . readline ( ) . split ( ' : ' ) NEW_LINE s_hr , s_min = [ int ( tok [ 0 ] ) for tok in tok [ 1 : ] ] NEW_LINE res = None NEW_LINE for i in range ( s_hr * min + s_min , hr * min ) : NEW_LINE INDENT res = self . flip ( i , hr , min ) NEW_LINE if res is not None : break NEW_LINE DEDENT if not res : res = [ 0 , 0 , 0 , 0 ] NEW_LINE print ( " % d % d : % d % d \n " % ( res [ 0 ] , res [ 1 ] , res [ 2 ] , res [ 3 ] ) ) NEW_LINE DEDENT DEDENT def flip ( self , val , hr , min ) : NEW_LINE INDENT this_hr , this_min = val // min , val % min NEW_LINE disp = [ this_min % 10 , this_min // 10 , this_hr % 10 , this_hr // 10 ] NEW_LINE for i in disp : NEW_LINE INDENT if i in self . FLIP : return None NEW_LINE self . FLIP [ i ] = self . FLIP [ i ] NEW_LINE DEDENT new_hr , new_min = 10 ** ( self . FLIP [ disp [ 0 ] ] ) + self . FLIP [ disp [ 1 ] ] NEW_LINE if new_hr >= hr or new_min >= min : return None NEW_LINE return self . FLIP [ new_hr // 10 , this_hr % 10 , this_min // 10 , this_min % 10 ] NEW_LINE DEDENT DEDENT
def import _fastread NEW_LINE import sys NEW_LINE import struct NEW_LINE class A ( struct . Struct ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n , nax = struct . unpack ( ' > ii ' , self . read ( 1 ) ) NEW_LINE a = sc . read_array ( n ) NEW_LINE cnts = [ 0 ] * nax NEW_LINE for e in a : NEW_LINE INDENT cnts [ e + 1 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE pre = [ 0 ] * nax NEW_LINE for i in range ( 1 , nax ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + cnts [ i ] NEW_LINE val = ( pre [ i ] + i - 1 ) / i NEW_LINE ans = max ( ans , val ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT def ruffle_sort ( a ) : NEW_LINE INDENT al = [ ] NEW_LINE for i in a : NEW_LINE INDENT al . append ( i ) NEW_LINE DEDENT al . sort ( ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT a . append ( al [ i ] ) NEW_LINE DEDENT return a NEW_LINE DEDENT def write ( self , a ) : NEW_LINE INDENT for e in a : NEW_LINE INDENT print ( e , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT class Fastread ( struct . Struct ) : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT while not isinstance ( self . readline , list ) : NEW_LINE INDENT try : NEW_LINE INDENT self . readline ( ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT pass NEW_LINE DEDENT return self . readline ( ) NEW_LINE DEDENT return readline NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return int ( self . readline ( ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return long ( self . readline ( ) ) NEW_LINE DEDENT def readarray ( self , n ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( sc . read ( n ) ) NEW_LINE DEDENT return a NEW_LINE DEDENT DEDENT DEDENT return A NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class HelloWorld ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = [ ] NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT t = time . time ( ) NEW_LINE while t : NEW_LINE INDENT n = time . time ( ) NEW_LINE s = [ ] NEW_LINE if n == 1 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT while n : NEW_LINE INDENT ans = n & 1 NEW_LINE n = n >> 1 NEW_LINE if ans == 1 : NEW_LINE INDENT s . insert ( 0 , 1 ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT s . insert ( 0 , 0 ) NEW_LINE DEDENT DEDENT if n == 0 : NEW_LINE INDENT s . pop ( ) NEW_LINE s . append ( 1 ) NEW_LINE DEDENT val = int ( ' ' . join ( s ) , 2 ) NEW_LINE print ( val ) NEW_LINE DEDENT DEDENT DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = len ( _main . args ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return _main . args [ key ] NEW_LINE DEDENT def __setitem__ ( self , key , value ) : NEW_LINE INDENT return _main . args [ key ] NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return _main . args [ 0 ] NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return _main . args [ 1 ] NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return _main . args [ 2 ] NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return _main . args [ 3 ] NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return _main . args [ 4 ] NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return _main . args [ 5 ] NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return _main . args [ 6 ] NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return _main . args [ 7 ] NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return _main . args [ 8 ] NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return _main . args [ 9 ] NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return _main . args [ 8 ] NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return _main . args [ 9 ] NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class league ( object ) : NEW_LINE INDENT def solve ( self , f ) : NEW_LINE INDENT n = sys . stdin . readline ( ) . strip ( ) NEW_LINE num = 0 NEW_LINE a = [ ] NEW_LINE start = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num += sys . stdin . readline ( ) . strip ( ) NEW_LINE for j in range ( start , num ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT start = num NEW_LINE DEDENT m = sys . stdin . readline ( ) . strip ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( a [ sys . stdin . readline ( ) . strip ( ) - 1 ] , end = ' ▁ ' ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT def run ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT with open ( sys . stdin . readline ( ) , ' w ' ) as f : NEW_LINE INDENT f . write ( sys . stdin . readline ( ) ) NEW_LINE DEDENT DEDENT except IOError : NEW_LINE INDENT print ( sys . stdin . readline ( ) , file = sys . stdout ) NEW_LINE DEDENT DEDENT DEDENT
def import import _sum NEW_LINE import math NEW_LINE import os NEW_LINE import sys NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import math NEW_LINE class Ada ( ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . _sum = 0 NEW_LINE self . _sum = 0 NEW_LINE self . _sum = 0 NEW_LINE DEDENT DEDENT
def print_max ( arr , n , k ) : NEW_LINE INDENT import deque NEW_LINE import sys NEW_LINE class SlidingWindow ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . _arr = arr NEW_LINE DEDENT DEDENT Qi = deque ( ) NEW_LINE i = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT while not Qi . empty ( ) and arr [ i ] >= arr [ Qi . popleft ( ) ] : NEW_LINE INDENT Qi . popleft ( ) NEW_LINE DEDENT Qi . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ Qi . peek ( ) ] , end = ' ▁ ' ) NEW_LINE while ( not Qi . empty ( ) and Qi . peek ( ) <= i - k ) : NEW_LINE INDENT Qi . popleft ( ) NEW_LINE DEDENT while ( not Qi . empty ( ) and arr [ i ] >= arr [ Qi . popleft ( ) ] ) : NEW_LINE INDENT Qi . popleft ( ) NEW_LINE DEDENT Qi . append ( i ) NEW_LINE DEDENT print ( arr [ Qi . peek ( ) ] ) NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 12 , 1 , 78 , 90 , 57 , 89 , 56 ] NEW_LINE k = 3 NEW_LINE print_max ( arr , len ( arr ) , k ) NEW_LINE DEDENT DEDENT
def russian_peasant ( a , b ) : NEW_LINE INDENT import sys NEW_LINE from math import sin , cos , pi NEW_LINE from math import pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import pi , pi , pi , pi NEW_LINE from math import pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi NEW_LINE from math import pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi , pi
def GFG ( data , len ) : NEW_LINE INDENT for i in range ( 1 , len ) : NEW_LINE INDENT if data [ i ] == data [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT from random import random NEW_LINE from math import pow NEW_LINE from random import seed NEW_LINE from math import factorial NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import factorial NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import factorial NEW_LINE from math import log NEW_LINE from math import factorial NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import factorial NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import factorial NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE DEDENT
def test_sub ( ) : NEW_LINE INDENT import sys NEW_LINE class Sub ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . num = 0 NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " Sub ( ) " NEW_LINE DEDENT DEDENT num = Sub ( ) NEW_LINE while num : NEW_LINE INDENT a = Sub ( ) NEW_LINE b = Sub ( ) NEW_LINE res = 0 NEW_LINE while a != 0 and b != 0 : NEW_LINE INDENT if a >= b : NEW_LINE INDENT res += a // b NEW_LINE a %= b NEW_LINE DEDENT else : NEW_LINE INDENT res += b // a NEW_LINE b %= a NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT DEDENT
def import java . util . regex NEW_LINE import re NEW_LINE class CP ( object ) : NEW_LINE INDENT def __init__ ( self , s ) : NEW_LINE INDENT self . s = s NEW_LINE self . f = open ( s ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not self . s or not self . s : NEW_LINE INDENT self . s = self . s . readline ( ) NEW_LINE DEDENT return self . s NEW_LINE DEDENT def atoi ( self ) : NEW_LINE INDENT return int ( self . s . split ( ) [ 0 ] ) NEW_LINE DEDENT def long ( self ) : NEW_LINE INDENT return long ( self . s . split ( ) [ 0 ] ) NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if not b : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def print_ ( al ) : NEW_LINE INDENT for i in al : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def digitsum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT try : NEW_LINE INDENT s = sys . stdin . readline ( ) NEW_LINE s = ' ' NEW_LINE st = s . split ( ) NEW_LINE k = len ( st ) NEW_LINE hs = set ( [ x for x in st if x ] ) NEW_LINE if len ( st ) < k : NEW_LINE INDENT s += ' impossible ' NEW_LINE DEDENT else : NEW_LINE INDENT if k <= len ( hs ) : NEW_LINE INDENT s += '0 \n ' NEW_LINE DEDENT else : NEW_LINE INDENT s += str ( k - len ( hs ) ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT except : NEW_LINE INDENT print ( sys . exc_info ( ) [ 0 ] ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT N = 3 NEW_LINE def MaxTraceSub ( mat ) : NEW_LINE INDENT max_trace = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT r , s , trace = i , j , 0 NEW_LINE while r < N and s < N : NEW_LINE INDENT trace += mat [ r , s ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE max_trace = max ( trace , max_trace ) NEW_LINE DEDENT DEDENT DEDENT return max_trace NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT mat = [ [ 10 , 2 , 5 ] , [ 6 , 10 , 4 ] , [ 2 , 7 , - 10 ] ] NEW_LINE print ( MaxTraceSub ( mat ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . args = sys . argv [ 1 : ] NEW_LINE DEDENT DEDENT for xa1 , ya1 , xa2 , ya2 , xb1 , yb1 , xb2 , yb2 in sys . argv [ 1 : ] : NEW_LINE INDENT xa1 , xa2 , ya1 = xa1 . split ( ' : ' ) NEW_LINE xa2 , ya2 = ya1 . split ( ' : ' ) NEW_LINE xb1 , yb1 = xb1 . split ( ' : ' ) NEW_LINE xb2 , yb2 = yb1 . split ( ' : ' ) NEW_LINE xb_min , xb_max = min ( xa1 , xa2 ) , max ( xa1 , xa2 ) NEW_LINE xb_min , xb_max = min ( xb1 , xb2 ) , max ( xb1 , xb2 ) NEW_LINE yaa_min , yaa_max = min ( ya1 , ya2 ) , max ( ya1 , ya2 ) NEW_LINE yb_min , yb_max = min ( yb1 , yb2 ) , max ( yb1 , yb2 ) NEW_LINE if xb_max < xb_min or xb_max < xb_min or yaa_max < yb_min or yb_max < yaa_min : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT DEDENT
def import import sys NEW_LINE class ArrayElimination ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stream = sys . stdin NEW_LINE self . t = sys . stdin . readline ( ) . strip ( ) NEW_LINE DEDENT for tt in range ( t ) : NEW_LINE INDENT n = int ( tt ) NEW_LINE bit = [ 0 ] * 32 NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE INDENT temp = ( 1 << ( j - 1 ) ) NEW_LINE bitwise_and = arr [ i ] & temp NEW_LINE if bitwise_and : NEW_LINE INDENT bit [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT possible = True NEW_LINE for j in range ( 32 ) : NEW_LINE INDENT if bit [ j ] % i != 0 : NEW_LINE INDENT possible = False NEW_LINE break NEW_LINE DEDENT DEDENT if possible : NEW_LINE INDENT sys . stdout . write ( " % d ▁ " % i ) NEW_LINE DEDENT DEDENT sys . stdout . write ( " \n " ) NEW_LINE DEDENT DEDENT
def _OddDivCount ( a , b ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import math NEW_LINE import random NEW_LINE import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = a NEW_LINE self . b = b NEW_LINE self . res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT div_count = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT div_count += 1 NEW_LINE DEDENT DEDENT if ( div_count % 2 ) != 0 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return GFG NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( self . n ) NEW_LINE self . m = int ( self . m ) NEW_LINE self . M = float ( self . m ) NEW_LINE arr = [ ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT arr . append ( self . n [ i ] ) NEW_LINE DEDENT self . max = 0 NEW_LINE self . ans = 0 NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT x = int ( math . ceil ( arr [ i ] / self . M ) ) NEW_LINE if x >= self . max : NEW_LINE INDENT self . max = x NEW_LINE self . ans = i NEW_LINE DEDENT DEDENT print ( self . ans + 1 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def GFG ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE def repl_array ( N , arr ) : NEW_LINE INDENT pos_sum , neg_sum , i , j , diff = 0 , 0 , 0 , 0 , 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE if i > 0 : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ i ] NEW_LINE DEDENT arr [ i ] = abs ( diff ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 ] NEW_LINE repl_array ( N , arr ) NEW_LINE printArray ( N , arr ) NEW_LINE N = 6 NEW_LINE arr1 = [ - 3 , - 4 , - 2 , 5 , 1 , - 2 ] NEW_LINE repl_array ( N , arr1 ) NEW_LINE printArray ( N , arr1 ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def GFG ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE def repl_array ( N , arr ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ i ] NEW_LINE DEDENT DEDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE arr [ i ] = abs ( diff ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 ] NEW_LINE repl_array ( N , arr ) NEW_LINE printArray ( N , arr ) NEW_LINE N = 6 NEW_LINE arr1 = [ - 3 , - 4 , - 2 , 5 , 1 , - 2 ] NEW_LINE repl_array ( N , arr1 ) NEW_LINE printArray ( N , arr1 ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def __count_divisbleby4 ( s ) : NEW_LINE INDENT import string NEW_LINE n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] in [ '4' , '8' , '0' ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT h = ( s [ i ] - '0' ) * 10 + ( s [ i + 1 ] - '0' ) NEW_LINE if h % 4 == 0 : NEW_LINE INDENT count = count + i + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def import _cf1535A NEW_LINE class cf1535A ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin NEW_LINE self . t = sys . stdin . read ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT for i in range ( 1 , self . t + 1 ) : NEW_LINE INDENT a = [ ] NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT a . append ( self . input . read ( ) ) NEW_LINE DEDENT if max ( a [ 0 ] , a [ 1 ] ) > min ( a [ 2 ] , a [ 3 ] ) and max ( a [ 2 ] , a [ 3 ] ) > min ( a [ 0 ] , a [ 1 ] ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def _96B ( ) : NEW_LINE INDENT import sys NEW_LINE from struct import calcsize NEW_LINE from struct import Struct NEW_LINE from struct import Struct NEW_LINE from struct import Struct NEW_LINE number = Struct ( ' > I ' ) . unpack ( ' < I ' ) [ 0 ] NEW_LINE ans , value = - 1 , 0 NEW_LINE mask = 2 NEW_LINE while value < number : NEW_LINE INDENT s = Struct ( ' > I ' ) . unpack ( ' < I ' ) [ mask ] [ 1 : ] NEW_LINE zeros = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == '0' : zeros += 1 NEW_LINE DEDENT if zeros != len ( s ) - zeros : continue NEW_LINE s = s . replace ( '0' , '4' ) NEW_LINE s = s . replace ( '1' , '7' ) NEW_LINE value = Struct ( ' > I ' ) . unpack ( s ) [ 0 ] NEW_LINE DEDENT print ( value ) NEW_LINE DEDENT
def import _oracAndMedians_641B NEW_LINE import os NEW_LINE import sys NEW_LINE from os . path import join NEW_LINE from os import sep NEW_LINE from os . path import join NEW_LINE from os import sep NEW_LINE from os . path import join NEW_LINE from os import sep NEW_LINE from os import sep NEW_LINE from os import chdir NEW_LINE from os . path import join NEW_LINE from os import sep NEW_LINE from os import chdir NEW_LINE cases = int ( join ( sep , ' ▁ ' ) ) NEW_LINE for line in open ( join ( sep , ' ▁ ' ) ) : NEW_LINE INDENT line = line . strip ( ) NEW_LINE n , target = map ( int , line . split ( ) ) NEW_LINE nums = [ ] NEW_LINE line = join ( sep , ' ▁ ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT nums . append ( join ( nums [ i : ] ) ) NEW_LINE DEDENT helper ( nums , target ) NEW_LINE DEDENT def helper ( nums , target ) : NEW_LINE INDENT is_target_found , can_print_yes = False , False NEW_LINE score , prev = 0 , - 1 NEW_LINE for num in nums : NEW_LINE INDENT if num == target : NEW_LINE INDENT is_target_found = True NEW_LINE DEDENT if num < target : NEW_LINE INDENT score -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT score += 1 NEW_LINE DEDENT if score > 0 and prev > - 1 : NEW_LINE INDENT can_print_yes = True NEW_LINE DEDENT prev , score = score , max ( score , 0 ) NEW_LINE DEDENT if ( len ( nums ) == 1 or can_print_yes ) and is_target_found : NEW_LINE INDENT print ( ' yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' no ' ) NEW_LINE DEDENT DEDENT
def import _sys , StringIO , traceback , time , traceback , count , limit , traceback , count , limit , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace , trace
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = 12 NEW_LINE ofs = [ [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] , [ 0 , 1 ] ] NEW_LINE def del ( self , map , y , x ) : NEW_LINE INDENT map [ y ] [ x ] = False NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT nx = x + ofs [ i ] [ 0 ] NEW_LINE ny = y + ofs [ i ] [ 1 ] NEW_LINE if 0 <= ny < N and 0 <= nx < N : NEW_LINE INDENT if self . map [ ny ] [ nx ] : NEW_LINE INDENT del ( self , map , ny , nx ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def solve ( self , map ) : NEW_LINE INDENT c = 0 NEW_LINE for y in range ( N ) : NEW_LINE INDENT for x in range ( N ) : NEW_LINE INDENT if self . map [ y ] [ x ] : NEW_LINE INDENT c += 1 NEW_LINE del ( self , map , y , x ) NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT def io ( self ) : NEW_LINE INDENT with open ( self . io , ' r ' ) as f : NEW_LINE INDENT for line in f : NEW_LINE INDENT data = [ line . decode ( ' utf - 8' ) for line in f ] NEW_LINE map = [ [ data [ y ] [ x ] == '1' ] for y in range ( N ) ] NEW_LINE print ( solve ( map ) ) NEW_LINE if line . startswith ( ' \n ' ) : NEW_LINE INDENT line = f . readline ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return Main NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i - 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def candies ( ) : NEW_LINE INDENT import numpy NEW_LINE import numpy NEW_LINE import numpy . random NEW_LINE import numpy . core NEW_LINE import numpy . random NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import numpy . core . genomial_structure NEW_LINE import
def import _pylab NEW_LINE class GFG ( object ) : NEW_LINE INDENT def printKDistinct ( self , arr , n , k ) : NEW_LINE INDENT h = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in h : NEW_LINE INDENT h [ arr [ i ] ] = h [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if len ( h ) < k : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if h [ arr [ i ] ] == 1 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if dist_count == k : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE print ( printKDistinct ( ar , n , 2 ) ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT def fib ( f ) : NEW_LINE INDENT f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , 59 ) : NEW_LINE INDENT f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 NEW_LINE DEDENT DEDENT def find_last_digit ( n ) : NEW_LINE INDENT f = [ 0 ] * 60 NEW_LINE fib ( f ) NEW_LINE index = int ( n % 60. ) NEW_LINE return f [ index ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT global n NEW_LINE ob = GFG ( ) NEW_LINE n = 1 NEW_LINE print ( ob . find_last_digit ( n ) ) NEW_LINE n = 61 NEW_LINE print ( ob . find_last_digit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( ob . find_last_digit ( n ) ) NEW_LINE n = 67 NEW_LINE print ( ob . find_last_digit ( n ) ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def import import * NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = ' ' NEW_LINE self . num_1 = int ( self . data ) NEW_LINE self . data = ' ' NEW_LINE self . num_2 = int ( self . data ) NEW_LINE self . data = ' ' NEW_LINE self . num_3 = int ( self . data ) NEW_LINE if self . num_1 == 7 : NEW_LINE INDENT if self . num_2 == 5 and self . num_3 == 5 : NEW_LINE INDENT self . data = ' YES ' NEW_LINE DEDENT else : NEW_LINE INDENT self . data = ' NO ' NEW_LINE DEDENT DEDENT elif self . num_2 == 7 : NEW_LINE INDENT if self . num_1 == 5 and self . num_3 == 5 : NEW_LINE INDENT self . data = ' YES ' NEW_LINE DEDENT else : NEW_LINE INDENT self . data = ' NO ' NEW_LINE DEDENT DEDENT elif self . num_3 == 7 : NEW_LINE INDENT if self . num_2 == 5 and self . num_1 == 5 : NEW_LINE INDENT self . data = ' YES ' NEW_LINE DEDENT else : NEW_LINE INDENT self . data = ' NO ' NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import __main__ NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 0 NEW_LINE self . z = 0 NEW_LINE self . w = 1 NEW_LINE a = [ i for i in range ( self . n ) if i == self . z ] NEW_LINE if n == 1 : NEW_LINE INDENT print ( abs ( w - a [ 0 ] ) ) NEW_LINE return NEW_LINE DEDENT ans1 = abs ( a [ n - 2 ] - a [ n - 1 ] ) NEW_LINE ans2 = abs ( w - a [ n - 1 ] ) NEW_LINE print ( max ( ans1 , ans2 ) ) NEW_LINE DEDENT DEDENT
def count_ele_less_than ( arr1 , arr2 , m , n ) : NEW_LINE INDENT import sys NEW_LINE for i in range ( m ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr2 [ j ] <= arr1 [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT sys . stdout . write ( " % d ▁ " % count ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] NEW_LINE return sum ( arr1 [ i ] * arr2 [ i ] for i in range ( n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def __main ( ) : NEW_LINE INDENT from sympy . core . compatibility import builtins NEW_LINE from sympy . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . differ import District NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . differ import District NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . differ import District NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . differ import District NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . differ import District NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . differ import District NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . differ import District NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . differ import District NEW_LINE from sympy . sets . sets import FiniteSet NEW_LINE from sympy . sets . differ import District NEW_LINE from sympy . sets . differ import District NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT import sys NEW_LINE from os . path import join NEW_LINE from os import rename NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os . path import dirname , join NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE name1 , name2 = join ( getcwd ( ) , join ( dirname ( dirname ( abspath ( __file__ ) ) ) , ' . . ' ) ) NEW_LINE print ( name1 , name2 ) NEW_LINE n = len ( dirname ( abspath ( join ( dirname ( abspath ( __file__ ) ) , ' . . ' ) ) ) ) NEW_LINE while 1 : NEW_LINE INDENT s1 , s2 = join ( getcwd ( ) , join ( dirname ( abspath ( join ( dirname ( abspath ( __file__ ) ) ) , ' . . ' ) ) ) ) NEW_LINE if s1 == name1 : NEW_LINE INDENT name1 = s2 NEW_LINE DEDENT if s1 == name2 : NEW_LINE INDENT name2 = s2 NEW_LINE DEDENT print ( name1 , name2 ) NEW_LINE n -= 1 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def import input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , )
def import input_stream NEW_LINE from sys import stdin , stdout NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from time import time NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import dirname , expanduser NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import exists NEW_LINE from os . path import exists NEW_LINE from os . remove import exists NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import islice NEW_LINE from itertools import islice NEW_LINE from itertools import islice NEW_LINE from random import randint NEW_LINE from itertools import islice NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE a = islice ( range ( n ) , n ) NEW_LINE p = islice ( range ( n ) , n ) NEW_LINE x = islice ( a , n ) NEW_LINE l = [ ] NEW_LINE r = [ ] NEW_LINE for i in islice ( p , n ) : NEW_LINE INDENT if x . first ( ) == p [ i ] : NEW_LINE INDENT l . append ( p [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT lower = islice ( x . lower ( p [ i ] ) , n ) NEW_LINE l . append ( p [ i ] - lower ) NEW_LINE DEDENT if x . last ( ) == p [ i ] : NEW_LINE INDENT r . append ( n - p [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT high = islice ( x . higher ( p [ i ] ) , n ) NEW_LINE r . append ( high - p [ i ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in islice ( l , n ) : NEW_LINE INDENT ans += int ( l [ i ] * r [ i ] * ( i + 1 ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def LPS ( x , y ) : return ( x > y ) NEW_LINE def lps ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE i , j , cl = 0 , len ( seq ) NEW_LINE L = [ [ 1 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if seq [ i ] == seq [ j ] and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif seq [ i ] == seq [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " , lps ( seq ) ) NEW_LINE DEDENT
def GFG ( last , first ) : NEW_LINE INDENT print ( first , end = ' ▁ ' ) NEW_LINE first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( ' ▁ + ▁ ' , x , end = ' ▁ ' ) NEW_LINE DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( last ) : NEW_LINE INDENT if 2 * N == ( last - first ) * ( last + first + 1 ) : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( ' - 1' , end = ' ▁ ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE DEDENT return findConsecutive ( main ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from sys import stdin as stdin NEW_LINE from sys import stderr NEW_LINE from os . path import join NEW_LINE from sys import argv NEW_LINE from os import devnull as devnull NEW_LINE if not devnull : NEW_LINE INDENT devnull = open ( ' / dev / null ' , ' w ' ) NEW_LINE DEDENT else : NEW_LINE INDENT devnull = sys . stderr NEW_LINE DEDENT if not ( even and odd ) : NEW_LINE INDENT devnull . write ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT sub = abs ( even - odd ) NEW_LINE if sub <= 1 : NEW_LINE INDENT devnull . write ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT devnull . write ( ' NO ' ) NEW_LINE DEDENT DEDENT devnull . close ( ) NEW_LINE DEDENT
def __gcd ( a , b ) : NEW_LINE INDENT import math NEW_LINE if not a or not b : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def number_of_squares ( x , y ) : NEW_LINE INDENT s = __gcd ( x , y ) NEW_LINE ans = ( x * y ) / ( s * s ) NEW_LINE return ans NEW_LINE DEDENT
def isAlphabatiaticOrder ( s ) : NEW_LINE INDENT import string NEW_LINE from string import ascii_lowercase NEW_LINE n = len ( s ) NEW_LINE c = [ s [ i ] for i in ascii_lowercase ] NEW_LINE c = [ s [ i ] for i in c ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if c [ i ] != s [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def GFG ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n - k ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE for j in range ( 1 , k ) : NEW_LINE INDENT if arr [ i + j ] > max : NEW_LINE INDENT max = arr [ i + j ] NEW_LINE DEDENT DEDENT print ( max , end = ' ▁ ' ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE k = 3 NEW_LINE print ( arr , len ( arr ) , k ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . graph = [ ] NEW_LINE self . visited = [ ] NEW_LINE self . color = [ ] NEW_LINE self . one = 0 NEW_LINE self . bipartite = 0 NEW_LINE self . count = 0 NEW_LINE self . mujun = False NEW_LINE def dfs ( a , c ) : NEW_LINE INDENT if self . visited [ a ] : NEW_LINE INDENT if self . color [ a ] in [ 0 , 1 ] : NEW_LINE INDENT mujun = True NEW_LINE DEDENT return 0 NEW_LINE DEDENT self . visited [ a ] = True NEW_LINE self . color [ a ] = c NEW_LINE total = 1 NEW_LINE for b in self . graph [ a ] : NEW_LINE INDENT total += dfs ( b , 1 - c ) NEW_LINE DEDENT return total NEW_LINE DEDENT DEDENT def run ( self ) : NEW_LINE INDENT Scanner ( ) . run ( ) NEW_LINE n , m = Scanner ( ) . scan ( ) NEW_LINE self . graph = [ [ ] for _ in range ( n ) ] NEW_LINE for u , v in Scanner ( ) . scan ( ) : NEW_LINE INDENT self . graph [ u ] . append ( v ) NEW_LINE self . graph [ v ] . append ( u ) NEW_LINE DEDENT self . visited = [ ] NEW_LINE self . color = [ ] NEW_LINE self . color = [ ] NEW_LINE self . one = 0 NEW_LINE self . bipartite = 0 NEW_LINE self . count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if self . visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT self . count += 1 NEW_LINE mujun = False NEW_LINE kind = self . dfs ( i , 0 ) NEW_LINE if kind == 1 : NEW_LINE INDENT self . one += 1 NEW_LINE DEDENT elif not mujun : NEW_LINE INDENT self . bipartite += 1 NEW_LINE DEDENT DEDENT DEDENT self . total = self . one * ( 2 * self . n - one ) NEW_LINE self . total += ( self . count - one ) ** 2 NEW_LINE self . total += self . bipartite ** 2 NEW_LINE print ( self . total ) NEW_LINE DEDENT
def import import input , outputfile , input_stream , input_encoding , output_encoding , problem , problem , problem , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding , input_encoding
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . main = sys . argv [ 0 ] NEW_LINE DEDENT def P ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT def P ( self , x , y ) : NEW_LINE INDENT return int ( self . x ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT with open ( " . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . . / . . / . / . . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . / . . / . / . . / . / . / . . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . . / . / . / . / . / . / . / . / .
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , a , b ) : NEW_LINE INDENT for i , c in enumerate ( a ) : NEW_LINE INDENT if c < b [ i ] : NEW_LINE INDENT return - 1 + ( i % 2 ) * 2 NEW_LINE DEDENT elif c > b [ i ] : NEW_LINE INDENT return 1 - ( i % 2 ) * 2 NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT sc = _main ( self ) NEW_LINE n , m = sc . regs [ 0 ] NEW_LINE a = [ ] NEW_LINE ids = { } NEW_LINE for i , c in enumerate ( sc ) : NEW_LINE INDENT a . append ( sc . regs [ 1 ] ) NEW_LINE ids [ c ] = i + 1 NEW_LINE DEDENT a . sort ( key = comp ) NEW_LINE for x in a : NEW_LINE INDENT print ( ids [ x ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import re NEW_LINE class GFG ( object ) : NEW_LINE INDENT def pre_process ( self , substrings , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dup = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT dup += s [ j ] NEW_LINE self . substrings . append ( dup ) NEW_LINE DEDENT DEDENT size = len ( substrings ) NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( substrings ) ) : NEW_LINE INDENT if substrings [ i ] > substrings [ j ] : NEW_LINE INDENT temp = substrings [ i ] NEW_LINE substrings [ i ] = substrings [ j ] NEW_LINE substrings [ j ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT s = " geek " NEW_LINE substrings = [ ] NEW_LINE pre_process ( substrings , s ) NEW_LINE queries = [ 1 , 5 , 10 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( substrings [ queries [ i ] - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . screen = sys . stdout NEW_LINE while 1 : NEW_LINE INDENT w , h = self . screen . getmaxyx ( ) NEW_LINE if not w and not h : NEW_LINE INDENT break NEW_LINE DEDENT if not w : NEW_LINE INDENT break NEW_LINE DEDENT s = self . screen . recv ( w ) NEW_LINE if not s : NEW_LINE INDENT print ( " % d ▁ % d " % ( x , y + 1 ) ) NEW_LINE break NEW_LINE DEDENT elif s == " R " : NEW_LINE INDENT d += 1 NEW_LINE if d == 4 : NEW_LINE INDENT d = 0 NEW_LINE DEDENT DEDENT elif s == " L " : NEW_LINE INDENT d -= 1 NEW_LINE if d == - 1 : NEW_LINE INDENT d = 3 NEW_LINE DEDENT DEDENT elif ( s == " F " and d == 0 ) or ( s == " B " and d == 2 ) : NEW_LINE INDENT t = self . screen . getmaxyx ( ) NEW_LINE y += t NEW_LINE if y > h - 1 : NEW_LINE INDENT y = h - 1 NEW_LINE DEDENT DEDENT elif ( s == " F " and d == 1 ) or ( s == " B " and d == 3 ) : NEW_LINE INDENT t = self . screen . getmaxyx ( ) NEW_LINE x += t NEW_LINE if x > w - 1 : NEW_LINE INDENT x = w - 1 NEW_LINE DEDENT DEDENT elif ( s == " F " and d == 2 ) or ( s == " B " and d == 0 ) : NEW_LINE INDENT t = self . screen . getmaxyx ( ) NEW_LINE y -= t NEW_LINE if y < 0 : NEW_LINE INDENT y = 0 NEW_LINE DEDENT DEDENT elif ( s == " F " and d == 3 ) or ( s == " B " and d == 1 ) : NEW_LINE INDENT t = self . screen . getmaxyx ( ) NEW_LINE x -= t NEW_LINE if x < 0 : NEW_LINE INDENT x = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def import import sys , string , count , total NEW_LINE class FileName ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 1 NEW_LINE self . str = string NEW_LINE self . count = 0 NEW_LINE self . total = 0 NEW_LINE for c in str : NEW_LINE INDENT if c == ' x ' : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT if count >= 3 : NEW_LINE INDENT total += count - 2 NEW_LINE count = 0 NEW_LINE DEDENT self . count = 0 NEW_LINE DEDENT DEDENT if count >= 3 : NEW_LINE INDENT total += count - 2 NEW_LINE count = 0 NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from string import printable NEW_LINE while 1 : NEW_LINE INDENT a = printable . readline ( ) NEW_LINE num = a . split ( ) NEW_LINE if num [ 0 ] == '0' : break NEW_LINE A , B = 0 , 0 NEW_LINE for c in num [ 1 : ] : NEW_LINE INDENT if c == ' A ' : NEW_LINE INDENT A += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT DEDENT if A > B : NEW_LINE INDENT A += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT print ( A , B ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import factorial NEW_LINE class GFG ( object ) : NEW_LINE INDENT def fact ( self , N ) : NEW_LINE INDENT i , product = 1 , 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT return product NEW_LINE DEDENT def nth_term ( self , N ) : NEW_LINE INDENT return ( self . factorial ( N ) * self . factorial ( N ) ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nth_term ( self ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if isZeroPresent : NEW_LINE INDENT return n NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import import sys NEW_LINE class AA ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = sys . stdin NEW_LINE self . t = sys . stdin . readline ( ) . strip ( ) NEW_LINE for i in range ( self . t ) : NEW_LINE INDENT k = sys . stdin . readline ( ) . strip ( ) NEW_LINE x = sys . stdin . readline ( ) . strip ( ) NEW_LINE f = k * 9 NEW_LINE for y in range ( x , 9 ) : NEW_LINE INDENT f -= 1 NEW_LINE DEDENT print ( f ) NEW_LINE DEDENT DEDENT DEDENT
def test_gf_gcd ( ) : NEW_LINE INDENT import sympy NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , l , b , x , y ) : NEW_LINE INDENT self . left = x * b NEW_LINE self . right = ( l - x - 1 ) * b NEW_LINE self . above = l * y NEW_LINE self . below = ( b - y - 1 ) * l NEW_LINE print ( max ( max ( self . left , self . right ) , max ( self . above , self . below ) ) ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT L , B = 8 , 8 NEW_LINE X , Y = 0 , 0 NEW_LINE return GFG ( L , B , X , Y ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT NO_OF_CHARS = 256 NEW_LINE def max_distinct_char ( str , n ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for c in str : NEW_LINE INDENT count [ c ] += 1 NEW_LINE DEDENT max_distinct = 0 NEW_LINE for c in str : NEW_LINE INDENT if c in count : NEW_LINE INDENT max_distinct += 1 NEW_LINE DEDENT DEDENT return max_distinct NEW_LINE DEDENT def smallest_substr_max_distict_char ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE max_distinct = max_distinct_char ( str , n ) NEW_LINE minl = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT subs = None NEW_LINE if i < j : NEW_LINE INDENT subs = str [ i : j ] NEW_LINE DEDENT else : NEW_LINE INDENT subs = str [ j : i ] NEW_LINE DEDENT subs_lenght = len ( subs ) NEW_LINE sub_distinct_char = max_distinct_char ( subs , subs_lenght ) NEW_LINE if subs_lenght < minl and max_distinct == sub_distinct_char : NEW_LINE INDENT minl = subs_lenght NEW_LINE DEDENT DEDENT DEDENT return minl NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT str = " AABBBCBB " NEW_LINE len = smallest_substr_max_distict_char ( str ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ smallest ▁ substring ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ characters ▁ : ▁ " , len ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE class Main ( object ) : NEW_LINE INDENT def aver ( arr ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in arr : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT return sum / len ( arr ) NEW_LINE DEDENT def fac ( x ) : NEW_LINE INDENT sum = 1 NEW_LINE while x > 0 : NEW_LINE INDENT sum = sum * x NEW_LINE x = x - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT def comb ( x , y ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = fac ( x ) NEW_LINE temp = ( fac ( y ) * fac ( x - y ) ) NEW_LINE return sum / temp NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT with open ( ' / proc / sys / stdin ' ) as sc : NEW_LINE INDENT n = sc . readline ( ) NEW_LINE while n > 0 : NEW_LINE INDENT sc . readline ( ) NEW_LINE sc . readline ( ) NEW_LINE f = sc . readline ( ) . split ( ' ' ) NEW_LINE s = sc . readline ( ) . split ( ' ' ) NEW_LINE flag = True NEW_LINE for i in f : NEW_LINE INDENT if i == ' R ' : NEW_LINE INDENT if i == ' B ' or i == ' G ' : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if i == ' R ' : NEW_LINE INDENT if i == ' B ' or i == ' G ' : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT DEDENT if flag : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT n = n - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return Main NEW_LINE DEDENT
def GFG ( n , q , size ) : NEW_LINE INDENT row = [ 0 for i in range ( n ) ] NEW_LINE col = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT x , y = q [ i ] NEW_LINE row [ x - 1 ] += 1 NEW_LINE col [ y - 1 ] += 1 NEW_LINE DEDENT r1 , r2 = 0 , 0 NEW_LINE c1 , c2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if row [ i ] % 2 == 0 : NEW_LINE INDENT r1 += 1 NEW_LINE DEDENT if row [ i ] % 2 == 1 : NEW_LINE INDENT r2 += 1 NEW_LINE DEDENT if col [ i ] % 2 == 0 : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if col [ i ] % 2 == 1 : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT count = r1 * c1 + r2 * c2 NEW_LINE return count NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , arr , n ) : NEW_LINE INDENT arr = np . array ( arr ) NEW_LINE DEDENT def check_type ( self ) : NEW_LINE INDENT if arr [ 0 ] <= arr [ 1 ] <= arr [ n - 2 ] : NEW_LINE INDENT print ( " Increasing " ) NEW_LINE DEDENT elif arr [ 0 ] >= arr [ 1 ] <= arr [ n - 2 ] : NEW_LINE INDENT print ( " Decreasing " ) NEW_LINE DEDENT elif arr [ 0 ] <= arr [ 1 ] <= arr [ n - 2 ] : NEW_LINE INDENT print ( " Increasing ▁ then ▁ decreasing " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Decreasing ▁ then ▁ increasing " ) NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT arr = np . array ( [ 1 , 2 , 3 , 4 ] ) NEW_LINE n = len ( arr ) NEW_LINE return GFG ( arr , n ) NEW_LINE DEDENT DEDENT
def import _sys , os , sys , sys , stdin , stdout , stderr , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , output , input , input , input , input , input , input , input , input , output , input , input , input , input , input , input , output , input , input , input , input , input , input , output , input , input , input , input , output , input , input , input , input , output , input , input , input , input , output , input , input , input , input , output , input , input , input , input , input , output , input , input , input , input , output , input , input , input , input , output , input , input , input , output , input , input , input , input , input , output , input , input , input , output , input , input , input , input , output , input , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , output , input , input , output , input , input , input , output , input , input , output , input , input , output , input , input , output , input , input , output , input , input , output , input , input , output , input , output , input , input , output , input , output , input , input , output , input , output , input , output , input , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , output , input , output , input , output , input , output , output , output , input , output , input , output , output , input , output , output , input , output , input , output , input , output , output , output , output , output , output
def import import os , sys , glob , glob , flags , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray
def test_GFG ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def number_of_ways ( self , x ) : NEW_LINE INDENT dp = np . zeros ( x + 1 ) NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT return dp [ x ] NEW_LINE DEDENT DEDENT x = 3 NEW_LINE print ( number_of_ways ( x ) ) NEW_LINE DEDENT
def test_gf_rearrange ( ) : NEW_LINE INDENT import sys NEW_LINE import scipy . sparse NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , arr , n ) : NEW_LINE INDENT j , temp = 0 , arr NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT if i != j : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE self . rearrange ( arr , n ) NEW_LINE print ( np . array ( arr ) ) NEW_LINE DEDENT DEDENT
def _import_GFG ( ) : NEW_LINE INDENT from scipy . special import csc_matrix NEW_LINE class GFG ( object ) : NEW_LINE INDENT def _centered ( self , n ) : NEW_LINE INDENT return n ** 2 + ( ( n - 1 ) ** 2 ) NEW_LINE DEDENT def _import_GFG ( self ) : NEW_LINE INDENT n = 7 NEW_LINE print ( " % th ▁ Centered " % n + " ▁ square ▁ number : ▁ % s " % self . _centered ( n ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def import import sys , StringIO , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes " " NEW_LINE from pipes import pipes NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import product NEW_LINE from itertools import chain NEW_LINE n = len ( sys . stdin . readline ( ) ) NEW_LINE nums = [ chain ( * repeat ( n , n ) ) for n in range ( n ) ] NEW_LINE nums = [ chain ( * repeat ( n , n ) ) for n in nums ] NEW_LINE first_half = second_half = 0 NEW_LINE length = n / 2 NEW_LINE for i in range ( length ) : NEW_LINE INDENT first_half += nums [ i ] NEW_LINE DEDENT for i in range ( length ) : NEW_LINE INDENT second_half += nums [ i ] NEW_LINE DEDENT result = ( first_half ** 2 ) + ( second_half ** 2 ) NEW_LINE print ( result ) NEW_LINE DEDENT
def __max_subarray_sum ( arr , size ) : NEW_LINE INDENT from math import max , pow NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , size ) : NEW_LINE INDENT max_so_far = self . max_subarray_sum ( arr , size ) NEW_LINE curr_max = self . curr_max NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( self . curr_max , curr_max + self . curr_max ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT DEDENT def len_of_long_subarr_with_given_sum ( self , n , k ) : NEW_LINE INDENT um = { } NEW_LINE sum , max_len = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += self . max_subarray_sum ( i , n ) NEW_LINE if sum == k : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if um . has_key ( sum ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if um . has_key ( sum - k ) : NEW_LINE INDENT if max_len < ( i - um [ sum - k ] ) : NEW_LINE INDENT max_len = i - um [ sum - k ] NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT def len_long_subarr_with_max_sum ( self , n ) : NEW_LINE INDENT max_sum = max_subarray_sum ( self , n ) NEW_LINE return len_of_long_subarr_with_given_sum ( self , n , max_sum ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT arr = [ 5 , - 2 , - 1 , 3 , - 4 ] NEW_LINE n = len ( args ) NEW_LINE print ( " Length ▁ of ▁ longest ▁ subarray ▁ " " having ▁ maximum ▁ sum ▁ = ▁ { } " . format ( len_long_subarr_with_max_sum ( self , n ) ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def import import sys , getopt NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from time import clock NEW_LINE from os import urandom NEW_LINE from math import sin , cos NEW_LINE from os import urandom NEW_LINE from os import fdopen , fdopen NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os . path import expanduser NEW_LINE from os . path import join , dirname , abspath NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os . path import expanduser NEW_LINE from os . path import join , dirname , abspath NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os . path import expanduser NEW_LINE from os . path import join , dirname , abspath NEW_LINE from os import path as dirname , abspath NEW_LINE from os . path import join NEW_LINE from os import path as dirname NEW_LINE from os . path import join NEW_LINE from os import path as dirname NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import exists NEW_LINE from os . path import exists NEW_LINE from os . path import exists NEW_LINE from os . path import exists NEW_LINE from os . path import join NEW_LINE from os . path import exists NEW_LINE from os . path import exists NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import dirname NEW_LINE from os . path import isfile NEW_LINE from os . walk import walk NEW_LINE from os . path import dirname , abspath NEW_LINE from os . walk import walk NEW_LINE from os . path import realpath , dirname , abspath NEW_LINE from os . walk import walk NEW_LINE from os . path import dirname , dirname , abspath NEW_LINE from os . walk import walk NEW_LINE from os . path import realpath , walk NEW_LINE from os . path import join , dirname , abspath NEW_LINE from os . walk import walk NEW_LINE from os . path import dirname , abspath NEW_LINE from os . walk import walk NEW_LINE from os . path import dirname , dirname , abspath NEW_LINE from os . walk import walk NEW_LINE from os . path import realpath , walk NEW_LINE from os . walk import walk NEW_LINE from os . path import dirname , dirname , abspath NEW_LINE from os . walk import walk NEW_LINE from os . path import dirname , dirname , abspath NEW_LINE from os . walk import walk NEW_LINE from os . walk import dirname , dirname , abspath NEW_LINE from os . walk import dirname , walk NEW_LINE from os . walk import dirname , dirname , abspath , isexos NEW_LINE DEDENT
def GFG ( dividend , divisor , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return [ 0 , dividend ] NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE n = dividend - divisor * mid NEW_LINE if n > divisor : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT elif n < 0 : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if n == divisor : NEW_LINE INDENT mid += 1 NEW_LINE n = 0 NEW_LINE DEDENT return [ mid , n ] NEW_LINE DEDENT return [ dividend , divisor , start , end ] NEW_LINE DEDENT def divide ( dividend , divisor ) : NEW_LINE INDENT return [ dividend , divisor , 1 , dividend ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT dividend , divisor = 10 , 3 NEW_LINE ans = divide ( dividend , divisor ) NEW_LINE print ( ans [ 0 ] , end = end ) NEW_LINE print ( ans [ 1 ] , end = end ) NEW_LINE DEDENT
def import _intfunc NEW_LINE import math NEW_LINE import os NEW_LINE import sys NEW_LINE class omar ( object ) : NEW_LINE INDENT def __init__ ( self , size ) : NEW_LINE INDENT self . size = size NEW_LINE DEDENT def __init__ ( self , size ) : NEW_LINE INDENT self . size = size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __setitem__ ( self , key , value ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . size NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy import array NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE DEDENT
def GFG ( n , from_rod = ' A ' , to_rod = ' B ' , aux_rod1 = ' C ' , aux_rod2 = ' C ' ) : NEW_LINE INDENT if n == 0 : return NEW_LINE if n == 1 : NEW_LINE INDENT print ( " Move ▁ disk ▁ { } ▁ from ▁ rod ▁ { } ▁ to ▁ rod ▁ { } " . format ( n , from_rod , to_rod ) ) NEW_LINE return NEW_LINE DEDENT towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) NEW_LINE print ( " Move ▁ disk ▁ { } ▁ from ▁ rod ▁ { } ▁ to ▁ rod ▁ { } " . format ( n - 1 , from_rod , to_rod ) ) NEW_LINE print ( " Move ▁ disk ▁ { } ▁ from ▁ rod ▁ { } ▁ to ▁ rod ▁ { } " . format ( n - 1 , from_rod , to_rod ) ) NEW_LINE print ( " Move ▁ disk ▁ { } ▁ from ▁ rod ▁ { } ▁ to ▁ rod ▁ { } " . format ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) ) NEW_LINE towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) NEW_LINE DEDENT
def import import os , sys , re , time NEW_LINE from os import urandom NEW_LINE from io import BytesIO NEW_LINE import math NEW_LINE from random import randint NEW_LINE from itertools import chain NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . r = sys . stdin NEW_LINE self . n = sys . stdout . readline ( ) NEW_LINE self . res = " " NEW_LINE for c in n : NEW_LINE INDENT if c == ' > ' : NEW_LINE INDENT self . res += "1000" NEW_LINE DEDENT elif c == ' < ' : NEW_LINE INDENT self . res += "1001" NEW_LINE DEDENT elif c == ' + ' : NEW_LINE INDENT self . res += "1010" NEW_LINE DEDENT elif c == ' - ' : NEW_LINE INDENT self . res += "1011" NEW_LINE DEDENT elif c == ' . ' : NEW_LINE INDENT self . res += "1100" NEW_LINE DEDENT elif c == ' , ' : NEW_LINE INDENT self . res += "1101" NEW_LINE DEDENT elif c == ' [ ' : NEW_LINE INDENT self . res += "1110" NEW_LINE DEDENT elif c == ' ] ' : NEW_LINE INDENT self . res += "1111" NEW_LINE DEDENT DEDENT DEDENT k = 0 NEW_LINE m = 0 NEW_LINE for c in chain ( * chain ( * repeat ( res ) ) ) : NEW_LINE INDENT y = randint ( 1 , int ( c ) ) NEW_LINE m += long ( ( pow ( 2 , k ) % 1000003 ) * y ) % 1000003 NEW_LINE k += 1 NEW_LINE DEDENT print ( m % 1000003 ) NEW_LINE DEDENT
def import import os , sys , getopt , pipes , quote , string , count , quote , marks , count , words , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , titles , keywords , keywords , titles , keywords , titles , keywords , keywords , titles , keywords , titles , keywords , keywords , titles , keywords , keywords , titles , keywords , keywords , titles , keywords , keywords , titles , keywords , keywords , titles , keywords , keywords , titles , keywords , keywords , titles , keywords , keywords , titles , keywords , keywords , titles , keywords , keywords , titles , keywords , keywords , titles , keywords , keywords , keywords , titles , keywords , keywords , keywords , titles , keywords , keywords , keywords , titles , keywords , keywords , keywords , titles , keywords , keywords , keywords , titles , keywords , keywords , keywords , titles , keywords , keywords , keywords , keywords , titles , keywords , keywords , keywords , keywords , keywords , keywords , keywords , titles , keywords , keywords , keywords , keywords , keywords , titles , keywords , keywords , keywords , keywords , keywords , titles , keywords , keywords , keywords , keywords , keywords , titles , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , titles , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords , keywords
def minsum ( arr , n ) : NEW_LINE INDENT import scipy . optimize NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sum , self . prev = arr [ 0 ] , arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if self . prev <= prev : NEW_LINE INDENT self . prev = self . prev + 1 NEW_LINE self . sum = self . sum + self . prev NEW_LINE DEDENT else : NEW_LINE INDENT self . sum = self . sum + self . prev NEW_LINE self . prev = self . prev NEW_LINE DEDENT DEDENT DEDENT DEDENT return GFG NEW_LINE DEDENT
def test_find_n ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_n ( self , k ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT if k == 1 : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif k % 4 == 0 : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif k % 4 == 3 : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT k = 7 NEW_LINE res = find_n ( k ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def subsetXOR ( arr , n , K ) : NEW_LINE INDENT import math NEW_LINE max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max_ele : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << int ( math . log ( max_ele ) / math . log ( 2 ) + 1 ) ) - 1 NEW_LINE dp = [ [ 0 for i in range ( 0 , n + 1 ) ] for j in range ( 0 , m + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT for k in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if k != 0 : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from math import pow NEW_LINE from random import randint NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE D = int ( sys . stdin . read ( ) ) NEW_LINE G = int ( sys . stdin . read ( ) ) NEW_LINE p = [ log ( x ) for x in range ( D ) ] NEW_LINE c = [ log ( x ) for x in range ( D ) ] NEW_LINE min = 1001 NEW_LINE count = ans = 0 NEW_LINE a = 4 NEW_LINE for i in range ( pow ( 2 , D ) ) : NEW_LINE INDENT bit = ' % % d % s ' % ( D , int ( i ) ) . replace ( ' ▁ ' , '0' ) NEW_LINE N = len ( bit ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT if bit [ j ] == '1' : NEW_LINE INDENT count += p [ j ] * ( j + 1 ) * 100 + c [ j ] NEW_LINE ans += p [ j ] NEW_LINE DEDENT DEDENT if count < G : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if bit [ j ] == '0' : NEW_LINE INDENT l = p [ j ] NEW_LINE while count < G and l > 0 : NEW_LINE INDENT count += ( j + 1 ) * 100 NEW_LINE ans += 1 NEW_LINE l -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if count >= G : NEW_LINE INDENT min = min ( ans , min ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 0 NEW_LINE DEDENT print ( min ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from nltk . corpus import brown NEW_LINE from nltk . util import get_scanner NEW_LINE scanner = get_scanner ( ) NEW_LINE n = scanner . count ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = 0 NEW_LINE a , b = scanner . split ( ) NEW_LINE for j in range ( a ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if b == k : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT
def import _intpredicate NEW_LINE import math NEW_LINE import os NEW_LINE import sys NEW_LINE class omar ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin NEW_LINE self . size = sys . maxsize NEW_LINE self . count = 0 NEW_LINE self . arr = [ ] NEW_LINE for i in range ( self . size ) : NEW_LINE INDENT self . arr . append ( i ) NEW_LINE DEDENT self . arr . sort ( ) NEW_LINE for i in range ( 1 , self . size - 1 ) : NEW_LINE INDENT if self . arr [ i ] > self . arr [ 0 ] and self . arr [ i ] < self . arr [ - 1 ] : NEW_LINE INDENT self . count += 1 NEW_LINE DEDENT DEDENT print ( self . count ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import log NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def minAbsDiff ( self ) : NEW_LINE INDENT left = int ( log ( self . n ) / log ( 2 ) ) NEW_LINE right = self . left * 2 NEW_LINE return min ( ( self . n - left ) , ( self . right - self . n ) ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT DEDENT
def GFG ( arr1 , n , arr2 , m ) : NEW_LINE INDENT import numpy as np NEW_LINE table = [ 0 for j in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if arr1 [ i ] == arr2 [ j ] : NEW_LINE INDENT if current + 1 > table [ j ] : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT if arr1 [ i ] > arr2 [ j ] : NEW_LINE INDENT if table [ j ] > current : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if table [ i ] > result : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT bitCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bitCount += count_set_bits_util ( i ) NEW_LINE DEDENT return bitCount NEW_LINE def count_set_bits_util ( x ) : NEW_LINE INDENT if x <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 0 if x % 2 == 0 else 1 ) + count_set_bits_util ( x / 2 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 4 NEW_LINE print ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ " , end = " " ) NEW_LINE print ( count_set_bits ( n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def gf_partition ( arr , low , high ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . pivot = arr [ low ] NEW_LINE DEDENT DEDENT i , j = low - 1 , high + 1 NEW_LINE while True : NEW_LINE INDENT while True : NEW_LINE INDENT i += 1 NEW_LINE if arr [ i ] < pivot : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT j -= 1 NEW_LINE if arr [ j ] > pivot : NEW_LINE INDENT break NEW_LINE DEDENT if i >= j : NEW_LINE INDENT return j NEW_LINE DEDENT temp = arr [ i ] NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , temp NEW_LINE DEDENT DEDENT def quick_sort ( self , low , high ) : NEW_LINE INDENT if low < high : NEW_LINE INDENT pi = partition ( self , low , high ) NEW_LINE quick_sort ( self , low , pi ) NEW_LINE quick_sort ( self , pi + 1 , high ) NEW_LINE DEDENT DEDENT def print_array ( self , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( self . arr ) NEW_LINE quick_sort ( self , 0 , n - 1 ) NEW_LINE print ( ' Sorted ▁ array : ' ) NEW_LINE print_array ( self , n ) NEW_LINE DEDENT DEDENT
def GFG ( array , position1 , position2 ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , array , position1 , position2 ) : NEW_LINE INDENT temp = array [ position1 ] NEW_LINE array [ position1 ] = array [ position2 ] NEW_LINE array [ position2 ] = temp NEW_LINE DEDENT def partition ( self , arr , low , high ) : NEW_LINE INDENT pivot = arr [ high ] NEW_LINE i = ( low - 1 , ) NEW_LINE for j in range ( low , high - 1 ) : NEW_LINE INDENT if arr [ j ] <= pivot : NEW_LINE INDENT i += 1 NEW_LINE self . swap ( arr , i , j ) NEW_LINE DEDENT DEDENT self . swap ( arr , i + 1 , high ) NEW_LINE return ( i + 1 , ) NEW_LINE DEDENT DEDENT def quicksort ( self , arr , low , high ) : NEW_LINE INDENT if low < high : NEW_LINE INDENT pi = self . partition ( arr , low , high ) NEW_LINE self . quicksort ( arr , low , pi - 1 ) NEW_LINE self . quicksort ( arr , pi + 1 , high ) NEW_LINE DEDENT DEDENT def printArray ( self , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( self . swap ( arr , 0 , n - 1 ) ) NEW_LINE self . quicksort ( arr , 0 , n - 1 ) NEW_LINE print ( ' Sorted ▁ array : ' ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT DEDENT
def GFG ( a , size ) : NEW_LINE INDENT max_so_far , max_ending_here = int ( 0 ) , 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE def min_possible_sum ( a , n , x ) : NEW_LINE INDENT mxsum = max_subarray_sum ( a , n ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum = sum - mxsum + mxsum / x NEW_LINE print ( sum , end = ' \n ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = 3 NEW_LINE X = 2 NEW_LINE A = [ 1 , - 2 , 3 ] NEW_LINE min_possible_sum ( A , N , X ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import _readline NEW_LINE from sys import stdin NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import readline NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE import readline NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE DEDENT
def import _pylab NEW_LINE class GFG ( object ) : NEW_LINE INDENT def printArray ( N , SUM , K ) : NEW_LINE INDENT minSum = ( N * ( N + 1 ) ) / 2 NEW_LINE maxSum = ( N * K ) - ( N * ( N - 1 ) ) / 2 NEW_LINE if minSum > SUM or maxSum < SUM : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT arr = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT sum = minSum NEW_LINE for i in range ( N , 1 , - 1 ) : NEW_LINE INDENT x = sum + ( K - i ) NEW_LINE if x < SUM : NEW_LINE INDENT sum = sum + ( K - i ) NEW_LINE arr . append ( K ) NEW_LINE K -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( SUM - sum ) NEW_LINE sum = SUM NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def import _sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT COST = 3 NEW_LINE def maxitems ( self , x , y , z ) : NEW_LINE INDENT type1 = x / COST NEW_LINE x %= COST NEW_LINE type2 = y / COST NEW_LINE y %= COST NEW_LINE type3 = z / COST NEW_LINE z %= COST NEW_LINE type4 = min ( x , min ( y , z ) ) NEW_LINE maxitems = type1 + type2 + type3 + type4 NEW_LINE return maxitems NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT x , y , z = 4 , 5 , 6 NEW_LINE print ( maxitems ( x , y , z ) ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import queue NEW_LINE class GFG ( object ) : NEW_LINE INDENT def run ( self ) : NEW_LINE INDENT total_time = 0 NEW_LINE while not self . empty ( ) : NEW_LINE INDENT x = self . pop ( ) NEW_LINE y = self . pop ( ) NEW_LINE if x == y : NEW_LINE INDENT self . pop ( ) NEW_LINE self . pop ( ) NEW_LINE self . pop ( ) NEW_LINE total_time += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . pop ( ) NEW_LINE self . append ( x ) NEW_LINE self . append ( y ) NEW_LINE self . append ( y ) NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT DEDENT A = [ 3 , 2 , 1 , 4 ] NEW_LINE B = [ 4 , 1 , 3 , 2 ] NEW_LINE print ( run_tasks ( A , B ) ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT def line ( x0 , y0 ) : NEW_LINE INDENT c = int ( 2 * y0 * x0 ) NEW_LINE print ( ' % . 1 . f ' % y0 , ' x ' , ' ▁ + ▁ % . 1 . f ' % x0 , ' y ▁ = ▁ % . 1 . f ' % c ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x0 , y0 = 4 , 3 NEW_LINE return line ( x0 , y0 ) NEW_LINE DEDENT DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , agrs ) : NEW_LINE INDENT self . agrs = agrs NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . agrs . append ( agrs ) NEW_LINE DEDENT n = len ( agrs ) NEW_LINE seen = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = list ( agrs ) NEW_LINE l = len ( s ) NEW_LINE x = [ 0 ] * 26 NEW_LINE s1 = " " NEW_LINE for i in range ( l ) : NEW_LINE INDENT c = s [ i ] - ord ( ' a ' ) NEW_LINE x [ c ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if x [ i ] : NEW_LINE INDENT s1 += ( chr ( ord ( ' a ' ) + i ) ) NEW_LINE DEDENT DEDENT seen . add ( s1 ) NEW_LINE DEDENT print ( len ( seen ) ) NEW_LINE DEDENT
def import _pylab NEW_LINE import pylab NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . cm NEW_LINE import matplotlib . pylab as plt NEW_LINE import matplotlib . pylab as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . specshow NEW_LINE plt . show ( ) NEW_LINE q = np . arange ( 3 ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT plt . subplot ( 2 , i + 1 , j ) NEW_LINE plt . imshow ( gridspec . get ( ' axes ' , [ ] ) , cmap = ' gray ' ) NEW_LINE plt . show ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import string NEW_LINE class GFG ( object ) : NEW_LINE INDENT def isAnyNotPalindrome ( self ) : NEW_LINE INDENT unique = set ( string . ascii_lowercase ) NEW_LINE if len ( unique ) > 1 : return True NEW_LINE else : return False NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT s = ' aaaaab ' NEW_LINE if isAnyNotPalindrome ( s ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT
def test ( arr , n ) : NEW_LINE INDENT return arr [ n // 2 ] NEW_LINE def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_majority ( arr , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import _open , fileinput , fileinput , fileinput , fileinput , fileinput , fileinput , fileinput , fileinput , fileinput , fileinput , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input
def count_subarrays ( arr , n , K ) : NEW_LINE INDENT from scipy . sparse import csc_matrix NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if bitwise_or >= K : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def test_gf_gcd ( ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def can_be_equal ( self , a , b , c , k ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] NEW_LINE k = k - diff NEW_LINE if k < 0 or k % 3 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT a1 , b1 , c1 , k1 = 6 , 3 , 2 , 7 NEW_LINE if gf_gcd ( a1 , b1 , c1 , k1 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT adjacency = [ ] NEW_LINE def insert ( self , x , y ) : NEW_LINE INDENT self . adjacency [ x ] . append ( y ) NEW_LINE DEDENT def dfs ( self , node , leaf , vis ) : NEW_LINE INDENT self . leaf [ node ] = 0 NEW_LINE vis [ node ] = 1 NEW_LINE for it in self . adjacency [ node ] : NEW_LINE INDENT if vis [ it ] == 0 : NEW_LINE INDENT dfs ( it , leaf , vis ) NEW_LINE self . leaf [ node ] += leaf [ it ] NEW_LINE DEDENT DEDENT if not self . adjacency [ node ] : NEW_LINE INDENT self . leaf [ node ] = 1 NEW_LINE DEDENT DEDENT def print_leaf ( self , n ) : NEW_LINE INDENT for i in range ( 1 , self . n + 1 ) : NEW_LINE INDENT print ( " The ▁ node ▁ % d ▁ has ▁ % d ▁ leaf ▁ nodes \n " % ( i , self . leaf [ i ] ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT N = 6 NEW_LINE for i in range ( 0 , N + 1 ) : NEW_LINE INDENT self . adjacency . append ( [ ] ) NEW_LINE DEDENT DEDENT def insert ( self , node ) : NEW_LINE INDENT self . adjacency [ node ] = [ ] NEW_LINE DEDENT def dfs ( self , node ) : NEW_LINE INDENT self . adjacency [ node ] . append ( node ) NEW_LINE DEDENT def print_leaf ( self , node ) : NEW_LINE INDENT self . adjacency [ node ] = [ ] NEW_LINE DEDENT def insert ( self , node ) : NEW_LINE INDENT self . adjacency [ node ] = [ ] NEW_LINE DEDENT def dfs ( self , node ) : NEW_LINE INDENT self . adjacency [ node ] . append ( node ) NEW_LINE DEDENT def print_leaf ( self , node ) : NEW_LINE INDENT self . adjacency [ node ] = [ ] NEW_LINE DEDENT DEDENT
def import __main__ NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT self . s = raw_input ( ) NEW_LINE v = self . s . split ( ' ▁ ' ) NEW_LINE n = self . s . split ( ' ▁ ' ) [ 0 ] NEW_LINE for i , e in enumerate ( reversed ( range ( len ( v ) ) ) ) : NEW_LINE INDENT if v [ i ] != '1' : NEW_LINE INDENT print ( v [ i ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( '1' ) NEW_LINE DEDENT DEDENT
def import os , re , N NEW_LINE from string import ascii_letters NEW_LINE from string import digits NEW_LINE from string import punctuation NEW_LINE from string import digits NEW_LINE from string import letters NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import punctuation NEW_LINE from string import digits NEW_LINE from string import letters NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import letters NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import punctuation NEW_LINE from string import digits NEW_LINE from string import letters NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import letters NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import letters NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import letters NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import letters NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import punctuation NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import digits NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE DEDENT
def LCS_3Strings ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT for k in range ( 0 , o ) : NEW_LINE INDENT if i == 0 or j == 0 or k == 0 : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT
def test_cf596b ( ) : NEW_LINE INDENT import numpy as np NEW_LINE from numpy . testing import assert_array_almost_equal NEW_LINE with open ( ' test . txt ' , ' r ' ) as f : NEW_LINE INDENT n = np . random . randint ( 1 , 6 ) NEW_LINE arr = np . random . randint ( 1 , 6 ) NEW_LINE answer = np . abs ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT answer += np . abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT assert_array_almost_equal ( answer , np . ones ( n ) ) NEW_LINE DEDENT DEDENT
def GFG ( n , a ) : NEW_LINE INDENT sum , c1 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE if a [ i ] == 1 : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if sum % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( sum // 2 ) % 2 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if c1 > 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE from math import sin , cos , cos , log NEW_LINE with open ( " / proc / test . txt " , " r " ) as sc : NEW_LINE INDENT n = randint ( 1 , 5 ) NEW_LINE arr = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr . append ( sc . read ( ) ) NEW_LINE DEDENT dp = [ 0 ] * 5 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 1 ] = dp [ 1 ] + ( arr [ i ] == 1 ) NEW_LINE dp [ 2 ] = max ( dp [ 1 ] , dp [ 2 ] + ( arr [ i ] == 2 ) ) NEW_LINE dp [ 3 ] = max ( dp [ 2 ] , dp [ 3 ] + ( arr [ i ] == 1 ) ) NEW_LINE dp [ 4 ] = max ( dp [ 3 ] , dp [ 4 ] + ( arr [ i ] == 2 ) ) NEW_LINE DEDENT print ( dp [ 4 ] ) NEW_LINE DEDENT DEDENT
def test_count_even_odd ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , min , max , steps ) : NEW_LINE INDENT self . min = min NEW_LINE self . max = max NEW_LINE self . steps = steps NEW_LINE self . steps = [ [ 0 , 1 ] , [ 3 , 4 ] ] NEW_LINE self . beven = True NEW_LINE self . aeven = False NEW_LINE self . n = 2 NEW_LINE for a , b in steps : NEW_LINE INDENT if not ( self . aeven or ( a & 1 ) > 0 ) : NEW_LINE INDENT self . aeven = True NEW_LINE DEDENT if self . beven : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT self . beven = False NEW_LINE DEDENT DEDENT elif not ( ( a & 1 ) > 0 ) : NEW_LINE INDENT if not ( ( b & 1 ) > 0 ) : NEW_LINE INDENT self . beven = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT self . beven = True NEW_LINE DEDENT DEDENT DEDENT if self . beven : NEW_LINE INDENT self . even = int ( max ) // 2 - int ( min - 1 ) // 2 NEW_LINE self . odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT self . even = int ( max ) // 2 - int ( min - 1 ) // 2 NEW_LINE self . odd = 0 NEW_LINE DEDENT if not ( self . beven ^ self . aeven ) : NEW_LINE INDENT self . even += self . max - min + 1 - int ( max ) // 2 + int ( min - 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT self . odd += self . max - min + 1 - int ( max ) // 2 + int ( min - 1 ) // 2 NEW_LINE DEDENT print ( " even ▁ = ▁ % d , ▁ odd ▁ = ▁ % d " % ( self . even , self . odd ) ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT min , max = 1 , 4 NEW_LINE steps = [ [ 1 , 2 ] , [ 3 , 4 ] ] NEW_LINE self . count_even_odd ( min , max , steps ) NEW_LINE DEDENT DEDENT
def JohnyLikesNumbers ( ) : NEW_LINE INDENT _input = raw_input NEW_LINE n , k = _input . __next__ ( ) NEW_LINE print ( ( n / k + 1 ) ** 2 ) NEW_LINE DEDENT
def test_KPFNums ( ) : NEW_LINE INDENT import sys NEW_LINE from sympy . polys . polygamma import KPFNums NEW_LINE prime = [ True ] * ( B + 1 ) NEW_LINE p_factors = [ 0 ] * ( B + 1 ) NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if p_factors [ p ] == 0 : NEW_LINE INDENT for i in range ( p , B + 1 , p ) : NEW_LINE INDENT p_factors [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if p_factors [ i ] == K : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def reverseWords ( data ) : NEW_LINE INDENT import sys NEW_LINE import string NEW_LINE import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = data NEW_LINE DEDENT DEDENT def reverseWords ( self ) : NEW_LINE INDENT st = [ ] NEW_LINE for char in self . data : NEW_LINE INDENT if char != ' ▁ ' : NEW_LINE INDENT st . append ( char ) NEW_LINE DEDENT else : NEW_LINE INDENT while st . empty ( ) == False : NEW_LINE INDENT sys . stdout . write ( st . pop ( ) ) NEW_LINE DEDENT sys . stdout . write ( ' ▁ ' ) NEW_LINE DEDENT DEDENT while st . empty ( ) == False : NEW_LINE INDENT sys . stdout . write ( st . pop ( ) ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT data = ' Geeks ▁ for ▁ Geeks ' NEW_LINE reverseWords ( data ) NEW_LINE DEDENT DEDENT
def import import _sys , string NEW_LINE class Task ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( string . ascii_letters ) NEW_LINE self . p = [ ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT self . p . append ( _sys . stdin . read ( ) ) NEW_LINE DEDENT DEDENT def run ( self ) : NEW_LINE INDENT self . only_fist_solve = 0 NEW_LINE self . only_second_solve = 0 NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT r = _sys . stdin . read ( ) NEW_LINE if p [ i ] == 1 and r == 0 : NEW_LINE INDENT only_fist_solve += 1 NEW_LINE DEDENT elif p [ i ] == 0 and r == 1 : NEW_LINE INDENT only_second_solve += 1 NEW_LINE DEDENT DEDENT if only_fist_solve == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( only_second_solve + only_fist_solve ) / only_fist_solve ) NEW_LINE DEDENT DEDENT DEDENT
def import sys , StringIO , I , O , I , O , I , O , I , O , I , O , I , O , O , K , O , N , O , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , K , O , O , K , O , K , O , K , O , O , K , O , K , O , O , K , O , O , K , O , K , O , O , K , O , K , O , O , K , O , O , K , O , O , K , O , O , K , O , K , O , O , K , O , O , K ,
def import _sys NEW_LINE import sys NEW_LINE import inspect NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . h = 0 NEW_LINE self . w = 0 NEW_LINE self . c = 1 NEW_LINE self . ans = 1 NEW_LINE self . count = 1 NEW_LINE self . color_order = [ ] NEW_LINE self . map = [ ] NEW_LINE self . tmp = [ ] NEW_LINE DEDENT def read ( self ) : NEW_LINE INDENT with open ( self . filename ) as sc : NEW_LINE INDENT for ns in sc . readlines ( ) : NEW_LINE INDENT stack = [ ] NEW_LINE for n in ns : NEW_LINE INDENT if n [ : 1 ] == ' . ' : NEW_LINE INDENT stack . append ( float ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sw = n [ 0 ] NEW_LINE if sw in [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ] : NEW_LINE INDENT stack . append ( float ( n ) ) NEW_LINE DEDENT elif sw == ' + ' : NEW_LINE INDENT x = stack . pop ( ) NEW_LINE y = stack . pop ( ) NEW_LINE stack . append ( x + y ) NEW_LINE DEDENT elif sw == ' - ' : NEW_LINE INDENT x = stack . pop ( ) NEW_LINE y = stack . pop ( ) NEW_LINE stack . append ( y - x ) NEW_LINE DEDENT elif sw == ' * ' : NEW_LINE INDENT x = stack . pop ( ) NEW_LINE y = stack . pop ( ) NEW_LINE stack . append ( y * x ) NEW_LINE DEDENT elif sw == ' / ' : NEW_LINE INDENT x = stack . pop ( ) NEW_LINE y = stack . pop ( ) NEW_LINE stack . append ( y / x ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT ans = stack . pop ( ) NEW_LINE sys . stdout . write ( ' % .6f \n ' % ans ) NEW_LINE DEDENT DEDENT
def import function_height NEW_LINE class FunctionHeight ( object ) : NEW_LINE INDENT def __init__ ( self , n , k ) : NEW_LINE INDENT self . n = n NEW_LINE self . k = k NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " Function ▁ Height ▁ % s " % self . n if n >= k else " Function ▁ Height ▁ % s " % self . k NEW_LINE DEDENT DEDENT
def test_find_nth_term ( ) : NEW_LINE INDENT import math NEW_LINE from math import pow NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import pow NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import cos , sin NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , sin , cos NEW_LINE from math import sin , sin , cos , sin NEW_LINE from math import sin , cos , sin NEW_LINE from math import sin , sin , cos , sin NEW_LINE from math import sin , sin , cos , sin NEW_LINE from math import sin , sin , cos , sin NEW_LINE from math import sin , sin , cos , sin NEW_LINE from math import sin , sin , cos , sin , sin NEW_LINE from math import sin , sin , cos , sin , sin NEW_LINE from math import sin , sin , cos , sin , sin NEW_LINE from math import sin , sin , sin , cos , sin NEW_LINE from math import sin , sin , sin , cos , sin , sin NEW_LINE from math import sin , sin , sin , cos , sin , sin NEW_LINE from math import sin , sin , sin , sin , cos , sin , sin , sin
def GFG ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE arr = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] >= arr [ i ] : NEW_LINE INDENT arr += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( arr + 1 ) * arr [ i ] ) / 2 ) NEW_LINE arr = 1 NEW_LINE DEDENT DEDENT if len ( arr ) > 1 : NEW_LINE INDENT cnt += ( ( ( arr - 1 ) * arr [ i ] ) / 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def maximize ( A1 , A2 , n , x , y ) : NEW_LINE INDENT c = np . zeros ( n ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = A2 [ i ] - A1 [ i ] NEW_LINE sum += A1 [ i ] NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if c [ i ] < c [ i + 1 ] : NEW_LINE INDENT temp = c [ i ] NEW_LINE c [ i ] = c [ i + 1 ] NEW_LINE c [ i + 1 ] = temp NEW_LINE DEDENT DEDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += c [ i ] NEW_LINE if i + 1 >= ( n - x ) : NEW_LINE INDENT maxi = max ( sum , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT DEDENT A1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE A2 = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE n = 5 NEW_LINE x , y = 3 , 3 NEW_LINE print ( maximize ( A1 , A2 , n , x , y ) ) NEW_LINE DEDENT
def main_module ( ) : NEW_LINE INDENT import sys NEW_LINE from os import path NEW_LINE from os . path import join NEW_LINE f = open ( path , ' r ' ) NEW_LINE lines = f . readlines ( ) NEW_LINE f . close ( ) NEW_LINE t = int ( lines . pop ( 0 ) ) NEW_LINE while t : NEW_LINE INDENT lines = f . readlines ( ) NEW_LINE x = int ( lines . pop ( 0 ) ) NEW_LINE s = str ( x ) NEW_LINE extra = len ( s ) NEW_LINE temp = len ( u ' ' . join ( s ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , temp ) : NEW_LINE INDENT ans += 10 NEW_LINE DEDENT ans += ( extra ) * ( extra + 1 ) / 2 NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
def import sys , getopt NEW_LINE from os import popen NEW_LINE from time import time NEW_LINE from math import ceil NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math NEW_LINE import f NEW_LINE from math import f NEW_LINE from math NEW_LINE import string NEW_LINE from math NEW_LINE import math NEW_LINE from math . hexf import f NEW_LINE from math . hexf import f NEW_LINE from math import log NEW_LINE from math . hexf import f NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . r1 , self . r2 , self . c1 , self . c2 , self . d1 , self . d2 = sys . stdin . read ( ) . decode ( ' utf - 8' ) . split ( ' ▁ ' ) NEW_LINE DEDENT DEDENT if ( c1 + c2 - r1 - r2 ) != 0 or ( d1 + d2 - r1 - r2 ) != 0 : NEW_LINE INDENT sys . stdout . write ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE t , z , y , x = ( r2 - d2 + c2 ) // 2 , d2 - c2 + t , c2 - t , r1 + r2 - y - z - t NEW_LINE box = [ x , y , z , t ] NEW_LINE for gem in box : NEW_LINE INDENT if gem > 9 or gem < 1 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( x == y or x == z or x == t or y == z or y == t or z == t ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT if flag : NEW_LINE INDENT sys . stdout . write ( ' % d ▁ % d % d % d ▁ % d ' % ( x , y , z , t ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def _calc_nearest_weight ( x , w , i , sum , additions ) : NEW_LINE INDENT from itertools import chain NEW_LINE from itertools import chain NEW_LINE for line in chain ( [ x ] , repeat ( len ( x ) ) ) : NEW_LINE INDENT n , m = map ( int , line . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ chain ( [ x ] , [ ] ) for x in line . split ( ) ] NEW_LINE w = [ chain ( [ x ] , [ ] ) for x in line . split ( ) ] NEW_LINE common_additions = None NEW_LINE for i in range ( n ) : NEW_LINE INDENT additions = chain ( [ ] , [ ] ) NEW_LINE b_Just = _calc_nearest_weight ( a [ i ] , w [ : i ] , 0 , additions ) NEW_LINE if not b_Just : NEW_LINE INDENT if common_additions is None : NEW_LINE INDENT common_additions = additions NEW_LINE DEDENT else : NEW_LINE INDENT common_additions . sort ( ) NEW_LINE DEDENT DEDENT DEDENT if common_additions is None : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if common_additions : NEW_LINE INDENT print ( common_additions [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT def calc_nearest_weight ( x , w , i , sum , additions ) : NEW_LINE INDENT if x == sum : NEW_LINE INDENT return True NEW_LINE DEDENT if i == len ( w ) : NEW_LINE INDENT additions . append ( abs ( x - sum ) ) NEW_LINE return False NEW_LINE DEDENT if calc_nearest_weight ( x , w , i + 1 , sum , additions ) : NEW_LINE INDENT return True NEW_LINE DEDENT if calc_nearest_weight ( x , w , i + 1 , sum + w [ i ] , additions ) : NEW_LINE INDENT return True NEW_LINE DEDENT return calc_nearest_weight ( x , w , i + 1 , sum - w [ i ] , additions ) NEW_LINE DEDENT return calc_nearest_weight NEW_LINE DEDENT
def import import struct NEW_LINE from os import sys NEW_LINE from os import urandom NEW_LINE from math import sin , cos , pow NEW_LINE from os import fdopen , fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE DEDENT
def __startswith__ ( str , pre ) : NEW_LINE INDENT from os import path NEW_LINE str_len = len ( str ) NEW_LINE pre_len = len ( pre ) NEW_LINE i , j = 0 , 0 NEW_LINE while i < str_len and j < pre_len : NEW_LINE INDENT if str [ i ] != pre [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def endswith ( str , suff ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE j = len ( suff ) - 1 NEW_LINE while i >= 0 and j >= 0 : NEW_LINE INDENT if str [ i ] != suff [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def checkstring ( str , a , b ) : NEW_LINE INDENT if len ( str ) != len ( a ) + len ( b ) : NEW_LINE INDENT return False NEW_LINE DEDENT if startswith ( str , a ) : NEW_LINE INDENT if endswith ( str , b ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if startswith ( str , b ) : NEW_LINE INDENT if endswith ( str , a ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT str , a , b = ' GeeksforGeeks ' , ' Geeksfo ' , ' rGeeks ' NEW_LINE if checkstring ( str , a , b ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def printCombination ( self , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if i % 3 : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if j % 3 : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if k % 3 : NEW_LINE INDENT if ( i + j + k ) == n : NEW_LINE INDENT print ( i , j , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 233 NEW_LINE print ( n ) NEW_LINE DEDENT DEDENT
def count_integral_solutions ( n ) : NEW_LINE INDENT import sympy NEW_LINE class GFG ( sympy . polys . RootOf ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT super ( GFG , self ) . __init__ ( ) NEW_LINE self . n = n NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT for k in range ( 0 , ( n - i - j ) ) : NEW_LINE INDENT if i + j + k == n : NEW_LINE INDENT self . result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return GFG ( n ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT TEN = 10 NEW_LINE def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % TEN NEW_LINE n /= TEN NEW_LINE DEDENT return sum NEW_LINE DEDENT def getNthTerm ( n ) : NEW_LINE INDENT sum = digitSum ( n ) NEW_LINE if sum % TEN == 0 : NEW_LINE INDENT return ( n * TEN ) NEW_LINE DEDENT extra = TEN - ( sum % TEN ) NEW_LINE return ( ( n * TEN ) + extra ) NEW_LINE DEDENT def firstNTerms ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( getNthTerm ( i ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 10 NEW_LINE firstNTerms ( n ) NEW_LINE DEDENT DEDENT
def GFG ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while a : NEW_LINE INDENT if a & 1 : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE def breakInteger ( N ) : NEW_LINE INDENT if N == 2 : return 1 NEW_LINE if N == 3 : return 2 NEW_LINE maxProduct = - 1 NEW_LINE if N % 3 == 0 : NEW_LINE INDENT maxProduct = power ( 3 , N // 3 ) NEW_LINE DEDENT elif N % 3 == 1 : NEW_LINE INDENT maxProduct = 2 * 2 * power ( 3 , ( N // 3 ) - 1 ) NEW_LINE DEDENT elif N % 3 == 2 : NEW_LINE INDENT maxProduct = 2 * power ( 3 , N // 3 ) NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT maxProduct = breakInteger ( 10 ) NEW_LINE print ( maxProduct ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import sin , cos , pi NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . res = [ 0 ] * ( n + 1 ) NEW_LINE p = [ True ] * ( n + 1 ) NEW_LINE p [ 0 ] = p [ 1 ] = False NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT self . res [ i ] = i NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if self . p [ i ] : NEW_LINE INDENT self . res [ i ] -= self . res [ i ] / i NEW_LINE for j in range ( i + i , n + 1 , i ) : NEW_LINE INDENT self . p [ j ] = False NEW_LINE self . res [ j ] -= self . res [ j ] / i NEW_LINE DEDENT DEDENT DEDENT return self . res NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT N = 1000000 NEW_LINE f = euler_phi_table ( N ) NEW_LINE res = [ 0 ] * ( N + 1 ) NEW_LINE res [ 1 ] = 2 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] + f [ i ] NEW_LINE DEDENT with open ( " / proc / " , " r " ) as f : NEW_LINE INDENT T = f . read ( ) NEW_LINE DEDENT while T : NEW_LINE INDENT print ( res [ f . read ( ) ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = _main ( ) NEW_LINE s = sc . read ( ) NEW_LINE s = s . replace ( '2017' , '2018' ) NEW_LINE print ( s ) NEW_LINE DEDENT DEDENT
def firstNonRepeating ( data ) : NEW_LINE INDENT import Queue NEW_LINE from Queue import Queue NEW_LINE class NonReapatingCQueue ( Queue ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE def __init__ ( self , data ) : NEW_LINE INDENT Queue . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue ( ) . Queue
def _import ( ) : NEW_LINE INDENT from pybind11_tests import pybind11_tests NEW_LINE class CF862B ( pybind11_tests . CF862B ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = n NEW_LINE self . arr = [ ] NEW_LINE self . total_false = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT self . arr . append ( Node ( i ) ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT a , b = pybind11_tests . CF862B ( i ) NEW_LINE self . arr [ a ] . neighbors . append ( b ) NEW_LINE self . arr [ b ] . neighbors . append ( a ) NEW_LINE DEDENT self . dfs ( 0 , True ) NEW_LINE total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if self . arr [ i ] . parity : NEW_LINE INDENT total += ( self . total_false - len ( self . arr [ i ] . neighbors ) ) NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE DEDENT def dfs ( self , curr_node = None , parity = False ) : NEW_LINE INDENT self . arr [ curr_node ] . parity = parity NEW_LINE if not parity : NEW_LINE INDENT self . total_false += 1 NEW_LINE DEDENT for next_node in self . arr [ curr_node ] . neighbors : NEW_LINE INDENT if self . arr [ next_node ] . parity : NEW_LINE INDENT continue NEW_LINE DEDENT self . dfs ( next_node , not parity ) NEW_LINE DEDENT DEDENT DEDENT class Node ( pybind11_tests . CF862B ) : NEW_LINE INDENT def __init__ ( self , index ) : NEW_LINE INDENT self . index = index NEW_LINE self . neighbors = [ ] NEW_LINE self . parity = None NEW_LINE DEDENT DEDENT return Node NEW_LINE DEDENT
def import _solve NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n , m , obstacles , range ) : NEW_LINE INDENT val = min ( n , m ) NEW_LINE range . sort ( ) NEW_LINE c = 1 NEW_LINE for i in range [ obstacles - 1 : - 1 ] : NEW_LINE INDENT range [ i ] = 2 * range [ i ] NEW_LINE val -= range [ i ] NEW_LINE if val <= 0 : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if val > 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n , m , obstacles = 4 , 5 , 3 NEW_LINE range = [ 1.0 , 1.25 , 1.15 ] NEW_LINE sys . stdout . write ( _solve ( n , m , obstacles , range ) + " \n " ) NEW_LINE DEDENT DEDENT
def import import sys , string , eval , choice ) : NEW_LINE INDENT from string import atoi NEW_LINE from string import strip NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from math import log NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import string NEW_LINE from from from string import join NEW_LINE from string import join NEW_LINE DEDENT
def import _MinStack NEW_LINE class MinStack ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . min_stack = [ ] NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT self . stack . append ( x ) NEW_LINE if not self . min_stack or x <= self . min_stack [ - 1 ] : NEW_LINE INDENT self . min_stack . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT self . min_stack . append ( self . min_stack [ - 1 ] ) NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT self . stack . pop ( ) NEW_LINE self . min_stack . pop ( ) NEW_LINE DEDENT def top ( self ) : NEW_LINE INDENT return self . stack [ - 2 ] NEW_LINE DEDENT def getMin ( self ) : NEW_LINE INDENT return self . min_stack [ - 3 ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT m = MinStack ( ) NEW_LINE m . push ( - 2 ) NEW_LINE m . push ( 0 ) NEW_LINE m . push ( - 3 ) NEW_LINE print ( m . getMin ( ) ) NEW_LINE m . pop ( ) NEW_LINE print ( m . top ( ) ) NEW_LINE print ( m . getMin ( ) ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT one = [ ' ' , ' one ▁ ' , ' two ▁ ' , ' three ▁ ' , ' four ▁ ' , ' five ▁ ' , ' six ▁ ' , ' seven ▁ ' , ' eight ▁ ' , ' nine ▁ ' , ' ten ▁ ' , ' eleven ▁ ' , ' twelve ▁ ' , ' thirteen ▁ ' , ' fourteen ▁ ' , ' fifteen ▁ ' , ' sixteen ▁ ' , ' seventeen ▁ ' , ' eighteen ▁ ' , ' nineteen ▁ ' ] NEW_LINE ten = [ ' ' , ' ' , ' twenty ▁ ' , ' thirty ▁ ' , ' forty ▁ ' , ' fifty ▁ ' , ' sixty ▁ ' , ' seventy ▁ ' , ' eighty ▁ ' , ' ninety ▁ ' ] NEW_LINE def num_to_words ( n , s ) : NEW_LINE INDENT str = " " NEW_LINE if n > 19 : NEW_LINE INDENT str += ten [ n // 10 ] + one [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] NEW_LINE DEDENT if n != 0 : NEW_LINE INDENT str += s NEW_LINE DEDENT return str NEW_LINE DEDENT def convert_to_words ( n ) : NEW_LINE INDENT out = " " NEW_LINE out += num_to_words ( int ( n / 10000000 ) , " crore ▁ " ) NEW_LINE out += num_to_words ( int ( ( n / 100000 ) % 100 ) , " lakh ▁ " ) NEW_LINE out += num_to_words ( int ( ( n / 1000 ) % 100 ) , " thousand ▁ " ) NEW_LINE out += num_to_words ( int ( ( n / 100 ) % 10 ) , " hundred ▁ " ) NEW_LINE if n > 100 and n % 100 : NEW_LINE INDENT out += " and ▁ " NEW_LINE DEDENT out += num_to_words ( int ( n % 100 ) , " " ) NEW_LINE return out NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 438237764 NEW_LINE print ( convert_to_words ( n ) ) NEW_LINE DEDENT DEDENT
def GFG ( a ) : NEW_LINE INDENT neg = 0 NEW_LINE tmp = 1 if a < 0 else - 1 NEW_LINE while a != 0 : NEW_LINE INDENT neg += tmp NEW_LINE a += tmp NEW_LINE DEDENT return neg NEW_LINE def areDifferentSign ( a , b ) : NEW_LINE INDENT return ( ( a < 0 and b > 0 ) or ( a > 0 and b < 0 ) ) NEW_LINE DEDENT def sub ( a , b ) : NEW_LINE INDENT return a + flipSign ( b ) NEW_LINE DEDENT def mul ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT return mul ( b , a ) NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( abs ( b ) , 0 , - 1 ) : NEW_LINE INDENT sum += a NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT sum = flipSign ( sum ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def division ( a , b ) : NEW_LINE INDENT if not b : NEW_LINE INDENT raise ZeroDivisionError NEW_LINE DEDENT quotient , dividend = 0 , 0 NEW_LINE divisor = flipSign ( abs ( b ) ) NEW_LINE for dividend in range ( abs ( a ) , abs ( divisor ) + 1 , - 1 ) : NEW_LINE INDENT quotient += 1 NEW_LINE DEDENT if areDifferentSign ( a , b ) : NEW_LINE INDENT quotient = flipSign ( quotient ) NEW_LINE DEDENT return quotient NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT print ( ' Subtraction ▁ is ▁ % d ' % sub ( 4 , - 2 ) ) NEW_LINE print ( ' Product ▁ is ▁ % d ' % mul ( - 9 , 6 ) ) NEW_LINE try : NEW_LINE INDENT print ( ' Division ▁ is ▁ % d ' % division ( 8 , 2 ) ) NEW_LINE DEDENT except ZeroDivisionError : NEW_LINE INDENT print ( ' Exception ▁ : - ▁ Divide ▁ by ▁ 0' ) NEW_LINE DEDENT DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT i , fact = n , 1 NEW_LINE while n / i != n : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT
def GFG ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( number % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def import import sys NEW_LINE class B272 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdin = sys . stdin NEW_LINE self . N = self . N NEW_LINE stat = [ 0 ] * 30 NEW_LINE for n in range ( self . N ) : NEW_LINE INDENT a = sys . stdin . read ( ) NEW_LINE stat [ int ( a ) ] += 1 NEW_LINE DEDENT DEDENT answer = 0 NEW_LINE for count in stat : NEW_LINE INDENT answer += count * ( count - 1 ) NEW_LINE DEDENT answer /= 2 NEW_LINE print ( answer ) NEW_LINE DEDENT
def min_noOf_operation ( arr , n , k ) : NEW_LINE INDENT import sys NEW_LINE import gc NEW_LINE gc . collect ( ) NEW_LINE class GfG ( gc . Model ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT gc . collect ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if arr [ i ] > arr [ i - 1 ] : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k NEW_LINE if ( arr [ i ] - arr [ i - 1 ] ) % k != 0 : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT DEDENT DEDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if arr [ i ] > arr [ i - 1 ] : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k NEW_LINE if ( arr [ i ] - arr [ i - 1 ] ) % k != 0 : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT res = res + noOfSubtraction NEW_LINE DEDENT return res NEW_LINE DEDENT
def GFG ( arr , n , X ) : NEW_LINE INDENT N = int ( sum ( [ i for i in range ( N ) if i & ( 1 << j ) ] ) ) NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i & ( 1 << j ) : NEW_LINE INDENT if arr [ j ] == X : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT n = 5 NEW_LINE def FindMaxProduct ( arr , n ) : NEW_LINE INDENT max , result = 0 , arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j - 3 ) >= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] NEW_LINE if max < result : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( i - 3 ) >= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] NEW_LINE if max < result : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( i - 3 ) >= 0 and ( j - 3 ) >= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] NEW_LINE if max < result : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( i - 3 ) >= 0 and ( j - 1 ) <= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] NEW_LINE if max < result : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT DEDENT DEDENT return max NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 6 , 7 , 8 , 9 , 1 ] , [ 2 , 3 , 4 , 5 , 6 ] , [ 7 , 8 , 9 , 1 , 0 ] , [ 9 , 6 , 4 , 2 , 3 ] ] NEW_LINE print ( FindMaxProduct ( arr , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import random NEW_LINE from sympy . utilities . randtest import Normal NEW_LINE from sympy . utilities . randtest import Normal NEW_LINE MAX = 50002 NEW_LINE primes = [ ] NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime = [ True for i in range ( MAX ) ] NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def power ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE z = y NEW_LINE while x >= z : NEW_LINE INDENT count += ( x // z ) NEW_LINE z *= y NEW_LINE DEDENT return count NEW_LINE DEDENT def mod_mul ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while b > 0 : NEW_LINE INDENT if b % 2 == 1 : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def count_ways ( n , m ) : NEW_LINE INDENT ans = 1 NEW_LINE for p in primes [ 1 : ] : NEW_LINE INDENT powers = power ( n , p ) NEW_LINE if powers == 0 : break NEW_LINE ans = mod_mul ( ans , powers + 1 , m ) % m NEW_LINE DEDENT if ( ( ans - 1 ) % m ) < 0 : return ( ans - 1 + m ) % m NEW_LINE else : return ( ans - 1 ) % m NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT return Normal ( ) NEW_LINE DEDENT n , m = 4 , 7 NEW_LINE print ( count_ways ( n , m ) ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while i >= 0 and arr [ i ] % 2 == 1 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def import _strptime NEW_LINE import time NEW_LINE import time NEW_LINE import datetime NEW_LINE import time NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT t1 = self . input NEW_LINE t2 = self . input NEW_LINE date = time . strptime ( t1 , ' % Y : % m : % d ' ) NEW_LINE print ( abs ( date - date ) . total_seconds ( ) / ( 1000 * 60 * 60 * 24 ) ) NEW_LINE DEDENT DEDENT
def import sys , string , glob , symbols , count , symbols , count , * , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature , has_signature ,
def _import ( ) : NEW_LINE INDENT from itertools import islice NEW_LINE from itertools import islice NEW_LINE from random import randint NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import randint NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE from random import shuffle NEW_LINE dp = [ [ False ] * ( k - a [ now - 1 ] ) for _ in range ( n + 1 ) ] NEW_LINE dp = [ [ True ] * ( k - a [ now - 1 ] ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = True NEW_LINE shuffle ( dp ) NEW_LINE for i in range ( k - 1 , max ( k - a [ now - 1 ] , 0 ) - 1 ) : NEW_LINE INDENT if i == now : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT if dp [ i - 1 ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE if j + a [ i - 1 ] <= k : NEW_LINE INDENT dp [ i ] [ j + a [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( k - 1 , max ( k - a [ now - 1 ] , 0 ) - 1 ) : NEW_LINE INDENT if dp [ n ] [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT
def import import sys NEW_LINE class Solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n = sc . readline ( ) . strip ( ) NEW_LINE s = sc . readline ( ) . strip ( ) NEW_LINE if n > 0 : NEW_LINE INDENT k = s / n NEW_LINE count = 0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT k = s / i NEW_LINE count += k NEW_LINE s -= k * i NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT DEDENT DEDENT
def import _product NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . carry = 0 NEW_LINE self . size = len ( self . v ) NEW_LINE for i in range ( self . size ) : NEW_LINE INDENT res = self . carry + self . v [ i ] * x NEW_LINE self . v [ i ] = res % 10 NEW_LINE carry = res // 10 NEW_LINE DEDENT while carry != 0 : NEW_LINE INDENT self . v . append ( carry % 10 ) NEW_LINE carry //= 10 NEW_LINE DEDENT DEDENT def findSumOfDigits ( self , n ) : NEW_LINE INDENT self . v . append ( 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT self . multiply ( i ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT self . n = 1000 NEW_LINE print ( findSumOfDigits ( self . n ) ) NEW_LINE DEDENT DEDENT
def test_B436 ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import count NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B436 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 as b36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 as b36 NEW_LINE from b36 import B36 NEW_LINE from b36 import B36 as b36 NEW_LINE from b36 import B36 as b36 NEW_LINE from b36 import B36 as b36 NEW_LINE from b36 import B36 as b36 NEW_LINE from b36 import B36 as b36 NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from itertools import islice NEW_LINE from itertools import islice NEW_LINE from random import randint NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE from codeforces356A import islice NEW_LINE DEDENT
def import import sys , StringIO , pickle , pdb , set , symbols , object , count , trace NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from os import urandom NEW_LINE from itertools import product , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat as repeat NEW_LINE from itertools import chain , repeat as repeat NEW_LINE from itertools import repeat as repeat NEW_LINE from itertools import chain , repeat as repeat NEW_LINE from itertools import chain , repeat as repeat NEW_LINE from itertools import chain , repeat as repeat NEW_LINE from itertools import chain , repeat as repeat NEW_LINE from from itertools import repeat as repeat NEW_LINE from from itertools import repeat as repeat NEW_LINE from from from itertools import repeat as repeat NEW_LINE from itertools import repeat as repeat as repeat NEW_LINE from from from itertools import iterable , repeat as repeat as repeat NEW_LINE from from from from from from from itertools import iterable , repeat as repeat as repeat NEW_LINE DEDENT
def pell ( n ) : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT return 2 * pell ( n - 1 ) + pell ( n - 2 ) NEW_LINE def main ( args ) : NEW_LINE INDENT n = 4 NEW_LINE print ( pell ( n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import import sys , StringIO , traceback , debug NEW_LINE from twisted . python . compat import builtins NEW_LINE from twisted . python import log NEW_LINE from twisted . internet import reactor NEW_LINE from twisted . python . compat import py3compat NEW_LINE from twisted . python . util import printable_module_name NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import py3compat NEW_LINE from twisted . python . util import printable_module_name NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import py3compat NEW_LINE from twisted . python . util import printable_module_name NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . util import printable_module_name NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . iteritems import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . iteritems import iteritems NEW_LINE from twisted . python . compat import iteritems NEW_LINE from twisted . python . iteritems import iteritems NEW_LINE from twisted . python . iteritems import iteritems NEW_LINE class Hello ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . __dict__ = dict ( self . __dict__ ) NEW_LINE self . __dict__ [ ' _ _ name _ _ ' ] = ' World ' NEW_LINE self . __dict__ [ ' _ _ class _ _ ' ] = Hello NEW_LINE self . __dict__ [ ' _ _ class _ _ ' ] = Dummy NEW_LINE self . __dict__ [ ' _ _ name _ _ ' ] = self . __name__ NEW_LINE self . __dict__ [ ' _ _ class _ _ ' ] = self . __class__ NEW_LINE DEDENT DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def print_small ( self , arr , asize , n ) : NEW_LINE INDENT copy_arr = arr [ asize : ] NEW_LINE copy_arr . sort ( ) NEW_LINE for i in range ( asize ) : NEW_LINE INDENT if np . sum ( copy_arr [ : n ] ) > - 1 : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE asize = len ( arr ) NEW_LINE n = 5 NEW_LINE print_small ( arr , asize , n ) NEW_LINE DEDENT DEDENT
def __count_numbers ( n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __count__ ( self ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n & 1 == 0 : NEW_LINE INDENT count += int ( math . pow ( 2 , k ) ) NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def __count__ ( self ) : NEW_LINE INDENT n = 11 NEW_LINE print ( __count__ ( self ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def import sys , StringIO , traceback NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from random import randint NEW_LINE from sys import random NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import exists NEW_LINE from os . path import isfile NEW_LINE from os . walk import isfile NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import dirname NEW_LINE from os . walk import isfile NEW_LINE from os . path import join NEW_LINE from os . path import isfile NEW_LINE from os . walk import isfile NEW_LINE from os . path import join NEW_LINE from os . path import dirname NEW_LINE from os . walk import isfile NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . walk import isfile NEW_LINE from os . path import join NEW_LINE from os . path import dirname NEW_LINE from os . walk import isfile NEW_LINE from os . path import join NEW_LINE from os . walk import isfile NEW_LINE from os . path import isfile NEW_LINE from os . walk import isfile NEW_LINE from os . walk import isfile NEW_LINE from os . walk import isfile NEW_LINE from os . walk import isfile NEW_LINE from os . walk import isfile NEW_LINE from os . path import isfile NEW_LINE from os . walk import isfile NEW_LINE from os . walk import isfile NEW_LINE from os . rmdir import isfile NEW_LINE DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT maximum , x , ans = int ( 0 ) , int ( 0 ) , int ( 0 ) NEW_LINE graph = [ [ ] ] NEW_LINE weight = [ ] NEW_LINE def __builtin_popcount ( x ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 60 ) : NEW_LINE INDENT if ( ( x >> i ) & 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def dfs ( node , parent ) : NEW_LINE INDENT a = __builtin_popcount ( weight [ node ] + x ) NEW_LINE if maximum < a : NEW_LINE INDENT maximum , ans = a , node NEW_LINE DEDENT elif maximum == a : NEW_LINE INDENT ans = min ( ans , node ) NEW_LINE DEDENT for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if graph [ node ] [ i ] == parent : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( graph [ node ] [ i ] , node ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT x = 15 NEW_LINE weight . append ( [ 0 , 5 , 10 , 11 , 8 , 6 ] ) NEW_LINE for i in range ( 100 ) : NEW_LINE INDENT graph . append ( [ ] ) NEW_LINE DEDENT graph [ 1 ] . append ( 2 ) NEW_LINE graph [ 2 ] . append ( 3 ) NEW_LINE graph [ 2 ] . append ( 4 ) NEW_LINE graph [ 1 ] . append ( 5 ) NEW_LINE dfs ( 1 , 1 ) NEW_LINE print ( ans ) NEW_LINE DEDENT return GFG NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 26 NEW_LINE def updateFreq ( str , freq ) : NEW_LINE INDENT freq = [ ord ( c ) - ord ( ' a ' ) for c in str ] NEW_LINE for i in range ( len ( freq ) ) : NEW_LINE INDENT freq [ freq [ i ] - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT def maxCount ( str , patt ) : NEW_LINE INDENT strFreq = [ 0 ] * MAX NEW_LINE updateFreq ( str , strFreq ) NEW_LINE pattFreq = [ 0 ] * MAX NEW_LINE updateFreq ( patt , pattFreq ) NEW_LINE ans = sum ( [ 0 ] * ( MAX - len ( str ) ) ) NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if pattFreq [ i ] == 0 : continue NEW_LINE ans = min ( ans , strFreq [ i ] / pattFreq [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT str = ' geeksforgeeks ' NEW_LINE patt = ' geeks ' NEW_LINE print ( maxCount ( str , patt ) ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from math import sin , cos , tan NEW_LINE from os . path import join NEW_LINE from os import urandom NEW_LINE n = int ( sys . stdin . read ( ) ) NEW_LINE a = [ sin ( i ) for i in range ( 1 , n + 1 ) ] NEW_LINE b = [ sin ( i ) for i in range ( 1 , n + 1 ) ] NEW_LINE a1 , b1 , ans = 0 , 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a1 = a1 | a [ i ] NEW_LINE b1 = b1 | b [ i ] NEW_LINE if a1 + b1 > ans : NEW_LINE INDENT ans = a1 + b1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def test_A354 ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy . testing import assert_array_almost_equal NEW_LINE from scipy . sparse import csum NEW_LINE N = np . random . randint ( 1 , 6 ) NEW_LINE L = np . random . randint ( 1 , 6 ) NEW_LINE R = np . random . randint ( 1 , 6 ) NEW_LINE QL = np . random . randint ( 1 , 6 ) NEW_LINE QR = np . random . randint ( 1 , 6 ) NEW_LINE W = np . random . randint ( 1 , 6 ) NEW_LINE sum = np . sum ( csum , axis = 1 ) NEW_LINE min = np . inf NEW_LINE for first_r in range ( 0 , N ) : NEW_LINE INDENT l_count = first_r NEW_LINE r_count = N - l_count NEW_LINE cand = sum [ l_count ] * L + ( sum [ N ] - sum [ l_count ] ) * R NEW_LINE ll_count = max ( 0 , l_count - r_count - 1 ) NEW_LINE rrd_count = max ( 0 , r_count - l_count - 1 ) NEW_LINE cand += ll_count * QL NEW_LINE cand += rrd_count * QR NEW_LINE min = min ( cand , min ) NEW_LINE DEDENT assert_array_almost_equal ( min , W ) NEW_LINE DEDENT
def wastedWater ( V , M , N ) : NEW_LINE INDENT global wasted_amt , amt_per_min , time_to_fill NEW_LINE amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT
def GFG ( x , n ) : NEW_LINE INDENT count0 , count1 = 0 , 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x [ i ] == '0' : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT if count0 == count1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if count0 != count1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE abc = [ sc . randint ( 0 , 3 ) for i in range ( 3 ) ] NEW_LINE max = sys . maxint NEW_LINE min = sys . maxint NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if max < abc [ i ] : NEW_LINE INDENT max = abc [ i ] NEW_LINE DEDENT if min > abc [ i ] : NEW_LINE INDENT min = abc [ i ] NEW_LINE DEDENT DEDENT print ( min , max ) NEW_LINE DEDENT DEDENT
def find_s ( s ) : NEW_LINE INDENT def find_s ( ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , s ) : NEW_LINE INDENT sum += n NEW_LINE if sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = 15 NEW_LINE n = find_s ( s ) NEW_LINE if n == - 1 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT return find_s ( ) NEW_LINE DEDENT
def __maximum_absolute ( arr , n ) : NEW_LINE INDENT import math NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE from math import pi NEW_LINE arr = [ - 1 , - 1 , 11 , - 1 , 3 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( __maximum_absolute ( arr , n ) ) NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE def countStrings ( N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( 9 , 3 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 2 ] = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = 3 NEW_LINE print ( countStrings ( N ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( n , k , s ) : NEW_LINE INDENT dp = [ ] NEW_LINE max_length = [ 26 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = s [ i ] - ord ( ' a ' ) NEW_LINE lower = max ( 0 , curr - k ) NEW_LINE upper = min ( 25 , curr + k ) NEW_LINE for j in range ( lower , upper + 1 ) : NEW_LINE INDENT dp . append ( max ( dp [ i ] , max_length [ j ] + 1 ) ) NEW_LINE DEDENT max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in dp : NEW_LINE INDENT ans = max ( i , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def GFG ( n , a ) : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT len = 2 NEW_LINE mx = sys . maxint NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] + a [ i - 2 ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = 2 NEW_LINE DEDENT mx = max ( mx , len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT
def test_gf_gn_subarrays ( ar , n ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . se = [ ] NEW_LINE cnt = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if self . se in [ i ] is False : NEW_LINE INDENT self . se . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE self . se = [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE print ( minimum_subarrays ( ar , n ) ) NEW_LINE DEDENT
def GFG ( s ) : NEW_LINE INDENT freq = [ 0 for i in range ( 10 ) ] NEW_LINE while s != 0 : NEW_LINE INDENT r , s = s % 10 , int ( s / 10 ) NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor__ = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor__ = xor__ ^ freq [ i ] NEW_LINE if xor__ == 0 : return True NEW_LINE else : return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def import import struct NEW_LINE from os import popen , pipes NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from io import BytesIO NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from random import randint NEW_LINE from itertools import izip , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter , ifilter
def GFG ( ) : NEW_LINE INDENT MAXN = 1000005 NEW_LINE even = [ 0 ] * MAXN NEW_LINE odd = [ 0 ] * MAXN NEW_LINE def precompute ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 1 : NEW_LINE INDENT odd [ i ] = 1 NEW_LINE DEDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT even [ i ] = even [ i ] + even [ i - 1 ] NEW_LINE odd [ i ] = odd [ i ] + odd [ i - 1 ] NEW_LINE DEDENT DEDENT def isOdd ( L , R ) : NEW_LINE INDENT cnt = odd [ R ] NEW_LINE if L > 0 : NEW_LINE INDENT cnt -= odd [ L - 1 ] NEW_LINE DEDENT if cnt == R - L + 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def performQueries ( a , n , q , m ) : NEW_LINE INDENT precompute ( a , n ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT L , R = q [ i ] NEW_LINE if isOdd ( L , R ) : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT a = [ 2 , 1 , 5 , 7 , 6 , 8 , 9 ] NEW_LINE n = len ( a ) NEW_LINE q = [ [ 0 , 2 ] , [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 6 ] ] NEW_LINE m = len ( q ) NEW_LINE performQueries ( a , n , q , m ) NEW_LINE DEDENT DEDENT
def _import ( ) : return sys . stdin . readline ( ) NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE class Pre422 ( readline ) : NEW_LINE INDENT class FastReader : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE readline . parse_and_bind ( ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def import import sys NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os . path import join NEW_LINE from os import urandom NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import exists NEW_LINE from os . path import exists NEW_LINE from os . path import isfile NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import exists NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import dirname , join NEW_LINE from os . walk import isfile NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . walk import isfile NEW_LINE for dirname in ( join ( dirname ( __file__ ) , ' . . ' ) ) : NEW_LINE INDENT path = join ( dirname ( abspath ) , ' . . ' ) NEW_LINE if isfile ( join ( path ) ) : NEW_LINE INDENT os . remove ( join ( dirname ( abspath ) , join ( path , ' . . ' ) ) ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import random NEW_LINE import time NEW_LINE time . sleep ( 1 ) NEW_LINE n = random . randint ( 1 , 3 ) NEW_LINE out = 3 NEW_LINE good = True NEW_LINE playing = [ 1 , 2 ] NEW_LINE for win in range ( n ) : NEW_LINE INDENT if win == out : NEW_LINE INDENT good = False NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT replace = 0 NEW_LINE for j in range ( 1 , 3 ) : NEW_LINE INDENT if win != j and out != j : NEW_LINE INDENT replace = j NEW_LINE break NEW_LINE DEDENT DEDENT index = 0 NEW_LINE for j in range ( len ( playing ) ) : NEW_LINE INDENT if playing [ j ] == replace : NEW_LINE INDENT index = j NEW_LINE break NEW_LINE DEDENT DEDENT playing . pop ( index ) NEW_LINE playing . append ( out ) NEW_LINE out = replace NEW_LINE DEDENT DEDENT if good : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def GFG ( steps , n ) : NEW_LINE INDENT current_level = 0 NEW_LINE previous_level = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT previous_level = current_level NEW_LINE current_level = current_level + steps [ i ] NEW_LINE if ( previous_level < 0 and current_level >= 0 ) or ( previous_level > 0 and current_level <= 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def import datetime NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n = sc . readline ( ) . strip ( ) NEW_LINE holidays = [ Holiday ( sc . get ( ' start ' ) , sc . get ( ' end ' ) , sc . get ( ' start ' ) , sc . get ( ' end ' ) ) for i in range ( n ) ] NEW_LINE min = sys . maxint NEW_LINE for i in range ( 1 , 360 ) : NEW_LINE INDENT max = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT max = max ( max , holidays [ j ] . get_rowded ( i ) ) NEW_LINE DEDENT min = min ( min , max ) NEW_LINE DEDENT print ( min ) NEW_LINE DEDENT class Holiday ( object ) : NEW_LINE INDENT def __init__ ( self , month , day , time , value ) : NEW_LINE INDENT self . start = ( month - 1 ) * 30 + day NEW_LINE self . end = start + time - 1 NEW_LINE if end > 360 : NEW_LINE INDENT end -= 360 NEW_LINE DEDENT self . value = value NEW_LINE DEDENT def get_rowded ( self , target ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT if target <= end or target >= start : NEW_LINE INDENT return value NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if start <= target <= end : NEW_LINE INDENT return value NEW_LINE DEDENT DEDENT if target < start : NEW_LINE INDENT v1 = max ( 0 , value - ( start - target ) ) NEW_LINE DEDENT else : NEW_LINE INDENT v1 = max ( 0 , value - ( 360 + start - target ) ) NEW_LINE DEDENT if end < target : NEW_LINE INDENT v2 = max ( 0 , value - ( target - end ) ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 = max ( 0 , value - ( 360 + target - end ) ) NEW_LINE DEDENT return max ( v1 , v2 ) NEW_LINE DEDENT DEDENT DEDENT return Main NEW_LINE DEDENT
def import import sys NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from io import BytesIO NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os import sep NEW_LINE from os . walk import walk NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . walk import walk NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . walk import walk NEW_LINE from os . path import walk NEW_LINE from os . path import join NEW_LINE from os . path import walk NEW_LINE from os . walk import walk NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . walk import walk NEW_LINE from os . path import walk NEW_LINE from os . walk import walk NEW_LINE from os . path import join NEW_LINE from os . path import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE from os . walk import walk NEW_LINE DEDENT
def GFG ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = " " NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT if s [ i ] > s [ i + 1 ] : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT ans += s [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT ans = s [ : l - 1 ] NEW_LINE return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = 0 NEW_LINE self . b = 1 NEW_LINE self . g = [ 0 , 0 , 2 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE if self . g [ a ] == self . g [ b ] : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = sys . maxint NEW_LINE found = False NEW_LINE sum = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE if sum == k : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif sum > k : NEW_LINE INDENT while sum > k : NEW_LINE INDENT sum = sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if sum == k : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if found : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE from . import scanner NEW_LINE from . import printer NEW_LINE from . import scanner NEW_LINE from . import scanner NEW_LINE from . import pr NEW_LINE from . import sys NEW_LINE s = scanner . next ( ) . split ( ' ▁ ' ) NEW_LINE cnt = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == '1' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT pr . pprint ( cnt ) NEW_LINE def main ( ) : NEW_LINE INDENT sc = scanner . Scanner ( sys . stdin ) NEW_LINE pr = printer . Printer ( sys . stdout ) NEW_LINE solve ( ) NEW_LINE pr . close ( ) NEW_LINE sc . close ( ) NEW_LINE DEDENT class Printer ( object ) : NEW_LINE INDENT def __init__ ( self , stream = sys . stdout ) : NEW_LINE INDENT self . stream = stream NEW_LINE DEDENT DEDENT return Printer NEW_LINE DEDENT
def GFG ( n , k ) : NEW_LINE INDENT temp = ( k / 2 ) if k & 1 else ( k / 2 - 1 ) NEW_LINE palindrome = int ( pow ( 10 , temp ) ) NEW_LINE palindrome += n - 1 NEW_LINE print ( palindrome , end = ' ▁ ' ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT palindrome /= 10 NEW_LINE DEDENT while palindrome > 0 : NEW_LINE INDENT print ( palindrome % 10 , end = ' ▁ ' ) NEW_LINE palindrome /= 10 NEW_LINE DEDENT print ( ' ' ) NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT INF = sys . maxsize NEW_LINE def __init__ ( self ) : NEW_LINE INDENT super ( Main , self ) . __init__ ( ) NEW_LINE self . INF = sys . maxsize NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT with open ( ' . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . . / . . / . / . . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . / . . / . / . / . . / . / . / . / . . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / .
def import _solution NEW_LINE class Solution : NEW_LINE INDENT def __init__ ( self , arr ) : NEW_LINE INDENT self . MAX = 10000 NEW_LINE self . hashTable = { } NEW_LINE DEDENT def minOperations ( self , n ) : NEW_LINE INDENT arr = [ i for i in arr if i % n == 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT self . hashTable [ i ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if self . hashTable [ i ] != 0 : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if self . hashTable [ j ] % self . hashTable [ i ] == 0 : NEW_LINE INDENT self . hashTable [ i ] = 0 NEW_LINE DEDENT DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT arr = [ 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . p1 = sys . stdin . read ( ) NEW_LINE self . p2 = sys . stdin . read ( ) NEW_LINE self . p3 = sys . stdin . read ( ) NEW_LINE self . p4 = sys . stdin . read ( ) NEW_LINE self . a = sys . stdin . read ( ) NEW_LINE self . b = sys . stdin . read ( ) NEW_LINE DEDENT def get ( self ) : NEW_LINE INDENT min = min ( min ( self . p1 , self . p2 ) , min ( self . p3 , self . p4 ) ) NEW_LINE c = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if i < min : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT DEDENT DEDENT
def p033 ( ) : NEW_LINE INDENT print ( eval ( ' p033' ) ( ) ) NEW_LINE numer = 1 NEW_LINE denom = 1 NEW_LINE for d in range ( 10 , 100 ) : NEW_LINE INDENT for n in range ( 10 , d ) : NEW_LINE INDENT n0 , n1 = n % 10 , n // 10 NEW_LINE d0 , d1 = d % 10 , d // 10 NEW_LINE if n1 == d0 and n0 * d == n * d1 or n0 == d1 and n1 * d == n * d0 : NEW_LINE INDENT numer *= n NEW_LINE denom *= d NEW_LINE DEDENT DEDENT DEDENT return str ( denom / library . gcd ( numer , denom ) ) NEW_LINE DEDENT
def _count_set_bits ( n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def count_set_bits ( self , n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT def count_of_odd_pascal ( self , n ) : NEW_LINE INDENT c = count_set_bits ( n ) NEW_LINE return int ( math . pow ( 2 , c ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 20 NEW_LINE print ( count_of_odd_pascal ( n ) ) NEW_LINE DEDENT return GFG NEW_LINE DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import math NEW_LINE import random NEW_LINE import random NEW_LINE class Codechef ( sys . stdin ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sys . stdin . close ( ) NEW_LINE sys . stdin . close ( ) NEW_LINE sys . stdin . close ( ) NEW_LINE sys . stdin . close ( ) NEW_LINE DEDENT def readline ( ) : NEW_LINE INDENT try : NEW_LINE INDENT sys . stdin . readline ( ) NEW_LINE t = sys . stdin . readline ( ) . strip ( ) NEW_LINE while t : NEW_LINE INDENT a , b , x , y = select . select ( [ a , b ] , [ ] , [ ] , 0 ) NEW_LINE ans = max ( max ( x , a - 1 - x ) * b , a * max ( y , b - 1 - y ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT finally : NEW_LINE INDENT sys . stdin . close ( ) NEW_LINE DEDENT DEDENT DEDENT
def min_swaps ( arr ) : NEW_LINE INDENT import numpy NEW_LINE from numpy . polynomial . polynomial import polynomial NEW_LINE class GfG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . _arr = arr NEW_LINE self . _arr = arr NEW_LINE self . _arrpos = [ ( x , i ) for x in range ( self . _arr . size ) ] NEW_LINE self . _arrpos . sort ( key = lambda x : x [ 0 ] ) NEW_LINE DEDENT def __cmp__ ( self , other ) : NEW_LINE INDENT if self . _arr [ 0 ] > other . _arr [ 1 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif self . _arr [ 0 ] == other . _arr [ 1 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT vis = [ False ] * n NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if vis [ i ] or arrpos [ i ] [ 1 ] == i : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while not vis [ j ] : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = arrpos [ j ] [ 1 ] NEW_LINE cycle_size += 1 NEW_LINE DEDENT if cycle_size > 0 : NEW_LINE INDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def import _primes NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = 1000005 NEW_LINE self . prime = [ True ] * self . N NEW_LINE DEDENT def sieve ( self ) : NEW_LINE INDENT [ prime ] = True NEW_LINE self . prime [ 1 ] = False NEW_LINE self . prime [ 0 ] = False NEW_LINE for i in range ( 2 , self . N ) : NEW_LINE INDENT if self . prime [ i ] : NEW_LINE INDENT for j in range ( i * 2 , self . N , i ) : NEW_LINE INDENT self . prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sum_truncatable_primes ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT num = i NEW_LINE flag = True NEW_LINE while num > 0 : NEW_LINE INDENT if not self . prime [ num ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT num /= 10 NEW_LINE DEDENT num = i NEW_LINE power = 10 NEW_LINE while num // power > 0 : NEW_LINE INDENT if not self . prime [ num % power ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT power *= 10 NEW_LINE DEDENT if flag : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . n = 25 NEW_LINE self . sieve ( ) NEW_LINE print ( sum_truncatable_primes ( self , n ) ) NEW_LINE DEDENT DEDENT
def test_find_weights ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_weights ( self , X ) : NEW_LINE INDENT sum = 0 NEW_LINE power = 0 NEW_LINE number = 3 NEW_LINE while sum < X : NEW_LINE INDENT sum = number - 1 NEW_LINE sum /= 2 NEW_LINE power += 1 NEW_LINE number *= 3 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 1 , power + 1 ) : NEW_LINE INDENT print ( ans , end = ' ▁ ' ) NEW_LINE ans = ans * 3 NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT X = 2 NEW_LINE find_weights ( X ) NEW_LINE DEDENT DEDENT
def test_to_array_form ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . v = [ ] NEW_LINE self . ans = [ ] NEW_LINE self . rem = 0 NEW_LINE self . i = 0 NEW_LINE for my in A [ : : - 1 ] : NEW_LINE INDENT self . my = self . A [ : , 0 ] + self . K % 10 + self . rem NEW_LINE if my > 9 : NEW_LINE INDENT self . rem = 1 NEW_LINE self . v . append ( self . my % 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . v . append ( self . my ) NEW_LINE self . rem = 0 NEW_LINE DEDENT self . K = self . K // 10 NEW_LINE DEDENT while self . K > 0 : NEW_LINE INDENT my = self . K % 10 + self . rem NEW_LINE self . v . append ( self . my % 10 ) NEW_LINE if self . my // 10 > 0 : NEW_LINE INDENT self . rem = 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . rem = 0 NEW_LINE DEDENT self . K = self . K // 10 NEW_LINE DEDENT if self . rem : NEW_LINE INDENT self . v . append ( self . rem ) NEW_LINE DEDENT DEDENT for i in range ( len ( self . v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT self . ans . append ( self . v [ i ] ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT A = [ 2 , 7 , 4 ] NEW_LINE K = 181 NEW_LINE ans = add_to_array_form ( A , K ) NEW_LINE for i in ans : NEW_LINE INDENT sys . stdout . write ( i ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def GFG ( x , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( x , ' ' , 0 , i , R , C ) NEW_LINE print ( ) NEW_LINE DEDENT def dfs ( x , res , i , j , R , C ) : NEW_LINE INDENT if i == R : NEW_LINE INDENT print ( res , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT res = res + x [ i ] [ j ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( x , res , i + 1 , k , R , C ) NEW_LINE if i + 1 == R : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT x = [ [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] ] NEW_LINE R , C = len ( x ) , len ( x [ 0 ] ) NEW_LINE printPaths ( x , R , C ) NEW_LINE DEDENT DEDENT
def main ( args ) : NEW_LINE INDENT import sys NEW_LINE from string import ascii_letters NEW_LINE sc = open ( ' / proc / stagentes / ' ) NEW_LINE num = int ( sc . readline ( ) ) NEW_LINE line = sc . readline ( ) NEW_LINE hotel = [ 0 ] * 10 NEW_LINE for actual in ascii_letters : NEW_LINE INDENT if actual == ' L ' : NEW_LINE INDENT bb = True NEW_LINE for pos in range ( 10 , 1 ) : NEW_LINE INDENT if hotel [ pos ] == 0 : NEW_LINE INDENT hotel [ pos ] = 1 NEW_LINE bb = False NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if actual == ' R ' : NEW_LINE INDENT bb = True NEW_LINE for pos in range ( 9 , 0 , - 1 ) : NEW_LINE INDENT if hotel [ pos ] == 0 : NEW_LINE INDENT hotel [ pos ] = 1 NEW_LINE bb = False NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT pos = int ( " { } " . format ( actual ) ) NEW_LINE hotel [ pos ] = 0 NEW_LINE DEDENT DEDENT DEDENT res = [ ] NEW_LINE for x in hotel : NEW_LINE INDENT res . append ( x ) NEW_LINE DEDENT print ( ' ' . join ( res ) ) NEW_LINE DEDENT
def import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import sys NEW_LINE class B_Square ( readline ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT readline . __init__ ( self ) NEW_LINE self . readline = None NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not self . readline or not self . readline . strip ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . readline . strip ( ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return self . readline NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT data = ' ' NEW_LINE try : NEW_LINE INDENT if self . readline : NEW_LINE INDENT data = self . readline ( ) NEW_LINE DEDENT else : NEW_LINE INDENT data = self . readline ( ) NEW_LINE DEDENT return data NEW_LINE DEDENT except EOFError : NEW_LINE INDENT pass NEW_LINE DEDENT return data NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT data = ' ' NEW_LINE try : NEW_LINE INDENT if self . readline : NEW_LINE INDENT data = data . decode ( ' ascii ' ) NEW_LINE DEDENT else : NEW_LINE INDENT data = self . readline ( ) NEW_LINE DEDENT return data NEW_LINE DEDENT finally : NEW_LINE INDENT self . readline ( ) NEW_LINE DEDENT DEDENT DEDENT class B_Square ( readline ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT readline . __init__ ( self ) NEW_LINE self . readline = None NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT if self . readline is None : NEW_LINE INDENT self . readline = None NEW_LINE DEDENT return NEW_LINE DEDENT except EOFError : NEW_LINE INDENT pass NEW_LINE DEDENT return NEW_LINE DEDENT DEDENT B_Square . __doc__ = B_Square . __doc__ NEW_LINE B_Square . __dict__ . update ( locals ( ) ) NEW_LINE return B_Square NEW_LINE DEDENT
def test_precision_compute ( ) : NEW_LINE INDENT from sympy import Float NEW_LINE class Eulerian ( Float ) : NEW_LINE INDENT def __init__ ( self , x , y , n ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE self . n = n NEW_LINE DEDENT DEDENT if y == 0 : NEW_LINE INDENT print ( ' Infinite ' , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT if x == 0 : NEW_LINE INDENT print ( '0' , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT if n <= 0 : NEW_LINE INDENT print ( x / y , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT if ( ( x > 0 ) and ( y < 0 ) ) or ( ( x < 0 ) and ( y > 0 ) ) : NEW_LINE INDENT print ( ' - ' , end = ' ▁ ' ) NEW_LINE x , y = x . as_independent ( ) NEW_LINE DEDENT d = x / y NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( d , end = ' ▁ ' ) NEW_LINE x = x - ( y * d ) NEW_LINE if not x : NEW_LINE INDENT break NEW_LINE DEDENT x = x * 10 NEW_LINE d = x / y NEW_LINE if not i : NEW_LINE INDENT print ( ' . ' , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import gcd NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : return a NEW_LINE else : return gcd ( b , a % b ) NEW_LINE DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT if n < 1 : return 0 NEW_LINE lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) NEW_LINE return lcm NEW_LINE DEDENT def minPerfectCube ( arr , n ) : NEW_LINE INDENT if n < 1 : return 0 NEW_LINE lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectCube = lcm NEW_LINE cnt = 0 NEW_LINE while lcm > 1 and lcm % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE lcm /= 2 NEW_LINE DEDENT if cnt % 3 == 2 : NEW_LINE INDENT minPerfectCube *= 2 NEW_LINE DEDENT elif cnt % 3 == 1 : NEW_LINE INDENT minPerfectCube *= 4 NEW_LINE DEDENT i = 3 NEW_LINE while lcm > 1 : NEW_LINE INDENT cnt = 0 NEW_LINE while lcm % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE lcm /= i NEW_LINE DEDENT if cnt % 3 == 1 : NEW_LINE INDENT minPerfectCube *= i ** i NEW_LINE DEDENT elif cnt % 3 == 2 : NEW_LINE INDENT minPerfectCube *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectCube NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 10 , 125 , 14 , 42 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectCube ( arr , n ) ) NEW_LINE DEDENT DEDENT
def import _util NEW_LINE class Node ( object ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE left = right = None NEW_LINE DEDENT DEDENT class BinaryTree ( object ) : NEW_LINE INDENT def __init__ ( self , root ) : NEW_LINE INDENT self . root = root NEW_LINE DEDENT def print_specific_level_order_util ( self , s ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT q = Queue ( ) NEW_LINE q . put ( root . left ) NEW_LINE q . put ( root . right ) NEW_LINE first , second = None , None NEW_LINE while not q . empty ( ) : NEW_LINE INDENT first , second = q . get ( ) NEW_LINE q . put ( second . left ) NEW_LINE s . put ( first . right ) NEW_LINE s . put ( second . right ) NEW_LINE s . put ( first . left ) NEW_LINE if first . left . left : NEW_LINE INDENT q . put ( first . right ) NEW_LINE q . put ( second . left ) NEW_LINE DEDENT DEDENT DEDENT def print_specific_level_order ( self , root ) : NEW_LINE INDENT s = Stack ( ) NEW_LINE s . push ( root ) NEW_LINE if root . left : NEW_LINE INDENT s . push ( root . right ) NEW_LINE s . push ( root . left ) NEW_LINE DEDENT if root . left . left : NEW_LINE INDENT print_specific_level_order_util ( self , s ) NEW_LINE DEDENT while not s . empty ( ) : NEW_LINE INDENT print ( s . peek ( ) . data , end = ' ▁ ' ) NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT tree = BinaryTree ( ) NEW_LINE tree . root = Node ( 1 ) NEW_LINE tree . root . left = Node ( 2 ) NEW_LINE tree . root . right = Node ( 3 ) NEW_LINE print ( ' Specific ▁ Level ▁ Order ▁ Traversal ▁ of ▁ Binary ▁ Tree ▁ is ' ) NEW_LINE tree . print_specific_level_order ( tree . root ) NEW_LINE DEDENT DEDENT
def GFG ( rows ) : NEW_LINE INDENT for i , j in enumerate ( range ( 1 , rows + 1 ) ) : NEW_LINE INDENT if i == 1 or i == rows : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT print ( " * " , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT if j == 1 or j == rows : NEW_LINE INDENT print ( " * " , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( " \n " , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def solidSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT print ( " * " , end = ' ▁ ' ) NEW_LINE DEDENT print ( " \n " , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def printPattern ( rows ) : NEW_LINE INDENT print ( " Solid ▁ Square : \n " , end = ' ▁ ' ) NEW_LINE solidSquare ( rows ) NEW_LINE print ( " \n Hollow ▁ Square : \n " , end = ' ▁ ' ) NEW_LINE hollowSquare ( rows ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT rows = 5 NEW_LINE printPattern ( rows ) NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT import sys NEW_LINE from os . path import join NEW_LINE from os import urandom NEW_LINE n = urandom ( 4 ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( ' ab ' ) NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT print ( ' abc ' ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n // 4 ) : NEW_LINE INDENT print ( ' abcd ' , end = ' ' ) NEW_LINE DEDENT t = n % 4 NEW_LINE if t == 1 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif t == 2 : NEW_LINE INDENT print ( ' ab ' ) NEW_LINE DEDENT elif t == 3 : NEW_LINE INDENT print ( ' abc ' ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE from numpy . linalg import norm NEW_LINE from numpy . random import randint NEW_LINE from numpy . random import shuffle NEW_LINE from numpy . random import shuffle NEW_LINE from numpy . random import shuffle NEW_LINE from numpy . random import shuffle NEW_LINE n = int ( random ( ) ) NEW_LINE data = [ ] NEW_LINE max_len = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT data . append ( shuffle ( i ) ) NEW_LINE max_len += data [ i ] [ 0 ] NEW_LINE DEDENT shuffle ( data ) NEW_LINE dp = [ 0 ] * ( max_len + 1 ) NEW_LINE dp [ 0 ] = 10000 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( max_len , len ( data [ i ] ) , 0 ) : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , dp [ j - data [ i ] [ 0 ] ] + data [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( max_len , - 1 , - 1 ) : NEW_LINE INDENT if max_len - i >= dp [ i ] : NEW_LINE INDENT print ( max_len - i ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = sys . stdin . read ( ) NEW_LINE self . b = sys . stdin . read ( ) NEW_LINE self . x = sys . stdin . read ( ) NEW_LINE if ( self . x < a or ( self . a + self . b < x ) ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT DEDENT
def find_largest ( arr , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( arr [ i ] , gcd ) NEW_LINE DEDENT return gcd NEW_LINE def __gcd ( a , b ) : NEW_LINE INDENT return b , a % b NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 3 , 6 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_largest ( arr , n ) ) NEW_LINE DEDENT DEDENT
def find_winner ( n ) : NEW_LINE INDENT if ( n - 1 ) % 6 == 0 : NEW_LINE INDENT print ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ Player ▁ wins ▁ the ▁ game " ) NEW_LINE DEDENT DEDENT
def _import ( ) : return sys . modules [ ' _ _ main _ _ ' ] . __path__ NEW_LINE class Graph ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . V = self . V NEW_LINE self . adj = [ list ( ) ] NEW_LINE DEDENT def add_edge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * self . V NEW_LINE queue = [ ] NEW_LINE visited [ s ] = True NEW_LINE queue . append ( s ) NEW_LINE while len ( queue ) != 0 : NEW_LINE INDENT s = queue . pop ( ) NEW_LINE print ( s , end = ' ▁ ' ) NEW_LINE for ( n , v ) in self . adj [ s ] : NEW_LINE INDENT if not visited [ n ] : NEW_LINE INDENT visited [ n ] = True NEW_LINE queue . append ( n ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT g = Graph ( 4 ) NEW_LINE g . add_edge ( 0 , 1 ) NEW_LINE g . add_edge ( 0 , 2 ) NEW_LINE g . add_edge ( 1 , 2 ) NEW_LINE g . add_edge ( 2 , 0 ) NEW_LINE g . add_edge ( 2 , 3 ) NEW_LINE g . add_edge ( 3 , 3 ) NEW_LINE print ( ' Following ▁ is ▁ Breadth ▁ First ▁ Traversal ▁ ' ' ( starting ▁ from ▁ vertex ▁ 2 ) ' ) NEW_LINE g . BFS ( 2 ) NEW_LINE DEDENT DEDENT
def _import ( ) : return sys . modules [ ' _ _ main _ _ ' ] . __path__ NEW_LINE class Graph ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . V = self . V NEW_LINE self . adj = [ list ( ) ] NEW_LINE DEDENT def add_edge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT visited = [ False ] * self . V NEW_LINE queue = [ ] NEW_LINE visited [ s ] = True NEW_LINE queue . append ( s ) NEW_LINE while len ( queue ) != 0 : NEW_LINE INDENT s = queue . pop ( ) NEW_LINE print ( s , end = ' ▁ ' ) NEW_LINE for ( n , v ) in self . adj [ s ] : NEW_LINE INDENT if not visited [ n ] : NEW_LINE INDENT visited [ n ] = True NEW_LINE queue . append ( n ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT g = Graph ( 4 ) NEW_LINE g . add_edge ( 0 , 1 ) NEW_LINE g . add_edge ( 0 , 2 ) NEW_LINE g . add_edge ( 1 , 2 ) NEW_LINE g . add_edge ( 2 , 0 ) NEW_LINE g . add_edge ( 2 , 3 ) NEW_LINE g . add_edge ( 3 , 3 ) NEW_LINE print ( ' Following ▁ is ▁ Breadth ▁ First ▁ Traversal ▁ ' ' ( starting ▁ from ▁ vertex ▁ 2 ) ' ) NEW_LINE g . BFS ( 2 ) NEW_LINE DEDENT DEDENT
def get_elements ( a , arr , n ) : NEW_LINE INDENT from numpy import array NEW_LINE elements = array ( [ a ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = array ( [ 13 , 2 , 6 , 1 ] ) NEW_LINE n = len ( arr ) NEW_LINE a = 5 NEW_LINE get_elements ( a , arr , n ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import_string ( ) : NEW_LINE INDENT import string NEW_LINE class A ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = string . ascii_lowercase NEW_LINE self . cs = [ ' P ' , ' R ' , ' S ' ] NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT dp = [ [ ] for i in range ( 3 ) ] NEW_LINE for i in range ( 1 , len ( dp [ 0 ] ) ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT dp [ j ] [ i ] = dp [ j ] [ i - 1 ] + dp [ ( j + 1 ) % 3 ] [ i - 1 ] NEW_LINE o = dp [ ( j + 1 ) % 3 ] [ i - 1 ] + dp [ j ] [ i - 1 ] NEW_LINE if o < dp [ j ] [ i ] : NEW_LINE INDENT dp [ j ] [ i ] = o NEW_LINE DEDENT DEDENT DEDENT DEDENT self . T = sc . __next__ ( ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT print ( " Case ▁ # { } : ▁ " . format ( i ) , end = ' ▁ ' ) NEW_LINE print ( solve ( ) ) NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT N , R , P , S = [ ] , [ ] , [ ] , [ ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT c = [ ] NEW_LINE for ch in dp [ i ] [ N ] : NEW_LINE INDENT if ch == ' P ' : c . append ( 0 ) NEW_LINE if ch == ' R ' : c . append ( 1 ) NEW_LINE if ch == ' S ' : c . append ( 2 ) NEW_LINE DEDENT if c [ 0 ] == P and c [ 1 ] == R and c [ 2 ] == S : NEW_LINE INDENT ret = dp [ i ] [ N ] NEW_LINE DEDENT DEDENT return ret or ' IMPOSSIBLE ' NEW_LINE DEDENT return A NEW_LINE DEDENT
def _30_chips ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE scn = sys . stdin . readline ( ) NEW_LINE k = sys . stdin . readline ( ) . rstrip ( ' \n ' ) NEW_LINE row = [ False ] * n NEW_LINE col = [ False ] * n NEW_LINE for i in range ( k ) : NEW_LINE INDENT val = scn . readline ( ) . rstrip ( ' \n ' ) NEW_LINE val2 = scn . readline ( ) . rstrip ( ' \n ' ) NEW_LINE row [ val - 1 ] = True NEW_LINE col [ val2 - 1 ] = True NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if n % 2 == 1 and i == n / 2 : NEW_LINE INDENT if not row [ i ] or not col [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT elif not row [ i ] or not col [ i ] : NEW_LINE INDENT ans = ans + ( 2 if ( not row [ i ] and not col [ i ] ) else 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def print_repeating ( arr , size ) : NEW_LINE INDENT S = 0 NEW_LINE P = 1 NEW_LINE x , y = 0 , 0 NEW_LINE D = 0 NEW_LINE n = size - 2 , i NEW_LINE for i in range ( size ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE DEDENT S = S - n * ( n + 1 ) / 2 NEW_LINE P = P / fact ( n ) NEW_LINE D = int ( math . sqrt ( S ** 2 - 4 * P ) ) NEW_LINE x = ( D + S ) / 2 NEW_LINE y = ( S - D ) / 2 NEW_LINE print ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : ▁ " , end = " " ) NEW_LINE print ( " { } ▁ & ▁ { } " . format ( x , y ) , end = " " ) NEW_LINE print ( ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT return ( n , 1 ) * fact ( n - 1 ) NEW_LINE DEDENT class RepeatElement ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT RepeatElement . __init__ ( self ) NEW_LINE self . arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE self . arr_size = len ( arr ) NEW_LINE self . repeat . print_repeating ( arr , arr_size ) NEW_LINE DEDENT DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . count = 1 NEW_LINE self . isPrime = [ True ] * 10001 NEW_LINE self . primes = [ ] NEW_LINE self . sum = [ 0 ] * 100000 NEW_LINE def __init__ ( self ) : NEW_LINE INDENT [ isPrime ] = True NEW_LINE self . isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 0 , i * len ( self . isPrime ) + 1 ) : NEW_LINE INDENT if self . isPrime [ i ] : NEW_LINE INDENT for j in range ( i + i , len ( self . isPrime ) + i ) : NEW_LINE INDENT self . isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( len ( self . isPrime ) ) : NEW_LINE INDENT if self . isPrime [ i ] : NEW_LINE INDENT self . primes [ count ] = i NEW_LINE self . sum [ count ] = self . sum [ count - 1 ] + self . primes [ count ] NEW_LINE self . count += 1 NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT cin = sys . stdin NEW_LINE while True : NEW_LINE INDENT n = cin . readline ( ) NEW_LINE cnt = 0 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( self . count ) : NEW_LINE INDENT for j in range ( i + 1 , self . count ) : NEW_LINE INDENT if self . sum [ j ] - self . sum [ i ] == n : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT DEDENT DEDENT
def import import os , sys , np , pi , pi , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np , np
def _import ( ) : NEW_LINE INDENT from os import system , shell NEW_LINE from io import StringIO NEW_LINE sc = shell . InteractiveConsole ( ) NEW_LINE try : NEW_LINE INDENT while 1 : NEW_LINE INDENT st = sc . readline ( ) NEW_LINE if st == ' # ' : break NEW_LINE c = st . split ( ) NEW_LINE count , t = 0 , check ( c [ 0 ] ) NEW_LINE for c in c [ 1 : ] : NEW_LINE INDENT if t != check ( c ) : NEW_LINE INDENT count += 1 NEW_LINE t = check ( c ) NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT DEDENT DEDENT except : NEW_LINE INDENT print ( " Error " ) NEW_LINE DEDENT def check ( c ) : NEW_LINE INDENT if c in ( ' q ' , ' w ' , ' e ' , ' r ' , ' t ' , ' a ' , ' s ' , ' d ' , ' f ' , ' g ' , ' z ' , ' x ' , ' c ' , ' v ' , ' b ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT sc . close ( ) NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT import sys NEW_LINE from sympy . utilities . randtest import get_randtest NEW_LINE sc = get_randtest ( ) NEW_LINE n = sc . randint ( 1 , 10000 ) NEW_LINE str = sc . string NEW_LINE S = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if str [ i ] == ' S ' and str [ i + 1 ] == ' F ' : NEW_LINE INDENT S += 1 NEW_LINE DEDENT elif str [ i ] == ' F ' and str [ i + 1 ] == ' S ' : NEW_LINE INDENT S -= 1 NEW_LINE DEDENT DEDENT if S > 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def test_247 ( ) : NEW_LINE INDENT import sys NEW_LINE sys . stderr . write ( ' Testing ▁ 247 ▁ for ▁ Python ▁ 2.7 ▁ ( 3 ▁ only ) \n ' ) NEW_LINE t = sys . maxsize NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = sys . maxsize NEW_LINE a = [ ] NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT max = a [ 0 ] * a [ 1 ] NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if a [ i - 1 ] > a [ i + 1 ] : NEW_LINE INDENT if a [ i ] * a [ i - 1 ] > max : NEW_LINE INDENT max = a [ i ] * a [ i - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ i ] * a [ i + 1 ] > max : NEW_LINE INDENT max = a [ i ] * a [ i + 1 ] NEW_LINE DEDENT DEDENT DEDENT print ( max ) NEW_LINE DEDENT DEDENT
def test_find_gcd ( ) : NEW_LINE INDENT from sympy import gcd NEW_LINE class Test ( Function ) : NEW_LINE INDENT def test_gcd ( self , a , b ) : NEW_LINE INDENT return ( a * b ) / gcd ( a , b ) NEW_LINE DEDENT DEDENT def range_gcd ( self , m , n , a , b ) : NEW_LINE INDENT lcm = FindLCM ( a , b ) NEW_LINE a_divisor = n // a - ( m - 1 ) // a NEW_LINE b_divisor = n // b - ( m - 1 ) // b NEW_LINE common_divisor = n // lcm - ( m - 1 ) // lcm NEW_LINE ans = a_divisor + b_divisor - common_divisor NEW_LINE return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT m , n , a , b = 3 , 11 , 2 , 3 NEW_LINE print ( range_gcd ( self , m , n , a , b ) ) NEW_LINE m , n , a , b = 11 , 1000000 , 6 , 35 NEW_LINE print ( range_gcd ( self , m , n , a , b ) ) NEW_LINE DEDENT return Test ( ) NEW_LINE DEDENT
def import _readline NEW_LINE import sys NEW_LINE class Punctuation : NEW_LINE INDENT def is_latex_letter ( c ) : NEW_LINE INDENT return c in ' a ' and c in ' z ' NEW_LINE DEDENT def is_punctuation ( c ) : NEW_LINE INDENT if c == ' . ' : return True NEW_LINE if c == ' , ' : return True NEW_LINE if c == ' ! ' : return True NEW_LINE if c == ' ? ' : return True NEW_LINE return False NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = sys . stdin . readline ( ) NEW_LINE s = s . decode ( ' utf - 8' ) NEW_LINE s = [ s [ 0 ] ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT c = s [ i ] NEW_LINE if is_latex_letter ( c ) : NEW_LINE INDENT if not is_latex_letter ( s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = ' ▁ ' NEW_LINE DEDENT s [ i ] = c NEW_LINE DEDENT elif is_punctuation ( c ) : NEW_LINE INDENT s [ i ] = c NEW_LINE DEDENT DEDENT sys . stdout . write ( ' \n ' . join ( s ) ) NEW_LINE sys . stdout . flush ( ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT DEDENT
def smallest_k_freq ( a , n , k ) : NEW_LINE INDENT import scipy . stats NEW_LINE m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in m : NEW_LINE INDENT m [ a [ i ] ] = m [ a [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT res = scipy . stats . norm . cdf ( a , 2 ) NEW_LINE s = m . keys ( ) NEW_LINE for temp in s : NEW_LINE INDENT if m [ temp ] == k : NEW_LINE INDENT res = min ( res , temp ) NEW_LINE DEDENT DEDENT return ( res , scipy . stats . norm . cdf ( a , 2 ) ) NEW_LINE DEDENT
def test_gf_gis_in_order ( ) : NEW_LINE INDENT import string NEW_LINE class GFG ( object ) : NEW_LINE INDENT def are_vowels_in_order ( self ) : NEW_LINE INDENT n = len ( self ) NEW_LINE c = chr ( 64 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if self [ i ] in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT if self [ i ] < c : return False NEW_LINE else : NEW_LINE INDENT c = self [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import time NEW_LINE import random NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE def a ( ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , tetrahedral ( ) + 1 ) : NEW_LINE INDENT t = tetrahedral ( i ) NEW_LINE a . append ( t ) NEW_LINE DEDENT for i in a : NEW_LINE INDENT pass NEW_LINE DEDENT already_a = [ ] NEW_LINE already_b = [ ] NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , tetrahedral ( ) + 1 ) : NEW_LINE INDENT t = tetrahedral ( i ) NEW_LINE if t % 2 == 1 : NEW_LINE INDENT b . append ( t ) NEW_LINE DEDENT DEDENT DEDENT def a ( ) : NEW_LINE INDENT cin = time . time ( ) NEW_LINE already_a . append ( 0 ) NEW_LINE already_b . append ( 0 ) NEW_LINE a ( ) NEW_LINE while 1 : NEW_LINE INDENT N = cin . __next__ ( ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT cnt = 0 NEW_LINE min = time . time ( ) NEW_LINE print ( already_a [ N ] , end = ' ▁ ' ) NEW_LINE print ( already_b [ N ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def a ( ) : NEW_LINE INDENT for i in range ( 1 , 1000000 ) : NEW_LINE INDENT mina = time . time ( ) NEW_LINE minb = time . time ( ) NEW_LINE x , y = 0 , 0 NEW_LINE for j in range ( 180 and a [ j ] <= i ) : NEW_LINE INDENT mina = min ( 1 + already_a [ i - a [ j ] ] , mina ) NEW_LINE if a [ j ] % 2 == 1 : NEW_LINE INDENT minb = min ( 1 + already_b [ i - a [ j ] ] , minb ) NEW_LINE DEDENT DEDENT already_a [ i ] = mina NEW_LINE already_b [ i ] = minb NEW_LINE DEDENT DEDENT tetrahedral ( a ) NEW_LINE return ( a * ( a + 1 ) * ( a + 2 ) ) / 6 NEW_LINE DEDENT
def GFG ( x ) : NEW_LINE INDENT letter = 0 NEW_LINE for c in x : NEW_LINE INDENT if ( c >= ' A ' and c <= ' Z ' ) or ( c >= ' a ' and c <= ' z ' ) : NEW_LINE INDENT letter += 1 NEW_LINE DEDENT DEDENT return letter NEW_LINE def count_of_numbers ( x ) : NEW_LINE INDENT number = 0 NEW_LINE for c in x : NEW_LINE INDENT if c >= '0' and c <= '9' : NEW_LINE INDENT number += 1 NEW_LINE DEDENT DEDENT return number NEW_LINE DEDENT def check ( x ) : NEW_LINE INDENT if count_of_letters ( x ) == count_of_numbers ( x ) : NEW_LINE INDENT sys . stdout . write ( ' Yes \n ' ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( ' No \n ' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT x = ' GeeKs01324' NEW_LINE check ( x ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . box = [ ] NEW_LINE self . i = 0 NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT self . box . append ( 0 ) NEW_LINE DEDENT DEDENT return Main ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import islice NEW_LINE from itertools import islice NEW_LINE for N , x in islice ( sys . stdin , 1 , None ) : NEW_LINE INDENT if x == 1 or x == 2 * N - 1 : NEW_LINE INDENT print ( " No " ) NEW_LINE break NEW_LINE DEDENT print ( " Yes " ) NEW_LINE low , high = x - 1 , x + 1 NEW_LINE deq = islice ( sys . stdin , 1 , None ) NEW_LINE while low != 0 or high != 2 * N : NEW_LINE INDENT if low == 0 : NEW_LINE INDENT deq . append ( high ) NEW_LINE deq . append ( high + 1 ) NEW_LINE high += 2 NEW_LINE DEDENT elif high == 2 * N : NEW_LINE INDENT deq . append ( low ) NEW_LINE deq . append ( low - 1 ) NEW_LINE low -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT deq . append ( low ) NEW_LINE low -= 1 NEW_LINE deq . append ( high ) NEW_LINE high += 1 NEW_LINE DEDENT DEDENT for s in deq : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 100001 NEW_LINE perfect_div = [ 0 ] * MAX NEW_LINE def precompute_counts ( ) : NEW_LINE INDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT for j in range ( i * i , MAX + i * i ) : NEW_LINE INDENT perfect_div [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT def count_perfect_divisors ( n ) : NEW_LINE INDENT return perfect_div [ n ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT precompute_counts ( ) NEW_LINE n = 16 NEW_LINE print ( ' Total ▁ perfect ▁ divisors ▁ of ▁ { } ▁ = ▁ { } ' . format ( n , count_perfect_divisors ( n ) ) ) NEW_LINE n = 12 NEW_LINE print ( ' Total ▁ perfect ▁ divisors ▁ of ▁ { } ▁ = ▁ { } ' . format ( n , count_perfect_divisors ( n ) ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n = sc . readline ( ) . strip ( ) NEW_LINE m = sc . readline ( ) . strip ( ) NEW_LINE nn = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT nn += sc . readline ( ) . strip ( ) NEW_LINE DEDENT mm = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT mm += sc . readline ( ) . strip ( ) NEW_LINE DEDENT print ( nn * mm ) NEW_LINE DEDENT DEDENT
def import import sys , string , symbols , Dummy , factorial , Rational NEW_LINE from sympy . utilities . iterables import variations NEW_LINE from sympy . utilities . misc import get_filesystem_encoding NEW_LINE from sympy . utilities . misc import get_filesystem_encoding NEW_LINE from sympy . utilities . misc import get_filesystem_encoding NEW_LINE from sympy . utilities . misc import get_filesystem_encoding NEW_LINE from sympy . utilities . misc import get_filesystem_encoding NEW_LINE from sympy . utilities . misc import get_filesystem_encoding NEW_LINE from sympy . utilities . misc import get_filesystem_encoding NEW_LINE from sympy . utilities . misc import get_filesystem_encoding NEW_LINE from sympy . utilities . misc import get_filesystem_encoding NEW_LINE from sympy . utilities . misc import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE from sympy . utilities . lambdify import get_filesystem_encoding NEW_LINE sys . modules = get_filesystem_encoding NEW_LINE def main ( ) : NEW_LINE INDENT from sympy . utilities . utilities . lambdify import main NEW_LINE main ( ) NEW_LINE DEDENT
def cal_IST ( h , r ) : NEW_LINE INDENT import math NEW_LINE IST = ( h * r * 1.0 ) / 360 NEW_LINE int_IST = int ( IST ) NEW_LINE float_IST = int ( math . ceil ( int ( ( IST - int_IST ) * 60 ) ) ) NEW_LINE print ( int_IST , " : " , float_IST ) NEW_LINE DEDENT
def print_roots ( n ) : NEW_LINE INDENT import math NEW_LINE from math import pi NEW_LINE from math import sin NEW_LINE theta = pi * 2 / n NEW_LINE for k in range ( n ) : NEW_LINE INDENT real = math . cos ( k * theta ) NEW_LINE img = math . sin ( k * theta ) NEW_LINE print ( " % . 3 f " % real , end = ' ▁ ' ) NEW_LINE if img >= 0 : NEW_LINE INDENT print ( " ▁ + ▁ i ▁ " , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ - ▁ i ▁ " , end = ' ▁ ' ) NEW_LINE DEDENT print ( " % . 3 f " % abs ( img ) ) NEW_LINE DEDENT DEDENT
def test_find_cart ( arr1 , arr2 , n , n1 ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import os NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_cart ( self , arr1 , arr2 , n , n1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n1 ) : NEW_LINE INDENT print ( " { % d , ▁ % d } , ▁ " % ( arr1 [ i ] , arr2 [ j ] ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE return find_cart ( self , arr1 , arr2 , n1 , n2 ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def no_of_ways ( s ) : NEW_LINE INDENT import sys NEW_LINE class solution : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = len ( s ) NEW_LINE self . count_left , self . count_right = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if self . s [ i ] == s [ 0 ] : NEW_LINE INDENT self . count_left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if self . s [ i ] == s [ n - 1 ] : NEW_LINE INDENT self . count_right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if self . s [ 0 ] == s [ n - 1 ] : NEW_LINE INDENT return ( ( self . count_left + 1 ) * ( self . count_right + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( self . count_left + self . count_right + 1 ) NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( no_of_ways ( s ) ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT global MAX NEW_LINE MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in prime : NEW_LINE INDENT i . append ( True ) NEW_LINE DEDENT DEDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , p ** 2 + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT def Main ( ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE SumOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT return Main NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( 0 , MAX + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , p ** 2 + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def solve ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n , k = 5 , 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE solve ( arr , n , k ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT global MAX NEW_LINE MAX = 1000000 NEW_LINE prime = [ False ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = True NEW_LINE prime [ 0 ] = True NEW_LINE for p in range ( 2 , p * MAX + 1 ) : NEW_LINE INDENT if prime [ p ] == False : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT def productOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT product *= arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( product ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n , k = 5 , 2 NEW_LINE arr = ( 2 , 3 , 5 , 7 , 11 ) NEW_LINE productOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def _findAllSequences ( diff , out , start , end ) : NEW_LINE INDENT import string NEW_LINE import sys NEW_LINE class MinSwaps : NEW_LINE INDENT def findAllSequences ( self , diff , out , start , end ) : NEW_LINE INDENT if abs ( diff ) > ( end - start + 1 ) / 2 : NEW_LINE INDENT return NEW_LINE DEDENT if start > end : NEW_LINE INDENT if diff == 0 : NEW_LINE INDENT print ( ' ' . join ( out [ : - 1 ] ) , end = end ) NEW_LINE print ( ' ▁ ' , end = end ) NEW_LINE DEDENT return NEW_LINE DEDENT out [ start ] = '0' NEW_LINE out [ end ] = '1' NEW_LINE self . findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = out [ end ] = '1' NEW_LINE self . findAllSequences ( diff , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = out [ end ] = '0' NEW_LINE self . findAllSequences ( diff , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = '1' NEW_LINE out [ end ] = '0' NEW_LINE self . findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 2 NEW_LINE out = ' ' NEW_LINE out [ 2 * n + 1 ] = ' \0 ' NEW_LINE self . findAllSequences ( 0 , out , 0 , 2 * n - 1 ) NEW_LINE print ( ' ' ) NEW_LINE DEDENT DEDENT
def import _NarrowFridge NEW_LINE class NarrowFridge ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = sys . stdin NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n , h = self . s . split ( ' ▁ ' ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( self . s . split ( ' ▁ ' ) [ 0 ] ) NEW_LINE DEDENT over_all_pq = PriorityQueue ( reverse = True ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT over_all_pq . append ( arr [ i ] ) NEW_LINE pq = PriorityQueue ( reverse = True ) NEW_LINE pq . extend ( over_all_pq ) NEW_LINE c1 , c2 = h , h NEW_LINE flag = True NEW_LINE while not pq . empty ( ) : NEW_LINE INDENT if flag : NEW_LINE INDENT if c1 >= pq . peek ( ) : NEW_LINE INDENT c1 -= pq . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT flag = False NEW_LINE DEDENT else : NEW_LINE INDENT if c2 >= pq . peek ( ) : NEW_LINE INDENT c2 -= pq . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT flag = True NEW_LINE DEDENT DEDENT if pq . empty ( ) : NEW_LINE INDENT ans = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE self . s . close ( ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while node is not None : NEW_LINE INDENT print ( " % s ▁ - > ▁ " % node . data , end = " ▁ " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( " NULL " ) NEW_LINE DEDENT def cntNodes ( node ) : NEW_LINE INDENT if not node : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + cntNodes ( node . next ) ) NEW_LINE DEDENT def updateList ( head , m ) : NEW_LINE INDENT cnt = cntNodes ( head ) NEW_LINE if cnt != m and m < cnt : NEW_LINE INDENT skip = cnt - m NEW_LINE prev = None NEW_LINE curr = head NEW_LINE while skip > 0 : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE skip -= 1 NEW_LINE DEDENT prev . next = None NEW_LINE tempHead = head NEW_LINE head = curr NEW_LINE while curr . next is not None : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT curr . next = tempHead NEW_LINE DEDENT printList ( head ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT head = GFG ( 4 ) NEW_LINE head . next = GFG ( 5 ) NEW_LINE head . next . next = GFG ( 6 ) NEW_LINE head . next . next . next = GFG ( 1 ) NEW_LINE head . next . next . next . next = GFG ( 2 ) NEW_LINE head . next . next . next . next . next = GFG ( 3 ) NEW_LINE m = 3 NEW_LINE updateList ( head , m ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def __max_substrings ( s , k ) : NEW_LINE INDENT import string NEW_LINE import string NEW_LINE import string NEW_LINE import io NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , s , k ) : NEW_LINE INDENT self . max_sub_str , n = 0 , len ( s ) NEW_LINE for c in range ( 26 ) : NEW_LINE INDENT ch = chr ( ord ( ' a ' ) + c ) NEW_LINE curr = 0 NEW_LINE for i in range ( 0 , n - k ) : NEW_LINE INDENT if s [ i ] != ch : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE while i < n and s [ i ] == ch and cnt != k : NEW_LINE INDENT i += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE if cnt == k : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT DEDENT DEDENT self . max_sub_str = max ( self . max_sub_str , curr ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def ansQueries ( prefeven , prefodd , l , r ) : NEW_LINE INDENT if ( r - l + 1 ) % 2 == 0 : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT if l % 2 == 0 : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * 100 NEW_LINE prefeven = [ 0 ] * 100 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i ) % 2 == 0 : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i != q : NEW_LINE INDENT yield prefeven , prefodd , l [ i ] , r [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = [ 2 , 3 , 4 ] NEW_LINE q = len ( l ) NEW_LINE yield arr , n , l , r , q NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import count NEW_LINE from random import randint NEW_LINE from itertools import chain NEW_LINE from itertools import chain NEW_LINE n = len ( chain ( * chain ( * repeat ( range ( n ) , n ) ) ) ) NEW_LINE ans = chain ( * chain ( * chain ( * repeat ( range ( n ) , n ) ) ) ) NEW_LINE ans . sort ( ) NEW_LINE count = ans [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ans [ i ] < ans [ i + 1 ] : NEW_LINE INDENT count += ans [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT while ans [ i ] >= ans [ i + 1 ] : NEW_LINE INDENT ans [ i ] -= 1 NEW_LINE DEDENT if ans [ i ] > 0 : NEW_LINE INDENT count += ans [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def import java . io . BufferedReader , os , sys , stdin , stdout , stderr , readlines , strip , iter , line , text , count , words , count , words , count , words , count , words , count , text , count , words , count , words , count , text , count , words , count , words , count , text , count , words , count , words , count , text , count , words , count , text , count , words , count , text , count , words , count , text , count , words , count , text , count , words , text , count , words , count , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , words , text , count , text , count , words , text , count , words , text , count , text , count , words , text , count , words , text , count , words , text , count , text , count , words , text , count , text , count , words , text , count , words , text , count , text , count , words , text , count , text , count , text , count , words , text , count , text , count , text , count , words , text , count , text , count , text , count , text , count , count , text , count , text , count , text ,
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( sys . stdin . read ( ) ) NEW_LINE self . q = int ( sys . stdin . read ( ) ) NEW_LINE self . Stack = { } NEW_LINE lines = [ ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT L = deque ( ) NEW_LINE self . Stack [ i ] = L NEW_LINE DEDENT for i in range ( self . q ) : NEW_LINE INDENT cmd = self . cmd NEW_LINE t = self . t NEW_LINE if cmd == 0 : NEW_LINE INDENT self . Stack [ t ] . append ( self . n ) NEW_LINE DEDENT elif cmd == 1 and self . Stack [ t ] != [ ] : NEW_LINE INDENT lines . append ( self . Stack [ t ] [ 0 ] + " \n " ) NEW_LINE DEDENT elif cmd == 2 and self . Stack [ t ] != [ ] : NEW_LINE INDENT self . Stack [ t ] . pop ( ) NEW_LINE DEDENT DEDENT print ( lines , end = " " ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT i , minVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT i , maxVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT removeMin ( arr , n ) NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) NEW_LINE DEDENT return arr NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE modifyArray ( arr , n , k ) NEW_LINE DEDENT DEDENT
def find_centroid ( v ) : NEW_LINE INDENT ans = [ ] NEW_LINE n = len ( v ) NEW_LINE signed_area = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x0 , y0 = v [ i ] NEW_LINE x1 , y1 = v [ ( i + 1 ) % n ] NEW_LINE A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE signed_area += A NEW_LINE ans . append ( ( x0 + x1 ) * A ) NEW_LINE ans . append ( ( y0 + y1 ) * A ) NEW_LINE DEDENT signed_area *= 0.5 NEW_LINE ans . append ( ( ans [ 0 ] ) / ( 6 * signed_area ) ) NEW_LINE ans . append ( ( ans [ 1 ] ) / ( 6 * signed_area ) ) NEW_LINE return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE color = " blue " NEW_LINE locked = False NEW_LINE with open ( " / etc / init . d / app . conf " , " r " ) as f : NEW_LINE INDENT import readline NEW_LINE lines = readline . readlines ( ) NEW_LINE for next in lines : NEW_LINE INDENT if " lock " == next . lstrip ( ) : NEW_LINE INDENT locked = True NEW_LINE continue NEW_LINE DEDENT if " unlock " == next . lstrip ( ) : NEW_LINE INDENT locked = False NEW_LINE continue NEW_LINE DEDENT if locked : NEW_LINE INDENT continue NEW_LINE DEDENT color = next NEW_LINE DEDENT print ( color ) NEW_LINE DEDENT DEDENT
def minOperations ( ar , k ) : NEW_LINE INDENT from numpy import arange NEW_LINE ar = np . sort ( ar ) NEW_LINE opsNeeded = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT opsNeeded += ar [ k - 1 ] - ar [ i ] NEW_LINE DEDENT ans = opsNeeded NEW_LINE for i in range ( k , len ( ar ) ) : NEW_LINE INDENT opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) NEW_LINE opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) NEW_LINE ans = min ( ans , opsNeeded ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def charcheck ( input_char ) : NEW_LINE INDENT import sys NEW_LINE if ( input_char >= 65 and input_char <= 90 ) or ( input_char >= 97 and input_char <= 122 ) : NEW_LINE INDENT print ( " ▁ Alphabet ▁ " ) NEW_LINE DEDENT elif input_char >= 48 and input_char <= 57 : NEW_LINE INDENT print ( " ▁ Digit ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ Special ▁ Character ▁ " ) NEW_LINE DEDENT DEDENT
def import sys , symbols , dict NEW_LINE from sympy . utilities . iterables import iterables NEW_LINE sc = symbols ( ' r ' ) NEW_LINE n = len ( sys . stdin ) NEW_LINE lst = [ sc . readline ( ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d = { i + 1 : 1 } NEW_LINE flag = 0 NEW_LINE j = i NEW_LINE while flag == 0 : NEW_LINE INDENT if lst [ j ] not in d : NEW_LINE INDENT d [ lst [ j ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE print ( lst [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT j = lst [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT
def import _zeropy NEW_LINE class zer ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( self . n ) NEW_LINE self . m = int ( self . m ) NEW_LINE self . p = [ ] NEW_LINE self . tab = [ ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT self . p . append ( self . p [ i ] ) NEW_LINE self . tab . append ( set ( ) ) NEW_LINE DEDENT DEDENT ans = 3000003 NEW_LINE for i in range ( self . m ) : NEW_LINE INDENT a = _zeropy ( i ) - 1 NEW_LINE b = _zeropy ( i ) - 1 NEW_LINE for x in self . tab [ a ] : NEW_LINE INDENT if x in self . tab [ b ] : NEW_LINE INDENT ans = min ( self . p [ a ] + self . p [ b ] + self . p [ x ] , ans ) NEW_LINE DEDENT DEDENT self . tab [ a ] . add ( b ) NEW_LINE self . tab [ b ] . add ( a ) NEW_LINE DEDENT if ans == 3000003 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT
def import sys , StringIO , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B , C67B ,
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import string NEW_LINE import sys NEW_LINE class B147 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . x = random . randint ( 0 , 50 ) NEW_LINE self . y = random . randint ( 0 , 50 ) NEW_LINE DEDENT def __call__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT n = [ int ( i ) for i in range ( n ) ] NEW_LINE c = [ int ( i ) for i in range ( n ) ] NEW_LINE table = [ [ ] for i in range ( 50 ) ] NEW_LINE d = { } NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , c [ i - 1 ] + 1 ) : NEW_LINE INDENT cell = random . randint ( 0 , 50 ) NEW_LINE d [ cell ] = ( i , j ) NEW_LINE table [ i - 1 ] [ j - 1 ] = cell NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE m = 0 NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( c [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE if len ( table [ i ] [ j ] ) == cnt : NEW_LINE INDENT continue NEW_LINE DEDENT s . append ( " % d ▁ % d ▁ % d \n " % ( i + 1 , j + 1 , cnt ) ) NEW_LINE point = d [ cnt ] NEW_LINE s . append ( " % d ▁ % d \n " % ( point [ 0 ] , point [ 1 ] ) ) NEW_LINE tmp = table [ i ] [ j ] NEW_LINE table [ i ] [ j ] = table [ point [ 0 ] - 1 ] [ point [ 1 ] - 1 ] NEW_LINE table [ point [ 0 ] - 1 ] [ point [ 1 ] - 1 ] = tmp NEW_LINE d [ tmp ] = point NEW_LINE m += 1 NEW_LINE DEDENT DEDENT print ( m ) NEW_LINE s = ' ' . join ( s ) NEW_LINE if m > 0 : print ( s ) NEW_LINE DEDENT
def test_same_occurrence ( arr , n , x , y ) : NEW_LINE INDENT import pytree NEW_LINE class solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT ct_x , ct_y = 0 , 0 NEW_LINE for j in range ( i , n - 1 ) : NEW_LINE INDENT if arr [ j ] == x : NEW_LINE INDENT ct_x += 1 NEW_LINE DEDENT elif arr [ j ] == y : NEW_LINE INDENT ct_y += 1 NEW_LINE DEDENT if ct_x == ct_y : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT
def test_251 ( ) : NEW_LINE INDENT import sys NEW_LINE from pybind11_tests import test_251 NEW_LINE t = test_251 ( ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a = sys . stdin . read ( ) . decode ( ' utf - 8' ) NEW_LINE if len ( a ) >= 3 : NEW_LINE INDENT z , o = 0 , 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] == '1' : NEW_LINE INDENT o += 1 NEW_LINE DEDENT else : NEW_LINE INDENT z += 1 NEW_LINE DEDENT DEDENT if z > o : NEW_LINE INDENT print ( o ) NEW_LINE DEDENT elif o > z : NEW_LINE INDENT print ( z ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( z - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT
def import _sys , os , sys , stdin , stdout , stdin , stderr , n , words , words , count , words , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , count , words , words , count , words , count , words , words , count , words , count , words , words , count , words , words , count , words , words , count , words , count , words , words , count , words , words , count , words , words , count , words , words , count , words , words , count , words , words , count , words , words , count , words , words , count , words , words , count , words , words , words , count , words , words , words , count , words , words , words , count , words , words , words , count , words , words , words , count , words , words , words , words , count , words , words , words , count , words , words , words , words , count , words , words , words , words , words , count , words , words , words , words , words , count , words , words , words , words , words , count , words , words , words , words , words , words , words , count , words , words , words , words , words , words , words , count , words , words , words , words , words , words , words , words , words , count , words , words , words , words , words , words , words , words
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE DEDENT def __call__ ( self ) : NEW_LINE INDENT for i in range ( 5 ) : NEW_LINE INDENT print ( " % d ▁ " % i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE total_count = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT to_find = target / ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if arr [ k ] == to_find : NEW_LINE INDENT total_count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( " Total ▁ number ▁ of ▁ triplets ▁ found : ▁ " + str ( total_count ) ) NEW_LINE DEDENT
def _ import ▁ os . path ENDCOM import os NEW_LINE class Multiples_Of_Length ( object ) : NEW_LINE INDENT class FastReader : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT while not os . path . isfile ( self . path ) or not os . path . isfile ( self . path ) : NEW_LINE INDENT try : NEW_LINE INDENT os . readfp ( self . path ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return os . path . basename ( self . path ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not os . path . isfile ( self . path ) or not os . path . isfile ( self . path ) : NEW_LINE INDENT try : NEW_LINE INDENT os . readfp ( self . path ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return os . path . basename ( self . path ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT data = ' ' NEW_LINE try : NEW_LINE INDENT data = os . readfp ( self . path ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT return data NEW_LINE DEDENT DEDENT def write ( self , data ) : NEW_LINE INDENT t = FastReader ( data ) NEW_LINE o = sys . stdout NEW_LINE n = t . __next__ ( ) NEW_LINE a = [ t . __next__ ( ) for _ in range ( n ) ] NEW_LINE if n == 1 : NEW_LINE INDENT o . write ( "1 ▁ 1" ) NEW_LINE o . write ( - a [ 0 ] ) NEW_LINE o . write ( "1 ▁ 1" ) NEW_LINE o . write ( "0" ) NEW_LINE o . write ( "1 ▁ 1" ) NEW_LINE o . write ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT o . write ( "1 ▁ 1" ) NEW_LINE o . write ( - a [ 0 ] ) NEW_LINE o . write ( "1 ▁ % d " % n ) NEW_LINE a [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT o . write ( " % -20s ▁ " % ( - n * a [ i ] ) ) NEW_LINE DEDENT o . write ( " \n 2 ▁ % d " % n ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT o . write ( " % -20s ▁ " % ( ( n - 1 ) * a [ i ] ) ) NEW_LINE DEDENT o . flush ( ) NEW_LINE o . close ( ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = __gcd ( result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE def __gcd ( a , b ) : NEW_LINE INDENT return b , a % b NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 3 , 9 , 6 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( __gcd ( arr , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , a , n ) : NEW_LINE INDENT self . N = 1000 NEW_LINE DEDENT def lastElement ( self , a , n ) : NEW_LINE INDENT self . steps = 1 NEW_LINE v = [ [ ] for i in range ( self . N ) ] NEW_LINE if n == 1 : return a [ 0 ] NEW_LINE for i in range ( 0 , n , 2 ) : v [ steps ] . append ( a [ i ] | a [ i + 1 ] ) NEW_LINE while len ( v [ steps ] ) > 1 : NEW_LINE INDENT self . steps += 1 NEW_LINE for i in range ( 0 , len ( v [ steps - 1 ] ) , 2 ) : NEW_LINE INDENT if self . steps % 2 == 1 : v [ steps ] . append ( v [ steps - 1 ] [ i ] | v [ steps - 1 ] [ i + 1 ] ) NEW_LINE else : v [ steps ] . append ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT DEDENT return v [ steps ] [ 0 ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a = [ 1 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE index = 0 NEW_LINE value = 2 NEW_LINE a [ 0 ] = 2 NEW_LINE print ( self . lastElement ( a , n ) ) NEW_LINE index = 3 NEW_LINE value = 5 NEW_LINE a [ index ] = value NEW_LINE print ( self . lastElement ( a , n ) ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def number_cake ( self , n ) : NEW_LINE INDENT return ( n ** 2 * n ** 2 + 5 * n + 6 ) / 6 NEW_LINE DEDENT def number_cake ( self , n ) : NEW_LINE INDENT n = 2 NEW_LINE print ( self . number_cake ( n ) ) NEW_LINE n = 8 NEW_LINE print ( self . number_cake ( n ) ) NEW_LINE n = 25 NEW_LINE print ( self . number_cake ( n ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from string import printable NEW_LINE sc = Scanner ( ) NEW_LINE input = sc . next ( ) . split ( ' ▁ ' ) NEW_LINE result = 0 NEW_LINE p = 0 NEW_LINE g = 1 NEW_LINE for i in input : NEW_LINE INDENT if i == ' g ' : NEW_LINE INDENT if p + 1 <= g : NEW_LINE INDENT result += 1 NEW_LINE p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT g += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if p + 1 <= g : NEW_LINE INDENT p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT g += 1 NEW_LINE result -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def pattern ( N ) : NEW_LINE INDENT import sys NEW_LINE class solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = N NEW_LINE DEDENT DEDENT class solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = 6 NEW_LINE DEDENT DEDENT pattern = solution ( ) NEW_LINE pattern . start ( ) NEW_LINE pattern . stop ( ) NEW_LINE pattern . step ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def maximum_middle_value ( self , n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) // 2 NEW_LINE high = ( n + 1 - k ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n , k = 9 , 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def import _tree_from_root NEW_LINE class TreeNode ( object ) : NEW_LINE INDENT def __init__ ( self , root_data ) : NEW_LINE INDENT self . val = root_data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def __init__ ( self , root , sum ) : NEW_LINE INDENT self . result = 0 NEW_LINE self . cache = { } NEW_LINE self . cache [ 0 ] = 1 NEW_LINE self . path_sum_helper ( root , sum , 0 ) NEW_LINE return self . result NEW_LINE DEDENT def path_sum_helper ( root , target , so_far ) : NEW_LINE INDENT if root is not None : NEW_LINE INDENT complement = so_far + root . val - target NEW_LINE if complement in self . cache : NEW_LINE INDENT self . result += self . cache [ complement ] NEW_LINE DEDENT self . cache [ so_far + root . val ] = self . cache . get ( so_far + root . val , 0 ) + 1 NEW_LINE self . path_sum_helper ( root . left , target , so_far + root . val ) NEW_LINE self . path_sum_helper ( root . right , target , so_far + root . val ) NEW_LINE self . cache [ so_far + root . val ] = self . cache [ so_far + root . val ] - 1 NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE tree = TreeNode ( 10 ) NEW_LINE tree . left = TreeNode ( 5 ) NEW_LINE tree . right = TreeNode ( - 3 ) NEW_LINE tree . left . left = TreeNode ( 3 ) NEW_LINE tree . left . right = TreeNode ( 2 ) NEW_LINE tree . right . right = TreeNode ( 11 ) NEW_LINE tree . left . left . left = TreeNode ( 3 ) NEW_LINE tree . left . left . right = TreeNode ( - 2 ) NEW_LINE tree . left . right . right = TreeNode ( 1 ) NEW_LINE sum = 8 NEW_LINE out = sObj . path_sum ( tree , sum ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT
def test_getmax ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def getmax ( self , arr , n , x ) : NEW_LINE INDENT s = np . array ( arr ) NEW_LINE print ( np . min ( s ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( self . n ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " Case ▁ % d : " % i ) NEW_LINE self . msm ( self . n , 1 ) NEW_LINE DEDENT DEDENT def msm ( self , n , c ) : NEW_LINE INDENT if c == 11 : return NEW_LINE data = str ( n * n ) NEW_LINE data = [ 0 ] * 8 - len ( data ) NEW_LINE data = data [ 2 : 6 ] NEW_LINE out = int ( data ) NEW_LINE print ( out ) NEW_LINE self . msm ( out , c + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = sys . stdin NEW_LINE sosu = [ True ] * ( 123456 * 2 + 1 ) NEW_LINE sosu [ 0 ] = False NEW_LINE sosu [ 1 ] = False NEW_LINE for i in range ( 2 , 123456 * 2 ) : NEW_LINE INDENT if sosu [ i ] : NEW_LINE INDENT for j in range ( 2 , i * 123456 * 2 + 1 ) : NEW_LINE INDENT sosu [ i * j ] = False NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT n = sys . stdin . readline ( ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n + 1 , n * 2 + 1 ) : NEW_LINE INDENT if sosu [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) NEW_LINE DEDENT DEDENT return maxVal NEW_LINE DEDENT
def import java . util . regex NEW_LINE class Solution : NEW_LINE INDENT def numJewelsInStones ( self , J , S ) : NEW_LINE INDENT result = 0 NEW_LINE jHash = set ( [ J [ j ] for j in J ] ) NEW_LINE for s in S : NEW_LINE INDENT if s in jHash : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE J = " aA " NEW_LINE S = " aAAbbbb " NEW_LINE out = sObj . numJewelsInStones ( J , S ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX , self . n = 100 , self . MAX NEW_LINE DEDENT def store = [ ] NEW_LINE graph = [ ] NEW_LINE def d = [ ] NEW_LINE def is_clique ( self , b ) : NEW_LINE INDENT for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( i + 1 , b ) : NEW_LINE INDENT if self . graph [ store [ i ] ] [ store [ j ] ] == 0 : return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def max_cliques ( self , i , l ) : NEW_LINE INDENT max_ = 0 NEW_LINE for j in range ( i + 1 , self . n + 1 ) : NEW_LINE INDENT store . append ( l ) NEW_LINE if is_clique ( l + 1 ) : NEW_LINE INDENT max_ = max ( max_ , self . l ) NEW_LINE max_ = max ( max_ , max_cliques ( self , j , l + 1 ) ) NEW_LINE DEDENT DEDENT return max_ NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 1 ] , [ 4 , 2 ] ] NEW_LINE edges = [ [ 1 , 2 ] , [ 3 , 1 ] , [ 4 , 1 ] , [ 4 , 2 ] ] NEW_LINE edges = edges + [ [ 1 , 2 ] , [ 3 , 1 ] , [ 4 , 1 ] , [ 4 , 2 ] ] NEW_LINE edges = edges + [ [ 1 , 2 ] , [ 3 , 1 ] , [ 4 , 1 ] , [ 4 , 2 ] ] NEW_LINE edges = edges + [ [ 1 , 2 ] , [ 3 , 1 ] , [ 4 , 1 ] , [ 4 , 2 ] ] NEW_LINE edges = edges + [ [ 1 , 2 ] , [ 3 , 1 ] , [ 4 , 1 ] , [ 4 , 2 ] ] NEW_LINE edges = edges + [ [ 1 , 2 ] , [ 3 , 1 ] , [ 4 , 1 ] , [ 4 , 2 ] ] NEW_LINE edges = edges + [ [ 1 , 2 ] , [ 3 , 1 ] , [ 4 , 1 ] , [ 4 , 2 ] ] NEW_LINE edges = edges + [ [ 1 , 2 ] , [ 3 , 1 ] , [ 4 , 2 ] ] NEW_LINE graph . append ( edges ) NEW_LINE DEDENT print ( max_
def GFG ( n ) : NEW_LINE INDENT k = int ( math . log ( n ) / math . log ( 2 ) ) NEW_LINE return int ( math . pow ( 2 , k ) ) NEW_LINE def main ( arg ) : NEW_LINE INDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import import string , getopt NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from binascii import b2a_uu NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os . urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os . urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os . urandom NEW_LINE from os . urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os . urandom NEW_LINE from os import urandom NEW_LINE from os . urandom NEW_LINE from os import urandom NEW_LINE from os . urandom NEW_LINE from os import urandom NEW_LINE from os . urandom NEW_LINE from os . urandom NEW_LINE from os . urandom NEW_LINE from os . path import getfile NEW_LINE from os . urandom NEW_LINE from os . urandom NEW_LINE from os . path import getroot NEW_LINE from os . urandom NEW_LINE from os . urandom import randint NEW_LINE from os . urandom NEW_LINE from os . urandom import urandom NEW_LINE from os . urandom NEW_LINE from os . urandom import getroot NEW_LINE from os . urandom NEW_LINE from os . urandom import urandom NEW_LINE from os . urandom NEW_LINE from os . urandom import getroot NEW_LINE from os . urandom NEW_LINE from os . urandom import urandom NEW_LINE from os . urandom NEW_LINE from os . urandom import getroot NEW_LINE from os . urandom NEW_LINE def write ( s , f ) : NEW_LINE INDENT """ Write ▁ the ▁ text ▁ file ▁ to ▁ a ▁ random ▁ file . """ NEW_LINE f = urandom ( 16 ) NEW_LINE f = urandom ( 1024 ) NEW_LINE f = urandom ( 1 ) NEW_LINE f = urandom ( f ) NEW_LINE f = urandom ( f ) NEW_LINE f = urandom ( f ) NEW_LINE f = urandom ( f ) NEW_LINE f = urandom ( f ) NEW_LINE f = urandom ( f ) NEW_LINE f = urandom ( f ) NEW_LINE f = urandom ( f ) NEW_LINE f = urandom ( f ) NEW_LINE f = urandom ( f ) NEW_LINE f = urandom ( f ) NEW_LINE f = urandom ( f ) NEW_LINE from os . urandom import hexlify NEW_LINE bs = urandom ( bs ) NEW_LINE actions = [ ] NEW_LINE for i in range ( 0 , bs ) : NEW_LINE INDENT actions . append ( ' X ' ) NEW_LINE DEDENT for i in actions : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
def subset_pair_not_divisible_by_K ( arr , N , K ) : NEW_LINE INDENT from scipy . sparse import csc_matrix NEW_LINE f = [ 0 ] * K NEW_LINE f [ arr [ i ] % K ] += 1 NEW_LINE if K % 2 == 0 : NEW_LINE INDENT f [ K // 2 ] = min ( f [ K // 2 ] ) NEW_LINE DEDENT res = min ( f [ 0 ] ) NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT res += max ( f [ i ] , f [ K - i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT import math NEW_LINE import os NEW_LINE import os NEW_LINE import os NEW_LINE import math NEW_LINE class Main ( object ) : NEW_LINE INDENT def get ( a ) : NEW_LINE INDENT ret = 0 NEW_LINE now = 1 NEW_LINE t = 1 NEW_LINE for _ in range ( 10 ) : NEW_LINE INDENT if now * 10 > a : NEW_LINE INDENT ret += ( a - now + 1 ) * t NEW_LINE break NEW_LINE DEDENT ret += now * 9 * t NEW_LINE now *= 10 NEW_LINE t += 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def binary_search ( k , l , r , x ) : NEW_LINE INDENT if r >= l : NEW_LINE INDENT mid = l + ( r - l ) / 2 NEW_LINE if mid > ans and mid * k <= x : NEW_LINE INDENT ans = mid NEW_LINE DEDENT if k * mid == x : NEW_LINE INDENT return mid NEW_LINE DEDENT if k * mid > x : NEW_LINE INDENT return binary_search ( k , l , mid - 1 , x ) NEW_LINE DEDENT return binary_search ( k , mid + 1 , r , x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT f = open ( " / dev / null " , " r " ) NEW_LINE f . write ( " \n " ) NEW_LINE def main ( ) : NEW_LINE INDENT S = sys . stdin NEW_LINE gen , st , tim = S . read ( ) , S . read ( ) , S . read ( ) NEW_LINE gen /= tim NEW_LINE beg , end = st - 1 , int ( math . pow ( 10 , 18 ) ) NEW_LINE while 1 : NEW_LINE INDENT med = ( beg + end ) // 2 + 1 NEW_LINE if get ( med ) - get ( st - 1 ) > gen : NEW_LINE INDENT end = med - 1 NEW_LINE DEDENT else : NEW_LINE INDENT beg = med NEW_LINE DEDENT if beg == end : NEW_LINE INDENT print ( beg - st + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return main NEW_LINE DEDENT
def GFG ( a , b , c ) : NEW_LINE INDENT print ( 1 , c / ( a * 1.0 ) ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT memo = [ [ 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [
def GFG ( mat , n ) : NEW_LINE INDENT N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ ] NEW_LINE if mat [ 0 ] [ 0 ] == 1 : NEW_LINE INDENT dp . append ( [ 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ 0 ] [ i ] == 1 : NEW_LINE INDENT dp [ 0 ] . append ( int ( dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] . append ( dp [ 0 ] [ i - 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ 0 ] == 1 : NEW_LINE INDENT dp [ i ] . append ( int ( dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] . append ( dp [ i - 1 ] [ 0 ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ j ] == 1 : NEW_LINE INDENT dp [ i ] . append ( int ( max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] . append ( max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT return MaximumDecimalValue ( mat , 4 ) NEW_LINE DEDENT
def import _hash_of_fibonacci_pair NEW_LINE class GFG ( object ) : NEW_LINE INDENT def createHash ( self , maxElement ) : NEW_LINE INDENT prev , curr = 0 , 1 NEW_LINE self . hash . add ( prev ) NEW_LINE self . hash . add ( curr ) NEW_LINE while curr < maxElement : NEW_LINE INDENT temp = curr + prev NEW_LINE self . hash . add ( temp ) NEW_LINE prev , curr = curr , temp NEW_LINE DEDENT DEDENT def findFibonacci_pair ( self , n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE self . createHash ( hash , n ) NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT if i in hash and self . n - i in hash : NEW_LINE INDENT print ( i , end = ' , ▁ ' , end = ' ' ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' - 1 \n ' , end = ' ' ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT N = 90 NEW_LINE findFibonacci_pair ( self , N ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT import sys NEW_LINE import itertools NEW_LINE class GFG ( object ) : NEW_LINE INDENT def countgroup ( self , a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT if not xs : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countgroup ( a , n ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def __max_length ( s , n ) : NEW_LINE INDENT from math import ceil NEW_LINE ans = ceil ( 0 ) NEW_LINE A = [ ] NEW_LINE L = [ ] NEW_LINE R = [ ] NEW_LINE freq = [ 0 ] * ( n + 5 ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if s [ j ] - ' a ' == i : NEW_LINE INDENT count += 1 NEW_LINE DEDENT freq [ j ] = count NEW_LINE DEDENT DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT L . append ( ( 2 * freq [ j - 1 ] ) - j ) NEW_LINE R . append ( ( 2 * freq [ j ] ) - j ) NEW_LINE DEDENT max_len = ceil ( 0 ) NEW_LINE min_val = ceil ( 0 ) NEW_LINE for j in range ( len ( L ) ) : NEW_LINE INDENT min_val = min ( min_val , L [ j ] ) NEW_LINE A . append ( min_val ) NEW_LINE l , r = 0 , j NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE if A [ mid ] <= R [ j ] : NEW_LINE INDENT max_len = max ( max_len , j - mid + 1 ) NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT DEDENT ans = max ( ans , max_len ) NEW_LINE A = [ ] NEW_LINE R = [ ] NEW_LINE L = [ ] NEW_LINE DEDENT
def import _igg NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , first , second ) : NEW_LINE INDENT self . first = first NEW_LINE self . second = second NEW_LINE DEDENT def __init__ ( self , first , second ) : NEW_LINE INDENT self . first = first NEW_LINE self . second = second NEW_LINE DEDENT def N ( self ) : NEW_LINE INDENT return 100005 NEW_LINE DEDENT def gr ( self , gr ) : NEW_LINE INDENT self . colour = [ ] NEW_LINE self . edges = [ ] NEW_LINE DEDENT def add_edge ( self , x , y ) : NEW_LINE INDENT gr ( self , gr ) NEW_LINE self . colour . append ( y ) NEW_LINE gr ( self , gr ) NEW_LINE self . edges . append ( ( self . x , self . y ) ) NEW_LINE DEDENT def dfs ( self , col ) : NEW_LINE INDENT self . colour [ x ] = col NEW_LINE for i in gr ( self , gr ) : NEW_LINE INDENT if i == - 1 : NEW_LINE INDENT dfs ( i , col ^ 1 ) NEW_LINE DEDENT elif i == col : NEW_LINE INDENT bip = False NEW_LINE DEDENT DEDENT DEDENT def Directed_Graph ( self , n , m ) : NEW_LINE INDENT for i in range ( self . N ) : NEW_LINE INDENT self . colour [ i ] = - 1 NEW_LINE DEDENT bip = True NEW_LINE dfs ( 1 , 1 ) NEW_LINE if not bip : NEW_LINE INDENT print ( - 1 , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if self . colour [ edges [ i ] [ 0 ] ] == 0 : NEW_LINE INDENT self . swap ( edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT print ( edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n , m = 4 , 3 NEW_LINE for i in range ( self . N ) : NEW_LINE INDENT gr ( self , gr ) NEW_LINE DEDENT self . add_edge ( 1 , 2 ) NEW_LINE self . add_edge ( 1 , 3 ) NEW_LINE self . add_edge ( 1 , 4 ) NEW_LINE Directed_Graph ( self , n , m ) NEW_LINE DEDENT DEDENT
def import import struct NEW_LINE from EhabOddPerson import EhabOddPerson NEW_LINE from EhabOddPerson import EhabOddPerson NEW_LINE from EhabOddPerson import EhabOddPerson NEW_LINE from EhabOddPerson import EhabOddPerson NEW_LINE from EhabOddPerson import EhabOddPerson NEW_LINE f = open ( " EhabOddPerson . txt " , " r " ) NEW_LINE n = int ( f . readline ( ) . strip ( ) ) NEW_LINE line1 = f . readline ( ) . strip ( ) . split ( ) NEW_LINE arr = [ long ( i ) for i in line1 ] NEW_LINE odd , even = False , False NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even = True NEW_LINE DEDENT else : NEW_LINE INDENT odd = True NEW_LINE DEDENT ans . append ( arr [ i ] ) NEW_LINE DEDENT if odd and even : NEW_LINE INDENT ans . sort ( ) NEW_LINE DEDENT for i in ans : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . o , self . g , self . x = sys . argv [ 0 ] , 0 , 0 NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . o , self . x = 0 , 0 , 0 NEW_LINE self . n , self . g = 0 , 0 , 0 NEW_LINE for i in range ( 1 , self . g + 1 ) : NEW_LINE INDENT self . x = self . x + i * self . o NEW_LINE DEDENT self . borrow = self . x - self . n NEW_LINE if self . borrow <= 0 : NEW_LINE INDENT self . print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . print ( self . borrow ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( k ) : NEW_LINE INDENT if k <= 1 : return False NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if k % i == 0 : return False NEW_LINE DEDENT return True NEW_LINE def check ( num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if num % i == 0 : flag = 0 NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT if num % k == 0 : return 1 NEW_LINE else : return 0 NEW_LINE DEDENT else : return 0 NEW_LINE DEDENT def findCount ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE if not isPrime ( k ) : return 0 NEW_LINE else : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT ans = check ( i , k ) NEW_LINE if ans == 1 : count += 1 NEW_LINE else : continue NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a , b , k = 2020 , 6300 , 29 NEW_LINE print ( findCount ( a , b , k ) ) NEW_LINE DEDENT DEDENT
def import _readline NEW_LINE import termios NEW_LINE import sys NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . . builtin_module_field import _ECField NEW_LINE from . import _ECField NEW_LINE from . import _ECField NEW_LINE from . import _ECField NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT maxn = 16 NEW_LINE def precompute ( ) : NEW_LINE INDENT dp , arr = [ - 1 ] , [ 4 , 6 , 9 ] NEW_LINE for i in range ( maxn ) : NEW_LINE INDENT dp . append ( - 1 ) NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , maxn ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT j = arr [ k ] NEW_LINE if i >= j and dp [ i - j ] != - 1 : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp NEW_LINE DEDENT def Maximum_Summands ( dp , n ) : NEW_LINE INDENT if n < maxn : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT t = ( n - maxn ) // 4 + 1 NEW_LINE return t + dp [ n - 4 * t ] NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 12 NEW_LINE dp = precompute ( ) NEW_LINE print ( Maximum_Summands ( dp , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( n ) : return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 NEW_LINE def main ( ) : NEW_LINE INDENT n = 3 NEW_LINE print ( ' Count ▁ of ▁ squares ▁ is ▁ { } ' . format ( count_squares ( n ) ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from collections import defaultdict NEW_LINE from time import time NEW_LINE from time import sleep NEW_LINE from time import sleep NEW_LINE n = int ( time ( ) ) NEW_LINE m = int ( time ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a . append ( sleep ( 1 ) ) NEW_LINE DEDENT sum = [ a [ i ] + a [ i - 1 ] for i in range ( 1 , n + 1 ) ] NEW_LINE d = { } NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT d [ sum [ i ] % m ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = d [ sum [ i ] % m ] NEW_LINE d [ sum [ i ] % m ] = x + 1 NEW_LINE DEDENT ans = 0 NEW_LINE if 0l in d : NEW_LINE INDENT ans = d [ 0l ] NEW_LINE DEDENT for i in d : NEW_LINE INDENT if d [ i ] >= 2 : NEW_LINE INDENT for j in d [ i ] [ 1 : ] : NEW_LINE INDENT ans += j - 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT class Pair ( object ) : NEW_LINE INDENT def __init__ ( self , from = 0 , end = None , num = None , bango = None ) : NEW_LINE INDENT self . from = from NEW_LINE self . end = end NEW_LINE self . num = num NEW_LINE self . bango = bango NEW_LINE DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT otherpair = other NEW_LINE return self . from - otherpair . from NEW_LINE DEDENT DEDENT
def GFG ( arr , n , k ) : NEW_LINE INDENT count_one = [ sum ( arr [ i ] ) for i in range ( n ) ] NEW_LINE sum = count_one [ 0 ] NEW_LINE if n == 1 : NEW_LINE INDENT if count_one [ 0 ] >= k : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT ans = sys . maxint NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while i < n : NEW_LINE INDENT if k == count_one [ j ] : NEW_LINE INDENT ans = 1 NEW_LINE break NEW_LINE DEDENT elif k == count_one [ i ] : NEW_LINE INDENT ans = 1 NEW_LINE break NEW_LINE DEDENT elif sum + count_one [ i ] < k : NEW_LINE INDENT sum += count_one [ i ] NEW_LINE i += 1 NEW_LINE DEDENT elif sum + count_one [ i ] > k : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) NEW_LINE sum -= count_one [ j ] NEW_LINE j += 1 NEW_LINE DEDENT elif sum + count_one [ i ] == k : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) NEW_LINE sum += count_one [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if ans != sys . maxint : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT global loss NEW_LINE SP , P = 2400 , 30 NEW_LINE loss = float ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) NEW_LINE print ( " Loss ▁ = ▁ " + " % . 3 f " % loss ) NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = sys . stdin . readline ( ) . split ( ' ▁ ' ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . m , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . m , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . m , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . m , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . x , self . n NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . m , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . m , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . m , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . m , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x = self . n , self . x NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m , self . x
def test_A1138_SushiForTwo ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import count NEW_LINE n = count ( 1 ) NEW_LINE len , prev , one_seq , two_seq = 1 , 0 , 0 , 0 NEW_LINE while n : NEW_LINE INDENT x = sys . stdin . read ( n ) NEW_LINE if x == 1 : NEW_LINE INDENT if prev == 1 : NEW_LINE INDENT one_seq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one_seq = 1 NEW_LINE DEDENT prev = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if prev == 2 : NEW_LINE INDENT two_seq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT two_seq = 1 NEW_LINE DEDENT prev = 2 NEW_LINE DEDENT if min ( one_seq , two_seq ) > len : NEW_LINE INDENT len = min ( one_seq , two_seq ) NEW_LINE DEDENT DEDENT print ( len * 2 ) NEW_LINE DEDENT
def p092 ( ) : NEW_LINE INDENT print ( eval ( ' p092' ) ( ) ) NEW_LINE LIMIT = library . pow ( 10 , 7 ) NEW_LINE def run ( ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , LIMIT ) : NEW_LINE INDENT if is_class89 ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT def is_class89 ( x ) : NEW_LINE INDENT while True : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT elif x == 89 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT x = next_number ( x ) NEW_LINE DEDENT DEDENT DEDENT def next_number ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += ( x % 10 ) * ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT return run NEW_LINE DEDENT
def gf_fact ( n ) : NEW_LINE INDENT import string NEW_LINE from sympy . combinatorics . permutations import permutations NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT self . fact *= i NEW_LINE DEDENT DEDENT def countStrings ( self , n ) : NEW_LINE INDENT distinct_char = set ( string . ascii_lowercase ) NEW_LINE return len ( permutations ( distinct_char ) ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE print ( sum ( permutations ( str , n ) ) ) NEW_LINE DEDENT DEDENT return GFG ( n ) NEW_LINE DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , mat ) : NEW_LINE INDENT self . M = 4 NEW_LINE self . N = 5 NEW_LINE DEDENT def printCommonElements ( self ) : NEW_LINE INDENT mp = { } NEW_LINE for j in range ( self . N ) : NEW_LINE INDENT mp [ self . mat [ 0 ] [ j ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( self . N ) : NEW_LINE INDENT if mp . get ( self . mat [ i ] [ j ] ) and mp . get ( self . mat [ i ] [ j ] ) == i : NEW_LINE INDENT mp [ self . mat [ i ] [ j ] ] = i + 1 NEW_LINE if i == self . M - 1 : NEW_LINE INDENT print ( self . mat [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT mat = [ [ 1 , 2 , 1 , 4 , 8 ] , [ 3 , 7 , 8 , 5 , 1 ] , [ 8 , 7 , 7 , 3 , 1 ] , [ 8 , 1 , 2 , 7 , 9 ] , ] NEW_LINE printCommonElements ( mat ) NEW_LINE DEDENT DEDENT
def import _antonandlines NEW_LINE import csv NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from time import sleep NEW_LINE from time import sleep NEW_LINE from time import sleep NEW_LINE from time import sleep NEW_LINE n = int ( sleep ( 1 ) ) NEW_LINE t = int ( sleep ( 1 ) ) NEW_LINE s = [ sleep ( 1 ) for i in range ( n ) ] NEW_LINE d = [ sleep ( 1 ) for i in range ( n ) ] NEW_LINE print ( solve ( s , d , t ) ) NEW_LINE sleep ( 1 ) NEW_LINE def solve ( s , d , t ) : NEW_LINE INDENT min_time = sleep ( 1 ) NEW_LINE result = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT time = divmod ( t - s [ i ] , d [ i ] ) * d [ i ] + s [ i ] NEW_LINE if time < min_time : NEW_LINE INDENT min_time = time NEW_LINE result = i + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def divide_to_ceil ( x , y ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return x // y + ( 0 if x % y == 0 else 1 ) NEW_LINE DEDENT return solve ( s , d , t ) NEW_LINE DEDENT
def GFG ( a , d , n ) : NEW_LINE INDENT def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + a NEW_LINE a = a + d NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 20 NEW_LINE a , d = 2.5f , 1.5f NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE DEDENT return sumOfAP ( a , d , n ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT small , large = + 2147483647 , + 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] <= small : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif arr [ i ] <= large : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == n : NEW_LINE INDENT print ( " No ▁ such ▁ triplet ▁ found " ) NEW_LINE return NEW_LINE DEDENT for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ j ] < large : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small , large , arr [ i ] ) NEW_LINE return NEW_LINE def main ( arg ) : NEW_LINE INDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE return find3numbers ( arr , n ) NEW_LINE DEDENT DEDENT
def test_numbers_with_3_divisors ( n ) : NEW_LINE INDENT import sympy NEW_LINE from sympy . utilities . iterables import variations NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( 2 , n ** 2 + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT print ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : " ) NEW_LINE for i in range ( 0 , n ** 2 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT print ( i * i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def find_pair_count ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE rem = [ N // K ] NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem . append ( ( N - i ) // K + 1 ) NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT count += ( rem [ K // 2 ] * ( rem [ K // 2 ] - 1 ) ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def import time NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . m = 0 , 0 NEW_LINE DEDENT def __getitem__ ( self , x ) : NEW_LINE INDENT self . n , self . m = x NEW_LINE DEDENT def __getitem__ ( self , x ) : NEW_LINE INDENT self . n , self . m = x NEW_LINE DEDENT def __setitem__ ( self , x , 0 ) : NEW_LINE INDENT self . n , self . m = x NEW_LINE DEDENT def __getitem__ ( self , x ) : NEW_LINE INDENT self . n , self . m = x NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return iter ( self ) NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return iter ( self ) NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return iter ( self ) NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return iter ( self ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE from itertools import chain NEW_LINE from itertools import chain NEW_LINE n = randint ( 1 , 10000 ) NEW_LINE a = chain ( chain ( [ 0 ] , [ 1 ] ) , chain ( [ 0 ] , [ 1 ] ) ) NEW_LINE print ( ' YES ' if solve ( a ) else ' NO ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT PHI = 1.6180339 NEW_LINE f = [ 0 , 1 , 1 , 2 , 3 , 5 ] NEW_LINE def fib ( n ) : NEW_LINE INDENT if n < 6 : return f [ n ] NEW_LINE t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = int ( round ( fn * PHI ) ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 9 NEW_LINE print ( n , ' th ▁ Fibonacci ▁ Number ▁ = ▁ ' , fib ( n ) ) NEW_LINE DEDENT DEDENT
def GFG ( n , k ) : return ( 2 ** k ) . sum ( ) NEW_LINE def main ( args ) : NEW_LINE INDENT n , k = 8 , 4 NEW_LINE print ( kth_smallest ( n , k ) , end = ' ▁ ' ) NEW_LINE DEDENT
def import _pylab NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , mat , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return NEW_LINE DEDENT strip_sum = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT strip_sum [ 0 ] . append ( sum ) NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) NEW_LINE strip_sum [ i ] . append ( sum ) NEW_LINE DEDENT DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT sum += strip_sum [ i ] [ j ] NEW_LINE DEDENT print ( sum , end = ' ▁ ' ) NEW_LINE for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum += ( strip_sum [ i ] [ j + k - 1 ] - strip_sum [ i ] [ j - 1 ] ) NEW_LINE print ( sum , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] , ] NEW_LINE k = 3 NEW_LINE self . printSumTricky ( mat , k ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from math import pow NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE A = sin ( A ) NEW_LINE B = sin ( B ) NEW_LINE N = sin ( A ) NEW_LINE bigA = pow ( A , N ) NEW_LINE bigB = pow ( B , N ) NEW_LINE for x in range ( - 1000 , 1000 + 1 ) : NEW_LINE INDENT if pow ( x , N ) * bigA == bigB : NEW_LINE INDENT print ( x ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT
def ncr ( n , r ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def ncr ( self , n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 , 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE ans /= i NEW_LINE DEDENT return ans NEW_LINE DEDENT def total_ways ( self , X , Y , M , W ) : NEW_LINE INDENT return ( ncr ( M , X ) * ncr ( W , Y ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT X , Y , M , W = [ 4 , 3 , 6 , 5 ] NEW_LINE print ( total_ways ( X , Y , M , W ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if n != 0 and ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE def removeElement ( n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = nextPowerOf2 ( n ) NEW_LINE if n == a or n == a - 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n == a - 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 5 NEW_LINE print ( removeElement ( n ) ) NEW_LINE DEDENT DEDENT
def Choose ( n , k ) : NEW_LINE INDENT from random import randint NEW_LINE class NumTh : NEW_LINE INDENT def __init__ ( self , n , k ) : NEW_LINE INDENT self . n = n NEW_LINE self . k = k NEW_LINE DEDENT def Choose ( self , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n , n - k + 1 , - 1 ) : NEW_LINE INDENT res *= i NEW_LINE self . k /= k - n + i NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT class Main ( NumTh ) : NEW_LINE INDENT def Choose ( self , n ) : NEW_LINE INDENT sc = randint ( 1 , N ) NEW_LINE N , P = sc . randint ( 1 , P ) NEW_LINE Even , Odd = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A = sc . randint ( 1 , N ) NEW_LINE if A % 2 == 0 : NEW_LINE INDENT Even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Odd += 1 NEW_LINE DEDENT DEDENT if Odd == 0 : NEW_LINE INDENT if P == 0 : NEW_LINE INDENT print ( long ( 1 ) << Even ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( long ( 1 ) << long ( N - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from sympy . utilities . iterables import iterables NEW_LINE class GFG ( object ) : NEW_LINE INDENT def modinverse ( self , a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in iterables ( 1 , m ) : NEW_LINE INDENT if ( a * x ) % m == 1 : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT a , m = 3 , 11 NEW_LINE print ( self . modinverse ( a , m ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def GFG ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += x % 10 NEW_LINE x = x / 10 NEW_LINE DEDENT return sum NEW_LINE def count_numbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if i % 2 == 0 and sum_of_digits ( i ) % 3 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT l , r = 1000 , 6000 NEW_LINE print ( count_numbers ( l , r ) ) NEW_LINE DEDENT DEDENT
def find_greater ( a , b ) : NEW_LINE INDENT x = float ( a ) * float ( math . log ( float ( b ) ) ) NEW_LINE y = float ( b ) * float ( math . log ( float ( a ) ) ) NEW_LINE if y > x : NEW_LINE INDENT print ( " a ^ b ▁ is ▁ greater " ) NEW_LINE DEDENT elif y < x : NEW_LINE INDENT print ( " b ^ a ▁ is ▁ greater " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Both ▁ are ▁ equal " ) NEW_LINE DEDENT DEDENT
def test_find_answer ( ) : NEW_LINE INDENT import re NEW_LINE from math import ceil NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from scipy . sparse import csc_matrix NEW_LINE with open ( ' / proc / stagensor / solution . txt ' , ' r ' ) as sc : NEW_LINE INDENT t = sc . read ( ) . split ( ) NEW_LINE str = [ ] NEW_LINE for z in range ( t ) : NEW_LINE INDENT n , x , m = csc_matrix ( n ) NEW_LINE arr = [ [ x , x ] for x in range ( m ) ] NEW_LINE si = x NEW_LINE ei = x NEW_LINE for l , r in zip ( arr , arr ) : NEW_LINE INDENT if ( l <= si and si <= r ) or ( l <= ei and ei <= r ) : NEW_LINE INDENT si = min ( l , si ) NEW_LINE ei = max ( r , ei ) NEW_LINE DEDENT DEDENT str . append ( ei - si + 1 ) NEW_LINE str . append ( ' ' ) NEW_LINE DEDENT print ( ' \n ' . join ( str ) ) NEW_LINE DEDENT DEDENT
def GFG ( n , l , r ) : NEW_LINE INDENT num , prev , curr = n >> ( l - 1 ) , num & 1 , num >> 1 NEW_LINE for i in range ( 1 , ( r - l ) + 1 ) : NEW_LINE INDENT curr = num & 1 NEW_LINE if curr == prev : return False NEW_LINE prev , num = curr , num >> 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def import import sys , os , sys NEW_LINE from os import urandom NEW_LINE from random import randint NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE from eugene import eugene NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def nth_group ( self , n ) : NEW_LINE INDENT return n * ( 2 ** int ( math . pow ( n , 2 ) ) + 1 ) NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def import import sys NEW_LINE class Ex711B ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = len ( sys . stdin . readline ( ) . split ( ) ) NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT self . magic_square = [ [ ] for _ in range ( self . n ) ] NEW_LINE row , column = - 1 , - 1 NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT for j in range ( self . n ) : NEW_LINE INDENT self . magic_square [ i ] [ j ] = self . stdin . readline ( ) . split ( ) [ 0 ] NEW_LINE if self . magic_square [ i ] [ j ] == 0 : NEW_LINE INDENT row , column = i , j NEW_LINE DEDENT DEDENT DEDENT if self . n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT if row != 0 : NEW_LINE INDENT sum += self . magic_square [ 0 ] [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += self . magic_square [ 1 ] [ i ] NEW_LINE DEDENT DEDENT answer = sum NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT answer -= self . magic_square [ row ] [ i ] NEW_LINE DEDENT self . magic_square [ row ] [ column ] = answer NEW_LINE m = 0 NEW_LINE current_sumi , current_sumj = 0 , 0 NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT for j in range ( self . n ) : NEW_LINE INDENT current_sumi += self . magic_square [ i ] [ j ] NEW_LINE current_sumj += self . magic_square [ j ] [ i ] NEW_LINE DEDENT if current_sumi != sum or current_sumj != sum : NEW_LINE INDENT m += 1 NEW_LINE DEDENT current_sumi , current_sumj = 0 , 0 NEW_LINE DEDENT for i in range ( self . n ) : NEW_LINE INDENT current_sumi += self . magic_square [ i ] [ i ] NEW_LINE current_sumj += self . magic_square [ n - i - 1 ] [ i ] NEW_LINE DEDENT if current_sumi != sum or current_sumj != sum : NEW_LINE INDENT m += 1 NEW_LINE DEDENT if self . m == 0 and answer : NEW_LINE INDENT self . print ( answer ) NEW_LINE DEDENT else : NEW_LINE INDENT self . print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import ceil NEW_LINE from math import sin , cos , pi NEW_LINE from os . path import join NEW_LINE from os import urandom NEW_LINE from random import randint NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 1000000 NEW_LINE DEDENT def maximum_occurred_element ( self , L , R , n ) : NEW_LINE INDENT arr = np . zeros ( self . MAX ) NEW_LINE maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ L [ i ] ] += 1 NEW_LINE arr [ R [ i ] + 1 ] -= 1 NEW_LINE if R [ i ] > maxi : NEW_LINE INDENT maxi = R [ i ] NEW_LINE DEDENT DEDENT msum = arr [ 0 ] NEW_LINE ind = 0 NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE if msum < arr [ i ] : NEW_LINE INDENT msum = arr [ i ] NEW_LINE ind = i NEW_LINE DEDENT DEDENT return ind NEW_LINE DEDENT DEDENT L = [ 1 , 4 , 9 , 13 , 21 ] NEW_LINE R = [ 15 , 8 , 12 , 20 , 30 ] NEW_LINE n = len ( L ) NEW_LINE print ( maximum_occurred_element ( L , R , n ) ) NEW_LINE DEDENT
def import _Rough_02 NEW_LINE class Rough_02 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( self . n ) NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT arr = _Rough_02 ( ) NEW_LINE count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] != arr [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class Solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT Scanner ( ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( self . n ) NEW_LINE self . m = int ( self . m ) NEW_LINE if self . n == 0 : NEW_LINE INDENT if self . m != 0 : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE DEDENT return NEW_LINE DEDENT if self . m <= self . n : NEW_LINE INDENT if self . m == 0 : NEW_LINE INDENT self . m = 1 NEW_LINE DEDENT print ( self . n , self . m + self . n - 1 , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT print ( self . m , self . n + self . n - 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def _import ( ) : return ( 1 / ( 1 + x ** 2 ) ) NEW_LINE def calculate ( lower_limit , upper_limit , interval_limit ) : NEW_LINE INDENT global value NEW_LINE interval_size = ( upper_limit - lower_limit ) / interval_limit NEW_LINE sum = func ( lower_limit ) + func ( upper_limit ) NEW_LINE for i in range ( 1 , interval_limit ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT sum = sum + 2 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + 3 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT DEDENT return ( 3 * interval_size / 8 ) * sum NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def run ( self ) : NEW_LINE INDENT with open ( " . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . / . . / . / . / . . / . / . / . / . . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / .
def main ( ) : NEW_LINE INDENT import math NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = sc NEW_LINE DEDENT def __call__ ( self , x , h ) : NEW_LINE INDENT if not x and not h : NEW_LINE INDENT break NEW_LINE DEDENT c = math . sqrt ( h ** 2 + ( x / 2 ) ** 2 ) NEW_LINE ans = x ** 2 + x * c / 2 ** 4 NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT DEDENT
def count ( num ) : NEW_LINE INDENT from itertools import count NEW_LINE sum = 0 NEW_LINE while num > 0 : NEW_LINE INDENT sum += num % 10 NEW_LINE num = num / 10 NEW_LINE DEDENT return sum NEW_LINE def main ( ) : NEW_LINE INDENT with open ( ' / proc / cpuinfo ' , ' r ' ) as infile : NEW_LINE INDENT k , i , mo = 1 , 19 NEW_LINE k = infile . read ( ) NEW_LINE while i != k : NEW_LINE INDENT mo += 1 NEW_LINE if 10 == count ( mo ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( mo ) NEW_LINE DEDENT DEDENT return main NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import random NEW_LINE from math import sin , cos , pow NEW_LINE from math import sin , cos , pow NEW_LINE from math import cos , sin , pow NEW_LINE from math import sin , cos , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow NEW_LINE from math import sin , cos , sin , pow , pow NEW_LINE from math import sin , cos , sin , pow , pow NEW_LINE from math import sin , cos , sin , pow , sin , pow , pow NEW_LINE from math import sin , cos , sin , pow , sin , pow , pow NEW_LINE from math import sin , cos , sin , pow , sin , pow , pow , sin , pow , pow , sin , pow , sin , pow , pow , sin , pow , sin , pow , sin , pow , sin , pow , sin , pow , sin , pow , sin , pow , sin , pow , sin , pow , sin , pow , sin , pow , sin , pow , sin , sin , pow , sin , sin , pow , sin , pow , sin , sin , pow , sin , sin , pow , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , )
def GFG ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 0 , m ) ] for j in range ( 0 , n ) ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if x [ j - 1 ] == y [ i - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def test_find_sum_of_squares ( n , a , b ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_sum ( self , n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % a == 0 or i % b == 0 : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n , a , b = 10 , 3 , 5 NEW_LINE print ( find_sum ( n , a , b ) ) NEW_LINE DEDENT return GFG ( n , a , b ) NEW_LINE DEDENT
def import import sys , string , tanyaandpostcard NEW_LINE def main ( args ) : NEW_LINE INDENT with open ( ' tanyaandpostcard . txt ' , ' r ' ) as infile : NEW_LINE INDENT s1 = infile . read ( ) NEW_LINE s2 = infile . read ( ) NEW_LINE DEDENT a = [ 0 ] * 123 NEW_LINE b = [ 0 ] * len ( s1 ) NEW_LINE i , y , w = 0 , 0 NEW_LINE for ch in s2 : NEW_LINE INDENT a [ ch ] += 1 NEW_LINE DEDENT for ch in s1 : NEW_LINE INDENT if a [ ch ] >= 1 : NEW_LINE INDENT a [ ch ] -= 1 NEW_LINE b [ ch ] = 1 NEW_LINE y += 1 NEW_LINE DEDENT DEDENT for ch in s1 : NEW_LINE INDENT if b [ ch ] == 0 : NEW_LINE INDENT if ch <= 90 : NEW_LINE INDENT ch = chr ( ord ( ch ) + 32 ) NEW_LINE DEDENT else : NEW_LINE INDENT ch = chr ( ord ( ch ) - 32 ) NEW_LINE DEDENT if a [ ch ] >= 1 : NEW_LINE INDENT a [ ch ] -= 1 NEW_LINE w += 1 NEW_LINE DEDENT DEDENT DEDENT print ( y , w ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT global MAX NEW_LINE global sequence NEW_LINE global vanEckSequence NEW_LINE for i in range ( MAX - 1 ) : NEW_LINE INDENT sequence . append ( 0 ) NEW_LINE DEDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if sequence [ j ] == sequence [ i ] : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT vanEckSequence ( ) NEW_LINE n = 6 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 100000 NEW_LINE sequence = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence . append ( 0 ) NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if sequence [ j ] == sequence [ i ] : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT count = 1 NEW_LINE i = n - 1 NEW_LINE while sequence [ i + 1 ] != 0 : NEW_LINE INDENT count += 1 NEW_LINE i = i - sequence [ i + 1 ] NEW_LINE DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT vanEckSequence ( ) NEW_LINE n = 5 NEW_LINE print ( getCount ( n ) ) NEW_LINE n = 11 NEW_LINE print ( getCount ( n ) ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 100000 NEW_LINE sequence = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence . append ( 0 ) NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if sequence [ j ] == sequence [ i ] : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT nthTerm = sequence [ n - 1 ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if sequence [ i ] == nthTerm : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT vanEckSequence ( ) NEW_LINE n = 5 NEW_LINE print ( getCount ( n ) ) NEW_LINE n = 11 NEW_LINE print ( getCount ( n ) ) NEW_LINE DEDENT DEDENT
def __gcd ( a , b ) : NEW_LINE INDENT import math NEW_LINE if not a or not b : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def nth_element ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) / __gcd ( a , b ) NEW_LINE l , r = 1 , min ( a , b ) * n NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE val = mid // a + mid // b - mid // lcm NEW_LINE if val == n : NEW_LINE INDENT return max ( ( mid // a ) ** a , ( mid // b ) ** b ) NEW_LINE DEDENT if val < n : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , b , n = 5 , 3 , 5 NEW_LINE print ( nth_element ( a , b , n ) ) NEW_LINE DEDENT
def import datetime NEW_LINE import time NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . year = time . localtime ( time . time ( ) ) NEW_LINE self . month = time . localtime ( time . time ( ) ) [ 0 ] NEW_LINE self . day = time . localtime ( time . time ( ) ) [ 0 ] NEW_LINE self . leap = self . check_leap ( self . year ) NEW_LINE self . sum = 0 NEW_LINE self . mod = 0 NEW_LINE for i in range ( self . year + 1 ) : NEW_LINE INDENT if self . check_leap ( i ) : NEW_LINE INDENT self . sum += 366 NEW_LINE DEDENT else : NEW_LINE INDENT self . sum += 365 NEW_LINE DEDENT if self . sum % 7 == 0 : NEW_LINE INDENT if ( self . check_leap ( i ) and self . leap ) or ( not self . check_leap ( i ) and not self . leap ) : NEW_LINE INDENT print ( i ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT DEDENT def check_leap ( self ) : NEW_LINE INDENT return self . year % 400 == 0 or ( self . year % 4 == 0 and self . year % 100 != 0 ) NEW_LINE DEDENT DEDENT
def _ import _ , ▁ sys . stdout , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stdout , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr ,
def GFG ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : return 0 NEW_LINE if a == b : return a NEW_LINE if a > b : return __gcd ( a - b , b ) NEW_LINE return __gcd ( a , b - a ) NEW_LINE def findValue ( x , y , z ) : NEW_LINE INDENT g = __gcd ( y , z ) NEW_LINE return ( x * g ) / __gcd ( x , g ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x , y , z = 30 , 40 , 400 NEW_LINE print ( findValue ( x , y , z ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def foot ( arr ) : NEW_LINE INDENT import math NEW_LINE import numpy as np NEW_LINE class solution : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = 1 NEW_LINE self . b = - 2 NEW_LINE self . c = 0 NEW_LINE self . d = 0 NEW_LINE self . x1 = - 1 NEW_LINE self . y1 = 3 NEW_LINE self . z1 = 4 NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' % s ▁ % s ▁ % s ' % ( self . a , self . b , self . c , self . d ) NEW_LINE DEDENT DEDENT def foot ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / float ( a * a + b * b + c * c ) NEW_LINE x2 = a * k + x1 NEW_LINE y2 = b * k + y1 NEW_LINE z2 = c * k + z1 NEW_LINE print ( ' x2 ▁ = ▁ ' , ' % . 1 . f ' % x2 , end = ' ▁ ' ) NEW_LINE print ( ' ▁ y2 ▁ = ▁ ' , ' % . 1 . f ' % y2 , end = ' ▁ ' ) NEW_LINE print ( ' ▁ z2 ▁ = ▁ ' , ' % . 1 . f ' % z2 , end = ' ▁ ' ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a = 1 NEW_LINE b = - 2 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE x1 = - 1 NEW_LINE y1 = 3 NEW_LINE z1 = 4 NEW_LINE return solution ( a , b , c , d , x1 , y1 , z1 ) NEW_LINE DEDENT return NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = sys . stdin NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return sys . stdin . readline ( ) . strip ( ) NEW_LINE DEDENT DEDENT c1 = Main ( ) NEW_LINE c2 = Main ( ) NEW_LINE if c1 [ 0 ] == c2 [ - 1 ] and c2 [ 0 ] == c1 [ - 1 ] and c1 [ 1 ] == c2 [ 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def get_minimum_ops ( ar ) : NEW_LINE INDENT import numpy as np NEW_LINE from numpy . linalg import norm NEW_LINE n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE large = max ( ar ) NEW_LINE dp = [ [ abs ( ar [ 0 ] - j ) for j in range ( small , large + 1 ) ] for i in range ( small , large + 1 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minimum = np . inf NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = np . inf NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def test_area_leaf ( ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . AreaLeaf ) : NEW_LINE INDENT PI = 3.14159265 NEW_LINE def area_leaf ( self , a ) : NEW_LINE INDENT return ( a ** 2 * ( self . PI / 2 - 1 ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT a = 7 NEW_LINE print ( area_leaf ( a ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def _multi_alternates ( n ) : NEW_LINE INDENT from itertools import repeat NEW_LINE class Circular ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def remove ( self ) : NEW_LINE INDENT if self . n == 1 : return 1 NEW_LINE if self . n % 2 == 0 : return 2 * self . remove_alternates ( self . n // 2 ) - 1 NEW_LINE else : return 2 * self . remove_alternates ( ( ( self . n - 1 ) // 2 ) ) + 1 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 5 NEW_LINE print ( remove_alternates ( n ) , end = " " ) NEW_LINE n = 10 NEW_LINE print ( " \n " , remove_alternates ( n ) , end = " " ) NEW_LINE DEDENT DEDENT
def check ( n , m ) : NEW_LINE INDENT import sys NEW_LINE if n == 2 or m == 2 or n % m == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def import import os , sys , stdin , stdout , color , check , color , count , color , color , colorThePicture NEW_LINE class ColorThePicture ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdin = stdin NEW_LINE self . stdout = stdout NEW_LINE self . t = int ( stdin . readline ( ) ) NEW_LINE while t != 0 : NEW_LINE INDENT solve ( self . stdin , self . stdout ) NEW_LINE t -= 1 NEW_LINE DEDENT self . stdout . flush ( ) NEW_LINE self . stderr . close ( ) NEW_LINE DEDENT def solve ( self , f , pr ) : NEW_LINE INDENT temp = f . readline ( ) . split ( ) NEW_LINE m , n , k = [ int ( i ) for i in temp ] NEW_LINE sum = 0 NEW_LINE colors = [ ] NEW_LINE temp = f . readline ( ) . split ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT colors . append ( int ( temp [ i ] ) ) NEW_LINE sum += colors [ i ] NEW_LINE DEDENT flag = check ( m , n , colors ) or check ( n , m , colors ) NEW_LINE pr . write ( ' Yes ' if flag else ' No \n ' ) NEW_LINE DEDENT def check ( self , m , n , colors ) : NEW_LINE INDENT count = 0 NEW_LINE colors = set ( ) NEW_LINE for i in colors : NEW_LINE INDENT max = i // m NEW_LINE if max >= 2 : NEW_LINE INDENT count += max NEW_LINE colors . add ( max ) NEW_LINE DEDENT DEDENT if count < n : NEW_LINE INDENT return False NEW_LINE DEDENT if len ( colors ) >= 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( colors ) == 1 : NEW_LINE INDENT if color in colors : NEW_LINE INDENT return True if n % 2 == 0 else False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT positive , negative = 1 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if arr [ i ] == 1 : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT positive , negative = 1 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if arr [ i ] == 1 : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE def pos_prod_sub_arr ( arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) / 2 NEW_LINE cntneg = neg_prod_sub_arr ( arr , n ) NEW_LINE return ( total - cntneg ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pos_prod_sub_arr ( arr , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import java . io . BufferedReader , StringIO , ConfigParser NEW_LINE from io import StringIO , ConfigParser NEW_LINE class CF3 : NEW_LINE INDENT class FastReader ( object ) : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT while not isinstance ( self , str ) or not hasattr ( self , " readline " ) : NEW_LINE INDENT try : NEW_LINE INDENT self . readline ( ) NEW_LINE DEDENT except ConfigParser . NoOptionError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return StringIO ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not isinstance ( self , str ) or not hasattr ( self , " readline " ) : NEW_LINE INDENT try : NEW_LINE INDENT self . readline ( ) NEW_LINE DEDENT except ConfigParser . NoOptionError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return self . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not isinstance ( self , str ) or hasattr ( self , " readline " ) : NEW_LINE INDENT try : NEW_LINE INDENT self . readline ( ) NEW_LINE DEDENT except ConfigParser . NoOptionError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT DEDENT def readfp ( self ) : NEW_LINE INDENT return StringIO ( ) NEW_LINE DEDENT def write ( self , fp ) : NEW_LINE INDENT if not hasattr ( fp , " readline " ) : NEW_LINE INDENT fp = StringIO ( ) NEW_LINE DEDENT for line in fp : NEW_LINE INDENT if not line . strip ( ) : NEW_LINE INDENT fp . write ( line ) NEW_LINE DEDENT DEDENT DEDENT read = [ ] NEW_LINE while 1 : NEW_LINE INDENT n , k = readfp ( self ) NEW_LINE cur = 0 , 1 NEW_LINE while cur < k : NEW_LINE INDENT cur *= 2 NEW_LINE cur += 1 NEW_LINE DEDENT if cur < n : NEW_LINE INDENT cur += ( n - cur + k - 1 ) / k NEW_LINE DEDENT write ( self , fp ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import gcd NEW_LINE from os import environ NEW_LINE f = open ( ' / proc / self / loops / ' , ' r ' ) NEW_LINE z = f . read ( ) . split ( ) NEW_LINE x , y , a , b = map ( int , z [ 0 ] . split ( ) ) NEW_LINE c , i , j = 0 , 0 , 0 NEW_LINE lcm = x * y / gcd ( x , y ) NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if i % lcm == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( b , a - 1 , - 1 ) : NEW_LINE INDENT if j % lcm == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j % lcm == 0 and i % lcm == 0 : NEW_LINE INDENT c = ( j - i ) / lcm + 1 NEW_LINE DEDENT print ( c ) NEW_LINE f . close ( ) NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT temp = a NEW_LINE if a < b : NEW_LINE INDENT a , b = b , temp NEW_LINE DEDENT if a % b == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 1 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return n - len ( LIS ) NEW_LINE DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def print_max ( self , a , n , k ) : NEW_LINE INDENT max_upto = [ 0 ] * n NEW_LINE s = [ 0 ] NEW_LINE s . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while not s . empty ( ) and a [ s [ - 1 ] ] < a [ i ] : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = i - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT while not s . empty ( ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = n - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 0 , n - k ) : NEW_LINE INDENT while j < i or max_upto [ j ] < i + k - 1 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print ( a [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a = [ 9 , 7 , 2 , 4 , 6 , 8 , 2 , 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE return GFG ( a , n , k ) NEW_LINE DEDENT DEDENT
def test_p056 ( ) : NEW_LINE INDENT from sympy . core . compatibility import builtins NEW_LINE print ( builtins . eval ( ' p056' ) ) NEW_LINE def run ( ) : NEW_LINE INDENT max = 0 NEW_LINE for a in range ( 1 , 100 ) : NEW_LINE INDENT for b in range ( 1 , 100 ) : NEW_LINE INDENT pow = builtins . eval ( ' a ' ) ** b NEW_LINE max = max ( digital_sum ( pow ) , max ) NEW_LINE DEDENT DEDENT return str ( max ) NEW_LINE DEDENT def digital_sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE s = str ( n ) NEW_LINE for c in s : NEW_LINE INDENT sum += c - '0' NEW_LINE DEDENT return sum NEW_LINE DEDENT builtins . eval ( ' p056' ) NEW_LINE DEDENT
def countWindowDistinct ( win , k ) : NEW_LINE INDENT import numpy NEW_LINE dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if win [ i ] == win [ j ] : break NEW_LINE if j == i : dist_count += 1 NEW_LINE DEDENT DEDENT return dist_count NEW_LINE def countDistinct ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n - k ) : NEW_LINE INDENT print ( countWindowDistinct ( arr [ i : ] , k ) ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr , k = [ 1 , 2 , 1 , 3 , 4 , 2 , 3 ] , 4 NEW_LINE countDistinct ( arr , len ( arr ) , k ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def gf_gcd ( x ) : NEW_LINE INDENT x = x . replace ( ' . ' , ' ' ) NEW_LINE count = 0 NEW_LINE for i , temp in enumerate ( x ) : NEW_LINE INDENT if temp % 2 == 0 : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def solution ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if index == n : NEW_LINE INDENT if cnt == k : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if dp [ index ] [ cnt ] != - 1 : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE return dp [ index ] [ cnt ] = ans NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . factorial ) : NEW_LINE INDENT def Sum ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , math . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + ( n / i ) NEW_LINE DEDENT DEDENT DEDENT return sum - n NEW_LINE DEDENT def PrintAliquot ( self , n ) : NEW_LINE INDENT print ( " % d ▁ " % n , end = ' ▁ ' ) NEW_LINE s = sorted ( [ n ] ) NEW_LINE next = 0 NEW_LINE while n : NEW_LINE INDENT n = _SUM ( n ) NEW_LINE if n in s and n != s [ - 1 ] : NEW_LINE INDENT print ( " \n Repeats ▁ with ▁ % d " % n , end = ' ▁ ' ) NEW_LINE break NEW_LINE DEDENT print ( n , end = ' ▁ ' ) NEW_LINE s . append ( n ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT PrintAliquot ( 12 ) NEW_LINE DEDENT DEDENT
def import _readline NEW_LINE import os NEW_LINE import sys NEW_LINE import os NEW_LINE import getopt NEW_LINE class PashaAndHamsters ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdin = sys . stdin NEW_LINE self . stdout = sys . stdout NEW_LINE self . dimensions = self . dimensions [ 0 ] . split ( ) NEW_LINE self . total = int ( self . dimensions [ 0 ] ) NEW_LINE self . at = int ( self . dimensions [ 1 ] ) NEW_LINE self . pt = int ( self . dimensions [ 2 ] ) NEW_LINE self . vals = [ ] NEW_LINE as = self . stdin . readline ( ) . split ( ) NEW_LINE for i in range ( len ( as ) ) : NEW_LINE INDENT x = int ( as [ i ] ) NEW_LINE self . vals . append ( True ) NEW_LINE DEDENT s = ' ' NEW_LINE for i in range ( self . total ) : NEW_LINE INDENT s += ( '1' if self . vals [ i ] else '2' ) + ' ▁ ' NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def reverse ( self , n ) : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT self . swap ( self , i , ( n + ~ i + 1 ) + ~ 1 + 1 ) NEW_LINE DEDENT DEDENT def swap ( self , arr , i , j ) : NEW_LINE INDENT temp = self . arr [ i ] NEW_LINE self . arr [ i ] = self . arr [ j ] NEW_LINE self . arr [ j ] = temp NEW_LINE return self . arr [ i ] NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE self . reverse ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE a = 1 NEW_LINE cnt = 0 NEW_LINE flag = True NEW_LINE sum += a NEW_LINE while cnt < N : NEW_LINE INDENT if flag == True : NEW_LINE INDENT nextElement = a * 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * 3 / 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT a = nextElement NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from time import sleep NEW_LINE with open ( ' / proc / stdin ' , ' r ' ) as f : NEW_LINE INDENT lines = f . readlines ( ) NEW_LINE DEDENT T = len ( lines ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT h , w = lines [ i ] . split ( ) NEW_LINE gcd = gcd ( h , w ) NEW_LINE h /= gcd NEW_LINE w /= gcd NEW_LINE if h == w : NEW_LINE INDENT print ( '1 ▁ 0' ) NEW_LINE DEDENT elif h % 2 == 0 or w % 2 == 0 : NEW_LINE INDENT print ( '1 ▁ 1' ) NEW_LINE DEDENT else : NEW_LINE INDENT a , b = h , w NEW_LINE a = ( h * w ) / 2 + 1 NEW_LINE b = ( h * w ) / 2 NEW_LINE print ( a , b ) NEW_LINE DEDENT DEDENT def gcd ( a , b ) : NEW_LINE INDENT if not b : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT return gcd ( a , b ) NEW_LINE DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sz = int ( 1e5 ) NEW_LINE self . isPrime = [ True ] * ( sz + 1 ) NEW_LINE DEDENT def sieve ( self ) : NEW_LINE INDENT [ isPrime ] = True NEW_LINE self . isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , self . sz + 1 ) : NEW_LINE INDENT if self . isPrime [ i ] : NEW_LINE INDENT for j in range ( i * i , self . sz + 1 , i ) : NEW_LINE INDENT self . isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def minDifference ( self , L , R ) : NEW_LINE INDENT fst = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if self . isPrime [ i ] : NEW_LINE INDENT fst = i NEW_LINE break NEW_LINE DEDENT DEDENT snd = 0 NEW_LINE for i in range ( fst + 1 , R + 1 ) : NEW_LINE INDENT if self . isPrime [ i ] : NEW_LINE INDENT snd = i NEW_LINE break NEW_LINE DEDENT DEDENT if not snd : NEW_LINE INDENT return - 1 NEW_LINE DEDENT diff = snd - fst NEW_LINE left = snd + 1 NEW_LINE right = R NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT if self . isPrime [ i ] : NEW_LINE INDENT if i - snd <= diff : NEW_LINE INDENT fst , snd = snd , i NEW_LINE diff = snd - fst NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . sieve ( ) NEW_LINE L , R = 21 , 50 NEW_LINE print ( minDifference ( L , R ) ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE pre_cnt = 0 NEW_LINE while start < n and arr [ start ] == 1 : NEW_LINE INDENT pre_cnt += 1 NEW_LINE start += 1 NEW_LINE DEDENT end = n - 1 NEW_LINE suff_cnt = 0 NEW_LINE while end >= 0 and arr [ end ] == 1 : NEW_LINE INDENT suff_cnt += 1 NEW_LINE end -= 1 NEW_LINE DEDENT if start > end : NEW_LINE INDENT return n NEW_LINE DEDENT mid_cnt = 0 NEW_LINE result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT mid_cnt += 1 NEW_LINE result = max ( result , mid_cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT mid_cnt = 0 NEW_LINE DEDENT DEDENT return max ( result , pre_cnt + suff_cnt ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE s = sys . stdin NEW_LINE d = randint ( 1 , 10000 ) NEW_LINE n = randint ( 1 , 10000 ) NEW_LINE temp = [ randint ( 1 , 10000 ) for i in range ( d ) ] NEW_LINE a = [ randint ( 1 , 10000 ) for i in range ( n ) ] NEW_LINE b = [ randint ( 1 , 10000 ) for i in range ( n ) ] NEW_LINE c = [ randint ( 1 , 10000 ) for i in range ( n ) ] NEW_LINE dp = [ [ - 1 ] for i in range ( d ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= temp [ 0 ] and b [ i ] >= temp [ 0 ] : NEW_LINE INDENT dp [ 0 ] [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , d ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ j ] <= temp [ i ] and b [ j ] >= temp [ i ] : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if dp [ i - 1 ] [ k ] < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( c [ j ] - c [ k ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , dp [ d - 1 ] [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def import import * NEW_LINE import sys NEW_LINE import string NEW_LINE import math NEW_LINE class Main ( object ) : NEW_LINE INDENT def mod ( self ) : NEW_LINE INDENT return int ( 1e9 + 7 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT with open ( " / dev / null " , " w " ) as f : NEW_LINE INDENT n = len ( self . args ) NEW_LINE i1 , i2 = 0 , 0 NEW_LINE s = self . args [ 0 ] NEW_LINE flag = True NEW_LINE ch = s . split ( ) NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ch [ i ] > ch [ i + 1 ] : NEW_LINE INDENT i1 = i + 1 NEW_LINE i2 = i + 2 NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT f . write ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT f . write ( " YES " ) NEW_LINE f . write ( " % d ▁ % d \n " % ( i1 , i2 ) ) NEW_LINE DEDENT DEDENT DEDENT def debug ( * obj ) : NEW_LINE INDENT sys . stderr . write ( " " . join ( obj ) + " \n " ) NEW_LINE DEDENT DEDENT
def GFG ( s ) : NEW_LINE INDENT pSq = 0 NEW_LINE N = 0 NEW_LINE for i in range ( int ( s ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT pSq = i NEW_LINE N = j NEW_LINE break NEW_LINE DEDENT DEDENT if pSq > 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT d = s - pSq NEW_LINE P = d / ( 2. * N ) NEW_LINE A = N + P NEW_LINE sqrt_of_s = A - ( ( P * P ) / ( 2. * A ) ) NEW_LINE return sqrt_of_s NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 1 NEW_LINE DEDENT def go ( self ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT n = int ( self . n ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE s = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( self . n ) NEW_LINE b . append ( 0 ) NEW_LINE DEDENT tem = 1 NEW_LINE q = 0 NEW_LINE while q != n : NEW_LINE INDENT s += 1 NEW_LINE if tem == 1 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= q and b [ i ] == 0 : NEW_LINE INDENT b [ i ] = 1 NEW_LINE q += 1 NEW_LINE DEDENT DEDENT tem = 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] <= q and b [ i ] == 0 : NEW_LINE INDENT b [ i ] = 1 NEW_LINE q += 1 NEW_LINE DEDENT DEDENT tem = 1 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT DEDENT DEDENT
def import math NEW_LINE class Main ( ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . INF = 100.0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE while True : NEW_LINE INDENT r , n = select . select ( [ ] , [ ] , [ ] ) NEW_LINE if r == 0 : NEW_LINE INDENT break NEW_LINE DEDENT field = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT xl , xr , h = select . select ( [ ] , [ ] , [ ] ) NEW_LINE for j in range ( xl + 20 , xr + 20 ) : NEW_LINE INDENT field . append ( max ( field [ j ] , h ) ) NEW_LINE DEDENT DEDENT min_time = INF NEW_LINE for i in range ( len ( field ) ) : NEW_LINE INDENT min_time = min ( min_time , cross_time ( i - 20 , field [ i ] , r ) ) NEW_LINE min_time = min ( min_time , cross_time ( i + 1 - 20 , field [ i ] , r ) ) NEW_LINE DEDENT print ( min_time ) NEW_LINE DEDENT DEDENT def cross_time ( x , y , r ) : NEW_LINE INDENT d = int ( math . pow ( - 2 * ( y + r ) , 2 ) - 4 * ( x ** 2 + y ** 2 + 2 * y ** 2 ) ) NEW_LINE if d <= 0 : NEW_LINE INDENT return INF NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( 2 * ( y + r ) - math . sqrt ( d ) ) / 2 NEW_LINE return ans NEW_LINE DEDENT DEDENT def print_height ( self ) : NEW_LINE INDENT for i in range ( len ( field ) ) : NEW_LINE INDENT print ( " % d - % d : ▁ % s " % ( ( i - 20 ) + 1 , field [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . t = sys . maxint NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . maxint NEW_LINE DEDENT def find ( lst ) : NEW_LINE INDENT lst . sort ( ) NEW_LINE n = len ( lst ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if lst [ i ] <= i + 1 : NEW_LINE INDENT print ( i + 2 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( 1 ) NEW_LINE DEDENT DEDENT
def import _solve NEW_LINE class Main ( object ) : NEW_LINE INDENT def read ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT DEDENT def read ( self ) : NEW_LINE INDENT if self . num == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT table = [ 0 , 1 , 2 , 3 , 5 , 7 , 8 , 9 ] NEW_LINE s = str ( num ) NEW_LINE for char in s : NEW_LINE INDENT num2 = int ( ' % s ' % char , 8 ) NEW_LINE print ( table [ num2 ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ ] NEW_LINE inc = [ ] NEW_LINE dec . append ( inc [ 0 ] ) NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif arr [ j ] < arr [ i ] and flag == 1 : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT result = sum ( [ i for i in range ( n ) if i < inc [ i ] ] ) NEW_LINE if result < dec [ i ] : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def import _struct NEW_LINE class GFG ( _struct ) : NEW_LINE INDENT def generate_arr ( self , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = self . arr [ 0 ] NEW_LINE self . arr [ 0 ] = self . arr [ 0 ] & self . arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = self . arr [ i ] NEW_LINE self . arr [ i ] = self . prev & self . arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT self . arr [ n - 1 ] = self . prev & self . arr [ n - 1 ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( self . arr ) NEW_LINE gen_arr ( self , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( self . arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def _ReplaceElements ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE _ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sys . stdout . write ( arr [ i ] + " ▁ " ) NEW_LINE DEDENT DEDENT return main NEW_LINE DEDENT
def _ReplaceElements ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev + arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev + arr [ n - 1 ] NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sys . stdout . write ( arr [ i ] + " ▁ " ) NEW_LINE DEDENT DEDENT return main NEW_LINE DEDENT
def count_triplets ( A , B , C ) : NEW_LINE INDENT from math import factorial NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if i * k > j * j : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT MAX = 100000 NEW_LINE prime = [ False ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( self ) : NEW_LINE INDENT for i in range ( self . MAX + 1 ) : NEW_LINE INDENT self . prime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , self . MAX + 1 ) : NEW_LINE INDENT if self . prime [ p ] == True : NEW_LINE INDENT for i in range ( self . p ** 2 , self . MAX + 1 , p ) : NEW_LINE INDENT self . prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def smallestPrime ( self , d ) : NEW_LINE INDENT l = int ( random . randint ( 10 , d - 1 ) ) NEW_LINE r = int ( random . randint ( 10 , d ) ) - 1 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if self . prime [ i ] : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def largestPrime ( self , d ) : NEW_LINE INDENT l = int ( random . randint ( 10 , d - 1 ) ) NEW_LINE r = int ( random . randint ( 10 , d ) ) - 1 NEW_LINE for i in range ( r , l - 1 , - 1 ) : NEW_LINE INDENT if self . prime [ i ] : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE queries = [ 2 , 5 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( smallestPrime ( queries [ i ] ) , largestPrime ( queries [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT
def import import sys NEW_LINE import string NEW_LINE import string NEW_LINE import sys NEW_LINE import math NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . out = sys . stdout NEW_LINE self . INF = int ( sys . maxint / 2 ) NEW_LINE DEDENT def readline ( ) : NEW_LINE INDENT f = open ( sys . argv [ 1 ] ) NEW_LINE for line in f . readlines ( ) : NEW_LINE INDENT line = line . split ( ) NEW_LINE n = int ( line [ 0 ] ) NEW_LINE m = int ( line [ 1 ] ) NEW_LINE tir = [ [ INF ] * n + [ 0 ] for i in range ( m + 1 ) ] NEW_LINE d = [ int ( i ) for i in line [ 1 : ] ] NEW_LINE c = [ int ( i ) for i in line [ 1 : ] ] NEW_LINE for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT tir [ i ] [ j ] = min ( tir [ i + 1 ] [ j ] , tir [ i + 1 ] [ j + 1 ] + d [ j ] * c [ i ] ) NEW_LINE DEDENT DEDENT f . write ( tir ) NEW_LINE f . flush ( ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import numpy NEW_LINE from numpy . testing . utils import get_filesystem_input NEW_LINE from numpy . testing . utils import get_filesystem_input NEW_LINE input = get_filesystem_input ( ) NEW_LINE n = input . shape [ 0 ] NEW_LINE k = input . shape [ 1 ] NEW_LINE x = input . shape [ 2 ] NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( input . read ( ) ) NEW_LINE DEDENT for i in range ( len ( arr ) - k , len ( arr ) ) : NEW_LINE INDENT arr [ i ] = x NEW_LINE DEDENT sum = 0 NEW_LINE for i in arr : NEW_LINE INDENT sum += i NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def import import math NEW_LINE class AutomaticDoor ( ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( math . ceil ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) NEW_LINE self . m = int ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . floor ( math . ceiling ( math . ceiling ( math . floor ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math . ceiling ( math ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) NEW_LINE DEDENT def __init__ ( ) NEW_LINE DEDENT class _App ( ) NEW_LINE class AutomaticDoor ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def swig_import_helper ( ) : NEW_LINE INDENT from os . path import dirname NEW_LINE import imp NEW_LINE fp = open ( ' / proc / net / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / pans / ns / pans / pans / ns / pans / ns / pans / ns / pans / ns / pans / ns / pans / ns / pans / ns / ns / pans / ns / ns / pans / ns / ns / pans / ns / ns / pans / ns / ns / pans / ns / ns / pans / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ns / ns / pans / ns / ' ) NEW_LINE _mod = imp NEW_LINE return
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = sys . stdin . read ( ) NEW_LINE self . ar = [ 0 ] * 26 NEW_LINE for ch in s : NEW_LINE INDENT self . ar [ ch - 97 ] += 1 NEW_LINE DEDENT cntod = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( self . ar [ i ] % 2 ) : NEW_LINE INDENT cntod += 1 NEW_LINE DEDENT DEDENT if not cntod : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT else : NEW_LINE INDENT if cntod % 2 == 0 : NEW_LINE INDENT print ( " Second " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import ceil NEW_LINE def reverse ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while n != 0 : NEW_LINE INDENT rev = ( rev * 10 ) + ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT def _Sum ( n ) : NEW_LINE INDENT n = reverse ( n ) NEW_LINE sum_odd , sum_even , c = 0 , 0 , 1 NEW_LINE while n != 0 : NEW_LINE INDENT if c % 2 == 0 : NEW_LINE INDENT sum_even += n % 10 NEW_LINE DEDENT else : NEW_LINE INDENT sum_odd += n % 10 NEW_LINE DEDENT n //= 10 NEW_LINE c += 1 NEW_LINE DEDENT print ( ' Sum ▁ odd ▁ = ▁ { } ' . format ( sum_odd ) ) NEW_LINE print ( ' Sum ▁ even ▁ = ▁ { } ' . format ( sum_even ) ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 457892 NEW_LINE _Sum ( n ) NEW_LINE DEDENT return _Sum NEW_LINE DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def disp ( self , row_no , block ) : NEW_LINE INDENT print ( row_no * block , end = ' ▁ ' ) NEW_LINE DEDENT def row ( self , ht , h ) : NEW_LINE INDENT return ht // h NEW_LINE DEDENT def calculate ( self , l , w , h , a , ht ) : NEW_LINE INDENT no_block = ( 4 * a ) // l NEW_LINE if h < w : NEW_LINE INDENT row_no = self . row ( ht , w ) NEW_LINE DEDENT else : NEW_LINE INDENT row_no = self . row ( ht , h ) NEW_LINE DEDENT return self . disp ( row_no , no_block ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT l , w , h = 50 , 20 , 35 NEW_LINE a , ht = 700 , 140 NEW_LINE return self . calculate ( l , w , h , a , ht ) NEW_LINE DEDENT DEDENT
def GFG ( s ) : NEW_LINE INDENT bin = [ '000' , '001' , "010' , "011' , '100' , '101' , "110' , "111" ] NEW_LINE def maxFreq ( s ) : NEW_LINE INDENT binary = " " NEW_LINE for c in s : NEW_LINE INDENT binary += bin [ c - '0' ] NEW_LINE DEDENT binary = binary [ : - 1 ] NEW_LINE count , prev , i , j = 1 , - 1 , - 1 , i , 0 NEW_LINE for c in binary [ : - 1 ] : NEW_LINE INDENT if c == '1' : NEW_LINE INDENT count , prev = max ( count , j - prev ) , j NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT octal = "13" NEW_LINE print ( maxFreq ( octal ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( c ) : return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE def encryptString ( s , n , k ) : NEW_LINE INDENT cv = [ 0 ] NEW_LINE cc = [ 0 ] NEW_LINE if isVowel ( s [ 0 ] ) : NEW_LINE INDENT cv . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cc . append ( 1 ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT cv [ i ] = cv [ i - 1 ] + ( 1 if isVowel ( s [ i ] ) == True else 0 ) NEW_LINE cc [ i ] = cc [ i - 1 ] + ( 0 if isVowel ( s [ i ] ) == True else 1 ) NEW_LINE DEDENT ans = " " NEW_LINE prod = 0 NEW_LINE prod = cc [ k - 1 ] * cv [ k - 1 ] NEW_LINE ans += str ( prod ) NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) NEW_LINE ans += str ( prod ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def GFG ( arr , freq , n ) : NEW_LINE INDENT sum , frequency_sum = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + float ( freq [ i ] ) / arr [ i ] NEW_LINE frequency_sum = frequency_sum + freq [ i ] NEW_LINE DEDENT return ( frequency_sum / sum ) NEW_LINE def main ( args ) : NEW_LINE INDENT num = [ 13 , 14 , 15 , 16 , 17 ] NEW_LINE freq = [ 2 , 5 , 13 , 7 , 3 ] NEW_LINE n = len ( num ) NEW_LINE print ( ' % . 4 f ' % harmonic_mean ( num , freq , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def polyarea ( n , a ) : NEW_LINE INDENT import math NEW_LINE if a < 0 and n < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a ** 2 * n ) / float ( 4 * math . tan ( ( 180 / n ) * math . pi / 180 ) ) NEW_LINE return A NEW_LINE DEDENT
def Solution ( a , b ) : NEW_LINE INDENT if a == 0 : return b NEW_LINE if b == 0 : return a NEW_LINE if a == b : return a NEW_LINE if a > b : return __gcd ( a - b , b ) NEW_LINE return __gcd ( a , b - a ) NEW_LINE def lcm ( a , b ) : return ( a / __gcd ( a , b ) * b ) NEW_LINE def get_min_value ( c ) : NEW_LINE INDENT ans = sys . maxint NEW_LINE for i in range ( 1 , math . sqrt ( c ) + 1 ) : NEW_LINE INDENT if c % i == 0 and lcm ( i , c / i ) == c : NEW_LINE INDENT ans = min ( ans , max ( i , c / i ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT c = 6 NEW_LINE print ( get_min_value ( c ) ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sys = sys NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT for m , nmin , nmax in self . sys . argv : NEW_LINE INDENT if m + nmin + nmax == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = [ ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT p . append ( i ) NEW_LINE DEDENT gap = 0 NEW_LINE n = 0 NEW_LINE for i in range ( nmin , nmax + 1 ) : NEW_LINE INDENT if gap <= p [ i ] - p [ i + 1 ] and n < i : NEW_LINE INDENT gap = p [ i ] - p [ i + 1 ] NEW_LINE n = i NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE from math import sin , cos , tan NEW_LINE from math import pi NEW_LINE from math import log as inf NEW_LINE from math import log as log NEW_LINE from math import pi NEW_LINE from math import sin as sin NEW_LINE from math import cos as sin NEW_LINE from math import pi NEW_LINE from math import sin as sin NEW_LINE from math import cos as sin NEW_LINE from math import pi NEW_LINE from math import sin as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE from math import log as sin NEW_LINE DEDENT
def import import os , sys , stdin , stdout , stderr , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur , recur
def findIndex ( n ) : NEW_LINE INDENT fibo = 2.078087F * float ( math . log ( n ) ) + 1.672276F NEW_LINE return round ( fibo , 2 ) NEW_LINE DEDENT
def isSmaller ( str1 , str2 ) : NEW_LINE INDENT import string NEW_LINE n1 , n2 = len ( str1 ) , len ( str2 ) NEW_LINE if n1 < n2 : NEW_LINE INDENT return True NEW_LINE DEDENT if n2 < n1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if str1 [ i ] < str2 [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT elif str1 [ i ] > str2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def findDiff ( str1 , str2 ) : NEW_LINE INDENT if isSmaller ( str1 , str2 ) : NEW_LINE INDENT t = str1 NEW_LINE str1 = str2 NEW_LINE str2 = t NEW_LINE DEDENT str = " " NEW_LINE n1 , n2 = len ( str1 ) , len ( str2 ) NEW_LINE str1 = list ( reversed ( str1 ) ) NEW_LINE str2 = list ( reversed ( str2 ) ) NEW_LINE carry = 0 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT sub = ( ord ( str1 [ i ] ) - ord ( '0' ) ) - ord ( str2 [ i ] ) - carry NEW_LINE if sub < 0 : NEW_LINE INDENT sub = sub + 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT str += chr ( sub + '0' ) NEW_LINE DEDENT for i in range ( n2 , n1 ) : NEW_LINE INDENT sub = ( ord ( str1 [ i ] ) - ord ( '0' ) ) - carry NEW_LINE if sub < 0 : NEW_LINE INDENT sub = sub + 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT str += chr ( sub + '0' ) NEW_LINE DEDENT return list ( reversed ( str ) ) NEW_LINE DEDENT str1 = "978" NEW_LINE str2 = "12977" NEW_LINE print ( findDiff ( str1 , str2 ) ) NEW_LINE s1 = "100" NEW_LINE s2 = "1000000" NEW_LINE print ( findDiff ( s1 , s2 ) ) NEW_LINE DEDENT
def GFG ( s1 , s2 ) : NEW_LINE INDENT c0 , c1 = 0 , 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] == '0' and s2 [ i ] == '1' : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT elif s1 [ i ] == '1' and s2 [ i ] == '0' : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT ans = c0 / 2 + c1 / 2 NEW_LINE if c0 % 2 == 0 and c1 % 2 == 0 : NEW_LINE INDENT return ans NEW_LINE DEDENT elif ( c0 + c1 ) % 2 == 0 : NEW_LINE INDENT return ans + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def import _SegmentTree NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = _SegmentTree . __init__ ( self ) NEW_LINE self . n = sc . __next__ ( ) NEW_LINE x = [ sc . __next__ ( ) for i in range ( n ) ] NEW_LINE all = 0 NEW_LINE for i in range ( n ) : all += x [ i ] NEW_LINE seg = SegmentTree ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre = seg . query ( 0 , x [ i ] ) NEW_LINE seg . set ( x [ i ] , pre + x [ i ] ) NEW_LINE DEDENT fix = seg . query ( 0 , n + 1 ) NEW_LINE print ( all - fix ) NEW_LINE DEDENT class SegmentTree ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 1 NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 1 NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 2 NEW_LINE DEDENT def set ( self , k , l ) : NEW_LINE INDENT self . n *= 2 NEW_LINE self . val = [ l ] NEW_LINE while k > 0 : NEW_LINE INDENT k = ( k - 1 ) // 2 NEW_LINE self . val . append ( self . val [ 2 * k + 1 ] ) NEW_LINE DEDENT DEDENT def query ( self , a , b ) : NEW_LINE INDENT return self . query ( a , b , 0 , self . n , 0 ) NEW_LINE DEDENT def query ( self , a , b , l , r , k ) : NEW_LINE INDENT if r <= a or b <= l : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif a <= l and r <= b : NEW_LINE INDENT return self . val [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT vl = self . query ( a , b , l , ( l + r ) // 2 , 2 * k + 1 ) NEW_LINE vr = self . query ( a , b , ( l + r ) // 2 , r , 2 * k + 2 ) NEW_LINE return max ( vl , vr ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Main NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from os . path import join NEW_LINE from os import urandom NEW_LINE from random import randint NEW_LINE from time import sleep NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE DEDENT
def test_normalsieve ( ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . prime = [ False ] * ( n // 2 ) NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT for i in range ( 3 , n * 2 , 2 ) : NEW_LINE INDENT if self . prime [ i // 2 ] == False : NEW_LINE INDENT for j in range ( i * i , n , i * 2 ) : NEW_LINE INDENT self . prime [ j // 2 ] = True NEW_LINE DEDENT DEDENT DEDENT print ( "2 ▁ " , end = " " ) NEW_LINE for i in range ( 3 , n , 2 ) : NEW_LINE INDENT if self . prime [ i // 2 ] == False : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 100 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from nltk . corpus import brown NEW_LINE with open ( ' . txt ' , ' r ' ) as f : NEW_LINE INDENT word = f . readline ( ) NEW_LINE uppercase = lowercase = 0 NEW_LINE for ch in word : NEW_LINE INDENT if ch . isupper ( ) : NEW_LINE INDENT uppercase += 1 NEW_LINE DEDENT else : NEW_LINE INDENT lowercase += 1 NEW_LINE DEDENT DEDENT if uppercase > lowercase : NEW_LINE INDENT print ( word . upper ( ) ) NEW_LINE DEDENT elif lowercase > uppercase : NEW_LINE INDENT print ( word . lower ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( word . lower ( ) ) NEW_LINE DEDENT DEDENT DEDENT
def frequencyOfSmallest ( n , arr ) : NEW_LINE INDENT import scipy . ndimage NEW_LINE class GFG ( scipy . ndimage . measurements . Integral ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . mn , freq = arr [ 0 ] , 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if self . mn < mn : NEW_LINE INDENT self . mn , freq = arr [ i ] , 1 NEW_LINE DEDENT elif self . mn == mn : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return GFG NEW_LINE DEDENT
def GFG ( arr ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if A [ i ] == B [ j ] : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE if j == m : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i = i - j + 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def test_problem_b ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy . testing import assert_array_almost_equal NEW_LINE class ProblemB ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . scn = sys . stdin NEW_LINE self . arr = np . arange ( self . scn ) NEW_LINE DEDENT DEDENT arr = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 33 , 34 , 35 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36
def GFG ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT
def import import struct NEW_LINE import sys NEW_LINE import struct NEW_LINE import os NEW_LINE import sys NEW_LINE MOD = 1000000007L NEW_LINE TOKENS = [ ' A ' , ' C ' , ' G ' , ' T ' ] NEW_LINE def main ( ) : NEW_LINE INDENT with open ( ' / proc / self / stat ' ) as f : NEW_LINE INDENT N = struct . unpack ( ' I ' , f . read ( 4 ) ) [ 0 ] NEW_LINE DEDENT self . memo = [ { } for i in range ( N + 1 ) ] NEW_LINE def calc ( ) : NEW_LINE INDENT return dfs ( 0 , ' TTT ' ) NEW_LINE DEDENT def isOK ( last4 ) : NEW_LINE INDENT if last4 in ' AGC ' : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT vals = last4 [ i ] , last4 [ i + 1 ] NEW_LINE vals [ i + 1 ] = last4 [ i ] NEW_LINE s = ' ' . join ( vals ) NEW_LINE if last4 in s : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( current , last3 ) : NEW_LINE INDENT if last3 in self . memo [ current ] : NEW_LINE INDENT return struct . unpack ( ' I ' , last3 [ : current ] ) [ 0 ] NEW_LINE DEDENT if current == N : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for c in TOKENS : NEW_LINE INDENT if isOK ( last3 + c ) : NEW_LINE INDENT result = ( result + dfs ( current + 1 , last3 [ 1 : len ( last3 ) ] + c ) ) % MOD NEW_LINE DEDENT DEDENT self . memo [ current ] [ last3 ] = result NEW_LINE return result NEW_LINE DEDENT def dfs ( current , last3 ) : NEW_LINE INDENT ins = struct . unpack ( ' I ' , last3 [ : current ] ) NEW_LINE print ( ins . calc ( ) ) NEW_LINE DEDENT return dfs ( ) NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . args = args NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE n = 0 NEW_LINE total = 0 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT value , amount = select . select ( [ 1 ] ) NEW_LINE sum += value * amount NEW_LINE total += amount NEW_LINE n += 1 NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE print ( round ( float ( total ) / n , 2 ) ) NEW_LINE DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 100 NEW_LINE DEDENT def binomial_coeff ( self , n , k ) : NEW_LINE INDENT C = [ 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT def sum_ofproduct ( self , n ) : NEW_LINE INDENT return binomial_coeff ( 2 * self . n , n - 1 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = 3 NEW_LINE print ( sum_ofproduct ( self ) ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . string1 = sys . stdin . readline ( ) NEW_LINE print ( " Enter ▁ the ▁ first ▁ string : ▁ " , string1 ) NEW_LINE self . string2 = sys . stdin . readline ( ) NEW_LINE print ( " Enter ▁ the ▁ second ▁ string : ▁ " , string2 ) NEW_LINE print ( " Are ▁ both ▁ strings ▁ same : ▁ " , end = " " ) NEW_LINE if self . string1 == self . string2 == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def pair_count ( arr , n ) : NEW_LINE INDENT import numpy as np NEW_LINE max_val = np . max ( arr ) NEW_LINE prime = np . zeros ( max_val + 1 ) NEW_LINE for i in range ( max_val + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count * ( count - 1 ) ) / 2 NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT import numpy as np NEW_LINE def getPrime ( arr , n ) : NEW_LINE INDENT max_val = np . max ( arr ) NEW_LINE prime = np . zeros ( max_val + 1 ) NEW_LINE for i in range ( max_val + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE prime [ 2 ] = False NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT maximum = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT arr = [ 2 , 10 , 15 , 7 , 6 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getPrime ( arr , n ) ) NEW_LINE DEDENT
def test_p013 ( ) : NEW_LINE INDENT from sympy import Number NEW_LINE print ( Number ( ) ) NEW_LINE def run ( ) : NEW_LINE INDENT sum = 0 NEW_LINE for num in NUMBERS : sum = sum + Number ( num ) NEW_LINE return sum . hexdigest ( ) [ : 10 ] NEW_LINE DEDENT NUMBERS = [ '371072875339021027987979982208375902537236877223636045' , '1742370690585186066044837630453719324610405692' , '537107287533902102798797998220837590246510135740250' , '46376937677490009712648124896970078050417018260538' , '74324986199524741059474233309513058123726617309629' , "91942213363574161572522430563301811072406154908250' , '23067588207539346171171980310421047513778063246676' , '89261670696623633820136378418383684178734361726757' , '28112879812849979408065481931592621691275889832738' , '442742289174325203219235894228767964670272189318' , '47451445736001306439091167216856844588711603153276' , "70386486105843025439939619828917593665686757934951' , '6217645714973073073070492910143244581382663347944758178' , "92575867718337217661930730730730704929101432445813826633479447581725337466767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767
def test_find_elements ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE from numpy . testing import find_elements NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_elements ( self , arr , n ) : NEW_LINE INDENT arr = [ arr ] NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE find_elements ( arr , n ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def test_gf_distinct ( ) : NEW_LINE INDENT import sys NEW_LINE import numpy . random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def printDistinct ( self , arr , n ) : NEW_LINE INDENT arr = [ arr ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT while i < n - 1 and arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print_distinct ( arr , n ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def import import _sys , os , sys NEW_LINE from os import urandom NEW_LINE from math import pow NEW_LINE class Main ( object ) : NEW_LINE INDENT BIG_NUM = 2000000000 NEW_LINE MOD = 1000000007 NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . BIG_NUM = 2000000000 NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' % s ▁ % s ' % ( self . BIG_NUM , self . MOD ) NEW_LINE DEDENT DEDENT
def GFG ( a , b , n ) : NEW_LINE INDENT z = 0 NEW_LINE if n % 6 == 1 : NEW_LINE INDENT z = a NEW_LINE DEDENT elif n % 6 == 2 : NEW_LINE INDENT z = b NEW_LINE DEDENT elif n % 6 == 3 : NEW_LINE INDENT z = b - a NEW_LINE DEDENT elif n % 6 == 4 : NEW_LINE INDENT z = - a NEW_LINE DEDENT elif n % 6 == 5 : NEW_LINE INDENT z = - b NEW_LINE DEDENT if n % 6 == 0 : NEW_LINE INDENT z = - ( b - a ) NEW_LINE DEDENT return z NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_subsequence ( self , num ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while num > 0 : NEW_LINE INDENT if num & 1 == 1 : NEW_LINE INDENT res += self . s [ i ] - '0' NEW_LINE DEDENT i += 1 NEW_LINE num = num >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def combined_sum ( self ) : NEW_LINE INDENT n = len ( self . s ) NEW_LINE c_sum = 0 NEW_LINE range = ( 1 << n ) - 1 NEW_LINE for i in range ( 0 , range ) : NEW_LINE INDENT c_sum += find_subsequence ( self , self . s [ i ] ) NEW_LINE DEDENT return c_sum NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT s = '123' NEW_LINE print ( combined_sum ( s ) ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT import sys NEW_LINE import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def minimumCost ( self , cost , n ) : NEW_LINE INDENT dp1 , dp2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 , dp1 = dp1 , dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import factorial NEW_LINE class GFG ( factorial ) : NEW_LINE INDENT def count_multiples ( self , n ) : NEW_LINE INDENT return n // 3 + n // 7 - n // 21 NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def long_substr ( str1 , k = 1 ) : NEW_LINE INDENT import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE NEW_LINE import string NEW_LINE import string NEW_LINE NEW_LINE import string NEW_LINE NEW_LINE import string NEW_LINE NEW_LINE import string NEW_LINE NEW_LINE NEW_LINE import string NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE > > > NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE > > > > NEW_LINE NEW_LINE NEW_LINE NEW_LINE NEW_LINE DEDENT
def class6 ( arg ) : NEW_LINE INDENT import sys NEW_LINE from math import sin , cos , cos , exp NEW_LINE with open ( ' test . txt ' , ' r ' ) as sc : NEW_LINE INDENT n = sc . read ( ) NEW_LINE ch = [ ] NEW_LINE s1 , s2 = 0 , 0 NEW_LINE i , j , flag , dif = 0 , 0 , 0 NEW_LINE for x , y in zip ( sc . read ( ) , ch ) : NEW_LINE INDENT temp1 = s1 + x NEW_LINE temp2 = s2 + y NEW_LINE if abs ( temp1 - s2 ) <= 500 : NEW_LINE INDENT s1 += x NEW_LINE ch . append ( ' A ' ) NEW_LINE continue NEW_LINE DEDENT if abs ( temp2 - s1 ) <= 500 : NEW_LINE INDENT s2 += y NEW_LINE ch . append ( ' G ' ) NEW_LINE continue NEW_LINE DEDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' ' NEW_LINE ans = sin ( ch ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT DEDENT
def Solution ( num ) : NEW_LINE INDENT hex_map = "0123456789abcdef " NEW_LINE if not num : NEW_LINE INDENT return "0" NEW_LINE DEDENT res = " " NEW_LINE while num != 0 and len ( res ) < 8 : NEW_LINE INDENT res = hex_map [ num & 15 ] + res NEW_LINE num = num >> 4 NEW_LINE DEDENT return res NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import count NEW_LINE def print_island ( n , count ) : NEW_LINE INDENT with open ( ' . . / ' , ' r ' ) as f : NEW_LINE INDENT n = f . read ( ) NEW_LINE DEDENT DEDENT def print_island ( n , count ) : NEW_LINE INDENT a = ( n + 1 ) // 2 NEW_LINE b = n // 2 NEW_LINE max = a * a + b * b NEW_LINE if count > max : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE return NEW_LINE DEDENT print ( ' YES ' ) NEW_LINE lines = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i + j ) % 2 == 0 and count > 0 : NEW_LINE INDENT lines . append ( ' L ' ) NEW_LINE count -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT lines . append ( ' S ' ) NEW_LINE DEDENT DEDENT lines . append ( ' ' ) NEW_LINE DEDENT print ( ' \n ' . join ( lines ) ) NEW_LINE DEDENT return print_island NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT count1 , count2 = [ 0 ] * 26 NEW_LINE for c in str1 : NEW_LINE INDENT count1 [ c - ' a ' ] += 1 NEW_LINE DEDENT for c in str2 : NEW_LINE INDENT count2 [ c - ' a ' ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result += chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE def main ( ) : NEW_LINE INDENT str1 , str2 = " geeks " , " cake " NEW_LINE longestString ( str1 , str2 ) NEW_LINE DEDENT DEDENT
def GFG ( x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( x >> ( ret + 1 ) ) : NEW_LINE INDENT ret += 1 NEW_LINE DEDENT return ret NEW_LINE def xor_range ( l , r ) : NEW_LINE INDENT max_bit = msb ( r ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , max_bit + 1 ) : NEW_LINE INDENT if ( l / mul ) * mul == ( r / mul ) * mul : NEW_LINE INDENT if ( ( l & ( 1 << i ) ) != 0 and ( r - l + 1 ) % 2 == 1 ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE continue NEW_LINE DEDENT odd_c = 0 NEW_LINE if ( ( l & ( 1 << i ) ) != 0 and l % 2 == 1 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( ( r & ( 1 << i ) ) != 0 and r % 2 == 0 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if odd_c != 0 : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) // 2 NEW_LINE if l % 2 == 1 and r % 2 == 1 : NEW_LINE INDENT zero_bit_cnt += 1 NEW_LINE DEDENT if zero_bit_cnt % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT l , r = 1 , 4 NEW_LINE print ( xor_range ( l , r ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def GFG ( s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT if s [ i ] == " a " : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT def q2 ( s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT if s [ i ] == " a " : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT def q3 ( s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT if s [ i ] == " a " : NEW_LINE INDENT q4 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT def q0 ( s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT if s [ i ] == " a " : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = sys . stdin NEW_LINE while 1 : NEW_LINE INDENT n = sys . stdin . readline ( ) . strip ( ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT m = [ 0 ] * 10000 NEW_LINE t = [ 1 ] NEW_LINE a , b = sys . stdin . readline ( ) . strip ( ) . split ( ' ▁ ' ) NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT [ m [ i ] , t [ i ] ] = 1 NEW_LINE a , b = sys . stdin . readline ( ) . strip ( ) . split ( ' ▁ ' ) NEW_LINE for j in range ( 0 , a * b , a ) : NEW_LINE INDENT for k in range ( 0 , max ) : NEW_LINE INDENT if t [ k ] : NEW_LINE INDENT m [ j + k ] += t [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT max += a * b NEW_LINE t = m [ : ] NEW_LINE DEDENT s = sys . stdin . readline ( ) . strip ( ) . split ( ' ▁ ' ) NEW_LINE for i in range ( s ) : NEW_LINE INDENT print ( m [ sys . stdin . readline ( ) . strip ( ) ] ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( T , K ) : NEW_LINE INDENT minutes = ( ( T [ 0 ] - '0' ) * 10 + T [ 1 ] - '0' ) * 60 + ( ( T [ 3 ] - '0' ) * 10 + T [ 4 ] - '0' ) NEW_LINE minutes += K NEW_LINE hour = ( minutes / 60 ) % 24 NEW_LINE min = minutes % 60 NEW_LINE if hour < 10 : NEW_LINE INDENT print ( '0' + str ( hour ) + ' : ' , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( hour + ' : ' , end = ' ▁ ' ) NEW_LINE DEDENT if min < 10 : NEW_LINE INDENT print ( '0' + str ( min ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ) NEW_LINE DEDENT DEDENT
def test_gf_max_product_sum ( ) : NEW_LINE INDENT import string NEW_LINE from sympy . combinatorics . permutations import Permutation NEW_LINE n = len ( string . ascii_letters ) NEW_LINE max_prod , max_sum = [ 0 ] , [ 0 ] NEW_LINE for i in range ( n - m ) : NEW_LINE INDENT product , sum = 1 , 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product , sum = product * ( string . ascii_letters [ j ] - '0' ) , sum + ( string . ascii_letters [ j ] - '0' ) NEW_LINE DEDENT max_prod = max ( max_prod , product ) NEW_LINE max_sum = max ( max_sum , sum ) NEW_LINE DEDENT print ( ' Maximum ▁ Product ▁ = ▁ { } ' . format ( max_prod ) ) NEW_LINE print ( ' Maximum ▁ Sum ▁ = ▁ { } ' . format ( max_sum ) ) NEW_LINE DEDENT
def GFG ( x , y , z ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return ( x , z ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( y , z ) NEW_LINE DEDENT def minCost ( cost , m , n ) : NEW_LINE INDENT if n < 0 or m < 0 : NEW_LINE INDENT return sys . maxint NEW_LINE DEDENT elif m == 0 and n == 0 : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = n NEW_LINE self . x = [ ] NEW_LINE self . ji = [ ] NEW_LINE self . shu = [ ] NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT shu . append ( sys . stdin . read ( ) ) NEW_LINE DEDENT shu . sort ( ) NEW_LINE l1 = l2 = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT s1 = i * 2 + 1 NEW_LINE s2 = i * 2 + 2 NEW_LINE id = shu [ i ] NEW_LINE if id != s1 : NEW_LINE INDENT l1 = l1 + abs ( s1 - id ) NEW_LINE DEDENT if id != s2 : NEW_LINE INDENT l2 = l2 + abs ( s2 - id ) NEW_LINE DEDENT DEDENT self . min = min ( l1 , l2 ) NEW_LINE DEDENT DEDENT
def import _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _
def sum_divisibles ( A , B , M ) : NEW_LINE INDENT import sys NEW_LINE from math import sin , cos , sqrt NEW_LINE sum = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if i % M == 0 : sum += i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def count_numbers_with_4 ( n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( math . log10 ( n ) ) NEW_LINE a = [ 0 ] * ( d + 2 ) NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + int ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT p = int ( math . ceil ( math . pow ( 10 , d ) ) ) NEW_LINE msd = n // p NEW_LINE if msd == 4 : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if msd > 4 : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + p + count_numbers_with_4 ( n % p ) NEW_LINE DEDENT return ( msd ) * a [ d ] + count_numbers_with_4 ( n % p ) NEW_LINE DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class vfe ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . x = sys . stdin . read ( ) NEW_LINE self . y = sys . stdin . read ( ) NEW_LINE self . list = [ x , y , y - x ] NEW_LINE i = 2 NEW_LINE while not ( self . list [ i ] == y and self . list [ i - 1 ] == x or self . list [ i ] == 0 and self . list [ i - 1 ] == 0 ) : NEW_LINE INDENT self . list [ i ] = self . list [ i ] - self . list [ i - 1 ] NEW_LINE i += 1 NEW_LINE DEDENT k = sys . stdin . read ( ) NEW_LINE i -= 1 NEW_LINE k = k % i NEW_LINE if k == 0 : NEW_LINE INDENT k = i NEW_LINE DEDENT print ( ( ( self . list [ k - 1 ] % 1000000007 ) + 1000000007 ) % 1000000007 ) NEW_LINE DEDENT DEDENT
def import _Solution NEW_LINE class Solution : NEW_LINE INDENT class INT ( object ) : NEW_LINE INDENT def __init__ ( self , d ) : NEW_LINE INDENT self . data = d NEW_LINE DEDENT DEDENT def find_post_order_util ( pre , n , minval , maxval , pre_index ) : NEW_LINE INDENT if pre_index . data == n : NEW_LINE INDENT return NEW_LINE DEDENT if pre [ pre_index . data ] < minval or pre [ pre_index . data ] > maxval : NEW_LINE INDENT return NEW_LINE DEDENT val = pre [ pre_index . data ] NEW_LINE pre_index . data += 1 NEW_LINE find_post_order_util ( pre , n , minval , val , pre_index ) NEW_LINE find_post_order_util ( pre , n , val , maxval , pre_index ) NEW_LINE print ( val , end = ' ▁ ' ) NEW_LINE DEDENT def find_post_order ( pre , n ) : NEW_LINE INDENT pre_index = INT ( 0 ) NEW_LINE find_post_order_util ( pre , n , int ( minval ) , int ( maxval ) , pre_index ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT pre = [ 40 , 30 , 35 , 80 , 100 ] NEW_LINE n = len ( pre ) NEW_LINE find_post_order ( pre , n ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def count_ways ( self , arr , k ) : NEW_LINE INDENT if k <= 0 or k >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = set ( arr ) NEW_LINE if len ( s ) <= k : NEW_LINE INDENT return 0 NEW_LINE DEDENT return len ( s ) - k NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 100 , 200 , 400 , 50 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( count_ways ( n , arr , k ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from io import StringIO NEW_LINE from termios import TIOCGWINSZ NEW_LINE from io import BytesIO NEW_LINE class _250B ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdin = StringIO ( ) NEW_LINE self . stdout . write ( " \n " ) NEW_LINE self . stdout . write ( " \n " ) NEW_LINE self . stdout . write ( " \n " ) NEW_LINE self . stdout . write ( " \n " ) NEW_LINE self . stdout . write ( " \n " ) NEW_LINE self . stdout . write ( " \n " ) NEW_LINE self . stdout . write ( " \n " ) NEW_LINE self . stdout . write ( " \n " ) NEW_LINE self . stdout . write ( " \n " ) NEW_LINE self . stdout . write ( " \n " ) NEW_LINE self . stdout . write ( " \n " ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT s = [ ] NEW_LINE for i , s in enumerate ( self . stdin ) : NEW_LINE INDENT k , m = 0 , len ( s ) - 1 NEW_LINE if s [ k ] == " " : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if s [ m ] == " " : NEW_LINE INDENT m -= 1 NEW_LINE DEDENT for j in range ( k , m + 1 ) : NEW_LINE INDENT if s [ j ] == " " : NEW_LINE INDENT for l , lim in zip ( 1 , 8 - m + k ) : NEW_LINE INDENT s . append ( "0000" ) NEW_LINE if l < lim : NEW_LINE INDENT s . append ( ' : ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT for l in s [ j ] . split ( " ▁ " ) [ : 4 ] : NEW_LINE INDENT s . append ( '0' ) NEW_LINE DEDENT s . append ( s [ j ] ) NEW_LINE DEDENT if j < m : NEW_LINE INDENT s . append ( ' : ' ) NEW_LINE DEDENT DEDENT s . append ( " \n " ) NEW_LINE DEDENT DEDENT return _250B NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , 2 * n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT return ( flag == 1 ) NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def countInterestingPrimes ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT for j in range ( 1 , 2 * i + 1 ) : NEW_LINE INDENT if isPerfectSquare ( i - j ** 2 ) : NEW_LINE INDENT answer += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = 10 NEW_LINE print ( countInterestingPrimes ( N ) , end = ' ▁ ' ) NEW_LINE DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , name ) : NEW_LINE INDENT self . name = name NEW_LINE self . N = len ( self . name ) NEW_LINE previous = self . name NEW_LINE next = self . name NEW_LINE used_words = set ( [ previous ] ) NEW_LINE while N > 1 : NEW_LINE INDENT next = self . name NEW_LINE if not ( ( previous [ - 1 ] == next [ 0 ] ) and used_words . add ( next ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE self . name = next NEW_LINE return NEW_LINE DEDENT previous = next NEW_LINE N -= 1 NEW_LINE DEDENT self . name = previous NEW_LINE self . N = N NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT
def GFG ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE DEDENT return num NEW_LINE def main ( ) : NEW_LINE INDENT div = [ 8 , 3 ] NEW_LINE rem = [ 2 , 2 ] NEW_LINE N = len ( div ) NEW_LINE print ( find_num ( div , rem , N ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def segregate0and1 ( arr ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . type0 = 0 NEW_LINE self . type1 = len ( self . arr ) - 1 NEW_LINE while self . type0 < self . type1 : NEW_LINE INDENT if self . arr [ self . type0 ] == 1 : NEW_LINE INDENT self . arr [ self . type1 ] = self . arr [ self . type1 ] + self . arr [ self . type0 ] NEW_LINE self . arr [ self . type0 ] = self . arr [ self . type1 ] - self . arr [ self . type0 ] NEW_LINE self . arr [ self . type1 ] = self . arr [ self . type1 ] - self . arr [ self . type0 ] NEW_LINE self . type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . type0 += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT array = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE segregate0and1 ( array ) NEW_LINE sys . stdout . write ( " Array ▁ after ▁ segregation ▁ is ▁ " ) NEW_LINE for a in array : NEW_LINE INDENT sys . stdout . write ( a + " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( sys . stdin . read ( ) ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . d = [ ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT self . d . append ( i ) NEW_LINE DEDENT DEDENT def sort ( self ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( self . n - 1 ) : NEW_LINE INDENT if self . d [ i ] != self . d [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def import import string NEW_LINE class ShortestKingPath ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = string NEW_LINE self . s1 = string NEW_LINE DEDENT def go ( self ) : NEW_LINE INDENT self . s = string . split ( self . s ) [ 0 ] NEW_LINE self . s1 = string . split ( self . s1 ) [ 1 ] NEW_LINE c = string . split ( self . s ) NEW_LINE c1 = string . split ( self . s1 ) NEW_LINE diff = c1 [ 0 ] - c [ 0 ] NEW_LINE dif = c1 [ 1 ] - c [ 1 ] NEW_LINE n = abs ( diff ) NEW_LINE m = abs ( dif ) NEW_LINE ans = " " NEW_LINE while diff != 0 or dif != 0 : NEW_LINE INDENT if diff > 0 : NEW_LINE INDENT ans += " R " NEW_LINE diff -= 1 NEW_LINE DEDENT if diff < 0 : NEW_LINE INDENT ans += " L " NEW_LINE diff += 1 NEW_LINE DEDENT if dif > 0 : NEW_LINE INDENT ans += " U " NEW_LINE dif -= 1 NEW_LINE DEDENT if dif < 0 : NEW_LINE INDENT ans += " D " NEW_LINE dif += 1 NEW_LINE DEDENT ans += " \n " NEW_LINE DEDENT print ( max ( n , m ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . h = sys . maxint NEW_LINE self . w = sys . maxint NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT for i in range ( self . h ) : NEW_LINE INDENT for j in range ( self . w ) : NEW_LINE INDENT x = sys . stdin . read ( ) NEW_LINE total = 0 NEW_LINE for i in range ( self . h ) : NEW_LINE INDENT for j in range ( self . w ) : NEW_LINE INDENT x = sys . stdin . read ( ) NEW_LINE total += x * ( i + 1 ) * ( self . h - i ) * ( j + 1 ) * ( self . w - j ) NEW_LINE DEDENT DEDENT DEDENT print ( total ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import itertools NEW_LINE import itertools NEW_LINE import itertools NEW_LINE n = int ( os . environ [ ' LINES ' ] ) NEW_LINE lab = [ [ int ( i ) for i in fin . split ( ' ▁ ' ) ] for j in itertools . product ( range ( n ) , range ( n ) ) ] NEW_LINE ans = True NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( n ) : NEW_LINE INDENT if lab [ x ] [ y ] != 1 : NEW_LINE INDENT cur = lab [ x ] [ y ] NEW_LINE is_valid = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if lab [ x ] [ i ] + lab [ j ] [ y ] == cur : NEW_LINE INDENT is_valid = True NEW_LINE break NEW_LINE DEDENT DEDENT if is_valid : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not is_valid : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if not ans : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ' Yes ' if ans else ' No ' ) NEW_LINE DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . x , self . y = _main ( ) NEW_LINE self . print_bin ( self . fill_zero ( str ( x & y ) ) ) NEW_LINE self . print_bin ( self . fill_zero ( str ( x | y ) ) ) NEW_LINE self . print_bin ( self . fill_zero ( str ( x ^ y ) ) ) NEW_LINE DEDENT def print_bin ( self ) : NEW_LINE INDENT for char in self . x [ - 32 : ] : NEW_LINE INDENT print ( char , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def fill_zero ( self ) : NEW_LINE INDENT zero = ' ' NEW_LINE if len ( self . x ) < 32 : NEW_LINE INDENT for char in self . x [ : 32 - len ( self . x ) ] : NEW_LINE INDENT zero += '0' NEW_LINE DEDENT DEDENT return zero . ljust ( 32 ) NEW_LINE DEDENT DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . _main = _main ( ) NEW_LINE DEDENT def __init__ ( self , x ) : NEW_LINE INDENT self . _main . append ( x ) NEW_LINE DEDENT def print_bin ( self ) : NEW_LINE INDENT for c in self . _main [ - 32 : ] : NEW_LINE INDENT print ( c , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def fillzero ( self ) : NEW_LINE INDENT zero = ' ' NEW_LINE if len ( self . _main ) < 32 : NEW_LINE INDENT for i in range ( 32 - len ( self . _main ) ) : NEW_LINE INDENT zero += '0' NEW_LINE DEDENT DEDENT return zero . ljust ( 32 ) NEW_LINE DEDENT DEDENT
def import import _number , parse_int , parse_long , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int , parse_int ,
def import import _line_number NEW_LINE class InterceptedMessage ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . total_first_files = int ( self . total_first_files ) NEW_LINE self . total_second_files = int ( self . total_second_files ) NEW_LINE self . first_files = [ ] NEW_LINE self . second_files = [ ] NEW_LINE for i in range ( self . total_first_files ) : NEW_LINE INDENT self . first_files . append ( i ) NEW_LINE DEDENT for i in range ( self . total_second_files ) : NEW_LINE INDENT self . second_files . append ( i ) NEW_LINE DEDENT print ( self . intercepted_message ( self . first_files , self . second_files ) ) NEW_LINE DEDENT def __init__ ( self , first_files , second_files ) : NEW_LINE INDENT self . max_files = 0 NEW_LINE self . first_pointer = 0 NEW_LINE self . second_pointer = 0 NEW_LINE self . has_finished = False NEW_LINE self . temp_first_number = 0 NEW_LINE self . temp_second_number = 0 NEW_LINE while not self . has_finished : NEW_LINE INDENT if self . first_pointer == 0 and self . second_pointer == 0 : NEW_LINE INDENT self . temp_first_number += first_files [ self . first_pointer ] NEW_LINE self . temp_second_number += second_files [ self . second_pointer ] NEW_LINE DEDENT if self . temp_first_number == self . temp_second_number : NEW_LINE INDENT self . max_files += 1 NEW_LINE self . first_pointer += 1 NEW_LINE self . second_pointer += 1 NEW_LINE if self . first_pointer > len ( self . first_files ) - 1 and self . second_pointer > len ( self . second_files ) - 1 : NEW_LINE INDENT break NEW_LINE DEDENT self . temp_first_number = self . first_files [ self . first_pointer ] NEW_LINE self . temp_second_number = self . second_files [ self . second_pointer ] NEW_LINE DEDENT elif self . temp_first_number < self . temp_second_number : NEW_LINE INDENT self . first_pointer += 1 NEW_LINE self . first_files [ self . first_pointer ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . second_pointer += 1 NEW_LINE self . second_files [ self . second_pointer ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , args ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE for a , op , b in [ ( int , ' ? ' ) , ( int , ' + ' ) , ( int , ' - ' ) , ( int , ' * ' ) , ( int , ' / ' ) , ( int , ' / ' ) ] : NEW_LINE INDENT if op == ' ? ' : break NEW_LINE if op == ' + ' : print ( a + b ) NEW_LINE if op == ' - ' : print ( a - b ) NEW_LINE if op == ' * ' : print ( a * b ) NEW_LINE if op == ' / ' : print ( a / b ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE stdin_stream = sys . stdin NEW_LINE N = len ( sys . stdin . readline ( ) ) NEW_LINE A = repeat ( N ) NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i == N - 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif A [ i ] == A [ i + 1 ] : NEW_LINE INDENT pass NEW_LINE DEDENT elif A [ i ] < A [ i + 1 ] : NEW_LINE INDENT while A [ i ] <= A [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE if i == N - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT while A [ i ] >= A [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE if i == N - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def import _count_pairs NEW_LINE class GFG ( object ) : NEW_LINE INDENT MAX = 256 NEW_LINE def count_pairs ( self ) : NEW_LINE INDENT cnt = [ 0 ] * MAX NEW_LINE for c in self . s : NEW_LINE INDENT cnt [ c ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT s = ' geeksforgeeks ' NEW_LINE print ( count_pairs ( s ) ) NEW_LINE DEDENT DEDENT
def import _solution NEW_LINE class solution ( object ) : NEW_LINE INDENT prime = [ False ] * 100006 NEW_LINE def SieveOfEratosthenes ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , p * n + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return prime NEW_LINE DEDENT def sortedArray ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == False : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == True : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v [ j ] , end = ' ▁ ' ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT DEDENT n = 6 NEW_LINE arr = [ 100 , 11 , 500 , 2 , 17 , 1 ] NEW_LINE sortedArray ( arr , n ) NEW_LINE DEDENT
def import _gcd NEW_LINE class GFG ( object ) : NEW_LINE INDENT def createHash ( self , maxElement ) : NEW_LINE INDENT prev , curr = 0 , 1 NEW_LINE self . hash . add ( prev ) NEW_LINE self . hash . add ( curr ) NEW_LINE while curr <= maxElement : NEW_LINE INDENT temp = curr + prev NEW_LINE self . hash . add ( temp ) NEW_LINE prev , curr = curr , temp NEW_LINE DEDENT DEDENT def gcdFibonacciFreq ( arr , n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE self . createHash ( hash , [ arr ] . max ( ) . astype ( int ) ) NEW_LINE if arr [ 0 ] in m : NEW_LINE INDENT m [ arr [ 0 ] ] = m [ arr [ 0 ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ 0 ] ] = 1 NEW_LINE DEDENT gcd = 0 NEW_LINE for it in m . items ( ) : NEW_LINE INDENT if it in self . hash : NEW_LINE INDENT gcd = __gcd ( gcd , it ) NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT return b , a % b NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 5 , 3 , 6 , 5 , 6 , 6 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( gcdFibonacciFreq ( arr , n ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def GFG ( a ) : NEW_LINE INDENT R = a * float ( 2.0 - math . sqrt ( 2 ) ) NEW_LINE area = float ( ( 3.14 * R ** 2 ) / 2.0 ) NEW_LINE return area NEW_LINE DEDENT
def GFG ( a , b , c , d , x , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT for l in range ( n ) : NEW_LINE INDENT if ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT x = 3 NEW_LINE a = [ 0 , 1 ] NEW_LINE b = [ 2 , 0 ] NEW_LINE c = [ 0 , 1 ] NEW_LINE d = [ 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( find_quadruples ( a , b , c , d , x , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import java . io . StringIO NEW_LINE import pylongru NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , l , r , n ) : NEW_LINE INDENT self . l = l NEW_LINE self . r = r NEW_LINE self . n = n NEW_LINE DEDENT def print_smallest ( self , q ) : NEW_LINE INDENT N = len ( self . s ) NEW_LINE H = [ [ 0 ] * ( N + 1 ) for i in range ( 1 , N + 1 ) ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT H [ i ] [ self . s [ i - 1 ] - ' a ' ] += 1 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT H [ i ] [ j ] += H [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT m = len ( q ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT l , r , n = q [ j ] NEW_LINE sum = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT sum += H [ r ] [ i ] - H [ l - 1 ] [ i ] NEW_LINE if sum >= n : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT s = " afbccdeb " NEW_LINE q = [ ( 2 , 4 , 1 ) , ( 1 , 6 , 4 ) , ( 1 , 8 , 7 ) ] NEW_LINE print_smallest ( s , q ) NEW_LINE DEDENT DEDENT
def import import os , sys , stdin , stdout , stderr , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input
def test_223 ( ) : NEW_LINE INDENT import sys NEW_LINE from pybind11_tests import test_223 NEW_LINE t = sys . stdin . readline ( ) . strip ( ) NEW_LINE for j in range ( t ) : NEW_LINE INDENT x = sys . stdin . readline ( ) . strip ( ) NEW_LINE if x == 1 : NEW_LINE INDENT print ( "2" ) NEW_LINE DEDENT elif x == 2 : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT elif x % 3 == 0 : NEW_LINE INDENT print ( x / 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x / 3 + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def import _sys , B999 , reverse NEW_LINE class B999 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . f = open ( " B999 . txt " ) NEW_LINE self . f . readline ( ) NEW_LINE t = int ( self . f . readline ( ) ) NEW_LINE data = self . f . readline ( ) NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT if t % i == 0 : NEW_LINE INDENT data = reverse ( data , i - 1 ) NEW_LINE DEDENT DEDENT print ( data ) NEW_LINE DEDENT def reverse ( self , last ) : NEW_LINE INDENT arr = [ ] NEW_LINE for c in data : NEW_LINE INDENT arr . append ( c ) NEW_LINE DEDENT counter_up , counter_down = 0 , last NEW_LINE for i in range ( 0 , last // 2 ) : NEW_LINE INDENT yield arr [ counter_up : counter_down ] NEW_LINE counter_up += 1 NEW_LINE counter_down -= 1 NEW_LINE DEDENT result = " " NEW_LINE for c in arr : NEW_LINE INDENT result += c NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT
def print_pairs ( arr , n ) : NEW_LINE INDENT import math NEW_LINE import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . arr = arr NEW_LINE DEDENT def print_pairs ( self , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] ) == abs ( arr [ j ] ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if len ( v ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in v : NEW_LINE INDENT print ( - v [ i ] , v [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 4 , 8 , 9 , - 4 , 1 , - 1 , - 8 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE print_pairs ( arr , n ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import factorial NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __getattr__ ( self , attr ) : NEW_LINE INDENT if attr == " _ _ int _ _ " or attr == " _ _ int _ _ " : NEW_LINE INDENT return factorial ( n ) NEW_LINE DEDENT return factorial ( self . _int__ ( attr ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def isPalindrome ( x ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( x ) - 1 NEW_LINE while h > l : NEW_LINE INDENT if x [ l ] != x [ h ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minRemovals ( self ) : NEW_LINE INDENT if x [ 0 ] == 0X : NEW_LINE INDENT return 0 NEW_LINE DEDENT if isPalindrome ( x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT print ( minRemovals ( '010010' ) ) NEW_LINE print ( minRemovals ( '0100101' ) ) NEW_LINE DEDENT DEDENT
def sum_of_substrings ( num ) : NEW_LINE INDENT import random NEW_LINE from math import ceil NEW_LINE n = len ( num ) NEW_LINE sumofdigit = [ num [ 0 ] - '0' ] * n NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = num [ i ] - '0' NEW_LINE sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def test_find_count_of_pairs ( a , b , n ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_count_of_pairs ( self , a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * ( a / n ) * ( b / n ) NEW_LINE ans += ( a / n ) * ( b % n ) NEW_LINE ans += ( a % n ) * ( b / n ) NEW_LINE ans += ( ( a % n ) + ( b % n ) ) / n NEW_LINE return ans NEW_LINE DEDENT DEDENT a , b , n = 5 , 13 , 3 NEW_LINE print ( find_count_of_pairs ( a , b , n ) ) NEW_LINE DEDENT
def p071 ( ) : NEW_LINE INDENT print ( eval ( " p071" ) ) NEW_LINE LIMIT = 1000000 NEW_LINE def run ( ) : NEW_LINE INDENT max_n = 0 NEW_LINE max_d = 1 NEW_LINE for d in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT n = d * 3 // 7 NEW_LINE if d % 7 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT if long ( n ) * max_d > long ( max_n ) * d : NEW_LINE INDENT max_n = n NEW_LINE max_d = d NEW_LINE DEDENT DEDENT return str ( max_n ) NEW_LINE DEDENT return run NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT c = [ 1 ] * 100 NEW_LINE def coef ( n ) : NEW_LINE INDENT c [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ 0 ] = - c [ 0 ] , i NEW_LINE DEDENT c [ 1 + i ] = 1 NEW_LINE for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT c [ j ] = c [ j - 1 ] - c [ j ] NEW_LINE DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT coef ( n ) NEW_LINE c [ 0 ] += 1 NEW_LINE c [ n ] -= 1 NEW_LINE i = n NEW_LINE while ( i > 0 and c [ i ] % n == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT return i < 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 37 NEW_LINE if isPrime ( n ) : NEW_LINE INDENT print ( " Prime " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT min = sys . maxint NEW_LINE counter = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] > min : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT if arr [ i ] <= min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE N = sc . readline ( ) . strip ( ) NEW_LINE x = sc . readline ( ) . strip ( ) NEW_LINE sweet = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = sc . readline ( ) . strip ( ) NEW_LINE sweet . append ( a ) NEW_LINE DEDENT sweet . sort ( ) NEW_LINE num = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if x - sweet [ num ] >= 0 : NEW_LINE INDENT x = x - sweet [ num ] NEW_LINE num += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( num == N ) : NEW_LINE INDENT num -= 1 NEW_LINE DEDENT print ( num ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE leer = raw_input NEW_LINE casos , x , y , conta , cont = 0 , 0 , 0 NEW_LINE casos = leer . __next__ ( ) NEW_LINE for i in range ( casos ) : NEW_LINE INDENT x = leer . __next__ ( ) NEW_LINE y = leer . __next__ ( ) NEW_LINE if x : NEW_LINE INDENT conta += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cont += 1 NEW_LINE DEDENT DEDENT if conta > 1 and cont > 1 : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . raw_input ( ) NEW_LINE DEDENT DEDENT try : NEW_LINE INDENT with open ( " / proc / stations " , " r " ) as sc : NEW_LINE INDENT while True : NEW_LINE INDENT T , D , L = select . select ( [ ] , [ ] , [ ] ) NEW_LINE if T == 0 and D == 0 and L == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans , time = 0 , 0 NEW_LINE for i in range ( T - 1 ) : NEW_LINE INDENT x = sc . next ( ) NEW_LINE if x >= L : NEW_LINE INDENT time = D - 1 NEW_LINE ans += 1 NEW_LINE DEDENT elif time != 0 : NEW_LINE INDENT time -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT sc . close ( ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT DEDENT except KeyboardInterrupt : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def test_minimum_swaps ( arr ) : NEW_LINE INDENT import sys NEW_LINE import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . count = 0 NEW_LINE DEDENT def minimumSwaps ( self ) : NEW_LINE INDENT self . count += 1 NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT if arr [ i ] != i + 1 : NEW_LINE INDENT while arr [ i ] != i + 1 : NEW_LINE INDENT temp = 0 NEW_LINE temp = arr [ arr [ i ] - 1 ] NEW_LINE arr [ arr [ i ] - 1 ] = arr [ i ] NEW_LINE arr [ i ] = temp NEW_LINE self . count += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def p500 ( ) : NEW_LINE INDENT import collections NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE NEW_LINE import p500 NEW_LINE import p500 NEW_LINE import p500 NEW_LINE NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE DEDENT set_bit_no = XOR & ~ ( XOR - 1 ) NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] & set_bit_no : NEW_LINE INDENT x , y = x ^ arr [ i ] , y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ unique ▁ pair ▁ is ▁ ( % d , ▁ % d ) " % ( x , y ) ) NEW_LINE DEDENT
def import _readline NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from . . . import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import BytesIO NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE from io import CustomScanner NEW_LINE NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def do_it ( self ) : NEW_LINE INDENT with open ( ' / etc / init . d / ' ) as sc : NEW_LINE INDENT for line in sc . readlines ( ) : NEW_LINE INDENT data = line . strip ( ) NEW_LINE data = data . split ( ) NEW_LINE for now in data : NEW_LINE INDENT if now != ' @ ' : NEW_LINE INDENT print ( now , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT self . i += 1 NEW_LINE num = data [ i ] - '0' NEW_LINE self . i += 1 NEW_LINE if 0 <= num <= 9 : NEW_LINE INDENT now = data [ i ] NEW_LINE for j in range ( num ) : NEW_LINE INDENT print ( now , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ' ' ) NEW_LINE DEDENT DEDENT obj = Main ( ) NEW_LINE obj . do_it ( ) NEW_LINE DEDENT
def __GFG ( a , n ) : NEW_LINE INDENT import os NEW_LINE import sys NEW_LINE import os NEW_LINE import math NEW_LINE import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def isMajority ( self , n ) : NEW_LINE INDENT mp = { } NEW_LINE for x in range ( n ) : NEW_LINE INDENT if x in mp : NEW_LINE INDENT mp [ x ] = mp [ x ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ x ] = 1 NEW_LINE DEDENT DEDENT for x , y in mp . items ( ) : NEW_LINE INDENT if y >= n / 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if isMajority ( a , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( self . n ) NEW_LINE self . w = int ( self . w ) NEW_LINE knaps = [ _Knap ( self . n , self . w ) for i in range ( self . n ) ] NEW_LINE knaps . sort ( ) NEW_LINE dp = np . zeros ( ( self . n , self . w + 1 ) ) NEW_LINE print ( self . dfw ( self . n - 1 , self . w ) ) NEW_LINE DEDENT def dfw ( self , idx , weight ) : NEW_LINE INDENT if weight < 0 : NEW_LINE INDENT return int ( self . weight ) NEW_LINE DEDENT if idx < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if self . dp [ idx ] [ weight ] != 0 : NEW_LINE INDENT return self . dp [ idx ] [ weight ] NEW_LINE DEDENT if weight % self . knaps [ idx ] [ weight ] == 0 : NEW_LINE INDENT return self . dp [ idx ] [ weight ] = weight / self . knaps [ idx ] [ weight ] * self . knaps [ idx ] [ value ] NEW_LINE DEDENT max = 0 NEW_LINE for i in range ( 0 , self . knaps [ idx ] [ weight ] <= self . weight ) : NEW_LINE INDENT max = max ( max , self . dfw ( self . idx - 1 , self . weight - self . knaps [ idx ] [ weight ] * i ) + self . knaps [ idx ] [ value ] * i ) NEW_LINE DEDENT return self . dp [ idx ] [ weight ] = max NEW_LINE DEDENT def knap ( self , value , weight ) : NEW_LINE INDENT self . value = value NEW_LINE self . weight = weight NEW_LINE DEDENT def knap ( self , another ) : NEW_LINE INDENT return self . value * another . weight - another . value * weight NEW_LINE DEDENT DEDENT
def import math NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . do_it ( ) NEW_LINE DEDENT def do_it ( self ) : NEW_LINE INDENT self . do_it ( ) NEW_LINE DEDENT def do_it ( self ) : NEW_LINE INDENT self . do_it ( ) NEW_LINE DEDENT n = int ( sys . argv [ 1 ] ) NEW_LINE while n != - 1 : NEW_LINE INDENT rad = 0 NEW_LINE hyp = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT rad += math . atan ( 1 / hyp ) NEW_LINE hyp = math . sqrt ( hyp * hyp + 1 ) NEW_LINE DEDENT print ( hyp * math . cos ( rad ) ) NEW_LINE print ( hyp * math . sin ( rad ) ) NEW_LINE n = int ( sys . argv [ 1 ] ) NEW_LINE DEDENT DEDENT
def test_gf_missing ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT arr = [ ] NEW_LINE i = 0 NEW_LINE while i < n and arr [ i ] <= 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT count , curr = 0 , 1 NEW_LINE while count < k and i < n : NEW_LINE INDENT if arr [ i ] != curr : NEW_LINE INDENT print ( curr , end = ' ▁ ' ) NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE curr += 1 NEW_LINE DEDENT DEDENT while count < k : NEW_LINE INDENT print ( curr , end = ' ▁ ' ) NEW_LINE curr += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE gf_missing ( arr , n , k ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE from sympy . utilities . iterables import flatten NEW_LINE from sympy . printing . latex import Printer NEW_LINE mpp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE for j in range ( 1 , 2 ** num ) : NEW_LINE INDENT if num % j == 0 : NEW_LINE INDENT if j != 1 : NEW_LINE INDENT if j in mpp : NEW_LINE INDENT mpp [ j ] = mpp [ j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ j ] = 1 NEW_LINE DEDENT DEDENT if ( num // j ) != j : NEW_LINE INDENT if num // j in mpp : NEW_LINE INDENT mpp [ num // j ] = mpp [ num // j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ num // j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT maxi = 0 NEW_LINE for it , v in sorted ( mpp . items ( ) ) : NEW_LINE INDENT maxi = max ( v , maxi ) NEW_LINE DEDENT for it , v in sorted ( mpp . items ( ) ) : NEW_LINE INDENT if v == maxi : NEW_LINE INDENT print ( it , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def import _cf1146B NEW_LINE class cf1146B ( _cf1146B ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = _cf1146B . data NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . data [ key ] NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . data [ key ] NEW_LINE DEDENT def __len__ ( self ) : NEW_LINE INDENT return len ( self . data ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . data [ key ] NEW_LINE DEDENT def __len__ ( self ) : NEW_LINE INDENT return len ( self . data ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . data [ key ] NEW_LINE DEDENT def __len__ ( self ) : NEW_LINE INDENT return len ( self . data ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . data [ key ] NEW_LINE DEDENT def __len__ ( self ) : NEW_LINE INDENT return len ( self . data ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' : ( ' NEW_LINE DEDENT DEDENT
def import fscanner NEW_LINE import sys NEW_LINE import os NEW_LINE class voting ( object ) : NEW_LINE INDENT def __init__ ( self , f , * args , ** kwargs ) : NEW_LINE INDENT self . f = fscanner ( f , * args , ** kwargs ) NEW_LINE self . n = self . n NEW_LINE self . ans , self . max = 0 , 0 NEW_LINE a = [ 0 ] * 1000001 NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT b = self . f . read ( ) NEW_LINE a [ b ] += 1 NEW_LINE if a [ b ] > self . max : NEW_LINE INDENT self . max = a [ b ] NEW_LINE self . ans = b NEW_LINE DEDENT DEDENT self . f . write ( self . ans ) NEW_LINE self . f . close ( ) NEW_LINE DEDENT def fscanner ( self ) : NEW_LINE INDENT f = open ( self . f ) NEW_LINE lines = f . readlines ( ) NEW_LINE f . close ( ) NEW_LINE for line in lines : NEW_LINE INDENT try : NEW_LINE INDENT line = line . decode ( ' utf - 8' ) NEW_LINE DEDENT except UnicodeDecodeError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return line NEW_LINE DEDENT def fscanner ( self ) : NEW_LINE INDENT return voting ( self ) NEW_LINE DEDENT DEDENT
def GFG ( x ) : NEW_LINE INDENT if x [ 0 ] >= ' A ' and x [ 0 ] <= ' Z ' : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def GFG ( prev_avg , x , n ) : return ( prev_avg * n + x ) / ( n + 1 ) NEW_LINE def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) NEW_LINE print ( " Average ▁ of ▁ % d ▁ numbers ▁ is ▁ % s " % ( i + 1f , " % . 1 f " % avg ) ) NEW_LINE DEDENT return avg NEW_LINE DEDENT
def p050 ( ) : NEW_LINE INDENT print ( eval ( ' p050' ) ( ) ) NEW_LINE LIMIT = library . pow ( 10 , 6 ) NEW_LINE def run ( ) : NEW_LINE INDENT is_prime , primes = library . list_primality ( LIMIT ) NEW_LINE max_sum = 0 NEW_LINE max_run = - 1 NEW_LINE for i in primes : NEW_LINE INDENT sum = 0 NEW_LINE for j in i : NEW_LINE INDENT sum += j NEW_LINE if sum > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT elif j - i > max_run and sum > max_sum and is_prime [ sum ] : NEW_LINE INDENT max_sum = sum NEW_LINE max_run = j - i NEW_LINE DEDENT DEDENT DEDENT return str ( max_sum ) NEW_LINE DEDENT return run NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def lis ( self , arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE lst = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] and lst [ i ] < lst [ j ] + 1 : NEW_LINE INDENT lst [ i ] = lst [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max < lst [ i ] : NEW_LINE INDENT max = lst [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT DEDENT arr = [ 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ lst ▁ is ▁ " , lis ( arr , n ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import math NEW_LINE from math import log10 NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import math NEW_LINE from math import log NEW_LINE from math import sqrt NEW_LINE from math import log NEW_LINE from math import log NEW_LINE a = int ( math . log10 ( b ) ) + 1 NEW_LINE a = int ( a * pow ( 10 , k ) + b ) NEW_LINE yono = sqrt ( a ) NEW_LINE if yono - ceil ( yono ) == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def test_gf_fix ( ) : NEW_LINE INDENT import sympy NEW_LINE import sympy NEW_LINE class GFG ( sympy . combinatorics . combinatorics . perm ) : NEW_LINE INDENT def fix ( self , A ) : NEW_LINE INDENT s = set ( A ) NEW_LINE for i , perm in enumerate ( A ) : NEW_LINE INDENT if perm in s : NEW_LINE INDENT A [ i ] = perm NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = - 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT DEDENT A = [ - 1 , - 1 , 6 , 1 , 9 , 3 , 2 , - 1 , 4 , - 1 ] NEW_LINE print ( sum ( [ i for i in fix ( A ) if i in s ] ) ) NEW_LINE DEDENT
def import import os , sys , logfile , log NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT with open ( self . systemin , ' r ' ) as sc : NEW_LINE INDENT a = sc . read ( ) NEW_LINE b = sc . read ( ) NEW_LINE c = sc . read ( ) NEW_LINE d = sc . read ( ) NEW_LINE sum = a + b + c + d NEW_LINE s1 = abs ( sum - ( a + b ) * 2 ) NEW_LINE s2 = abs ( sum - ( a + c ) * 2 ) NEW_LINE s3 = abs ( sum - ( a + d ) * 2 ) NEW_LINE min = min ( s1 , min ( s2 , s3 ) ) NEW_LINE sys . stdout . write ( " % d \n " % min ) NEW_LINE sc . close ( ) NEW_LINE return False NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT with open ( self . systemin , ' w ' ) as log : NEW_LINE INDENT self . systemin = sys . stdout NEW_LINE DEDENT DEDENT def instance ( self ) : NEW_LINE INDENT self . systemin = sys . stdout NEW_LINE logfile = logfile . name NEW_LINE self . logfile = logfile . name NEW_LINE self . result = instance ( ) NEW_LINE self . systemin . close ( ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = new_data NEW_LINE self . prev , self . next = self . next , self . prev NEW_LINE DEDENT def push ( self , head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . prev = None NEW_LINE new_node . next = ( head_ref , ) NEW_LINE if type ( head_ref ) != Node : ( head_ref ) . prev = new_node NEW_LINE ( head_ref , ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT def make_odd_node ( self , head_ref , A , n ) : NEW_LINE INDENT ptr = head_ref NEW_LINE while ptr : NEW_LINE INDENT next = ptr . next NEW_LINE if ptr . data % 2 == 0 : NEW_LINE INDENT ptr . data = A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ptr = next NEW_LINE DEDENT return head_ref NEW_LINE DEDENT def print_list ( self ) : NEW_LINE INDENT while self . head : NEW_LINE INDENT print ( self . data , end = ' ▁ ' ) NEW_LINE self . head = self . head . next NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT head = None NEW_LINE Arr = [ 3 , 5 , 23 , 17 , 1 ] NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 9 ) NEW_LINE head = push ( head , 6 ) NEW_LINE n = len ( Arr ) NEW_LINE print ( ' Original ▁ List : ▁ ' , end = ' ▁ ' ) NEW_LINE print_list ( head ) NEW_LINE print ( ) NEW_LINE head = make_odd_node ( head , Arr , n ) NEW_LINE print ( ' New ▁ odd ▁ List : ▁ ' , end = ' ▁ ' ) NEW_LINE print_list ( head ) NEW_LINE DEDENT DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdout = sys . stdin NEW_LINE self . dp = [ 0 ] * 11 NEW_LINE self . use = [ False ] * 10 NEW_LINE self . dfs ( 1 , 0 , self . dp , self . use ) NEW_LINE for line in self . stdout : NEW_LINE INDENT values = line . split ( ) NEW_LINE n = int ( values [ 0 ] ) NEW_LINE s = int ( values [ 1 ] ) NEW_LINE if n > 10 or s > 330 : NEW_LINE INDENT print ( '0' ) NEW_LINE continue NEW_LINE DEDENT print ( self . dp [ n ] [ s ] ) NEW_LINE DEDENT DEDENT def dfs ( self , depth , sum , dp , use ) : NEW_LINE INDENT dp [ self . depth - 1 ] [ sum ] += 1 NEW_LINE for i in range ( 0 , 9 ) : NEW_LINE INDENT if not use [ i ] : NEW_LINE INDENT use [ i ] = True NEW_LINE self . dfs ( self . depth + 1 , sum + self . depth * i , dp , use ) NEW_LINE use [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import _GFG NEW_LINE mod = 1000000007 NEW_LINE def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def powmod ( a , n ) : NEW_LINE INDENT if n == 0 : return 1 NEW_LINE pt = powmod ( a , n // 2 ) NEW_LINE pt = ( pt * pt ) % mod NEW_LINE if n % 2 == 1 : return ( pt * a ) % mod NEW_LINE else : return pt NEW_LINE DEDENT def CountSubset ( arr , n ) : NEW_LINE INDENT ans = powmod ( 2 , n - 1 ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while j < n and arr [ j ] == arr [ i ] : NEW_LINE INDENT r = n - 1 - j NEW_LINE l = i NEW_LINE ans = ( ans + nCr ( l + r , l ) ) % mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubset ( arr , n ) ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 1000001 NEW_LINE prime_upto = [ 0 ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT is_prime = [ 1 for i in range ( MAX ) ] NEW_LINE is_prime [ 0 ] = is_prime [ 1 ] = 0 NEW_LINE for i in range ( 2 * MAX ) : NEW_LINE INDENT if is_prime [ i ] == 1 : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT is_prime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT prime_upto [ i ] = prime_upto [ i - 1 ] NEW_LINE if is_prime [ i ] == 1 : NEW_LINE INDENT prime_upto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def count_of_numbers ( N , K ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if mid - prime_upto [ mid ] >= K : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT ans = N - ans + 1 if ans != 0 else 0 NEW_LINE return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N , K = 10 , 3 NEW_LINE print ( count_of_numbers ( N , K ) ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i < n ) and ( n % i ) > 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT i = n NEW_LINE DEDENT return ( 1 + ( n - i ) / 2 ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from os import getenv NEW_LINE from os import fdopen NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os import sep NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os import sep NEW_LINE from os . path import join NEW_LINE Q = len ( sys . argv ) NEW_LINE S = join ( expanduser ( ' ~ ' ) , ' . . ' ) NEW_LINE t = [ ] NEW_LINE for i in range ( 0 , len ( S ) - 1 , 1 ) : NEW_LINE INDENT if S [ i ] == ' A ' and S [ i + 1 ] == ' C ' : NEW_LINE INDENT t . append ( t [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT t . append ( t [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( 0 , Q , 1 ) : NEW_LINE INDENT l = dup_degree ( open ( join ( expanduser ( ' ~ ' ) , ' . . ' ) , ' r ' ) ) NEW_LINE r = dup_degree ( open ( join ( expanduser ( ' ~ ' ) , ' . . ' ) , ' r ' ) ) NEW_LINE os . dup2 ( r , t [ r - 1 ] ) NEW_LINE DEDENT DEDENT
def A_find_divisible ( ) : NEW_LINE INDENT import sys NEW_LINE from os . path import join NEW_LINE from os . path import exists NEW_LINE f = open ( join ( sys . argv [ 1 : ] , ' r ' ) ) NEW_LINE while f . readline ( ) . strip ( ) : NEW_LINE INDENT try : NEW_LINE INDENT l , r = f . readline ( ) . split ( ) NEW_LINE print ( l , int ( l ) * 2 ) NEW_LINE t -= 1 NEW_LINE DEDENT except : NEW_LINE INDENT sys . exit ( 0 ) NEW_LINE DEDENT DEDENT sys . exit ( 0 ) NEW_LINE DEDENT
def p249 ( ) : NEW_LINE INDENT print ( eval ( ' p249 ( ) ' ) ) NEW_LINE LIMIT = 5000 NEW_LINE MODULUS = 10000000000000000L NEW_LINE def run ( ) : NEW_LINE INDENT is_prime = library . list_primality ( LIMIT ** 2 // 2 ) NEW_LINE num_subsets = [ 1 ] * LIMIT ** 2 // 2 NEW_LINE max_sum = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if not is_prime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT max_sum += i NEW_LINE for j in range ( max_sum , i , - 1 ) : NEW_LINE INDENT temp = num_subsets [ j ] + num_subsets [ j - i ] NEW_LINE if temp < MODULUS : NEW_LINE INDENT num_subsets [ j ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT num_subsets [ j ] = temp - MODULUS NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( len ( num_subsets ) ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT sum = ( sum + num_subsets [ i ] ) % MODULUS NEW_LINE DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT return run NEW_LINE DEDENT
def GFG ( row_num ) : NEW_LINE INDENT count = 0 NEW_LINE while row_num > 0 : NEW_LINE INDENT count += row_num & 1 NEW_LINE row_num >>= 1 NEW_LINE DEDENT return ( 1 << count ) NEW_LINE def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( n ) : NEW_LINE INDENT print ( count_odd_number ( row_num ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 16 NEW_LINE gouldSequence ( n ) NEW_LINE DEDENT DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] NEW_LINE self . n = len ( self . deno ) NEW_LINE DEDENT def findMin ( self , V ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( self . n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while V >= self . deno [ i ] : NEW_LINE INDENT V -= self . deno [ i ] NEW_LINE ans . append ( self . deno [ i ] ) NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 93 NEW_LINE print ( ' Following ▁ is ▁ minimal ▁ number ▁ of ▁ change ▁ for ▁ % d ▁ : ▁ ' % n , end = ' ▁ ' ) NEW_LINE findMin ( self . n ) NEW_LINE DEDENT DEDENT
def test_p052 ( ) : NEW_LINE INDENT import math NEW_LINE print ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log10 ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) NEW_LINE DEDENT
def count ( arr , n , x ) : NEW_LINE INDENT import math NEW_LINE class solution : NEW_LINE INDENT def count ( self , n , x ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT ans = long ( math . pow ( 2 , n ) ) - 1 NEW_LINE return ans NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % x == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = long ( math . pow ( 2 , count ) ) - 1 NEW_LINE return ans NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE DEDENT DEDENT solution ( arr , n , x ) NEW_LINE DEDENT
def test_find_ele ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_ele ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == sum - arr [ i ] : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE sys . stdout . write ( find_ele ( arr , n ) ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT m1 = [ 0 ] * 256 NEW_LINE for i in range ( len ( strB ) ) : NEW_LINE INDENT m1 [ strB [ i ] ] += 1 NEW_LINE DEDENT for i in range ( len ( strA ) ) : NEW_LINE INDENT m1 [ strA [ i ] ] -= 1 NEW_LINE DEDENT for i in m1 : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT return chr ( i ) NEW_LINE DEDENT DEDENT return chr ( 0 ) NEW_LINE DEDENT
def import import os , errno NEW_LINE from os import urandom NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE import getopt NEW_LINE class MyOW ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT super ( MyOW , self ) . __init__ ( ) NEW_LINE with self . open ( ' rb ' ) as f : NEW_LINE INDENT self . doit = True NEW_LINE DEDENT DEDENT def aoj1216 ( self ) : NEW_LINE INDENT a = [ ] NEW_LINE b = [ ] NEW_LINE def doit ( ) : NEW_LINE INDENT for i in range ( 101 ) : NEW_LINE INDENT a . append ( i * i * i ) NEW_LINE DEDENT for i in range ( 101 ) : NEW_LINE INDENT b . append ( i * ( i + 1 ) * ( i + 2 ) / 6 ) NEW_LINE DEDENT while True : NEW_LINE INDENT n = os . read ( 1 , os . O_RDONLY ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( 101 ) : NEW_LINE INDENT for j in range ( 101 ) : NEW_LINE INDENT if a [ i ] + b [ j ] <= n : NEW_LINE INDENT num = max ( num , a [ i ] + b [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( num ) NEW_LINE DEDENT DEDENT doit ( ) NEW_LINE DEDENT DEDENT
def import re NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE class Main ( ) : NEW_LINE INDENT def __init__ ( self , stream ) : NEW_LINE INDENT Queue = Queue ( ) NEW_LINE DEDENT def queue ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = stream . get ( ) NEW_LINE if n == 0 : NEW_LINE INDENT stream . clear ( ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT def queue ( self ) : NEW_LINE INDENT return Queue ( ) NEW_LINE DEDENT def queue ( self ) : NEW_LINE INDENT return Queue ( ) NEW_LINE DEDENT def queue ( self ) : NEW_LINE INDENT return Queue ( ) NEW_LINE DEDENT def queue ( self ) : NEW_LINE INDENT return Queue ( ) NEW_LINE DEDENT def queue ( self ) : NEW_LINE INDENT return Queue ( ) NEW_LINE DEDENT def queue ( self ) : NEW_LINE INDENT return Queue ( ) NEW_LINE DEDENT def queue ( self ) : NEW_LINE INDENT depth = 0 NEW_LINE convertable = False NEW_LINE bfs : NEW_LINE INDENT while not self . empty ( ) : NEW_LINE INDENT depth += 1 NEW_LINE self . size = len ( self . size ) NEW_LINE for q in self . size : NEW_LINE INDENT poll = queue ( ) NEW_LINE for p in self . get ( ) : NEW_LINE INDENT test = re . sub ( p , p ) NEW_LINE if test == self . get ( ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif test == self . get ( ) : NEW_LINE INDENT convertable = True NEW_LINE break bfs NEW_LINE DEDENT elif len ( test ) <= len ( self . get ( ) ) : NEW_LINE INDENT self . remove ( test ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if convertable : NEW_LINE INDENT self . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . get ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import import sys , min , max , abs , problem , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hasta_laVistaLa , hast
def AAB ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = sum ( arr1 ) NEW_LINE max2 = sum ( arr2 ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if arr1 [ i ] > max1 : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( n2 ) : NEW_LINE INDENT if arr2 [ i ] > max2 : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT
def operations ( op , n , k ) : NEW_LINE INDENT i , count = 0 , 0 NEW_LINE n_val = 0 NEW_LINE min = sys . maxint NEW_LINE for i in range ( n ) : NEW_LINE INDENT n_val += op [ i ] NEW_LINE min = min ( min , n_val ) NEW_LINE if ( k + n_val ) <= 0 : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT if n_val >= 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT times = ( k - abs ( min ) ) / abs ( n_val ) NEW_LINE k = ( k - ( times * abs ( n_val ) ) ) NEW_LINE count = ( times * n ) NEW_LINE while k > 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT k = k + op [ i ] NEW_LINE count += 1 NEW_LINE if k <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE class GFG ( math ) : NEW_LINE INDENT def __init__ ( self , pref = [ ] ) : NEW_LINE INDENT self . pref = [ ] NEW_LINE DEDENT def isPerfectCube ( x ) : NEW_LINE INDENT cr = round ( math . cbrt ( x ) ) NEW_LINE if cr ** 2 == float ( x ) : return x NEW_LINE return 0 NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100000 ) : NEW_LINE INDENT self . pref . append ( self . pref [ i - 1 ] + isPerfectCube ( i ) ) NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT sum = self . pref [ R ] - self . pref [ L - 1 ] NEW_LINE print ( sum , end = ' ▁ ' ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . compute ( ) NEW_LINE Q = 4 NEW_LINE arr = [ [ 1 , 10 ] , [ 1 , 100 ] , [ 2 , 25 ] , [ 4 , 50 ] ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def import import os , sys , getopt , symbols , string , count , symbol , types , symbols , count , recenter , fra , fra , frb , frc , fra , frb , fra , frb , fra , fra , frb , fra , fra , frb , fra , fra , frb , fra , fra , frb , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , fra , frb , fra , fra , fra , fra , frb , fra , fra , fra , fra , frb , fra , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , fra , frb , fra , fra , fra , fra , frb , fra , fra , fra , frb , fra , fra , fra , fra , fra , frb , fra , fra , frb , fra , fra , fra , frb , fra , fra , frb , fra , fra , frb , fra , frb , fra , fra , frb , fra , frb , fra , fra , frb , fra , frb , fra , fra , fr
def GFG ( n ) : return ( 2 * n + 1 ) * ( n ** 2 + n + 1 ) NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 3 NEW_LINE print ( " { } th ▁ Centered " . format ( self . n ) , end = " " ) NEW_LINE self . print ( self . centered_cube ( n ) ) NEW_LINE self . n = 10 NEW_LINE print ( " { } th ▁ Centered " . format ( self . n ) , end = " " ) NEW_LINE self . print ( self . centered_cube ( n ) ) NEW_LINE DEDENT DEDENT
def import _readline NEW_LINE import sys NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE class pre132 : NEW_LINE INDENT class FastReader : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT return sys . stdin . readline NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not isinstance ( self , chain ) or not isinstance ( self , chain ) : NEW_LINE INDENT try : NEW_LINE INDENT yield self . chain . readline ( ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return next ( self ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return int ( next ( self ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return long ( next ( self ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return double ( next ( self ) ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT data = " " NEW_LINE try : NEW_LINE INDENT data = yield self . readline ( ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT pass NEW_LINE DEDENT return data NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT obj = chain ( repeat ( args ) , repeat ( args ) ) NEW_LINE tc = obj . count NEW_LINE while tc : NEW_LINE INDENT n = obj . count NEW_LINE arr = obj . next ( ) . decode ( ' ascii ' ) NEW_LINE r , l = n - 1 , - 1 NEW_LINE while r >= 0 and arr [ r ] == '1' : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT while l + 1 < n and arr [ 0 ] == '0' and arr [ l + 1 ] == '0' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT flag = [ True for i in range ( 0 , l ) ] NEW_LINE for i in range ( n - 1 , r , - 1 ) : NEW_LINE INDENT flag [ i ] = repeat ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if flag [ i ] : NEW_LINE INDENT out . write ( arr [ i ] ) NEW_LINE DEDENT out . write ( " \n " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def nth_term ( N ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def nth_term ( self ) : NEW_LINE INDENT nth , i = 0 , self . n NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT nth += math . pow ( i , i ) NEW_LINE DEDENT return nth NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT N = 3 NEW_LINE print ( nth_term ( N ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def Test ( ) : NEW_LINE INDENT print ( ' True ' if isPower ( 10 , 1 ) else ' False ' ) NEW_LINE print ( ' True ' if isPower ( 1 , 20 ) else ' False ' ) NEW_LINE print ( ' True ' if isPower ( 2 , 128 ) else ' False ' ) NEW_LINE print ( ' True ' if isPower ( 2 , 30 ) else ' False ' ) NEW_LINE def isPower ( x , y ) : NEW_LINE INDENT if x == 1 : return ( y == 1 ) NEW_LINE pow = 1 NEW_LINE while pow < y : pow = pow * x NEW_LINE return ( pow == y ) NEW_LINE DEDENT return isPower ( 10 , 1 ) NEW_LINE DEDENT
def Test ( ) : NEW_LINE INDENT print ( 1 if isPower ( 10 , 1 ) else 0 ) NEW_LINE print ( 1 if isPower ( 1 , 20 ) else 0 ) NEW_LINE print ( 1 if isPower ( 2 , 128 ) else 0 ) NEW_LINE print ( 1 if isPower ( 2 , 30 ) else 0 ) NEW_LINE def isPower ( x , y ) : NEW_LINE INDENT if x == 1 : return ( y == 1 ) NEW_LINE pow = 1 NEW_LINE while pow < y : pow = pow * x NEW_LINE return ( pow == y ) NEW_LINE DEDENT return isPower ( 10 , 1 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def minimum_value ( self , arr , n , k ) : NEW_LINE INDENT arr = arr [ n : ] NEW_LINE answer = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] NEW_LINE DEDENT return answer * ( 2 ** k - 2 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 4 , 21 , 5 , 3 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( minimum_value ( arr , n , k ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from collections import deque NEW_LINE from os . path import join NEW_LINE sc = open ( join ( sys . argv [ 1 : ] , ' r ' ) , ' r ' ) NEW_LINE N = len ( sc . readlines ( ) ) NEW_LINE vs = set ( ) NEW_LINE indeg = { } NEW_LINE outdeg = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT u , d , rel = ' u ' + sc . readline ( ) . split ( ) NEW_LINE d = ' d ' + sc . readline ( ) . split ( ) [ 0 ] NEW_LINE vs . add ( u ) NEW_LINE vs . add ( d ) NEW_LINE indeg . setdefault ( u , set ( ) ) NEW_LINE indeg . setdefault ( d , set ( ) ) NEW_LINE outdeg . setdefault ( u , set ( ) ) NEW_LINE outdeg . setdefault ( d , set ( ) ) NEW_LINE if rel == ' lock ' : NEW_LINE INDENT indeg [ u ] . add ( d ) NEW_LINE outdeg [ d ] . add ( u ) NEW_LINE DEDENT else : NEW_LINE INDENT indeg [ d ] . add ( u ) NEW_LINE outdeg [ u ] . add ( d ) NEW_LINE DEDENT DEDENT que = deque ( ) NEW_LINE for v in indeg : NEW_LINE INDENT if len ( indeg [ v ] ) == 0 : NEW_LINE INDENT que . append ( v ) NEW_LINE DEDENT DEDENT while not que . empty ( ) : NEW_LINE INDENT u = que . popleft ( ) NEW_LINE for v in outdeg [ u ] : NEW_LINE INDENT indeg [ v ] . remove ( u ) NEW_LINE if len ( indeg [ v ] ) == 0 : NEW_LINE INDENT que . append ( v ) NEW_LINE DEDENT DEDENT del vs [ u ] NEW_LINE DEDENT print ( len ( vs ) == 0 ) NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) // 2 NEW_LINE if N == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : return 0 NEW_LINE if a == b : return a NEW_LINE if a > b : return __gcd ( a - b , b ) NEW_LINE return __gcd ( a , b - a ) NEW_LINE def find_lcm ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) / __gcd ( arr [ i ] , lcm ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def count_numbers ( arr , n , l , r ) : NEW_LINE INDENT lcm = find_lcm ( arr , n ) NEW_LINE count = ( r / lcm ) - ( ( l - 1 ) / lcm ) NEW_LINE return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 4 , 2 ] NEW_LINE n , l , r = arr NEW_LINE print ( count_numbers ( arr , n , l , r ) ) NEW_LINE DEDENT DEDENT
def import import os , sys , stdin , stdout , stderr , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , output , input , input , input , input , input , input , input , input , input , input , input , input , output , input , input , input , input , input , input , input , input , input , input , input , input , output , input , input , input , input , input , input , input , input , input , output , input , input , input , input , input , input , input , input , input , output , input , input , input , input , input , input , input , output , input , input , input , input , input , input , output , input , input , input , input , output , input , input , input , input , input , output , input , input , input , input , input , output , input , input , input , input , output , input , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , input , output , input , input , input , output , input , input , output , input , input , input , output , input , input , input , output , input , input , output , input , input , output , input , input , output , input , input , output , input , input , output , input , output , input , input , output , input , input , output , input , input , output , input , output , input , input , output , input , output , input , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , output , input , output , input , output , output , input , output , input , output , output , output , input , output , output , output , input , output , output , input , output , output , output , output , input , output , output , output , input , output , output , output , output , output , output
def import import sys , string , traceback NEW_LINE class Run ( object ) : NEW_LINE INDENT def __init__ ( self , Z ) : NEW_LINE INDENT self . Z = Z NEW_LINE self . T = int ( self . Z ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT self . Z = Z NEW_LINE self . T -= 1 NEW_LINE self . n = int ( self . Z [ 0 ] ) NEW_LINE self . stz = self . Z [ 1 : ] NEW_LINE self . a = [ int ( i ) for i in self . stz ] NEW_LINE yes = True NEW_LINE self . a = [ i for i in self . a if i != self . n ] NEW_LINE area = self . a [ 0 ] * self . a [ - 1 ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT lf , rg = self . i * 2 , self . rg - ( self . i * 2 ) - 1 NEW_LINE if ( a [ lf ] != a [ lf + 1 ] ) or ( a [ rg ] != a [ rg - 1 ] ) or ( a [ lf ] * a [ rg ] != area ) : NEW_LINE INDENT yes = False NEW_LINE break NEW_LINE DEDENT DEDENT if yes : NEW_LINE INDENT self . op . append ( ' YES \n ' ) NEW_LINE DEDENT else : NEW_LINE INDENT self . op . append ( ' NO \n ' ) NEW_LINE DEDENT DEDENT print ( ' \n ' . join ( op ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import os NEW_LINE class GFG ( object ) : NEW_LINE INDENT def MinDeletion ( self , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mp . has_key ( i ) : NEW_LINE INDENT mp [ i ] = mp [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i , frequency in mp . items ( ) : NEW_LINE INDENT if x <= frequency : NEW_LINE INDENT ans += ( frequency - x ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += frequency NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE print ( MinDeletion ( a , n ) ) NEW_LINE DEDENT
def delete_n ( args ) : NEW_LINE INDENT inp = 1234 NEW_LINE inp = str ( inp ) NEW_LINE del inp = 3 NEW_LINE print ( " num _ after _ deleting _ from _ starting ▁ " + str ( from_start ( inp , del ) ) ) NEW_LINE print ( " num _ after _ deleting _ from _ ending ▁ " + str ( from_end ( inp , del ) ) ) NEW_LINE def from_start ( inp , del ) : NEW_LINE INDENT try : NEW_LINE INDENT inp1 = inp [ : del - 1 ] NEW_LINE inp2 = inp [ del : ] NEW_LINE return inp1 + inp2 NEW_LINE DEDENT except : NEW_LINE INDENT return " Check ▁ Input " NEW_LINE DEDENT DEDENT def from_end ( inp , del ) : NEW_LINE INDENT try : NEW_LINE INDENT inp1 = inp [ : - del ] NEW_LINE inp2 = inp [ - del + 1 : ] NEW_LINE return inp1 + inp2 NEW_LINE DEDENT except : NEW_LINE INDENT return " Check ▁ Input " NEW_LINE DEDENT DEDENT return " delete _ n " NEW_LINE DEDENT
def nondecdigits ( n ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import math NEW_LINE from math import ceil NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10 NEW_LINE from math import log10
def import import sys , traceback NEW_LINE import inspect NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdin = sys . stdin NEW_LINE self . stdout = sys . stdout NEW_LINE self . stdin . close ( ) NEW_LINE self . stdout = sys . stdout NEW_LINE self . x1 , self . y1 , self . x2 , self . y2 = self . stdin . split ( ' \n ' ) NEW_LINE if self . x1 == self . x2 : NEW_LINE INDENT dif = abs ( y1 - self . y2 ) NEW_LINE self . stdout . write ( ( self . x1 + dif , y1 , self . x1 + dif , self . y2 ) ) NEW_LINE DEDENT elif self . y1 == self . y2 : NEW_LINE INDENT dif = abs ( x1 - self . x2 ) NEW_LINE self . stdout . write ( ( self . x1 , self . y1 + dif , self . x2 , self . y2 + dif ) ) NEW_LINE DEDENT elif abs ( self . x1 - self . x2 ) == abs ( self . y1 - self . y2 ) : NEW_LINE INDENT self . stdout . write ( ' % s ▁ % s ▁ % s ▁ % s ' % ( self . x1 , self . y2 , self . x2 , self . y1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . stdout . write ( ' % s \n ' % self . x2 ) NEW_LINE DEDENT DEDENT def debug ( * obj ) : NEW_LINE INDENT sys . stderr . write ( " ▁ " . join ( obj ) + " \n " ) NEW_LINE DEDENT DEDENT
def import _bucketize NEW_LINE class BusGame ( object ) : NEW_LINE INDENT def can_take ( self , x_needed , x_available , y_needed , y_available ) : NEW_LINE INDENT if x_needed > x_available : return False NEW_LINE if y_needed > y_available : return False NEW_LINE return True NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT f = open ( self . path ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . readline ( ) NEW_LINE f . close ( ) NEW_LINE x = int ( f . readline ( ) ) NEW_LINE y = int ( f . readline ( ) ) NEW_LINE turn = 0 NEW_LINE while True : NEW_LINE INDENT if turn % 2 == 0 : NEW_LINE INDENT if can_take ( 2 , x , 2 , y ) : NEW_LINE INDENT x -= 2 NEW_LINE y -= 2 NEW_LINE DEDENT elif can_take ( 1 , x , 12 , y ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 12 NEW_LINE DEDENT elif can_take ( 0 , x , 22 , y ) : NEW_LINE INDENT y -= 22 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Hanako " ) NEW_LINE return NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if can_take ( 0 , x , 22 , y ) : NEW_LINE INDENT y -= 22 NEW_LINE DEDENT elif can_take ( 1 , x , 12 , y ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 12 NEW_LINE DEDENT elif can_take ( 2 , x , 2 , y ) : NEW_LINE INDENT x -= 2 NEW_LINE y -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Ciel " ) NEW_LINE return NEW_LINE DEDENT DEDENT turn += 1 NEW_LINE DEDENT DEDENT return BusGame NEW_LINE DEDENT
def import import sys , StringIO , StringIO , sys NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE from dask . chessboard import chessboard NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from flipping_game import check_no NEW_LINE if sys . stdin . isatty ( ) : NEW_LINE INDENT n = sys . stdin . readline ( ) . strip ( ) NEW_LINE arr = [ i for i in range ( n ) ] NEW_LINE max = sys . maxint NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT x = 0 NEW_LINE brr = [ k for k in arr if x == k ] NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT if brr [ k ] == 0 : NEW_LINE INDENT brr [ k ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT brr [ k ] = 0 NEW_LINE DEDENT DEDENT count = check_no ( brr ) NEW_LINE if count > max : NEW_LINE INDENT max = count NEW_LINE DEDENT DEDENT DEDENT if n == 1 : NEW_LINE INDENT if arr [ 0 ] == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( max ) NEW_LINE DEDENT DEDENT def check_no ( brr ) : NEW_LINE INDENT val = 0 NEW_LINE for i in brr : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT val += 1 NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT return NEW_LINE DEDENT
def count_distict_subarray ( arr , n ) : NEW_LINE INDENT import collections NEW_LINE class Test ( object ) : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE if not self . has_key ( key ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return super ( Test , self ) . __getitem__ ( key ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT vis = { } NEW_LINE DEDENT k = len ( vis ) NEW_LINE vis = vis . copy ( ) NEW_LINE ans , right , window = 0 , 0 , 0 NEW_LINE for left in range ( n ) : NEW_LINE INDENT while right < n and window < k : NEW_LINE INDENT vis [ right ] = vis [ right ] + 1 NEW_LINE if vis [ right ] == 1 : NEW_LINE INDENT window += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if window == k : NEW_LINE INDENT ans += ( n - right + 1 ) NEW_LINE DEDENT vis [ left ] = vis [ left ] - 1 NEW_LINE if vis [ left ] == 0 : NEW_LINE INDENT window -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def import import struct NEW_LINE from os import urandom NEW_LINE from io import BytesIO NEW_LINE from struct import Struct NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from os import fdopen NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from os import fdopen NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from os import os_encoding NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE DEDENT
def _gf_prime ( n ) : NEW_LINE INDENT from sympy . combinatorics . factorials import gcd NEW_LINE if n <= 1 : return False NEW_LINE if n <= 3 : return True NEW_LINE if n % 2 == 0 or n % 3 == 0 : return False NEW_LINE for i in range ( 5 , n ** 2 + 6 ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : return False NEW_LINE DEDENT return True NEW_LINE DEDENT def primeBitsInRange ( l , r ) : NEW_LINE INDENT tot_bit , count = 0 , 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT tot_bit = gcd ( i , l ) NEW_LINE if gcd ( tot_bit ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = count_set_bits ( arr [ i ] ) + count_set_bits ( arr [ j ] ) NEW_LINE if sum == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE DEDENT DEDENT
def Reverse ( ) : NEW_LINE INDENT import Queue NEW_LINE import Queue NEW_LINE import sys NEW_LINE import sys NEW_LINE class Reverse_k_element_queue : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . queue = Queue ( ) NEW_LINE DEDENT def reverse ( self ) : NEW_LINE INDENT if self . queue == True or k > len ( self . queue ) : NEW_LINE INDENT return NEW_LINE DEDENT if k <= 0 : NEW_LINE INDENT return NEW_LINE DEDENT stack = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT stack . append ( self . queue [ - 1 ] ) NEW_LINE self . queue . pop ( ) NEW_LINE DEDENT while not stack . empty ( ) : NEW_LINE INDENT self . queue . append ( self . stack [ - 1 ] ) NEW_LINE self . stack . pop ( ) NEW_LINE DEDENT for i in range ( len ( self . queue ) - k ) : NEW_LINE INDENT self . queue . append ( self . queue [ - 1 ] ) NEW_LINE self . queue . pop ( ) NEW_LINE DEDENT DEDENT def Print ( self ) : NEW_LINE INDENT while not self . queue . empty ( ) : NEW_LINE INDENT print ( self . queue . pop ( ) , end = ' ▁ ' ) NEW_LINE self . queue . pop ( ) NEW_LINE DEDENT DEDENT def Main ( self , args ) : NEW_LINE INDENT self . queue = Queue ( ) NEW_LINE self . queue . append ( 10 ) NEW_LINE self . queue . append ( 20 ) NEW_LINE self . queue . append ( 30 ) NEW_LINE self . queue . append ( 40 ) NEW_LINE self . queue . append ( 50 ) NEW_LINE self . queue . append ( 60 ) NEW_LINE self . queue . append ( 70 ) NEW_LINE self . queue . append ( 80 ) NEW_LINE self . queue . append ( 90 ) NEW_LINE self . queue . append ( 100 ) NEW_LINE DEDENT DEDENT DEDENT
def import import sys , string , os , sys , sys , platform , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api , win32api ,
def GFG ( k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( k + 1 ) & k ) == 0 : NEW_LINE INDENT return k / 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def Solution ( num ) : NEW_LINE INDENT low = 1 NEW_LINE high = num NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if mid * mid == num : NEW_LINE INDENT return True NEW_LINE DEDENT elif mid * mid < num : NEW_LINE INDENT low = int ( mid + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT high = int ( mid - 1 ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def import import * NEW_LINE import sys NEW_LINE import string NEW_LINE import string NEW_LINE import math NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT Scanner ( ) NEW_LINE self . a = int ( self . a ) NEW_LINE self . b = int ( self . b ) NEW_LINE self . c = int ( self . c ) NEW_LINE self . result = " No " NEW_LINE if max ( a , max ( b , c ) ) * 2 == a + b + c : NEW_LINE INDENT self . result = " Yes " NEW_LINE DEDENT print ( self . result ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not self . hasNext ( ) : NEW_LINE INDENT self . next = self . next NEW_LINE DEDENT return self . next NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while self . hasNext ( ) : NEW_LINE INDENT self . next = self . next NEW_LINE DEDENT return self . next NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return string . strip ( self . result ) NEW_LINE DEDENT DEDENT
def import import sys , string , count , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , comment , line , line , line , comment , line , line , comment , line , line , line , comment , line , line , line , comment , line , line , line , comment , line , line , line , comment , line , line , line , comment , line , line , line , comment , line , line , line , comment , line , line , line , comment , line , line , line , comment , line , line , line , comment , line , line , line , comment , line , line , line , line , comment , line , line , line , line , comment , line , line , line , line , line , comment , line , line , line , line , line , line , comment , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line , line
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE SIZE = 100000 NEW_LINE x = [ ] NEW_LINE head = tail = 0 NEW_LINE def dequeue ( ) : NEW_LINE INDENT if is_empty ( ) : NEW_LINE INDENT raise Exception ( ' You ▁ dequeued ▁ from ▁ empty ▁ ' ' queue . ' ) NEW_LINE DEDENT value = x [ tail ] NEW_LINE tail += 1 NEW_LINE if tail == SIZE : NEW_LINE INDENT tail -= SIZE NEW_LINE DEDENT return value NEW_LINE DEDENT def enqueue ( ) : NEW_LINE INDENT if is_full ( ) : NEW_LINE INDENT raise Exception ( ' You ▁ enqueued ▁ to ▁ full ▁ queue . ' ) NEW_LINE DEDENT x . append ( process ) NEW_LINE head += 1 NEW_LINE if head == SIZE : NEW_LINE INDENT head -= SIZE NEW_LINE DEDENT DEDENT def is_full ( ) : NEW_LINE INDENT return head + 1 == ( tail % SIZE ) NEW_LINE DEDENT def is_empty ( ) : NEW_LINE INDENT return head == tail NEW_LINE DEDENT class Process ( object ) : NEW_LINE INDENT def __init__ ( self , name , quantum ) : NEW_LINE INDENT self . name = name NEW_LINE self . quantum = quantum NEW_LINE DEDENT DEDENT DEDENT
def find_element ( arr , ranges , rotations , index ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . arr = arr NEW_LINE self . ranges = ranges NEW_LINE self . rotations = rotations NEW_LINE self . index = index NEW_LINE DEDENT DEDENT for left , right in zip ( range ( rotations - 1 , - 1 , - 1 ) , range ( rotations ) ) : NEW_LINE INDENT if left <= index and right >= index : NEW_LINE INDENT if index == left : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index -= 1 NEW_LINE DEDENT DEDENT DEDENT return GFG ( arr , ranges , index ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT MAXN = 1000001 NEW_LINE spf = [ ] NEW_LINE hash1 = { } NEW_LINE def sieve ( ) : NEW_LINE INDENT spf . append ( 1 ) NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf . append ( i ) NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf . append ( 2 ) NEW_LINE DEDENT for i in range ( 3 , MAXN * i , 2 ) : NEW_LINE INDENT if spf [ i ] == i : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if spf [ j ] == j : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while x != 1 : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if x % temp == 0 : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x / spf [ x ] NEW_LINE DEDENT while x % temp == 0 : NEW_LINE INDENT x = x / temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while x != 1 : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if x % temp == 0 and hash1 [ temp ] > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT while x % temp == 0 : NEW_LINE INDENT x = x / temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if check ( arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if hasValidNum ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def isExists ( a , n ) : NEW_LINE INDENT import os NEW_LINE class Solution : NEW_LINE INDENT def isExists ( self , n ) : NEW_LINE INDENT freq = { } NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] = freq . get ( a [ i ] , None ) or 0 NEW_LINE sum += a [ i ] NEW_LINE DEDENT if sum % 2 == 0 : NEW_LINE INDENT if freq [ sum / 2 ] : return True NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT a = [ 5 , 1 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if isExists ( a , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT return Solution ( a , n ) NEW_LINE DEDENT
def GFG ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE return area NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE from numpy . testing import assert_array_equal NEW_LINE DEDENT
def import _codeforces NEW_LINE class code_forces ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT sc = _codeforces ( ) NEW_LINE n = sc . number NEW_LINE if ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n < 10 : NEW_LINE INDENT return False NEW_LINE DEDENT prod_odd , prod_even = 1 , 1 NEW_LINE while n > 0 : NEW_LINE INDENT digit = n % 10 NEW_LINE prod_odd *= digit NEW_LINE n /= 10 NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT digit = n % 10 NEW_LINE prod_even *= digit NEW_LINE n /= 10 NEW_LINE DEDENT if prod_even == prod_odd : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def import readline NEW_LINE import sys NEW_LINE from io import BytesIO NEW_LINE from codecs import BOM_UTF8 NEW_LINE from codecs import BOM_UTF8 NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF8 NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF8 NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF8 NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF8 NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF8 NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF8 NEW_LINE from codecs import BOM_UTF8 NEW_LINE from codecs import BOM_UTF8 NEW_LINE from codecs import BOM_UTFUTFUTF16_BE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF16_LE NEW_LINE from codecs import BOM_UTF8 NEW_LINE DEDENT
def test_gf_even_odd ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . arr = np . array ( [ 1 , 1 , 0 , 1 ] ) NEW_LINE self . n = np . array ( [ 1 , 1 , 0 , 1 ] ) NEW_LINE self . l = np . array ( [ 1 , 1 , 1 , 1 ] ) NEW_LINE self . r = np . array ( [ 1 , 1 , 1 , 1 ] ) NEW_LINE DEDENT def test ( self ) : NEW_LINE INDENT arr = np . array ( [ 1 , 1 , 0 , 1 ] ) NEW_LINE self . n = np . array ( [ 1 , 1 , 3 ] ) NEW_LINE self . r = np . array ( [ 1 , 1 , 1 , 1 ] ) NEW_LINE self . l = np . array ( [ 1 , 1 , 1 , 1 ] ) NEW_LINE self . r = np . array ( [ 1 , 1 , 1 , 1 ] ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdout = sys . stdin NEW_LINE try : NEW_LINE INDENT data = self . stdout . read ( ) NEW_LINE DEDENT except : NEW_LINE INDENT print ( " ? ? ¨ ? ? ? ? " ) NEW_LINE DEDENT else : NEW_LINE INDENT split = data . split ( ) NEW_LINE w , h = int ( split [ 0 ] ) , int ( split [ 1 ] ) NEW_LINE x , y , r = int ( split [ 2 ] ) , int ( split [ 3 ] ) , int ( split [ 4 ] ) NEW_LINE if ( x - r >= 0 and x + r <= w and y - r >= 0 and y + r <= h ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n <= 1 : return False NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : return False NEW_LINE DEDENT return True NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while num > 0 : NEW_LINE INDENT if isPrime ( num ) : return num NEW_LINE num = num + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if isPrime ( sum ) : return 0 NEW_LINE num = findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minNumber ( arr , n ) ) NEW_LINE DEDENT
def compositeProduct ( arr , n ) : NEW_LINE INDENT import numpy NEW_LINE max_val = numpy . max ( arr ) NEW_LINE prime = numpy . zeros ( max_val + 1 , dtype = bool ) NEW_LINE prime [ 0 ] = True NEW_LINE prime [ 1 ] = True NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not prime [ arr [ i ] ] : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . intx = None NEW_LINE self . inty = None NEW_LINE self . intwork = None NEW_LINE try : NEW_LINE INDENT f = open ( sys . argv [ 1 ] ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT print ( sys . exc_info ( ) [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while 1 : NEW_LINE INDENT strLine = f . readline ( ) NEW_LINE if strLine : NEW_LINE INDENT str_num_list = strLine . split ( ) NEW_LINE intx = int ( str_num_list [ 0 ] ) NEW_LINE inty = int ( str_num_list [ 1 ] ) NEW_LINE if intx != None or inty != None : NEW_LINE INDENT if intx > inty : NEW_LINE INDENT intwork = intx NEW_LINE intx = inty NEW_LINE inty = intwork NEW_LINE DEDENT print ( intx , inty ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import os NEW_LINE strarr = ( ' FILIPINO ' , ' JAPANESE ' , ' KOREAN ' ) NEW_LINE s = os . popen ( ' cat ▁ ' + strarr ) NEW_LINE t = s . read ( ) . split ( ) NEW_LINE index_word = 0 NEW_LINE for s1 in s : NEW_LINE INDENT if s1 . endswith ( ' po ' ) : NEW_LINE INDENT index_word = 0 NEW_LINE DEDENT elif s1 . endswith ( ' mnida ' ) : NEW_LINE INDENT index_word = 2 NEW_LINE DEDENT else : NEW_LINE INDENT index_word = 1 NEW_LINE DEDENT print ( strarr [ index_word ] ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n , left , right ) : NEW_LINE INDENT k = right - left NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 NEW_LINE return ans NEW_LINE DEDENT
def maxResult ( n , a , b , c ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . maxVal = 0 NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if math . floor ( z ) == math . ceil ( z ) : NEW_LINE INDENT x = i / a NEW_LINE y = j / b NEW_LINE self . maxVal = max ( self . maxVal , x + y + int ( z ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return GFG ( n , a , b , c ) NEW_LINE DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , a ) : NEW_LINE INDENT self . a = a NEW_LINE DEDENT def sort ( self ) : NEW_LINE INDENT for i in range ( len ( self ) - 1 ) : NEW_LINE INDENT for j in range ( len ( self ) - 1 , i , - 1 ) : NEW_LINE INDENT if self . a [ j ] > self . a [ j - 1 ] : NEW_LINE INDENT t = self . a [ j ] NEW_LINE self . a [ j ] = self . a [ j - 1 ] NEW_LINE self . a [ j - 1 ] = t NEW_LINE DEDENT DEDENT DEDENT DEDENT def print_hill ( self ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT print ( self . a [ i ] ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT hills = [ ] NEW_LINE inp = sys . stdin . readline ( ) NEW_LINE bre = inp . decode ( ' utf - 8' ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT num = bre . readline ( ) NEW_LINE n = int ( num ) NEW_LINE hills . append ( n ) NEW_LINE DEDENT sort ( hills ) NEW_LINE print_hill ( hills ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import factorial NEW_LINE def fact ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT def number_of_possible_pallindrome ( x , n ) : NEW_LINE INDENT mp = { x : 1 if x [ i ] == 0 else mp . get ( x [ i ] , 0 ) + 1 for i in range ( n ) } NEW_LINE k = 0 NEW_LINE num = 0 NEW_LINE den = 1 NEW_LINE for it , v in mp . items ( ) : NEW_LINE INDENT if v % 2 == 0 : NEW_LINE INDENT fi = v // 2 NEW_LINE DEDENT else : NEW_LINE INDENT fi = ( v - 1 ) // 2 NEW_LINE k += 1 NEW_LINE DEDENT num = num + fi NEW_LINE den = den * fact ( fi ) NEW_LINE DEDENT if num != 0 : NEW_LINE INDENT num = fact ( num ) NEW_LINE DEDENT ans = num / den NEW_LINE if k != 0 : NEW_LINE INDENT ans = ans * k NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = ' ababab ' NEW_LINE n = len ( x ) NEW_LINE print ( number_of_possible_pallindrome ( x , n ) ) NEW_LINE DEDENT DEDENT
def main ( args ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE from math import ceil NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE DEDENT
def _ ( n , m ) : NEW_LINE INDENT import sys NEW_LINE import gc NEW_LINE class GfG ( gc . Gg ) : NEW_LINE INDENT def toggle_last_mb_its ( self , n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def main ( self , argc ) : NEW_LINE INDENT n = 107 NEW_LINE m = 4 NEW_LINE n = toggle_last_mb_its ( n , m ) NEW_LINE print ( n ) NEW_LINE DEDENT DEDENT return GfG NEW_LINE DEDENT
def import _cf1672b NEW_LINE class cf1672b ( _cf1672b ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = _cf1672b NEW_LINE self . t = len ( self . t ) NEW_LINE DEDENT def f ( self ) : NEW_LINE INDENT s = self . t NEW_LINE a , b = 0 , 0 NEW_LINE f = True NEW_LINE for ch in s : NEW_LINE INDENT if ch == ' A ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE if a < b : NEW_LINE INDENT self . t = t NEW_LINE f = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if f : NEW_LINE INDENT if b != 0 and s [ - 1 ] == ' B ' : NEW_LINE INDENT self . t = t NEW_LINE DEDENT else : NEW_LINE INDENT self . t = t NEW_LINE DEDENT DEDENT DEDENT DEDENT
def _ import _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _
def _import ( ) : NEW_LINE INDENT import string NEW_LINE import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def count_consecutive ( self , n ) : NEW_LINE INDENT s = string . ascii_lowercase NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT n = 44522255 NEW_LINE print ( count_consecutive ( n ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def test_find_angle ( ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . math ) : NEW_LINE INDENT def find_angle ( self , n ) : NEW_LINE INDENT interior_angle , exterior_angle = ( n - 2 ) * 180 / n , 360 / n NEW_LINE print ( " Interior ▁ angle : ▁ " , interior_angle ) NEW_LINE print ( " Exterior ▁ angle : ▁ " , exterior_angle ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE GFG ( n ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT smallest = int ( math . ceil ( math . sqrt ( math . pow ( 10 , n - 1 ) ) ) ) NEW_LINE print ( smallest , end = " ▁ " ) NEW_LINE largest = int ( math . ceil ( math . sqrt ( math . pow ( 10 , n ) ) ) - 1 ) NEW_LINE print ( largest , end = " ▁ " ) NEW_LINE DEDENT
def import _solve NEW_LINE class A ( object ) : NEW_LINE INDENT def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT super ( A , self ) . __init__ ( * args , ** kwargs ) NEW_LINE self . solve ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT f = _solve ( ) NEW_LINE t = len ( f ) NEW_LINE while t > 0 : NEW_LINE INDENT n = len ( f ) NEW_LINE message = [ x for x in f if x != t ] NEW_LINE self . _identify_message ( message , n ) NEW_LINE DEDENT DEDENT def identify_message ( self , n ) : NEW_LINE INDENT self . _identify_message ( self , n ) NEW_LINE self . _identify_message ( self , n ) NEW_LINE self . _identify_message ( self , n ) NEW_LINE DEDENT def identify_message ( self , message ) : NEW_LINE INDENT self . _identify_message ( message , n ) NEW_LINE self . _identify_message ( message , n ) NEW_LINE self . _identify_message ( message , n ) NEW_LINE DEDENT DEDENT
def _import ( ) : return solve ( ) NEW_LINE class akarshanand2810 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . solve ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT sc = io . open ( self . filename , ' r ' ) NEW_LINE f = io . open ( self . filename , ' w ' ) NEW_LINE n = sc . __next__ ( ) NEW_LINE arr = sc . next ( ) . split ( ) NEW_LINE cnt = 0 NEW_LINE idx = [ ] NEW_LINE for i in range ( n - 1 , i + 2 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE idx . append ( i ) NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE for index in idx : NEW_LINE INDENT if arr [ index ] == ' a ' : NEW_LINE INDENT arr [ index ] = ' b ' NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = ' a ' NEW_LINE DEDENT DEDENT f . write ( ' ' . join ( arr ) ) NEW_LINE f . flush ( ) NEW_LINE DEDENT class reader ( object ) : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT while not self . readline or not self . readline : NEW_LINE INDENT try : NEW_LINE INDENT self . readline ( ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return self . readline ( ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return int ( self . __next__ ( ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return long ( self . __next__ ( ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return float ( self . __next__ ( ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return float ( self . __next__ ( ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return int ( self . __next__ ( ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return long ( self . __next__ ( ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return float ( self . __next__ ( ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return next ( self . __next__ ( ) ) NEW_LINE DEDENT DEDENT DEDENT return akarshanand2810 NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT if n == 0 : return 1 NEW_LINE p = power ( a , n // 2 ) NEW_LINE p = p * p NEW_LINE if n % 2 == 1 : p = p * a NEW_LINE return p NEW_LINE DEDENT def solve ( i , n , sum , k , a , prefix ) : NEW_LINE INDENT if sum > k : NEW_LINE INDENT discard_count += power ( 2 , n - i ) NEW_LINE return NEW_LINE DEDENT if i == n : return NEW_LINE rem = prefix [ n - 1 ] - prefix [ i ] NEW_LINE if sum + a [ i ] + rem > k : NEW_LINE INDENT solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) NEW_LINE DEDENT if sum + rem > k : NEW_LINE INDENT solve ( i + 1 , n , sum , k , a , prefix ) NEW_LINE DEDENT DEDENT def count_subsequences ( arr , n , K ) : NEW_LINE INDENT sum = 0. NEW_LINE k = float ( math . log ( K , 2 ) ) NEW_LINE prefix = [ ] NEW_LINE a = [ float ( math . log ( x ) ) for x in arr ] NEW_LINE sum += a [ i ] NEW_LINE prefix . append ( a [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix . append ( prefix [ i - 1 ] + a [ i ] ) NEW_LINE DEDENT total = power ( 2 , n ) - 1 NEW_LINE if sum <= k : NEW_LINE INDENT return int ( total ) NEW_LINE DEDENT solve ( 0 , n , 0. , k , a , prefix ) NEW_LINE return int ( total - discard_count ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 4 , 8 , 7 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( count_subsequences ( arr , n , k ) , end = ' ▁ ' ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT def newNode ( self , data ) : NEW_LINE INDENT node = Node ( ) NEW_LINE node . data = data NEW_LINE node . left = None NEW_LINE node . right = None NEW_LINE return node NEW_LINE DEDENT def inorder ( self ) : NEW_LINE INDENT if not self . left : NEW_LINE INDENT return 0 NEW_LINE DEDENT inorder ( self . left ) NEW_LINE print ( self . data , end = ' ▁ ' ) NEW_LINE inorder ( self . right ) NEW_LINE DEDENT def isIdentical ( self , root1 , root2 ) : NEW_LINE INDENT if not self . left and not self . right : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif self . left and not self . right : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif self . left and self . right : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if self . data == root2 . data and isIdentical ( self . left , root2 . left ) == 1 and isIdentical ( self . right , root2 . right ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT root1 = newNode ( 5 ) NEW_LINE root2 = newNode ( 5 ) NEW_LINE root1 . left = newNode ( 3 ) NEW_LINE root1 . right = newNode ( 8 ) NEW_LINE root1 . left . left = newNode ( 2 ) NEW_LINE root1 . left . right = newNode ( 4 ) NEW_LINE root2 . left = newNode ( 3 ) NEW_LINE root2 . right = newNode ( 8 ) NEW_LINE root2 . left . left = newNode ( 2 ) NEW_LINE root2 . left . right = newNode ( 4 ) NEW_LINE if isIdentical ( self , self . left , self . right ) == 1 : NEW_LINE INDENT print ( ' Both ▁ BSTs ▁ are ▁ identical ' , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' BSTs ▁ are ▁ not ▁ identical ' , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = len ( sys . stdin ) NEW_LINE arr = sys . stdin . read ( ) NEW_LINE DEDENT left_j = [ 0 ] * ( n + 2 ) NEW_LINE right_i = [ 0 ] * ( n + 2 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT left_j [ i ] = left_j [ i - 1 ] NEW_LINE if arr [ i - 1 ] == ' J ' : NEW_LINE INDENT left_j [ i ] += 1 NEW_LINE DEDENT right_i [ n - i + 1 ] = right_i [ n - i + 2 ] NEW_LINE if arr [ n - i ] == ' I ' : NEW_LINE INDENT right_i [ n - i + 1 ] += 1 NEW_LINE DEDENT DEDENT sum_i = 0 NEW_LINE sum_j = 0 NEW_LINE max_o = 0 NEW_LINE total = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if arr [ i - 1 ] == ' O ' : NEW_LINE INDENT tmp = left_j [ i - 1 ] * right_i [ i + 1 ] NEW_LINE total += tmp NEW_LINE sum_j += ( left_j [ i - 1 ] + 1 ) * right_i [ i + 1 ] NEW_LINE sum_i += left_j [ i - 1 ] * ( right_i [ i + 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = left_j [ i - 1 ] * right_i [ i ] NEW_LINE DEDENT max_o = max ( max_o , tmp ) NEW_LINE DEDENT total += max_o NEW_LINE total = max ( total , sum_j ) NEW_LINE total = max ( total , sum_i ) NEW_LINE print ( total ) NEW_LINE DEDENT
def import import sys , StringIO , os , sys , traceback , ** kwargs ) : NEW_LINE INDENT from io import StringIO NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE from dise import Dise NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT class node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT def add ( self , data ) : NEW_LINE INDENT newnode = node ( ) NEW_LINE newnode . data = data NEW_LINE newnode . next = None NEW_LINE return newnode NEW_LINE DEDENT def print_arr ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def findlength ( self ) : NEW_LINE INDENT curr = self . head NEW_LINE cnt = 0 NEW_LINE while curr is not None : NEW_LINE INDENT cnt += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT return cnt NEW_LINE DEDENT def convertarr ( self ) : NEW_LINE INDENT len = findlength ( self ) NEW_LINE arr = [ ] NEW_LINE index = 0 NEW_LINE curr = self . head NEW_LINE while curr is not None : NEW_LINE INDENT arr . append ( curr . data ) NEW_LINE curr = curr . next NEW_LINE DEDENT return arr NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT head = node ( ) NEW_LINE head = add ( 1 ) NEW_LINE head . next = add ( 2 ) NEW_LINE head . next . next = add ( 3 ) NEW_LINE head . next . next . next = add ( 4 ) NEW_LINE head . next . next . next . next = add ( 5 ) NEW_LINE convertarr ( head ) NEW_LINE DEDENT DEDENT
def test_gf_gcd ( ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . a = [ [ 0 ] * ( n + 1 ) for i in range ( 0 , 9 ) ] NEW_LINE self . a . append ( [ 1 ] * ( n + 1 ) ) NEW_LINE DEDENT def f ( self ) : NEW_LINE INDENT self . a [ 0 ] [ 0 ] = 1 NEW_LINE self . a [ 1 ] [ 9 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT self . a [ i ] [ j ] = self . a [ i - 1 ] [ j ] + self . a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return self . a [ n ] [ 0 ] NEW_LINE DEDENT def g ( self ) : NEW_LINE INDENT self . a = [ [ 0 ] * ( n + 1 ) for i in range ( 0 , 9 ) ] NEW_LINE self . a [ 9 ] = a [ 9 ] NEW_LINE self . a [ 9 ] = a [ 9 ] NEW_LINE return self . a [ 9 ] NEW_LINE DEDENT def g ( self ) : NEW_LINE INDENT self . a = [ [ 0 ] * ( n + 1 ) for i in range ( 0 , 9 ) ] NEW_LINE self . a [ 9 ] = a [ 9 ] NEW_LINE return self . a [ 9 ] NEW_LINE DEDENT def g ( self ) : NEW_LINE INDENT self . a = [ [ 0 ] * ( n + 1 ) for i in range ( 0 , 9 ) ] NEW_LINE self . a [ 9 ] = a [ 9 ] NEW_LINE return self . a [ 9 ] NEW_LINE DEDENT def g ( self ) : NEW_LINE INDENT self . a = [ [ 0 ] * ( n + 1 ) for i in range ( 0 , 8 ) ] NEW_LINE return self . a [ 9 ] NEW_LINE DEDENT def g ( self ) : NEW_LINE INDENT self . a = [ [ 0 ] * ( n + 1 ) for i in range ( 0 , 9 ) ] NEW_LINE return self . a [ 9 ] NEW_LINE DEDENT def g ( self ) : NEW_LINE INDENT self . a = [ [ 0 ] * ( n + 1 ) for i in range ( 0 , 9 ) ] NEW_LINE return self . a [ 9 ] NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def class29 ( arg ) : NEW_LINE INDENT import sys NEW_LINE class class29 ( object ) : NEW_LINE INDENT def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE t = sc . readline ( ) NEW_LINE while t : NEW_LINE INDENT n = sc . readline ( ) NEW_LINE st = set ( ) NEW_LINE i , flag = 0 , 0 NEW_LINE a = [ ] NEW_LINE vis = [ 0 ] * n NEW_LINE for i in st : NEW_LINE INDENT a . append ( sc . readline ( ) ) NEW_LINE val = ( i + a [ i ] ) % n NEW_LINE if val < 0 : NEW_LINE INDENT val += n NEW_LINE DEDENT vis [ int ( val ) ] = 1 NEW_LINE DEDENT for i in st : NEW_LINE INDENT if vis [ i ] == 0 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE class Solution ( object ) : NEW_LINE INDENT def minMoves ( self , nums ) : NEW_LINE INDENT if not nums : NEW_LINE INDENT return 0 NEW_LINE DEDENT nums . sort ( ) NEW_LINE min_num = nums [ 0 ] NEW_LINE ans = 0 NEW_LINE for num in nums : NEW_LINE INDENT ans += num - min_num NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 ] NEW_LINE out = sObj . minMoves ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = sys . maxint NEW_LINE self . b = sys . maxint NEW_LINE if a <= 0 and b >= 0 or a <= 0 and b >= 0 : NEW_LINE INDENT print ( " Zero " ) NEW_LINE DEDENT elif a < 0 and b < 0 : NEW_LINE INDENT print ( " Positive " if ( ( b - a + 1 ) % 2 == 0 ) else " Negative " ) NEW_LINE DEDENT elif a > 0 and b > 0 : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT DEDENT DEDENT
def geeks ( n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT
def import _unicode2string NEW_LINE class GFG ( object ) : NEW_LINE INDENT MAX_CHAR = 256 NEW_LINE def maximumChars ( self , data ) : NEW_LINE INDENT n = len ( data ) NEW_LINE res = - 1 NEW_LINE firstInd = [ - 1 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT firstInd = firstInd [ data [ i ] ] NEW_LINE if firstInd == - 1 : NEW_LINE INDENT firstInd [ data [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - firstInd - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def maximumChars ( self ) : NEW_LINE INDENT data = ' abba ' NEW_LINE print ( maximumChars ( data ) ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import os NEW_LINE import sys NEW_LINE from os . path import join NEW_LINE from os import path NEW_LINE from os . path import join NEW_LINE from os import path NEW_LINE from os import getenv NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os import path NEW_LINE from os . path import join NEW_LINE from os import path NEW_LINE from os import getenv NEW_LINE from os . path import join NEW_LINE from os import path NEW_LINE from os . path import join NEW_LINE from os import path NEW_LINE from os . path import join NEW_LINE from os import path NEW_LINE from os import getenv NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os . path import join NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import getenv NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path as path NEW_LINE from os import path NEW_LINE from os import path NEW_LINE from os import path as path NEW_LINE from os import path as path NEW_LINE from os import path as path NEW_LINE DEDENT
def import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_area ( self , a ) : NEW_LINE INDENT area = float ( 5 * math . sqrt ( 3 ) * a ** 2 ) NEW_LINE return area NEW_LINE DEDENT def find_volume ( self , a ) : NEW_LINE INDENT volume = float ( ( float ( 5 ) / 12 ) * ( 3 + math . sqrt ( 5 ) ) * a ** 2 ) NEW_LINE return volume NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a = 5 NEW_LINE print ( " Area : ▁ " , " % . 2 . f " % self . find_area ( a ) ) NEW_LINE print ( " Volume : ▁ " , " % . 2 . f " % self . find_volume ( a ) ) NEW_LINE DEDENT DEDENT
def p205 ( ) : NEW_LINE INDENT print ( np . array ( [ 0 , 1 , 1 , 1 , 1 ] ) ) NEW_LINE PYRAMIDAL_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE CUBIC_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE nine_pyramidal_pdf = [ 1 ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT nine_pyramidal_pdf = convolve ( nine_pyramidal_pdf , PYRAMIDAL_DIE_PDF ) NEW_LINE DEDENT sixp_pdf = [ 1 ] NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT sixp_pdf = convolve ( sixp_pdf , CUBIC_DIE_PDF ) NEW_LINE DEDENT numer = 0 NEW_LINE for i in range ( len ( nine_pyramidal_pdf ) ) : NEW_LINE INDENT numer += long ( nine_pyramidal_pdf [ i ] ) * sum ( sixp_pdf [ : , i ] ) NEW_LINE DEDENT denom = long ( sum ( nine_pyramidal_pdf [ : , : - 1 ] ) * sum ( sixp_pdf [ : , : - 1 ] ) ) NEW_LINE return ' % .7f ' % ( float ( numer ) / denom ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE N = 6 NEW_LINE Even = N // 2 NEW_LINE Odd = N - Even NEW_LINE print ( Even * Odd ) NEW_LINE DEDENT
def _solve ( M , N , s ) : NEW_LINE INDENT import sys NEW_LINE from sympy . utilities . iterables import variations NEW_LINE class GFG ( object ) : NEW_LINE INDENT def solve ( self , M , N , s ) : NEW_LINE INDENT if N % s == 0 : NEW_LINE INDENT N = N // s NEW_LINE DEDENT else : NEW_LINE INDENT N = ( N // s ) + 1 NEW_LINE DEDENT if M % s == 0 : NEW_LINE INDENT M = M // s NEW_LINE DEDENT else : NEW_LINE INDENT M = ( M // s ) + 1 NEW_LINE DEDENT return M * N NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT N , M , s = 12 , 13 , 4 NEW_LINE print ( self . solve ( M , N , s ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import gcd NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : return b NEW_LINE return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) / gcd ( a , b ) NEW_LINE DEDENT def count_pairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( count_pairs ( arr , n ) , end = ' ▁ ' ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import import sys , string , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice
def _import ( ) : NEW_LINE INDENT from math import ceil NEW_LINE class GFG ( object ) : NEW_LINE INDENT def _popcnt32 ( self , number ) : NEW_LINE INDENT counter = 0 NEW_LINE while number > 0 : NEW_LINE INDENT if number % 2 == 1 : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT number = number // 2 NEW_LINE DEDENT return counter NEW_LINE DEDENT def maximize ( self ) : NEW_LINE INDENT n = _popcnt32 ( self ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = int ( res | ( 1 << ( 32 - i ) ) ) NEW_LINE DEDENT return abs ( res ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT a = 1 NEW_LINE print ( maximize ( a ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def test_CF_1712_A ( ) : NEW_LINE INDENT from sympy . utilities . randtest import DecimalTest NEW_LINE class CF_1712_A ( DecimalTest ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT DecimalTest . __init__ ( self ) NEW_LINE self . prec = 10 NEW_LINE DEDENT def get_prec ( self ) : NEW_LINE INDENT return self . prec NEW_LINE DEDENT DEDENT t = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 41 , 42 , 43 , 43 , 44 , 45 , 47 , 48 , 49 , 52 , 53 , 56 , 57 , 58 , 59 , 59 , 59 , 60 , 60 , 60 , 60 , 60 ] NEW_LINE def f ( ) : NEW_LINE INDENT t . append ( DecimalTest . get_prec ( ) ) NEW_LINE DEDENT f . write ( " a ▁ = ▁ " ) NEW_LINE f . write ( " b ▁ = ▁ " ) NEW_LINE f . write ( " c ▁ = ▁ " ) NEW_LINE f . write ( " d ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE f . write ( " e ▁ = ▁ " ) NEW_LINE
def python_application_38 ( ) : NEW_LINE INDENT from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE num1 = environ . get ( ' NUMBER ' ) NEW_LINE num2 = environ . get ( ' NUMBER ' ) NEW_LINE counter = 0 NEW_LINE while num1 != 0 and num2 != 0 : NEW_LINE INDENT if num1 == 1 and num2 == 1 : NEW_LINE INDENT break NEW_LINE DEDENT if num1 <= num2 : NEW_LINE INDENT num1 += 1 NEW_LINE num2 -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT num1 -= 2 NEW_LINE num2 += 1 NEW_LINE DEDENT counter += 1 NEW_LINE DEDENT print ( counter ) NEW_LINE DEDENT
def import _Solution NEW_LINE class Solution : NEW_LINE INDENT def xor_queries ( self , arr , queries ) : NEW_LINE INDENT res , q = [ ] , [ ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT arr [ i ] ^= arr [ i - 1 ] NEW_LINE DEDENT for i , q in enumerate ( queries ) : NEW_LINE INDENT res . append ( arr [ q [ 0 ] - 1 ] ^ arr [ q [ 1 ] ] if q [ 0 ] > 0 else arr [ q [ 1 ] ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE arr = [ 1 , 3 , 4 , 8 ] NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 2 ] , [ 0 , 3 ] , [ 3 , 3 ] ] NEW_LINE out = sObj . xor_queries ( arr , queries ) NEW_LINE print ( " ▁ " . join ( out ) ) NEW_LINE DEDENT DEDENT
def encodedChar ( str , k ) : NEW_LINE INDENT expand = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while i < len ( str ) and str [ i ] in " a " and str [ i ] in " z " : NEW_LINE INDENT temp += str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while i < len ( str ) and str [ i ] in "1" and str [ i ] in "9" : NEW_LINE INDENT freq = freq * 10 + str [ i ] - '0' NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT DEDENT if not freq : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def printPossible ( self , a , b , c ) : NEW_LINE INDENT if ( a + b + c ) % 2 or a + b < c : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT DEDENT a , b , c = 2 , 4 , 2 NEW_LINE GFG ( a , b , c ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) // 2 NEW_LINE sign = 1 if n + 1 % 2 == 0 else - 1 NEW_LINE result_sum = sign * abs_sum NEW_LINE return result_sum NEW_LINE DEDENT
def test_gf_gate_sort ( ) : NEW_LINE INDENT import sys NEW_LINE import scipy . sparse NEW_LINE class GFG ( scipy . sparse . csr_matrix ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = len ( self . n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT self . n = self . n * self . n NEW_LINE DEDENT self . sort ( ) NEW_LINE DEDENT def __call__ ( self ) : NEW_LINE INDENT arr = [ - 6 , - 3 , - 1 , 2 , 4 , 5 ] NEW_LINE n = len ( self . n ) NEW_LINE print ( " Before ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( self . n , end = ' ▁ ' ) NEW_LINE DEDENT self . sort_squares ( arr ) NEW_LINE print ( " " ) NEW_LINE print ( " After ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( self . n , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import _cp19 NEW_LINE class CP19 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = _cp19 NEW_LINE n , t , k , pos = [ int ( i ) for i in range ( n ) ] NEW_LINE arr = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT arr . append ( sc . choice ( arr ) ) NEW_LINE DEDENT while pos < t : NEW_LINE INDENT k , pos = pos + arr [ pos - 1 ] , k NEW_LINE DEDENT if pos == t : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def import import _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline ,
def __is_triangular ( num ) : NEW_LINE INDENT import math NEW_LINE if num < 0 : return False NEW_LINE c = ( - 2 * num ) NEW_LINE b , a = 1 , 1 NEW_LINE d = ( b ** 2 ) - ( 4 * a * c ) NEW_LINE if d < 0 : return False NEW_LINE root1 = ( - b + float ( math . sqrt ( d ) ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - float ( math . sqrt ( d ) ) ) / ( 2 * a ) NEW_LINE if root1 and math . floor ( root1 ) == root1 : return True NEW_LINE if root2 and math . floor ( root2 ) == root2 : return True NEW_LINE return False NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def printNumberWithDR ( self , k , d ) : NEW_LINE INDENT if d == 0 and k != 1 : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE k -= 1 NEW_LINE while k > 0 : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT k , d = 4 , 4 NEW_LINE GFG ( k , d ) NEW_LINE DEDENT
def import _rotate_matrix NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , mat ) : NEW_LINE INDENT self . N = 3 NEW_LINE DEDENT def rotateMatrix ( self ) : NEW_LINE INDENT for i in range ( self . N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( self . N - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( self . mat [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE return np . dot ( np . dot ( np . dot ( mat , self . mat ) , self . mat ) , self . mat ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT with open ( ' . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . / .
def __GFG ( n ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def getProduct ( self ) : NEW_LINE INDENT product = 1 NEW_LINE while n != 0 : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = 4513 NEW_LINE print ( getProduct ( n ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sn = sys . stdin NEW_LINE while True : NEW_LINE INDENT slot = Slot ( self . sn , self . sn , self . sn , self . sn , self . sn ) NEW_LINE if slot . is_end : NEW_LINE INDENT break NEW_LINE DEDENT print ( 100 + slot . benefit - slot . lost ) NEW_LINE DEDENT DEDENT DEDENT class Slot ( object ) : NEW_LINE INDENT def __init__ ( self , b , r , g , c , s , t ) : NEW_LINE INDENT self . b , self . r , self . g , self . c , self . s , self . t = t NEW_LINE DEDENT def get_lost ( self ) : NEW_LINE INDENT return ( t - 5 * b - 3 * r - s ) * 3 + ( 5 * b + 3 * r ) * 2 NEW_LINE DEDENT def get_benefit ( self ) : NEW_LINE INDENT return b * 15 + r * 15 + g * 7 + c * 2 + ( b * 5 + r * 3 ) * 15 NEW_LINE DEDENT def is_end ( self ) : NEW_LINE INDENT return b + r + g + c + s + t == 0 NEW_LINE DEDENT DEDENT return Main ( ) NEW_LINE DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import getopt NEW_LINE import getopt NEW_LINE import getopt NEW_LINE import getopt NEW_LINE global ColoredBalls NEW_LINE mod = 1000000007 NEW_LINE MAXN = 1010 NEW_LINE def main ( ) : NEW_LINE INDENT with open ( sys . argv [ 1 ] , ' r ' , encoding = ' utf - 8' ) as infile , open ( sys . argv [ 2 ] , ' w ' , encoding = ' utf - 8' ) as outfile : NEW_LINE INDENT comb = getopt . getopt ( infile , ' a ' , [ ' b ' ] ) NEW_LINE for i in range ( 1 , MAXN ) : NEW_LINE INDENT comb [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT comb [ i ] [ j ] = ( comb [ i - 1 ] [ j ] + comb [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT DEDENT K = getopt . Getoptyx ( ) NEW_LINE color = [ ] NEW_LINE for i in range ( K ) : NEW_LINE INDENT color . append ( infile . read ( ) ) NEW_LINE DEDENT res = 1 NEW_LINE total = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT res = ( res * comb [ total + color [ i ] - 1 ] [ color [ i ] - 1 ] ) % mod NEW_LINE total += color [ i ] NEW_LINE DEDENT outfile . write ( res ) NEW_LINE outfile . close ( ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . ComplexInfinity ) : NEW_LINE INDENT PI = 3.14159265 NEW_LINE def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT r = 7 NEW_LINE print ( length_rope ( r ) ) NEW_LINE DEDENT DEDENT
def GFG ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE def isPalindrome ( n ) : NEW_LINE INDENT rev_n = reverseDigits ( n ) NEW_LINE if rev_n == n : return 1 NEW_LINE else : return 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 4562 NEW_LINE print ( " Is ▁ % d ▁ a ▁ Palindrome ▁ number ? ▁ - > ▁ % s " % ( n , isPalindrome ( n ) == 1 and " True " or " False " ) ) NEW_LINE n = 2002 NEW_LINE print ( " Is ▁ % d ▁ a ▁ Palindrome ▁ number ? ▁ - > ▁ % s " % ( n , isPalindrome ( n ) == 1 and " True " or " False " ) ) NEW_LINE DEDENT DEDENT
def Solution ( ) : NEW_LINE INDENT def addStrings ( num1 , num2 ) : NEW_LINE INDENT s = [ ] NEW_LINE carry = 0 NEW_LINE for i , j in zip ( num1 [ : - 1 ] , num2 [ : - 1 ] ) : NEW_LINE INDENT x = 0 if i < 0 else num1 [ i ] - '0' NEW_LINE y = 0 if j < 0 else num2 [ j ] - '0' NEW_LINE s . append ( ( x + y + carry ) % 10 ) NEW_LINE carry = ( x + y + carry ) / 10 NEW_LINE DEDENT return ' ' . join ( reversed ( s ) ) NEW_LINE DEDENT sObj = Solution ( ) NEW_LINE num1 = '11' NEW_LINE num2 = '123' NEW_LINE out = sObj . addStrings ( num1 , num2 ) NEW_LINE print ( out ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , 2 * i <= n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if i * i != n : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT DEDENT if sum == n and n != 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT for x in range ( 2 , math . sqrt ( n ) + 1 ) : NEW_LINE INDENT p = x NEW_LINE while p <= n : NEW_LINE INDENT p = p * x NEW_LINE if p == n : return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT for x in range ( 2 , math . sqrt ( n ) + 1 ) : NEW_LINE INDENT y = 2 NEW_LINE p = math . pow ( x , y ) NEW_LINE while p <= n and p > 0 : NEW_LINE INDENT if p == n : NEW_LINE INDENT return True NEW_LINE DEDENT y += 1 NEW_LINE p = math . pow ( x , y ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def _ _ main _ _ ( a , b ) : NEW_LINE INDENT import sys NEW_LINE class Solution : NEW_LINE INDENT def __gcd ( self , a ) : NEW_LINE INDENT if not b : NEW_LINE INDENT return a NEW_LINE DEDENT return self . __gcd ( b , a % b ) NEW_LINE DEDENT def findTwoNumbers ( self , sum , gcd ) : NEW_LINE INDENT if self . __gcd ( gcd , sum - gcd ) == gcd and sum != gcd : NEW_LINE INDENT print ( " a ▁ = ▁ % d , ▁ b ▁ = ▁ % d " % ( min ( gcd , sum - gcd ) , int ( sum - min ( gcd , sum - gcd ) ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT sum = 8 NEW_LINE gcd = 2 NEW_LINE findTwoNumbers ( sum , gcd ) NEW_LINE DEDENT DEDENT
def time ( m , n , rb , cb , rd , cd ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE class RobotCleaner : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . t = 0 NEW_LINE self . dr = 1 NEW_LINE self . dc = 1 NEW_LINE while True : NEW_LINE INDENT if rb == rd or cb == cd : NEW_LINE INDENT return self . t NEW_LINE DEDENT self . t += 1 NEW_LINE if ( self . rb + self . dr <= 0 or self . rb + self . dr > m ) : NEW_LINE INDENT self . dr *= - 1 NEW_LINE DEDENT if ( self . cb + self . dc <= 0 or self . cb + self . dc > n ) : NEW_LINE INDENT self . dc *= - 1 NEW_LINE DEDENT self . rb += self . dr NEW_LINE self . cb += self . dc NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT streamfile = open ( self . stream , " r " ) NEW_LINE stream = streamfile . readlines ( ) NEW_LINE self . test_cases = int ( stream ) NEW_LINE for input in stream : NEW_LINE INDENT t = self . time ( int ( input [ 0 ] ) , int ( input [ 1 ] ) , int ( input [ 2 ] ) , int ( input [ 3 ] ) , int ( input [ 4 ] ) , int ( input [ 5 ] ) ) NEW_LINE print ( t ) NEW_LINE DEDENT DEDENT DEDENT return RobotCleaner ( ) NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( sys . stdin . read ( ) ) NEW_LINE self . a = int ( sys . stdin . read ( ) ) NEW_LINE self . b = int ( sys . stdin . read ( ) ) NEW_LINE self . c = int ( sys . stdin . read ( ) ) NEW_LINE self . d = int ( sys . stdin . read ( ) ) NEW_LINE self . ans1 , self . ans2 = 100000 , 1000000 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if self . a * i >= self . n : NEW_LINE INDENT self . ans1 = i * self . b NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 1 , self . n + 1 ) : NEW_LINE INDENT if self . c * i >= self . n : NEW_LINE INDENT self . ans2 = i * self . d NEW_LINE break NEW_LINE DEDENT DEDENT print ( min ( self . ans2 , self . ans1 ) ) NEW_LINE DEDENT DEDENT
def count_set_bits ( n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def count_set_bits ( self , n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def total_pairs ( self , arr , n ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = count_set_bits ( self , arr [ i ] ) NEW_LINE if count in m : NEW_LINE INDENT m [ count ] = m [ count ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ count ] = 1 NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT result += ( ( value * ( key - 1 ) ) / 2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 7 , 5 , 3 , 9 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( total_pairs ( arr , n ) ) NEW_LINE DEDENT DEDENT
def _center_hexadecagonal_num ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT n = 2 NEW_LINE print ( " { } th ▁ centered ▁ { } hexadecagonal ▁ number : ▁ " . format ( n , " hexadecagonal ▁ number " ) , end = " " ) NEW_LINE print ( self . center_hexadecagonal_num ( n ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def import import sys NEW_LINE import random NEW_LINE import math NEW_LINE import random NEW_LINE import sys NEW_LINE class Main ( sys . stdout ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT Scanner ( ) NEW_LINE Q , H , S , D , N = random . randint ( 0 , 2 ) NEW_LINE one_price = min ( min ( Q * 4 , H * 2 ) , S ) NEW_LINE if float ( one_price ) <= float ( D ) / 2 : NEW_LINE INDENT self . out . append ( N * one_price ) NEW_LINE DEDENT else : NEW_LINE INDENT self . out . append ( ( N / 2 ) * D + ( N % 2 ) * one_price ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( L , R , K ) : NEW_LINE INDENT if K == 9 : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers / 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if rem1 == K : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import math NEW_LINE from random import randint NEW_LINE for a , b , c , d , e , f in [ ( randint ( 0 , 9 ) , randint ( 0 , 9 ) , randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) ) , ( randint ( 0 , 9 ) , randint ( 0 , 9 ) ) ] : NEW_LINE INDENT y = min ( c , b ) NEW_LINE x = a NEW_LINE if y + x <= d : NEW_LINE INDENT print ( y * f + x * e ) NEW_LINE DEDENT elif f >= e : NEW_LINE INDENT print ( min ( y , d ) * f + ( d - min ( y , d ) ) * e ) NEW_LINE DEDENT elif e >= f : NEW_LINE INDENT print ( min ( x , d ) * e + ( d -
def Solution ( A ) : NEW_LINE INDENT import sys NEW_LINE from math import ceil NEW_LINE ans = 2 NEW_LINE n = len ( A ) NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT llap = [ 2 for i in range ( n ) ] NEW_LINE A . sort ( ) NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while i >= 0 and k < n : NEW_LINE INDENT if A [ i ] + A [ k ] == 2 * A [ j ] : NEW_LINE INDENT llap [ j ] = max ( llap [ k ] + 1 , llap [ j ] ) NEW_LINE ans = max ( ans , llap [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT elif A [ i ] + A [ k ] < 2 * A [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def minimum_changes ( arr , n , d ) : NEW_LINE INDENT import numpy as np NEW_LINE max_freq = - 1 NEW_LINE freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = arr [ i ] - ( i ) * d NEW_LINE if a0 in freq : NEW_LINE INDENT freq [ a0 ] = freq [ a0 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a0 ] = 1 NEW_LINE DEDENT if freq [ a0 ] > max_freq : NEW_LINE INDENT max_freq = freq [ a0 ] NEW_LINE DEDENT DEDENT return ( n - max_freq ) NEW_LINE DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import os NEW_LINE import sys NEW_LINE import numpy . random NEW_LINE import numpy . testing as np NEW_LINE import random NEW_LINE import numpy . testing as np NEW_LINE import random NEW_LINE import numpy . testing as np NEW_LINE import random NEW_LINE import numpy . testing as np NEW_LINE import random NEW_LINE import numpy . testing as np NEW_LINE import random NEW_LINE n = random . randint ( 1 , 4 ) NEW_LINE vec = np . random . rand ( n , 4 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT vec [ i , 0 ] = random . randint ( 1 , 4 ) NEW_LINE vec [ i , 1 ] = random . randint ( 1 , 4 ) NEW_LINE vec [ i , 2 ] = random . randint ( 1 , 4 ) NEW_LINE vec [ i , 3 ] = random . randint ( 1 , 4 ) NEW_LINE DEDENT ans = 500 NEW_LINE ansprice = 20000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT fl = 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if vec [ i , 0 ] < vec [ j , 0 ] < vec [ i , 1 ] < vec [ j , 1 ] and vec [ i , 2 ] < vec [ j , 2 ] : NEW_LINE INDENT fl = 0 NEW_LINE DEDENT DEDENT if fl == 1 : NEW_LINE INDENT if vec [ i , 3 ] < ansprice : NEW_LINE INDENT ansprice = vec [ i , 3 ] NEW_LINE ans = i + 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE os . system ( ' mv ▁ % s ' % ( ans ) ) NEW_LINE DEDENT
def test_countpoints ( n , m , a , b , x , y ) : NEW_LINE INDENT import math NEW_LINE a = [ x , y ] NEW_LINE b = [ y , x ] NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if a [ i ] + y < b [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT if b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT x , y = 1 , 4 NEW_LINE a = [ 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 1 , 1 , 2 ] NEW_LINE m = len ( a ) NEW_LINE print ( countpoints ( n , m , a , b , x , y ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT class GFG ( object ) : NEW_LINE INDENT def __mul__ ( self , x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT DEDENT x = 4 NEW_LINE print ( __mul__ ( GFG ( x ) ) ) NEW_LINE DEDENT
def import import sys , string , traceback NEW_LINE from os import urandom NEW_LINE from random import randint NEW_LINE class B ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = int ( sys . stdin . read ( ) ) NEW_LINE self . a = [ ] NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE self . a . append ( random . randint ( 1 , n ) ) NEW_LINE DEDENT def solve ( self , n , a , s ) : NEW_LINE INDENT ans = - 1 NEW_LINE sum = 0 NEW_LINE r = min ( a ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE r = min ( a
def longest_substring ( s ) : NEW_LINE INDENT import re NEW_LINE import math NEW_LINE cnt , maxi = 1 , 1 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] != s [ i - 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) NEW_LINE return maxi NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . main = Main ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT with open ( " / proc / self / " ) as f : NEW_LINE INDENT k = f . read ( ) NEW_LINE n = 50 NEW_LINE sum = k / n NEW_LINE amari = k % n NEW_LINE a = [ i + sum for i in range ( 50 ) ] NEW_LINE for i in range ( amari ) : NEW_LINE INDENT a [ n - 1 - i ] += 1 NEW_LINE DEDENT print ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , " \n " if i == n - 1 else " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( digits ) : NEW_LINE INDENT first = int ( ( pow ( 10 , digits ) - 1 ) / 9 ) NEW_LINE second = int ( ( pow ( 9 , digits ) - 1 ) / 8 ) NEW_LINE return 9 * ( first - second ) NEW_LINE def int_or_zero ( c ) : NEW_LINE INDENT return ord ( c ) - 48 NEW_LINE DEDENT def count_zero ( num ) : NEW_LINE INDENT k = len ( num ) NEW_LINE total = zero_upto ( k - 1 ) NEW_LINE non_zero = 0 NEW_LINE for i , c in enumerate ( num ) : NEW_LINE INDENT if c == '0' : NEW_LINE INDENT non_zero -= 1 NEW_LINE break NEW_LINE DEDENT non_zero += ( int_or_zero ( c ) - 1 ) * ( pow ( 9 , k - 1 - i ) ) NEW_LINE DEDENT no , remaining , calculated_upto = 0 , 0 , 0 NEW_LINE for i , c in enumerate ( num ) : NEW_LINE INDENT no = no * 10 + ( int_or_zero ( c ) ) NEW_LINE if i != 0 : NEW_LINE INDENT calculated_upto = calculated_upto * 10 + 9 NEW_LINE DEDENT DEDENT remaining = no - calculated_upto NEW_LINE ans = zero_upto ( k - 1 ) + ( remaining - non_zero - 1 ) NEW_LINE return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT num = "107" NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1" + " ▁ to ▁ " + num + " ▁ is ▁ " + str ( count_zero ( num ) ) ) NEW_LINE num = "1264" NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1" + " ▁ to ▁ " + num + " ▁ is ▁ " + str ( count_zero ( num ) ) ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def GFG ( a ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . ComplexInfinity ) : NEW_LINE INDENT def cone ( self ) : NEW_LINE INDENT if a < 0 : return - 1 NEW_LINE r = float ( a * math . sqrt ( 2 ) ) / 3 NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = float ( 3.14 * math . pow ( r , 2 ) * h ) NEW_LINE return V NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT a = 5 NEW_LINE print ( ' % . 4 f ' % cone ( a ) ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT import math NEW_LINE if n == 1 : return False NEW_LINE for i in range ( 2 , 2 * n + 1 ) : NEW_LINE INDENT if n % i == 0 : return False NEW_LINE DEDENT return True NEW_LINE DEDENT def checkSumPrime ( str ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT summ += abs ( str [ i - 1 ] - str [ i ] ) NEW_LINE DEDENT if Prime ( summ ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT num = 142 NEW_LINE str = '142' NEW_LINE if checkSumPrime ( str ) : NEW_LINE INDENT print ( ' Prime ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Not ▁ Prime ' ) NEW_LINE DEDENT DEDENT
def import java . io NEW_LINE class GFG ( object ) : NEW_LINE INDENT def sum ( self , n ) : NEW_LINE INDENT if n < 2 : return 1 NEW_LINE else : return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT g = GFG ( ) NEW_LINE print ( ' % . 3 f ' % g . sum ( 8 ) ) NEW_LINE print ( ' % . 3 f ' % g . sum ( 10 ) , end = ' ' ) NEW_LINE DEDENT DEDENT
def GFG ( p , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from os import urandom NEW_LINE from random import randint NEW_LINE from sys import stdin NEW_LINE a = stdin . read ( ) . decode ( ' utf - 8' ) NEW_LINE b = stdin . read ( ) . decode ( ' utf - 8' ) NEW_LINE if a > b : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import scipy . optimize . fsolve NEW_LINE class GFG ( scipy . optimize . fsolve ) : NEW_LINE INDENT def find_volume ( self , l , b , h ) : NEW_LINE INDENT volume = ( l * b * h ) / 2 NEW_LINE return volume NEW_LINE DEDENT DEDENT l , b , h = [ 18 , 12 , 9 ] , [ 9 , 9 , 9 ] NEW_LINE print ( " Volume ▁ of ▁ triangular ▁ prism : ▁ { } " . format ( find_volume ( l , b , h ) ) ) NEW_LINE DEDENT
def practice462b ( ) : NEW_LINE INDENT import sys NEW_LINE from csv import reader NEW_LINE from c462b import c462b NEW_LINE f = reader ( sys . stdin ) NEW_LINE out = csv . writer ( sys . stdout ) NEW_LINE f . writerow ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerow ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerow ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerow ( [ ] ) NEW_LINE f . writerow ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerow ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerow ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerow ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerow ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerow ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerow ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE f . writerows ( [ ] ) NEW_LINE DEDENT
def p045 ( ) : NEW_LINE INDENT print ( eval ( " p045" ) ) NEW_LINE def run ( ) : NEW_LINE INDENT i = 286 NEW_LINE j = 166 NEW_LINE k = 144 NEW_LINE while True : NEW_LINE INDENT triangle = long ( i * ( i + 1 ) ) / 2 NEW_LINE pentagon = long ( j * ( j * 3 - 1 ) ) / 2 NEW_LINE hexagon = long ( k * ( k * 2 - 1 ) ) NEW_LINE min = min ( min ( triangle , pentagon ) , min ( hexagon ) ) NEW_LINE if min == triangle and min == pentagon and min == hexagon : NEW_LINE INDENT return str ( min ) NEW_LINE DEDENT if min == triangle : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if min == pentagon : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if min == hexagon : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT return run NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT if N < 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr = [ False ] * ( N + 1 ) NEW_LINE prod , res = 1 , 0 NEW_LINE for p in range ( 2 , p * 2 + 1 ) : NEW_LINE INDENT if arr [ p ] == False : NEW_LINE INDENT for i in range ( p * 2 , N + 1 , p ) : NEW_LINE INDENT arr [ i ] = True NEW_LINE DEDENT prod *= p NEW_LINE if prod > N : NEW_LINE INDENT return res NEW_LINE DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def test_gf_gcd ( ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , a ) : NEW_LINE INDENT self . m = a [ 0 ] NEW_LINE for i in a : NEW_LINE INDENT self . m = max ( i , m ) NEW_LINE DEDENT return self . m NEW_LINE DEDENT def checkDivisors ( self , n ) : NEW_LINE INDENT X = max_element ( self . a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , self . n ** 2 + 1 ) : NEW_LINE INDENT if X % i == 0 : NEW_LINE INDENT b . append ( i ) NEW_LINE if X / i != i : NEW_LINE INDENT b . append ( X / i ) NEW_LINE DEDENT DEDENT DEDENT if len ( b ) != n : NEW_LINE INDENT return False NEW_LINE DEDENT self . a = [ i for i in b if i != a [ i ] ] NEW_LINE self . b = [ i for i in b if i != a [ i ] ] NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 8 , 1 , 2 , 12 , 48 , 6 , 4 , 24 , 16 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE if checkDivisors ( arr , N ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def test ( n ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE def subarray ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT print ( " All ▁ Non - empty ▁ Subarrays " ) NEW_LINE subarray ( len ( arr ) ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin NEW_LINE self . tc = self . input . count ( ) NEW_LINE self . work : NEW_LINE INDENT while self . tc : NEW_LINE INDENT n = self . input . get ( ) NEW_LINE x = int ( x ) NEW_LINE y = int ( y ) NEW_LINE if n % 6 == 0 : NEW_LINE INDENT x = min ( x , n // 6 ) NEW_LINE y = max ( y , n // 6 ) NEW_LINE DEDENT if n % 6 == 2 and n != 2 : NEW_LINE INDENT x = min ( x , ( ( n // 6 ) - 1 ) + 2 ) NEW_LINE y = max ( y , n // 6 + 1 ) NEW_LINE DEDENT if n % 6 == 4 and n != 4 : NEW_LINE INDENT x = min ( x , n // 6 + 1 ) NEW_LINE y = max ( y , n // 6 + 1 ) NEW_LINE DEDENT if n % 4 == 0 : NEW_LINE INDENT x = min ( x , n // 4 ) NEW_LINE y = max ( y , n // 4 ) NEW_LINE DEDENT if n % 4 == 2 and n != 2 : NEW_LINE INDENT x = min ( x , ( n // 4 ) - 1 + 1 ) NEW_LINE y = max ( y , ( n // 4 ) - 1 + 1 ) NEW_LINE DEDENT if x != int ( x ) and y != int ( y ) : NEW_LINE INDENT print ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def gf_max ( arr , n ) : NEW_LINE INDENT import numpy NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT arr = numpy . asarray ( arr ) NEW_LINE self . sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT self . sum += ( arr [ i ] * i ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 3 , 5 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( self . max_sum ( arr , n ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def GFG ( a , n ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def maxSum ( self , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT DEDENT return GFG ( a , n ) NEW_LINE DEDENT
def test_find_answer ( n , arr ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_answer ( self , n , arr ) : NEW_LINE INDENT arr = [ arr [ i ] for i in range ( n // 2 ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT sum += ( arr [ i ] + arr [ n - i - 1 ] ) ** 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT arr = [ 53 , 28 , 143 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_answer ( n , arr ) ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_sum ( self , n ) : NEW_LINE INDENT arr = np . array ( arr ) NEW_LINE sum = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] != arr [ i + 1 ] : NEW_LINE INDENT sum = sum + arr [ i + 1 ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_sum ( arr , n ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE return self . data NEW_LINE DEDENT def newNode ( self , data ) : NEW_LINE INDENT temp = Node ( ) NEW_LINE temp . data = data NEW_LINE self . left = temp . right = None NEW_LINE return temp NEW_LINE DEDENT def getDeepestLeftLeafNode ( self ) : NEW_LINE INDENT if not self . left : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ self . left ] NEW_LINE result = None NEW_LINE while not self . left : NEW_LINE INDENT temp = q [ - 1 ] NEW_LINE del q [ - 1 ] NEW_LINE if temp . left : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE if not temp . left . left and not temp . left . right : NEW_LINE INDENT result = temp . left NEW_LINE DEDENT DEDENT if temp . right : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT root = new_node ( 1 ) NEW_LINE root . left = new_node ( 2 ) NEW_LINE root . right = new_node ( 3 ) NEW_LINE root . left . left = new_node ( 4 ) NEW_LINE root . right . left = new_node ( 5 ) NEW_LINE root . right . right = new_node ( 6 ) NEW_LINE root . right . left . right = new_node ( 7 ) NEW_LINE root . right . right . right = new_node ( 8 ) NEW_LINE root . right . left . right . left = new_node ( 9 ) NEW_LINE root . right . right . right = new_node ( 10 ) NEW_LINE result = getDeepestLeftLeafNode ( root ) NEW_LINE if result : NEW_LINE INDENT print ( " Deepest ▁ Left ▁ Leaf ▁ Node ▁ : : ▁ " + result . data ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ result , ▁ " + " left ▁ leaf ▁ not ▁ found " ) NEW_LINE DEDENT DEDENT DEDENT
def import _g_from_list NEW_LINE class GFG ( object ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE return self . data NEW_LINE DEDENT def newNode ( self , data ) : NEW_LINE INDENT temp = Node ( ) NEW_LINE temp . data = data NEW_LINE self . left = temp . right = None NEW_LINE return temp NEW_LINE DEDENT def getDeepestRightLeafNode ( self ) : NEW_LINE INDENT if not self . data : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ self . data ] NEW_LINE result = None NEW_LINE while not self . data : NEW_LINE INDENT temp = q . pop ( ) NEW_LINE self . data = temp . data NEW_LINE if temp . left : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if temp . right : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE if not temp . right . left and not temp . right . right : NEW_LINE INDENT result = temp . right NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT root = new_node ( 1 ) NEW_LINE root . left = new_node ( 2 ) NEW_LINE root . right = new_node ( 3 ) NEW_LINE root . left . right = new_node ( 4 ) NEW_LINE root . right . left = new_node ( 5 ) NEW_LINE root . right . right = new_node ( 6 ) NEW_LINE root . right . left . right = new_node ( 7 ) NEW_LINE root . right . left . right = new_node ( 8 ) NEW_LINE root . right . left . right . left = new_node ( 9 ) NEW_LINE root . right . right . right = new_node ( 10 ) NEW_LINE result = getDeepestRightLeafNode ( root ) NEW_LINE if result : NEW_LINE INDENT print ( " Deepest ▁ Right ▁ Leaf ▁ Node ▁ : : ▁ " + result . data ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ result , ▁ right ▁ leaf ▁ not ▁ found \n " ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = self . n NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . n NEW_LINE DEDENT def __setitem__ ( self , key , value ) : NEW_LINE INDENT self . n = self . n + 1 NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . n + 1 NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . n + 1 NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . n + 1 NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . n + 1 NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . n + 1 NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . n + 1 NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . n + 1 NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . n + 1 NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . n + 1 NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . n + 1 NEW_LINE DEDENT DEDENT return Main ( ) NEW_LINE DEDENT
def __gcd ( a , b ) : NEW_LINE INDENT import sys NEW_LINE if not a : NEW_LINE INDENT return b NEW_LINE DEDENT if not b : NEW_LINE INDENT return a NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def print_ratio ( a , b , c , d ) : NEW_LINE INDENT if b * c > a * d : NEW_LINE INDENT temp , c , d = c , d , c NEW_LINE temp , a , b = a , b , temp NEW_LINE DEDENT lcm = ( a * c ) / __gcd ( a , c ) NEW_LINE x , b = lcm // a NEW_LINE b *= x NEW_LINE y , d *= y NEW_LINE k = __gcd ( b , d ) NEW_LINE b /= k NEW_LINE d /= k NEW_LINE print ( b , d , end = ' ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , b , c , d = 4 , 3 , 2 , 2 NEW_LINE print_ratio ( a , b , c , d ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i - 1 ] < arr [ i ] : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT
def _gcd_gcd ( a , b ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . gcd ) : NEW_LINE INDENT def find_max_sum_util ( arr , n ) : NEW_LINE INDENT final_gcd = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT final_gcd = GCD ( arr [ i ] , final_gcd ) NEW_LINE DEDENT return final_gcd NEW_LINE DEDENT def find_max_sum ( arr , n ) : NEW_LINE INDENT max_element = find_max_sum_util ( arr , n ) NEW_LINE return ( max_element * n ) NEW_LINE DEDENT DEDENT arr = [ 8 , 20 , 12 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_max_sum ( arr , n ) ) NEW_LINE DEDENT
def import _sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def gcd ( self , a , b ) : NEW_LINE INDENT while b != 0 : NEW_LINE INDENT t = b NEW_LINE b , a = a % b , t NEW_LINE DEDENT return a NEW_LINE DEDENT def find_min_diff ( self , a , b , x , y ) : NEW_LINE INDENT g = gcd ( a , b ) NEW_LINE diff = abs ( x - y ) % g NEW_LINE return min ( diff , g - diff ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , b = 20 , 52 , 5 , 7 NEW_LINE print ( find_min_diff ( a , b , x , y ) ) NEW_LINE DEDENT DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdin = sys . stdin NEW_LINE self . a = sys . stdin . read ( ) NEW_LINE while True : NEW_LINE INDENT X , Y , W , H , N = self . stdin . read ( ) . split ( ' ▁ ' ) NEW_LINE count = 0 NEW_LINE for x , y in zip ( X , Y ) : NEW_LINE INDENT if ( X <= x <= X + W and Y <= y <= Y + H ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n1 ) : NEW_LINE INDENT l = len ( n1 ) NEW_LINE if n1 == '0' : return 0 NEW_LINE if l % 3 == 1 : NEW_LINE INDENT n1 = '00' + n1 NEW_LINE l += 2 NEW_LINE DEDENT elif l % 3 == 2 : NEW_LINE INDENT n1 = '0' + n1 NEW_LINE l += 1 NEW_LINE DEDENT n = n1 . split ( ' . ' ) NEW_LINE g_sum = 0 NEW_LINE while l != 0 : NEW_LINE INDENT if l == 2 : NEW_LINE INDENT gvalue = ( int ( n [ ( l - 2 ) ] ) - 48 ) * 100 + ( int ( n [ ( l - 1 ) ] ) - 48 ) * 10 NEW_LINE DEDENT elif l == 1 : NEW_LINE INDENT gvalue = ( int ( n [ ( l - 1 ) ] ) - 48 ) * 100 NEW_LINE DEDENT else : NEW_LINE INDENT gvalue = ( int ( n [ ( l - 3 ) ] ) - 48 ) * 100 + ( int ( n [ ( l - 2 ) ] ) - 48 ) * 10 + ( int ( n [ ( l - 1 ) ] ) - 48 ) * 1 NEW_LINE DEDENT l = l - 3 NEW_LINE g_sum = g_sum + gvalue NEW_LINE DEDENT if g_sum >= 1000 : NEW_LINE INDENT return ( divisibleby37 ( str ( g_sum ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 1 if g_sum % 37 == 0 else 0 ) NEW_LINE DEDENT DEDENT
def import import * NEW_LINE from StringIO import StringIO NEW_LINE class A111 ( object ) : NEW_LINE INDENT def __init__ ( self , f ) : NEW_LINE INDENT self . f = f NEW_LINE DEDENT def __getattr__ ( self , attr ) : NEW_LINE INDENT return getattr ( self . f , attr ) NEW_LINE DEDENT def __getitem__ ( self , item ) : NEW_LINE INDENT return getattr ( self . f , attr ) NEW_LINE DEDENT def __setattr__ ( self , attr , value ) : NEW_LINE INDENT return setattr ( self . f , attr , value ) NEW_LINE DEDENT def __setitem__ ( self , item , value ) : NEW_LINE INDENT return setattr ( self . f , attr , value ) NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT for i in range ( len ( self . f ) ) : NEW_LINE INDENT self . f . write ( " % s \n " % i ) NEW_LINE DEDENT DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " A111 : ▁ % s \n " % repr ( self . f ) NEW_LINE DEDENT DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT import numpy as np NEW_LINE from math import log NEW_LINE L = np . zeros ( ( m + 1 , n + 1 ) ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L NEW_LINE def find_min_cost ( X , Y , cost_x , cost_y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE len_lcs = lcs ( X , Y , m , n ) NEW_LINE return cost_x * ( m - len_lcs ) + cost_y * ( n - len_lcs ) NEW_LINE DEDENT X = ' ef ' NEW_LINE Y = ' gh ' NEW_LINE print ( ' Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ ' ' ▁ identical ▁ is ▁ = ▁ { } ' . format ( find_min_cost ( X , Y , 10 , 20 ) ) ) NEW_LINE DEDENT
def number_of_squares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base // 2 NEW_LINE return base * ( base + 1 ) // 2 NEW_LINE DEDENT
def rmsValue ( arr , n ) : NEW_LINE INDENT square = mean = 0 NEW_LINE root = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT square += sum ( arr [ i ] ** 2 ) NEW_LINE DEDENT mean = ( square / float ( n ) ) NEW_LINE root = float ( math . sqrt ( mean ) ) NEW_LINE return root NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import product NEW_LINE from itertools import chain NEW_LINE M , N = product ( range ( M ) , repeat = N ) NEW_LINE P = chain ( range ( M ) , repeat = N ) NEW_LINE P . sort ( ) NEW_LINE dp = [ 0 ] * ( M + 10001 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT C = sum ( P ) NEW_LINE E = sum ( P ) NEW_LINE for j in range ( len ( dp ) - 1 , - C , - 1 ) : NEW_LINE INDENT if dp [ j - C ] == sum ( P ) : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ j ] = min ( dp [ j ] , dp [ j - C ] + E ) NEW_LINE DEDENT DEDENT dp = [ sum ( P ) for i in range ( M ) ] NEW_LINE for i in range ( M + 1 , len ( dp ) ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + P [ M - 1 - i ] NEW_LINE DEDENT for i in range ( M + 1 , len ( dp ) ) : NEW_LINE INDENT dp [ i ] = dp [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( dp ) ) : NEW_LINE INDENT if dp [ i ] == sum ( P ) : NEW_LINE INDENT continue NEW_LINE DEDENT ans = max ( ans , sum ( dp [ i ] - dp [ i ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE from itertools import chain NEW_LINE n = len ( sys . stdin . readline ( ) ) NEW_LINE iterable = [ chain ( iterable , repeat ( n + 1 ) ) for _ in range ( 1 , n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " node ▁ % d : ▁ key ▁ = ▁ % d , ▁ " % ( i , iterable [ i ] ) ) NEW_LINE if i / 2 > 0 : NEW_LINE INDENT print ( " parent ▁ key ▁ = ▁ % d , ▁ " % ( iterable [ i / 2 ] ) ) NEW_LINE DEDENT if 2 * i <= n : NEW_LINE INDENT print ( " left ▁ key ▁ = ▁ % d , ▁ " % ( iterable [ 2 * i ] ) ) NEW_LINE DEDENT if ( 2 * i + 1 ) <= n : NEW_LINE INDENT print ( " right ▁ key ▁ = ▁ % d , ▁ " % ( iterable [ 2 * i + 1 ] ) ) NEW_LINE DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT DEDENT
def GFG ( arr ) : NEW_LINE INDENT n , m = 6 , 6 NEW_LINE dp = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
def GFG ( ) : NEW_LINE INDENT def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y1 , y3 ) NEW_LINE x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE if x5 > x6 or y5 > y6 : NEW_LINE INDENT print ( " No ▁ intersection " ) NEW_LINE return NEW_LINE DEDENT print ( " ( % d , ▁ % d ) ▁ " % ( x5 , y5 ) , end = ' ▁ ' ) NEW_LINE print ( " ( % d , ▁ % d ) ▁ " % ( x6 , y6 ) , end = ' ▁ ' ) NEW_LINE x7 = x5 NEW_LINE y7 = y6 NEW_LINE print ( " ( % d , ▁ % d ) ▁ " % ( x7 , y7 ) , end = ' ▁ ' ) NEW_LINE x8 = x6 NEW_LINE y8 = y5 NEW_LINE print ( " ( % d , ▁ % d ) ▁ " % ( x8 , y8 ) , end = ' ▁ ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = 0 , 0 , 10 , 8 NEW_LINE x3 , y3 , x4 , y4 = 2 , 2 , 3 , 7 , 9 NEW_LINE FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) NEW_LINE DEDENT DEDENT
def _424A ( ) : NEW_LINE INDENT from math import sin , cos , cos , tan NEW_LINE sc = Scanner ( ) NEW_LINE n = sc . nextInt ( ) NEW_LINE sc . nextLine ( ) NEW_LINE s = sc . nextLine ( ) NEW_LINE sitting_to_standing = 0 NEW_LINE sitting , standing = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' x ' : NEW_LINE INDENT sitting += 1 NEW_LINE DEDENT else : NEW_LINE INDENT standing += 1 NEW_LINE DEDENT DEDENT sitting_to_standing = ( sitting - standing ) / 2 NEW_LINE print ( abs ( sitting_to_standing ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' x ' and sitting_to_standing > 0 : NEW_LINE INDENT print ( ' X ' , end = ' ' ) NEW_LINE sitting_to_standing -= 1 NEW_LINE DEDENT elif s [ i ] == ' X ' and sitting_to_standing < 0 : NEW_LINE INDENT print ( ' x ' , end = ' ' ) NEW_LINE sitting_to_standing += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def import import sys , StringIO , pipes , pipes , c , n , d , e , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input
def GFG ( W , wt , val , n ) : NEW_LINE INDENT maxratio = float ( 0 ) NEW_LINE maxindex = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( val [ i ] / wt [ i ] ) > maxratio : NEW_LINE INDENT maxratio = ( val [ i ] / wt [ i ] ) NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT return ( W * maxratio ) NEW_LINE def main ( ) : NEW_LINE INDENT val = [ 14 , 27 , 44 , 19 ] NEW_LINE wt = [ 6 , 7 , 9 , 8 ] NEW_LINE n = len ( val ) NEW_LINE W = 50 NEW_LINE print ( knapSack ( W , wt , val , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , arr , n ) : NEW_LINE INDENT arr = [ ] NEW_LINE v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT index , i , j = 0 , 0 , 0 NEW_LINE flag = False NEW_LINE if arr [ 0 ] % 2 == 0 : NEW_LINE INDENT flag = True NEW_LINE DEDENT while index < n : NEW_LINE INDENT if flag == True : NEW_LINE INDENT arr [ index ] = int ( v1 [ i ] ) NEW_LINE i += 1 NEW_LINE index += 1 NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = int ( v2 [ j ] ) NEW_LINE j += 1 NEW_LINE index += 1 NEW_LINE flag = not flag NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 9 , 8 , 13 , 2 , 19 , 14 ] NEW_LINE n = len ( arr ) NEW_LINE return GFG ( arr , n ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . A = sys . stdin . read ( ) NEW_LINE self . B = sys . stdin . read ( ) NEW_LINE self . C = sys . stdin . read ( ) NEW_LINE DEDENT def execute ( self ) : NEW_LINE INDENT if self . A <= self . C and self . B >= self . C : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def dec_to_binary ( n ) : NEW_LINE INDENT import struct NEW_LINE class GFG ( struct . Struct ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT binary_num = [ ] NEW_LINE i = 0 NEW_LINE while n > 0 : NEW_LINE INDENT binary_num . append ( n % 2 ) NEW_LINE n = n // 2 NEW_LINE i += 1 NEW_LINE DEDENT binary = " " NEW_LINE for i in binary_num [ i - 1 : - 1 ] : NEW_LINE INDENT binary += str ( binary_num [ i ] ) NEW_LINE DEDENT return binary NEW_LINE DEDENT def count_freq ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , N - M ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == M : NEW_LINE INDENT res += 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def find_occurrence ( self , arr , n , pattern ) : NEW_LINE INDENT for binary in dec_to_binary ( arr ) : NEW_LINE INDENT print ( " { } ▁ " . format ( count_freq ( pattern , binary ) ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 5 , 106 , 7 , 8 ] NEW_LINE pattern = "10" NEW_LINE n = len ( arr ) NEW_LINE find_occurrence ( arr , n , pattern ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += ( arr [ i ] & 1 ) NEW_LINE DEDENT print ( min ( x , n - x ) ) NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE return arr NEW_LINE DEDENT return main ( ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from random import shuffle NEW_LINE class Solution : NEW_LINE INDENT def find_kth_largest ( self , nums , k ) : NEW_LINE INDENT self . shuffle ( nums ) NEW_LINE k = len ( nums ) - k NEW_LINE lo = 0 NEW_LINE hi = len ( nums ) - 1 NEW_LINE while lo < hi : NEW_LINE INDENT ( i , j ) = partition ( nums , lo , hi ) NEW_LINE if j < k : NEW_LINE INDENT lo = j + 1 NEW_LINE DEDENT elif j > k : NEW_LINE INDENT hi = j - 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return nums [ k ] NEW_LINE DEDENT def partition ( self , a , lo , hi ) : NEW_LINE INDENT i = lo NEW_LINE j = hi + 1 NEW_LINE while True : NEW_LINE INDENT while i < hi and less ( a [ i ] , a [ lo ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while j > lo and less ( a [ lo ] , a [ -- j ] ) : NEW_LINE INDENT if i >= j : NEW_LINE INDENT break NEW_LINE DEDENT self . exch ( a , i , j ) NEW_LINE DEDENT self . exch ( a , lo , j ) NEW_LINE return j NEW_LINE DEDENT DEDENT def exch ( self , a , i , j ) : NEW_LINE INDENT ( tmp , a [ i ] ) = a [ i ] , a [ j ] NEW_LINE a [ i ] = tmp NEW_LINE DEDENT def less ( self , v , w ) : NEW_LINE INDENT return v < w NEW_LINE DEDENT def shuffle ( self , a ) : NEW_LINE INDENT import random NEW_LINE random . seed ( 0 ) NEW_LINE for ind in range ( 1 , len ( a ) ) : NEW_LINE INDENT r = random . randrange ( 0 , ind + 1 ) NEW_LINE self . exch ( a , ind , r ) NEW_LINE DEDENT DEDENT DEDENT sObj = Solution ( ) NEW_LINE nums = [ 3 , 2 , 1 , 5 , 6 , 4 ] NEW_LINE k = 2 NEW_LINE out = sObj . find_kth_largest ( nums , k ) NEW_LINE print ( out ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT temp = n NEW_LINE while n > 0 : NEW_LINE INDENT k = n % 10 NEW_LINE if temp % k == 0 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n /= 10 NEW_LINE DEDENT return " NO " NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT k = int ( n ) % 10 NEW_LINE sum += k NEW_LINE n /= 10 NEW_LINE DEDENT if temp % sum == 0 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT return " NO " NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s = sys . stdin NEW_LINE a = s . readline ( ) NEW_LINE b = s . readline ( ) NEW_LINE answer = " " NEW_LINE naa = len ( a ) NEW_LINE nab = len ( b ) NEW_LINE i = 0 NEW_LINE if naa == nab : NEW_LINE INDENT if a == b : NEW_LINE INDENT answer = " EQUAL " NEW_LINE DEDENT else : NEW_LINE INDENT for q in a : NEW_LINE INDENT l = b [ i ] - 0 NEW_LINE if q > l : NEW_LINE INDENT answer = " GREATER " NEW_LINE break NEW_LINE DEDENT elif q < l : NEW_LINE INDENT answer = " LESS " NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT elif naa > nab : NEW_LINE INDENT answer = " GREATER " NEW_LINE DEDENT elif naa < nab : NEW_LINE INDENT answer = " LESS " NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT
def calculate_area_sum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE max_size = min ( l , b ) NEW_LINE total_area = 0 NEW_LINE for i in range ( 1 , max_size + 1 ) : NEW_LINE INDENT total_squares = ( l - size + 1 ) * ( b - size + 1 ) NEW_LINE area = total_squares * size ** 2 NEW_LINE total_area += area NEW_LINE size += 1 NEW_LINE DEDENT return total_area NEW_LINE DEDENT
def gf_arrange ( N ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT print ( '1' ) NEW_LINE return NEW_LINE DEDENT if N == 2 or N == 3 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE return NEW_LINE DEDENT even , odd = - 1 , - 1 NEW_LINE if N % 2 == 0 : NEW_LINE INDENT even , odd = N , N - 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd , even = N , N - 1 NEW_LINE DEDENT while odd >= 1 : NEW_LINE INDENT print ( odd , end = ' ▁ ' ) NEW_LINE print ( ' ▁ ' , end = ' ▁ ' ) NEW_LINE odd = odd - 2 NEW_LINE DEDENT while even >= 2 : NEW_LINE INDENT print ( even , end = ' ▁ ' ) NEW_LINE print ( ' ▁ ' , end = ' ▁ ' ) NEW_LINE even = even - 2 NEW_LINE DEDENT DEDENT
def test_find_min_equal_sums ( ) : NEW_LINE INDENT import math NEW_LINE from numpy import abs NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_min_equal_sums ( self , a , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum1 , sum2 = 0 , 0 NEW_LINE min = float ( ' inf ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE sum2 = sum - sum1 NEW_LINE if abs ( sum1 - sum2 ) < min : NEW_LINE INDENT min = abs ( sum1 - sum2 ) NEW_LINE DEDENT if min == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT a = [ 3 , 2 , 1 , 5 , 7 , 8 ] NEW_LINE N = len ( a ) NEW_LINE print ( find_min_equal_sums ( a , N ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE t = sys . stdin . read ( ) . split ( ' \n ' ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = sys . stdin . read ( ) . split ( ' \n ' ) [ 0 ] NEW_LINE yield from repeat ( n ) NEW_LINE mod = n % 3 NEW_LINE if mod == 1 : NEW_LINE INDENT for i in range ( n // 3 ) : NEW_LINE INDENT yield from repeat ( 12 ) NEW_LINE DEDENT yield from repeat ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n // 3 ) : NEW_LINE INDENT yield from repeat ( 21 ) NEW_LINE DEDENT if mod == 2 : NEW_LINE INDENT yield from repeat ( 2 ) NEW_LINE DEDENT DEDENT print ( ' \n ' . join ( map ( str , repeat ( n ) ) ) ) NEW_LINE DEDENT DEDENT
def test_find_optimal_solution ( ) : NEW_LINE INDENT import numpy as np NEW_LINE import scipy . optimize NEW_LINE class GFG ( scipy . optimize . leastsq ) : NEW_LINE INDENT def find_optimal_solution ( self , a , N ) : NEW_LINE INDENT a = np . array ( a ) NEW_LINE points = np . sum ( a * np . ones ( N ) ) NEW_LINE return points NEW_LINE DEDENT DEDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEW_LINE N = len ( a ) NEW_LINE print ( find_optimal_solution ( a , N ) ) NEW_LINE DEDENT
def import import struct NEW_LINE from io import StringIO NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE from pydevd import pydevd import pydevd NEW_LINE from pydevd import pydevd NEW_LINE DEDENT
def import import sys , string , symbols , Dummy , factorial , Dummy , factorial , Dummy , factorial , Dummy , Dummy , Dummy NEW_LINE factorial = Dummy ( factorial ) NEW_LINE t = factorial ( factorial ) NEW_LINE while t : NEW_LINE INDENT n , m = Dummy . objects . get_or_create ( factorial = factorial ) NEW_LINE a = Dummy . objects . filter ( factorial = factorial ) NEW_LINE if n > factorial ( n ) : NEW_LINE INDENT Dummy . objects . create ( factorial = factorial ( n ) ) NEW_LINE continue NEW_LINE DEDENT a . sort ( ) NEW_LINE ans = a [ n - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE if i : NEW_LINE INDENT ans += factorial ( i ) NEW_LINE DEDENT DEDENT if ans <= factorial ( n ) : NEW_LINE INDENT Dummy . objects . create ( factorial = factorial ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT Dummy . objects . create ( factorial = factorial ( n ) ) NEW_LINE DEDENT DEDENT
def GFG ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in a : NEW_LINE INDENT for j in a : NEW_LINE INDENT if i < j : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def import import sys , StringIO , pipes , pipes , c , n , k , out = sys . stdout , pipes , c , n , k , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , k , n , n , k , n , k , n , k , n , k , n , k , n , n , k , n , n , k , n , k , n , n , k , n , k , n , n , k , n , n
def mainlist ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy . testing import assert_equal NEW_LINE sc = sc . sc NEW_LINE arr = [ ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT arr . append ( sc . sc ( ) ) NEW_LINE DEDENT DEDENT if arr [ 0 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 0 ] [ 1 ] == 1 or arr [ 0 ] [ 2 ] == 1 or arr [ 0 ] [ 0 ] == 1 or arr [ 1 ] [ 0 ] == 1 or arr [ 2 ] [ 1 ] == 1 or arr [ 3 ] [ 2 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 1 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 1 ] [ 1 ] == 1 or arr [ 1 ] [ 2 ] == 1 or arr [ 1 ] [ 0 ] == 1 or arr [ 2 ] [ 0 ] == 1 or arr [ 3 ] [ 2 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 2 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 2 ] [ 1 ] == 1 or arr [ 2 ] [ 2 ] == 1 or arr [ 2 ] [ 0 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 3 ] [ 1 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 3 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 3 ] [ 1 ] == 1 or arr [ 3 ] [ 2 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 3 ] [ 0 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 3 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 3 ] [ 1 ] == 1 or arr [ 3 ] [ 2 ] == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT N = 10000 NEW_LINE MOD = 1000000007 NEW_LINE F = [ ] NEW_LINE def precompute ( ) : NEW_LINE INDENT F . append ( 2 ) NEW_LINE F . append ( 3 ) NEW_LINE F . append ( 4 ) NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 8 NEW_LINE precompute ( ) NEW_LINE print ( F [ n ] ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import java . util . regex NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , z ) : NEW_LINE INDENT self . i , self . j , self . k , self . c , self . t , self . b = z NEW_LINE s = Scanner ( ) NEW_LINE for t in s . scan ( ) : NEW_LINE INDENT print ( self . b ) NEW_LINE for b in [ i , j , k , c , t , b ] : NEW_LINE INDENT for c , k in [ ( i , j , k , c ) , ( i , j , k , c ) , ( i , j , k , c ) , ( i , j , k , c ) ] : NEW_LINE INDENT print ( c ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def _import ( A , l , r , key ) : NEW_LINE INDENT from itertools import chain NEW_LINE class LIS : NEW_LINE INDENT def CeilIndex ( A , l , r , key ) : NEW_LINE INDENT while r - l > 1 : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if A [ m ] >= key : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def LongestIncreasingSubsequenceLength ( A , size ) : NEW_LINE INDENT tailTable = [ ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT if A [ i ] < tailTable [ 0 ] : NEW_LINE INDENT tailTable . append ( A [ i ] ) NEW_LINE DEDENT elif A [ i ] > tailTable [ - 1 ] : NEW_LINE INDENT tailTable . append ( A [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT tailTable [ CeilIndex ( tailTable , - 1 , len ( A ) - 1 , A [ i ] ) ] = A [ i ] NEW_LINE DEDENT DEDENT return tailTable NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT A = [ 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 ] NEW_LINE n = len ( A ) NEW_LINE print ( " Length ▁ of ▁ Longest ▁ Increasing ▁ Subsequence ▁ is ▁ " , LongestIncreasingSubsequenceLength ( A , n ) ) NEW_LINE DEDENT return LIS NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT s = sys . stdin NEW_LINE N = s . readline ( ) . strip ( ) NEW_LINE ban = [ s . readline ( ) . strip ( ) for i in range ( N ) ] NEW_LINE ban = [ s . readline ( ) . strip ( ) for i in ban ] NEW_LINE print ( ( ban [ N - 1 ] - ban [ 0 ] + 1 ) / 2 ) NEW_LINE DEDENT DEDENT
def _import library NEW_LINE from itertools import product , repeat NEW_LINE class p074 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT print ( self . _import ( ) ) NEW_LINE self . _import ( ) NEW_LINE DEDENT def get_chain_length ( self ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( self . _LIMIT ) : NEW_LINE INDENT if self . _chain_length ( ) == 60 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT def get_chain_length ( n ) : NEW_LINE INDENT seen = set ( ) NEW_LINE while True : NEW_LINE INDENT if n not in seen : NEW_LINE INDENT return len ( seen ) NEW_LINE DEDENT n = self . _factorialize ( n ) NEW_LINE DEDENT return sum ( ) NEW_LINE DEDENT FACTORIAL = [ 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 ] NEW_LINE def factorialize ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for _ in range ( 10 ) : NEW_LINE INDENT sum += FACTORIAL [ n % 10 ] NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT
def colour_visible ( height , colour , K ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , height , colour , K ) : NEW_LINE INDENT arr = np . zeros ( K + 1 ) NEW_LINE visible = 0 NEW_LINE max = height [ K - 1 ] NEW_LINE arr [ colour [ K - 1 ] ] = 1 NEW_LINE for i in range ( K - 2 , - 1 , - 1 ) : NEW_LINE INDENT if height [ i ] > max : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ colour [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT visible += 1 NEW_LINE DEDENT DEDENT return visible NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE colour = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE K = len ( colour ) NEW_LINE print ( self . colour_visible ( height , colour , K ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def check_powerof8 ( n ) : NEW_LINE INDENT i = math . log ( n ) / math . log ( 8 ) NEW_LINE return ( i - math . floor ( i ) < 0.000001 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdin = sys . stdin NEW_LINE for t in range ( 0 , sys . maxint - 1 , - 1 ) : NEW_LINE INDENT a = sys . stdin . read ( ) NEW_LINE b = sys . stdin . read ( ) NEW_LINE res = min ( ( a + b ) / 4 , min ( a , b ) ) NEW_LINE print ( res ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import import sys , asyncio NEW_LINE from asyncio import sleep NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT ( self . maxes , ) = [ ] NEW_LINE with asyncio . open_connection ( ' / proc / self / maxes ' ) as sc : NEW_LINE INDENT while True : NEW_LINE INDENT n , m = select . select ( [ 0 ] , [ ] , [ ] ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT points = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT points [ j ] += sc . get ( ) NEW_LINE if i == m - 1 and max < points [ j ] : NEW_LINE INDENT max = points [ j ] NEW_LINE DEDENT DEDENT DEDENT self . maxes . append ( max ) NEW_LINE DEDENT for max in maxes : NEW_LINE INDENT yield max NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stream = sys . stdin NEW_LINE self . t = sys . maxsize NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT n = sys . stdin . readline ( ) . strip ( ) NEW_LINE l = [ ] NEW_LINE r = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE r . append ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s < r [ i ] : NEW_LINE INDENT if l [ i ] > s : NEW_LINE INDENT s = l [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT s += 1 NEW_LINE DEDENT sys . stdout . write ( s + " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( 0 + " ▁ " ) NEW_LINE DEDENT DEDENT sys . stdout . write ( " \n " ) NEW_LINE DEDENT DEDENT DEDENT
def count_ways ( n , m ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . count = [ 0 ] * ( n + 1 ) NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i > m : NEW_LINE INDENT self . count [ i ] = self . count [ i - 1 ] + self . count [ i - m ] NEW_LINE DEDENT elif i < m : NEW_LINE INDENT self . count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . count [ i ] = 2 NEW_LINE DEDENT DEDENT return self . count [ n ] NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 7 NEW_LINE m = 4 NEW_LINE print ( " Number ▁ of ▁ ways ▁ = ▁ % d " % count_ways ( n , m ) ) NEW_LINE DEDENT return GFG ( n , m ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT print ( n + n // 2 ) NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE import os NEW_LINE import subprocess NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT bfr = sys . stdin NEW_LINE data = " " NEW_LINE try : NEW_LINE INDENT data = bfr . read ( ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT data = " " NEW_LINE DEDENT DEDENT res = 0 NEW_LINE han = 0 NEW_LINE ni_beki = 1 NEW_LINE ruijyo = 0 NEW_LINE if data == " " : NEW_LINE INDENT sys . exit ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res = int ( data ) NEW_LINE for i in range ( 1 , 4 ) : NEW_LINE INDENT han = ( res >> ruijyo ) % 2 NEW_LINE if han == 0 : NEW_LINE INDENT res = ( res % ni_beki ) + 1 NEW_LINE i = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT ni_beki = ni_beki * 2 NEW_LINE ruijyo += 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE s = sc . readline ( ) NEW_LINE while '0B ' in s or '1B ' in s : NEW_LINE INDENT s = s . decode ( ' utf - 8' ) NEW_LINE s = s . decode ( ' utf - 8' ) NEW_LINE DEDENT s = s . decode ( ' utf - 8' ) NEW_LINE print ( s ) NEW_LINE DEDENT DEDENT
def import import _intlist NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import itertools NEW_LINE import itertools NEW_LINE import itertools NEW_LINE import itertools NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . next = None NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT a = sys . stdin . read ( 1 ) NEW_LINE b = sys . stdin . read ( 1 ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count = itertools . count ( 0 ) NEW_LINE used = [ ] NEW_LINE def intlist ( x ) : NEW_LINE INDENT for y in x : NEW_LINE INDENT if y != x : NEW_LINE INDENT continue NEW_LINE DEDENT for z in x + y + z : NEW_LINE INDENT if z != x and z != y : NEW_LINE INDENT continue NEW_LINE DEDENT if z in used : NEW_LINE INDENT return NEW_LINE DEDENT used . append ( z ) NEW_LINE count . append ( 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( count [ 0 ] ) NEW_LINE DEDENT DEDENT DEDENT
def import _gcd NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT MAX = 100 NEW_LINE DEDENT def recur ( self , ind , cnt , last , a , n , k , dp ) : NEW_LINE INDENT if cnt == k : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ind == n : NEW_LINE INDENT return int ( - 1e9 ) NEW_LINE DEDENT if dp [ self ] [ cnt ] != - 1 : NEW_LINE INDENT return dp [ self ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( self , ind , n ) : NEW_LINE INDENT if cnt % 2 == 0 : NEW_LINE INDENT ans = max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) NEW_LINE DEDENT DEDENT return dp [ self ] [ cnt ] = ans NEW_LINE DEDENT def __gcd ( self , a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return __gcd ( b , a % b ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a = [ 4 , 5 , 3 , 7 , 8 , 10 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE k = 4 NEW_LINE dp = [ [ - 1 ] * MAX for i in range ( n ) ] NEW_LINE print ( recur ( 0 , 0 , 0 , a , n , k , dp ) ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE n = int ( math . ceil ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . math ( math ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) NEW_LINE lines = [ ] NEW_LINE n = int ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) NEW_LINE lines = [ ] NEW_LINE DEDENT
def equivalent_base4 ( bin ) : NEW_LINE INDENT if bin == '00' : return 0 NEW_LINE if bin == '01' : return 1 NEW_LINE if bin == '10' : return 2 NEW_LINE return 3 NEW_LINE DEDENT def is_divisible_by5 ( bin ) : NEW_LINE INDENT l = len ( bin ) NEW_LINE if l % 2 : NEW_LINE INDENT bin = '0' + bin NEW_LINE DEDENT odd_sum , even_sum = 0 , 0 NEW_LINE is_odd_digit = 1 NEW_LINE for i in range ( 0 , len ( bin ) , 2 ) : NEW_LINE INDENT if is_odd_digit != 0 : NEW_LINE INDENT odd_sum += equivalent_base4 ( bin [ i : i + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT even_sum += equivalent_base4 ( bin [ i : i + 2 ] ) NEW_LINE DEDENT is_odd_digit ^= 1 NEW_LINE DEDENT if abs ( odd_sum - even_sum ) % 5 == 0 : NEW_LINE INDENT return ' Yes ' NEW_LINE DEDENT return ' No ' NEW_LINE DEDENT
def import _import_string NEW_LINE import collections NEW_LINE import os NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import scanner NEW_LINE class Main ( object ) : NEW_LINE INDENT queue = collections . deque ( ) NEW_LINE map = { } NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . queue = [ ] NEW_LINE map = { } NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . map = { } NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . map [ self . map [ 0 ] ] = 0 NEW_LINE DEDENT def d ( self ) : NEW_LINE INDENT d = [ [ 0 , 1 , 4 ] , [ - 1 , 1 , 4 ] , [ - 1 , 1 , 4 ] , [ - 1 , 0 , 4 ] , [ 0 , 1 , - 4 ] , [ - 1 , 1 , - 4 ] , [ - 1 , 1 , - 4 ] , [ - 1 , 0 , - 4 ] ] NEW_LINE def bfs ( self ) : NEW_LINE INDENT while not self . queue . empty ( ) : NEW_LINE INDENT str1 = self . queue . popleft ( ) NEW_LINE point = map . get ( str1 ) NEW_LINE str2 = ' ' NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT if str1 [ i ] == '0' : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT change = str1 [ i + d [ i ] [ j ] ] NEW_LINE str2 = str1 . replace ( '0' , '9' ) NEW_LINE str2 = str2 . replace ( change , '0' ) NEW_LINE str2 = str2 . replace ( '9' , change ) NEW_LINE if not map . get ( str2 ) : NEW_LINE INDENT map [ str2 ] = self . point + 1 NEW_LINE self . queue . append ( str2 ) NEW_LINE DEDENT DEDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT with scanner : NEW_LINE INDENT self . queue . append ( '01234567' ) NEW_LINE map . put ( '01234567' , 0 ) NEW_LINE self . bfs ( ) NEW_LINE for s in scanner : NEW_LINE INDENT token = s . split ( ) NEW_LINE str = ' ' NEW_LINE for t in token : NEW_LINE INDENT str += t NEW_LINE DEDENT print ( map [ str ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import _util NEW_LINE class _SmallestNumber ( object ) : NEW_LINE INDENT def __init__ ( self , min ) : NEW_LINE INDENT self . min = float ( min ) NEW_LINE DEDENT def __init__ ( self , arr , ops , idx ) : NEW_LINE INDENT self . ops = ops NEW_LINE self . util ( arr , ops , 0 ) NEW_LINE print ( self . min ) NEW_LINE DEDENT def util ( self , arr , ops , idx ) : NEW_LINE INDENT if idx == 3 : NEW_LINE INDENT self . min = min ( self . min , arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( arr ) ) : NEW_LINE INDENT a = [ ] NEW_LINE for k in range ( len ( arr ) ) : NEW_LINE INDENT if k != j and k != i : NEW_LINE INDENT a . append ( arr [ k ] ) NEW_LINE DEDENT DEDENT if idx < 3 and ops [ idx ] == ' + ' : NEW_LINE INDENT res = arr [ i ] + arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT res = arr [ i ] * arr [ j ] NEW_LINE DEDENT a . append ( res ) NEW_LINE self . util ( a , ops , idx + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import random NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import LongTest NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE from sympy . utilities . randtest import ( ) NEW_LINE DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . x = sys . stdin . read ( ) NEW_LINE self . a = sys . stdin . read ( ) NEW_LINE self . b = sys . stdin . read ( ) NEW_LINE print ( ( x - a ) % b ) NEW_LINE DEDENT DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( self . n ) NEW_LINE self . k = int ( self . k ) NEW_LINE arr = [ ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT idx = self . k - 1 NEW_LINE flag = True NEW_LINE while idx < self . n : NEW_LINE INDENT if arr [ idx ] != arr [ self . k - 1 ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT idx += 1 NEW_LINE DEDENT if not flag : NEW_LINE INDENT sys . stdout . write ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT i = self . k - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if arr [ i ] != arr [ self . k - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n ) : return n & ( n - 1 ) NEW_LINE def main ( arg ) : NEW_LINE INDENT n = 7 NEW_LINE print ( " The ▁ number ▁ after ▁ unsetting ▁ " " the ▁ rightmost ▁ set ▁ bit ▁ " , fun ( n ) , end = ' ▁ ' ) NEW_LINE DEDENT
def LongestFibSubseq ( A , n ) : NEW_LINE INDENT import bisect NEW_LINE S = bisect . bisect_left ( A , n ) NEW_LINE maxLen , x , y = 0 , 0 , A [ i ] , A [ i ] + A [ j ] NEW_LINE length = 3 NEW_LINE while y in S and ( y != S . last ( ) ) : NEW_LINE INDENT z = x + y NEW_LINE x , y = y , z NEW_LINE maxLen = max ( maxLen , 1 ) NEW_LINE length += 1 NEW_LINE DEDENT return maxLen if maxLen >= 3 else 0 NEW_LINE DEDENT
def test_gf_gcd ( ) : NEW_LINE INDENT import os NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , a , b , n , m ) : NEW_LINE INDENT self . cnt = 0 NEW_LINE self . s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT sum = a [ i ] + b [ j ] NEW_LINE if sum in self . s : NEW_LINE INDENT self . cnt += 1 NEW_LINE self . s . add ( sum ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def GFG ( arr , x , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = math . sqrt ( arr [ i ] ) NEW_LINE if math . floor ( y ) == math . ceil ( y ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if sum % x == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def import select , queue , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes NEW_LINE
def _calculate_min_sum ( a , n ) : NEW_LINE INDENT import math NEW_LINE def calculate_min_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE min_sum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT min_sum += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT return min_sum NEW_LINE DEDENT def calculate_max_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE max_sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT max_sum += abs ( a [ n - 1 - i ] - a [ i ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = [ 10 , - 10 , 20 , - 40 ] NEW_LINE n = len ( a ) NEW_LINE print ( ' The ▁ minimum ▁ sum ▁ of ▁ pairs ▁ is ▁ { } ' . format ( calculate_min_sum ( a , n ) ) ) NEW_LINE print ( ' The ▁ maximum ▁ sum ▁ of ▁ pairs ▁ is ▁ { } ' . format ( calculate_max_sum ( a , n ) ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( sys . stdin . read ( ) ) NEW_LINE self . a = [ ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT self . a . append ( sys . stdin . read ( ) ) NEW_LINE DEDENT self . m = int ( sys . stdin . read ( ) ) NEW_LINE self . b = [ ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT if self . b >= self . a : NEW_LINE INDENT print ( '0' ) NEW_LINE break NEW_LINE DEDENT if self . a >= self . b : NEW_LINE INDENT print ( '1' ) NEW_LINE break NEW_LINE DEDENT if self . a > self . b : NEW_LINE INDENT print ( '0' ) NEW_LINE break NEW_LINE DEDENT if self . a < self . b : NEW_LINE INDENT print ( '1' ) NEW_LINE break NEW_LINE DEDENT self . a += 1 NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import chain NEW_LINE from itertools import chain NEW_LINE from itertools import chain NEW_LINE def main ( ) : NEW_LINE INDENT global sum NEW_LINE sc = chain ( [ ] , repeat ( a ) ) NEW_LINE a = sc . __next__ ( ) NEW_LINE state_list = [ ] NEW_LINE cnt4 = cnt2 = work = 0 NEW_LINE for i in chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , chain ( a , a , chain ( a , a , c ) , c ) , c ) , ) , ) , ) , ) , ) , ) , ) , ) , ) , ) , ) , ) ] NEW_LINE for i in range ( a ) ) : NEW_LINE INDENT state_list . append ( sc . __next__ ( ) ) ) NEW_LINE work = state_list [ i ] % 4 NEW_LINE if work == 0 : NEW_LINE INDENT cnt4 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT work = state_list [ i ] % 2 NEW_LINE if work == 0 : NEW_LINE INDENT cnt2 += 1 NEW_LINE DEDENT DEDENT DEDENT work = a // 2 NEW_LINE if work <= cnt4 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT work = a - ( cnt4 * 2 ) NEW_LINE if ( work == 0 ) | ( cnt2 == 0 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT if work == cnt2 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT print ( " No " ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def isPalindrome ( s ) : NEW_LINE INDENT import random NEW_LINE from math import sin , cos , exp NEW_LINE def isPalindrome ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ - i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def ans ( s ) : NEW_LINE INDENT s2 = s NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s2 = s2 [ - 1 ] + s2 NEW_LINE s2 = s2 [ : - 1 ] NEW_LINE if ( s , s2 ) not in ans ( s2 ) and isPalindrome ( s2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT if len ( s ) <= 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 ] * 25 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ s [ i ] - ' a ' ] += 1 NEW_LINE DEDENT if sum ( cnt ) >= ( len ( s ) - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ans ( s ) and 1 or 2 ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT s = ' nolon ' NEW_LINE print ( solve ( s ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def test_gf_count_numbers ( k , n ) : NEW_LINE INDENT import sympy NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . dp = [ [ 0 , k - 1 ] ] * ( n + 1 ) NEW_LINE DEDENT def count_numbers ( self , k , n ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT k = 10 NEW_LINE n = 3 NEW_LINE print ( count_numbers ( self , k , n ) ) NEW_LINE DEDENT return GFG ( k , n ) NEW_LINE DEDENT
def GfG ( n , arr , cost ) : NEW_LINE INDENT sum , total_cost = 0 , 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE total_cost += cost * sum NEW_LINE DEDENT arr [ n - 1 ] += sum NEW_LINE total_cost += ( 2 * cost * arr [ n - 1 ] ) NEW_LINE return total_cost NEW_LINE DEDENT
def import _main NEW_LINE from os . path import isfile , isfile NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os . path import join NEW_LINE from os import sep NEW_LINE from os import chdir NEW_LINE from os import environ NEW_LINE from os import chdir NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . main = Main ( ) NEW_LINE self . team_formation_make ( ) NEW_LINE return NEW_LINE DEDENT def team_formation_make ( self ) : NEW_LINE INDENT stdin = open ( ' input . txt ' , ' r ' ) NEW_LINE try : NEW_LINE INDENT input_str = stdin . readline ( ) NEW_LINE year_num = int ( input_str ) NEW_LINE programmer_list = [ ] NEW_LINE team_num = 0 NEW_LINE for i in range ( year_num ) : NEW_LINE INDENT team_str = stdin . readline ( ) NEW_LINE team_strs = team_str . split ( ) NEW_LINE programmer_list . append ( list ( ) ) NEW_LINE for j in team_strs : NEW_LINE INDENT programmer_list [ i ] . append ( int ( j ) ) NEW_LINE DEDENT DEDENT for i in range ( year_num ) : NEW_LINE INDENT c , a , n = programmer_list [ i ] NEW_LINE while True : NEW_LINE INDENT if c >= 1 and a >= 1 and n >= 1 : NEW_LINE INDENT team_num += 1 NEW_LINE c -= 1 NEW_LINE a -= 1 NEW_LINE n -= 1 NEW_LINE DEDENT elif c >= 2 and a >= 1 : NEW_LINE INDENT team_num += 1 NEW_LINE c = c - 2 NEW_LINE a -= 1 NEW_LINE DEDENT elif c >= 3 : NEW_LINE INDENT team_num += 1 NEW_LINE c = c - 3 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( team_num ) NEW_LINE team_num = 0 NEW_LINE DEDENT DEDENT finally : NEW_LINE INDENT stdin . close ( ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE for n in range ( 1 , len ( sys . stdin ) ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT m = sys . stdin . read ( n ) - ( n << 1 ) NEW_LINE ch = ( sys . stdin . read ( n ) ) . decode ( ' utf - 8' ) NEW_LINE count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ch [ i ] == ' I ' : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ch [ i + 1 + ( j << 1 ) ] != ' O ' or ch [ i + ( ( j + 1 ) << 1 ) ] != ' I ' : NEW_LINE INDENT break NEW_LINE DEDENT elif j == n - 1 : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT
def import _sys , _sys , _readline , _sys , _sre , _sre , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_compile , re_
def import import sys NEW_LINE class Node ( object ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT class GFG ( Node ) : NEW_LINE INDENT def insert ( self , root , data ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT if data < root . data : NEW_LINE INDENT root . left = insert ( root . left , data ) NEW_LINE DEDENT if data > root . data : NEW_LINE INDENT root . right = insert ( root . right , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT def inOrder ( self ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT inOrder ( self . left ) NEW_LINE print ( root . data , end = ' ▁ ' ) NEW_LINE inOrder ( self . right ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE root = None NEW_LINE for i in range ( n ) : NEW_LINE INDENT root = insert ( root , arr [ i ] ) NEW_LINE DEDENT inOrder ( root ) NEW_LINE DEDENT DEDENT
def GFG ( str , k ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE def removeChars ( str , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( str ) NEW_LINE for c in str : NEW_LINE INDENT hash [ c - ' a ' ] += 1 NEW_LINE DEDENT res = " " NEW_LINE for c in str : NEW_LINE INDENT if hash [ c - ' a ' ] >= k : NEW_LINE INDENT res += c NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT return str NEW_LINE DEDENT
def LongestCommonSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCStuff = [ ] NEW_LINE result = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] : NEW_LINE INDENT LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCStuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def count_occurrences ( self , x , d ) : NEW_LINE INDENT count = 0 NEW_LINE while x > 0 : NEW_LINE INDENT if x % 10 == d : NEW_LINE INDENT count += 1 NEW_LINE DEDENT x = x / 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def max_occurring ( self , x ) : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT x = - x NEW_LINE DEDENT result = 0 NEW_LINE max_count = 1 NEW_LINE for d in range ( 0 , 9 ) : NEW_LINE INDENT count = count_occurrences ( x , d ) NEW_LINE if count >= max_count : NEW_LINE INDENT max_count = count NEW_LINE result = d NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT x = 1223355 NEW_LINE print ( " Max ▁ occurring ▁ digit ▁ is ▁ % d " % max_occurring ( x ) ) NEW_LINE DEDENT
def print_logest_inc_sub_arr ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE max , len , max_index = 1 , 1 , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ i - 1 ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if max < len : NEW_LINE INDENT max = len NEW_LINE max_index = i - max NEW_LINE DEDENT len = 1 NEW_LINE DEDENT DEDENT if max < len : NEW_LINE INDENT max = len NEW_LINE max_index = n - max NEW_LINE DEDENT for i in range ( max_index , max + max_index ) : NEW_LINE INDENT sys . stdout . write ( " % d ▁ " % arr [ i ] ) NEW_LINE DEDENT DEDENT
def import import sys , string , traceback ; NEW_LINE from time import sleep NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE
def import import struct NEW_LINE import sys NEW_LINE import random NEW_LINE import time NEW_LINE import sys NEW_LINE class program ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sf = sys . stdin NEW_LINE t = 1 NEW_LINE for t1 in range ( t ) : NEW_LINE INDENT n , m , p , hash = struct . unpack ( ' > IIII ' , sf . read ( 8 ) ) NEW_LINE DEDENT DEDENT def program ( ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT l , r , x = struct . unpack ( ' > IIII ' , sf . read ( 8 ) ) NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE x -= 1 NEW_LINE ind = x NEW_LINE if ind < l or ind > r : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT hash1 = { } NEW_LINE for j in range ( l ) : NEW_LINE INDENT hash1 [ p [ j ] ] += 1 NEW_LINE DEDENT for j in range ( r + 1 ) : NEW_LINE INDENT hash1 [ p [ j ] ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if hash1 [ j ] == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if j == hash [ x ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dif1 = ind - l + 1 NEW_LINE if dif1 != cnt : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . Sum ) : NEW_LINE INDENT def __init__ ( self , a , n ) : NEW_LINE INDENT b = [ ] NEW_LINE S = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( res ) NEW_LINE res += a [ i ] NEW_LINE S += a [ i ] NEW_LINE res = max ( res , - S ) NEW_LINE DEDENT ans = S NEW_LINE ans = max ( ans , res ) NEW_LINE g = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT g -= a [ i ] NEW_LINE ans = max ( ans , g + b [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT a = [ - 6 , 10 , - 3 , 10 , - 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( ' Maximum ▁ sum ▁ is : ▁ { } ' . format ( Max_Sum ( a , n ) ) ) NEW_LINE DEDENT
def test_A1452 ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE try : NEW_LINE INDENT t = sys . maxsize NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT print ( " No ▁ such ▁ file ▁ or ▁ directory " ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT while t : NEW_LINE INDENT a = sys . stdin . read ( 2 ) NEW_LINE a . close ( ) NEW_LINE sys . stdout . write ( a ) NEW_LINE if a [ 0 ] == a [ 1 ] : NEW_LINE INDENT assert_almost_equal ( 2 * a [ 0 ] , a [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT assert_almost_equal ( 2 * a [ 1 ] - 1 , a [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( x ) : NEW_LINE INDENT n = ( len ( str ) - x ) / 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( str [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( n + x - 1 , n - 1 , - 1 ) : NEW_LINE INDENT print ( str [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( n + x , len ( str ) ) : NEW_LINE INDENT print ( str [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT str = ' geeksforgeeks ' NEW_LINE x = 3 NEW_LINE reverse ( str , x ) NEW_LINE DEDENT DEDENT
def GFG ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 1 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if str [ i ] == str [ j ] and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif str [ i ] == str [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT if ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def _ import _ , ▁ sys . stdout , ▁ sys . stderr ) : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁
def test_p187 ( ) : NEW_LINE INDENT import library NEW_LINE print ( library . p187 ( ) . run ( ) ) NEW_LINE LIMIT = library . pow ( 10 , 8 ) - 1 NEW_LINE def run ( ) : NEW_LINE INDENT count = 0 NEW_LINE primes = library . list_primes ( LIMIT / 2 ) NEW_LINE for i , sqrt in enumerate ( reversed ( range ( len ( primes ) ) ) ) : NEW_LINE INDENT end = bisect . bisect_right ( primes , LIMIT / primes [ i ] ) NEW_LINE if end >= 0 : NEW_LINE INDENT end += 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = - end - 1 NEW_LINE DEDENT count += end - i NEW_LINE DEDENT return str ( count ) NEW_LINE DEDENT return run NEW_LINE DEDENT
def import _solution NEW_LINE class Solution : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . M = 20 NEW_LINE DEDENT def dp ( self , pos , cnt , tight , nonz , num ) : NEW_LINE INDENT if pos == len ( num ) : NEW_LINE INDENT if cnt == K : return 1 NEW_LINE return 0 NEW_LINE DEDENT if self . dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 : NEW_LINE INDENT return self . dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = ( ( 9 if tight != 0 else num [ pos ] ) ) NEW_LINE for dig in range ( 0 , limit ) : NEW_LINE INDENT curr_cnt = cnt NEW_LINE if dig == d : NEW_LINE INDENT if d != 0 or ( d == 0 and nonz != 0 ) : NEW_LINE INDENT curr_cnt += 1 NEW_LINE DEDENT DEDENT curr_ght = tight NEW_LINE if dig < num [ pos ] : NEW_LINE INDENT curr_ght = 1 NEW_LINE DEDENT ans += count ( pos + 1 , curr_cnt , curr_ght , ( 1 if dig != 0 else 0 ) , num ) NEW_LINE DEDENT return self . dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT num = [ ] NEW_LINE while x != 0 : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x /= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( 2 ) : NEW_LINE INDENT for l in range ( 2 ) : NEW_LINE INDENT self . dp [ i ] [ j ] [ k ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return self . count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT L , R = 11 , 100 NEW_LINE d = 2 , 1 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def test_numerical_stability ( ) : NEW_LINE INDENT import math NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE class Test1 ( object ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE DEDENT def __call__ ( self , x ) : NEW_LINE INDENT return self . data NEW_LINE DEDENT DEDENT x = np . random . random ( ( 10 , ) ) NEW_LINE while x > 0 : NEW_LINE INDENT r = x % 10 NEW_LINE if 9 - r < r : NEW_LINE INDENT if x // 10 == 0 and 9 - r == 0 : NEW_LINE INDENT data . append ( r ) NEW_LINE DEDENT else : NEW_LINE INDENT data . append ( 9 - r ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT data . append ( r ) NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT pow = 0 NEW_LINE new_number = 0 NEW_LINE for i in data : NEW_LINE INDENT new_number = new_number + i * int ( math . pow ( 10 , pow ) ) NEW_LINE pow += 1 NEW_LINE DEDENT assert_almost_equal ( new_number , 1 ) NEW_LINE DEDENT
def GFG ( arr , n , num , i , j ) : NEW_LINE INDENT from scipy . stats import gaussian_filter NEW_LINE if i >= 0 and arr [ i ] > num : NEW_LINE INDENT return False NEW_LINE DEDENT if j < n and arr [ j ] > num : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def is_trough ( arr , n , num , i , j ) : NEW_LINE INDENT if i >= 0 and arr [ i ] < num : NEW_LINE INDENT return False NEW_LINE DEDENT if j < n and arr [ j ] < num : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def print_peaks_toughs ( arr , n ) : NEW_LINE INDENT print ( " Peaks ▁ : ▁ " , end = ' ▁ ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if is_peak ( arr , n , arr [ i ] , i - 1 , i + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE print ( " Troughs ▁ : ▁ " , end = ' ▁ ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if is_trough ( arr , n , arr [ i ] , i - 1 , i + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 5 , 10 , 5 , 7 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print_peaks_toughs ( arr , n ) NEW_LINE DEDENT
def GFG ( i ) : return 1 + ( i >> 31 ) - ( - i >> 31 ) NEW_LINE def check ( n ) : NEW_LINE INDENT s = [ " negative " , " zero " , " positive " ] NEW_LINE val = index ( n ) NEW_LINE print ( n , s [ val ] ) NEW_LINE DEDENT
def import _pylab NEW_LINE class GFG ( object ) : NEW_LINE INDENT def frequency ( self , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == x : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a = [ 0 , 5 , 5 , 5 , 4 ] NEW_LINE x = 5 NEW_LINE n = len ( a ) NEW_LINE print ( frequency ( a , n , x ) ) NEW_LINE DEDENT DEDENT
def __is_num_balanced ( num ) : NEW_LINE INDENT import string NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . num = abs ( num ) NEW_LINE str = " % d " % num NEW_LINE ch_arr = str . split ( " ▁ " ) NEW_LINE hs = set ( ch for ch in ch_arr ) NEW_LINE str_len = len ( str ) NEW_LINE hs_len = len ( hs ) NEW_LINE if hs_len <= str_len / 2 or hs_len == str_len : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT N = 1234567890 NEW_LINE flag = __is_num_balanced ( N ) NEW_LINE if flag : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n <= 1 : return False NEW_LINE if n <= 3 : return True NEW_LINE if n % 2 == 0 or n % 3 == 0 : return False NEW_LINE for i in range ( 5 , 2 ** n , 6 ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : return False NEW_LINE DEDENT return True NEW_LINE DEDENT def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = int ( math . sqrt ( n ) ) NEW_LINE if 1 * sq ** 2 != n : return False NEW_LINE return True if isPrime ( sq ) else False NEW_LINE DEDENT
def test_p065 ( ) : NEW_LINE INDENT import sympy NEW_LINE from sympy . utilities . misc import get_base_args NEW_LINE print ( get_base_args ( ) ) NEW_LINE def run ( ) : NEW_LINE INDENT n = 1 NEW_LINE d = 0 NEW_LINE for i in range ( 99 , - 1 , - 1 ) : NEW_LINE INDENT temp = get_base_args ( continued_fraction_term ( i ) ) * n + d NEW_LINE d = n NEW_LINE n = temp NEW_LINE DEDENT sum = 0 NEW_LINE while not n in [ 0 , 1 , 2 ] : NEW_LINE INDENT divrem = n // 2 NEW_LINE sum += divrem [ 1 ] [ 0 ] NEW_LINE n = divrem [ 0 ] NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT def continued_fraction_term ( i ) : NEW_LINE INDENT if i == 0 : return 2 NEW_LINE elif i % 3 == 2 : return i // 3 * 2 + 2 NEW_LINE else : return 1 NEW_LINE DEDENT return run ( ) NEW_LINE DEDENT
def __gcd ( a , b ) : NEW_LINE INDENT from math import pow NEW_LINE if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( b , a % b ) NEW_LINE DEDENT def LCM ( x , y , z ) : NEW_LINE INDENT ans = ( ( x * y ) / ( __gcd ( x , y ) ) ) NEW_LINE return ( ( z * ans ) / ( __gcd ( ans , z ) ) ) NEW_LINE DEDENT def findDivisible ( n , x , y , z ) : NEW_LINE INDENT lcm = LCM ( x , y , z ) NEW_LINE ndigitnumber = int ( pow ( 10 , n - 1 ) ) NEW_LINE reminder = ndigitnumber % lcm NEW_LINE if reminder == 0 : return ndigitnumber NEW_LINE ndigitnumber += lcm - reminder NEW_LINE if ndigitnumber < pow ( 10 , n ) : return ndigitnumber NEW_LINE else : return 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , x , y , z = 4 , 2 , 3 , 5 NEW_LINE res = findDivisible ( n , x , y , z ) NEW_LINE if res : print ( res ) NEW_LINE else : print ( " Not ▁ possible " ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT MAXN = 100001 NEW_LINE prime = [ True for i in range ( MAXN ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in prime : NEW_LINE INDENT yield True NEW_LINE DEDENT DEDENT prime = [ False for i in range ( MAXN ) ] NEW_LINE for p in range ( 2 , 2 * MAXN ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , MAXN + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT def common_prime ( a , b ) : NEW_LINE INDENT gcd = int ( __gcd ( a , b ) ) NEW_LINE for i in range ( 2 , ( gcd ) + 1 ) : NEW_LINE INDENT if prime [ i ] and gcd % i == 0 : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def __gcd ( a , b ) : NEW_LINE INDENT if not a : NEW_LINE INDENT return b NEW_LINE DEDENT return __gcd ( b % a , a ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE a , b = 6 , 12 NEW_LINE common_prime ( a , b ) NEW_LINE DEDENT DEDENT
def import _main NEW_LINE import sys NEW_LINE import random NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random as np NEW_LINE import numpy . random NEW_LINE import numpy . random as np NEW_LINE import numpy . random NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as as np NEW_LINE from sklearn . _main import _main NEW_LINE DEDENT
def _ import _ , ▁ sys . stdout , ▁ sys . stdout , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stdout , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stdout , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stdout , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr , ▁ sys . stderr ,
def import _solve NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , n , M ) : NEW_LINE INDENT self . N = 205 NEW_LINE self . M = 205 NEW_LINE self . grid = [ [ 0 for i in range ( self . N ) ] for j in range ( self . M ) ] NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT self . n , self . m = self . n , self . m NEW_LINE for line in self . line : NEW_LINE INDENT for i in range ( self . m ) : NEW_LINE INDENT self . grid [ i ] [ j ] = self . grid [ i ] [ j ] - '0' NEW_LINE DEDENT DEDENT DEDENT for i in range ( self . n - 1 ) : NEW_LINE INDENT for j in range ( self . m - 1 ) : NEW_LINE INDENT sum = self . grid [ i ] [ j ] + self . grid [ i + 1 ] [ j ] + self . grid [ i ] [ j + 1 ] + self . grid [ i + 1 ] [ j + 1 ] NEW_LINE if sum == 3 : NEW_LINE INDENT self . print ( " NO " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT self . print ( " YES " ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE from itertools import chain NEW_LINE from itertools import chain NEW_LINE from itertools import chain NEW_LINE tc = 1 NEW_LINE while repeat : NEW_LINE INDENT n , k = chain ( repeat ( n ) , repeat ( k ) ) NEW_LINE chain ( [ s for s in chain ( chain ( [ s ] , repeat ( s ) ) for s in chain ( [ s ] , repeat ( s ) ) ] , repeat ( s ) ) for s in chain ( [ s for s in chain ( [ s for s in chain ( [ s for s in chain ( s , repeat ( s ) ] , repeat ( s ) ) for s in chain ( s , repeat ( s ) ) ] , repeat ( s ) ) ] , repeat ( s ) ) ] , repeat ( s ) ) ) NEW_LINE p = chain ( chain ( [ s for s in chain ( [ s for s in chain ( s , repeat ( s ) ] , repeat ( s ) ) for s in chain ( [ s for s in chain ( s , repeat ( s ) ] , repeat ( s ) ) for s in chain ( s , repeat ( s ) ) ] , repeat ( s ) ) for s in chain ( [ s for s in chain ( s , repeat ( s ) ] , repeat ( s ) ) ] , repeat ( s ) ) ) for s in chain ( [ s for s in chain ( [ s for s in chain ( s , repeat ( s ) ] , repeat ( s ) ) ] , repeat ( s ) ) ] , repeat ( s ) ) ) NEW_LINE min , max = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if len ( i ) == plen : NEW_LINE INDENT min += 1 NEW_LINE break NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE min += 1 NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT k = kk NEW_LINE min += 5 NEW_LINE DEDENT DEDENT k = kk NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( i == plen and i + 1 > plen ) : NEW_LINE INDENT max += 1 NEW_LINE break NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE max += 1 NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT k = kk NEW_LINE max += 5 NEW_LINE DEDENT DEDENT if len ( i ) == plen : NEW_LINE INDENT max += 1 NEW_LINE DEDENT print ( min , max ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE with open ( ' test . txt ' , ' r ' ) as infile : NEW_LINE INDENT word1 = infile . read ( ) . decode ( ' utf - 8' ) . lower ( ) NEW_LINE word2 = infile . read ( ) . decode ( ' utf - 8' ) . lower ( ) NEW_LINE word3 = infile . read ( ) . decode ( ' utf - 8' ) . lower ( ) NEW_LINE perm1 = word1 + word2 + word3 NEW_LINE perm2 = word1 + word3 + word2 NEW_LINE perm3 = word2 + word1 + word3 NEW_LINE perm4 = word2 + word3 + word1 NEW_LINE perm5 = word3 + word2 + word1 NEW_LINE perm6 = word3 + word1 + word2 NEW_LINE students = len ( infile ) NEW_LINE infile . write ( ' \n ' ) NEW_LINE for case in [ perm1 , perm2 , perm3 , perm4 , perm5 , perm6 ] : NEW_LINE INDENT print ( ' ACC ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' WA ' ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import os NEW_LINE import sys NEW_LINE import random NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import integer NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import integer NEW_LINE import integer NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import integer NEW_LINE import integer NEW_LINE import integer NEW_LINE import integer NEW_LINE from string import integer NEW_LINE from string import string NEW_LINE from string import string NEW_LINE from string import string NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE from string import ( ' ' , ' ' ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from pysal . core import Solution NEW_LINE class Solution ( object ) : NEW_LINE INDENT def max_area_of_land ( self , grid ) : NEW_LINE INDENT dr = ( 1 , - 1 , 0 , 0 ) NEW_LINE dc = ( 0 , 0 , 1 , - 1 ) NEW_LINE ans = 0 NEW_LINE for r0 in range ( len ( grid ) ) : NEW_LINE INDENT for c0 in range ( len ( grid [ 0 ] ) ) : NEW_LINE INDENT if grid [ r0 ] [ c0 ] == 1 : NEW_LINE INDENT shape = 0 NEW_LINE stack = [ ( r0 , c0 ) ] NEW_LINE grid [ r0 ] [ c0 ] = 0 NEW_LINE while not stack . empty ( ) : NEW_LINE INDENT node = stack . pop ( ) NEW_LINE r , c = node [ 0 ] , node [ 1 ] NEW_LINE shape += 1 NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT nr = r + dr [ k ] NEW_LINE nc = c + dc [ k ] NEW_LINE if 0 <= nr < len ( grid ) and 0 <= nc < len ( grid [ 0 ] ) and grid [ nr ] [ nc ] == 1 : NEW_LINE INDENT stack . append ( ( nr , nc ) ) NEW_LINE grid [ nr ] [ nc ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = max ( ans , shape ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT sObj = Solution ( ) NEW_LINE grid = [ [ 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
def GFG ( x , y , n ) : NEW_LINE INDENT sum1 = int ( ( pow ( x , 2 ) * ( pow ( x , 2 * n ) - 1 ) ) / ( pow ( x , 2 - 1 ) ) ) NEW_LINE sum2 = int ( ( x * y * ( pow ( x , n ) * pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) NEW_LINE return sum1 + sum2 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_sum ( self , n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return sum NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 3 NEW_LINE print ( find_sum ( n ) ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def sum ( self ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT def sum ( self ) : NEW_LINE INDENT return sum + self . n % 10 NEW_LINE DEDENT def sum ( self ) : NEW_LINE INDENT return sum NEW_LINE DEDENT DEDENT n = 687 NEW_LINE print ( sum ( n ) ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def sum ( self , n ) : NEW_LINE INDENT for sum in [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 24 , 25 , 26 , 27 , 28 , 29 , 29 , 30 , 31 , 32 , 33 , 33 , 33 , 34 , 35 , 37 , 38 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 , 39 ,
def GFG ( ) : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = data NEW_LINE DEDENT def push ( self , head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref , ) NEW_LINE ( head_ref , new_node ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : return False NEW_LINE if n <= 3 : return True NEW_LINE if n % 2 == 0 or n % 3 == 0 : return False NEW_LINE for i in range ( 5 , n ** 2 + 1 , 6 ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : return False NEW_LINE DEDENT return True NEW_LINE DEDENT def deleteNonPrimeNodes ( self ) : NEW_LINE INDENT ptr = head_ref NEW_LINE while ptr and not isPrime ( self . data ) : NEW_LINE INDENT temp = ptr NEW_LINE ptr = ptr . next NEW_LINE DEDENT self . head_ref = ptr NEW_LINE if not ptr : return None NEW_LINE curr = ptr . next NEW_LINE while curr : NEW_LINE INDENT if not isPrime ( self . curr . data ) : NEW_LINE INDENT ptr . next = curr . next NEW_LINE curr = ptr . next NEW_LINE DEDENT else : NEW_LINE INDENT ptr = curr NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT return ptr NEW_LINE DEDENT def printList ( self ) : NEW_LINE INDENT while head : NEW_LINE INDENT print ( self . data , end = ' ▁ ' ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 17 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 16 ) NEW_LINE head = push ( head , 15 ) NEW_LINE print ( ' Original ▁ List : ▁ ' , end = ' ▁ ' ) NEW_LINE printList ( head ) NEW_LINE head = deleteNonPrimeNodes ( head ) NEW_LINE print ( ' \n Modified ▁ List : ▁ ' , end = ' ▁ ' ) NEW_LINE printList ( head ) NEW_LINE DEDENT DEDENT
def import _main NEW_LINE import sys NEW_LINE import random NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = random . randint ( 0 , N ) NEW_LINE self . M = random . randint ( 0 , M ) NEW_LINE self . L = random . randint ( 0 , L ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . cs = [ [ ] for _ in range ( self . N * self . M ) ] NEW_LINE for D , A , K , T in _main ( self ) : NEW_LINE INDENT start = D * self . N + A NEW_LINE self . cs [ start ] . append ( ( K << 16 ) | T ) NEW_LINE DEDENT DEDENT dp = [ [ 0 ] * ( self . L + 1 ) for _ in range ( self . N * self . M + 1 ) ] NEW_LINE for i in range ( self . N * self . M ) : NEW_LINE INDENT for j in range ( self . L ) : NEW_LINE INDENT for c in self . cs [ i ] : NEW_LINE INDENT c = c >> 16 NEW_LINE t = c & 0xFFFF NEW_LINE dp [ j + 1 ] [ i + len ] = max ( dp [ j + 1 ] [ i + len ] , dp [ j ] [ i ] + t ) NEW_LINE DEDENT DEDENT for j in range ( 0 , self . L ) : NEW_LINE INDENT dp [ j ] [ i + 1 ] = max ( dp [ j ] [ i + 1 ] , dp [ j ] [ i ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 0 , self . L ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ N * self . M ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT class Box ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . bolls = 1 NEW_LINE self . is_red = False NEW_LINE DEDENT def add ( self , src ) : NEW_LINE INDENT self . is_red |= src . is_red NEW_LINE self . bolls += 1 NEW_LINE self . bolls -= 1 NEW_LINE if self . bolls == 0 : NEW_LINE INDENT src . is_red = False NEW_LINE DEDENT DEDENT DEDENT def main ( sc ) : NEW_LINE INDENT n , m = sc . recv_match ( ) NEW_LINE boxs = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT boxs . append ( Box ( ) ) NEW_LINE DEDENT boxs [ 0 ] . is_red = True NEW_LINE for i in range ( m ) : NEW_LINE INDENT x , y = sc . recv_match ( ) NEW_LINE boxs [ y - 1 ] . add ( boxs [ x - 1 ] ) NEW_LINE DEDENT print ( sum ( boxs ) ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT sc . recv_match ( ) NEW_LINE DEDENT DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . h = sys . maxint NEW_LINE self . w = sys . maxint NEW_LINE self . list = [ ] NEW_LINE max = 0 NEW_LINE for i , arr in enumerate ( sys . stdin ) : NEW_LINE INDENT for j , w in enumerate ( arr ) : NEW_LINE INDENT if i == ' . ' : NEW_LINE INDENT continue NEW_LINE DEDENT for x in self . list : NEW_LINE INDENT hh = x // w NEW_LINE ww = x % w NEW_LINE max = max ( max , abs ( i - hh ) + abs ( j - ww ) ) NEW_LINE DEDENT self . list . append ( i * w + j ) NEW_LINE DEDENT DEDENT print ( max ) NEW_LINE DEDENT DEDENT
def GFG ( x ) : NEW_LINE INDENT if len ( x ) > 26 : NEW_LINE INDENT print ( " IMPOSSIBLE " ) NEW_LINE DEDENT else : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for c in x : NEW_LINE INDENT hash [ c - ' a ' ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for c in x : NEW_LINE INDENT if hash [ c - ' a ' ] > 1 : NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT if hash [ i ] == 0 : NEW_LINE INDENT hash [ c - ' a ' ] -= 1 NEW_LINE x = x [ : i ] + chr ( j + ' a ' ) + x [ i + 1 : ] NEW_LINE hash [ i ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( x ) NEW_LINE DEDENT DEDENT
def gf_gcd ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_0 = [ 0 ] * ( n + 2 ) NEW_LINE pre_count_1 = [ 0 ] * ( n + 1 ) NEW_LINE post_count_0 = [ 0 ] * ( n + 2 ) NEW_LINE pre_count_0 [ 0 ] = 0 NEW_LINE post_count_0 [ 0 ] = 0 NEW_LINE pre_count_1 [ 0 ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pre_count_0 [ j ] = pre_count_0 [ j - 1 ] NEW_LINE pre_count_1 [ j ] = pre_count_1 [ j - 1 ] NEW_LINE post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] NEW_LINE if s [ j - 1 ] == '0' : NEW_LINE INDENT pre_count_0 [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre_count_1 [ j ] += 1 NEW_LINE DEDENT if s [ n - j ] == '0' : NEW_LINE INDENT post_count_0 [ n - j + 1 ] += 1 NEW_LINE DEDENT DEDENT if pre_count_0 [ n ] == n or pre_count_0 [ n ] == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def GFG ( N , s ) : NEW_LINE INDENT prime = [ 2 for i in range ( 2 , N + 1 , 2 ) ] NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if prime [ i ] == False : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , i * i + 1 , 2 ) : NEW_LINE INDENT if prime [ i * j ] == False : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ ] NEW_LINE return sieveOfEratosthenes ( N , s ) NEW_LINE DEDENT print ( " Factor ▁ Power " ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while N > 1 : NEW_LINE INDENT N /= s [ N ] NEW_LINE if curr == s [ N ] : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print ( curr , ' \ t ' , cnt ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT
def GFG ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( n ) ] for j in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while num != 0 : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num /= 10 NEW_LINE DEDENT DEDENT longest = sum ( hash ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if hash [ i ] [ j ] == 1 & hash [ i + 1 ] [ j ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if j == 10 : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT
def _1196A_ThreePilesOfCandies ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import time NEW_LINE time . sleep ( 1 ) NEW_LINE test = int ( random . choice ( range ( 1000 ) ) ) NEW_LINE while test : NEW_LINE INDENT a = random . randint ( 0 , 1 ) NEW_LINE b = random . randint ( 0 , 1 ) NEW_LINE c = random . randint ( 0 , 1 ) NEW_LINE result = ( a + b + c ) / 2 NEW_LINE print ( result ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT from sympy . combinatorics . permutations import Permutation NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . c = 0 NEW_LINE v = [ ] NEW_LINE while x % 2 == 0 : NEW_LINE INDENT self . c += 1 NEW_LINE x /= 2 NEW_LINE DEDENT v . append ( self . c ) NEW_LINE self . c = 0 NEW_LINE while x % 3 == 0 : NEW_LINE INDENT self . c += 1 NEW_LINE x /= 3 NEW_LINE DEDENT v . append ( self . c ) NEW_LINE self . c = 0 NEW_LINE while x % 7 == 0 : NEW_LINE INDENT self . c += 1 NEW_LINE x /= 7 NEW_LINE DEDENT v . append ( self . c ) NEW_LINE v . append ( self . x ) NEW_LINE return v NEW_LINE DEDENT def MinOperations ( self , a , b ) : NEW_LINE INDENT va = Divisors ( a ) NEW_LINE vb = Divisors ( b ) NEW_LINE if va [ 3 ] != vb [ 3 ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = abs ( va [ 0 ] - vb [ 0 ] ) + abs ( va [ 1 ] - vb [ 1 ] ) + abs ( va [ 2 ] - vb [ 2 ] ) NEW_LINE return minOperations NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT a , b = 14 , 28 NEW_LINE print ( MinOperations ( a , b ) ) NEW_LINE DEDENT DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = 1000001 NEW_LINE self . c = 0 NEW_LINE self . n = 0 NEW_LINE self . m = 0 NEW_LINE self . a = 0 NEW_LINE self . b = 0 NEW_LINE self . c += 1 NEW_LINE for i in self . v [ a ] : NEW_LINE INDENT if self . vis [ i ] == 0 and i != self . b : NEW_LINE INDENT self . dfs ( i , self . b , self . v , self . vis ) NEW_LINE DEDENT DEDENT DEDENT def Calculate ( self , v ) : NEW_LINE INDENT vis = [ 0 ] * self . n + [ 1 ] NEW_LINE self . c = 0 NEW_LINE self . dfs ( self . a , self . b , v , vis ) NEW_LINE ans1 = self . n - self . c - 1 NEW_LINE vis = [ 0 ] * self . n + [ 1 ] NEW_LINE self . c = 0 NEW_LINE self . dfs ( self . b , self . a , self . v , vis ) NEW_LINE ans2 = self . n - self . c - 1 NEW_LINE print ( ans1 * ans2 , end = ' \n ' ) NEW_LINE DEDENT def Main ( self ) : NEW_LINE INDENT self . n = 7 NEW_LINE self . m = 7 NEW_LINE self . a = 3 NEW_LINE self . b = 5 NEW_LINE self . edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 7 , 5 ] ] NEW_LINE v = [ [ ] for i in range ( 0 , self . n + 1 ) ] NEW_LINE for i in range ( self . m ) : NEW_LINE INDENT v [ i ] = [ ] NEW_LINE DEDENT for i in range ( self . n ) : NEW_LINE INDENT v [ i ] . append ( self . edges [ i ] [ 0 ] ) NEW_LINE v [ i ] . append ( self . edges [ i ] [ 1 ] ) NEW_LINE v [ i ] . append ( self . edges [ i ] [ 0 ] ) NEW_LINE DEDENT self . Calculate ( v ) NEW_LINE DEDENT DEDENT
def import _readline NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE class B_Nirvana : NEW_LINE INDENT def __init__ ( self , stream = BytesIO ( ) ) : NEW_LINE INDENT self . stream = stream NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not stream or not stream . readline : NEW_LINE INDENT try : NEW_LINE INDENT stream = BytesIO ( next ( self . stream ) ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return stream . readline ( ) NEW_LINE DEDENT def randint ( self ) : NEW_LINE INDENT return int ( self . stream . readline ( ) ) NEW_LINE DEDENT def long ( self ) : NEW_LINE INDENT return long ( self . stream . readline ( ) ) NEW_LINE DEDENT def uniform ( self ) : NEW_LINE INDENT return float ( self . stream . readline ( ) ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT data = " " NEW_LINE try : NEW_LINE INDENT if isinstance ( self . stream , BytesIO ) : NEW_LINE INDENT data = data . decode ( " ascii " ) NEW_LINE DEDENT else : NEW_LINE INDENT data = self . stream . readline ( ) NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT pass NEW_LINE DEDENT return data NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT stream = BytesIO ( ) NEW_LINE num = stream . readline ( ) NEW_LINE prod = 1 NEW_LINE ans = prod_of_digits ( num ) NEW_LINE while num > 9 : NEW_LINE INDENT prod *= 9 NEW_LINE digit = num % 10 NEW_LINE num = num // 10 NEW_LINE if digit == 9 : NEW_LINE INDENT ans = max ( ans , prod_of_digits ( long ( num ) ) * prod ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , prod_of_digits ( long ( num - 1 ) ) * prod ) NEW_LINE num = num - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT def prod_of_digits ( N ) : NEW_LINE INDENT prod = 1 NEW_LINE while N != 0 : NEW_LINE INDENT digit = int ( N % 10 ) NEW_LINE if digit == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT prod *= digit NEW_LINE N //= 10 NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT DEDENT
def test_helloworld ( ) : NEW_LINE INDENT import os NEW_LINE class HelloWorld ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = 1 NEW_LINE self . b = 2 NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT a = HelloWorld ( ) NEW_LINE b = HelloWorld ( ) NEW_LINE res = a NEW_LINE while a >= b : NEW_LINE INDENT res += ( a / b ) NEW_LINE a = ( a / b ) + ( a % b ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def _ _ main _ _ ( ) : NEW_LINE INDENT import math NEW_LINE import math NEW_LINE class GFG ( math . factorial ) : NEW_LINE INDENT def _Sum ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n / 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisior ( self , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , math . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT res = max ( res , _Sum ( i ) ) NEW_LINE res = max ( res , _Sum ( n / i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE DEDENT DEDENT return GFG ( GFG ( ) ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import pow NEW_LINE class A : NEW_LINE INDENT def power ( a ) : NEW_LINE INDENT res = 0 NEW_LINE while a > 0 : NEW_LINE INDENT res += 1 NEW_LINE a = a // 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def mult ( a ) : NEW_LINE INDENT pow = power ( a ) NEW_LINE max = 0 NEW_LINE for j in range ( pow ) : NEW_LINE INDENT max = max * 10 + 9 NEW_LINE DEDENT return a * ( max - a ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT from math import log NEW_LINE l = log ( ' l ' ) NEW_LINE r = log ( ' r ' ) NEW_LINE res = 0 NEW_LINE maxxes = [ ] NEW_LINE temp = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT temp = temp * 10 + 9 NEW_LINE maxxes . append ( temp / 2 * ( temp - temp / 2 ) ) NEW_LINE DEDENT res = max ( mult ( l ) , res ) NEW_LINE res = max ( mult ( r ) , res ) NEW_LINE temp = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT temp = temp * 10 + 9 NEW_LINE if l <= temp / 2 <= r : NEW_LINE INDENT res = max ( maxxes [ i ] , res ) NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT return A NEW_LINE DEDENT
def main ( * args ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE from itertools import chain NEW_LINE n = len ( list ( range ( n ) ) ) NEW_LINE a = chain ( [ repeat ( x ) for x in range ( n ) ] ) NEW_LINE print_ ( a ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT key = a [ i ] NEW_LINE j = i - 1 NEW_LINE while j >= 0 and a [ j ] > key : NEW_LINE INDENT a [ j + 1 ] = a [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT a [ j + 1 ] = key NEW_LINE print_ ( a ) NEW_LINE DEDENT def print_ ( a ) : NEW_LINE INDENT for i in range ( len ( a ) - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( a [ - 1 ] ) NEW_LINE DEDENT DEDENT
def _ _ main _ _ ( ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def is_perturb_square ( self , x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def is_product ( self , num ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 2 , 2 , i * i <= num ) : NEW_LINE INDENT while num % i == 0 : NEW_LINE INDENT num /= i NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT if num > 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT def find_numbers ( self , N ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if is_product ( i ) and not is_perturb_square ( i ) : NEW_LINE INDENT vec . append ( i ) NEW_LINE DEDENT DEDENT for ( i , j ) in vec : NEW_LINE INDENT print ( j , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT N = 30 NEW_LINE find_numbers ( N ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def import import sys NEW_LINE import string NEW_LINE import sys NEW_LINE class Test ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = "111111101010101111100101001111111 ▁ 100000100000000001010110001000001 ▁ 101110100110110000011010001011101 ▁ 101110101011001001111101001011101 ▁ 10111010110001100011000111100101011101 ▁ 100000101010101011010000101000001 ▁ 111111101010101010101010101111111 ▁ 000000001111101111100111100000000 ▁ 100010111100100001011110111111001 ▁ 110111001111111100100001001000101100 ▁ 011100111010000101000111010001010 ▁ 011110000110001111110101100000011 ▁ 111111111111111000111001001011000 ▁ 1110000101110100010011010100100 ▁ 10101010010010101010000010 ▁ 101100000101010001111101000000000 ▁ 00001010001100110100011010000010 ▁ 101100000101010001111101000000000 ▁ 00001010001100110100011010000010 ▁ 001101101001101110010010010011011000 ▁ 0111100001010000011010000011010000011010000011010000010000010 ▁ 001101101001101110010010011011000 ▁ 00001010000011010000011010000011010000010000011010000010000011010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000010000
def test_newclass37 ( ) : NEW_LINE INDENT import sys NEW_LINE class NewClass37 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . p = 1 NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT t = args [ 0 ] NEW_LINE p = 1 NEW_LINE while t : NEW_LINE INDENT n = f ( * args , ** kwargs ) NEW_LINE count = 0 NEW_LINE x = n NEW_LINE if n < 10 : NEW_LINE INDENT print ( n ) NEW_LINE continue NEW_LINE DEDENT while x > 0 : NEW_LINE INDENT count += 1 NEW_LINE x /= 10 NEW_LINE DEDENT first = 0 NEW_LINE while count > 0 : NEW_LINE INDENT first = first * 10 + 1 NEW_LINE count -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE if first <= n : NEW_LINE INDENT sum += n / first NEW_LINE DEDENT first /= 10 NEW_LINE while first > 0 : NEW_LINE INDENT sum += 9 NEW_LINE first /= 10 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_GFG ( n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . Integral ) : NEW_LINE INDENT def div_sum ( self , n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , 2 * n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def are_equivalent ( self , num1 , num2 ) : NEW_LINE INDENT return div_sum ( num1 ) == div_sum ( num2 ) NEW_LINE DEDENT DEDENT num1 = 559 NEW_LINE num2 = 703 NEW_LINE if are_equivalent ( num1 , num2 ) : NEW_LINE INDENT print ( " Equivalent " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Equivalent " ) NEW_LINE DEDENT DEDENT
def test_find_y ( x ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . Integral ) : NEW_LINE INDENT def find_y ( self , y ) : NEW_LINE INDENT if y > 2 : NEW_LINE INDENT return y - 2 NEW_LINE DEDENT return y + 2 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT x = 5 NEW_LINE print ( find_y ( x ) ) NEW_LINE DEDENT DEDENT
def GFG ( n , m ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , m = 3 , 2 NEW_LINE print ( modFact ( n , m ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = sys . stdin NEW_LINE self . n = self . n NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . A = [ ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT self . A . append ( a . read ( ) ) NEW_LINE DEDENT DEDENT def __init__ ( self ) : NEW_LINE INDENT self . minj = 0 NEW_LINE self . count = 0 NEW_LINE for i in range ( 0 , self . n - 2 ) : NEW_LINE INDENT minj = i NEW_LINE c = 0 NEW_LINE for j in range ( i + 1 , self . n - 1 ) : NEW_LINE INDENT if self . A [ j ] < self . A [ minj ] : NEW_LINE INDENT minj = j NEW_LINE c = 1 NEW_LINE DEDENT DEDENT if c == 1 : NEW_LINE INDENT x = self . A [ i ] NEW_LINE self . A [ i ] = self . A [ minj ] NEW_LINE self . A [ minj ] = x NEW_LINE self . count += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( self . n ) : NEW_LINE INDENT print ( self . A [ i ] , end = ' ▁ ' ) NEW_LINE if i < self . n - 1 : NEW_LINE INDENT print ( ' ▁ ' , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE print ( count ) NEW_LINE DEDENT
def import os , sys , traceback , traceback , traceback , exc_info , info , ** kwargs ) : NEW_LINE INDENT traceback . print_exc ( ) NEW_LINE sys . stdin . close ( ) NEW_LINE sys . stdout . flush ( ) NEW_LINE sys . stdout . flush ( ) NEW_LINE sys . stdout . flush ( ) NEW_LINE sys . stdout . flush ( ) NEW_LINE sys . stdout . flush ( ) NEW_LINE sys . stdout . flush ( ) NEW_LINE sys . stdout . flush ( ) NEW_LINE sys . stdout . flush ( ) NEW_LINE sys . stdout . close ( ) NEW_LINE w = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE h = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE d = [ False ] * ( h + 2 ) NEW_LINE v = [ False ] * ( w + 2 ) NEW_LINE for i in range ( 1 , h + 1 ) : NEW_LINE INDENT for j in range ( 1 , w + 1 ) : NEW_LINE INDENT d [ i ] [ j ] = traceback . extract_tb ( sys . stdout . readline ( ) ) == 1 NEW_LINE DEDENT DEDENT print ( slove ( 0 , 0 ) ) NEW_LINE def slove ( y , x ) : NEW_LINE INDENT v [ y ] [ x ] = True NEW_LINE res = 0 NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT ny = y + dy [ i ] NEW_LINE nx = x + ( dx1 [ i ] if y % 2 == 1 else dx2 [ i ] ) NEW_LINE if not isOK ( ny , nx ) : NEW_LINE INDENT continue NEW_LINE DEDENT if d [ ny ] [ nx ] : NEW_LINE INDENT res += 1 NEW_LINE continue NEW_LINE DEDENT if v [ ny ] [ nx ] : NEW_LINE INDENT continue NEW_LINE DEDENT res += slove ( ny , nx ) NEW_LINE DEDENT return res NEW_LINE DEDENT def isOK ( ny , nx ) : NEW_LINE INDENT if 0 <= ny <= h + 1 and 0 <= nx <= w + 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT h , w = h , w NEW_LINE if not isOK ( h , w ) : NEW_LINE INDENT raise RuntimeError ( " Couldn ' t ▁ find ▁ a ▁ valid ▁ line ▁ number " ) NEW_LINE DEDENT if not isOK ( h , w ) : NEW_LINE INDENT raise RuntimeError ( " Couldn ' t ▁ find ▁ a ▁ valid ▁ line ▁ number " ) NEW_LINE DEDENT if not isOK ( h , w ) : NEW_LINE INDENT raise RuntimeError ( " Couldn ' t ▁ find ▁ a ▁ valid ▁ line ▁ number " ) NEW_LINE DEDENT return NEW_LINE DEDENT
def import import sys NEW_LINE from os . path import join NEW_LINE from os import sep NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE if environ [ ' wsgi . input ' ] . read ( ) : NEW_LINE INDENT environ [ ' wsgi . input ' ] . read ( ) NEW_LINE DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = float ( ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ) NEW_LINE return A NEW_LINE DEDENT
def GFG ( arr , length , s ) : NEW_LINE INDENT for i in range ( 1 , ( sum ( arr ) ) + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( ( i >> j ) & 1 ) % 2 == 1 : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT if sum == s : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sum = 5 NEW_LINE array = [ - 1 , 2 , 4 , 121 ] NEW_LINE length = len ( array ) NEW_LINE return array [ length ] NEW_LINE DEDENT return main ( ) NEW_LINE DEDENT
def GFG ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE fre = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT fre [ s [ i ] - ' a ' ] += 1 NEW_LINE DEDENT str = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if fre [ i ] % k == 0 : NEW_LINE INDENT x = fre [ i ] / k NEW_LINE while x != 0 : NEW_LINE INDENT str += chr ( i ) + chr ( ' a ' ) NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT
def import import math NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE from numpy . core import get_random_string NEW_LINE DEDENT
def import import _mpmath NEW_LINE import mpmath NEW_LINE import mpmath NEW_LINE import mpmath NEW_LINE import mpmath NEW_LINE import mpmath NEW_LINE import mpmath NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = mpmath . Scanner ( ) NEW_LINE for a , b , n in self . _mpmath . iterparse ( " " ) : NEW_LINE INDENT c = mpmath . mpf ( float ( a ) / b ) . decode ( ' utf - 8' ) NEW_LINE f = [ ] NEW_LINE idx = c . index ( " . " ) NEW_LINE f . append ( ( c [ idx - 1 : idx ] , c [ idx ] ) ) NEW_LINE for i in range ( 1 , min ( 200 , len ( c [ idx + 1 ] ) + 1 ) ) : NEW_LINE INDENT f . append ( ( c [ idx + i : idx + i + 1 ] , c [ idx + i + 1 ] ) ) NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += f [ i ] NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( sys . stdin . readline ( ) ) NEW_LINE self . a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT self . a . append ( i ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT nodec = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if self . a [ i ] <= self . a [ i - 1 ] : NEW_LINE INDENT nodec = False NEW_LINE DEDENT DEDENT if nodec : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT m = 500 NEW_LINE l , r = 1 , 210000 NEW_LINE mid = 2 NEW_LINE dec = [ 0 ] * m NEW_LINE out : NEW_LINE while r - l > 1 : NEW_LINE INDENT mid = ( l + r ) / 2 NEW_LINE dec = [ 1 ] * m NEW_LINE nout : NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if self . a [ i ] <= self . a [ i - 1 ] < m : NEW_LINE INDENT if self . dec [ i - 1 ] < mid : NEW_LINE INDENT self . dec [ i - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = self . a [ i ] - 1 NEW_LINE while pos > 0 : NEW_LINE INDENT self . dec [ pos - 1 ] += 1 NEW_LINE for j in range ( pos , m ) : NEW_LINE INDENT self . dec [ j ] = 1 NEW_LINE DEDENT if self . dec [ pos - 1 ] <= mid : NEW_LINE INDENT continue nout NEW_LINE DEDENT pos -= 1 NEW_LINE DEDENT l = mid NEW_LINE continue out NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( self . a [ i ] - 1 , m ) : NEW_LINE INDENT self . dec [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT r = mid NEW_LINE DEDENT print ( r ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import subprocess NEW_LINE class Main ( subprocess . Popen ) : NEW_LINE INDENT def communicate ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT line = None NEW_LINE lines = [ ] NEW_LINE line = line . split ( ) NEW_LINE lines = line . split ( ) NEW_LINE N = int ( lines [ 0 ] ) NEW_LINE K = int ( lines [ 1 ] ) NEW_LINE if N == 0 and K == 0 : NEW_LINE INDENT return NEW_LINE DEDENT line = open ( ' / proc / sys / stdin / stdout ' ) . readline ( ) NEW_LINE lines = line . split ( ) NEW_LINE bloodAmt = [ int ( line ) for line in lines ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT line = open ( ' / proc / sys / stdin / stdout ' ) . readline ( ) NEW_LINE lines = line . split ( ) NEW_LINE for j in range ( K ) : NEW_LINE INDENT bloodAmt [ j ] -= int ( lines [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( K ) : NEW_LINE INDENT if bloodAmt [ i ] < 0 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE break NEW_LINE DEDENT if i == K - 1 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def import _struct NEW_LINE class GFG ( object ) : NEW_LINE INDENT def maxfreq ( self , a , b ) : NEW_LINE INDENT fre = [ 0 ] * 10 NEW_LINE n = len ( self . s ) NEW_LINE if a > b : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT fre [ self . s [ i ] - '0' ] += 1 NEW_LINE DEDENT if not fre [ a ] and not fre [ b ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif fre [ a ] >= fre [ b ] : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT a , b = 4 , 7 NEW_LINE s = '47744' NEW_LINE sys . stdout . write ( self . maxfreq ( s , a , b ) ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n == 0 or ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT b = 4 NEW_LINE setBit , prev , i = 1 , 0 , i NEW_LINE for i in range ( 1 , b * 8 + 1 ) : NEW_LINE INDENT prev += 1 NEW_LINE if n & setBit == setBit : NEW_LINE INDENT setBit = setBit << 1 NEW_LINE break NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE DEDENT max0 , cur = int ( prev ) , prev NEW_LINE for j in range ( i + 1 , b * 8 + 1 ) : NEW_LINE INDENT cur += 1 NEW_LINE if n & setBit == setBit : NEW_LINE INDENT if max0 < ( cur - prev - 1 ) : NEW_LINE INDENT max0 = cur - prev - 1 NEW_LINE DEDENT prev = cur NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE DEDENT return max0 NEW_LINE DEDENT
def _sum_powers_k ( n , k ) : NEW_LINE INDENT from math import pow NEW_LINE from math import sqrt NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE n , k = 10 , 3 NEW_LINE print ( log ( log ( n , k ) ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def Xand_Yand_Zintercept ( self , A , B , C , D ) : NEW_LINE INDENT rslt = np . zeros ( 3 ) NEW_LINE x = - D / A NEW_LINE y = - D / B NEW_LINE z = - D / C NEW_LINE rslt [ 0 ] = x NEW_LINE rslt [ 1 ] = y NEW_LINE rslt [ 2 ] = z NEW_LINE return rslt NEW_LINE DEDENT DEDENT A = 2 NEW_LINE B = 5 NEW_LINE C = 7 NEW_LINE D = 8 NEW_LINE rslt = Xand_Yand_Zintercept ( A , B , C , D ) NEW_LINE print ( np . mean ( rslt ) ) NEW_LINE DEDENT
def test_gf_max_sum ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , a , n ) : NEW_LINE INDENT self . a = a NEW_LINE self . n = n NEW_LINE DEDENT def f ( self ) : NEW_LINE INDENT l = [ ] NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += abs ( self . a [ i ] ) NEW_LINE if self . a [ i ] >= 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . l . append ( i + 1 ) NEW_LINE self . l . append ( i ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE for i in l : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 4 NEW_LINE a = [ 1 , - 2 , - 3 , 4 ] NEW_LINE return GFG ( a , n ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 1000 NEW_LINE def replaceSpaces ( str ) : NEW_LINE INDENT space_count , i = 0 , 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] == ' ▁ ' : space_count += 1 NEW_LINE while str [ i - 1 ] == ' ▁ ' : NEW_LINE INDENT space_count -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT new_length = i + space_count * 2 NEW_LINE if new_length > MAX : NEW_LINE INDENT return str NEW_LINE DEDENT index = new_length - 1 NEW_LINE new_str = str NEW_LINE str = [ ] NEW_LINE for i in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if new_str [ i ] == ' ▁ ' : NEW_LINE INDENT str . append ( '0' ) NEW_LINE str . append ( '2' ) NEW_LINE str . append ( ' % ' ) NEW_LINE index = index - 3 NEW_LINE DEDENT else : NEW_LINE INDENT str . append ( new_str [ i ] ) NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT str = ' Mr ▁ John ▁ Smith ▁ ' NEW_LINE str = replaceSpaces ( str ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT print ( str [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = _main ( ) NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT super ( B , self ) . __init__ ( ) NEW_LINE DEDENT class B ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n , str , ctr = self . sc . split ( ' ▁ ' ) NEW_LINE m = self . m NEW_LINE num = self . n NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT s . append ( ctr [ i ] ) NEW_LINE DEDENT elif m < num : NEW_LINE INDENT if i == '0' : NEW_LINE INDENT s . append ( 1 ) NEW_LINE m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i == '0' : s . append ( 1 ) NEW_LINE else : s . append ( 0 ) NEW_LINE DEDENT num -= 1 NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def check ( self , n ) : NEW_LINE INDENT m = n NEW_LINE while n != 0 : NEW_LINE INDENT r = n % 10 NEW_LINE if r > 0 : NEW_LINE INDENT if ( m % r ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def count ( self , l ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if self . check ( i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT l , r = 10 , 20 NEW_LINE print ( count ( 10 , 20 ) ) NEW_LINE DEDENT DEDENT
def main_class ( agrs ) : NEW_LINE INDENT from sys import argv NEW_LINE from pylada . utils import get_args NEW_LINE from pylada . utils import get_args NEW_LINE from pylada . utils import get_args NEW_LINE from pylada . utils import get_args NEW_LINE a = get_args ( agrs ) NEW_LINE b = get_args ( agrs ) NEW_LINE if a == b : NEW_LINE INDENT print ( a * 10 + 1 , a * 10 + 2 ) NEW_LINE DEDENT elif a + 1 == b : NEW_LINE INDENT print ( a , b ) NEW_LINE DEDENT elif a + 1 == b * 10 : NEW_LINE INDENT print ( a , b * 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def python_application115 ( ) : NEW_LINE INDENT from pyapp115 import pyapp115 NEW_LINE sc = pyapp115 . Scanner ( ) NEW_LINE num = sc . __next__ ( ) NEW_LINE arr = [ ] NEW_LINE arra = [ ] NEW_LINE max_dif = 0 NEW_LINE max_all = 1000000000 NEW_LINE for i in range ( num ) : NEW_LINE INDENT h = sc . __next__ ( ) NEW_LINE arr . append ( h ) NEW_LINE arra . append ( h ) NEW_LINE DEDENT for i in range ( 1 , num - 1 ) : NEW_LINE INDENT for j in range ( len ( arr ) - 1 ) : NEW_LINE INDENT if j == i : NEW_LINE INDENT max_dif = max ( abs ( arr [ j - 1 ] - arr [ j + 1 ] ) , max_dif ) NEW_LINE DEDENT else : NEW_LINE INDENT max_dif = max ( abs ( arr [ j ] - arr [ j + 1 ] ) , max_dif ) NEW_LINE DEDENT DEDENT max_all = min ( max_all , max_dif ) NEW_LINE max_dif = 0 NEW_LINE DEDENT print ( max_all ) NEW_LINE DEDENT
def import import struct NEW_LINE class hw19 ( struct . Struct ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT with open ( self . data ) as f : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT def __init__ ( self ) : NEW_LINE INDENT struct . __init__ ( self ) NEW_LINE DEDENT def read ( ) : NEW_LINE INDENT f . read ( ) NEW_LINE DEDENT def write ( s ) : NEW_LINE INDENT f . read ( ) NEW_LINE DEDENT def write ( s ) : NEW_LINE INDENT f . write ( s ) NEW_LINE DEDENT def write ( s ) : NEW_LINE INDENT f . write ( s ) NEW_LINE DEDENT def write ( s ) : NEW_LINE INDENT f . write ( s ) NEW_LINE DEDENT def write ( s ) : NEW_LINE INDENT f . write ( s ) NEW_LINE DEDENT def write ( s ) : NEW_LINE INDENT f . write ( s ) NEW_LINE DEDENT def write ( s ) : NEW_LINE INDENT f . write ( s ) NEW_LINE DEDENT def write ( s ) : NEW_LINE INDENT f . write ( s ) NEW_LINE DEDENT def write ( s ) : NEW_LINE INDENT f . write ( s ) NEW_LINE DEDENT DEDENT
def import _readline NEW_LINE import readline NEW_LINE import sys NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import time NEW_LINE import math NEW_LINE class pre5 : NEW_LINE INDENT class FastReader : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT return sys . stdin . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not readline or not readline . is_readline : NEW_LINE INDENT try : NEW_LINE INDENT readline . readline ( ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return readline . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT data = ' ' NEW_LINE try : NEW_LINE INDENT data = readline ( self ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT return data NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT data = ' ' NEW_LINE try : NEW_LINE INDENT data = readline ( self ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT return data NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT obj = FastReader ( ) NEW_LINE k = obj . __next__ ( ) NEW_LINE data = obj . __next__ ( ) . split ( ) NEW_LINE n = len ( data ) NEW_LINE data . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in data : sum += ord ( i ) - ord ( '0' ) NEW_LINE idx , ans = 0 , 0 NEW_LINE while idx < n and sum < k : NEW_LINE INDENT sum -= len ( data [ idx ] ) - ord ( '0' ) NEW_LINE data [ idx ] = '9' NEW_LINE sum += 9 NEW_LINE idx += 1 NEW_LINE ans += 1 NEW_LINE DEDENT out . write ( ans ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class B940 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdin = sys . stdin NEW_LINE self . N = sys . stdin . read ( ) NEW_LINE self . K = sys . stdin . read ( ) NEW_LINE self . A = sys . stdin . read ( ) NEW_LINE self . B = sys . stdin . read ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT cost = 0 NEW_LINE while N != 1 : NEW_LINE INDENT if self . N < K : NEW_LINE INDENT cost += ( self . N - 1 ) * A NEW_LINE break NEW_LINE DEDENT r = self . N % K NEW_LINE cost += r * A NEW_LINE self . N -= r NEW_LINE if self . B >= ( self . N - self . N // K ) * A : NEW_LINE INDENT cost += ( self . N - 1 ) * A NEW_LINE break NEW_LINE DEDENT cost += self . B NEW_LINE self . N /= K NEW_LINE DEDENT print ( cost ) NEW_LINE DEDENT DEDENT
def digit_sum ( n ) : NEW_LINE INDENT import sys NEW_LINE class GfG ( gr . G1 ) : NEW_LINE INDENT def digit_sum ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 or sum > 9 : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum += n % 10 NEW_LINE n /= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( self , argc ) : NEW_LINE INDENT n = 1234 NEW_LINE print ( digit_sum ( n ) ) NEW_LINE DEDENT DEDENT return GfG ( ) NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n , m = sc . readline ( ) . split ( ' ▁ ' ) NEW_LINE a , b = sc . readline ( ) . split ( ' ▁ ' ) NEW_LINE dp = [ [ max ( dp [ i ] [ j ] , max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) - 1 ) for i in range ( 1 , n + 1 ) ] for j in range ( 1 , m + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) - 1 ) NEW_LINE if a [ i - 1 ] == b [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + 2 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def centered_heptagonal_num ( self , n ) : NEW_LINE INDENT return ( 7 * n ** 2 - 7 * n + 2 ) / 2 NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = 5 NEW_LINE print ( " % th ▁ Centered ▁ " " heptagonal ▁ number ▁ : ▁ % s " % ( n , centered_heptagonal_num ( n ) ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def _missing_num ( arr , n ) : NEW_LINE INDENT import numpy as np NEW_LINE import numpy . random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT arr = np . array ( arr ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return arr [ key ] NEW_LINE DEDENT DEDENT minvalue = min ( arr ) NEW_LINE xornum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xornum ^= ( minvalue ) ^ arr [ i ] NEW_LINE minvalue += 1 NEW_LINE DEDENT return xornum ^ minvalue NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE if n % 2 == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res . append ( chr ( 48 + i + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( chr ( 48 + i ) ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res . append ( chr ( 48 + i + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( chr ( 48 + i ) ) NEW_LINE DEDENT DEDENT res . append ( chr ( 48 + n - 2 ) ) NEW_LINE res . append ( chr ( 48 + n ) ) NEW_LINE res . append ( chr ( 48 + n ) ) NEW_LINE res . append ( chr ( 48 + n - 1 ) ) NEW_LINE DEDENT res . append ( ' \ 0' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def minOperations ( a , n , K ) : NEW_LINE INDENT import __builtin__ NEW_LINE class geeks ( object ) : NEW_LINE INDENT def __init__ ( self , a , n , K ) : NEW_LINE INDENT self . a = a NEW_LINE self . n = n NEW_LINE self . K = K NEW_LINE DEDENT def __index__ ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT if self . a [ self . n ] : return 1 NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT try : NEW_LINE INDENT self . a [ self . n ] = True NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT b = [ a [ i ] for i in range ( n ) ] NEW_LINE b = [ i for i in range ( n ) if a [ i ] & K ] NEW_LINE a = [ a [ i ] for i in range ( n ) if a [ i ] != b [ i ] ] NEW_LINE b = [ a [ i ] for i in range ( n ) if a [ i ] != b [ i ] ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE b = [ b [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n ) ] NEW_LINE a = [ a [ i ] for i in range ( n )
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . h , self . w = 0 , 0 NEW_LINE self . grid = [ ] NEW_LINE self . B , self . W = None , None NEW_LINE self . count_B , self . count_W = 0 , None NEW_LINE self . dx = [ 1 , - 1 , 0 , 0 ] NEW_LINE self . dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE self . from = ' ' , ' ' NEW_LINE self . count_grid = 0 NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT with open ( self . from_input , ' r ' ) as f : NEW_LINE INDENT self . w = f . read ( ) NEW_LINE while self . w != 0 : NEW_LINE INDENT self . h = self . w NEW_LINE self . grid = [ ] NEW_LINE for line in f : NEW_LINE INDENT self . grid . append ( line . split ( ) ) NEW_LINE DEDENT self . count_B = 0 NEW_LINE self . count_W = 0 NEW_LINE for i in range ( self . h ) : NEW_LINE INDENT for j in range ( self . w ) : NEW_LINE INDENT if self . grid [ i ] [ j ] == ' . ' : NEW_LINE INDENT B = False NEW_LINE W = False NEW_LINE self . count_grid = 0 NEW_LINE self . dfs ( j , i ) NEW_LINE if B and not W : NEW_LINE INDENT self . count_B += self . count_grid NEW_LINE DEDENT if not B and W : NEW_LINE INDENT self . count_W += self . count_grid NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( self . count_B , self . count_W ) NEW_LINE self . w = f . read ( ) NEW_LINE DEDENT DEDENT DEDENT def dfs ( self , x , y ) : NEW_LINE INDENT self . grid [ y ] [ x ] = ' x ' NEW_LINE self . count_grid += 1 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT nx = x + self . dx [ i ] NEW_LINE ny = y + self . dy [ i ] NEW_LINE if nx < self . w and nx >= 0 and ny < self . h and ny >= 0 : NEW_LINE INDENT if self . grid [ ny ] [ nx ] == ' B ' : NEW_LINE INDENT B = True NEW_LINE DEDENT elif self . grid [ ny ] [ nx ] == ' W ' : NEW_LINE INDENT W = True NEW_LINE DEDENT elif self . grid [ ny ] [ nx ] == ' . ' : NEW_LINE INDENT self . dfs ( nx , ny ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def import __vfe NEW_LINE class Vfe ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT self . f = __vfe NEW_LINE self . t = __vfe NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " NO " NEW_LINE DEDENT def __call__ ( self ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT def __call__ ( self ) : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT
def import library NEW_LINE import math NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy . random NEW_LINE import numpy . testing as numpy NEW_LINE import numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE import numpy . testing as numpy . testing as numpy NEW_LINE import numpy . testing as numpy . testing as numpy NEW_LINE import numpy . testing as numpy NEW_LINE DEDENT
def import import _sys , time , time , time , minutes , ) : NEW_LINE INDENT import sys NEW_LINE import time , time NEW_LINE time = time . time ( ) NEW_LINE minutes = [ ] NEW_LINE for i in range ( landings ) : NEW_LINE INDENT hours = time . hour * 60 NEW_LINE minute = time . minute NEW_LINE minutes . append ( minute + hours ) NEW_LINE DEDENT if time + 1 <= minutes [ 0 ] : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE return NEW_LINE DEDENT for i in range ( landings - 1 ) : NEW_LINE INDENT if minutes [ i + 1 ] - minutes [ i ] >= 2 * time + 2 : NEW_LINE INDENT flight = minutes [ i ] + time + 1 NEW_LINE h , m = flight // 60 , flight % 60 NEW_LINE print ( h , m ) NEW_LINE return NEW_LINE DEDENT DEDENT flight = minutes [ landings - 1 ] + time + 1 NEW_LINE h , m = flight // 60 , flight % 60 NEW_LINE print ( h , m ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from sympy . utilities . lambdify import NUMPY_COMPILED NEW_LINE k = NUMPY_COMPILED NEW_LINE for A in in range ( k ) : NEW_LINE INDENT B = NUMPY_COMPILED [ A ] NEW_LINE if B == 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE print ( A , A * B , B + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def import import _sys , _sys , _sys , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , _inf , inf , _inf , inf , _inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf , inf ,
def find_max_value ( arr , n ) : NEW_LINE INDENT import numpy NEW_LINE if n < 4 : NEW_LINE INDENT print ( " The ▁ array ▁ should ▁ have " " ▁ atleast ▁ 4 ▁ elements " ) NEW_LINE DEDENT table1 = numpy . zeros ( n + 1 , dtype = numpy . int32 ) NEW_LINE table2 = numpy . zeros ( n , dtype = numpy . int32 ) NEW_LINE table3 = numpy . zeros ( n - 1 , dtype = numpy . int32 ) NEW_LINE table4 = numpy . zeros ( n - 2 , dtype = numpy . int32 ) NEW_LINE table1 [ : n ] = numpy . maximum ( arr [ : n ] , arr [ n : ] ) NEW_LINE table2 [ : n ] = numpy . maximum ( arr [ n : ] , arr [ n : ] ) NEW_LINE table3 [ : n ] = numpy . maximum ( arr [ n : ] , arr [ n : ] ) NEW_LINE table4 [ : n ] = numpy . maximum ( arr [ n : ] , arr [ n : ] ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = numpy . maximum ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = numpy . maximum ( table2 [ i + 1 ] , arr [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = numpy . maximum ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = numpy . maximum ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT
def test_gf_hex_series ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sys . stdout . write ( 3 * i * ( i - 1 ) + 1 + " ▁ " ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 10 NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . ABC = [ ' A ' , ' B ' , ' C ' ] NEW_LINE DEDENT def __init__ ( self , S ) : NEW_LINE INDENT self . S = S NEW_LINE if self . dfs ( S ) : NEW_LINE INDENT self . print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT self . print ( ' No ' ) NEW_LINE DEDENT DEDENT def dfs ( S ) : NEW_LINE INDENT if S == ' ABC ' : NEW_LINE INDENT return True NEW_LINE DEDENT cnt = 0 NEW_LINE f = False NEW_LINE pos = [ False ] * len ( S ) NEW_LINE for j in range ( 0 , len ( S ) + 3 ) : NEW_LINE INDENT if S [ j : j + 3 ] == ' ABC ' : NEW_LINE INDENT pos [ j ] = True NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT if cnt < 1 : NEW_LINE INDENT return False NEW_LINE DEDENT out : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( len ( S ) ) : NEW_LINE INDENT if S [ j ] == ' A ' + str ( i ) : NEW_LINE INDENT if j - i < 0 or not pos [ j - i ] : NEW_LINE INDENT continue out NEW_LINE DEDENT DEDENT DEDENT next = S . replace ( ' ABC ' , ABC [ i ] ) NEW_LINE f |= dfs ( str ( next ) ) NEW_LINE DEDENT DEDENT return f NEW_LINE DEDENT def tr ( self , * args ) : NEW_LINE INDENT print ( " ▁ " . join ( map ( str , args ) ) ) NEW_LINE DEDENT DEDENT
def code_ninety_seven ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import sys NEW_LINE from itertools import repeat NEW_LINE input = raw_input ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ in ▁ the ▁ file : ▁ " ) NEW_LINE m = int ( input . strip ( ) ) NEW_LINE n = int ( input . strip ( ) ) NEW_LINE array_one = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT data = " " NEW_LINE if input . strip ( ) : NEW_LINE INDENT data = input . strip ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT array_one [ i ] . append ( data ) NEW_LINE DEDENT DEDENT sumr = sumc = count1 = count2 = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if array_one [ i ] [ j ] == 66 : NEW_LINE INDENT sumr += i + 1 NEW_LINE count1 += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if array_one [ i ] [ j ] == 66 : NEW_LINE INDENT sumc += j + 1 NEW_LINE count2 += 1 NEW_LINE DEDENT DEDENT DEDENT print ( sumr / count1 , sumc / count2 ) NEW_LINE DEDENT
def diagonal_minmax ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE if n == 0 : return NEW_LINE principal_min , principal_max = mat [ 0 ] [ 0 ] , mat [ 0 ] [ 0 ] NEW_LINE secondary_min , secondary_max = mat [ n - 1 ] [ 0 ] , mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT if mat [ i ] [ j ] < principal_min : NEW_LINE INDENT principal_min = mat [ i ] [ j ] NEW_LINE DEDENT if mat [ i ] [ j ] > principal_max : NEW_LINE INDENT principal_max = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( i + j ) == ( n - 1 ) : NEW_LINE INDENT if mat [ i ] [ j ] < secondary_min : NEW_LINE INDENT secondary_min = mat [ i ] [ j ] NEW_LINE DEDENT if mat [ i ] [ j ] > secondary_max : NEW_LINE INDENT secondary_max = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ ▁ " , principal_min ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " , principal_max ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , secondary_min ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondary_max ) NEW_LINE def main ( ) : NEW_LINE INDENT matrix = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] NEW_LINE return matrix NEW_LINE DEDENT return main NEW_LINE DEDENT
def diagonal_minmax ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE if n == 0 : return NEW_LINE principal_min , principal_max = mat [ 0 , 0 ] , mat [ 0 , 0 ] NEW_LINE secondary_min , secondary_max = mat [ n - 1 , 0 ] , mat [ n - 1 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i , i ] < principal_min : NEW_LINE INDENT principal_min = mat [ i , i ] NEW_LINE DEDENT if mat [ i , i ] > principal_max : NEW_LINE INDENT principal_max = mat [ i , i ] NEW_LINE DEDENT if mat [ n - 1 - i , i ] < secondary_min : NEW_LINE INDENT secondary_min = mat [ n - 1 - i , i ] NEW_LINE DEDENT if mat [ n - 1 - i , i ] > secondary_max : NEW_LINE INDENT secondary_max = mat [ n - 1 - i , i ] NEW_LINE DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ ▁ " , principal_min ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " , principal_max ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , secondary_min ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondary_max ) NEW_LINE def main ( ) : NEW_LINE INDENT matrix = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] NEW_LINE return matrix NEW_LINE DEDENT return main NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT sum , count = 0 , 0 NEW_LINE while n >= 1 : NEW_LINE INDENT count += 1 NEW_LINE sum += n NEW_LINE n = n - 2 NEW_LINE DEDENT return sum / count NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT n = 15 NEW_LINE print ( average_odd ( n ) ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def averageOdd ( self , n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 1 ) / 2 NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def test_gf_gg ( ) : NEW_LINE INDENT import os NEW_LINE from sympy . polys . domains import ZZ NEW_LINE class GFG ( ZZ ) : NEW_LINE INDENT def are_elements_contiguous ( self , arr , n ) : NEW_LINE INDENT us = set ( [ i for i in arr ] ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us is True : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us is True : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == ( len ( us ) ) ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if are_elements_contiguous ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import Queue NEW_LINE class GFG ( object ) : NEW_LINE INDENT def getLeftMostZero ( self ) : NEW_LINE INDENT if self . zero == None : return - 1 NEW_LINE self . zero . pop ( ) NEW_LINE return 0 NEW_LINE DEDENT def getLeftMostOne ( self ) : NEW_LINE INDENT if self . one == None : return - 1 NEW_LINE self . one . pop ( ) NEW_LINE return 1 NEW_LINE DEDENT def getLeftMostElement ( self , zero , one ) : NEW_LINE INDENT if self . zero == None and self . one == None : return - 1 NEW_LINE elif self . zero == None : NEW_LINE INDENT self . one . pop ( ) NEW_LINE return 1 NEW_LINE DEDENT elif self . one == None : NEW_LINE INDENT self . zero . pop ( ) NEW_LINE return 0 NEW_LINE DEDENT res = ( self . zero < one ) NEW_LINE if res == 0 : self . zero . pop ( ) NEW_LINE else : self . one . pop ( ) NEW_LINE return res NEW_LINE DEDENT def performQueries ( self , arr , n , queries , q ) : NEW_LINE INDENT zero = Queue . Queue ( ) NEW_LINE one = Queue . Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if self . arr [ i ] == 0 : self . zero . append ( i ) NEW_LINE else : self . one . append ( i ) NEW_LINE DEDENT for type in queries : NEW_LINE INDENT if type == 1 : NEW_LINE INDENT print ( self . getLeftMostZero ( zero ) ) NEW_LINE DEDENT elif type == 2 : NEW_LINE INDENT print ( self . getLeftMostOne ( one ) ) NEW_LINE DEDENT elif type == 3 : NEW_LINE INDENT print ( self . getLeftMostElement ( zero , one ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE queries = [ 1 , 3 , 1 ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( arr , n , queries , q ) NEW_LINE DEDENT DEDENT
def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) NEW_LINE print ( val * ( - 1 if x < 0 else 1 ) , " ▁ 0 ▁ " , end = ' ▁ ' ) NEW_LINE print ( "0 ▁ " + val * ( - 1 if y < 0 else 1 ) , end = ' ▁ ' ) NEW_LINE DEDENT
def gf_eval ( f , n ) : NEW_LINE INDENT from sympy . polys . domains import ZZ NEW_LINE from sympy . polys . polyroots import Poly NEW_LINE P = [ f [ 0 ] ] + [ f [ 1 ] ] NEW_LINE S = P [ n - 1 ] NEW_LINE hash = { i : 1 for i in range ( n ) } NEW_LINE res = set ( ) NEW_LINE for i in range ( 1 , 2 ** i + 1 ) : NEW_LINE INDENT if S % i == 0 : NEW_LINE INDENT pres = True NEW_LINE div1 , div2 = i , S // i NEW_LINE for j in range ( div1 , S + 1 , div2 ) : NEW_LINE INDENT if hash [ j ] is None or hash [ j ] != 1 : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if pres and div1 != S : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT pres = True NEW_LINE for j in range ( S // i , S + 1 , div2 ) : NEW_LINE INDENT if hash [ j ] is None or hash [ j ] != 1 : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if pres and div2 != S : NEW_LINE INDENT res . add ( div2 ) NEW_LINE DEDENT DEDENT DEDENT if len ( res ) == 0 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def _ import _ , ▁ numpy . linalg . lstsq ( ) : ▁ return ▁ numpy . linalg . lstsq ( ) ▁ """ NEW_LINE import numpy . linalg NEW_LINE class GFG ( object ) : NEW_LINE INDENT def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr . append ( temp [ k ] ) NEW_LINE del temp [ k ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT Arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( Arr ) NEW_LINE return np . linalg . lstsq ( Arr , n ) NEW_LINE DEDENT DEDENT
def import _practice NEW_LINE class practice ( object ) : NEW_LINE INDENT def __init__ ( self , s , p ) : NEW_LINE INDENT self . s , self . p = s , p NEW_LINE self . k , x , y , ans = self . k , self . x , self . y , self . ans , self . a , self . b NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT p = _practice ( i ) NEW_LINE for s in s : NEW_LINE INDENT for s in p : NEW_LINE INDENT if s [ s [ s [ 0 ] ] ] == s [ s [ 1 ] ] : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif s [ s [ s [ 0 ] ] ] == s [ s [ 1 ] ] : NEW_LINE INDENT y += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += min ( x , y ) NEW_LINE x , y = 0 , 0 NEW_LINE DEDENT DEDENT DEDENT ans += min ( x , y ) NEW_LINE x , y = 0 , 0 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def import _solution NEW_LINE class Solution ( object ) : NEW_LINE INDENT def find_radius ( self , houses , heaters ) : NEW_LINE INDENT heaters = [ heaters [ i ] for i in range ( len ( heaters ) ) ] NEW_LINE result = int ( 0 ) NEW_LINE for house in houses : NEW_LINE INDENT index = bisect . bisect_left ( heaters , house ) NEW_LINE if index < 0 : NEW_LINE INDENT index = - ( index + 1 ) NEW_LINE DEDENT dist1 = house - heaters [ index - 1 ] if index - 1 >= 0 else int ( index ) NEW_LINE dist2 = heaters [ index ] - house if index < len ( heaters ) else int ( index ) NEW_LINE result = max ( result , min ( dist1 , dist2 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE houses = [ 1 , 2 , 3 ] NEW_LINE heaters = [ 2 ] NEW_LINE out = sObj . find_radius ( houses , heaters ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT
def p130 ( ) : NEW_LINE INDENT print ( eval ( " p130 ( ) " ) ) NEW_LINE def test ( ) : NEW_LINE INDENT sum = 0 NEW_LINE found = 0 NEW_LINE for i in range ( 7 , 25 , 2 ) : NEW_LINE INDENT if i % 5 != 0 and not lib . is_prime ( i ) and ( i - 1 ) % find_least_divisible_repunit ( i ) == 0 : NEW_LINE INDENT sum += i NEW_LINE found += 1 NEW_LINE DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT def find_least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n > int ( n ) / 10 : NEW_LINE INDENT raise ValueError ( " Arithmetic ▁ overflow " ) NEW_LINE DEDENT sum = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while sum % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT return test NEW_LINE DEDENT
def import math NEW_LINE import math NEW_LINE import math NEW_LINE class Solution ( object ) : NEW_LINE INDENT def __init__ ( self , num , x , k , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT self . res += 1 NEW_LINE DEDENT r = int ( math . floor ( math . pow ( num , 1.0 / n ) ) ) NEW_LINE for i in range ( k + 1 , r + 1 ) : NEW_LINE INDENT a = x - int ( math . pow ( i , n ) ) NEW_LINE if a >= 0 : NEW_LINE INDENT self . checkRecursive ( num , x - int ( math . pow ( i , n ) ) , i , n ) NEW_LINE DEDENT DEDENT return self . res NEW_LINE DEDENT def check ( x , n ) : NEW_LINE INDENT return self . checkRecursive ( x , x , 0 , n ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT print ( self . check ( 10 , 2 ) ) NEW_LINE DEDENT DEDENT
def _ import _ , ▁ sys . stdout , ▁ sys . stderr , ▁ etc . . . ENDCOM import os , sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . oper = ' ' NEW_LINE DEDENT def __call__ ( self , s ) : NEW_LINE INDENT with open ( ' / proc / % s ' % self . op , ' r ' ) as sc : NEW_LINE INDENT s = sc . read ( ) NEW_LINE DEDENT DEDENT def dfs ( self , chs , idx , cur , opers ) : NEW_LINE INDENT if idx == len ( self . oper ) : NEW_LINE INDENT if cur == 7 : return opers NEW_LINE else : return None NEW_LINE DEDENT plus = dfs ( self , chs , idx + 1 , cur + ( self . oper [ idx ] - '0' ) , opers + ' + ' ) NEW_LINE if plus : return plus NEW_LINE nega = dfs ( self , chs , idx + 1 , cur - ( self . oper [ idx ] - '0' ) , opers + ' - ' ) NEW_LINE if nega : return nega NEW_LINE DEDENT DEDENT
def main ( agrs ) : NEW_LINE INDENT import sys NEW_LINE from numpy import zeros NEW_LINE from scipy . sparse import csc_matrix NEW_LINE from scipy . sparse import csc_matrix NEW_LINE from scipy . sparse import csc_matrix NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . sparse import csc_matrix NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE from scipy . sparse . linalg import solve NEW_LINE solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( solve ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (
def import _solve NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = random . randint ( 0 , 1 ) NEW_LINE self . print ( solve ( n ) ) NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT sum = str ( n ) . chars . map ( lambda ch : ch - '0' ) . tolist ( ) NEW_LINE for i in range ( len ( sum ) - 1 ) : NEW_LINE INDENT sum [ i ] -= 1 NEW_LINE sum [ i + 1 ] += 10 NEW_LINE DEDENT for i in range ( len ( sum ) - 1 , 1 , - 1 ) : NEW_LINE INDENT if sum [ i ] == 19 : NEW_LINE INDENT sum [ i ] -= 10 NEW_LINE sum [ i - 1 ] += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import sin , cos , exp NEW_LINE class GFG ( object ) : NEW_LINE INDENT def prime ( self , n ) : NEW_LINE INDENT for i in range ( 2 , 2 * i <= n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def third_number ( self , a , b ) : NEW_LINE INDENT sum , temp = 0 , 0 NEW_LINE sum = a + b NEW_LINE temp = 1 NEW_LINE if sum == 0 : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while not prime ( sum + temp ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( arr ) : NEW_LINE INDENT a , b = 3 , 5 NEW_LINE third_number ( a , b ) NEW_LINE DEDENT DEDENT
def import _solution NEW_LINE class Solution : NEW_LINE INDENT def __init__ ( self , n , m , a ) : NEW_LINE INDENT self . n = n NEW_LINE self . m = m NEW_LINE self . a = a NEW_LINE DEDENT def main ( self , arr ) : NEW_LINE INDENT n , m , a = 6 , 6 , 4 NEW_LINE print ( self . Squares ( n , m , a ) ) NEW_LINE DEDENT DEDENT
def import _two_regular_polygons NEW_LINE class _two_regular_polygons ( object ) : NEW_LINE INDENT def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT sc = _two_regular_polygons ( ) NEW_LINE t = sc . count ( ) NEW_LINE while t : NEW_LINE INDENT n , m = sc . count ( ) , sc . count ( ) NEW_LINE print ( " YES " if ( n % m ) == 0 else " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , a ** 2 , b ** 2 ) : NEW_LINE INDENT if j ** 2 == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE from math import ceil NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT print ( i , j ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT str = ' abcd ' NEW_LINE return SubString ( str , len ( str ) ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def count_prime_position ( arr ) : NEW_LINE INDENT c0 , c1 = 0 , 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 and is_prime ( i ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT if arr [ i ] == 1 and is_prime ( i ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ 0s ▁ = ▁ { } " . format ( c0 ) ) NEW_LINE print ( " Number ▁ of ▁ 1s ▁ = ▁ { } " . format ( c1 ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 ] NEW_LINE count_prime_position ( arr ) NEW_LINE DEDENT
def test_angle_extcycquad ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , z ) : NEW_LINE INDENT sys . stdout . write ( " The ▁ exterior ▁ angle ▁ of ▁ the " " ▁ cyclic ▁ quadrilateral ▁ is ▁ % d ▁ degrees \n " % z ) NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT z = 48 NEW_LINE return GFG ( self , z ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT min_index = sys . maxint NEW_LINE m = len ( str ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if patt [ i ] == str [ j ] and j < min_index : NEW_LINE INDENT min_index = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if min_index != sys . maxint : NEW_LINE INDENT print ( " Minimum ▁ Index ▁ Character ▁ = ▁ " + str [ min_index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ character ▁ present " ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE n = len ( sys . argv ) NEW_LINE for a , b in repeat ( n ) : NEW_LINE INDENT if b < a : NEW_LINE INDENT print ( " Happy ▁ Alex " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Poor ▁ Alex " ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import ceil NEW_LINE from math import sin , cos , exp NEW_LINE class GFG ( object ) : NEW_LINE INDENT def maxnumber ( self , n ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 1 NEW_LINE while n // i > 0 : NEW_LINE INDENT temp = ( n // ( i * 10 ) ) * i + ( n % i ) NEW_LINE i *= 10 NEW_LINE ans = max ( ans , temp ) NEW_LINE DEDENT n = ans NEW_LINE DEDENT return n NEW_LINE DEDENT DEDENT n = 6358 NEW_LINE k = 1 NEW_LINE print ( maxnumber ( n , k ) ) NEW_LINE DEDENT
def import import sys , StringIO , StringIO , mp , log NEW_LINE log = sys . stdout NEW_LINE result = sys . stdout NEW_LINE with mp . multiple ( range ( N ) , range ( M ) ) : NEW_LINE INDENT N , M = mp . select ( [ ] , [ ] , [ ] , 1 ) NEW_LINE w = [ 0 ] * N NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , L = mp . select ( [ ] , [ ] , [ ] , 1 ) NEW_LINE for j in range ( L ) : NEW_LINE INDENT w [ ( a + j ) % N ] = 1 NEW_LINE DEDENT DEDENT t = [ 0 ] * N + [ 1 ] * N NEW_LINE s = f = s0 = None NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT if f == 0 and w [ i ] == 1 : NEW_LINE INDENT s = i NEW_LINE f = 1 NEW_LINE DEDENT elif f == 1 and w [ i ] == 0 : NEW_LINE INDENT f = 0 NEW_LINE if s == 0 : NEW_LINE INDENT s0 = i NEW_LINE DEDENT else : NEW_LINE INDENT t [ i - s ] += 1 NEW_LINE DEDENT DEDENT DEDENT if f == 1 : NEW_LINE INDENT t [ i - s + s0 ] += 1 NEW_LINE DEDENT elif s0 is not None : NEW_LINE INDENT t [ s0 ] += 1 NEW_LINE DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT if t [ i ] > 0 : NEW_LINE INDENT result . write ( " % d ▁ % d \n " % ( i , t [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import math NEW_LINE from os import urandom NEW_LINE io = urandom ( 4096 ) NEW_LINE n = int ( io . read ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a . append ( io . read ( ) ) NEW_LINE DEDENT sum = 0 NEW_LINE now = 0 NEW_LINE border = 1 NEW_LINE end = 0 NEW_LINE ans_p = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE end = border - sum NEW_LINE if border > 0 : NEW_LINE INDENT if now < end : NEW_LINE INDENT ans_p += abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if now > end : NEW_LINE INDENT ans_p += abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT border = - border NEW_LINE DEDENT sum = 0 NEW_LINE now = 0 NEW_LINE border = - 1 NEW_LINE end = 0 NEW_LINE ans_m = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE end = border - sum NEW_LINE if border > 0 : NEW_LINE INDENT if now < end : NEW_LINE INDENT ans_m += abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if now > end : NEW_LINE INDENT ans_m += abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT border = - border NEW_LINE DEDENT print ( min ( ans_p , ans_m ) ) NEW_LINE DEDENT
def get_last_two_digit ( N ) : NEW_LINE INDENT if N <= 10 : NEW_LINE INDENT ans , fac = 0 , 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT return int ( ans ) % 100 NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT
def GFG ( args ) : NEW_LINE INDENT binaryNumber = "1001" NEW_LINE print ( int ( binaryNumber , 2 ) ) NEW_LINE DEDENT
def __pow__ ( x , y , z ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __pow__ ( self , x , y , z ) : NEW_LINE INDENT a = x ** 2 + y ** 2 + z ** 2 NEW_LINE if math . ceil ( a ) == 1 and math . floor ( a ) == 1 : return True NEW_LINE return False NEW_LINE DEDENT def __pow__ ( self , x , y , z ) : NEW_LINE INDENT l , m , n = 0.70710678f , 0.5 , 0.5 NEW_LINE if __pow__ ( l , m , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT return GFG ( x , y , z ) NEW_LINE DEDENT
def import _io NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 1000000 NEW_LINE self . MOD = 10000007 NEW_LINE self . result = [ 0 ] * ( MAX + 1 ) NEW_LINE self . fact = [ 0 ] * ( MAX + 1 ) NEW_LINE def pre_compute ( self ) : NEW_LINE INDENT self . fact [ 0 ] = 1 NEW_LINE self . result [ 0 ] = 1 NEW_LINE for i in range ( 1 , self . MAX + 1 ) : NEW_LINE INDENT self . fact [ i ] = ( ( self . fact [ i - 1 ] % self . MOD ) * i ) % self . MOD NEW_LINE self . result [ i ] = ( ( self . result [ i - 1 ] % self . MOD ) * ( self . fact [ i ] % self . MOD ) ) % self . MOD NEW_LINE DEDENT DEDENT DEDENT def perform_queries ( self , n ) : NEW_LINE INDENT self . pre_compute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( self . result [ i ] ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT q = [ 4 , 5 ] NEW_LINE n = len ( self . q ) NEW_LINE return self . perform_queries ( q , n ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class D ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . T = 0 NEW_LINE DEDENT DEDENT T = D ( ) NEW_LINE while T : NEW_LINE INDENT n = D ( ) NEW_LINE a = [ D ( ) for _ in range ( n ) ] NEW_LINE a . sort ( ) NEW_LINE mini = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = a [ i ] - a [ i - 1 ] NEW_LINE mini = mini + ( - 1 ) * diff * i NEW_LINE ans += mini NEW_LINE DEDENT print ( ans , a [ n - 1 ] ) NEW_LINE DEDENT DEDENT
def import segregate , find_missing_positive , size = 0 ) : NEW_LINE INDENT from math import fabs NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , arr , size ) : NEW_LINE INDENT self . j , self . i = 0 , 0 NEW_LINE for x in range ( size ) : NEW_LINE INDENT if arr [ x ] <= 0 : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE self . j += 1 NEW_LINE DEDENT DEDENT return self . j NEW_LINE DEDENT def find_missing_positive ( self , size ) : NEW_LINE INDENT for x in abs ( arr [ i ] ) : NEW_LINE INDENT if x - 1 < size and arr [ x - 1 ] > 0 : NEW_LINE INDENT arr [ x - 1 ] = - arr [ x - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT DEDENT def find_missing ( self , size ) : NEW_LINE INDENT shift = segregate ( self , size ) NEW_LINE arr2 = [ ] NEW_LINE j = 0 NEW_LINE for i in range ( shift , size ) : NEW_LINE INDENT arr2 . append ( arr [ i ] ) NEW_LINE j += 1 NEW_LINE DEDENT return find_missing_positive ( arr2 , j ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = find_missing ( arr , arr_size ) NEW_LINE print ( " The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ " , missing ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def _ _ main _ _ ( ) : NEW_LINE INDENT from math import pow as mod NEW_LINE mod = 1000000007 NEW_LINE def digitNumber ( n ) : NEW_LINE INDENT if n == 0 : return 1 NEW_LINE if n == 1 : return 9 NEW_LINE if n % 2 : NEW_LINE INDENT temp = digitNumber ( ( n - 1 ) / 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n / 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT DEDENT def countExcluding ( n , d ) : NEW_LINE INDENT if d == 0 : return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE else : return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT d = 9 NEW_LINE n = 3 NEW_LINE print ( countExcluding ( n , d ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import java . io io io NEW_LINE import os NEW_LINE from os import io NEW_LINE from os import urandom NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE from codecs import StreamWriter NEW_LINE from io import BufferedWriter NEW_LINE from io import StringIO NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BytesIO NEW_LINE from io import BufferedWriter NEW_LINE from io import StringIO NEW_LINE from io import StringIO NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BufferedWriter NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BufferedReader NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BufferedReader NEW_LINE from io import BufferedWriter NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BufferedReader NEW_LINE from io import BufferedReader NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BufferedWriter NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BufferedWriter NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BufferedWriter NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BufferedWriter NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BufferedReader NEW_LINE from io import BufferedWriter NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE import StreamWriter NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE import StreamWriter NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE import StreamWriter NEW_LINE from io import StreamWriter NEW_LINE from io import StreamWriter NEW_LINE from io import StreamWriter NEW_LINE from io import StringIO NEW_LINE DEDENT
def convert12 ( x ) : NEW_LINE INDENT import struct NEW_LINE class GFG ( struct . Struct ) : NEW_LINE INDENT def convert12 ( self ) : NEW_LINE INDENT h1 = struct . unpack ( ' H ' , self . data [ 0 ] ) [ 0 ] - '0' NEW_LINE h2 = struct . unpack ( ' H ' , self . data [ 1 ] ) [ 0 ] - '0' NEW_LINE hh = h1 * 10 + h2 NEW_LINE if hh < 12 : NEW_LINE INDENT Meridien = ' AM ' NEW_LINE DEDENT else : NEW_LINE INDENT Meridien = ' PM ' NEW_LINE DEDENT hh %= 12 NEW_LINE if hh == 0 : NEW_LINE INDENT print ( '12' , end = ' ▁ ' ) NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( x [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( hh , end = ' ▁ ' ) NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( x [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ' ▁ ' , Meridien ) NEW_LINE DEDENT def convert13 ( self ) : NEW_LINE INDENT x = '17:35:20' NEW_LINE convert12 ( x ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def GFG ( s , k ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ i % k ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE def count_common_divisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n , m = len ( a ) , len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if n % i == 0 and m % i == 0 : NEW_LINE INDENT if a [ : i ] == b [ : i ] : NEW_LINE INDENT if check ( a , i ) and check ( b , i ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , b = ' xaxa ' , ' xaxaxaxa ' NEW_LINE print ( count_common_divisors ( a , b ) ) NEW_LINE DEDENT DEDENT
def GFG ( a , b ) : return ( a > b ) NEW_LINE def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT global K NEW_LINE K = [ [ 0 for i in range ( n + 1 ) ] for w in range ( 0 , W + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for w in range ( 0 , W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE print ( res ) NEW_LINE w = W NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if res == K [ i - 1 ] [ w ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] , end = ' ▁ ' ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT def main ( arg ) : NEW_LINE INDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE printknapSack ( W , wt , val , n ) NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = self . n NEW_LINE self . z = self . n * 2 NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . arr = [ ] NEW_LINE DEDENT ff = [ ] NEW_LINE ss = [ ] NEW_LINE while n : NEW_LINE INDENT ff . append ( sys . stdin . read ( ) ) NEW_LINE ss . append ( sys . stdin . read ( ) ) NEW_LINE DEDENT pp = len ( ff ) NEW_LINE for i in range ( pp ) : NEW_LINE INDENT for j in range ( pp ) : NEW_LINE INDENT if ff [ i ] == ss [ j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT sys . stdout . write ( c ) NEW_LINE DEDENT
def test_indexed_sequential_search ( arr , n , k ) : NEW_LINE INDENT from scipy . ndimage import binary_structure NEW_LINE elements = [ ] NEW_LINE indices = [ ] NEW_LINE temp , i = 0 , 0 , 0 NEW_LINE for i in range ( 0 , n , 3 ) : NEW_LINE INDENT elements . append ( arr [ i : i + 3 ] ) NEW_LINE indices . append ( i ) NEW_LINE ind += 1 NEW_LINE DEDENT if k < elements [ 0 ] : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , ind + 1 ) : NEW_LINE INDENT if k < elements [ i ] : NEW_LINE INDENT start , end = indices [ i - 1 ] , indices [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT if k == arr [ i ] : NEW_LINE INDENT j = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if j == 1 : NEW_LINE INDENT print ( " Found ▁ at ▁ index ▁ " + str ( i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 8 NEW_LINE binary_structure ( arr , n , k ) NEW_LINE DEDENT DEDENT
def larrgestPalindrome ( n ) : NEW_LINE INDENT upper_limit = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT upper_limit *= 10 NEW_LINE upper_limit += 9 NEW_LINE DEDENT lower_limit = 1 + upper_limit / 10 NEW_LINE max_product = 0 NEW_LINE for i in range ( upper_limit , lower_limit - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i , lower_limit - 1 , - 1 ) : NEW_LINE INDENT product = i * j NEW_LINE if product < max_product : NEW_LINE INDENT break NEW_LINE DEDENT number = product NEW_LINE reverse = 0 NEW_LINE while number != 0 : NEW_LINE INDENT reverse = reverse * 10 + number % 10 NEW_LINE number /= 10 NEW_LINE DEDENT if product == reverse and product > max_product : NEW_LINE INDENT max_product = product NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT
def check ( dp , a ) : NEW_LINE INDENT from math import ceil NEW_LINE start = end = len ( dp ) - 1 NEW_LINE while 1 : NEW_LINE INDENT if dp [ start ] >= a : NEW_LINE INDENT return start NEW_LINE DEDENT elif dp [ end ] <= a : NEW_LINE INDENT return end NEW_LINE DEDENT else : NEW_LINE INDENT if start + 1 == end : NEW_LINE INDENT return end NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if dp [ mid ] == a : NEW_LINE INDENT return mid NEW_LINE DEDENT elif dp [ mid ] > a : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def test_FastFoodRestaurant ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE for test in range ( 10 ) : NEW_LINE INDENT a , b , c = next ( itertools ) NEW_LINE if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if b > c and b > a : NEW_LINE INDENT k = a NEW_LINE a , b = b , k NEW_LINE DEDENT if c > b and c > a : NEW_LINE INDENT k = a NEW_LINE a , c = c , k NEW_LINE DEDENT res = repeat ( a , b ) NEW_LINE if a >= 1 : NEW_LINE INDENT a -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if b >= 1 : NEW_LINE INDENT b -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if c >= 1 : NEW_LINE INDENT c -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if a >= 1 and b >= 1 : NEW_LINE INDENT a -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if c >= 1 and b >= 1 : NEW_LINE INDENT c -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if a >= 1 and b >= 1 and c >= 1 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT DEDENT DEDENT
def import _solution_788A NEW_LINE import math NEW_LINE import os NEW_LINE class Solution788A ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . arr = [ ] NEW_LINE self . dist = [ ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT f = open ( self . arr [ 0 ] ) NEW_LINE n = int ( f . readline ( ) ) NEW_LINE f = f . readline ( ) . split ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT self . arr . append ( int ( f . readline ( ) ) ) NEW_LINE DEDENT DEDENT final_max = 0 NEW_LINE for start in range ( 1 , 3 ) : NEW_LINE INDENT max = sum = 0 NEW_LINE add = True NEW_LINE for i in range ( start , n ) : NEW_LINE INDENT dist [ i ] = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE if add : NEW_LINE INDENT sum += dist [ i ] NEW_LINE max = sum if sum > max else max NEW_LINE add = False NEW_LINE DEDENT else : NEW_LINE INDENT sum -= dist [ i ] NEW_LINE add = True NEW_LINE DEDENT if sum < 0 : NEW_LINE INDENT sum = 0 NEW_LINE add = True NEW_LINE DEDENT DEDENT final_max = max if max > final_max else final_max NEW_LINE DEDENT print ( final_max ) NEW_LINE DEDENT
def maximum_xor ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . __forward__ , self . __s_backward = [ ] , [ ] NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while not self . __forward__ and arr [ i ] < arr [ self . __forward__ ] : NEW_LINE INDENT ans = max ( ans , arr [ i ] ^ arr [ self . __forward__ ] ) NEW_LINE self . __forward__ . pop ( ) NEW_LINE DEDENT self . __forward__ . append ( i ) NEW_LINE while not self . __s_backward and arr [ n - i - 1 ] < arr [ self . __s_backward ] : NEW_LINE INDENT ans = max ( ans , arr [ n - i - 1 ] ^ arr [ self . __s_backward ] ) NEW_LINE self . __s_backward . pop ( ) NEW_LINE DEDENT self . __s_backward . append ( n - i - 1 ) NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 8 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maximum_xor ( arr , n ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def dec_to_hexa ( n ) : NEW_LINE INDENT import sys NEW_LINE from math import ceil NEW_LINE hexadeci_num = [ ] NEW_LINE i = 0 NEW_LINE while n != 0 : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if temp < 10 : NEW_LINE INDENT hexadeci_num . append ( chr ( temp + 48 ) ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexadeci_num . append ( chr ( temp + 55 ) ) NEW_LINE i += 1 NEW_LINE DEDENT n = n / 16 NEW_LINE DEDENT for i in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT sys . stdout . write ( hexadeci_num [ i ] ) NEW_LINE DEDENT DEDENT
def import _main NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 0 NEW_LINE self . map = { } NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT self . n = int ( self . n ) NEW_LINE self . map = { } NEW_LINE for i in range ( - 1 , 1.0e+5 + 2 ) : NEW_LINE INDENT self . map [ i ] = 0 NEW_LINE DEDENT DEDENT def solve ( self ) : NEW_LINE INDENT max = sys . maxint NEW_LINE for x in range ( 0 , 1.0e+5 + 1 ) : NEW_LINE INDENT max = max ( max , self . map [ x - 1 ] + self . map [ x ] + self . map [ x + 1 ] ) NEW_LINE DEDENT print ( max ) NEW_LINE DEDENT DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . i = 0 NEW_LINE self . j = 0 NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT R , C = [ ] , [ ] NEW_LINE if not R and not C : NEW_LINE INDENT break NEW_LINE DEDENT hm = { } NEW_LINE for i , data in enumerate ( self . i ) : NEW_LINE INDENT for j , c in enumerate ( data ) : NEW_LINE INDENT if c == ' _ ' : NEW_LINE INDENT continue NEW_LINE DEDENT hm [ c ] = ( i , j ) NEW_LINE DEDENT DEDENT data = self . i . strip ( ) NEW_LINE iPos = 0 NEW_LINE jPos = 0 NEW_LINE count = len ( data ) NEW_LINE for i , j in enumerate ( data ) : NEW_LINE INDENT loc = hm [ i ] NEW_LINE count += abs ( iPos - loc [ 0 ] ) + abs ( jPos - loc [ 1 ] ) NEW_LINE iPos = loc [ 0 ] NEW_LINE jPos = loc [ 1 ] NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT DEDENT DEDENT
def test_main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . m = Main ( ) NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT self . m = Main ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT n = self . m . n NEW_LINE if n == 1 : NEW_LINE INDENT print ( " Hello ▁ World " ) NEW_LINE DEDENT else : NEW_LINE INDENT a = self . a NEW_LINE b = self . b NEW_LINE print ( a + b ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def extractMaximum ( data ) : NEW_LINE INDENT num , res = 0 , 0 NEW_LINE for c in data : NEW_LINE INDENT if c . isdigit ( ) : NEW_LINE INDENT num = num * 10 + ord ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , num ) NEW_LINE num = 0 NEW_LINE DEDENT DEDENT return max ( res , num ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT global f NEW_LINE f = [ ] NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE f . append ( arr [ n ] ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print_elements ( arr , n ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def GFG ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in ar : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT if sum % n == 0 : NEW_LINE INDENT return sum / n NEW_LINE DEDENT else : NEW_LINE INDENT A , B = sum / n , sum / n + 1 NEW_LINE ValueA , ValueB = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ValueA += ( ar [ i ] - A ) ** 2 NEW_LINE ValueB += ( ar [ i ] - B ) ** 2 NEW_LINE DEDENT if ValueA < ValueB : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT return B NEW_LINE DEDENT DEDENT DEDENT
def import import sys , string , int NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sys = sys . stdin NEW_LINE self . t = sys . stdin . readline ( ) . strip ( ) NEW_LINE for i in range ( self . t ) : NEW_LINE INDENT n = self . n NEW_LINE l = self . l NEW_LINE s = ' ' NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . atoi ( string . int ( string . int ( string . int ( ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) NEW_LINE while len ( temp ) < l : NEW_LINE INDENT temp = '0' + temp NEW_LINE DEDENT for k in range ( l ) : NEW_LINE INDENT if k < len ( temp ) and temp [ k ] == '1' : NEW_LINE INDENT arr [ k ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( l ) : NEW_LINE INDENT if n - arr [ i ] >= arr [ i ] : NEW_LINE INDENT s += 0 NEW_LINE DEDENT else : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT print ( int ( s , 2 ) ) NEW_LINE DEDENT DEDENT DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = _main ( ) NEW_LINE s = sc . next ( ) NEW_LINE s_l = len ( s ) NEW_LINE s_t = s NEW_LINE for i in range ( len ( s ) / 2 ) : NEW_LINE INDENT s_l -= 2 NEW_LINE s_t = s_t [ : s_l ] NEW_LINE if s_t [ : s_l / 2 ] == s_t [ s_l / 2 : ] : NEW_LINE INDENT print ( s_l ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def find_nth ( n ) : NEW_LINE INDENT import sys NEW_LINE import math NEW_LINE from math import sin , cos NEW_LINE count = 0 NEW_LINE for curr in range ( 19 , 9 ) : NEW_LINE INDENT sum = 0 NEW_LINE for x in range ( curr , 0 , - 1 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE DEDENT if sum == 10 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == n : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT sys . stdout . write ( find_nth ( 5 ) ) NEW_LINE DEDENT
def find_nth ( n ) : NEW_LINE INDENT import sys NEW_LINE import math NEW_LINE from math import sin , cos NEW_LINE count = 0 NEW_LINE for curr in range ( 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for x in curr : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE DEDENT if sum == 10 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == n : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT sys . stdout . write ( find_nth ( 5 ) ) NEW_LINE DEDENT
def GFG ( N , S ) : NEW_LINE INDENT count_elements = 0 NEW_LINE curr_sum = 0 NEW_LINE while curr_sum <= S : NEW_LINE INDENT curr_sum += N NEW_LINE N -= 1 NEW_LINE count_elements += 1 NEW_LINE DEDENT return count_elements NEW_LINE DEDENT
def __test_strmatch ( str , pattern , n , m ) : NEW_LINE INDENT import re NEW_LINE if m == 0 : return ( n , False ) NEW_LINE lookup = [ [ False for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE lookup [ 0 ] [ 0 ] = True NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if pattern [ j - 1 ] == ' * ' : lookup [ 0 ] [ j ] = lookup [ 0 ] [ j - 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if pattern [ j - 1 ] == ' * ' : lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] or lookup [ i - 1 ] [ j ] NEW_LINE elif pattern [ j - 1 ] == ' ? ' or str [ i - 1 ] == pattern [ j - 1 ] : lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE else : lookup [ i ] [ j ] = False NEW_LINE DEDENT DEDENT return lookup [ n ] [ m ] NEW_LINE DEDENT
def import import os , sys , glob , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes
def nCr ( n , r ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def nCr ( self , n , r ) : NEW_LINE INDENT fac = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT ans = fac [ n ] / ( fac [ n - r ] ** 2 ) NEW_LINE return ans NEW_LINE DEDENT def nCr ( self , n , r ) : NEW_LINE INDENT n , k = 3 , 3 NEW_LINE ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) NEW_LINE return ans NEW_LINE DEDENT DEDENT return GFG ( n , r ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from math import fabs NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE a = [ sin ( x ) for x in range ( n ) ] NEW_LINE a . sort ( ) NEW_LINE min = sys . maxint NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sa = abs ( a [ n - 1 ] - a [ i ] * 2 ) NEW_LINE if sa < min : NEW_LINE INDENT min = sa NEW_LINE ans = a [ i ] NEW_LINE DEDENT DEDENT sys . stdout . write ( a [ n - 1 ] + " ▁ " ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import gcd NEW_LINE class GFG ( object ) : NEW_LINE INDENT def gcd ( self , a ) : NEW_LINE INDENT if a == 0 : return b NEW_LINE return gcd ( b % a , a ) NEW_LINE DEDENT def powgcd ( self , a , n , b ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a = a * a NEW_LINE DEDENT return gcd ( a , b ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT a , b , n = 10 , 5 , 2 NEW_LINE print ( powgcd ( a , n , b ) ) NEW_LINE DEDENT DEDENT
def import import sys , string , traceback NEW_LINE import sys NEW_LINE import string NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . A = [ ] NEW_LINE self . B = [ ] NEW_LINE self . C = [ 0 ] * 10000 NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return string . split ( self . A ) [ 0 ] NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( self . n ) NEW_LINE self . A = [ ] NEW_LINE self . B = [ ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT self . A . append ( int ( self . A [ i ] ) ) NEW_LINE self . C [ self . A [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , 10000 ) : NEW_LINE INDENT self . C [ i ] = self . C [ i - 1 ] + self . C [ i ] NEW_LINE DEDENT for i in range ( self . n - 1 , - 1 , - 1 ) : NEW_LINE INDENT self . B [ self . C [ A [ i ] ] - 1 ] = self . A [ i ] NEW_LINE self . C [ A [ i ] ] -= 1 NEW_LINE DEDENT for i in range ( self . n - 1 ) : NEW_LINE INDENT self . B [ i ] = self . B [ i ] + 1 NEW_LINE DEDENT print ( ' ▁ ' . join ( self . B ) + ' ▁ ' ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n = sc . readline ( ) NEW_LINE s = sc . read ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '8' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( min ( count , n / 11 ) ) NEW_LINE DEDENT DEDENT
def GFG ( n , b ) : NEW_LINE INDENT unit_digit , sum = 0 , 0 NEW_LINE while n > 0 : NEW_LINE INDENT unit_digit = n % b NEW_LINE sum += unit_digit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT
def import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def printLargestDivisible ( self , a ) : NEW_LINE INDENT i , c0 , c5 = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c5 += 1 NEW_LINE DEDENT DEDENT c5 = int ( math . floor ( c5 / 9 ) ) * 9 NEW_LINE if c0 == 0 : NEW_LINE INDENT print ( - 1 , end = ' ▁ ' ) NEW_LINE DEDENT elif c5 == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( c5 ) : NEW_LINE INDENT print ( 5 , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( c0 ) : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT a = [ 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 0 , 5 , 5 ] NEW_LINE n = len ( a ) NEW_LINE printLargestDivisible ( self , n , a ) NEW_LINE DEDENT DEDENT
def count_ways ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def count_ways ( self ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if self . i + j + k + l == n : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = 8 NEW_LINE print ( count_ways ( n ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def __numberOfMinutes ( S , S1 ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . floor ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . Min = 0 NEW_LINE self . Min = int ( ( ( S - S1 ) / math . floor ( S ) ) * 60 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT S , S1 = 30 , 10 NEW_LINE print ( " % d ▁ min " % ( number_of_minutes ( S , S1 ) ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def import codechef_submission NEW_LINE import sys NEW_LINE import random NEW_LINE import string NEW_LINE import sys NEW_LINE from codechef import codechef_submission NEW_LINE from codechef import codechef_submission NEW_LINE from codechef import codechef_submission NEW_LINE from codechef import codechef_submission NEW_LINE from codechef import codechef_submission NEW_LINE from codechef import codechef_submission NEW_LINE from codechef import codechef_submission NEW_LINE from codechef import codechef_submission NEW_LINE from codechef_submission import codechef_submission NEW_LINE n , m , k = codechef_submission . get_n ( ) NEW_LINE b = codechef_submission . get_n ( n ) NEW_LINE if n < k : NEW_LINE INDENT print ( n ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b [ i ] = codechef_submission . get_n ( n ) NEW_LINE DEDENT d = codechef_submission . get_n ( n - 1 ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT d [ i ] = b [ i + 1 ] - b [ i ] - 1 NEW_LINE DEDENT d . sort ( ) NEW_LINE sum = b [ - 1 ] - b [ 0 ] + 1 NEW_LINE for i in d [ - 1 ] [ - 1 - ( k - 1 ) : ] : NEW_LINE INDENT sum -= d [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT number_of_bits = int ( math . floor ( math . log ( n ) / math . log ( 2 ) ) ) + 1 NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ n NEW_LINE DEDENT
def test_new_class_27 ( ) : NEW_LINE INDENT import sys NEW_LINE class NewClass27 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . t = sys . stdin . readline ( ) . strip ( ) NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT while len ( self . t ) : NEW_LINE INDENT w , h , n = self . t NEW_LINE sheet = 1 NEW_LINE while w % 2 == 0 : NEW_LINE INDENT w //= 2 NEW_LINE sheet *= 2 NEW_LINE DEDENT while h % 2 == 0 : NEW_LINE INDENT h //= 2 NEW_LINE sheet *= 2 NEW_LINE DEDENT if sheet >= n : NEW_LINE INDENT self . t = sheet NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def GFG ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( " ( % d , % d ▁ ) " % ( int ( 2 * x2 - x1 ) , int ( 2 * y2 - y1 ) ) ) NEW_LINE DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , z ) : NEW_LINE INDENT self . s = s NEW_LINE for n , m , a , b , i in z : NEW_LINE INDENT print ( ( m - 1 - max ( abs ( ( a , b , i ) ) if n % 2 and n % 2 else a ) , abs ( ( b , b , i ) if n % 2 and n % 2 else b ) ) % 3 + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def alter ( self , x , y ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT if not x or not y : NEW_LINE INDENT break NEW_LINE DEDENT if x >= 2 * y : NEW_LINE INDENT x = x % ( 2 * y ) NEW_LINE DEDENT elif y >= 2 * x : NEW_LINE INDENT y = y % ( 2 * x ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " X ▁ = ▁ % d , ▁ " " Y ▁ = ▁ % d " % ( x , y ) ) NEW_LINE DEDENT DEDENT x , y = 12 , 5 NEW_LINE return GFG ( x , y ) NEW_LINE DEDENT
def import import os NEW_LINE import random NEW_LINE import random NEW_LINE import sys NEW_LINE import random NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = random . randint ( 1 , 10000 ) NEW_LINE DEDENT def __init__ ( self , a , x , y ) : NEW_LINE INDENT self . n = int ( a ) NEW_LINE v = [ ] NEW_LINE seen = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( random . randint ( 0 , 10000 ) ) NEW_LINE seen . add ( v [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT self . swap ( v , int ( random . random ( ) * ( i - 1 ) ) , i ) NEW_LINE DEDENT v . sort ( ) NEW_LINE ans = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d = v [ j ] - v [ i ] NEW_LINE if v [ i ] - d in seen : continue NEW_LINE cnt , cur = 2 , v [ j ] NEW_LINE while cur + d in seen : NEW_LINE INDENT cur += d NEW_LINE cnt += 1 NEW_LINE DEDENT ans = max ( ans , cnt ) NEW_LINE DEDENT DEDENT self . write ( ans ) NEW_LINE DEDENT def swap ( self , a , x , y ) : NEW_LINE INDENT t = self . a [ x ] NEW_LINE self . a [ x ] = a [ y ] NEW_LINE self . a [ y ] = t NEW_LINE DEDENT DEDENT
def import _A1569 NEW_LINE class A1569 ( object ) : NEW_LINE INDENT def __init__ ( self , case ) : NEW_LINE INDENT self . case = case NEW_LINE self . finals = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . case -= 1 NEW_LINE flag = False NEW_LINE letters = _A1569 . keys ( ) NEW_LINE ab = _A1569 [ 0 ] NEW_LINE for i in range ( 1 , letters ) : NEW_LINE INDENT if ab [ i - 1 ] != ab [ i ] : NEW_LINE INDENT flag = True NEW_LINE print ( ( i , i + 1 ) ) NEW_LINE break NEW_LINE DEDENT DEDENT if flag == False : NEW_LINE INDENT print ( ' - 1 ▁ ' , ' - 1' ) NEW_LINE DEDENT DEDENT DEDENT
def import _re NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , num ) : NEW_LINE INDENT self . mod = 1000000007 NEW_LINE self . inv2 = 500000004 NEW_LINE DEDENT def modulo ( self , num ) : NEW_LINE INDENT res = 0 NEW_LINE for c in num : res = ( res * 10 + ord ( c ) - ord ( '0' ) ) % mod NEW_LINE return res NEW_LINE DEDENT def findsum ( L , R ) : NEW_LINE INDENT a , b , l , r , ret = modulo ( L ) , modulo ( R ) , modulo ( L ) , modulo ( R ) NEW_LINE a = a NEW_LINE b = b NEW_LINE l = ( ( a * ( a - 1 ) ) % mod * self . inv2 ) % mod NEW_LINE r = ( ( b * ( b + 1 ) ) % mod * self . inv2 ) % mod NEW_LINE ret = ( r % mod - l % mod ) NEW_LINE if ret < 0 : ret = ret + mod NEW_LINE else : ret = ret % mod NEW_LINE return ret NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT if k < 1 or l + 1 == r : NEW_LINE INDENT return NEW_LINE DEDENT k -= 2 NEW_LINE mid = ( l + r ) // 2 NEW_LINE temp = a [ mid - 1 ] NEW_LINE a [ mid - 1 ] = a [ mid ] NEW_LINE a [ mid ] = temp NEW_LINE unsort ( l , mid , a , k ) NEW_LINE unsort ( mid , r , a , k ) NEW_LINE def arrayWithKCalls ( n , k ) : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT print ( " NO ▁ SOLUTION " , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT a = [ 1 ] + [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = i + 1 NEW_LINE DEDENT k -= 1 NEW_LINE unsort ( 0 , n , a , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n , k = 10 , 17 NEW_LINE arrayWithKCalls ( n , k ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import sqrt NEW_LINE class GFG ( object ) : NEW_LINE INDENT def mean ( self , mid , freq , n ) : NEW_LINE INDENT sum , freq_sum = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + mid [ i ] * freq [ i ] NEW_LINE freq_sum = freq_sum + freq [ i ] NEW_LINE DEDENT return sum / freq_sum NEW_LINE DEDENT def grouped_sd ( self , lower_limit , upper_limit , freq , n ) : NEW_LINE INDENT mid = [ ( lower_limit [ i ] + upper_limit [ i ] ) / 2 for i in range ( n ) ] NEW_LINE sum , freq_sum , sd = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 NEW_LINE sum = sum + freq [ i ] * mid [ i ] ** 2 NEW_LINE freq_sum = freq_sum + freq [ i ] NEW_LINE DEDENT sd = float ( sqrt ( ( sum - freq_sum * mean ( mid , freq , n ) ** 2 ) ) / ( freq_sum - 1 ) ) NEW_LINE return sd NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT lower_limit = [ 50 , 61 , 71 , 86 , 96 ] NEW_LINE upper_limit = [ 60 , 70 , 85 , 95 , 100 ] NEW_LINE freq = [ 9 , 7 , 9 , 12 , 8 ] NEW_LINE n = len ( lower_limit ) NEW_LINE print ( grouped_sd ( self , lower_limit , upper_limit , freq , n ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT import math NEW_LINE import math NEW_LINE class GFG ( math . factorial ) : NEW_LINE INDENT def gcd ( self , a ) : NEW_LINE INDENT if a == 0 : return b NEW_LINE return gcd ( b % a , a ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def import _rectanglearea NEW_LINE import math NEW_LINE import os NEW_LINE import math NEW_LINE import os NEW_LINE class GFG ( math . Float ) : NEW_LINE INDENT def rectanglearea ( self , a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a , b = 10 , 8 NEW_LINE print ( rectanglearea ( a , b ) ) NEW_LINE DEDENT DEDENT
def import import os , errno , StringIO , configparser , ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import BytesIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import BytesIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE from io import StringIO NEW_LINE from io import StringIO NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE from io import BytesIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE from io import BytesIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE from io import StringIO NEW_LINE import ConfigParser NEW_LINE from io import StringIO NEW_LINE from io import StringIO NEW_LINE import StringIO NEW_LINE from io import StringIO NEW_LINE NEW_LINE class CF427_1 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . readfp = StringIO ( ) NEW_LINE self . readfp = file NEW_LINE DEDENT DEDENT
def GFG ( x ) : return ( x * ( x + 1 ) ) / 2 NEW_LINE def count_jumps ( n ) : NEW_LINE INDENT n = abs ( n ) NEW_LINE ans = 0 NEW_LINE while getsum ( ans ) < n or ( ( getsum ( ans ) - n ) & 1 ) > 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 10 NEW_LINE def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if k < 0 : NEW_LINE INDENT return - 10000000 NEW_LINE DEDENT if n < 0 or m < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n , m , k ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT try : NEW_LINE INDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if arr1 [ n - 1 ] == arr2 [ m - 1 ] : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT k = 1 NEW_LINE arr1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE arr2 = [ 5 , 3 , 1 , 4 , 2 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE dp = [ [ - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1
def import import decimal NEW_LINE import sys NEW_LINE import decimal NEW_LINE import matplotlib . pyplot as plt NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT plt . figure ( ) NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT N = float ( args [ 0 ] ) NEW_LINE d = float ( args [ 1 ] ) NEW_LINE x = float ( args [ 2 ] ) NEW_LINE ans = decimal . Decimal ( '0.0' ) NEW_LINE while N > 0.5 : NEW_LINE INDENT adnum = decimal . Decimal ( d + x * ( N - 0.5 ) ) NEW_LINE ans = ans + adnum NEW_LINE d = ( N + 1.0 ) * d / N + ( 5.0 * x ) / ( 2.0 * N ) NEW_LINE x = ( 1.0 + ( 2.0 / N ) ) * x NEW_LINE del N NEW_LINE DEDENT DEDENT plt . plot ( ans , ' - ' ) NEW_LINE plt . show ( ) NEW_LINE DEDENT
def reverseorder ( n ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE from math import sin , cos , pi NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n ** 2 + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n , 2 , - 1 ) : NEW_LINE INDENT if prime [ i ] == True : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT N = 25 NEW_LINE print ( ' Prime ▁ number ▁ in ▁ reverse ▁ order ' ) NEW_LINE if N == 1 : NEW_LINE INDENT print ( ' No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range ' ) NEW_LINE DEDENT else : NEW_LINE INDENT reverseorder ( N ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . min_stars = 1 NEW_LINE self . p_space = self . p_height - 1 NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT x = 1 NEW_LINE for i in range ( self . p_height ) : NEW_LINE INDENT for j in range ( self . p_space , i - 1 , - 1 ) : NEW_LINE INDENT print ( " ▁ " , end = ' ' ) NEW_LINE DEDENT for k in range ( self . min_stars ) : NEW_LINE INDENT print ( " * " , end = ' ' ) NEW_LINE DEDENT for n in range ( ( self . p_height + self . p_height - 2 ) , self . x - n , - 1 ) : NEW_LINE INDENT print ( " ▁ " , end = ' ' ) NEW_LINE DEDENT for k in range ( self . min_stars ) : NEW_LINE INDENT print ( " * " , end = ' ' ) NEW_LINE DEDENT DEDENT self . min_stars = self . min_stars + 2 NEW_LINE self . x = self . x + 2 NEW_LINE print ( ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT min_stars = 1 NEW_LINE self . p_height = 5 NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class B629 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 1 NEW_LINE self . FfriendPerDay = [ 0 ] * 367 NEW_LINE self . MfriendPerDay = [ 0 ] * 367 NEW_LINE self . answer = 0 NEW_LINE for c in self . n : NEW_LINE INDENT a = ord ( c ) NEW_LINE b = ord ( c ) NEW_LINE for j in range ( a , b + 1 ) : NEW_LINE INDENT if c == ' M ' : NEW_LINE INDENT self . MfriendPerDay [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . FfriendPerDay [ j ] += 1 NEW_LINE DEDENT if self . MfriendPerDay [ j ] < self . FfriendPerDay [ j ] : NEW_LINE INDENT if self . MfriendPerDay [ j ] > self . answer : NEW_LINE INDENT self . answer = self . MfriendPerDay [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . FfriendPerDay [ j ] > self . answer : NEW_LINE INDENT self . answer = self . FfriendPerDay [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( self . answer * 2 ) NEW_LINE DEDENT DEDENT
def import _gradient_gradient_gradient_sum NEW_LINE class GFG ( object ) : NEW_LINE INDENT def distancesum ( self , x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( self . distancesum ( x , y , n ) ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import sqrt NEW_LINE class GFG ( object ) : NEW_LINE INDENT def fib ( self , n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return int ( round ( pow ( phi , n ) / sqrt ( 5 ) ) ) NEW_LINE DEDENT def calculateSum ( self , l ) : NEW_LINE INDENT sum = self . fib ( r + 2 ) - self . fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT def sumFibonacci ( self , k ) : NEW_LINE INDENT l = ( self . k * ( k - 1 ) ) / 2 NEW_LINE r = self . l + k NEW_LINE sum = calculateSum ( self . l , self . r - 1 ) NEW_LINE return sum NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT k = 3 NEW_LINE print ( sumFibonacci ( self , k ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import sqrt NEW_LINE class GFG ( object ) : NEW_LINE INDENT def fib ( self , n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return int ( round ( pow ( phi , n ) / sqrt ( 5 ) ) ) NEW_LINE DEDENT def calculateSum ( self , l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += self . fib ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT l , r = 4 , 8 NEW_LINE print ( calculateSum ( self , l , r ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 NEW_LINE return int ( round ( math . pow ( phi , n ) / math . sqrt ( 5 ) ) ) NEW_LINE def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT l , r = 4 , 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE DEDENT DEDENT
def import readline NEW_LINE import sys NEW_LINE import readline NEW_LINE import select NEW_LINE try : NEW_LINE INDENT input = open ( sys . stdin . fileno ( ) , ' r ' ) NEW_LINE n , q , s = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) NEW_LINE str = [ s ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT l , r = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) NEW_LINE c1 , c2 = readline ( ) NEW_LINE start = l NEW_LINE end = r NEW_LINE while start <= end : NEW_LINE INDENT if s [ start ] == c1 : NEW_LINE INDENT s [ start ] = c2 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT DEDENT for c in s : NEW_LINE INDENT sys . stdout . write ( c ) NEW_LINE DEDENT sys . stdout . write ( ' ' ) NEW_LINE DEDENT
def compare_strings ( str1 , str2 ) : NEW_LINE INDENT import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE NEW_LINE import string NEW_LINE import string NEW_LINE NEW_LINE import string NEW_LINE import string NEW_LINE NEW_LINE import string NEW_LINE NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = sys . stdin . read ( ) NEW_LINE self . b = sys . stdin . read ( ) NEW_LINE self . ans = self . get_num ( a , b ) NEW_LINE print ( self . ans ) NEW_LINE DEDENT def get_num ( self , a , b ) : NEW_LINE INDENT reverse_b = 0 NEW_LINE while b > 0 : NEW_LINE INDENT reverse_b = reverse_b * 10 + b % 10 NEW_LINE b //= 10 NEW_LINE DEDENT return a + reverse_b NEW_LINE DEDENT DEDENT return Main ( ) NEW_LINE DEDENT
def test_A1133 ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy . testing import assert_array_almost_equal NEW_LINE class A1133 ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT self . x1 = 0 NEW_LINE self . y1 = 1 NEW_LINE self . x2 = 2 NEW_LINE self . y2 = 3 NEW_LINE self . x3 = 3 NEW_LINE self . y3 = 4 NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return "3" NEW_LINE DEDENT DEDENT assert_array_almost_equal ( A1133 ( ) , A1133 ( ) ) NEW_LINE DEDENT
def import import sys , StringIO , pickle , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes
def GFG ( n , d ) : NEW_LINE INDENT n //= d NEW_LINE return ( n ) * ( 1 + n ) ** d / 2 NEW_LINE def sum_multiples ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE return sum_ap ( n , 2 ) + sum_ap ( n , 5 ) - sum_ap ( n , 10 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 20 NEW_LINE print ( sum_multiples ( n ) ) NEW_LINE DEDENT return sum_multiples ( n ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . n = 0 NEW_LINE DEDENT DEDENT return Main ( ) NEW_LINE DEDENT
def GFG ( num ) : NEW_LINE INDENT fact = 1 NEW_LINE while num > 1 : NEW_LINE INDENT fact *= num NEW_LINE num -= 1 NEW_LINE DEDENT return fact NEW_LINE def catalan ( n ) : NEW_LINE INDENT return fact ( 2 * n ) / ( fact ( n ) * fact ( n + 1 ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE i , k = 0 , 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < arr [ k ] : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT catalan_left_bst = catalan ( s ) NEW_LINE catalan_right_bst = catalan ( n - s - 1 ) NEW_LINE total_bst = catalan_right_bst * catalan_left_bst NEW_LINE print ( total_bst , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def import naming , icon , image , image , objcontext , objservice_revoked_event , array , * , math , spi , locale_name_provider NEW_LINE from naming import naming NEW_LINE from naming import icon , icon , image , image , objcontext , objservice_revoked_event , array , * , math , spi , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , , * , , * , , * , , * , , * , , * , * , , * , , * , , * , * , , * , , * , * , , * , * , , * , * , , * , * , , * , * , , * , , * , * , , * , , * , , * , , * , , * , , * , , * , , * , , * , , * , , * , , * , , * , , * , , * , * , , * , , * , * , , * , , * , * , , * , * , , * , * , , * , , * , , * , ,
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class Codechef ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT sc = sys . stdin NEW_LINE t = sys . __stdin__ . count ( ' \n ' ) NEW_LINE while t : NEW_LINE INDENT a = sc . read ( 1 ) NEW_LINE b = sc . read ( 1 ) NEW_LINE if a < b : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT else : NEW_LINE INDENT if a % 2 != b % 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n , arr , ** kwargs ) : NEW_LINE INDENT count = [ 1 ] * ( n + 1 ) NEW_LINE if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in range ( len ( arr ) ) : NEW_LINE INDENT if i - arr [ j ] >= 0 : NEW_LINE INDENT no_ways += count [ i - arr [ j ] ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
def import _pylab NEW_LINE import pylab NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . cm as cm NEW_LINE import matplotlib . pylab as plt NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = plt . gcf ( ) NEW_LINE def doit ( self ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT n = sc . select ( 0 ) . size NEW_LINE if n == 0 : break NEW_LINE data = [ sc . get ( i ) - sc . get ( i ) for i in range ( 12 ) ] NEW_LINE sum = 0 NEW_LINE flg = False NEW_LINE ans = - 1 NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT sum += data [ i ] NEW_LINE if sum >= n : NEW_LINE INDENT ans = i + 1 NEW_LINE flg = True NEW_LINE break NEW_LINE DEDENT DEDENT if flg : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NA ' ) NEW_LINE DEDENT DEDENT DEDENT def debug ( self , * x ) : NEW_LINE INDENT print ( " debug ▁ = ▁ " , repr ( x ) ) NEW_LINE DEDENT DEDENT def doit ( self ) : NEW_LINE INDENT plt . figure ( ) NEW_LINE plt . subplot ( 111 ) NEW_LINE plt . imshow ( Main ( ) ) NEW_LINE plt . show ( ) NEW_LINE DEDENT DEDENT
def import _Practice NEW_LINE class Practice ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT sc = _Practice ( ) NEW_LINE t = sc . count ( ) NEW_LINE while t : NEW_LINE INDENT a , b , c = _Practice ( a , b , c ) NEW_LINE if a == b and c == b : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = abs ( a - b ) + abs ( b - c ) + abs ( c - a ) NEW_LINE sum -= 4 NEW_LINE print ( max ( sum ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import import sys NEW_LINE class CF709A ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . stdin . read ( ) NEW_LINE self . b = sys . stdin . read ( ) NEW_LINE self . d = sys . stdin . read ( ) NEW_LINE self . a , self . sum , count = 0 , 0 , 0 NEW_LINE while self . n : NEW_LINE INDENT a = self . a NEW_LINE if a <= self . b : NEW_LINE INDENT self . sum += a NEW_LINE DEDENT if self . sum > self . d : NEW_LINE INDENT self . sum = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT
def main ( arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return binary_search ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binary_search ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT
def test_gf_eq ( ) : NEW_LINE INDENT class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE Xor = Xor ^ arr [ i ] NEW_LINE DEDENT if Sum == Xor : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE return GFG ( arr , n ) NEW_LINE DEDENT DEDENT
def import import _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline ,
def GFG ( arr , n ) : NEW_LINE INDENT cntEven , cntOdd = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT cntEven += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 NEW_LINE DEDENT DEDENT evenPairs = 0 NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) NEW_LINE oddPairs = 0 NEW_LINE oddPairs += ( cntEven * cntOdd ) NEW_LINE print ( " Odd ▁ pairs ▁ = ▁ " , oddPairs ) NEW_LINE print ( " Even ▁ pairs ▁ = ▁ " , evenPairs ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import ceil NEW_LINE from math import sin , cos , exp NEW_LINE n = len ( houses ) NEW_LINE m = len ( towers ) NEW_LINE left_tower = ceil ( floor ( houses [ 0 ] ) ) NEW_LINE right_tower = towers [ 0 ] NEW_LINE j , k = 0 , 0 NEW_LINE min_range = 0 NEW_LINE while j < n : NEW_LINE INDENT if houses [ j ] < right_tower : NEW_LINE INDENT left = houses [ j ] - left_tower NEW_LINE right = right_tower - houses [ j ] NEW_LINE local_max = left < right NEW_LINE if local_max > min_range : NEW_LINE INDENT min_range = local_max NEW_LINE DEDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT left_tower = towers [ k ] NEW_LINE if k < m - 1 : NEW_LINE INDENT k += 1 NEW_LINE right_tower = towers [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT right_tower = ceil ( floor ( houses [ k ] ) ) NEW_LINE DEDENT DEDENT DEDENT return min_range NEW_LINE DEDENT
def _ ( ) : return ( ' ' ) NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , num , divisor ) : NEW_LINE INDENT self . num = num NEW_LINE self . divisor = divisor NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT print ( self . num , self . divisor ) NEW_LINE DEDENT DEDENT
def import tennis NEW_LINE class tennis ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = [ ] NEW_LINE self . res , self . cnt1 , self . cnt2 = 0 , 0 , 0 NEW_LINE self . n , self . m , self . z = self . s [ : - 1 ] , self . s [ - 1 ] , self . s [ - 1 ] NEW_LINE for i in range ( self . m , self . z + 1 , self . m ) : NEW_LINE INDENT for j in range ( self . n , self . z + 1 , self . n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT self . res += 1 NEW_LINE DEDENT DEDENT DEDENT print ( self . res ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT super ( AOJ0181 , self ) . __init__ ( ) NEW_LINE self . do_it ( ) NEW_LINE DEDENT def do_it ( self , width ) : NEW_LINE INDENT w , cnt = 0 , 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT w += self . books [ i ] NEW_LINE if self . books [ i ] > width : return False NEW_LINE if w > width : NEW_LINE INDENT cnt += 1 NEW_LINE w = self . books [ i ] NEW_LINE DEDENT DEDENT return cnt > m and False or True NEW_LINE DEDENT def do_it ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT m , n = self . books [ 0 ] NEW_LINE if n + m == 0 : return False NEW_LINE books = [ self . books [ i ] for i in range ( n ) ] NEW_LINE left = 1 NEW_LINE right = 1500000 NEW_LINE while right - left != 1 : NEW_LINE INDENT next = ( left + right ) / 2 NEW_LINE if is_possible ( next ) : NEW_LINE INDENT right = next NEW_LINE DEDENT else : NEW_LINE INDENT left = next NEW_LINE DEDENT DEDENT print ( right ) NEW_LINE DEDENT DEDENT DEDENT
def import decimal , * , s , ** kwargs ) : return decimal . Decimal ( ) NEW_LINE import sys NEW_LINE import collections NEW_LINE import inspect NEW_LINE class Stuff ( object ) : NEW_LINE INDENT def __init__ ( self , v , w ) : NEW_LINE INDENT self . v = v NEW_LINE self . w = w NEW_LINE self . performance = 1.0 * v / w NEW_LINE DEDENT def __lt__ ( self , s ) : NEW_LINE INDENT if self . performance < s . performance : return 1 NEW_LINE if self . performance > s . performance : return - 1 NEW_LINE return 0 NEW_LINE DEDENT DEDENT class Main ( object ) : NEW_LINE INDENT def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n , w = sc . read ( ) . split ( ' \n ' ) NEW_LINE que = collections . deque ( [ ( vi , wi ) for vi , wi in izip ( sc . read ( ) , [ ( ' v ' , ' w ' ) , ( ' performance ' , ' performance ' ) ] ) ] ) NEW_LINE res = 0 NEW_LINE while w > 0 and not que . empty ( ) : NEW_LINE INDENT s = que . popleft ( ) NEW_LINE if w >= s . w : NEW_LINE INDENT res += s . v NEW_LINE w -= s . w NEW_LINE DEDENT else : NEW_LINE INDENT res += s . performance * w NEW_LINE w = 0 NEW_LINE DEDENT DEDENT print ( decimal . Decimal ( res ) . quantize ( decimal . Decimal ( '0.01' ) ) ) NEW_LINE sc . close ( ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT ones , twos = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT
def gf_maxdiff ( arr , n ) : NEW_LINE INDENT import scipy . ndimage NEW_LINE freq = { i : freq . get ( i , 0 ) or 1 for i in range ( n ) } NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if freq [ i ] > freq [ j ] and arr [ i ] > arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ i ] - freq [ j ] ) NEW_LINE DEDENT elif freq [ i ] < freq [ j ] and arr [ i ] < arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ j ] - freq [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def test_CF_1447B_numbersbox ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy import arange NEW_LINE count = range ( 10 ) NEW_LINE for i in range ( count ) : NEW_LINE INDENT n = arange ( n ) NEW_LINE m = arange ( m ) NEW_LINE arr = arange ( n * m ) NEW_LINE nagivitem_times = 0 NEW_LINE min_num = sys . maxint NEW_LINE sum_num = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT arr [ i ] = arange ( n ) NEW_LINE if arr [ i ] < 0 : NEW_LINE INDENT arr [ i ] = 0 - arr [ i ] NEW_LINE nagivitem_times += 1 NEW_LINE sum_num += arr [ i ] NEW_LINE if min_num > arr [ i ] : NEW_LINE INDENT min_num = arr [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT sum_num += arr [ i ] NEW_LINE if min_num > arr [ i ] : NEW_LINE INDENT min_num = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT if nagivitem_times % 2 == 0 : NEW_LINE INDENT print ( sum_num ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum_num - min_num * 2 ) NEW_LINE DEDENT DEDENT DEDENT
def make_ap ( arr , n ) : NEW_LINE INDENT from scipy . special import make_ap NEW_LINE if n == 3 : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) / 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( initial_term , ( i * common_difference ) , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE def main ( ) : NEW_LINE INDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE make_ap ( arr , n ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( y + x ) % ( y ^ x ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def test_gf_division ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def count_pairs ( self ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( y * x ) % ( y + x ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 15 NEW_LINE print ( count_pairs ( n ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def longestPalindrome ( s ) : NEW_LINE INDENT count = [ 0 ] * 128 NEW_LINE for c in s : NEW_LINE INDENT count [ c ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for v in count : NEW_LINE INDENT ans += v / 2 * 2 NEW_LINE if ans % 2 == 0 and v % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def GFG ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if k > n - k : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE def catalan ( n ) : NEW_LINE INDENT c = binomial_coeff ( 2 * n , n ) NEW_LINE return c / ( n + 1 ) NEW_LINE DEDENT def find_ways ( n ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return catalan ( n // 2 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 6 NEW_LINE print ( " Total ▁ possible ▁ expressions ▁ of ▁ length ▁ { } ▁ is ▁ { } " . format ( n , find_ways ( 6 ) ) ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class ex8 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . stdin . readline ( ) . strip ( ) NEW_LINE self . s = [ ] NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT self . s . append ( " ▁ " . join ( args ) ) NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT self . s . append ( " ▁ " . join ( args ) ) NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT res = " " NEW_LINE count = 0 NEW_LINE for q in range ( 1 , 12 ) : NEW_LINE INDENT if self . s [ q ] == " X " : NEW_LINE INDENT res = " ▁ 1x12" NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( 2 , 6 ) : NEW_LINE INDENT flag = 0 NEW_LINE if 12 % j == 0 : NEW_LINE INDENT for k in range ( 1 , 12 // j ) : NEW_LINE INDENT flag = 0 NEW_LINE for p in range ( k , 12 + 1 , 12 // j ) : NEW_LINE INDENT if self . s [ p ] == " O " : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT count += 1 NEW_LINE res += " ▁ " + str ( j ) + " x " * 12 / j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT flag = 0 NEW_LINE for l in range ( 1 , 12 ) : NEW_LINE INDENT if self . s [ l ] == " O " : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT res += " ▁ 12x1" NEW_LINE count += 1 NEW_LINE DEDENT sys . stdout . write ( " % d % s " % ( count , res ) ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def import import input_reader , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream ,
def GFG ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def count_number ( n ) : NEW_LINE INDENT import collections NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT collections . deque ( ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE return self . value NEW_LINE DEDENT DEDENT for i in range ( 1 , 9 ) : NEW_LINE INDENT s = [ ] NEW_LINE if i <= n : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while not s . empty ( ) : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . popleft ( ) NEW_LINE for j in range ( tp % 10 , 9 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if x <= n : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def GFG ( cost , N ) : NEW_LINE INDENT dp = [ [ cost [ 0 ] [ 0 ] ] for i in range ( 1 , N + 1 ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return float ( dp [ N - 1 ] [ N - 1 ] ) / ( 2 * N - 1 ) NEW_LINE DEDENT
def import _io NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 1000000 NEW_LINE self . sieve_Prime = [ 0 ] * ( MAX + 4 ) NEW_LINE self . sieve_count = [ 0 ] * ( MAX + 4 ) NEW_LINE DEDENT def form_sieve ( self ) : NEW_LINE INDENT self . sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if self . sieve_Prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if self . sieve_Prime [ j ] == 0 : NEW_LINE INDENT self . sieve_Prime [ j ] = 1 NEW_LINE self . sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT self . form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( " Count ▁ = ▁ % d " % ( self . sieve_count [ n ] + 1 ) ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = ▁ % d " % ( self . sieve_count [ n ] + 1 ) ) NEW_LINE DEDENT DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . k , self . t , self . u , self . v , self . l = sys . argv [ 1 : ] NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . k , self . t , self . u , self . v , self . l = self . n , self . k , self . t , self . u , self . v , self . l NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . k , self . t , self . v , self . l = self . n , self . k , self . t , self . v , self . l NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . d = [ ] NEW_LINE for i in range ( self . n + 1 ) : NEW_LINE INDENT self . d . append ( self . d [ i ] ) NEW_LINE DEDENT DEDENT def __init__ ( self ) : NEW_LINE INDENT self . d = [ ] NEW_LINE DEDENT def pos , c , nk = 0 , 0 , 0 NEW_LINE tm = 0 NEW_LINE while pos < self . l : NEW_LINE INDENT if pos < self . d [ c ] : NEW_LINE INDENT if nk > 0 : NEW_LINE INDENT nk -= 1 NEW_LINE x = min ( self . l , pos + self . t * v ) NEW_LINE tm += ( x - pos ) / float ( self . v ) NEW_LINE pos = x NEW_LINE DEDENT else : NEW_LINE INDENT tm += ( self . d [ c ] - pos ) / float ( self . u ) NEW_LINE pos = self . d [ c ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . d [ c ] == pos : NEW_LINE INDENT x = min ( self . l , pos + self . t * v ) NEW_LINE tm += ( x - pos ) / float ( self . v ) NEW_LINE pos = x NEW_LINE c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if nk < self . k : NEW_LINE INDENT c += 1 NEW_LINE nk += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = min ( self . l , self . d [ c ] + self . t * v ) NEW_LINE tm += ( x - pos ) / float ( self . v ) NEW_LINE pos = x NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( tm ) NEW_LINE DEDENT
def ways_to_split ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE prefix = [ 0 ] * n NEW_LINE suffix = [ 0 ] * n NEW_LINE seen = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = ( prefix [ i - 1 ] if i - 1 >= 0 else 0 ) NEW_LINE if seen [ s [ i ] - ' a ' ] == 0 : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev NEW_LINE seen [ s [ i ] - ' a ' ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT seen [ i ] = 0 NEW_LINE DEDENT suffix = [ 0 ] * n NEW_LINE for i in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] NEW_LINE if seen [ s [ i ] - ' a ' ] == 0 : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev NEW_LINE seen [ s [ i ] - ' a ' ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if prefix [ i ] == suffix [ i ] : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def test_p121 ( ) : NEW_LINE INDENT from sympy import factorial NEW_LINE print ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( ) ( I ) ( I ) ( I ) ( I ) ( I ) ( I ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) NEW_LINE TURNS = 15 NEW_LINE def factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( I ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) NEW_LINE DEDENT factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( factorial ( I ( factorial ( I ( I ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) NEW_LINE DEDENT
def import import string , symbols , glob , symbols , count , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray , recarray
def import _np NEW_LINE class Test ( object ) : NEW_LINE INDENT def __init__ ( self , arr1 , arr2 ) : NEW_LINE INDENT self . arr1 = arr1 NEW_LINE self . arr2 = arr2 NEW_LINE DEDENT def merge ( self , m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j , last = self . arr1 [ m - 1 ] NEW_LINE for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT self . arr1 [ j + 1 ] = self . arr1 [ j ] NEW_LINE DEDENT if j != m - 2 or last > self . arr2 [ i ] : NEW_LINE INDENT self . arr1 [ j + 1 ] = self . arr2 [ i ] NEW_LINE self . arr2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if a == 0 : return b NEW_LINE return gcd ( b % a , a ) NEW_LINE def same_remainder ( a , b , c ) : NEW_LINE INDENT a1 , b1 , c1 = ( b - a , c - b , c - a ) NEW_LINE return gcd ( a1 , gcd ( b1 , c1 ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , b , c = 62 , 132 , 237 NEW_LINE print ( same_remainder ( a , b , c ) ) NEW_LINE DEDENT DEDENT
def import _readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import sys NEW_LINE import struct NEW_LINE import sys NEW_LINE import struct NEW_LINE import sys NEW_LINE import struct NEW_LINE import sys NEW_LINE import struct NEW_LINE import sys NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import time NEW_LINE import math NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE class Main ( ) : NEW_LINE INDENT INF = 0x3f3f3f3f NEW_LINE LNF = 0x3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f
def GFG ( ) : NEW_LINE INDENT dp = [ [ 0 ] * 5001 , [ 0 ] * 5001 , [ 0 ] * 5 ] NEW_LINE def count_ways ( n , parts , next_part ) : NEW_LINE INDENT if not parts and not n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n <= 0 or parts <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ n ] [ next_part ] [ parts ] != - 1 : NEW_LINE INDENT return dp [ n ] [ next_part ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( next_part , n + 1 ) : NEW_LINE INDENT ans += count_ways ( n - i , parts - 1 , i ) NEW_LINE DEDENT return ( dp [ n ] [ next_part ] [ parts ] , ans ) NEW_LINE DEDENT def count_ways ( n ) : NEW_LINE INDENT for i in range ( 5001 ) : NEW_LINE INDENT for j in range ( 5001 ) : NEW_LINE INDENT for l in range ( 5 ) : NEW_LINE INDENT dp [ i ] [ j ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT return count_ways ( n , 4 , 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 8 NEW_LINE print ( count_ways ( n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT if ( a + b ) % 2 == 0 : NEW_LINE INDENT return ( ( a + b ) / 2 ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT N = 101 NEW_LINE mod = int ( 1e9 ) + 7 NEW_LINE exactsum = [ ] NEW_LINE exactnum = [ ] NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE exactnum [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 0 , x ) : NEW_LINE INDENT for j in range ( 0 , y ) : NEW_LINE INDENT for k in range ( 0 , z ) : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] % mod NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT x , y , z = 1 , 1 , 1 NEW_LINE print ( getSum ( x , y , z ) % mod ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT CHARS = 26 NEW_LINE def isValidString ( str ) : NEW_LINE INDENT freq = [ 0 ] * CHARS NEW_LINE for c in str : NEW_LINE INDENT freq [ c - ' a ' ] += 1 NEW_LINE DEDENT i , freq1 , count_freq1 = 0 , 0 , 0 NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if i in freq : NEW_LINE INDENT freq1 = freq [ i ] NEW_LINE count_freq1 = 1 NEW_LINE break NEW_LINE DEDENT DEDENT j , freq2 , count_freq2 = 0 , 0 , 0 NEW_LINE for i in range ( i + 1 , CHARS ) : NEW_LINE INDENT if i in freq : NEW_LINE INDENT if freq [ i ] == freq1 : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1 NEW_LINE freq2 = freq [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , CHARS ) : NEW_LINE INDENT if i in freq : NEW_LINE INDENT if freq [ i ] == freq1 : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT if freq [ i ] == freq2 : NEW_LINE INDENT count_freq2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if count_freq1 > 1 and count_freq2 > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT str = " abcbc " NEW_LINE if isValidString ( str ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def import import os , sys , string , unicode , string , list , dict , str , unicode , string , list , dict , str , unicode , strings , unicode , strings , strings , unicode , strings , strings , unicode , strings , strings , unicode , strings , strings , strings , unicode , strings , strings , strings , strings , unicode , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings , strings
def find_minimum_subsequences ( A , B ) : NEW_LINE INDENT number_of_subsequences = 1 NEW_LINE sizeof_b = len ( B ) NEW_LINE sizeof_a = len ( A ) NEW_LINE inf = 1000000 NEW_LINE next = [ [ inf for i in range ( 26 ) ] for j in range ( sizeof_b ) ] NEW_LINE for i in range ( sizeof_b ) : NEW_LINE INDENT next [ B [ i ] - ' a ' ] [ i ] = i NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( sizeof_b - 2 , - 1 , - 1 ) : NEW_LINE INDENT if next [ i ] [ j ] == inf : NEW_LINE INDENT next [ i ] [ j ] = next [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT pos = 0 NEW_LINE i = 0 NEW_LINE while i < sizeof_a : NEW_LINE INDENT if pos == 0 and next [ A [ i ] - ' a ' ] [ pos ] == inf : NEW_LINE INDENT number_of_subsequences = - 1 NEW_LINE break NEW_LINE DEDENT elif pos < sizeof_b and next [ A [ i ] - ' a ' ] [ pos ] < inf : NEW_LINE INDENT next_index = next [ A [ i ] - ' a ' ] [ pos ] + 1 NEW_LINE pos = next_index NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number_of_subsequences += 1 NEW_LINE pos = 0 NEW_LINE DEDENT DEDENT return number_of_subsequences NEW_LINE DEDENT
def import import _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline , _readline ,
def GFG ( arr , length ) : NEW_LINE INDENT from math import factorial NEW_LINE print ( "1" , end = ' ▁ ' ) NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT rank = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT rank += 1 NEW_LINE DEDENT DEDENT print ( rank , end = ' ▁ ' ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 88 , 14 , 69 , 30 , 29 , 89 ] NEW_LINE shape = arr . shape NEW_LINE return find_rank ( arr , shape ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import islice NEW_LINE from itertools import islice NEW_LINE from itertools import islice NEW_LINE from random import shuffle NEW_LINE from random import seed NEW_LINE from random import shuffle NEW_LINE from itertools import islice NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE h = islice ( sys . stdin . readline ( ) ) NEW_LINE a = islice ( sys . stdin . readline ( ) , n ) NEW_LINE b = islice ( sys . stdin . readline ( ) , n ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( key = islice ) NEW_LINE a . reverse ( ) NEW_LINE b . reverse ( ) NEW_LINE ans = islice ( a , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT h -= b [ i - 1 ] NEW_LINE DEDENT cnt = 0 NEW_LINE if h > 0 : NEW_LINE INDENT cnt = ( h + a [ n - 1 ] - 1 ) // a [ n - 1 ] NEW_LINE DEDENT ans = min ( ans , cnt + i ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while int ( product / pow ( 10 , k ) ) != 0 : NEW_LINE INDENT product = product / 10 NEW_LINE DEDENT return product NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE r = os . popen ( ' / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / bin / net ▁ - t ▁ / usr / local / net ▁ - t ▁ / usr / local / net ▁ - t ▁ / usr / local / net ▁ - t ▁ / usr / local / bin / env ▁ ' ) NEW_LINE for line in r . readlines ( ) : NEW_LINE INDENT m , n = int ( line . split ( ) [ 0 ] ) , int ( line . split ( ) [ 1 ] ) NEW_LINE if m < n : NEW_LINE INDENT t = m NEW_LINE m , n = n , t NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT t , n = n , m % n , t NEW_LINE DEDENT print ( m ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from nltk . corpus import brown NEW_LINE sc = brown . corpus ( ' s1' ) NEW_LINE s = sc . read ( ) NEW_LINE a = [ 0 ] * 26 NEW_LINE sum = 0 NEW_LINE for c in s : NEW_LINE INDENT a [ c - ' a ' ] += 1 NEW_LINE DEDENT for c in range ( 26 ) : NEW_LINE INDENT sum += a [ c ] % 2 NEW_LINE DEDENT print ( sum / 2 ) NEW_LINE DEDENT
def complement ( num ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . i , self . len , temp , comp = 0 , 0 , num NEW_LINE temp = self . num NEW_LINE while True : NEW_LINE INDENT self . len += 1 NEW_LINE num = num / 10 NEW_LINE if abs ( num ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT self . num = temp NEW_LINE comp = int ( math . pow ( 10 , self . len ) ) - num NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT def count_unset_bits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return sum ( x ^ n ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 17 NEW_LINE print ( count_unset_bits ( n ) ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def min_operations ( self , arr , n ) : NEW_LINE INDENT maxi , result = 0 , 0 NEW_LINE freq = np . zeros ( 1000001 ) NEW_LINE for x in arr : NEW_LINE INDENT freq [ x ] += 1 NEW_LINE DEDENT maxi = np . max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT for j in range ( i * 2 , maxi , j + i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( min_operations ( arr , n ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def total_ways ( self , N , M , X ) : NEW_LINE INDENT dp = np . zeros ( ( N + 1 , 2 ) ) NEW_LINE if X == 1 : NEW_LINE INDENT dp [ 0 , 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 , 1 ] = 0 NEW_LINE DEDENT if X == 1 : NEW_LINE INDENT dp [ 1 , 0 ] = 0 NEW_LINE dp [ 1 , 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 , 0 ] = 1 NEW_LINE dp [ 1 , 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i , 0 ] = dp [ i - 1 , 1 ] NEW_LINE dp [ i , 1 ] = dp [ i - 1 , 0 ] * ( M - 1 ) + dp [ i - 1 , 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 , 0 ] NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT N , M , X = 4 , 3 , 2 NEW_LINE print ( total_ways ( self , N , M , X ) ) NEW_LINE DEDENT return GFG NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT import sys NEW_LINE import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def get_min_num ( self , a , b , c ) : NEW_LINE INDENT if c < a or c > b : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE c = 4 NEW_LINE g = GFG ( ) NEW_LINE print ( g . get_min_num ( a , b , c ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = self . n NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT return self . n NEW_LINE DEDENT def __init__ ( self , * args ) : NEW_LINE INDENT self . s = args [ 0 ] NEW_LINE x = max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' I ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT x = max ( x , x ) NEW_LINE DEDENT print ( x ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . d , self . p = sys . stdin . read ( ) . split ( ' \n ' ) NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT while True : NEW_LINE INDENT ans = 0 NEW_LINE n , m = self . n , self . m NEW_LINE al = [ ] NEW_LINE if not n and not m : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT al . append ( ( self . d , self . p ) ) NEW_LINE DEDENT al . sort ( ) NEW_LINE while not al . empty ( ) : NEW_LINE INDENT st = al . pop ( 0 ) NEW_LINE m -= st . d NEW_LINE if m <= 0 : NEW_LINE INDENT ans -= m * st . p NEW_LINE break NEW_LINE DEDENT DEDENT while not al . empty ( ) : NEW_LINE INDENT st = al . pop ( 0 ) NEW_LINE ans += st . d * st . p NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT DEDENT class State ( object ) : NEW_LINE INDENT def __init__ ( self , d , p ) : NEW_LINE INDENT self . d , self . p = d , p NEW_LINE DEDENT def __call__ ( self , st ) : NEW_LINE INDENT return st . p - self . p NEW_LINE DEDENT DEDENT return Main ( ) NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( sys . stdin . read ( ) ) NEW_LINE DEDENT front = PriorityQueue ( ) NEW_LINE back = PriorityQueue ( ) NEW_LINE arr = [ ] NEW_LINE front_sum = 0 NEW_LINE back_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = raw_input ( ) NEW_LINE front_sum += x NEW_LINE front . add ( x ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr . append ( raw_input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = raw_input ( ) NEW_LINE back_sum += x NEW_LINE back . add ( - x ) NEW_LINE DEDENT values = [ front_sum , - back_sum ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT front_sum += arr [ i ] NEW_LINE front . add ( arr [ i ] ) NEW_LINE front_sum -= front . poll ( ) NEW_LINE values [ i + 1 ] += front_sum NEW_LINE back_sum += arr [ n - i - 1 ] NEW_LINE back . add ( - arr [ n - i - 1 ] ) NEW_LINE back_sum += back . poll ( ) NEW_LINE values [ n - i - 1 ] -= back_sum NEW_LINE DEDENT max = sum ( values ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max = max ( max , values [ i ] ) NEW_LINE DEDENT print ( max ) NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT arr = [ 1 , 5 , 6 ] NEW_LINE def countWays ( N ) : NEW_LINE INDENT count = [ 1 ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( len ( arr ) ) : NEW_LINE INDENT if i >= arr [ j ] : NEW_LINE INDENT count [ i ] += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT DEDENT return count [ N ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = 7 NEW_LINE print ( " Total ▁ number ▁ of ▁ ways ▁ = ▁ " , countWays ( N ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import factorial NEW_LINE class GFG ( factorial ) : NEW_LINE INDENT def factorial ( self ) : NEW_LINE INDENT if self . factorial == 0 or self . factorial == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorial ( self . factorial - 1 ) + ( self . factorial - 1 ) * factorial ( self . factorial - 2 ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT x = 3 NEW_LINE print ( factorial ( x ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def GFG ( a , n ) : NEW_LINE INDENT hm = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] += 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if hm [ a [ i ] ] != 0 : NEW_LINE INDENT print ( a [ i ] , " - > " , cumul ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = [ 1 , 3 , 2 , 4 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE return sum ( a ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def test_possible_triplet_in_range ( ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . L = 2 NEW_LINE self . R = 10 NEW_LINE self . L = 23 NEW_LINE self . R = 46 NEW_LINE self . numbers_in_range = ( R - L + 1 ) NEW_LINE if self . numbers_in_range < 3 : NEW_LINE INDENT flag = False NEW_LINE DEDENT elif self . numbers_in_range > 3 : NEW_LINE INDENT flag = True NEW_LINE if self . L % 2 : NEW_LINE INDENT self . L += 1 NEW_LINE DEDENT self . possible_a = self . L NEW_LINE self . possible_b = self . L + 1 NEW_LINE self . possible_c = self . L + 2 NEW_LINE DEDENT else : NEW_LINE INDENT if not ( self . L % 2 ) : NEW_LINE INDENT flag = True NEW_LINE self . possible_a = self . L NEW_LINE self . possible_b = self . L + 1 NEW_LINE self . possible_c = self . L + 2 NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT self . possible_a = self . L NEW_LINE self . possible_b = self . L + 1 NEW_LINE self . possible_c = self . L + 2 NEW_LINE DEDENT else : NEW_LINE INDENT if not ( self . L % 2 ) : NEW_LINE INDENT flag = True NEW_LINE self . possible_a = self . L NEW_LINE self . possible_b = self . L + 1 NEW_LINE self . possible_c = self . L + 2 NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT DEDENT def test ( self ) : NEW_LINE INDENT L , R = 2 , 10 NEW_LINE self . L = 23 , 46 NEW_LINE self . possible_a = self . L NEW_LINE self . R = R NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT alphabets = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE def conversion ( charset , str1 ) : NEW_LINE INDENT s2 = " " NEW_LINE for i in str1 : NEW_LINE INDENT s2 += alphabets [ charset . index ( i ) ] NEW_LINE DEDENT return s2 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT charset = ' qwertyuiopasdfghjklzxcvbnm ' NEW_LINE str1 = ' egrt ' NEW_LINE sys . stdout . write ( conversion ( charset , str1 . capitalize ( ) ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import _gen_number NEW_LINE import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , count , a , n , num , k ) : NEW_LINE INDENT if count == k : NEW_LINE INDENT self . count = count NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT gen_number ( self , count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT def print_distinct_integers ( self , k , a , n ) : NEW_LINE INDENT gen_number ( 0 , a , n , 0 , k ) NEW_LINE print ( " The " , " ▁ " . join ( [ str ( i ) for i in self . count ] ) , " distinct ▁ integers ▁ are : ▁ " , end = " " ) NEW_LINE print ( ) NEW_LINE for ( i , j ) in self . count : NEW_LINE INDENT print ( i , j , end = " " ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 3 , 8 , 17 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print_distinct_integers ( self , k , arr , n ) NEW_LINE DEDENT DEDENT
def GFG ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while x > 0 : NEW_LINE INDENT prod *= ( x % 10 ) NEW_LINE x /= 10 NEW_LINE DEDENT def find_number ( l , r ) : NEW_LINE INDENT b = str ( r ) NEW_LINE ans = r NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if b [ i ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT curr = b [ i : i + 1 ] NEW_LINE curr . append ( chr ( ( ord ( curr [ i ] ) - ord ( '0' ) ) + ord ( '0' ) ) ) NEW_LINE for i in range ( i + 1 , len ( curr ) ) : NEW_LINE INDENT curr [ i ] = '9' NEW_LINE DEDENT num = 0 NEW_LINE for i in curr : NEW_LINE INDENT num = num * 10 + ord ( i ) NEW_LINE DEDENT if num >= l and product ( ans ) < product ( num ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT l , r = 1 , 10 NEW_LINE print ( find_number ( l , r ) ) NEW_LINE l , r = 51 , 62 NEW_LINE print ( find_number ( l , r ) ) NEW_LINE DEDENT return find_number ( l , r ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 100005 NEW_LINE isPrime = [ False ] * MAX NEW_LINE def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = True NEW_LINE for i in range ( 2 * i , MAX ) : NEW_LINE INDENT if not isPrime [ i ] : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while num > 0 : NEW_LINE INDENT if not isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr , n ) : NEW_LINE INDENT sieveOfEratostheneses ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if not isPrime [ sum ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minNumber ( arr , n ) ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT MAX = 25 NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count , max_bit , sum , ans = [ 0 ] * MAX , 0 , 0 , 0 NEW_LINE for d in range ( n ) : NEW_LINE INDENT e , f = arr [ d ] , 0 NEW_LINE while e > 0 : NEW_LINE INDENT rem = e % 2 NEW_LINE e = e // 2 NEW_LINE if rem == 1 : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = int ( pow ( 2 , d ) ) NEW_LINE if bits_count [ d ] > n / 2 : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans NEW_LINE sum = sum + arr [ d ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE DEDENT
def _7b ( ) : pass NEW_LINE import readline NEW_LINE import sys NEW_LINE class _70b ( readline ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdin = sys . stdin NEW_LINE self . stdout = sys . stdout NEW_LINE self . solve ( ) NEW_LINE self . n , c , q = self . n , 0 , 0 NEW_LINE s = readline ( ) NEW_LINE for i , l , p in enumerate ( s ) : NEW_LINE INDENT h = ord ( h ) NEW_LINE p += 1 NEW_LINE if h in ( ' . ' , ' ! ' , ' ? ' ) : NEW_LINE INDENT if p > n : NEW_LINE INDENT return ' Impossible ' NEW_LINE DEDENT if q == 0 : NEW_LINE INDENT q = p NEW_LINE DEDENT elif q + 1 + p <= n : NEW_LINE INDENT q += 1 + p NEW_LINE DEDENT else : NEW_LINE INDENT q = p NEW_LINE c += 1 NEW_LINE DEDENT self . p = 0 NEW_LINE self . i += 1 NEW_LINE DEDENT DEDENT if q > 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT with open ( ' _ 70b . txt ' , ' r ' ) as f : NEW_LINE INDENT out = sys . stdout . write NEW_LINE out . write ( solve ( ) ) NEW_LINE out . close ( ) NEW_LINE DEDENT DEDENT def readline ( self ) : NEW_LINE INDENT return sys . stdin . readline ( ) NEW_LINE DEDENT def select ( self , result ) : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT
def import _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , _sys , }
def import _strange_birth_day NEW_LINE class strange_birth_day ( object ) : NEW_LINE INDENT def help_birth_day_boy ( self , n , m ) : NEW_LINE INDENT [ k , m ] = n NEW_LINE ans = 0 NEW_LINE j = 0 NEW_LINE for k in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if k < len ( m ) : NEW_LINE INDENT if m [ k ] > m [ j ] : NEW_LINE INDENT ans += m [ j ] NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += m [ k ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT f = _fastreader ( ) NEW_LINE test = f . read ( ) NEW_LINE while test : NEW_LINE INDENT n , m = f . read ( ) NEW_LINE arr = [ ] NEW_LINE marr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( f . read ( ) - 1 ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT marr . append ( f . read ( ) ) NEW_LINE DEDENT strange = strange_birth_day ( ) NEW_LINE strange . help_birth_day_boy ( arr , marr ) NEW_LINE DEDENT DEDENT class _fastreader ( object ) : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT f . readline ( ) NEW_LINE while not f or not f . readline ( ) : NEW_LINE INDENT try : NEW_LINE INDENT f . readline ( ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return f . readline ( ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return int ( f . readline ( ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return long ( f . readline ( ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return float ( f . readline ( ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return float ( f . readline ( ) ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return next ( self ) NEW_LINE DEDENT DEDENT return _fastreader ( ) NEW_LINE DEDENT return strange_birth_day NEW_LINE DEDENT
def test_find_maximum_num ( arr , n ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_maximum_num ( self , arr , n ) : NEW_LINE INDENT for i in range ( n , 1 , - 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i <= arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count >= i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_maximum_num ( arr , n ) ) NEW_LINE DEDENT
def import import os NEW_LINE from subprocess import Popen , PIPE NEW_LINE from os . environ import env NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import chdir NEW_LINE from subprocess import Popen , PIPE NEW_LINE from os import chdir NEW_LINE from os import environ NEW_LINE from os import chdir NEW_LINE from . utils import get_output NEW_LINE from os import getcwd NEW_LINE from os . environ import env NEW_LINE from os import environ NEW_LINE from os import chdir NEW_LINE from os import getcwd NEW_LINE from os . environ import env NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . walk import walk NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . walk import walk NEW_LINE from os . path import normpath NEW_LINE from os . path import join NEW_LINE from os . walk import walk NEW_LINE from os . path import normpath NEW_LINE from os . path import join NEW_LINE from os . walk import walk NEW_LINE from os . path import join NEW_LINE from os . path import dirname NEW_LINE from os . walk import walk NEW_LINE from os . path import normpath NEW_LINE from os . walk import walk NEW_LINE from os . path import join NEW_LINE from os . path import normpath NEW_LINE from os . walk import walk NEW_LINE from os . path import join NEW_LINE from os . path import dirname NEW_LINE from os . walk import walk NEW_LINE from os . path import normpath NEW_LINE from os . walk import walk NEW_LINE from os . path import join NEW_LINE from os . walk import walk NEW_LINE from os . path import dirname NEW_LINE from os . walk import normpath NEW_LINE from os . walk import walk NEW_LINE from os . walk import normpath NEW_LINE from os . path import join NEW_LINE from os . path import dirname NEW_LINE from os . walk import normpath NEW_LINE from os . walk import normpath NEW_LINE from os . walk import normpath NEW_LINE from os . path import dirname NEW_LINE from os . walk import normpath NEW_LINE from os . walk import dirname NEW_LINE from os . walk import dirname NEW_LINE from os . walk import normpath NEW_LINE from os . walk import dirname NEW_LINE from os . walk import dirname NEW_LINE DEDENT
def GFG ( A , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2000 ) ] for j in range ( n ) ] NEW_LINE flag = 1 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT for i in range ( - sum , sum + 1 ) : NEW_LINE INDENT try : NEW_LINE INDENT dp [ 0 ] [ i ] = int ( i ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , sum ) : NEW_LINE INDENT try : NEW_LINE INDENT dp [ flag ] [ j ] = int ( i ) NEW_LINE if j - A [ i - 1 ] <= sum and j - A [ i - 1 ] >= - sum : NEW_LINE INDENT dp [ flag ] [ j ] = dp [ flag ^ 1 ] [ j - A [ i - 1 ] ] NEW_LINE DEDENT if j + A [ i - 1 ] <= sum and j + A [ i - 1 ] >= - sum and dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] != int ( i ) : NEW_LINE INDENT dp [ flag ] [ j ] = min ( dp [ flag ] [ j ] , dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] + 1 ) NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT flag = flag ^ 1 NEW_LINE DEDENT for i in range ( 0 , sum ) : NEW_LINE INDENT if dp [ flag ^ 1 ] [ i ] != int ( i ) : NEW_LINE INDENT return dp [ flag ^ 1 ] [ i ] NEW_LINE DEDENT DEDENT return n - 1 NEW_LINE DEDENT
def import import _sys , _sys , _atol , _warnings , _warnings , _verbose , _verbose , * args , ** kwargs ) : NEW_LINE INDENT eps = 1e-10 NEW_LINE with _sys . stdout . buffer . as_default ( ) : NEW_LINE INDENT _sys . stdout . buffer . as_default ( ) NEW_LINE x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = _sys . _getframe ( ) . f_code . readline ( ) . split ( ' \n ' ) NEW_LINE vax , vay = x2 - x1 , y2 - y1 NEW_LINE vbx , vby = x4 - x3 , y4 - y3 NEW_LINE if abs ( vax * vbx + vay * vby ) < eps : NEW_LINE INDENT _sys . stdout . write ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT _sys . stdout . write ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from calibre . utils . input import input NEW_LINE from calibre . gui2 . tweak_book . utils import get_user NEW_LINE from calibre . gui2 . tweak_book . utils import get_user NEW_LINE from calibre . gui2 . tweak_book . utils import get_user NEW_LINE from calibre . gui2 . tweak_book . utils import get_user NEW_LINE from calibre . gui2 . tweak_book . utils import get_user NEW_LINE from calibre . gui2 . tweak_book . utils import get_user NEW_LINE from calibre . gui2 . tweak_book . utils import get_user NEW_LINE class AOJ0221 ( AOJ0221 ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . person = [ False ] NEW_LINE self . user = None NEW_LINE self . cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT input = input ( ) NEW_LINE talk = get_user ( i ) NEW_LINE if input == talk == False and self . m - self . cnt > 1 : NEW_LINE INDENT self . person [ user ] = True NEW_LINE self . cnt += 1 NEW_LINE DEDENT self . user = get_user ( self . user ) NEW_LINE DEDENT i = 0 NEW_LINE for i in range ( self . m ) : NEW_LINE INDENT if self . person [ i ] == False : NEW_LINE INDENT print ( i + 1 , end = ' ▁ ' ) NEW_LINE break NEW_LINE DEDENT for i in range ( self . user + 1 , self . m ) : NEW_LINE INDENT if self . person [ i ] == False : NEW_LINE INDENT print ( ' ▁ ' , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT def get_talk ( num ) : NEW_LINE INDENT return num % 15 or ' FizzBuzz ' NEW_LINE DEDENT def get_user ( self ) : NEW_LINE INDENT for i in range ( 1 , self . m + 1 ) : NEW_LINE INDENT if not self . person [ ( self . user + i ) % m ] : NEW_LINE INDENT return ( self . user + i ) % m NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT l = [ [ 0 for i in range ( 1 , 1001 ) ] for i in range ( 1 , 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE from itertools import chain NEW_LINE from itertools import chain NEW_LINE a , b , c , d = map ( int , repeat ( a , b ) ) NEW_LINE x = chain ( [ a , b , c , d ] , repeat ( a , b ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 101 ) : NEW_LINE INDENT if x [ i ] == 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def calculate ( self , a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if b [ i ] != 0 : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = int ( math . floor ( a [ i ] / mul ) ) NEW_LINE print ( x , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n , m = len ( a ) , len ( b ) NEW_LINE return GFG ( a , b , n , m ) NEW_LINE DEDENT DEDENT
def quick_sort ( a , d , c ) : NEW_LINE INDENT import random NEW_LINE class problemB ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = a NEW_LINE self . d = d NEW_LINE self . c = c NEW_LINE self . mid = a [ ( self . d + self . c ) // 2 ] NEW_LINE while self . i <= self . j : NEW_LINE INDENT while self . a [ self . i ] < self . mid : NEW_LINE INDENT self . i += 1 NEW_LINE DEDENT while self . a [ self . j ] > self . mid : NEW_LINE INDENT self . j -= 1 NEW_LINE DEDENT if self . i <= self . j : NEW_LINE INDENT tg = self . a [ self . i ] NEW_LINE self . a [ self . i ] = self . a [ self . j ] NEW_LINE self . a [ self . j ] = tg NEW_LINE self . i += 1 NEW_LINE self . j -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if self . d < self . j : NEW_LINE INDENT quick_sort ( a , d , self . j ) NEW_LINE DEDENT if self . i < self . c : NEW_LINE INDENT quick_sort ( a , i , self . c ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sc = random . choice ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 24 , 25 , 26 , 26 , 27 , 28 , 28 , 29 , 30 , 31 , 32 , 33 , 33 , 34 , 35 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36 , 36
def import import sys , string , traceback ; NEW_LINE class TEST ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . T = sys . stdin . read ( ) NEW_LINE DEDENT def test ( self ) : NEW_LINE INDENT self . T = sys . stdin . read ( ) NEW_LINE while True : NEW_LINE INDENT self . T -= 1 NEW_LINE n , c = self . T , self . T NEW_LINE del c [ n - 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if c [ i ] == ' > ' or c [ n - 1 - i ] == ' < ' : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def codforce ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import sys NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import sys NEW_LINE class Codforce ( string ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . string = string NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return string NEW_LINE DEDENT DEDENT return Codforce NEW_LINE DEDENT
def import import sys NEW_LINE class B148 ( object ) : NEW_LINE INDENT def __init__ ( self , name , value ) : NEW_LINE INDENT self . name = name NEW_LINE self . value = value NEW_LINE self . VP = self . value NEW_LINE self . VD = self . value NEW_LINE self . T = self . value NEW_LINE self . F = self . value NEW_LINE self . C = self . value NEW_LINE if self . VD <= self . VP : NEW_LINE INDENT print ( '0' ) NEW_LINE return NEW_LINE DEDENT DEDENT def answer ( self ) : NEW_LINE INDENT self . start = self . T NEW_LINE while True : NEW_LINE INDENT x = self . start * self . VP / ( self . VD - self . VP ) NEW_LINE if ( self . start + x ) * self . VP >= self . C : NEW_LINE INDENT break NEW_LINE DEDENT self . start += 2 * x + self . F NEW_LINE self . answer += 1 NEW_LINE DEDENT print ( self . answer ) NEW_LINE DEDENT DEDENT
def import time NEW_LINE import sys NEW_LINE import time NEW_LINE import time NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT with open ( sys . argv [ 1 ] ) as sc : NEW_LINE INDENT s , t = sc . read ( ) . split ( ' : ' ) NEW_LINE x = time . localtime ( int ( s [ 0 ] ) , int ( s [ 1 ] ) ) NEW_LINE y = time . localtime ( int ( t [ 0 ] ) , int ( t [ 1 ] ) ) NEW_LINE print ( x - y . tm_hour , y . tm_min ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( a , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] * a [ i - 1 ] < 0 : NEW_LINE INDENT cnt += 1 NEW_LINE longest = max ( longest , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT return longest NEW_LINE DEDENT
def check_type_of_triangle ( a , b , c ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = a NEW_LINE self . b = b NEW_LINE self . c = c NEW_LINE self . sqa = int ( math . pow ( a , 2 ) ) NEW_LINE self . sqb = int ( math . pow ( b , 2 ) ) NEW_LINE self . sqc = int ( math . pow ( c , 2 ) ) NEW_LINE if self . sqa == self . sqa + self . sqb or self . sqb == self . sqa + self . sqc or self . sqc == self . sqa + self . sqb : NEW_LINE INDENT print ( " Right - angled ▁ Triangle " , end = " " ) NEW_LINE DEDENT elif self . sqa > self . sqc + self . sqb or self . sqb > self . sqa + self . sqc or self . sqc > self . sqa + self . sqb : NEW_LINE INDENT print ( " Obtuse - angled ▁ Triangle " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Acute - angled ▁ Triangle " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT a , b , c = 2 , 2 , 2 NEW_LINE self . a = a NEW_LINE self . b = b NEW_LINE self . c = c NEW_LINE return GFG ( self ) NEW_LINE DEDENT DEDENT
def countSubsequence ( s , n ) : NEW_LINE INDENT class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , s , n ) : NEW_LINE INDENT self . max = 100 NEW_LINE DEDENT def countSubsequence ( self , s ) : NEW_LINE INDENT cntG , cntF , result , C = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' G ' : NEW_LINE INDENT self . cntG += 1 NEW_LINE result += C NEW_LINE DEDENT elif s [ i ] == ' F ' : NEW_LINE INDENT self . cntF += 1 NEW_LINE C += self . cntG NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT s = ' GFGFG ' NEW_LINE n = len ( s ) NEW_LINE countSubsequence ( s , n ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from itertools import count , repeat NEW_LINE from random import randint NEW_LINE from itertools import count NEW_LINE MAX = 100 NEW_LINE try : NEW_LINE INDENT with open ( ' . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . . / . . / . / . . / . / . . / . / . . / . / . . / . / . / . . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / ) as
def GFG ( ) : NEW_LINE INDENT steps = 0 NEW_LINE while n > 0 : NEW_LINE INDENT largest = int ( math . cbrt ( n ) ) NEW_LINE n -= ( largest ** 2 ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT
def import import sys NEW_LINE import time NEW_LINE class Main ( object ) : NEW_LINE INDENT class AOJ_0138 ( object ) : NEW_LINE INDENT def __init__ ( self , num , time ) : NEW_LINE INDENT self . num = num NEW_LINE self . time = time NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT self . time = time NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT self . num = other . num NEW_LINE self . time = other . time NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT self . num = other . num NEW_LINE self . time = other . time NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT self . num = other . num NEW_LINE self . time = other . time NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT self . num = other . num NEW_LINE self . time = other . time NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT self . num = other . num NEW_LINE self . time = other . time NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT self . num = other . num NEW_LINE self . time = other . time NEW_LINE DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT return other . num == other . num NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT return other . time == other . time NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT return other . num == other . num NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT return other . time == other . time NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT return other . num == other . num NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT return other . time == other . time NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT return other . num == other . num NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT return other . time == other . time NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT return other . num == other . num NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT return other . time == other . time NEW_LINE DEDENT DEDENT return Main ( ) NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT import sys NEW_LINE from numpy . core import amax NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import amax NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import amax NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import amax NEW_LINE n = len ( args ) NEW_LINE arr = zeros ( n ) NEW_LINE mx , mn , mxcount , mncount = amax ( arr ) , amax ( arr ) , amax ( arr ) , amax ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == mx : NEW_LINE INDENT mxcount += 1 NEW_LINE DEDENT if arr [ i ] == mn : NEW_LINE INDENT mncount += 1 NEW_LINE DEDENT DEDENT if mx != mn : NEW_LINE INDENT print ( mx - mn , mxcount * mncount ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( mx - mn , mxcount * ( mxcount - 1 ) / 2 ) NEW_LINE DEDENT DEDENT
def GFG ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = sum ( i ) NEW_LINE if i % x == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from sympy . utilities . iterables import iterables NEW_LINE from sympy . printing . latex import latex NEW_LINE from sympy . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . latex import latex NEW_LINE from sympy . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE from sympy . core . printing . debugoptions import printinfo NEW_LINE printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( printinfo ( ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) } NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def maxProd ( self , N ) : NEW_LINE INDENT if not N : NEW_LINE INDENT return 1 NEW_LINE DEDENT if N < 10 : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT N = 390 NEW_LINE print ( maxProd ( N ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def import _sys , input_sugoroku NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( self . n ) NEW_LINE self . sugoroku = " " NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . input_sugoroku = input_sugoroku NEW_LINE self . solve_sugoroku ( ) NEW_LINE DEDENT def solve_sugoroku ( self ) : NEW_LINE INDENT dice = 0 NEW_LINE safes = self . sugoroku . split ( '0' ) NEW_LINE for i in safes : NEW_LINE INDENT dice = max ( dice , len ( i ) ) NEW_LINE DEDENT print ( dice + 1 ) NEW_LINE DEDENT def input_sugoroku ( self ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT s . append ( self . sugoroku ) NEW_LINE DEDENT self . sugoroku = s NEW_LINE DEDENT DEDENT
def practice2 ( ) : NEW_LINE INDENT import math NEW_LINE from numpy import sqrt NEW_LINE from numpy import zeros NEW_LINE from numpy import sqrt NEW_LINE from numpy import sin NEW_LINE from numpy import cos NEW_LINE from numpy import sin NEW_LINE from numpy import cos NEW_LINE from numpy import sin NEW_LINE from numpy import cos NEW_LINE from numpy import sin NEW_LINE from numpy import cos NEW_LINE from numpy import sin NEW_LINE from numpy import sin NEW_LINE from numpy import cos NEW_LINE from numpy import sin NEW_LINE from numpy import sin NEW_LINE t = sys . maxsize NEW_LINE while t : NEW_LINE INDENT n = sys . maxsize NEW_LINE x = [ ] NEW_LINE y = [ ] NEW_LINE t1 , t2 = 0 , 0 NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT x1 , y1 = sin ( x [ i ] ) , sin ( y [ i ] ) NEW_LINE if x1 == 0 : NEW_LINE INDENT y . append ( y1 * sin ( y1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT x . append ( x1 * sin ( x1 ) ) NEW_LINE DEDENT DEDENT x . sort ( ) NEW_LINE y . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum += sqrt ( x [ i ] + y [ i ] ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count /= i NEW_LINE DEDENT return count NEW_LINE DEDENT
def import __reduce_string NEW_LINE import re NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , s , l ) : NEW_LINE INDENT count , steps = 1 , 0 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT steps += ( count / 2 ) NEW_LINE count = 1 NEW_LINE DEDENT DEDENT steps += count / 2 NEW_LINE return steps NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE l = len ( s ) NEW_LINE print ( __reduce_string ( s , l ) ) NEW_LINE DEDENT DEDENT
def import _sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . read = _sys . stdin NEW_LINE self . a , self . b , self . n = self . read ( ) NEW_LINE if self . b >= self . a : NEW_LINE INDENT print ( " Impossible " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = " " NEW_LINE honest = self . _honest ( ) NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT ans += '1' if self . q ( honest , i ) else '0' NEW_LINE DEDENT print ( " ! ▁ " + ans , end = " " ) NEW_LINE DEDENT DEDENT def _honest ( self ) : NEW_LINE INDENT dis = self . b + 1 NEW_LINE lst = list ( self . n ) NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT if lst == [ ] : NEW_LINE INDENT lst . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT if self . q ( lst [ - 1 ] , i ) : NEW_LINE INDENT lst . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT lst . pop ( ) NEW_LINE dis -= 1 NEW_LINE DEDENT DEDENT if len ( lst ) >= dis : NEW_LINE INDENT return lst . pop ( ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def q ( self , a , b ) : NEW_LINE INDENT print ( " ? ▁ " + str ( a ) + " ▁ " + str ( b ) ) NEW_LINE return self . read ( ) == " Y " NEW_LINE DEDENT DEDENT return Main NEW_LINE DEDENT
def import import sys , StringIO , traceback NEW_LINE from time import sleep NEW_LINE from time import sleep NEW_LINE from sys import stdin , stdout , stderr NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from random import random NEW_LINE from sys import random NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import exists NEW_LINE from os . path import exists NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . isfile NEW_LINE from os . path import isfile NEW_LINE from os . remove import isfile NEW_LINE from os . rmdir import isfile NEW_LINE from os . rmdir import isfile NEW_LINE from os . rmdir import isfile NEW_LINE from os . rmdir import isfile NEW_LINE from os . rmdir import dirname NEW_LINE from os . rmdir NEW_LINE from os . rmdir import islink NEW_LINE from os . _stat import isfile NEW_LINE from os . _stat import isfile NEW_LINE from os . _stat import isfile NEW_LINE DEDENT
def GFG ( ) : mod = 1000000007L NEW_LINE def mult ( a , b ) : return ( ( a % mod ) * ( b % mod ) ) % mod NEW_LINE def calculate_factors ( n ) : NEW_LINE INDENT ans , cnt = 1 , 0 NEW_LINE ans = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n = n / 2 NEW_LINE DEDENT if cnt % 2 == 1 : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT for i in range ( 3 , math . sqrt ( n ) + 1 , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n = n / i NEW_LINE DEDENT if cnt % 2 == 1 : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT ans = mult ( ans , ( 2 ) ) NEW_LINE DEDENT return ans % mod NEW_LINE DEDENT
def import _cf32A NEW_LINE class CF32A ( _cf32A ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = _cf32A NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " < a ▁ class = \ " % s\ " > " % ( self . input ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT min_ele = arr [ 0 ] NEW_LINE max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT min_ele = min ( min_ele , arr [ i ] ) NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT return ( max_ele - min_ele ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a , self . b , self . c , self . N = sys . stdin . read ( ) . split ( ' \n ' ) NEW_LINE DEDENT DEDENT sc = sys . stdin . read ( ) NEW_LINE while True : NEW_LINE INDENT a = sc . readline ( ) . strip ( ) NEW_LINE b = sc . readline ( ) . strip ( ) NEW_LINE c = sc . readline ( ) . strip ( ) NEW_LINE if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT sys . exit ( 0 ) NEW_LINE DEDENT N = sc . readline ( ) . strip ( ) NEW_LINE checking = [ 0 ] * a + b + c NEW_LINE temp = list ( ) NEW_LINE checking . append ( 0 ) NEW_LINE for j in range ( 2 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT a1 , b1 , c1 , check = sc . readline ( ) . strip ( ) . split ( ' ▁ ' ) NEW_LINE a1 , b1 , c1 , check = sc . readline ( ) . strip ( ) . split ( ' ▁ ' ) NEW_LINE if check == 1 : NEW_LINE INDENT checking [ a1 - 1 ] = 1 NEW_LINE checking [ b1 - 1 ] = 1 NEW_LINE checking [ c1 - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp . append ( a1 ) NEW_LINE temp . append ( b1 ) NEW_LINE temp . append ( c1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if not temp : NEW_LINE INDENT break NEW_LINE DEDENT a2 , b2 , c2 = temp . pop ( ) NEW_LINE if checking [ a2 - 1 ] + checking [ b2 - 1 ] + checking [ c2 - 1 ] == 2 : NEW_LINE INDENT if checking [ a2 - 1 ] != 1 : NEW_LINE INDENT checking [ a2 - 1 ] = 3 NEW_LINE DEDENT elif checking [ b2 - 1 ] != 1 : NEW_LINE INDENT checking [ b2 - 1 ] = 3 NEW_LINE DEDENT else : NEW_LINE INDENT checking [ c2 - 1 ] = 3 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for contents in checking : NEW_LINE INDENT if contents == 3 : NEW_LINE INDENT result = 0 NEW_LINE DEDENT elif contents == 0 : NEW_LINE INDENT result = 2 NEW_LINE DEDENT else : NEW_LINE INDENT result = 1 NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT DEDENT DEDENT
def test_gf_remove ( ) : NEW_LINE INDENT import os NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , a , b , n , m ) : NEW_LINE INDENT count_a = { } NEW_LINE count_b = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in count_a : NEW_LINE INDENT count_a [ a [ i ] ] = count_a [ a [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_a [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if b [ i ] in count_b : NEW_LINE INDENT count_b [ b [ i ] ] = count_b [ b [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_b [ b [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT res = 0 NEW_LINE s = count_a . keys ( ) NEW_LINE for x in s : NEW_LINE INDENT if x in count_b : NEW_LINE INDENT res += min ( count_b [ x ] , count_a [ x ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import sin , cos , exp NEW_LINE from math import sin , cos , log NEW_LINE from math import log NEW_LINE from math import pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import cos , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi NEW_LINE from math import sin , pi , pi , pi , pi , pi NEW_LINE L , R = 2 , 60 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE L , R = 1 , 1000 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE DEDENT
def python_application125 ( ) : NEW_LINE INDENT from sympy . core . compatibility import PythonRational NEW_LINE from sympy . core . compatibility import PythonRational NEW_LINE from sympy . core . compatibility import PythonPythonPython3 NEW_LINE num = PythonRational ( 1 , 3 ) NEW_LINE old = - 1 NEW_LINE ans = 0 NEW_LINE for i in range ( num ) : NEW_LINE INDENT s = PythonRational ( i , 3 ) NEW_LINE if s == 1 : NEW_LINE INDENT if old >= 0 : NEW_LINE INDENT ans *= ( i - old ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT old = i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import sqrt NEW_LINE class GFG ( int ) : NEW_LINE INDENT def bit ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while x > 0 : NEW_LINE INDENT x /= 2 NEW_LINE ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def check ( d , x ) : NEW_LINE INDENT if bit ( x / d ) <= bit ( d ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def bs ( n ) : NEW_LINE INDENT l , r = 1 , int ( sqrt ( n ) ) NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) / 2 NEW_LINE if check ( m , n ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if not check ( l , n ) : NEW_LINE INDENT return l + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return l NEW_LINE DEDENT DEDENT def count_divisor ( n ) : NEW_LINE INDENT return n - bs ( n ) + 1 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 5 NEW_LINE print ( count_divisor ( n ) ) NEW_LINE DEDENT DEDENT
def minimalSteps ( s , n ) : NEW_LINE INDENT import math NEW_LINE dp = [ int ( math . floor ( math . log ( s , 2 ) ) ) for i in range ( n ) ] NEW_LINE s1 , s2 = " " , " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 ] NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if s1 == s2 : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def check_util ( num , dig , base ) : NEW_LINE INDENT if dig == 1 and num < base : NEW_LINE INDENT return True NEW_LINE DEDENT if dig > 1 and num >= base : NEW_LINE INDENT return check_util ( num // base , dig -= 1 , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in [ 2 , 32 ] : NEW_LINE INDENT if check_util ( num , dig , base ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT num = 8 NEW_LINE dig = 3 NEW_LINE if check ( num , dig ) : NEW_LINE INDENT sys . stdout . write ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( " No " ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while i <= j : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while i <= j : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if n == 0 : return NEW_LINE if n == 1 : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT tmpArr = [ ] NEW_LINE tmpArr . append ( getMax ( arr , 1 , n - 1 ) ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT tmpArr . append ( abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) ) NEW_LINE DEDENT tmpArr . append ( getMin ( arr , 0 , n - 2 ) ) NEW_LINE printArray ( tmpArr , n ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n = sc . readline ( ) . strip ( ) NEW_LINE a = [ sc . readline ( ) . strip ( ) for i in range ( n ) ] NEW_LINE s = sc . readline ( ) . strip ( ) NEW_LINE sum = 0 NEW_LINE for ch in s : NEW_LINE INDENT if ch == ' B ' : NEW_LINE INDENT sum += a [ ch ] NEW_LINE DEDENT DEDENT ans = sum NEW_LINE sum1 = sum NEW_LINE for ch in s : NEW_LINE INDENT if ch == ' A ' : NEW_LINE INDENT sum1 += a [ ch ] NEW_LINE DEDENT else : NEW_LINE INDENT sum1 -= a [ ch ] NEW_LINE DEDENT ans = max ( ans , sum1 ) NEW_LINE DEDENT sum1 = sum NEW_LINE for ch in s [ : - 1 ] : NEW_LINE INDENT if ch == ' A ' : NEW_LINE INDENT sum1 += a [ ch ] NEW_LINE DEDENT else : NEW_LINE INDENT sum1 -= a [ ch ] NEW_LINE DEDENT ans = max ( ans , sum1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from math import sin , cos , tan , fabs NEW_LINE from math import pi , pi , pi , pi NEW_LINE from os . path import join NEW_LINE from os import path NEW_LINE n = pi ( ) NEW_LINE while n : NEW_LINE INDENT xa , ya , xb , yb , xc , yc , xd , yd = select ( [ ' x1' , ' y1' , ' y2' , ' xc ' , ' yc ' , ' xd ' , ' yd ' ] , [ pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi ( ) , pi
def GFG ( n , a , b ) : NEW_LINE INDENT if n == 0 : return a NEW_LINE if n == 1 : return b NEW_LINE if n == 2 : return ( a ^ b ) NEW_LINE return nth_xor_fib ( n % 3 , a , b ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from os import urandom NEW_LINE n = urandom ( 16 ) NEW_LINE card1 , card2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT card1 = urandom ( n ) NEW_LINE card2 = urandom ( n ) NEW_LINE if card1 >= card2 : NEW_LINE INDENT player1 += 3 NEW_LINE DEDENT elif card1 <= card2 : NEW_LINE INDENT player2 += 3 NEW_LINE DEDENT elif card1 == card2 : NEW_LINE INDENT player1 += 1 NEW_LINE player2 += 1 NEW_LINE DEDENT DEDENT print ( player1 , player2 ) NEW_LINE DEDENT
def __area ( a ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . Area ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT if a < 0 : return - 1 NEW_LINE h = float ( 1.268 * a ) NEW_LINE A = float ( 0.70477 * math . pow ( h , 2 ) ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def p073 ( ) : print ( eval ( " p073" ) ) NEW_LINE def test_func ( ) : NEW_LINE INDENT return str ( stern_brocot_count ( 1 , 3 , 1 , 2 ) ) NEW_LINE DEDENT def test_func ( left_n , left_d , right_n , right_d ) : NEW_LINE INDENT n = left_n + right_n NEW_LINE d = left_d + right_d NEW_LINE if d > 12000 : return 0 NEW_LINE else : return 1 + stern_brocot_count ( left_n , left_d , n , d ) + stern_brocot_count ( n , d , right_n , right_d ) NEW_LINE DEDENT
def import _filling_Shapes NEW_LINE import os NEW_LINE import sys NEW_LINE class Filling_Shapes ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = _filling_Shapes NEW_LINE self . _filling_Shapes = sc NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = sc . __next__ ( ) NEW_LINE self . _filling_Shapes . append ( 0 if ( n % 2 ) == 1 else int ( pow ( 2 , n / 2 ) ) ) NEW_LINE DEDENT def find ( self , n ) : NEW_LINE INDENT arr = [ 0 ] * ( 60 + 1 ) NEW_LINE arr [ 1 ] = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 2 ] * 2 NEW_LINE DEDENT return arr [ n ] NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p * n + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT if d == 1 : NEW_LINE INDENT maxVal = int ( math . pow ( 10 , d ) ) - 1 NEW_LINE prime = [ True ] * ( maxVal + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prime [ d ] = False NEW_LINE DEDENT return prime NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT d = 3 NEW_LINE print ( sumPrime ( d ) ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT from math import pow NEW_LINE from math import sqrt NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math NEW_LINE DEDENT
def import import sys , StringIO , pickle , pdb , sys , sys , stdin , stdout , stderr , ** kwargs ) : NEW_LINE INDENT from io import BytesIO NEW_LINE from random import randint NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import izip , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import repeat as repeat NEW_LINE from itertools import chain , repeat as repeat NEW_LINE from itertools import chain , repeat as repeat NEW_LINE from itertools import chain , repeat as repeat NEW_LINE from itertools import chain , repeat as repeat NEW_LINE from itertools import chain , repeat as repeat NEW_LINE from itertools import repeat as repeat NEW_LINE from itertools import repeat as repeat NEW_LINE from itertools import repeat as repeat NEW_LINE from itertools import repeat as repeat NEW_LINE from itertools import repeat as repeat NEW_LINE from itertools import repeat as repeat NEW_LINE from itertools import repeat as repeat as repeat NEW_LINE from from itertools import repeat as repeat as repeat NEW_LINE from from itertools import repeat as repeat as repeat NEW_LINE from from itertools import repeat as repeat as repeat NEW_LINE from from itertools import repeat as repeat as repeat NEW_LINE from from itertools import repeat as repeat NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from datetime import date , timedelta , timedelta NEW_LINE age_difference ( ) NEW_LINE DEDENT
def gf_gf_max_partitions ( arr , n ) : NEW_LINE INDENT import os NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . ans , max_so_far = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if max_so_far == i : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return GFG ( arr , n ) NEW_LINE DEDENT
def count_max_contiguous ( arr , n ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . current_max , self . max_so_far = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if self . arr [ i ] % 2 : NEW_LINE INDENT current_max = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current_max += 1 NEW_LINE self . max_so_far = max ( current_max , self . max_so_far ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return GFG ( arr , n ) NEW_LINE DEDENT
def _cube ( h , r ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def cube ( self , h , r ) : NEW_LINE INDENT if h < 0 and r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( h * r * float ( math . sqrt ( 2 ) ) ) / ( h + float ( math . sqrt ( 2 ) ) * r ) NEW_LINE return a NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT h , r = 5 , 6 NEW_LINE print ( cube ( h , r ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def pattern ( self , rows_no ) : NEW_LINE INDENT for i in range ( 1 , rows_no + 1 ) : NEW_LINE INDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT for i in range ( rows_no - 1 , 1 , - 1 ) : NEW_LINE INDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT class GFG ( object ) : NEW_LINE INDENT def pattern ( self , rows_no ) : NEW_LINE INDENT return 7 NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . stdin . read ( ) NEW_LINE DEDENT def __call__ ( self ) : NEW_LINE INDENT for i in range ( 1 , len ( self . n ) ) : NEW_LINE INDENT if self . n [ i ] != '0' : NEW_LINE INDENT sum = 0 NEW_LINE for j in self . n [ i ] : NEW_LINE INDENT sum += j - '0' NEW_LINE DEDENT print ( sum ) NEW_LINE return NEW_LINE DEDENT DEDENT if self . n [ 0 ] == '1' : NEW_LINE INDENT print ( 10 ) NEW_LINE return NEW_LINE DEDENT print ( self . n [ 0 ] ) NEW_LINE DEDENT DEDENT
def Geeks ( n ) : NEW_LINE INDENT while n > 0 : NEW_LINE INDENT if ( n % 10 ) % 2 == 0 : return 0 NEW_LINE n /= 10 NEW_LINE DEDENT return 1 NEW_LINE def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if check_digits ( i ) > 0 : return i NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT if ( n % 10 ) % 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return 1 NEW_LINE def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if check_digits ( i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def test_triangular_series ( ) : NEW_LINE INDENT import sympy NEW_LINE class GFG ( sympy . MatrixBase ) : NEW_LINE INDENT def triangular_series ( self , n ) : NEW_LINE INDENT i , j , k = 1 , 1 , 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " % d ▁ " % k , end = ' ▁ ' ) NEW_LINE j , k = j + 1 , k + j NEW_LINE DEDENT return GFG ( n ) NEW_LINE DEDENT DEDENT sympy . MatrixBase . triangular_series ( GFG ( 0 ) ) NEW_LINE DEDENT
def import os , sys , stdin , stdout , stderr , line , number_of_ways , count , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , sum_natual , None
def GFG ( k , n ) : NEW_LINE INDENT f1 , f2 , f3 = 0 , 1 , 2 NEW_LINE i = 2 NEW_LINE while i != 0 : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 , f2 = f2 , f3 NEW_LINE if f2 % k == 0 : NEW_LINE INDENT return n ** i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def import sys , string , traceback NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = string NEW_LINE self . s = string NEW_LINE self . n = 0 NEW_LINE self . c = 0 NEW_LINE self . s = string . ascii_lowercase NEW_LINE self . e = [ False ] * 26 NEW_LINE for c in s : NEW_LINE INDENT if self . e [ ord ( c ) - 97 ] == False : NEW_LINE INDENT n += 1 NEW_LINE DEDENT self . e [ ord ( c ) - 97 ] = True NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT c = 0 NEW_LINE DEDENT else : NEW_LINE INDENT c = len ( s ) - 2 NEW_LINE if s [ 0 ] == s [ - 1 ] : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT DEDENT if c % 2 == 0 : NEW_LINE INDENT ans = " Second " NEW_LINE DEDENT else : NEW_LINE INDENT ans = " First " NEW_LINE DEDENT print ( ans ) NEW_LINE self . s = string . ascii_lowercase NEW_LINE DEDENT DEDENT
def __countMinimumMoves ( arr , n , k ) : NEW_LINE INDENT from math import floor NEW_LINE for i in range ( k - 1 , n ) : NEW_LINE INDENT if arr [ i ] != arr [ k - 1 ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] != arr [ k - 1 ] : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def import _powergcd NEW_LINE class Solution : NEW_LINE INDENT def power ( self , x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y & 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : return b NEW_LINE return gcd ( b % a , a ) NEW_LINE DEDENT def powergcd ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , b ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT a , b , n = 5 , 4 , 2 NEW_LINE print ( powergcd ( a , b , n ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def import import input_reader , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream , input_stream ,
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . maxint NEW_LINE self . s = n - 2 NEW_LINE DEDENT DEDENT
def count_identical_rows ( mat ) : NEW_LINE INDENT import sys NEW_LINE count = 0 NEW_LINE for i in mat : NEW_LINE INDENT hs = set ( [ i for j in range ( len ( i ) ) if j in hs ] ) NEW_LINE if len ( hs ) == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def import _pylab NEW_LINE class GFG ( object ) : NEW_LINE INDENT def createSorted ( self , a , n ) : NEW_LINE INDENT b = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if not b : NEW_LINE INDENT b . append ( a [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT start , end = 0 , len ( b ) - 1 NEW_LINE pos = 0 NEW_LINE while start <= end : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE if b [ mid ] == a [ j ] : NEW_LINE INDENT b . append ( ( max ( 0 , mid + 1 ) , a [ j ] ) ) NEW_LINE break NEW_LINE DEDENT elif b [ mid ] > a [ j ] : NEW_LINE INDENT pos = end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = start = mid + 1 NEW_LINE DEDENT if start > end : NEW_LINE INDENT pos = start NEW_LINE b . append ( ( max ( 0 , pos ) , a [ j ] ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = i ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT a = [ 2 , 5 , 4 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE createSorted ( a , n ) NEW_LINE DEDENT DEDENT
def count_total_distinct ( x ) : NEW_LINE INDENT from collections import Set NEW_LINE cnt = 0 NEW_LINE items = Set ( ) NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT temp = ' ' NEW_LINE ans = Set ( ) NEW_LINE for j in range ( i , len ( x ) ) : NEW_LINE INDENT temp = temp + x [ j ] NEW_LINE ans . add ( x [ j ] ) NEW_LINE if temp not in items : NEW_LINE INDENT items . add ( temp ) NEW_LINE cnt += len ( ans ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import log10 NEW_LINE class GFG ( object ) : NEW_LINE INDENT def firstDigit ( self , n ) : NEW_LINE INDENT digits = int ( log10 ( n ) ) NEW_LINE n = int ( n / int ( pow ( 10 , digits ) ) ) NEW_LINE return n NEW_LINE DEDENT def lastDigit ( self , n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT n = 98562 NEW_LINE print ( firstDigit ( n ) , lastDigit ( n ) ) NEW_LINE DEDENT DEDENT
def remove_zeros ( a , n ) : NEW_LINE INDENT import sys NEW_LINE class solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def __getitem__ ( self , i ) : NEW_LINE INDENT if self . n != i : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT def __setitem__ ( self , i , j ) : NEW_LINE INDENT if self . n == j : NEW_LINE INDENT self . n = j NEW_LINE DEDENT else : NEW_LINE INDENT self . n = i NEW_LINE DEDENT DEDENT def __len__ ( self ) : NEW_LINE INDENT return len ( self . n ) NEW_LINE DEDENT DEDENT if ind == - 1 : NEW_LINE INDENT print ( " Array ▁ has ▁ leading ▁ zeros ▁ only " , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT b . append ( a [ ind + i ] ) NEW_LINE DEDENT for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def find_maxm ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for x , freq in mp . items ( ) : NEW_LINE INDENT if x == freq : NEW_LINE INDENT ans = max ( ans , x ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def import import struct NEW_LINE from os . path import isfile , join NEW_LINE from os import urandom NEW_LINE from io import BytesIO NEW_LINE from os . path import expanduser NEW_LINE from os . path import expanduser NEW_LINE from os . environ import dict NEW_LINE from os . environ import environ NEW_LINE from os . environ import environ NEW_LINE from os . path import expanduser NEW_LINE from os . environ import environ NEW_LINE from os . environ import environ NEW_LINE from os . environ import environ NEW_LINE from os . path import expanduser NEW_LINE from os . environ import environ NEW_LINE from os . environ import dict NEW_LINE from os . environ import environ NEW_LINE from os . path import expanduser NEW_LINE from os . environ import environ NEW_LINE from os . path import join NEW_LINE from os import urandom NEW_LINE from time import time NEW_LINE from time import sleep NEW_LINE from os . path import join , getcwd NEW_LINE from os . environ import dict NEW_LINE from os . environ import environ NEW_LINE from os . path import expanduser NEW_LINE from os . environ import dict NEW_LINE from os . environ import environ NEW_LINE from os . path import join NEW_LINE from os import path NEW_LINE from os import urandom NEW_LINE from time import sleep NEW_LINE from os . path import join NEW_LINE from os import path NEW_LINE from os import getcwd NEW_LINE from os import path NEW_LINE from os import getcwd NEW_LINE from os import chdir NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os . environ import expanduser NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os . environ import dict NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os . environ import expanduser NEW_LINE from os . path import join NEW_LINE from os . environ import expanduser NEW_LINE from os . path import join NEW_LINE from os . environ import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . environ import expanduser NEW_LINE from os . path import join NEW_LINE from os . environ import expanduser NEW_LINE from os . path import join NEW_LINE from os . environ import expanduser NEW_LINE from os . path import join NEW_LINE from os . environ import join NEW_LINE from os . path import join NEW_LINE from os . environ import expanduser NEW_LINE from os . environ import join NEW_LINE from os . path import join NEW_LINE from os . environ import join NEW_LINE from os . path import join NEW_LINE from os . environ import join NEW_LINE from os . chdir import chdir NEW_LINE try : NEW_LINE INDENT chdir ( join ( dirname ( abspath ) , expanduser ( expanduser ( ' ~ ' ) ) ) ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT import sys NEW_LINE import math NEW_LINE import io NEW_LINE class GFG ( object ) : NEW_LINE INDENT def sum_of_digits_single ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while x != 0 : NEW_LINE INDENT ans += x % 10 NEW_LINE x //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT def closest ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ans * 10 + 9 <= x : NEW_LINE INDENT ans = ans * 10 + 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sum_of_digits_two_parts ( N ) : NEW_LINE INDENT A = closest ( N ) NEW_LINE return sum_of_digits_single ( A ) + sum_of_digits_single ( N - A ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT N = 35 NEW_LINE sys . stdout . write ( sum_of_digits_two_parts ( N ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE stdin_stream = sys . stdin NEW_LINE ca = ( 35.5 , 37.5 , 40 , 43 , 50 , 55 , 70 ) NEW_LINE cb = ( 71 , 77 , 83 , 89 , 105 , 116 , 148 ) NEW_LINE c = ( ' AAA ' , ' AA ' , ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' NA ' ) NEW_LINE for a , b in zip ( ca , cb ) : NEW_LINE INDENT ar = 100 NEW_LINE br = 100 NEW_LINE for i in range ( len ( ca ) ) : NEW_LINE INDENT if ca [ i ] > a : NEW_LINE INDENT ar = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( len ( cb ) ) : NEW_LINE INDENT if cb [ i ] > b : NEW_LINE INDENT br = i NEW_LINE break NEW_LINE DEDENT DEDENT ans = max ( ar , br ) NEW_LINE if ans == 100 : NEW_LINE INDENT ans = len ( c ) - 1 NEW_LINE DEDENT print ( c [ ans ] ) NEW_LINE DEDENT DEDENT
def test_q1 ( ) : NEW_LINE INDENT import time NEW_LINE class q1 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = 0 NEW_LINE self . b = 0 NEW_LINE self . c = 0 NEW_LINE self . d = 0 NEW_LINE DEDENT def f ( self ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT t = time . time ( ) NEW_LINE while t : NEW_LINE INDENT a , b , c , d = select ( [ q1 ( ) ] , [ ] , [ ] , 0 ) NEW_LINE res = max ( c - 1 , a - c ) + max ( d - 1 , b - d ) NEW_LINE print ( res ) NEW_LINE DEDENT DEDENT
def A_remove_Smallest ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import eigs NEW_LINE sn = zeros ( ( n , n ) ) NEW_LINE t = len ( eigs ) NEW_LINE while t : NEW_LINE INDENT n = eigs [ t ] NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( eigs [ i ] ) NEW_LINE DEDENT arr = sorted ( arr ) NEW_LINE i = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] - arr [ i ] ) <= 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == n - 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def cal_sin ( n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . sin ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . accuracy = float ( 0.0001 ) NEW_LINE self . denominator = float ( self . denominator ) NEW_LINE self . sinx = float ( self . sinx ) NEW_LINE self . sinval = float ( self . sin ( n ) ) NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT self . denominator = 2 * self . i * ( 2 * self . i + 1 ) NEW_LINE x1 = - x1 * self . n * self . n / denominator NEW_LINE self . sinx = self . sinx + x1 NEW_LINE i = i + 1 NEW_LINE if accuracy <= self . sinval - self . sinx : NEW_LINE INDENT return NEW_LINE DEDENT print ( self . sinx ) NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 90 NEW_LINE return GFG ( n ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE def multiply ( ) : NEW_LINE INDENT pro = 1 NEW_LINE for i in arr : NEW_LINE INDENT pro = pro * i NEW_LINE DEDENT return pro NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT print ( multiply ( ) ) NEW_LINE DEDENT DEDENT
def import decimal NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . q , order_num , i , j , n = 0 , 0 , 0 , 0 NEW_LINE flag = [ False ] * 64 NEW_LINE with open ( " input . txt " , " r " ) as f : NEW_LINE INDENT q = int ( f . read ( ) ) NEW_LINE for j in range ( q ) : NEW_LINE INDENT order_num = int ( f . read ( ) ) NEW_LINE if order_num <= 3 : NEW_LINE INDENT n = int ( f . read ( ) ) NEW_LINE DEDENT if order_num == 0 : NEW_LINE INDENT print ( "1" if flag [ n ] else "0" ) NEW_LINE DEDENT elif order_num == 1 : NEW_LINE INDENT flag [ n ] = True NEW_LINE DEDENT elif order_num == 2 : NEW_LINE INDENT flag [ n ] = False NEW_LINE DEDENT elif order_num == 3 : NEW_LINE INDENT flag [ n ] = not flag [ n ] NEW_LINE DEDENT elif order_num == 4 : NEW_LINE INDENT counter = 1 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] != True : NEW_LINE INDENT counter = 0 NEW_LINE break NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE DEDENT elif order_num == 5 : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] != False : NEW_LINE INDENT counter = 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE DEDENT elif order_num == 6 : NEW_LINE INDENT counter = 1 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] == True : NEW_LINE INDENT counter = 0 NEW_LINE break NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE DEDENT elif order_num == 7 : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] == True : NEW_LINE INDENT counter += 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( counter ) NEW_LINE DEDENT elif order_num == 8 : NEW_LINE INDENT sum = Decimal ( "0" ) NEW_LINE big = Decimal ( "2" ) NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] : NEW_LINE INDENT sum = sum + big ** i NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT import sys NEW_LINE import struct NEW_LINE import struct NEW_LINE class GFG ( struct . Struct ) : NEW_LINE INDENT def bit ( self , n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def max_sum_of_bits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE excl_new = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = ( incl , excl ) NEW_LINE incl = excl + arr [ i ] NEW_LINE excl = excl_new NEW_LINE DEDENT return ( ( incl , excl ) ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE sys . stdout . write ( max_sum_of_bits ( arr , n ) ) NEW_LINE DEDENT DEDENT
def python_application_70 ( ) : NEW_LINE INDENT from pyapp2 import pyapp3 NEW_LINE from pyapp3 import pyapp3 NEW_LINE with open ( ' . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . . / . . / . / . . / . / . . / . / . . / . / . . / . / . / . . / . / . / . . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / ) as
def GFG ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return 0 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return find_min_index ( arr , low , mid - 1 ) NEW_LINE DEDENT return find_min_index ( arr , mid + 1 , high ) NEW_LINE DEDENT def binary_search ( arr , l , h , x ) : NEW_LINE INDENT while l <= h : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] <= x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT return h NEW_LINE DEDENT def count_ele_less_than ( arr , n , x ) : NEW_LINE INDENT min_index = find_min_index ( arr , 0 , n - 1 ) NEW_LINE if x <= arr [ n - 1 ] : NEW_LINE INDENT return ( binary_search ( arr , min_index , n - 1 , x ) + 1 - min_index ) NEW_LINE DEDENT if ( min_index - 1 ) >= 0 and x <= arr [ min_index - 1 ] : NEW_LINE INDENT return ( n - min_index + binary_search ( arr , 0 , min_index - 1 , x ) + 1 ) NEW_LINE DEDENT return n NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 6 , 10 , 12 , 15 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 14 NEW_LINE print ( " Count ▁ = ▁ " + str ( count_ele_less_than ( arr , n , x ) ) , end = ' ▁ ' ) NEW_LINE DEDENT
def import _pylab NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT v = y - 2 * x * x + 1 NEW_LINE return v NEW_LINE DEDENT def predict ( self , x , y , h = 0.00001 ) : NEW_LINE INDENT y1p = y + h * f ( x , y ) NEW_LINE return y1p NEW_LINE DEDENT def correct ( self , x , y , x1 , y1 , h = 0.00001 ) : NEW_LINE INDENT e = 0.00001 NEW_LINE y1c = y1 NEW_LINE while abs ( y1c - y1 ) > e : NEW_LINE INDENT y1 = y1c NEW_LINE y1c = y + 0.5 * h * ( f ( x , y ) + f ( x1 , y1 ) ) NEW_LINE DEDENT return y1c NEW_LINE DEDENT def print_final_values ( self , x , xn , y , h = 0.00001 ) : NEW_LINE INDENT while x < xn : NEW_LINE INDENT x1 = x + h NEW_LINE y1p = predict ( self , x , y , h = h ) NEW_LINE y1c = correct ( self , x , y , x1 , y1p , h = h ) NEW_LINE x = x1 NEW_LINE y = y1c NEW_LINE DEDENT print ( " The ▁ final ▁ value ▁ of ▁ y ▁ at ▁ x ▁ = ▁ " , int ( x ) , " ▁ is ▁ : ▁ " , ' % . 4 f ' % y ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT x , y = 0 , 0.5 NEW_LINE xn = 1 , 0.2 NEW_LINE print_final_values ( self , x , xn , y , h = h ) NEW_LINE DEDENT DEDENT
def D_Pattern ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 9 NEW_LINE DEDENT DEDENT D_Pattern ( n ) NEW_LINE DEDENT
def GFG ( n , k ) : NEW_LINE INDENT total = 0 NEW_LINE i = 1 NEW_LINE while total < k : NEW_LINE INDENT total = total + n - i NEW_LINE i += 1 NEW_LINE DEDENT first_y_position = i - 1 NEW_LINE second_y_position = k - ( total - n + first_y_position ) NEW_LINE for i in range ( 1 , first_y_position ) : NEW_LINE INDENT print ( " x " , end = " ▁ " ) NEW_LINE DEDENT print ( " y " , end = " ▁ " ) NEW_LINE j = first_y_position + 1 NEW_LINE while second_y_position > 1 : NEW_LINE INDENT print ( " x " , end = " ▁ " ) NEW_LINE second_y_position -= 1 NEW_LINE j += 1 NEW_LINE DEDENT print ( " y " , end = " ▁ " ) NEW_LINE while j < n : NEW_LINE INDENT print ( " x " , end = " ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT
def GFG ( n , k ) : NEW_LINE INDENT C = [ 1 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE def count_of_subarrays ( N ) : NEW_LINE INDENT count = binomial_coeff ( 2 * N - 1 , N ) NEW_LINE return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = 3 NEW_LINE sys . stdout . write ( count_of_subarrays ( N ) + " \n " ) NEW_LINE DEDENT DEDENT
def import _solution NEW_LINE class Solution ( object ) : NEW_LINE INDENT def product_except_self ( self , nums ) : NEW_LINE INDENT n = len ( nums ) NEW_LINE res = [ 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] * nums [ i - 1 ] NEW_LINE DEDENT right = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT res [ i ] *= right NEW_LINE right *= nums [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1,2,3,4] NEW_LINE out = sObj . product_except_self ( nums ) NEW_LINE print ( [ x for x in out ] ) NEW_LINE DEDENT DEDENT
def GFG ( s , k ) : NEW_LINE INDENT curr_str = s [ 0 : k ] NEW_LINE lex_min = curr_str NEW_LINE lex_max = curr_str NEW_LINE for i in s [ k : ] : NEW_LINE INDENT curr_str = curr_str [ 1 : k ] + i NEW_LINE if lex_max < curr_str : NEW_LINE INDENT lex_max = curr_str NEW_LINE DEDENT if lex_min > curr_str : NEW_LINE INDENT lex_min = curr_str NEW_LINE DEDENT DEDENT print ( lex_min ) NEW_LINE print ( lex_max ) NEW_LINE DEDENT
def import _CF840A NEW_LINE class CF840A ( object ) : NEW_LINE INDENT def __init__ ( self , f ) : NEW_LINE INDENT self . f = f NEW_LINE self . n = len ( f ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return int ( key ) NEW_LINE DEDENT def __setitem__ ( self , key , value ) : NEW_LINE INDENT self . n = len ( value ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return int ( key ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return int ( key ) NEW_LINE DEDENT def __len__ ( self ) : NEW_LINE INDENT return len ( self . n ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return int ( key ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " CF840A ( % s ) " % repr ( self . n ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import ceil NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE from sys import stdin NEW_LINE from itertools import chain NEW_LINE from itertools import chain NEW_LINE number = randint ( 1 , 10000 ) NEW_LINE wooden = chain ( [ each for each in chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , wooden , chain ( wooden , wooden ) , wooden ) , wooden ) , wooden ) , wooden ) , ) , ) ) ) for wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , chain ( wooden , wooden ) , wooden ) , wooden ) , wooden ) , ) , ) ) , ) ) ) ] ) for i in range ( 1 , 4 ) ) NEW_LINE index = max = height [ 0 ] NEW_LINE for i in chain ( height [ 1 : ] , chain ( height [ 2 : ] , chain ( height [ 3 : ] , wooden [ 4 : ] , ) ) ) ) : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if max < i : NEW_LINE INDENT max = i NEW_LINE DEDENT DEDENT print ( max , index ) NEW_LINE DEDENT
def minAbsSumPair ( arr , n ) : NEW_LINE INDENT from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE from math import fabs NEW_LINE DEDENT
def solution ( ) : NEW_LINE INDENT class Solution : NEW_LINE INDENT def firstUniqChar ( self ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for c in self . s : NEW_LINE INDENT freq [ c - ' a ' ] += 1 NEW_LINE DEDENT for i in range ( len ( self . s ) ) : NEW_LINE INDENT if freq [ i - ' a ' ] == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT sObj = Solution ( ) NEW_LINE s = " leetcode " NEW_LINE out = sObj . firstUniqChar ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import random NEW_LINE from random import randint NEW_LINE from math import sin , cos , cos , exp NEW_LINE class GFG ( object ) : NEW_LINE INDENT def check_stack_permutation ( self , ip , op , n ) : NEW_LINE INDENT input = [ ip [ i ] for i in range ( n ) ] NEW_LINE output = [ op [ i ] for i in range ( n ) ] NEW_LINE temp_stack = [ ] NEW_LINE while not input . empty ( ) : NEW_LINE INDENT ele = input . pop ( ) NEW_LINE if ele == output [ - 1 ] : NEW_LINE INDENT output . pop ( ) NEW_LINE while not temp_stack . empty ( ) : NEW_LINE INDENT if temp_stack [ - 1 ] == output [ - 1 ] : NEW_LINE INDENT temp_stack . pop ( ) NEW_LINE output . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT temp_stack . append ( ele ) NEW_LINE DEDENT DEDENT return ( input , temp_stack ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT input = [ 1 , 2 , 3 ] NEW_LINE output = [ 2 , 1 , 3 ] NEW_LINE n = 3 NEW_LINE if check_stack_permutation ( self , input , output , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT import sys NEW_LINE from string import ascii_letters NEW_LINE sc = Scanner ( ) NEW_LINE s = sc . next ( ) NEW_LINE t = sc . next ( ) NEW_LINE l = len ( s ) NEW_LINE ans = True NEW_LINE for i in range ( l ) : NEW_LINE INDENT if s . find ( s [ i ] , i + 1 ) != t . find ( t [ i ] , i + 1 ) : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT print ( " Yes " if ans else " No " ) NEW_LINE DEDENT
def import _solution NEW_LINE class Solution ( object ) : NEW_LINE INDENT def getSum ( self , n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 10 == d : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n , d = 30 , 3 NEW_LINE print ( _Sum ( n , d ) ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sys = sys NEW_LINE self . t = sys . maxint NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT st = sys . stdin . readline ( ) NEW_LINE end = sys . stdin . readline ( ) NEW_LINE n = sys . stdin . readline ( ) NEW_LINE m = sys . stdin . readline ( ) NEW_LINE sum = 0 NEW_LINE if st > end : NEW_LINE INDENT temp = end NEW_LINE end = st NEW_LINE st = temp NEW_LINE DEDENT if n + m <= st : NEW_LINE INDENT sum = end - st NEW_LINE DEDENT elif n + m >= st and n - m < st : NEW_LINE INDENT sum = end - n - m NEW_LINE DEDENT elif n - m >= st and n <= end - m : NEW_LINE INDENT sum = end - st - 2 * m NEW_LINE DEDENT elif n - m < end and n + m >= end : NEW_LINE INDENT sum = n - m - st NEW_LINE DEDENT else : NEW_LINE INDENT sum = end - st NEW_LINE DEDENT if sum < 0 : sum = 0 NEW_LINE print ( sum ) NEW_LINE DEDENT DEDENT DEDENT
def import import os , sys , traceback NEW_LINE from os import urandom NEW_LINE import random NEW_LINE class Codechef ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = random . randint ( 1 , 10000 ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' Codechef ' NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT try : NEW_LINE INDENT sc = open ( self . n , ' r ' ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT n = sc . n NEW_LINE DEDENT DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT e = select . select ( [ ] , [ ] , [ ] , 0 ) NEW_LINE s = select . select ( [ ] , [ ] , [ ] , 1 ) NEW_LINE t = select . select ( [ ] , [ ] , [ ] , 1 ) NEW_LINE temp = max ( e - s , e - t ) NEW_LINE print ( temp + 1 ) NEW_LINE DEDENT DEDENT
def test_find_sum ( ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . Integral ) : NEW_LINE INDENT def find_sum ( self , N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT N , K = 10 , 2 NEW_LINE print ( find_sum ( N , K ) ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import gcd NEW_LINE from math import floor NEW_LINE class Ishu : NEW_LINE INDENT def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : return a NEW_LINE else : return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT with open ( ' / proc / ' , ' r ' ) as f : NEW_LINE INDENT while f . readline ( ) . strip ( ) . startswith ( ' / ' ) : NEW_LINE INDENT n , ans = f . readline ( ) . split ( ) NEW_LINE ans = 1 + ( ( 4 * n ) / gcd ( 4 * n , n + 1 ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT DEDENT return Ishu NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT PI = 3.14 NEW_LINE def find_area ( r , d ) : NEW_LINE INDENT R = d / PI NEW_LINE R += pow ( r , 2 ) NEW_LINE R = math . sqrt ( R ) NEW_LINE area = PI * pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT r , d = 4 , 5 NEW_LINE print ( find_area ( r , d ) ) NEW_LINE DEDENT return find_area NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n , s ) : NEW_LINE INDENT if ( s % n ) : NEW_LINE INDENT return s / n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return s / n NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 5 NEW_LINE s = 11 NEW_LINE print ( self . minimumNumbers ( n , s ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def count_triplets ( arr , n , m ) : NEW_LINE INDENT import math NEW_LINE count = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE end , start , mid = 0 , end - 1 , n NEW_LINE for end in range ( n - 1 , 2 , - 1 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while start < mid : NEW_LINE INDENT prod = arr [ end ] * arr [ start ] * arr [ mid ] NEW_LINE if prod > m : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif prod < m : NEW_LINE INDENT start += 1 NEW_LINE DEDENT elif prod == m : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def test_find_index ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_index ( self , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT a , b , c = 0 , 1 , 1 NEW_LINE res = 1 NEW_LINE while c < n : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a , b = b , c NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT result = find_index ( 21 ) NEW_LINE print ( result ) NEW_LINE DEDENT
def GFG ( ch ) : NEW_LINE INDENT if ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isSatisfied ( str , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if not isVowel ( str [ i ] ) and not isVowel ( str [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if isVowel ( str [ i ] ) and not isVowel ( str [ i - 1 ] ) and not isVowel ( str [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT str = ' acaba ' NEW_LINE n = len ( str ) NEW_LINE if isSatisfied ( str . split ( ) , n ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT dp = [ 0 , 1 , 1 ] NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def GFG ( m , n ) : NEW_LINE INDENT ans , i = 0.0 , 0.0 NEW_LINE for i in range ( m , 0 , - 1 ) : NEW_LINE INDENT ans += ( pow ( i / m , n ) - pow ( ( i - 1 ) / m , n ) ) * i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def ProdOfPrimes ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . prime = [ True ] * ( n + 1 ) NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT for p in range ( 2 , p * n + 1 ) : NEW_LINE INDENT if self . prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT self . prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT prod = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if self . prime [ i ] : NEW_LINE INDENT prod *= i NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 10 NEW_LINE sys . stdout . write ( ProdOfPrimes ( n ) ) NEW_LINE DEDENT DEDENT
def p019 ( ) : print ( eval ( ' p019 ( ) ' ) ) NEW_LINE def p019 ( ) : NEW_LINE INDENT count = 0 NEW_LINE for y in range ( 1901 , 2000 ) : NEW_LINE INDENT for m in range ( 1 , 12 ) : NEW_LINE INDENT if dayOfWeek ( y , m , 1 ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return str ( count ) NEW_LINE DEDENT def dayOfWeek ( year , month , day ) : NEW_LINE INDENT if not ( year < 0 or year > 10000 or month < 1 or month > 12 or day < 1 or day > 31 ) : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT m = ( month - 3 + 4800 ) % 4800 NEW_LINE y = ( year + m // 12 ) % 400 NEW_LINE m %= 12 NEW_LINE return ( y + y // 4 - y // 100 + ( 13 * m + 2 ) // 5 + day + 2 ) % 7 NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT class Date : NEW_LINE INDENT def __init__ ( self , d , m , y ) : NEW_LINE INDENT self . d = d NEW_LINE self . m = m NEW_LINE self . y = y NEW_LINE DEDENT DEDENT month_days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE def count_leap_years ( d ) : NEW_LINE INDENT years = d . y NEW_LINE if d . m <= 2 : NEW_LINE INDENT years -= 1 NEW_LINE DEDENT return years / 4 - years / 100 + years / 400 NEW_LINE DEDENT def getDifference ( dt1 , dt2 ) : NEW_LINE INDENT n1 = dt1 . y * 365 + dt1 . d NEW_LINE for i in range ( dt1 . m - 1 ) : NEW_LINE INDENT n1 += month_days [ i ] NEW_LINE DEDENT n1 += count_leap_years ( dt1 ) NEW_LINE n2 = dt2 . y * 365 + dt2 . d NEW_LINE for i in range ( dt2 . m - 1 ) : NEW_LINE INDENT n2 += month_days [ i ] NEW_LINE DEDENT n2 += count_leap_years ( dt2 ) NEW_LINE return ( n2 - n1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT dt1 = Date ( 1 , 2 , 2000 ) NEW_LINE dt2 = Date ( 1 , 2 , 2004 ) NEW_LINE print ( " Difference ▁ between ▁ two ▁ dates ▁ is ▁ " , getDifference ( dt1 , dt2 ) ) NEW_LINE DEDENT DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def generateNumbers ( self , n , num , a , b ) : NEW_LINE INDENT if num > 0 and num < n : NEW_LINE INDENT st . add ( num ) NEW_LINE DEDENT if num >= n : NEW_LINE INDENT return NEW_LINE DEDENT if num * 10 + a > num : NEW_LINE INDENT generateNumbers ( self , num * 10 + a , a , b ) NEW_LINE DEDENT generateNumbers ( self , num * 10 + b , a , b ) NEW_LINE DEDENT def printNumbers ( self , n ) : NEW_LINE INDENT for i in range ( 0 , 9 ) : NEW_LINE INDENT for j in range ( i + 1 , 9 ) : NEW_LINE INDENT generateNumbers ( self , n , 0 , i , j ) NEW_LINE DEDENT DEDENT print ( " The ▁ numbers ▁ are : ▁ " , end = " " ) NEW_LINE print ( st , end = " " ) NEW_LINE self . st = set ( ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT n = 12 NEW_LINE printNumbers ( self , n ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class ProgressBar ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( sys . stdin . readline ( ) ) NEW_LINE self . k = int ( sys . stdin . readline ( ) ) NEW_LINE self . t = int ( sys . stdin . readline ( ) ) NEW_LINE temp = ( t * self . k * self . n ) / 100.0 NEW_LINE x = 0 NEW_LINE while temp - k >= 0 : NEW_LINE INDENT temp -= k NEW_LINE x += 1 NEW_LINE DEDENT for i in range ( x ) : print ( k , end = ' ▁ ' ) NEW_LINE if temp != 0 : NEW_LINE INDENT print ( int ( temp ) , end = ' ▁ ' ) NEW_LINE x += 1 NEW_LINE DEDENT for i in range ( x , self . n ) : print ( 0 , end = ' ▁ ' ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from itertools import count , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE from itertools import chain , repeat NEW_LINE for N , Q in ni ( ) : NEW_LINE INDENT if ( N | Q ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT list = [ ] NEW_LINE dict = { } NEW_LINE for i in range ( 1 , 100 ) : NEW_LINE INDENT dict [ i ] = 0 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT M = ni ( ) NEW_LINE list . append ( chain ( range ( M ) , range ( M ) ) ) NEW_LINE for j in repeat ( range ( M ) , N ) : NEW_LINE INDENT d = repeat ( i , M ) NEW_LINE list [ i ] = [ d ] NEW_LINE dict [ d ] = dict [ d ] + 1 NEW_LINE DEDENT DEDENT max = 0 NEW_LINE idx = 0 NEW_LINE for key in dict : NEW_LINE INDENT n = dict [ key ] NEW_LINE if n >= Q : NEW_LINE INDENT if max < n : NEW_LINE INDENT idx = key NEW_LINE max = n NEW_LINE DEDENT DEDENT DEDENT print ( idx ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sc = chain ( repeat ( 1 , 2 ) , repeat ( 2 , 2 ) ) NEW_LINE DEDENT ni ( ) NEW_LINE return sc NEW_LINE DEDENT
def OddOccurance ( ar , ar_size ) : NEW_LINE INDENT def oddOccurrence ( ar , ar_size ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( ar_size ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT occur = OddOccurance ( ) NEW_LINE ar = ( 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ) NEW_LINE n = len ( ar ) NEW_LINE print ( occur . OddOccurrence ( ar , n ) ) NEW_LINE DEDENT
def GFG ( x , k ) : NEW_LINE INDENT rslt = ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) NEW_LINE return rslt NEW_LINE DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 NEW_LINE r = ( len ( bin ( x ) ) / 8 ) * 8 NEW_LINE while l < r : NEW_LINE INDENT if isKthBitSet ( x , l ) != isKthBitSet ( x , r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def GFG ( n , isPrime = [ True ] ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , p * p + 1 ) : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE isPrime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT x = n // i NEW_LINE if isPrime [ i ] and isPrime [ x ] and x != i and x * i == n : NEW_LINE INDENT print ( i , x ) NEW_LINE flag = 1 NEW_LINE return NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ found " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 39 NEW_LINE findPrimePair ( n ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT import math NEW_LINE import math NEW_LINE class GFG ( math . gcd ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT math . gcd ( self , a ) NEW_LINE if not a : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT DEDENT a , b = 10 , 15 , 10 NEW_LINE g = GFG ( a , b ) NEW_LINE print ( " GCD ( % d ▁ , ▁ % d ) ▁ = ▁ % d " % ( a , b , g ) ) NEW_LINE a , b = 35 , 10 NEW_LINE g = GFG ( a , b ) NEW_LINE print ( " GCD ( % d ▁ , ▁ % d ) ▁ = ▁ % d " % ( a , b , g ) ) NEW_LINE a , b = 31 , 2 NEW_LINE g = GFG ( a , b ) NEW_LINE print ( " GCD ( % d ▁ , ▁ % d ) ▁ = ▁ % d " % ( a , b , g ) ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT import math NEW_LINE import math NEW_LINE class GFG ( math . gcd ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT math . gcd ( self , a ) NEW_LINE if not a : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT DEDENT a , b = 10 , 15 , 10 NEW_LINE g = GFG ( a , b ) NEW_LINE print ( " GCD ( % d ▁ , ▁ % d ) ▁ = ▁ % d " % ( a , b , g ) ) NEW_LINE a , b = 35 , 10 NEW_LINE g = GFG ( a , b ) NEW_LINE print ( " GCD ( % d ▁ , ▁ % d ) ▁ = ▁ % d " % ( a , b , g ) ) NEW_LINE a , b = 31 , 2 NEW_LINE g = GFG ( a , b ) NEW_LINE print ( " GCD ( % d ▁ , ▁ % d ) ▁ = ▁ % d " % ( a , b , g ) ) NEW_LINE DEDENT
def p174 ( ) : NEW_LINE INDENT print ( eval ( ' p174 ( ) ' ) ) NEW_LINE SIZE_LIMIT = 1000000 NEW_LINE TYPE_LIMIT = 10 NEW_LINE def run ( ) : NEW_LINE INDENT type = [ 0 ] * ( SIZE_LIMIT + 1 ) NEW_LINE for n in range ( 3 , ( n - 1 ) * 4 , SIZE_LIMIT + 1 ) : NEW_LINE INDENT for m in range ( n - 2 , 1 , - 2 ) : NEW_LINE INDENT tiles = n ** 2 - m ** 2 NEW_LINE if tiles > SIZE_LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT type [ tiles ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for t in type : NEW_LINE INDENT if 1 <= t <= TYPE_LIMIT : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT return run NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from StringIO import StringIO NEW_LINE from itertools import repeat NEW_LINE from itertools import chain NEW_LINE one = zero = 0 NEW_LINE for i in chain ( chain ( [ 0 ] , repeat ( i ) ) for i in range ( 1 , len ( i ) ) ) : NEW_LINE INDENT if i == '1' : NEW_LINE INDENT if i - 1 == '1' : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i - 1 == '0' and one > 0 : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " YES " ) NEW_LINE def main ( ) : NEW_LINE INDENT f = sys . stdin NEW_LINE out = sys . stdout NEW_LINE test = f . readline ( ) NEW_LINE while test : NEW_LINE INDENT s = f . readline ( ) NEW_LINE remove ( s ) NEW_LINE DEDENT DEDENT class FastReader ( object ) : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT while not s or not s : NEW_LINE INDENT try : NEW_LINE INDENT s = s . decode ( ' ascii ' ) NEW_LINE DEDENT except UnicodeDecodeError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not s or not s : NEW_LINE INDENT try : NEW_LINE INDENT s = s . decode ( ' ascii ' ) NEW_LINE DEDENT except UnicodeDecodeError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT data = ' ' NEW_LINE try : NEW_LINE INDENT data = f . readline ( ) . decode ( ' ascii ' ) NEW_LINE DEDENT except UnicodeDecodeError : NEW_LINE INDENT pass NEW_LINE DEDENT return data NEW_LINE DEDENT DEDENT class FastWriter ( object ) : NEW_LINE INDENT def __init__ ( self , f ) : NEW_LINE INDENT self . f = f NEW_LINE DEDENT def write ( self , data ) : NEW_LINE INDENT self . f . write ( " % s " % data ) NEW_LINE DEDENT def getvalue ( self ) : NEW_LINE INDENT self . f . write ( " \n " ) NEW_LINE DEDENT def close ( self ) : NEW_LINE INDENT f . close ( ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( N ) : NEW_LINE INDENT maxm = - 1 NEW_LINE cnt = 0 NEW_LINE while N != 0 : NEW_LINE INDENT if N & 1 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE N >>= 1 NEW_LINE maxm = max ( maxm , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT maxm = max ( maxm , cnt ) NEW_LINE cnt = 0 NEW_LINE N >>= 1 NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT
def get_longest_seq ( a , n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , a , n ) : NEW_LINE INDENT self . max_idx , self . max_len , self . curr_len , self . curr_idx = 0 , 0 , 0 , 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if a [ k ] > 0 : NEW_LINE INDENT self . curr_len += 1 NEW_LINE if self . curr_len == 1 : NEW_LINE INDENT self . curr_idx = k NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . curr_len > self . max_len : NEW_LINE INDENT self . max_len = self . curr_len NEW_LINE self . max_idx = self . curr_idx NEW_LINE DEDENT self . curr_len = 0 NEW_LINE DEDENT DEDENT if self . max_len : NEW_LINE INDENT print ( " Index ▁ : ▁ " , self . max_idx , end = " ▁ " ) NEW_LINE print ( " ▁ , Length ▁ : ▁ " , self . max_len , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ positive ▁ sequence ▁ detected . " ) NEW_LINE return NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 1 , 2 , - 3 , 2 , 3 , 4 , - 6 , 1 , 2 , 3 , 4 , 5 , - 8 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE get_longest_seq ( arr , n ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def Linked_list_2D_Matrix ( ) : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self , arr , i , j , m , n ) : NEW_LINE INDENT self . data = arr [ i ] [ j ] NEW_LINE self . right = self . construct ( arr , i , j + 1 , m , n ) NEW_LINE self . down = self . construct ( arr , i + 1 , j , m , n ) NEW_LINE return self NEW_LINE DEDENT DEDENT def display ( head ) : NEW_LINE INDENT global Dp NEW_LINE Rp = head NEW_LINE while Dp : NEW_LINE INDENT Rp = Dp NEW_LINE while Rp : NEW_LINE INDENT print ( Rp . data , end = ' ▁ ' ) NEW_LINE Rp = Rp . right NEW_LINE DEDENT print ( ) NEW_LINE Dp = Dp . down NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE m , n = 3 , 3 NEW_LINE head = construct ( arr , 0 , 0 , m , n ) NEW_LINE display ( head ) NEW_LINE DEDENT return Node ( ) NEW_LINE DEDENT
def import sys , stdin , stdout , stderr , verbose , verbose , filename_verbose , verbose , filename , * args , ** kwargs ) : NEW_LINE INDENT import os NEW_LINE import sys NEW_LINE import readline NEW_LINE import sys NEW_LINE import os NEW_LINE n = int ( stdin . readline ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if is_prime ( int ( stdin . readline ( ) ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE def is_prime ( x ) : NEW_LINE INDENT if x < 2 : return False NEW_LINE if x <= 3 : return True NEW_LINE if x % 2 == 0 or x % 3 == 0 : return False NEW_LINE for i in range ( 5 , x ** 2 + 1 , 6 ) : NEW_LINE INDENT if x % i == 0 or x % ( i + 2 ) == 0 : return False NEW_LINE DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT if N % 2 == 0 : NEW_LINE INDENT ans = ( N // 2 ) * 6 + ( N // 2 ) * 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N // 2 + 1 ) * 6 + ( N // 2 ) * 2 NEW_LINE DEDENT print ( ans , end = ' \n ' ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , a , b , c , d ) : NEW_LINE INDENT if a == b and a == c and a == d and c == d and b == c and b == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == b and c == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == d and c == b : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == c and d == b : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT a , b , c , d = 1 , 2 , 3 , 4 NEW_LINE if isRectangle ( a , b , c , d ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) NEW_LINE an = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m NEW_LINE DEDENT value = [ 0 ] * m NEW_LINE for i , cur in enumerate ( range ( 1 , an + n + 1 ) ) : NEW_LINE INDENT if not value [ cur ] : NEW_LINE INDENT value [ cur ] = i NEW_LINE DEDENT cur = ( cur * an ) % m NEW_LINE DEDENT for i , cur in enumerate ( range ( 0 , b + n + 1 ) ) : NEW_LINE INDENT if value [ cur ] : NEW_LINE INDENT ans = value [ cur ] * n - i NEW_LINE if ans < m : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def __find_minimum_cost ( ind , a , n , k , dp ) : NEW_LINE INDENT from math import fabs NEW_LINE if ind == ( n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif dp [ ind ] != - 1 : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = float ( ' inf ' ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ind + i < n : NEW_LINE INDENT ans = min ( ans , fabs ( a [ ind + i ] - a [ ind ] ) + __find_minimum_cost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return dp [ ind ] = ans NEW_LINE DEDENT DEDENT
def __gcd ( a , b ) : NEW_LINE INDENT import math NEW_LINE if not a : NEW_LINE INDENT return b NEW_LINE DEDENT if not b : NEW_LINE INDENT return a NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def Probability ( sum , times ) : NEW_LINE INDENT favorable , total = 0 , 36 NEW_LINE probability = 0 NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT for j in range ( 1 , 6 ) : NEW_LINE INDENT if ( i + j ) == sum : NEW_LINE INDENT favorable += 1 NEW_LINE DEDENT DEDENT DEDENT gcd1 = __gcd ( int ( favorable ) , int ( total ) ) NEW_LINE favorable = favorable / float ( gcd1 ) NEW_LINE total = total / float ( gcd1 ) NEW_LINE probability = long ( math . pow ( total , times ) ) NEW_LINE return probability NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sum , times = 7 , 7 NEW_LINE print ( "1" + " / " + Probability ( sum , times ) ) NEW_LINE DEDENT
def import import sys NEW_LINE mod = 998244353 NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . nchoosek = [ ] NEW_LINE for i in range ( 4001 ) : NEW_LINE INDENT self . nchoosek . append ( [ ] ) NEW_LINE DEDENT for i in range ( 2 , len ( self . nchoosek ) ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT self . nchoosek [ i ] [ j ] = ( self . nchoosek [ i - 1 ] [ j ] + self . nchoosek [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT DEDENT DEDENT def run ( self ) : NEW_LINE INDENT self . k = self . k NEW_LINE self . n = self . n NEW_LINE for i in range ( 2 , 2 * k + 1 ) : NEW_LINE INDENT if i > k : NEW_LINE INDENT pairs = k - i // 2 NEW_LINE DEDENT else : NEW_LINE INDENT pairs = ( i - 1 ) // 2 NEW_LINE DEDENT active = k - 2 * pairs NEW_LINE if i % 2 == 0 : NEW_LINE INDENT active -= 1 NEW_LINE DEDENT times2 = 1 NEW_LINE total = 0 NEW_LINE for j in range ( 0 , pairs ) : NEW_LINE INDENT choice = times2 * self . nchoosek [ pairs ] [ j ] % mod NEW_LINE times2 = times2 * 2 % mod NEW_LINE if active + j - 1 < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT total += choice * self . nchoosek [ n + active - 1 ] [ active + j - 1 ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT total += choice * self . nchoosek [ n + active - 2 ] [ active + j - 1 ] NEW_LINE DEDENT total %= mod NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT DEDENT DEDENT
def import import string , collections , string , ** kwargs ) : NEW_LINE INDENT from collections import defaultdict NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from collections import defaultdict NEW_LINE from string import join NEW_LINE from string import join NEW_LINE from string import join NEW_LINE N = kwargs . get ( ' N ' , 1 ) NEW_LINE total = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT money = reduce ( lambda x , y : x + y , map ( join , x . split ( ) ) ) NEW_LINE A = join ( join ( list ( x ) , ' JPY ' ) ) NEW_LINE B = ' JPY ' NEW_LINE if A == B : NEW_LINE INDENT total += money NEW_LINE DEDENT else : NEW_LINE INDENT total += money * 380000 NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE DEDENT
def __GFG ( arr , n , num1 , num2 ) : NEW_LINE INDENT from numpy import array NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == num1 : break NEW_LINE if i >= n - 1 : return 0 NEW_LINE DEDENT for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT if arr [ j ] == num2 : break NEW_LINE if j == i : return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . raw_input = raw_input NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = len ( sys . stdin . readline ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( sys . stdin . readline ( ) ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE min = sys . maxint NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT min = min ( min , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT sys . stdout . write ( " % s \n " % ( min ) ) NEW_LINE DEDENT DEDENT DEDENT
def count_set_bits ( n ) : NEW_LINE INDENT import random NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . cnt = 0 NEW_LINE self . set_bits = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT self . set_bits [ i ] = self . set_bits [ i // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT self . set_bits [ i ] = self . set_bits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT self . cnt = self . cnt + self . set_bits [ i ] NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 6 NEW_LINE print ( count_set_bits ( n ) ) NEW_LINE DEDENT return GFG NEW_LINE DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if a == 0 : return b NEW_LINE return gcd ( b % a , a ) NEW_LINE def largestGCD1Subset ( A , n ) : NEW_LINE INDENT currentGCD = A [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currentGCD = gcd ( currentGCD , A [ i ] ) NEW_LINE if currentGCD == 1 : return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT A = [ 2 , 18 , 6 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestGCD1Subset ( A , n ) ) NEW_LINE DEDENT return main ( ) NEW_LINE DEDENT
def test_p179 ( ) : NEW_LINE INDENT import library NEW_LINE import numpy NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE import numpy . random NEW_LINE limit = library . pow ( 10 , 7 ) NEW_LINE numpy . random . seed ( limit ) NEW_LINE num_divisors = numpy . random . randint ( limit + 1 , limit + 1 , limit + 1 ) NEW_LINE for i in range ( 2 , len ( num_divisors ) ) : NEW_LINE INDENT for j in range ( i * 2 , len ( num_divisors ) , i ) : NEW_LINE INDENT num_divisors [ j ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( 2 , len ( num_divisors ) - 1 ) : NEW_LINE INDENT if num_divisors [ i ] == num_divisors [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT arr [ 0 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE return arr NEW_LINE DEDENT return main ( ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum - arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE return find_encrypted_array ( arr , N ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE return arr NEW_LINE DEDENT return main ( ) NEW_LINE DEDENT
def find_min_difference ( arr , n ) : NEW_LINE INDENT global min , second_min , max , second_max NEW_LINE min = second_max = ( arr [ 0 ] < arr [ 1 ] ) NEW_LINE max = second_min = ( arr [ 0 ] < arr [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT second_max = max NEW_LINE max = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second_max : NEW_LINE INDENT second_max = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < min : NEW_LINE INDENT second_min = min NEW_LINE min = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < second_min : NEW_LINE INDENT second_min = arr [ i ] NEW_LINE DEDENT DEDENT diff = min ( max - second_min , second_max - min ) NEW_LINE return diff NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import math NEW_LINE import random NEW_LINE import sys NEW_LINE import math NEW_LINE import random NEW_LINE import math NEW_LINE import random NEW_LINE import sys NEW_LINE num = random . randint ( 1 , 2 ) NEW_LINE pairs = [ [ random . randint ( 0 , 2 ) , random . randint ( 0 , 2 ) ] for _ in range ( num ) ] NEW_LINE common_factors = set ( ) NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT X = pairs [ 0 ] [ i ] NEW_LINE for k in range ( 2 , int ( math . ceil ( math . sqrt ( X ) ) ) + 1 ) : NEW_LINE INDENT if X % k == 0 : NEW_LINE INDENT while X % k == 0 : NEW_LINE INDENT X /= k NEW_LINE DEDENT common_factors . add ( k ) NEW_LINE DEDENT DEDENT if X != 1 : NEW_LINE INDENT common_factors . add ( X ) NEW_LINE DEDENT DEDENT for val in common_factors : NEW_LINE INDENT works = True NEW_LINE for i in range ( len ( pairs ) ) : NEW_LINE INDENT if pairs [ i ] [ 0 ] % val > 0 and pairs [ i ] [ 1 ] % val > 0 : NEW_LINE INDENT works = False NEW_LINE break NEW_LINE DEDENT DEDENT if works : NEW_LINE INDENT print ( val ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def import import sys , string , traceback , color , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_code , color_
def Factorial ( n ) : NEW_LINE INDENT def factorial ( n ) : NEW_LINE INDENT return ( n == 1 or n == 0 ) * factorial ( n - 1 ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT obj = Factorial ( ) NEW_LINE num = 5 NEW_LINE print ( " Factorial ▁ of ▁ { } ▁ is ▁ { } " . format ( num , obj . factorial ( num ) ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import import _readline NEW_LINE import sys NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import sys NEW_LINE import re NEW_LINE import sys NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT lines = sys . stdin . readlines ( ) NEW_LINE words = lines [ 1 : ] NEW_LINE words = words . split ( ) NEW_LINE n , d , x = int ( words [ 0 ] ) , int ( words [ 1 ] ) , int ( words [ 2 ] ) NEW_LINE price = [ [ ] for i in range ( d ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT words = words . split ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT price [ i ] [ j ] = int ( words [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( d - 1 ) : NEW_LINE INDENT dp = [ j for j in range ( x + 1 ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT for k in range ( 0 , x ) : NEW_LINE INDENT if k >= price [ i ] [ j ] : NEW_LINE INDENT dp [ k ] = max ( dp [ k ] , dp [ k - price [ i ] [ j ] ] + price [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT x = dp [ x ] NEW_LINE DEDENT print ( x ) NEW_LINE DEDENT
def import import sys , StringIO , os , sys NEW_LINE from io import StringIO NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedWriter NEW_LINE from io import StringIO NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from from io import BufferedReader , BufferedWriter NEW_LINE from io import BufferedReader , BufferedWriter NEW_LINE from from io import BufferedReader , BufferedWriter NEW_LINE DEDENT
def find_minimum_x ( a , n ) : NEW_LINE INDENT from itertools import combinations NEW_LINE st = combinations ( a , n ) NEW_LINE if len ( st ) == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if len ( st ) == 2 : NEW_LINE INDENT for ( el1 , el2 ) in st : NEW_LINE INDENT if ( el2 - el1 ) % 2 == 0 : NEW_LINE INDENT return ( el2 - el1 ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( el2 - el1 ) NEW_LINE DEDENT DEDENT DEDENT if len ( st ) == 3 : NEW_LINE INDENT for ( el1 , el2 , el3 ) in st : NEW_LINE INDENT if ( el2 - el1 ) == ( el3 - el2 ) : NEW_LINE INDENT return el2 - el1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( find_minimum_x ( a , n ) ) NEW_LINE DEDENT DEDENT
def test_find_x ( n , k ) : NEW_LINE INDENT import math NEW_LINE from random import randint NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT class GFG ( object ) : NEW_LINE INDENT def LiesInsieRectangle ( self , a , b , x , y ) : NEW_LINE INDENT if x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT a , b , x , y = 7 , 2 , 4 , 5 NEW_LINE if LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT print ( " Given ▁ point ▁ lies ▁ " + " inside ▁ the ▁ rectangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Given ▁ point ▁ does ▁ not ▁ " + " lie ▁ on ▁ the ▁ rectangle " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT N = 1000 NEW_LINE def count_pairs ( arr , n ) : NEW_LINE INDENT size = ( 2 * N ) + 1 NEW_LINE freq = [ 0 ] * size NEW_LINE for x in arr : NEW_LINE INDENT freq [ x + N ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if freq [ i ] > 0 : NEW_LINE INDENT ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 NEW_LINE for j in range ( i + 2 , 2001 , 2 ) : NEW_LINE INDENT if freq [ j ] > 0 and ( freq [ ( i + j ) / 2 ] > 0 ) : NEW_LINE INDENT ans += ( freq [ i ] * freq [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 4 , 2 , 5 , 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( count_pairs ( arr , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT def getAvg ( x ) : NEW_LINE INDENT sum += x NEW_LINE return ( ( float ( sum ) / n ) ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( int ( arr [ i ] ) ) NEW_LINE print ( " Average ▁ of ▁ % d ▁ numbers ▁ is ▁ % f " % ( i + 1 , avg ) ) NEW_LINE DEDENT return avg NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = ( 10 , 20 , 30 , 40 , 50 , 60 ) NEW_LINE n = len ( arr ) NEW_LINE streamAvg ( arr , n ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import _ZZ NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 10000 NEW_LINE self . s = set ( ) NEW_LINE DEDENT def SieveOfEratosthenes ( self ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , self . MAX ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , self . MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for p in range ( 2 , self . MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT product = product * p NEW_LINE self . s . add ( product + 1 ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( self , n ) : NEW_LINE INDENT if n in self . s : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT self . SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if isEuclid ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = 42 NEW_LINE if isEuclid ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def import _sys , collections , Scanner , Vector , int , N NEW_LINE class SS ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT Scanner ( ) . __init__ ( self ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT n = int ( self . n ) NEW_LINE b = int ( self . b ) NEW_LINE arr = [ ] NEW_LINE v = [ ] NEW_LINE odd , even , count = 0 , 0 , 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT if i != 0 and odd == even : NEW_LINE INDENT v . append ( abs ( arr [ i ] - arr [ i - 1 ] ) ) NEW_LINE DEDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE for i in v : NEW_LINE INDENT if b >= i : NEW_LINE INDENT count += 1 NEW_LINE b -= i NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT
def GFG ( x ) : NEW_LINE INDENT global g , gk , gks NEW_LINE i = g = gk = gks = 0 NEW_LINE for i in x : NEW_LINE INDENT if i == ' g ' : NEW_LINE INDENT g += 1 NEW_LINE DEDENT elif i == ' k ' : NEW_LINE INDENT if g > 0 : NEW_LINE INDENT g -= 1 NEW_LINE gks += 1 NEW_LINE DEDENT DEDENT elif i == ' s ' : NEW_LINE INDENT if gk > 0 : NEW_LINE INDENT gk -= 1 NEW_LINE gks += 1 NEW_LINE DEDENT DEDENT DEDENT return gks NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n = sc . readline ( ) . strip ( ) NEW_LINE a = [ sc . readline ( ) . strip ( ) for i in range ( n ) ] NEW_LINE a . sort ( ) NEW_LINE min , max = a [ 0 ] , a [ - 1 ] NEW_LINE res = max - min + 1 - n NEW_LINE print ( res ) NEW_LINE DEDENT DEDENT
def import _iterator NEW_LINE import collections NEW_LINE import sys NEW_LINE class Forming_Teams ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . count = 0 NEW_LINE self . seen = [ ] NEW_LINE self . path , self . cycle = 0 , 1 NEW_LINE self . graph = collections . deque ( ) NEW_LINE def dfs ( self , child , par ) : NEW_LINE INDENT if self . seen [ child ] == True : return self . cycle NEW_LINE self . seen [ child ] = True NEW_LINE for i in self . graph [ child ] : NEW_LINE INDENT if i != par : NEW_LINE INDENT self . count += 1 NEW_LINE if self . dfs ( i , child ) == self . cycle : return self . cycle NEW_LINE DEDENT DEDENT DEDENT return self . path NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE m , n = sc . readline ( ) . split ( ) NEW_LINE ft = Forming_Teams ( ) NEW_LINE ft . graph = collections . deque ( ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT ft . graph . append ( collections . deque ( ) ) NEW_LINE DEDENT ft . seen = [ [ ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = sc . readline ( ) . split ( ) NEW_LINE ft . graph [ x ] . append ( y ) NEW_LINE ft . graph [ y ] . append ( x ) NEW_LINE DEDENT toremove = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if not ft . seen [ i ] : NEW_LINE INDENT ft . count = 0 NEW_LINE if ft . dfs ( i , 0 ) == ft . cycle : NEW_LINE INDENT if ft . count % 2 == 1 : NEW_LINE INDENT toremove += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( m - toremove ) % 2 == 1 : NEW_LINE INDENT toremove += 1 NEW_LINE DEDENT print ( toremove ) NEW_LINE DEDENT DEDENT
def kth_smallest ( arr , k ) : NEW_LINE INDENT import sys NEW_LINE import scipy . sparse NEW_LINE class GFG ( object ) : NEW_LINE INDENT def kth_smallest ( self , arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = np . array ( [ 12 , 3 , 5 , 7 , 19 ] ) NEW_LINE k = 2 NEW_LINE print ( " K ' th ▁ smallest ▁ element ▁ is ▁ " + str ( kth_smallest ( arr , k ) ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def import _ques NEW_LINE class ques ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT self . obj = args NEW_LINE self . t = args . t NEW_LINE DEDENT for i in range ( self . obj ) : NEW_LINE INDENT n = len ( self . obj ) NEW_LINE arr = [ ] NEW_LINE arr2 = [ ] NEW_LINE try : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr . append ( _ques ( i ) ) NEW_LINE arr2 . append ( i + 1 ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if arr2 [ i ] == arr [ i ] : NEW_LINE INDENT temp = arr2 [ i ] NEW_LINE arr2 [ i ] = arr2 [ i + 1 ] NEW_LINE arr2 [ i + 1 ] = temp NEW_LINE DEDENT DEDENT if arr2 [ n - 1 ] == arr [ n - 1 ] : NEW_LINE INDENT temp = arr2 [ n - 1 ] NEW_LINE arr2 [ n - 1 ] = arr2 [ n - 2 ] NEW_LINE arr2 [ n - 2 ] = temp NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr2 [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT except : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def test_p329 ( ) : NEW_LINE INDENT import math NEW_LINE print ( math . ceil ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math ( ) , math . log ( math . log ( math . log ( math ( ) , ) , ) , ) , ) , ) , ) , ) , ) , ) , ) , ) , ) , ) ) ) ) ) ) ) ) ) ) ) ) ) ) NEW_LINE DEDENT class p329 : NEW_LINE INDENT """ Test ▁ p329 ▁ with ▁ math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math ( math . log ( math . log ( math ( math . log ( math ( math . log ( math ( math ) , log ( math . log ( math ( math . log ( math ( math ( math ( math ( math ) , log ( math ( math . log ( math ( math ( math ( math ( math ( math ( math ( ( ( math ( ( ( ( math ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (
def distance ( lat1 , lat2 , lon1 , lon2 ) : NEW_LINE INDENT import math NEW_LINE lon1 = math . radians ( lon1 ) NEW_LINE lon2 = math . radians ( lon2 ) NEW_LINE lat1 = math . radians ( lat1 ) NEW_LINE lat2 = math . radians ( lat2 ) NEW_LINE dlon = lon2 - lon1 NEW_LINE dlat = lat2 - lat1 NEW_LINE a = math . pow ( math . sin ( dlat / 2 ) , 2 ) + math . cos ( lat1 ) * math . cos ( lat2 ) * math . pow ( math . sin ( dlon / 2 ) , 2 ) NEW_LINE c = 2 * math . asin ( math . sqrt ( a ) ) NEW_LINE r = 6371 NEW_LINE return ( c * r ) NEW_LINE DEDENT
def test_gf_octahedral ( ) : NEW_LINE INDENT from sympy . combinatorics . permutations import Permutation NEW_LINE n = 3 NEW_LINE print ( Permutation ( [ Permutation ( [ 0 , 1 , 2 , 3 ] ) , Permutation ( [ 1 , 2 , 3 , 4 ] ) , Permutation ( [ 2 , 3 , 4 , 5 ] ) , Permutation ( [ 5 , 6 , 7 , 8 ] ) ] ) ) NEW_LINE n = 9 NEW_LINE print ( Permutation ( [ Permutation ( [ 0 , 1 , 2 , 3 ] ) , Permutation ( [ 1 , 2 , 3 ] ) , Permutation ( [ 4 , 5 , 6 ] ) , Permutation ( [ 5 , 6 , 7 ] ) ] ) ) NEW_LINE DEDENT
def import _solv NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import math NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import random NEW_LINE INF = 1 << 24 NEW_LINE def main ( ) : NEW_LINE INDENT stdIn = sys . stdin NEW_LINE N = np . random . randint ( 1 , N ) NEW_LINE M = np . random . randint ( 1 , M ) NEW_LINE p = np . random . randint ( 1 , M ) NEW_LINE Limit = N * 50 NEW_LINE isDist = np . zeros ( N ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT d = np . random . randint ( 1 , M ) NEW_LINE isDist [ d ] = True NEW_LINE DEDENT isDist2 = np . array ( isDist ) NEW_LINE solv ( 1 , p , 0 , 0 , False , isDist ) NEW_LINE solv ( - 1 , p , 0 , 0 , False , isDist2 ) NEW_LINE print ( min ) NEW_LINE min = 1 << 24 NEW_LINE Limit = 1 << 24 NEW_LINE DEDENT
def Solution ( A ) : NEW_LINE INDENT max = sum ( [ i for i in A if max < i ] ) NEW_LINE return max NEW_LINE DEDENT def SumDivPrime ( A , n ) : NEW_LINE INDENT max_val = ( max_element ( A ) ) + 1 NEW_LINE prime = [ True for i in range ( 0 , max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ A [ i ] ] : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if prime [ A [ i ] ] and sum % A [ i ] == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT def Main ( args ) : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE SumDivPrime ( A , n ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( arr [ i % n ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE self . left_rotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 3 NEW_LINE self . left_rotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 4 NEW_LINE self . left_rotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from Solution import Solution NEW_LINE class Solution ( object ) : NEW_LINE INDENT def closestMultiple ( self , n , x ) : NEW_LINE INDENT if x > n : return x NEW_LINE n = n + x // 2 NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT DEDENT n , x = 56287 , 27 NEW_LINE print ( closestMultiple ( n , x ) ) NEW_LINE DEDENT
def compititive_programmer ( args ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE from sys import stdin NEW_LINE t = stdin . readline ( ) . strip ( ) NEW_LINE stdin . readline ( ) . strip ( ) NEW_LINE while t != 0 : NEW_LINE INDENT t -= 1 NEW_LINE s = stdin . readline ( ) . strip ( ) NEW_LINE zero , sum , even = 0 , 0 , 0 NEW_LINE for i in s : NEW_LINE INDENT sum += ord ( i ) - ord ( '0' ) NEW_LINE if i == '0' : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if i % 2 == 0 and i != '0' : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if zero != len ( s ) and ( ( even == 0 and zero == 1 ) or zero == 0 or sum % 3 != 0 ) : NEW_LINE INDENT print ( ' cyan ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' red ' ) NEW_LINE DEDENT DEDENT DEDENT
def _ ( a , b ) : NEW_LINE INDENT import math NEW_LINE dp = math . ceil ( math . log10 ( a ) ) NEW_LINE if a > b or a < 0 or b < 0 or a > 900 or b > 8100 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if a == 0 and b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ a ] [ b ] != - 1 : NEW_LINE INDENT return dp [ a ] [ b ] NEW_LINE DEDENT ans = 101 NEW_LINE for i in range ( 9 , 1 , - 1 ) : NEW_LINE INDENT k = minimum_number_of_digits ( a - i , b - ( i * i ) ) NEW_LINE if k != - 1 : NEW_LINE INDENT ans = min ( ans , k + 1 ) NEW_LINE DEDENT DEDENT return dp [ a ] [ b ] = ans NEW_LINE DEDENT def print_smallest_number ( a , b ) : NEW_LINE INDENT for row in dp : NEW_LINE INDENT row [ 0 ] = - 1 NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE k = minimum_number_of_digits ( a , b ) NEW_LINE if k == - 1 or k > 100 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT while a > 0 and b > 0 : NEW_LINE INDENT for i in range ( 1 , 9 ) : NEW_LINE INDENT if a >= i and b >= i * i and 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE a -= i NEW_LINE b -= i * i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT a , b = 18 , 162 NEW_LINE print_smallest_number ( a , b ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = 5005 NEW_LINE self . n = self . N NEW_LINE self . k = self . N NEW_LINE DEDENT def __init__ ( self , x , y ) : NEW_LINE INDENT gr = [ [ ] ] NEW_LINE d = [ [ ] for i in range ( self . N ) ] NEW_LINE ans = 0 NEW_LINE def Add_edge ( self , x , y ) : NEW_LINE INDENT gr [ x ] . append ( y ) NEW_LINE gr [ y ] . append ( x ) NEW_LINE DEDENT def dfs ( self , v , par ) : NEW_LINE INDENT d [ v ] [ 0 ] = 1 NEW_LINE for i in gr [ v ] : NEW_LINE INDENT if i != par : NEW_LINE INDENT dfs ( i , v ) NEW_LINE for j in range ( 1 , self . k + 1 ) : NEW_LINE INDENT ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] NEW_LINE DEDENT for j in range ( 1 , self . k + 1 ) : NEW_LINE INDENT d [ v ] [ j ] += d [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT self . n = 5 NEW_LINE self . k = 2 NEW_LINE for i in range ( self . N ) : NEW_LINE INDENT gr [ i ] = [ ] NEW_LINE DEDENT Add_edge ( 1 , 2 ) NEW_LINE Add_edge ( 2 , 3 ) NEW_LINE Add_edge ( 3 , 4 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE dfs ( 1 , 0 ) NEW_LINE print ( ans , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def test_find_subsequence ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_subsequence ( self , arr , n ) : NEW_LINE INDENT arr = [ 1 ] NEW_LINE if arr [ 0 ] == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT DEDENT dp = [ 0 ] * 10 NEW_LINE cnt = [ 0 ] * 10 NEW_LINE loc_max = 0 NEW_LINE tmp = arr [ 0 ] NEW_LINE while tmp > 0 : NEW_LINE INDENT dp [ tmp % 10 ] = 1 NEW_LINE tmp /= 10 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE loc_max = 1 NEW_LINE [ cnt ] = 0 NEW_LINE while tmp > 0 : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 NEW_LINE tmp /= 10 NEW_LINE DEDENT for d in range ( 0 , 9 ) : NEW_LINE INDENT if cnt [ d ] == 1 : NEW_LINE INDENT dp [ d ] += 1 NEW_LINE loc_max = max ( loc_max , dp [ d ] ) NEW_LINE DEDENT DEDENT for d in range ( 0 , 9 ) : NEW_LINE INDENT if cnt [ d ] == 1 : NEW_LINE INDENT dp [ d ] = loc_max NEW_LINE DEDENT DEDENT arr = [ arr [ d ] for d in range ( 0 , n ) ] NEW_LINE DEDENT return arr NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] NEW_LINE n = len ( arr ) NEW_LINE sys . stdout . write ( find_subsequence ( arr , n ) ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import itertools NEW_LINE import itertools NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = sys . stdin NEW_LINE self . t = sys . stdin . readline ( ) . strip ( ) NEW_LINE for i in range ( self . t ) : NEW_LINE INDENT n = self . input . n NEW_LINE m = self . input . m NEW_LINE seen = set ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT seen . add ( self . input . n ) NEW_LINE DEDENT count = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if seen . add ( self . input . n ) == False : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GCD ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , 2 * n , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT while ( n % i == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE def count_pairs ( G , L ) : NEW_LINE INDENT if L % G != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT div = L // G NEW_LINE return ( 1 << total_prime_factors ( div ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT G , L = 2 , 12 NEW_LINE print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ % d " % G , end = ' ▁ & ▁ LCM ▁ % d ' % L , end = ' ▁ = ▁ ' , count_pairs ( G , L ) ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def calculate_sum ( a , N ) : NEW_LINE INDENT m = N // a NEW_LINE sum = m * ( m + 1 ) // 2 NEW_LINE ans = a * sum NEW_LINE return ans NEW_LINE DEDENT
def import csv , file , sys , stdin , stdout , stderr , n , m , k , skills , line , * args , ** kwargs ) : NEW_LINE INDENT from io import csv NEW_LINE from io import StringIO NEW_LINE from csv import writer NEW_LINE from csv import DictWriter NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import reader NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import reader NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import reader NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import DictWriter NEW_LINE from csv import csv NEW_LINE from csv import reader NEW_LINE from csv import DictWriter NEW_LINE from csv import reader NEW_LINE from csv import DictWriter NEW_LINE from csv import reader NEW_LINE from csv import DictWriter NEW_LINE from csv import reader NEW_LINE from csv import DictWriter NEW_LINE from csv import reader NEW_LINE from csv import DictWriter NEW_LINE from csv import DictWriter NEW_LINE from csv import reader NEW_LINE from csv import DictWriter NEW_LINE from csv import reader NEW_LINE from csv import DictWriter NEW_LINE from csv import reader NEW_LINE from csv import DictWriter NEW_LINE from csv import DictWriter NEW_LINE from csv import reader NEW_LINE from csv import DictWriter NEW_LINE from csv import DictWriter NEW_LINE from csv import reader NEW_LINE DEDENT
def count_solutions ( a ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = 3 NEW_LINE DEDENT def __call__ ( self ) : NEW_LINE INDENT self . a = 3 NEW_LINE DEDENT def __test ( self ) : NEW_LINE INDENT return self . a NEW_LINE DEDENT DEDENT return GFG ( a ) NEW_LINE DEDENT
def GFG ( arr , target ) : NEW_LINE INDENT start , end = 0 , len ( arr ) - 1 NEW_LINE ans = - 1 NEW_LINE while start <= end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if arr [ mid ] <= target : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT word = [ ' zero ' , ' one ' , ' two ' , ' three ' , ' four ' , ' five ' , ' six ' , ' seven ' , ' eight ' , ' nine ' ] NEW_LINE def printWordsWithoutIfSwitch ( n ) : NEW_LINE INDENT digits = [ ] NEW_LINE dc = 0 NEW_LINE while True : NEW_LINE INDENT digits . append ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE dc += 1 NEW_LINE if n != 0 : NEW_LINE INDENT for i in range ( dc - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( word [ digits [ i ] ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 350 NEW_LINE printWordsWithoutIfSwitch ( n ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import math NEW_LINE import random NEW_LINE import math NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE f = sys . stdin NEW_LINE out = sys . stdout NEW_LINE f = open ( ' f ' , ' r ' ) NEW_LINE f . readline ( ) NEW_LINE n , k , m = map ( int , f . readline ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE f = open ( ' f ' , ' w ' ) NEW_LINE f . write ( ' { : . 3f } \n ' . format ( n ) ) NEW_LINE f . close ( ) NEW_LINE f = open ( ' f ' , ' w ' ) NEW_LINE f . write ( ' { : . 3f } \n ' . format ( f . read ( ) ) ) NEW_LINE f . close ( ) NEW_LINE out . close ( ) NEW_LINE DEDENT
def GFG ( a , b ) : NEW_LINE INDENT l = len ( a ) NEW_LINE min , max = 0 , 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if a [ i ] == ' + ' or b [ i ] == ' + ' or a [ i ] != b [ i ] : NEW_LINE INDENT max += 1 NEW_LINE DEDENT if a [ i ] != ' + ' and b [ i ] != ' + ' and a [ i ] != b [ i ] : NEW_LINE INDENT min += 1 NEW_LINE DEDENT DEDENT print ( min + max , end = ' \n ' ) NEW_LINE def main ( ) : NEW_LINE INDENT s1 = ' a + c ' , s2 = ' + + b ' NEW_LINE solve ( s1 . split ( ' + ' ) , s2 . split ( ' + ' ) ) NEW_LINE DEDENT DEDENT
def GFG ( n , s , k ) : NEW_LINE INDENT dp = [ 1 ] * n NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def count_evenodd ( n ) : NEW_LINE INDENT import sys NEW_LINE from math import ceil NEW_LINE even_count = odd_count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE if rem % 2 == 0 : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT print ( " Even ▁ count ▁ : ▁ % d " % even_count ) NEW_LINE print ( " Odd ▁ count ▁ : ▁ % d " % odd_count ) NEW_LINE if even_count % 2 == 0 and odd_count % 2 != 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def import import os , sys , traceback NEW_LINE from io import StringIO NEW_LINE import sys NEW_LINE import random NEW_LINE import sys NEW_LINE import sys NEW_LINE import itertools NEW_LINE import itertools NEW_LINE import os . path NEW_LINE import sys NEW_LINE sys . stdin = StringIO ( sys . stdin ) NEW_LINE sys . stdout . write ( ' \n ' ) NEW_LINE sys . stdout = open ( sys . stdin , ' r ' ) NEW_LINE n = sys . stdin . readline ( ) . strip ( ) NEW_LINE k = sys . stdin . readline ( ) . strip ( ) NEW_LINE lists = [ ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT lists . append ( [ ] ) NEW_LINE for c in range ( n ) : NEW_LINE INDENT g = sys . stdin . read ( ) . strip ( ) NEW_LINE lists [ g ] . append ( c ) NEW_LINE DEDENT DEDENT dp = [ 0 ] * ( k + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT lists [ i ] . sort ( reverse = True ) NEW_LINE for j in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if dp [ j ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT sum = 0 NEW_LINE for l in lists [ i ] [ j : j + l + k ] : NEW_LINE INDENT sum += l NEW_LINE dp [ j + l + 1 ] = max ( dp [ j + l + 1 ] , dp [ j ] + sum + ( l + 1 ) * l ) NEW_LINE DEDENT DEDENT print ( dp [ k ] ) NEW_LINE DEDENT
def import _getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_getitem_
def maxGCD ( N , P ) : NEW_LINE INDENT from sympy . polys . polyroots import RootOf NEW_LINE class Solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . ans = 1 NEW_LINE DEDENT DEDENT prime_factors = { } NEW_LINE for i in range ( 2 , 2 * i <= P + 1 ) : NEW_LINE INDENT while P % i == 0 : NEW_LINE INDENT if not prime_factors [ i ] : NEW_LINE INDENT prime_factors [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime_factors [ i ] = ( prime_factors [ i ] + 1 ) NEW_LINE DEDENT P /= i NEW_LINE DEDENT DEDENT if P != 1 : NEW_LINE INDENT if not prime_factors [ P ] : NEW_LINE INDENT prime_factors [ P ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime_factors [ P ] = ( prime_factors [ P ] + 1 ) NEW_LINE DEDENT st = prime_factors . items ( ) NEW_LINE for me , n in st : NEW_LINE INDENT self . ans *= pow ( me , n // N ) NEW_LINE DEDENT DEDENT return Solution ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE from math import pow NEW_LINE from random import choice NEW_LINE n = randint ( 1 , n ) NEW_LINE k = randint ( 1 , k ) NEW_LINE mask = choice ( range ( k ) ) NEW_LINE for i in range ( pow ( 2 , k ) ) : NEW_LINE INDENT bitlist = [ 0 ] * n NEW_LINE temp = i NEW_LINE index = 0 NEW_LINE for j in range ( 0 , temp ) : NEW_LINE INDENT if temp % 2 == 1 : NEW_LINE INDENT bitlist [ mask [ j ] ] = 1 NEW_LINE index += pow ( 2 , mask [ j ] ) NEW_LINE DEDENT temp /= 2 NEW_LINE DEDENT print ( " % d : " % index , end = ' ▁ ' ) NEW_LINE for j in range ( k ) : NEW_LINE INDENT if bitlist [ mask [ j ] ] == 1 : NEW_LINE INDENT print ( " ▁ " , mask [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def import _sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT class PrimeFactorization : NEW_LINE INDENT def __init__ ( self , count_of_pf , prime_factor ) : NEW_LINE INDENT self . count_of_pf = count_of_pf NEW_LINE self . prime_factor = prime_factor NEW_LINE DEDENT DEDENT def generate_divisors ( cur_index , cur_divisor , arr ) : NEW_LINE INDENT if cur_index == len ( arr ) : NEW_LINE INDENT print ( cur_divisor , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , arr [ cur_index ] . count_of_pf ) : NEW_LINE INDENT generate_divisors ( cur_index + 1 , cur_divisor , arr ) NEW_LINE cur_divisor *= arr [ cur_index ] . prime_factor NEW_LINE DEDENT DEDENT def find_divisors ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE for i in range ( 2 , n ** 2 + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT count = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT n //= i NEW_LINE count += 1 NEW_LINE DEDENT arr . append ( ( count , i ) ) NEW_LINE DEDENT DEDENT if n > 1 : NEW_LINE INDENT arr . append ( ( 1 , n ) ) NEW_LINE DEDENT cur_index , cur_divisor = 0 , 1 NEW_LINE generate_divisors ( cur_index , cur_divisor , arr ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 6 NEW_LINE find_divisors ( n ) NEW_LINE DEDENT DEDENT
def import os , sys , stdin , stdout , stderr , line , n , beacon , dp , beacon , beacon , beacon , dp , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , dp , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , beacon , ) NEW_LINE
def largestPalinSub ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s [ 0 ] NEW_LINE for c in s [ 1 : ] : mx = chr ( max ( ord ( c ) , ord ( c ) ) ) NEW_LINE for c in s : NEW_LINE INDENT if c == mx : res += c NEW_LINE DEDENT return res NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = sys . stdin NEW_LINE while 1 : NEW_LINE INDENT n = self . sc . readline ( ) . strip ( ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT s = self . sc . readline ( ) . strip ( ) NEW_LINE if not s : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s = s . decode ( ' utf - 8' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT n = self . sc . readline ( ) . strip ( ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT s = s . decode ( ' utf - 8' ) NEW_LINE if not s : NEW_LINE INDENT break NEW_LINE DEDENT t = s . decode ( ' utf - 8' ) NEW_LINE u = ' ' NEW_LINE for k in range ( n ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT count = 1 NEW_LINE t = s [ i ] NEW_LINE while i < len ( s ) - 1 and s [ i + 1 ] == t : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT u += str ( count ) + chr ( t ) NEW_LINE DEDENT s = u + s NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT DEDENT
def import _sys , StringIO , glob , glob , dp NEW_LINE class Good_seq ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = sc NEW_LINE self . logfile = sys . stdout NEW_LINE self . dp = [ 0 ] * 100001 NEW_LINE DEDENT def factoriseopt ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE if n == 1 : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE return ans NEW_LINE DEDENT for i in range ( 2 , 2 * i <= n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT cnt = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n = n / i NEW_LINE DEDENT ans . append ( i ) NEW_LINE DEDENT DEDENT if n != 1 : NEW_LINE INDENT ans . append ( n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = glob ( " { } / * " . format ( n ) ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( sc . choice ( arr ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT anslist = factoriseopt ( arr [ i ] ) NEW_LINE best = 0 NEW_LINE for x in anslist : NEW_LINE INDENT best = max ( best , dp [ x ] ) NEW_LINE DEDENT for x in anslist : NEW_LINE INDENT dp [ x ] = best + 1 NEW_LINE DEDENT DEDENT maxsofar = 0 NEW_LINE for x in dp : NEW_LINE INDENT maxsofar = max ( maxsofar , x ) NEW_LINE DEDENT print ( maxsofar ) NEW_LINE DEDENT DEDENT
def GFG ( A , D ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D [ 0 ] = A [ 0 ] NEW_LINE D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT A [ i ] = D [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT print ( A [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE return 0 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE n = len ( A ) NEW_LINE D = zeros ( n + 1 ) NEW_LINE initializeDiffArray ( A , D ) NEW_LINE update ( D , 0 , 1 , 10 ) NEW_LINE printArray ( A , D ) NEW_LINE update ( D , 1 , 3 , 20 ) NEW_LINE update ( D , 2 , 2 , 30 ) NEW_LINE printArray ( A , D ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def test_find_max_guests ( arrl , exit , n ) : NEW_LINE INDENT import random NEW_LINE arrl = [ random . randint ( 0 , 1 ) for _ in arrl ] NEW_LINE exit = [ random . randint ( 0 , 1 ) for _ in exit ] NEW_LINE guests_in , max_guests , time = 1 , 1 , arrl [ 0 ] NEW_LINE i , j = 1 , 0 NEW_LINE while i < n and j < n : NEW_LINE INDENT if arrl [ i ] <= exit [ j ] : NEW_LINE INDENT guests_in += 1 NEW_LINE if guests_in > max_guests : NEW_LINE INDENT max_guests , time = guests_in , arrl [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT guests_in -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ { } ▁ at ▁ time ▁ { } " . format ( max_guests , time ) ) NEW_LINE DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def run ( self ) : NEW_LINE INDENT for line in self . input : NEW_LINE INDENT if line == ' # END ' : NEW_LINE INDENT return NEW_LINE DEDENT ans = ' ' NEW_LINE for i in range ( 1 , len ( line ) ) : NEW_LINE INDENT lcs = lcs ( line [ : i ] , line [ i : ] ) NEW_LINE if len ( lcs ) > len ( ans ) : NEW_LINE INDENT ans = lcs NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT def lcs ( s , t ) : NEW_LINE INDENT n = len ( s ) NEW_LINE m = len ( t ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) * ( m + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if s [ i ] == t [ j ] : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = [ ] NEW_LINE while n > 0 and m > 0 : NEW_LINE INDENT if dp [ n ] [ m ] == dp [ n - 1 ] [ m ] : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT elif dp [ n ] [ m ] == dp [ n ] [ m - 1 ] : NEW_LINE INDENT m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( s [ n - 1 ] ) NEW_LINE n -= 1 NEW_LINE m -= 1 NEW_LINE DEDENT DEDENT return str ( res ) NEW_LINE DEDENT DEDENT return Main NEW_LINE DEDENT
def calc_function ( n , r ) : NEW_LINE INDENT final_denominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = int ( math . pow ( i , i ) ) NEW_LINE numerator = int ( math . pow ( i - mx , i - mx ) ) NEW_LINE final_denominator = ( final_denominator * denominator ) / numerator NEW_LINE DEDENT return final_denominator NEW_LINE DEDENT
def test_gf_square_algorithm ( ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . sr = int ( math . sqrt ( x ) ) NEW_LINE if self . sr ** 2 == x : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n , k = 7 , 2 NEW_LINE return GFG ( n + k ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def import _number , ** kwargs ) : NEW_LINE INDENT import random NEW_LINE class Main ( int ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . NUM = int ( 1e5 + 2 ) NEW_LINE DEDENT DEDENT sc = _number ( ) NEW_LINE N = sc . number NEW_LINE d = { } NEW_LINE nums = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = random . randrange ( 1 , N ) NEW_LINE nums . append ( tmp ) NEW_LINE d [ tmp ] = i NEW_LINE DEDENT bin = 0 NEW_LINE diff = 0 NEW_LINE while not nums . empty ( ) : NEW_LINE INDENT num = nums . pop ( ) NEW_LINE idx = d [ num ] NEW_LINE if ( bin % 2 ) != ( idx % 2 ) : NEW_LINE INDENT diff += 1 NEW_LINE DEDENT bin += 1 NEW_LINE bin %= 2 NEW_LINE DEDENT ans = ( diff / 2 ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def import import sys NEW_LINE from StringIO import StringIO NEW_LINE from itertools import islice NEW_LINE from itertools import islice NEW_LINE try : NEW_LINE INDENT with open ( sys . stdin , ' r ' ) as infile : NEW_LINE INDENT n = infile . tell ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT value = islice ( infile , i + 1 , None ) NEW_LINE a . append ( value ) NEW_LINE DEDENT a = a . distinct ( ) NEW_LINE found = False NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if i + 1 < len ( a ) and i + 2 < len ( a ) : NEW_LINE INDENT if a [ i ] + 1 == a [ i + 1 ] and a [ i + 1 ] + 1 == a [ i + 2 ] : NEW_LINE INDENT found = True NEW_LINE DEDENT DEDENT DEDENT print ( ' YES ' if found else ' NO ' ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT import sys NEW_LINE import gc NEW_LINE class Main ( object ) : NEW_LINE INDENT def check ( b ) : NEW_LINE INDENT if b [ 0 ] != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 1 , len ( b ) ) : NEW_LINE INDENT if b [ i - 1 ] != b [ i ] - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def gap ( b ) : NEW_LINE INDENT for i in range ( len ( b ) ) : NEW_LINE INDENT if b [ i ] <= 0 : NEW_LINE INDENT b . pop ( i ) NEW_LINE i -= 1 NEW_LINE continue NEW_LINE DEDENT DEDENT b . trimToSize ( ) NEW_LINE DEDENT def removeGap ( b ) : NEW_LINE INDENT for i in range ( len ( b ) ) : NEW_LINE INDENT if b [ i ] <= 0 : NEW_LINE INDENT b . pop ( i ) NEW_LINE i -= 1 NEW_LINE continue NEW_LINE DEDENT DEDENT b . trimToSize ( ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT stdIn = sys . stdin NEW_LINE list = [ ] NEW_LINE while True : NEW_LINE INDENT N = stdIn . readline ( ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT list . append ( stdIn . readline ( ) ) NEW_LINE DEDENT c = 0 NEW_LINE while not check ( list ) and c < 10000 : NEW_LINE INDENT c += 1 NEW_LINE if gap ( list ) : NEW_LINE INDENT size = len ( list ) NEW_LINE for i in range ( len ( list ) ) : NEW_LINE INDENT list [ i ] = list [ i ] - 1 NEW_LINE DEDENT list . append ( size ) NEW_LINE DEDENT removeGap ( list ) NEW_LINE DEDENT print ( ( check ( list ) ) , c ) NEW_LINE list = [ ] NEW_LINE list . trimToSize ( ) NEW_LINE gc . collect ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def isdivisible ( S ) : NEW_LINE INDENT import re NEW_LINE if re . search ( r ' \d + ' , S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if S [ n - 1 ] != '5' and S [ n - 1 ] != '0' : return False NEW_LINE sum = 0 NEW_LINE for i in range ( len ( S ) ) : sum += ord ( S [ i ] ) NEW_LINE if sum % 3 == 0 : return True NEW_LINE else : return False NEW_LINE DEDENT else : NEW_LINE INDENT S = '15645746327462384723984023940239' NEW_LINE if isdivisible ( S ) == True : print ( ' Yes ' ) NEW_LINE else : print ( ' No ' ) NEW_LINE S1 = '15645746327462384723984023940235' NEW_LINE if isdivisible ( S1 ) == True : print ( ' Yes ' ) NEW_LINE else : print ( ' No ' ) NEW_LINE DEDENT DEDENT
def p142 ( ) : NEW_LINE INDENT print ( eval ( ' p142 ( ) ' ) ) NEW_LINE def run ( ) : NEW_LINE INDENT sum_limit = 10 NEW_LINE while 1 : NEW_LINE INDENT is_square = [ True ] * sum_limit NEW_LINE sum = find_sum ( sum_limit ) NEW_LINE if sum != - 1 : NEW_LINE INDENT sum = sum_limit NEW_LINE break NEW_LINE DEDENT sum_limit *= 10 NEW_LINE DEDENT while 1 : NEW_LINE INDENT sum = find_sum ( sum_limit ) NEW_LINE if sum == - 1 : NEW_LINE INDENT return str ( sum_limit ) NEW_LINE DEDENT sum_limit = sum NEW_LINE DEDENT DEDENT def find_sum ( limit ) : NEW_LINE INDENT for a in range ( 1 , limit ) : NEW_LINE INDENT for b in range ( a - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( a + b ) % 2 : NEW_LINE INDENT continue NEW_LINE DEDENT x = ( a ** 2 + b ** 2 ) / 2 NEW_LINE y = ( a ** 2 - b ** 2 ) / 2 NEW_LINE if x + y + 1 >= limit : NEW_LINE INDENT continue NEW_LINE DEDENT zlimit = min ( y , limit - x - y ) NEW_LINE for c in lib . sqrt ( y ) + 1 , lib . sqrt ( c - y ) , lib . sqrt ( c - z ) : NEW_LINE INDENT z = c * c - y NEW_LINE if is_square [ x + z ] and is_square [ x - z ] and is_square [ y - z ] : NEW_LINE INDENT return x , y , z NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return None NEW_LINE DEDENT
def GFG ( c ) : return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE def encryptString ( s , n , k ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE ans = " " NEW_LINE for l in range ( 0 , n - k ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE for r in range ( l , l + k - 1 ) : NEW_LINE INDENT if isVowel ( s [ r ] ) == True : NEW_LINE INDENT countVowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countConsonants += 1 NEW_LINE DEDENT DEDENT ans += str ( countVowels * countConsonants ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from math import gcd NEW_LINE for N , M , S , T in sys . stdin : NEW_LINE INDENT gcdNM = gcd ( N , M ) NEW_LINE lcmNM = ( long ( N ) / gcd ( N , M ) ) * M NEW_LINE stepS = M / gcdNM NEW_LINE stepT = N / gcdNM NEW_LINE curS = 0 NEW_LINE curT = 0 NEW_LINE isExisted = True NEW_LINE while curS < len ( S ) and curT < len ( T ) : NEW_LINE INDENT idxXS = curS * stepS + 1 NEW_LINE idxXT = curT * stepT + 1 NEW_LINE if idxXS == idxXT : NEW_LINE INDENT if S [ curS ] != T [ curT ] : NEW_LINE INDENT isExisted = False NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT curS += 1 NEW_LINE curT += 1 NEW_LINE DEDENT DEDENT elif idxXS < idxXT : NEW_LINE INDENT curS += 1 NEW_LINE DEDENT elif idxXT < idxXS : NEW_LINE INDENT curT += 1 NEW_LINE DEDENT DEDENT if isExisted : NEW_LINE INDENT print ( lcmNM ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT def gcd ( a , b ) : NEW_LINE INDENT return b , a % b NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class B203 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stdin = sys . stdin NEW_LINE self . N = self . N NEW_LINE self . M = self . M NEW_LINE self . black = [ ] NEW_LINE for m in range ( 1 , M + 1 ) : NEW_LINE INDENT x = self . N NEW_LINE y = self . N NEW_LINE for xx in range ( x - 1 , x + 1 ) : NEW_LINE INDENT for yy in range ( y - 1 , y + 1 ) : NEW_LINE INDENT if 1 == black [ xx ] [ yy ] == 9 : NEW_LINE INDENT self . print ( m ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def import sys NEW_LINE from py2exe import Scanner NEW_LINE dx = { 1 : 1 , 0 : - 1 , } NEW_LINE dy = { 0 : 1 , 1 : 1 , 1 : 1 } NEW_LINE for _ in range ( sys . stdin . readline ( ) . rstrip ( ) ) : NEW_LINE INDENT n = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE if n == 0 : return NEW_LINE a = [ ] NEW_LINE ans = 0 NEW_LINE for s in sys . stdin . readlines ( ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a . append ( [ int ( s [ i ] ) - '0' for i in range ( n ) ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( 4 ) : NEW_LINE INDENT cnt = 0 NEW_LINE sy = i NEW_LINE sx = j NEW_LINE while 0 <= sx < n and sy < n and a [ sy ] [ sx ] == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE sx += dx [ k ] NEW_LINE sy += dy [ k ] NEW_LINE DEDENT ans = max ( ans , cnt ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import factorial NEW_LINE from math import log NEW_LINE class GFG ( factorial ) : NEW_LINE INDENT def fourth_power_sum ( self , n ) : NEW_LINE INDENT return ( ( 6 * n ** 3 * n ** 2 ) + ( 15 * n ** 3 * n ** 3 ) + ( 10 * n ** 3 * n ** 2 ) - n ) / 30 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 6 NEW_LINE print ( fourth_power_sum ( n ) ) NEW_LINE DEDENT DEDENT
def max_length_sub ( arr ) : NEW_LINE INDENT import collections NEW_LINE max_val = 0 NEW_LINE start = 0 NEW_LINE d = { } NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT temp = 0 NEW_LINE if arr [ i ] - 1 in d : NEW_LINE INDENT temp = d [ arr [ i ] - 1 ] NEW_LINE DEDENT if arr [ i ] in d : NEW_LINE INDENT temp = max ( temp , d [ arr [ i ] ] ) NEW_LINE DEDENT if arr [ i ] + 1 in d : NEW_LINE INDENT temp = max ( temp , d [ arr [ i ] + 1 ] ) NEW_LINE DEDENT temp += 1 NEW_LINE if temp > max_val : NEW_LINE INDENT max_val = temp NEW_LINE DEDENT d [ arr [ i ] ] = temp NEW_LINE DEDENT return max_val NEW_LINE DEDENT
def gf_rearrange ( arr ) : NEW_LINE INDENT import sys NEW_LINE if not arr or len ( arr ) % 2 == 1 : NEW_LINE INDENT return NEW_LINE DEDENT curr_idx = ( len ( arr ) - 1 ) // 2 NEW_LINE while curr_idx > 0 : NEW_LINE INDENT count , swap_idx = curr_idx , curr_idx NEW_LINE while count : NEW_LINE INDENT temp = arr [ swap_idx + 1 ] NEW_LINE arr [ swap_idx + 1 ] = arr [ swap_idx ] NEW_LINE arr [ swap_idx ] = temp NEW_LINE swap_idx += 1 NEW_LINE DEDENT curr_idx -= 1 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 2 , 4 , 6 ] NEW_LINE return arr NEW_LINE DEDENT rearrange ( main ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT sys . stdout . write ( ' ▁ ' + str ( arr [ i ] ) + ' \n ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE from math import ceil NEW_LINE from math import log NEW_LINE from math import sin , cos , log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE INF = 1 << 58 NEW_LINE while 1 : NEW_LINE INDENT n , k = randint ( 1 , 128 ) NEW_LINE if ( n | k ) == 0 : break NEW_LINE fare = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT [ f , i ] = INF NEW_LINE fare . append ( [ 0 ] * ( n - k ) ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT init = randint ( 1 , n ) NEW_LINE if init == 1 : NEW_LINE INDENT c , d , e = randint ( 1 , n - 1 ) NEW_LINE if e < fare [ c ] [ d ] : NEW_LINE INDENT fare [ c ] [ d ] = fare [ d ] [ c ] = e NEW_LINE for p in range ( n ) : NEW_LINE INDENT for q in range ( n ) : NEW_LINE INDENT fare [ p ] [ q ] = min ( fare [ p ] [ q ] , fare [ p ] [ c ] + fare [ c ] [ d ] + fare [ d ] [ q ] ) NEW_LINE fare [ p ] [ q ] = min ( fare [ p ] [ q ] , fare [ p ] [ d ] + fare [ c ] [ d ] + fare [ c ] [ q ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT a , b = randint ( 1 , n - 1 ) , randint ( 1 , n - 1 ) NEW_LINE print ( fare [ a ] [ b ] != INF ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def count_character_type ( data ) : NEW_LINE INDENT import unicodedata NEW_LINE vowels , consonant , special_char , digit = 0 , 0 , 0 , 0 NEW_LINE for ch in data : NEW_LINE INDENT if ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) : NEW_LINE INDENT ch = unicodedata . normalize ( ' NFKD ' , ch ) . lower ( ) NEW_LINE if ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ch in [ '0' , '9' ] : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT special_char += 1 NEW_LINE DEDENT DEDENT print ( " Vowels : ▁ % d " % vowels ) NEW_LINE print ( " Consonant : ▁ % d " % consonant ) NEW_LINE print ( " Digit : ▁ % d " % digit ) NEW_LINE print ( " Special ▁ Character : ▁ % d " % special_char ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT percent_inc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) NEW_LINE percent_inc -= 1 NEW_LINE percent_inc *= 100 NEW_LINE return percent_inc NEW_LINE DEDENT
def __maxTotalRectangleArea ( a , n ) : NEW_LINE INDENT import sys NEW_LINE from math import sin , cos , tan , pi NEW_LINE a = list ( a ) NEW_LINE sum = 0 NEW_LINE flag = 0 NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and not flag : NEW_LINE INDENT flag = 1 NEW_LINE len = a [ i + 1 ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and ( flag ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next , self . prev = data NEW_LINE DEDENT def getNode ( self ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = self . data NEW_LINE return new_node NEW_LINE DEDENT def insertEnd ( self , head , new_node ) : NEW_LINE INDENT if not head : NEW_LINE INDENT new_node . next = new_node . prev = new_node NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT last = ( head . prev , ) NEW_LINE new_node . next = head NEW_LINE ( head . prev , ) = new_node NEW_LINE new_node . prev = last NEW_LINE last . next = new_node NEW_LINE return head NEW_LINE DEDENT def reverse ( self ) : NEW_LINE INDENT if not head : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE last = head . prev NEW_LINE curr = last , prev NEW_LINE while curr . prev != last : NEW_LINE INDENT prev = curr . prev NEW_LINE new_head = insertEnd ( new_head , curr ) NEW_LINE curr = prev NEW_LINE DEDENT new_head = insertEnd ( new_head , curr ) NEW_LINE return new_head NEW_LINE DEDENT def display ( self ) : NEW_LINE INDENT if not head : NEW_LINE INDENT return None NEW_LINE DEDENT temp = self NEW_LINE print ( " Forward ▁ direction : ▁ " , end = " ▁ " ) NEW_LINE while temp . next != head : NEW_LINE INDENT print ( temp . data , end = " ▁ " ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data , end = " ▁ " ) NEW_LINE last = head . prev NEW_LINE temp = self NEW_LINE print ( " \n Backward ▁ direction : ▁ " , end = " ▁ " ) NEW_LINE while temp . prev != last : NEW_LINE INDENT print ( temp . data , end = " ▁ " ) NEW_LINE temp = temp . prev NEW_LINE DEDENT print ( temp . data , end = " ▁ " ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT head = None NEW_LINE head = insertEnd ( head , getNode ( 1 ) ) NEW_LINE head = insertEnd ( head , getNode ( 2 ) ) NEW_LINE head = insertEnd ( head , getNode ( 3 ) ) NEW_LINE head = insertEnd ( head , getNode ( 4 ) ) NEW_LINE head = insertEnd ( head , getNode ( 5 ) ) NEW_LINE print ( " Current ▁ list : \n " ) NEW_LINE display ( head ) NEW_LINE head = reverse ( head ) NEW_LINE print ( " \n \n Reversed ▁ list : \n " ) NEW_LINE display ( head ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE def main ( ) : NEW_LINE INDENT n = 12345 NEW_LINE return NEW_LINE DEDENT return main NEW_LINE DEDENT
def test_p080 ( ) : NEW_LINE INDENT import math NEW_LINE print ( math . pow ( 100 , 2 ) ) NEW_LINE def run ( ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , 100 + 1 ) : NEW_LINE INDENT x = math . pow ( i , 2 ) NEW_LINE x = x * math . pow ( 100 , 2 ) NEW_LINE y = sqrt ( x ) NEW_LINE if not y * y == x : NEW_LINE INDENT s = str ( y ) [ : 100 ] NEW_LINE for c in s : NEW_LINE INDENT sum += c - '0' NEW_LINE DEDENT DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT def sqrt ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while math . pow ( i , 2 ) <= x : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = 0 NEW_LINE for i in range ( 0 , - 1 , - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE delta = None NEW_LINE for j in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT temp = math . pow ( j , 2 ) * math . pow ( i , 2 ) NEW_LINE delta = y >> 1 + temp * temp NEW_LINE if delta <= x : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j < 0 : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT x = x - delta NEW_LINE y = y + math . pow ( j , 2 ) NEW_LINE DEDENT return y NEW_LINE DEDENT return run NEW_LINE DEDENT
def evaluate ( n ) : NEW_LINE INDENT import sys NEW_LINE if n == 1 or n == 2 : NEW_LINE INDENT print ( " No ▁ Pythagoras ▁ " + " Triplet ▁ exists " ) NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT var = 1 * n ** 2 / 4 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ " + " exist ▁ i . e . ▁ " , end = " " ) NEW_LINE print ( n , end = " " ) NEW_LINE print ( var - 1 , end = " " ) NEW_LINE print ( var + 1 , end = " " ) NEW_LINE DEDENT elif n % 2 != 0 : NEW_LINE INDENT var = 1 * n ** 2 + 1 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ " + " exist ▁ i . e . ▁ " , end = " " ) NEW_LINE print ( n , end = " " ) NEW_LINE print ( var / 2 - 1 , end = " " ) NEW_LINE print ( var / 2 , end = " " ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = sys . maxint NEW_LINE self . b = sys . maxint NEW_LINE self . x = sys . maxint NEW_LINE count = 0 NEW_LINE count += b / self . x + 1 NEW_LINE if self . a != 0 : NEW_LINE INDENT count -= ( self . a - 1 ) / self . x + 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import gcd NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : return b NEW_LINE return gcd ( b % a , a ) NEW_LINE DEDENT def find_number ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == ans : return ans NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_number ( arr , n ) ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def count_kdiv_pairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rem = A [ i ] % K NEW_LINE if rem != 0 : NEW_LINE INDENT ans += freq [ K - rem ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += freq [ 0 ] NEW_LINE DEDENT freq [ rem ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from os import urandom NEW_LINE from random import randint NEW_LINE from time import sleep NEW_LINE a , b , c = getrandbits ( 1 ) NEW_LINE print ( a , b , c ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE from math import log NEW_LINE from math import radians NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE nums = [ log ( x ) for x in range ( n ) ] NEW_LINE l , r = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l == 0 and nums [ n - i - 1 ] != nums [ 0 ] : NEW_LINE INDENT l = n - i - 1 NEW_LINE DEDENT if r == 0 and nums [ i ] != nums [ n - 1 ] : NEW_LINE INDENT r = n - i - 1 NEW_LINE DEDENT DEDENT print ( max ( l , r ) ) NEW_LINE DEDENT
def count_subarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 1 ] * ( n + 1 ) NEW_LINE hash_negative = [ 1 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] & 1 == 1 : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if difference < 0 : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def import _geeksforgeeks NEW_LINE SIZE = 26 NEW_LINE def printChar ( data , n ) : NEW_LINE INDENT freq = { } NEW_LINE for c in data : NEW_LINE INDENT freq [ c - ' a ' ] += 1 NEW_LINE DEDENT for c in data : NEW_LINE INDENT if freq [ c - ' a ' ] % 2 == 0 : NEW_LINE INDENT print ( c , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for c in str : NEW_LINE INDENT freq [ c - ' a ' ] += 1 NEW_LINE DEDENT for c in str : NEW_LINE INDENT if freq [ c - ' a ' ] % 2 == 1 : NEW_LINE INDENT print ( c , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT str = ' geeksforgeeks ' NEW_LINE n = len ( str ) NEW_LINE print ( str , n ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE left_greater = n NEW_LINE while l <= r : NEW_LINE INDENT m = l + ( r - l ) / 2 NEW_LINE if arr [ m ] > k : NEW_LINE INDENT left_greater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ( n - left_greater ) NEW_LINE DEDENT
def import _main NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy . random as np NEW_LINE import numpy . random as np NEW_LINE import random NEW_LINE INF = 1 << 28 NEW_LINE EPS = 1e-10 NEW_LINE MOD = 1000000 NEW_LINE es = [ [ 0 , 1 , 2 , 3 ] , [ 0 , 1 , 2 ] , [ 0 , 1 , 2 , 4 ] , [ 2 , 3 ] , [ 0 , 4 ] ] NEW_LINE shape = ( 5 , ) NEW_LINE def run ( ) : NEW_LINE INDENT with open ( ' input . txt ' , ' r ' ) as f : NEW_LINE INDENT h , w = np . random . randint ( INF , size = ( INF , INF ) ) NEW_LINE if w == 1 : NEW_LINE INDENT ret = 1 NEW_LINE for i in range ( h ) : NEW_LINE INDENT ret = ret * 2 % MOD NEW_LINE DEDENT print ( ret ) NEW_LINE return NEW_LINE DEDENT cnt = np . zeros ( ( 2 , len ( es ) ) ) NEW_LINE cnt [ 0 , 0 ] = 1 NEW_LINE p = 1 NEW_LINE for i in range ( 0 , h ) : NEW_LINE INDENT fill ( cnt [ p ] , 0 ) NEW_LINE for j in range ( len ( es ) ) : NEW_LINE INDENT for k in es [ j ] : NEW_LINE INDENT cnt [ p ] [ es [ j ] [ k ] ] = ( cnt [ p ] [ es [ j ] [ k ] ] + cnt [ 1 - p ] [ j ] ) % MOD NEW_LINE DEDENT DEDENT p = 1 - p NEW_LINE DEDENT print ( cnt [ 1 - p ] [ 2 ] ) NEW_LINE DEDENT def debug ( * os ) : NEW_LINE INDENT print ( np . std ( os . read ( ' output . txt ' ) , dtype = np . float32 ) , file = sys . stderr ) NEW_LINE DEDENT DEDENT
def find_a_and_b ( N ) : NEW_LINE INDENT val = N ** 2 - 4.0 * N NEW_LINE if val < 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT a = ( N + math . sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - math . sqrt ( val ) ) / 2.0 NEW_LINE print ( " a ▁ = ▁ " , a ) NEW_LINE print ( " b ▁ = ▁ " , b ) NEW_LINE DEDENT
def import import _submit_main NEW_LINE class submit_main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . raw_input = raw_input NEW_LINE DEDENT def submit ( self ) : NEW_LINE INDENT self . raw_input = raw_input NEW_LINE self . t = 0 NEW_LINE while self . t != 0 : NEW_LINE INDENT n = self . raw_input ( ) NEW_LINE x , y = self . raw_input ( ) NEW_LINE temp1 , temp2 = self . raw_input ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = self . raw_input ( ) NEW_LINE temp1 = max ( temp1 , x ) NEW_LINE temp2 = min ( temp2 , y ) NEW_LINE DEDENT print ( max ( 0 , ( temp1 - temp2 ) ) ) NEW_LINE self . t -= 1 NEW_LINE DEDENT DEDENT DEDENT
def import java . util . regex NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . Set = set ( ) NEW_LINE DEDENT def n ( self ) : NEW_LINE INDENT return self . Set . n NEW_LINE DEDENT def m ( self ) : NEW_LINE INDENT return self . Set . m NEW_LINE DEDENT for x in java . util . regex . finditer ( java . util . regex . re . search ( ' X ( \d + ) ' , ' ( ? : [ ^ ' , ] * ) ' ) ) : NEW_LINE INDENT if x in java . util . regex . finditer ( java . util . regex . re . search ( ' X ( \d + ) ' , ' ( ? : [ ^ ' , ] * ) ' ) ) : NEW_LINE INDENT self . Set . add ( x ) NEW_LINE DEDENT DEDENT if len ( self . Set ) == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE MOD = 1000000007 NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MOD = 1000000007 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT sc = random . choice ( args ) NEW_LINE while True : NEW_LINE INDENT aa = sc . choice ( [ ' ' , ' ' , ' ' , ' ' ] ) NEW_LINE if aa [ 0 ] == '0' : NEW_LINE INDENT break NEW_LINE DEDENT bb = sc . choice ( [ ' ' , ' ' , ' ' , ' ' ] ) NEW_LINE cc = sc . choice ( [ ' ' , ' ' , ' ' , ' ' ] ) NEW_LINE n = len ( aa ) NEW_LINE dp = [ [ 1 ] * ( n + 1 ) for i in range ( 1 , n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT da = aa [ n - i ] == ' ? ' and - 1 or aa [ n - i ] - '0' NEW_LINE db = bb [ n - i ] == ' ? ' and - 1 or bb [ n - i ] - '0' NEW_LINE dc = cc [ n - i ] == ' ? ' and - 1 or cc [ n - i ] - '0' NEW_LINE for j in range ( 2 ) : NEW_LINE INDENT for carry in range ( 2 ) : NEW_LINE INDENT patterns = 0 NEW_LINE for a in range ( 10 ) : NEW_LINE INDENT if da != - 1 and da != a : NEW_LINE INDENT continue NEW_LINE DEDENT for b in range ( 10 ) : NEW_LINE INDENT if db != - 1 and db != b : NEW_LINE INDENT continue NEW_LINE DEDENT c = a + b + carry NEW_LINE if ( j == 0 and c >= 10 ) or ( j == 1 and c < 10 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if i == n : NEW_LINE INDENT if a * b * c == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if dc == - 1 or dc == c % 10 : NEW_LINE INDENT patterns += 1 NEW_LINE DEDENT DEDENT DEDENT dp [ i ] [ j ] += dp [ i - 1 ] [ carry ] * patterns % MOD NEW_LINE dp [ i ] [ j ] %= MOD NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] [ 0 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_multiply ( ) : NEW_LINE INDENT import sys NEW_LINE class Multiply ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = 1 NEW_LINE self . two = 0 NEW_LINE self . three = 0 NEW_LINE while self . a % 2 == 0 : NEW_LINE INDENT self . a = self . a // 2 NEW_LINE self . two += 1 NEW_LINE DEDENT while self . a % 3 == 0 : NEW_LINE INDENT self . a = self . a // 3 NEW_LINE self . three += 1 NEW_LINE DEDENT if self . a == 1 : NEW_LINE INDENT if self . three >= self . two : NEW_LINE INDENT temp = self . two NEW_LINE self . three -= self . two NEW_LINE temp += self . three * 2 NEW_LINE print ( temp ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def minIncrementForUnique ( A ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . A = A NEW_LINE DEDENT DEDENT mpp = { } NEW_LINE for i in A : NEW_LINE INDENT if i in mpp : NEW_LINE INDENT mpp [ i ] = mpp [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ i ] = 1 NEW_LINE DEDENT DEDENT taken = [ ] NEW_LINE ans = 0 NEW_LINE for x in range ( 100000 ) : NEW_LINE INDENT if x in mpp and mpp [ x ] >= 2 : NEW_LINE INDENT taken . append ( x * ( mpp [ x ] - 1 ) ) NEW_LINE DEDENT elif len ( taken ) > 0 and ( ( x in mpp and mpp [ x ] == 0 ) or x not in mpp ) : NEW_LINE INDENT ans += x - taken [ - 1 ] NEW_LINE taken . pop ( ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT import os NEW_LINE import sys NEW_LINE import math NEW_LINE import os NEW_LINE import sys NEW_LINE MOD = 1000003 NEW_LINE def f ( ) : NEW_LINE INDENT f = open ( sys . stdin , ' r ' ) NEW_LINE f = open ( sys . stdout , ' w ' ) NEW_LINE n = int ( f . readline ( ) ) NEW_LINE ans = 1 if n == 0 else pow ( 3 , n - 1 , MOD ) NEW_LINE f . write ( ans ) NEW_LINE f . close ( ) NEW_LINE return ans NEW_LINE DEDENT def pow ( a , p , m ) : NEW_LINE INDENT if p == 0 : return long ( 1 ) % m NEW_LINE if p == 1 : return long ( a ) % m NEW_LINE v = pow ( a , p // 2 , m ) NEW_LINE ans = v * v % m NEW_LINE if p % 2 == 1 : ans = ans * a % m NEW_LINE return ans NEW_LINE DEDENT return f NEW_LINE DEDENT
def GFG ( s , n ) : NEW_LINE INDENT MOD = int ( 1e9 + 7 ) NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = [ [ 1 ] * 13 ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = s [ i ] - '0' NEW_LINE if s [ i ] == ' ? ' : NEW_LINE INDENT nxt = j NEW_LINE DEDENT for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 ** k + nxt ) % 13 NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] NEW_LINE dp [ i + 1 ] [ rem ] %= MOD NEW_LINE DEDENT if s [ i ] != ' ? ' : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ n ] [ 5 ] ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = ' ? 44' NEW_LINE n = len ( s ) NEW_LINE print ( modulo_13 ( s , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( a , b , c , d ) : NEW_LINE INDENT x = b // c - ( a - 1 ) // c NEW_LINE y = b // d - ( a - 1 ) // d NEW_LINE k = ( c * d ) // __gcd ( c , d ) NEW_LINE z = b // k - ( a - 1 ) // k NEW_LINE return b - a + 1 - x - y + z NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE class GFG ( math . Integral ) : NEW_LINE INDENT def print_substrings ( self , n ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) NEW_LINE d = int ( math . pow ( 10 , s ) + 0.5 ) NEW_LINE k = d NEW_LINE while n > 0 : NEW_LINE INDENT while d > 0 : NEW_LINE INDENT yield n // d NEW_LINE d = d // 10 NEW_LINE DEDENT n , k = n % k , k // 10 NEW_LINE d = k NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 123 NEW_LINE print_substrings ( n ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT s = " " NEW_LINE c = 1 NEW_LINE for i in range ( 1 ) : NEW_LINE INDENT if c < 10 : NEW_LINE INDENT s += str ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT s1 = " " NEW_LINE dup = c NEW_LINE while dup > 0 : NEW_LINE INDENT s1 += str ( dup % 10 ) NEW_LINE dup /= 10 NEW_LINE DEDENT temp = list ( s1 ) NEW_LINE temp = temp . reverse ( ) NEW_LINE s += temp NEW_LINE DEDENT c += 1 NEW_LINE if len ( s ) >= n : NEW_LINE INDENT return s [ n - 1 ] NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 11 NEW_LINE print ( NthCharacter ( n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from time import sleep NEW_LINE from random import choice NEW_LINE from time import sleep NEW_LINE n = choice ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , 19 ,
def check_prime ( n ) : NEW_LINE INDENT import re NEW_LINE if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n ** 2 + 6 ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def count_prime_frequent ( s ) : NEW_LINE INDENT count = 0 NEW_LINE mp = { } NEW_LINE for char in s : NEW_LINE INDENT if char in mp : NEW_LINE INDENT mp [ char ] = mp [ char ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ char ] = 1 NEW_LINE DEDENT DEDENT for char , count in mp . items ( ) : NEW_LINE INDENT if check_prime ( count ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = ' geeksforgeeks ' NEW_LINE print ( count_prime_frequent ( s ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import sys NEW_LINE import sys NEW_LINE input = input . input NEW_LINE n = input . count ( ) NEW_LINE m = input . count ( ) NEW_LINE req = [ input . get ( ) for _ in range ( n ) ] NEW_LINE pre = [ input . get ( ) for _ in range ( m ) ] NEW_LINE i , j = n - 1 , m - 1 NEW_LINE ans = 0 NEW_LINE while i >= 0 and j >= 0 : NEW_LINE INDENT if req [ i ] > pre [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT sys . stdout . write ( ans + str ( i + 1 ) ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT catalan = [ 1 , 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT
def test_p243 ( ) : NEW_LINE INDENT import math NEW_LINE print ( math . ceil ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math ( math . log ( ) , math . log ( math . log ( math . log ( math ( math . log ( math ( ) , math . log ( math . log ( math ( math . log ( math ( math . log ( math ( ) , math . log ( math ( math ( math ( ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) NEW_LINE DEDENT DEDENT class p243 NEW_LINE class C ( math math math math math math math math math math math math math math math math math math ( math math math math math ( math math math ( math math math math math math ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math . log ( math ( math . log ( math . log ( math ( math . log ( math . log ( math . log ( math ( math . log ( math . log ( math ( math . log ( math ( math . log ( math ( math . log ( math ( math . log ( math . log ( math ( math ( math ( math . ) ,
def import sys , string , ishu NEW_LINE def main ( ) : NEW_LINE INDENT global i , j , x , y , k , dx , dy NEW_LINE flag = True NEW_LINE while True : NEW_LINE INDENT s = string . ascii_lowercase NEW_LINE co = [ [ ] for i in range ( 2 , 101 ) ] NEW_LINE s = s . replace ( ' ' , ' ' ) NEW_LINE ch = s . replace ( ' ' , ' ' ) NEW_LINE co [ 0 ] [ k ] = x NEW_LINE co [ 1 ] [ k ] = y NEW_LINE k += 1 NEW_LINE for c in s : NEW_LINE INDENT if c == ' L ' : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT elif c == ' R ' : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif c == ' U ' : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif c == ' D ' : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT co [ 0 ] [ k ] = x NEW_LINE co [ 1 ] [ k ] = y NEW_LINE k += 1 NEW_LINE DEDENT for i in range ( k - 3 ) : NEW_LINE INDENT for j in range ( i + 3 , k ) : NEW_LINE INDENT dx = co [ 0 ] [ i ] - co [ 0 ] [ j ] NEW_LINE dy = co [ 1 ] [ i ] - co [ 1 ] [ j ] NEW_LINE if dx < 0 : NEW_LINE INDENT dx *= ( - 1 ) NEW_LINE DEDENT if dy < 0 : NEW_LINE INDENT dy *= ( - 1 ) NEW_LINE DEDENT if ( dx <= 1 and dy == 0 ) or ( dy <= 1 and dx == 0 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( ' OK ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' BUG ' ) NEW_LINE DEDENT DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : return False NEW_LINE for i in range ( 2 , math . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res *= ( 2 ** n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE from time import sleep NEW_LINE t = randint ( 1 , 10000 ) NEW_LINE for tc in range ( t ) : NEW_LINE INDENT n = randint ( 1 , 10000 ) NEW_LINE print ( solve ( n ) ) NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT if n <= 30 : NEW_LINE INDENT return ' NO ' NEW_LINE DEDENT elif n in [ 36 , 40 , 44 ] : NEW_LINE INDENT return ' YES \n 6 ▁ 10 ▁ 15 ▁ % d ' % ( n - 31 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ' YES \n 6 ▁ 10 ▁ 14 ▁ % d ' % ( n - 30 ) NEW_LINE DEDENT DEDENT return solve ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from sympy . core . compatibility import builtins NEW_LINE from sympy . core . compatibility import builtins NEW_LINE try : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT print ( " Input ▁ not ▁ a ▁ list " ) NEW_LINE return NEW_LINE DEDENT a = builtins . open ( " a " , " r " ) NEW_LINE ans = a . next ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = gcd ( ans , a [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT builtins . open ( " a " , " r " ) . next ( ) NEW_LINE builtins . open ( " b " , " w " ) . next ( ) NEW_LINE builtins . open ( " b " , " r " ) . next ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE from time import sleep NEW_LINE a = [ randint ( 1 , 14 ) for _ in range ( randint ( 1 , 14 ) ) ] NEW_LINE max = 0 NEW_LINE for from_time , stones in a : NEW_LINE INDENT remainder = stones // 14 NEW_LINE score = ( remainder if remainder % 2 == 0 else 0 ) NEW_LINE for i in range ( 1 , 14 ) : NEW_LINE INDENT count = a [ ( from_time + i ) % 14 ] + ( stones + 14 - i ) // 14 NEW_LINE if count % 2 == 0 : NEW_LINE INDENT score += count NEW_LINE DEDENT DEDENT max = max ( max , score ) NEW_LINE DEDENT print ( max ) NEW_LINE DEDENT
def GFG ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT
def GFG ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = float ( 1.73 ) * a NEW_LINE return d NEW_LINE DEDENT
def _ ( str ) : NEW_LINE INDENT import string NEW_LINE import string NEW_LINE if len ( str ) < 2 : return NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while j < len ( str ) - 1 : NEW_LINE INDENT if str [ j ] == ' A ' and str [ j + 1 ] == ' B ' : NEW_LINE INDENT j = j + 2 NEW_LINE str [ i ] = ' C ' NEW_LINE continue NEW_LINE DEDENT str [ i ] = str [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if j == len ( str ) - 1 : NEW_LINE INDENT str [ i ] = str [ j ] NEW_LINE DEDENT str [ i ] = ' ▁ ' NEW_LINE str [ len ( str ) - 1 ] = ' ▁ ' NEW_LINE DEDENT
def _ ( str ) : NEW_LINE INDENT import string NEW_LINE class GFG ( string . Template ) : NEW_LINE INDENT def translate ( self , str ) : NEW_LINE INDENT for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if str [ i - 1 ] == ' A ' and str [ i ] == ' B ' : NEW_LINE INDENT str [ i - 1 ] = ' C ' NEW_LINE j = i NEW_LINE for j in range ( i , len ( str ) - 1 ) : NEW_LINE INDENT str [ j ] = str [ j + 1 ] NEW_LINE DEDENT str [ j ] = ' ▁ ' NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT st = ' helloABworldABGfG ' NEW_LINE str = st . render ( ) NEW_LINE self . translate ( st ) NEW_LINE print ( ' The ▁ modified ▁ string ▁ is ▁ : ' ) NEW_LINE print ( str ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def p128 ( ) : NEW_LINE INDENT print ( eval ( ' p128 ( ) ' ) ) NEW_LINE TARGET = 2000 NEW_LINE def run ( ) : NEW_LINE INDENT count = 2 NEW_LINE for ring in range ( 2 ) : NEW_LINE INDENT if long ( ring ) * 12 + 5 > int ( ring ) : NEW_LINE INDENT raise OverflowError NEW_LINE DEDENT if library . is_prime ( ring * 6 - 1 ) and library . is_prime ( ring * 6 + 1 ) and library . is_prime ( ring * 12 + 5 ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return str ( long ( ring ) * ( ring - 1 ) * 3 + 2 ) NEW_LINE DEDENT DEDENT if library . is_prime ( ring * 6 - 1 ) and library . is_prime ( ring * 6 + 5 ) and library . is_prime ( ring * 12 - 7 ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return str ( long ( ring ) * ( ring + 1 ) * 3 + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return run NEW_LINE DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import math NEW_LINE import random NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT Scanner ( ) NEW_LINE n = int ( sys . stdin . read ( ) ) NEW_LINE m = int ( sys . stdin . read ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , max ( n , m ) ) : NEW_LINE INDENT for j in range ( 0 , max ( n , m ) ) : NEW_LINE INDENT if ( i * i ) + j == n and i + ( j * j ) == m : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import random NEW_LINE from sympy . combinatorics . grayscale import Grayscale NEW_LINE class GFG ( Grayscale ) : NEW_LINE INDENT def Digits ( self , n ) : NEW_LINE INDENT largest = 0 NEW_LINE smallest = 9 NEW_LINE while n != 0 : NEW_LINE INDENT r = n % 10 NEW_LINE largest = max ( r , largest ) NEW_LINE smallest = min ( r , smallest ) NEW_LINE n = n // 10 NEW_LINE DEDENT print ( largest , smallest ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 2346 NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def solve ( self , d1 , d2 , d3 ) : NEW_LINE INDENT maxx = max ( d1 , max ( d2 , d3 ) ) NEW_LINE sum = ( d1 + d2 + d3 ) NEW_LINE if 2 * maxx > sum or sum % 2 == 1 : NEW_LINE INDENT print ( ' - 1' , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT x1 , y1 = 0 , 0 NEW_LINE x2 , y2 = d1 , 0 NEW_LINE x3 , y3 = ( d1 + d2 - d3 ) / 2 , ( d2 + d3 - d1 ) / 2 NEW_LINE print ( ' ( % d , ▁ % d ) , ▁ ( % d , ▁ % d ) ▁ and ▁ ( % d , ▁ % d ) ' % ( x1 , y1 , x2 , y2 , x3 , y3 ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def solve ( self , d1 , d2 , d3 ) : NEW_LINE INDENT return GFG ( self , d1 , d2 , d3 ) NEW_LINE DEDENT DEDENT
def import _sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE def distributing_balls ( self , k , n , str ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ str [ i ] - ' a ' ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if a [ i ] > k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n , k = 6 , 3 NEW_LINE str = ' aacaab ' NEW_LINE if distributing_balls ( self , k , n , str ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT
def _import ( fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt , fmt ,
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . e = [ ] NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT self . e . append ( args [ 0 ] ) NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT for i in range ( 12 ) : NEW_LINE INDENT e . append ( args [ i ] ) NEW_LINE DEDENT DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT for i in range ( 12 - i ) : NEW_LINE INDENT if e [ i ] < e [ i + 1 ] : NEW_LINE INDENT y = e [ i ] NEW_LINE e [ i ] = e [ i + 1 ] NEW_LINE e [ i + 1 ] = y NEW_LINE DEDENT DEDENT DEDENT for u in range ( 3 ) : NEW_LINE INDENT for k in range ( 4 ) : NEW_LINE INDENT i = u * 4 NEW_LINE if e [ i ] == e [ i + 1 ] and e [ i + 2 ] == e [ i + 3 ] and e [ i ] == e [ i + 2 ] and e [ i + 1 ] == e [ i + 3 ] and e [ i + 1 ] == e [ i + 3 ] and e [ i + 1 ] == e [ i + 2 ] : NEW_LINE INDENT p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 0 NEW_LINE DEDENT DEDENT DEDENT if p == 12 : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT DEDENT
def import _pylab NEW_LINE class GFG ( object ) : NEW_LINE INDENT R = 4 NEW_LINE C = 4 NEW_LINE def first ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid == 0 or arr [ mid - 1 ] == 0 ) and arr [ mid ] == 1 : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] == 0 : NEW_LINE INDENT return first ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return first ( arr , low , ( mid - 1 ) ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def rowWith0s ( mat ) : NEW_LINE INDENT max_row_index , max = 0 , Integer ( 0 ) NEW_LINE min_row_index , min = 0 , Integer ( 0 ) NEW_LINE for i in range ( R ) : NEW_LINE INDENT index = first ( mat [ i , : , C - 1 ] ) NEW_LINE cntZeroes = 0 NEW_LINE if index == - 1 : NEW_LINE INDENT cntZeroes = C NEW_LINE DEDENT else : NEW_LINE INDENT cntZeroes = index NEW_LINE DEDENT if max < cntZeroes : NEW_LINE INDENT max = cntZeroes NEW_LINE max_row_index = i NEW_LINE DEDENT if min > cntZeroes : NEW_LINE INDENT min = cntZeroes NEW_LINE min_row_index = i NEW_LINE DEDENT DEDENT print ( " Row ▁ with ▁ min ▁ 0s : ▁ " , min_row_index + 1 ) NEW_LINE print ( " Row ▁ with ▁ max ▁ 0s : ▁ " , max_row_index + 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT mat = [ [ 0 , 0 , 0 , 1 ] , [ 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE rowWith0s ( mat ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __test ( self ) : NEW_LINE INDENT new_num = n >> ( k - 1 ) NEW_LINE return ( new_num & 1 ) NEW_LINE DEDENT DEDENT n , k = 10 , 2 NEW_LINE if bitAtGivenPosSetOrUnset ( n , k ) == 1 : NEW_LINE INDENT print ( ' Set ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Unset ' ) NEW_LINE DEDENT DEDENT
def import os , sys , getopt , getopt , repeat = 1 ) : NEW_LINE INDENT from getopt import getopt NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from random import randint NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os . path import exists , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo , iinfo ,
def import import _readline NEW_LINE import sys NEW_LINE import numpy NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import dot NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import dot NEW_LINE from numpy . core import dot NEW_LINE from numpy . core import dot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE from numpy . core import rdot NEW_LINE DEDENT
def import import sys NEW_LINE class Sol ( object ) : NEW_LINE INDENT def __init__ ( self , argc ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE l = sc . readline ( ) NEW_LINE r = sc . readline ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , r + 1 , 2 ) : NEW_LINE INDENT for j in range ( 1 , i * i <= r + 1 , 3 ) : NEW_LINE INDENT if i * j >= l : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from math import sin , cos , pi NEW_LINE from math import pi , pi , pi , pi NEW_LINE N = pi NEW_LINE K = pi NEW_LINE pi = pi / 2 NEW_LINE t = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = min ( 2 * t , t + pi ) NEW_LINE DEDENT print ( t ) NEW_LINE DEDENT
def test_gf_gcd ( ) : NEW_LINE INDENT import os NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = [ ] NEW_LINE self . b = [ ] NEW_LINE self . n = len ( self . a ) NEW_LINE self . m = len ( self . b ) NEW_LINE self . sum1 = 0 NEW_LINE self . sum2 = 0 NEW_LINE self . mul1 = 1 NEW_LINE self . mul2 = 1 NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT self . sum1 += self . a [ i ] NEW_LINE self . mul1 *= self . a [ i ] NEW_LINE DEDENT for i in range ( self . m ) : NEW_LINE INDENT self . sum2 += self . b [ i ] NEW_LINE self . mul2 *= self . b [ i ] NEW_LINE DEDENT DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT self . sum1 = 0 NEW_LINE self . sum2 = 0 NEW_LINE self . mul1 = 1 NEW_LINE self . mul2 = 1 NEW_LINE return self . sum1 == self . sum2 and self . mul1 == self . mul2 NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT self . sum1 = 0 NEW_LINE self . sum2 = 0 NEW_LINE self . mul1 = 1 NEW_LINE self . mul2 = 1 NEW_LINE return self . sum1 == self . sum2 and self . mul1 == self . mul2 NEW_LINE DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT self . sum1 = 0 NEW_LINE self . sum2 = 0 NEW_LINE self . mul1 = 0 NEW_LINE self . mul2 = 1 NEW_LINE return self . sum1 == self . sum1 and self . mul1 == self . sum2 and self . mul2 == self . sum1 NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT self . sum2 = 0 NEW_LINE self . mul2 = 0 NEW_LINE self . sum2 = 0 NEW_LINE self . mul2 = self . sum2 NEW_LINE self . mul2 = self . sum2 NEW_LINE return self . sum1 == self . sum2 and self . mul1 == self . sum2 and self . mul2 == self . sum1 and self . sum1 == self . sum2 and self . sum1 == self . sum1 and self . sum1 == self . sum2 and self . sum2 == self . sum2 and self . sum1 == self . sum2 and self . sum1 == self . sum1 and self . sum1 == self . sum2 and
def GFG ( ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE def findAndPrintUncommonChars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT present [ str1 [ i ] - ' a ' ] = 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT if present [ str2 [ i ] - ' a ' ] == 1 or present [ str2 [ i ] - ' a ' ] == - 1 : NEW_LINE INDENT present [ str2 [ i ] - ' a ' ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT present [ str2 [ i ] - ' a ' ] = 2 NEW_LINE DEDENT DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if present [ i ] == 1 or present [ i ] == 2 : NEW_LINE INDENT print ( chr ( i + ' a ' ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT str1 = " characters " NEW_LINE str2 = " alphabets " NEW_LINE findAndPrintUncommonChars ( str1 , str2 ) NEW_LINE DEDENT DEDENT
def GFG ( circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT if ( x - circle_x ) ** 2 + ( y - circle_y ) ** 2 <= rad ** 2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def GFG ( arr , n , x ) : NEW_LINE INDENT sum = 0 NEW_LINE largestDivisible , minimum = - 1 , arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if arr [ i ] % x == 0 and largestDivisible < arr [ i ] : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if arr [ i ] < minimum : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if largestDivisible == - 1 : NEW_LINE INDENT return sum NEW_LINE DEDENT sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) NEW_LINE return min ( sum , sumAfterOperation ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT nth = 2 * ( ( n ** 2 ) - n ) NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( 2 * n ** 2 ) - n NEW_LINE DEDENT return nth NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . list = list ( ) NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return self NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . list NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . list NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . list NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . list NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . list NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . list NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . list NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . list NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . list NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . list NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . list NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . list NEW_LINE DEDENT DEDENT
def test_c1029_a ( ) : NEW_LINE INDENT import sys NEW_LINE from c1029a import c1029_a NEW_LINE n , k = c1029_a ( ) NEW_LINE s = c1029_a ( n , k ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ : i ] == s [ - i : ] : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT s = s [ - ans : ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT s . append ( s [ ans : ] ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . left , self . right = data NEW_LINE DEDENT DEDENT class INT ( object ) : NEW_LINE INDENT def __init__ ( self , a ) : NEW_LINE INDENT self . a = a NEW_LINE DEDENT DEDENT def new_node ( self , data ) : NEW_LINE INDENT temp = Node ( ) NEW_LINE temp . data = data NEW_LINE temp . left = temp . right = None NEW_LINE return temp NEW_LINE DEDENT def print_inorder ( node ) : NEW_LINE INDENT if not node : NEW_LINE INDENT return NEW_LINE DEDENT print_inorder ( node . left ) NEW_LINE print ( " % d ▁ " % node . data ) NEW_LINE print_inorder ( node . right ) NEW_LINE DEDENT def con_binary_tree ( pre , pre_m , pre_index , l , h , size ) : NEW_LINE INDENT if pre_index . a >= size or l > h : NEW_LINE INDENT return NEW_LINE DEDENT root = new_node ( pre [ pre_index . a ] ) NEW_LINE pre_index += ( pre_index . a , ) NEW_LINE if l == h : NEW_LINE INDENT return root NEW_LINE DEDENT for i in range ( l , h + 1 ) : NEW_LINE INDENT if pre [ pre_index . a ] == pre_my_i : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i <= h : NEW_LINE INDENT root . left = con_binary_tree ( pre , pre_m , pre_index , i , h , size ) NEW_LINE root . right = con_binary_tree ( pre , pre_m , pre_index , l + 1 , i - 1 , size ) NEW_LINE DEDENT return root NEW_LINE DEDENT def con_binary_tree ( root , pre , pre_my_i , size ) : NEW_LINE INDENT pre_index = INT ( 0 ) NEW_LINE pre_my_i = 0 NEW_LINE root = con_binary_tree ( pre , pre_my_i , pre_index , 0 , size - 1 , size ) NEW_LINE print_inorder ( root ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT pre_order = [ 1 , 2 , 4 , 5 , 3 , 6 , 7 ] NEW_LINE pre_order_my_i = [ 1 , 3 , 7 , 6 , 2 , 5 , 4 ] NEW_LINE size = len ( pre_order ) NEW_LINE root = Node ( ) NEW_LINE con_binary_tree ( root , pre_order , pre_order_my_i , size ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT no_of_chars = 256 NEW_LINE def findSubString ( str , pat ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 ] * no_of_chars NEW_LINE hash_str = [ 0 ] * no_of_chars NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT hash_pat [ pat [ i ] ] += 1 NEW_LINE DEDENT start , start_index , min_len = 0 , - 1 , sys . maxint NEW_LINE count = 0 NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT hash_str [ str [ i ] ] += 1 NEW_LINE if hash_pat [ i ] != 0 and hash_str [ i ] <= hash_pat [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while hash_str [ start ] > hash_pat [ start ] or hash_pat [ start ] == 0 : NEW_LINE INDENT if hash_str [ start ] > hash_pat [ start ] : NEW_LINE INDENT hash_str [ start ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = i - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if start_index == - 1 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT return str [ start_index : start_index + min_len ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT str = " this ▁ is ▁ a ▁ test ▁ string " NEW_LINE pat = " tist " NEW_LINE sys . stdout . write ( " Smallest ▁ window ▁ is ▁ : \n ▁ " + findSubString ( str , pat ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def __main__ ( ) : NEW_LINE INDENT from matplotlib import cProfile NEW_LINE import matplotlib . pyplot as plt NEW_LINE plt . ion ( ) NEW_LINE for f in plt . gcf ( ) . get_lines ( ) : NEW_LINE INDENT p = [ Point2 ( f . x , f . y ) for i in range ( 4 ) ] NEW_LINE judge = False NEW_LINE if ( ccw ( p [ 0 ] , p [ 3 ] , p [ 1 ] ) > 0 and ccw ( p [ 1 ] , p [ 3 ] , p [ 2 ] ) > 0 and ccw ( p [ 2 ] , p [ 3 ] , p [ 0 ] ) > 0 ) or ( ccw ( p [ 0 ] , p [ 3 ] , p [ 1 ] ) < 0 and ccw ( p [ 1 ] , p [ 3 ] , p [ 2 ] ) < 0 and ccw ( p [ 2 ] , p [ 3 ] , p [ 0 ] ) < 0 ) : NEW_LINE INDENT judge = True NEW_LINE DEDENT print ( " YES " if judge else " NO " ) NEW_LINE DEDENT def ccw ( p1 , p2 , p3 ) : NEW_LINE INDENT return ( p2 . y - p1 . y ) * ( p3 . x - p1 . x ) - ( p3 . y - p1 . y ) * ( p2 . x - p1 . x ) NEW_LINE DEDENT class Point2 ( object ) : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT return Point2 NEW_LINE DEDENT
def import _poland NEW_LINE from collections import defaultdict NEW_LINE from random import randint NEW_LINE from time import time NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . board . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE from poland . game import _poland NEW_LINE DEDENT
def import _ZZ NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 100005 NEW_LINE DEDENT def add_primes ( self ) : NEW_LINE INDENT self . MAX = self . MAX NEW_LINE DEDENT def is_prime ( self ) : NEW_LINE INDENT for p in range ( 2 , self . MAX + 1 ) : NEW_LINE INDENT if self . prime [ p ] == True : NEW_LINE INDENT for i in range ( self . prime [ p ] , self . n + 1 , p ) : NEW_LINE INDENT self . prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , self . MAX + 1 ) : NEW_LINE INDENT if self . prime [ p ] : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT def is_prime ( self , n ) : NEW_LINE INDENT return ( self . prime [ p ] == True ) NEW_LINE DEDENT def find_sum ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE v = self . add_primes ( ) NEW_LINE for i in range ( len ( v ) and n ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while a != 0 : NEW_LINE INDENT d = a % 10 NEW_LINE a = a // 10 NEW_LINE if is_prime ( d ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT self . n -= 1 NEW_LINE sum = sum + v [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . n = 7 NEW_LINE print ( find_sum ( self . n ) ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import solve NEW_LINE sc = zeros ( ( 4 , 4 ) ) NEW_LINE science = zeros ( ( 4 , 4 ) ) NEW_LINE minsc = 100 NEW_LINE sumsc = 0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT science [ i ] = solve ( sc , science ) NEW_LINE minsc = min ( minsc , science [ i ] ) NEW_LINE sumsc += science [ i ] NEW_LINE DEDENT sumsc -= minsc NEW_LINE sumso = solve ( sc , sumso ) NEW_LINE x = solve ( sc , sumso ) NEW_LINE if sumso < x : NEW_LINE INDENT sumso = x NEW_LINE DEDENT print ( sumsc , sumso ) NEW_LINE DEDENT
def import stdin , readline , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice ,
def import _ZZ NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , index , evenSum , oddSum , tight ) : NEW_LINE INDENT v = [ ] NEW_LINE dp = [ [ 0 , 0 , 0 , 0 , 0 ] ] NEW_LINE def memo ( self , index , evenSum , oddSum , tight ) : NEW_LINE INDENT if index == len ( self . v ) : NEW_LINE INDENT if evenSum > oddSum : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if self . dp [ index ] [ evenSum ] [ oddSum ] [ tight ] != - 1 : NEW_LINE INDENT return self . dp [ index ] [ evenSum ] [ oddSum ] [ tight ] NEW_LINE DEDENT limit = ( self . v [ index ] if tight else 9 ) NEW_LINE ans = 0 NEW_LINE for d in range ( 0 , limit ) : NEW_LINE INDENT currTight = 0 NEW_LINE if d == self . v [ index ] : NEW_LINE INDENT currTight = tight NEW_LINE DEDENT if d % 2 : NEW_LINE INDENT ans += memo ( self . index + 1 , evenSum , oddSum + d , currTight ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += memo ( self . index + 1 , evenSum + d , oddSum , currTight ) NEW_LINE DEDENT DEDENT self . dp [ index ] [ evenSum ] [ oddSum ] [ tight ] = ans NEW_LINE return ans NEW_LINE DEDENT def CountNum ( self , n ) : NEW_LINE INDENT v = [ ] NEW_LINE while n > 0 : NEW_LINE INDENT v . append ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT v . reverse ( ) NEW_LINE for i in range ( 18 ) : NEW_LINE INDENT for j in range ( 180 ) : NEW_LINE INDENT for k in range ( 180 ) : NEW_LINE INDENT for l in range ( 2 ) : NEW_LINE INDENT self . dp [ i ] [ j ] [ k ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return self . memo ( 0 , 0 , 0 , 1 ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT L , R = 2 , 10 NEW_LINE print ( CountNum ( R ) - CountNum ( L - 1 ) ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import chain NEW_LINE sc = iter ( sys . stdin ) NEW_LINE lines = [ ] NEW_LINE c = [ ] NEW_LINE b = True NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT c . append ( sc . next ( ) ) NEW_LINE DEDENT DEDENT loop : NEW_LINE INDENT for i in range ( 2 ) : NEW_LINE INDENT for j in range ( i + 1 , 3 ) : NEW_LINE INDENT if c [ i ] [ 0 ] - c [ j ] [ 0 ] == c [ i ] [ 1 ] - c [ j ] [ 1 ] and c [ i ] [ 1 ] - c [ j ] [ 1 ] == c [ i ] [ 2 ] - c [ j ] [ 2 ] : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT b = False NEW_LINE break loop NEW_LINE DEDENT DEDENT DEDENT loop : NEW_LINE INDENT for i in range ( 2 ) : NEW_LINE INDENT for j in range ( i + 1 , 3 ) : NEW_LINE INDENT if c [ 0 ] [ i ] - c [ 0 ] [ j ] == c [ 1 ] [ i ] - c [ 1 ] [ j ] and c [ 1 ] [ i ] - c [ 1 ] [ j ] == c [ 2 ] [ i ] - c [ 2 ] [ j ] : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT b = False NEW_LINE break loop NEW_LINE DEDENT DEDENT DEDENT DEDENT if b : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sys = sys NEW_LINE self . sys = sys NEW_LINE self . t = sys . maxint NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT n = self . sys . stdin . readline ( ) . strip ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( self . sys . stdin . readline ( ) . strip ( ) ) NEW_LINE DEDENT flag = True NEW_LINE b . append ( a [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] != 0 and b [ i - 1 ] - a [ i ] >= 0 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = b [ i - 1 ] + a [ i ] NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT self . sys . exit ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT self . sys . stdout . write ( " % s ▁ " % b [ i ] ) NEW_LINE DEDENT self . sys . stdout . write ( " \n " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def p218 ( ) : NEW_LINE INDENT print ( yield from p218 ( ) . run ( ) ) NEW_LINE DEDENT
def GFG ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE def main ( args ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = search ( arr , x ) NEW_LINE if result == - 1 : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % d " % result , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def import import os , sys , subprocess , sys , args , input , output , errors , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def toggleBitsFromLToR ( self , n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def unsetBitsInGivenRange ( self , n , l , r ) : NEW_LINE INDENT num = ( 1 << ( 4 * 8 - 1 ) ) - 1 NEW_LINE num = self . toggleBitsFromLToR ( num , l , r ) NEW_LINE return ( n & num ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n , l , r = 42 , 2 , 5 NEW_LINE print ( unsetBitsInGivenRange ( n , l , r ) ) NEW_LINE DEDENT DEDENT
def GFG ( a , n ) : NEW_LINE INDENT positive , negative , zero = 0 , 0 , 0 NEW_LINE step = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT elif a [ i ] < 0 : NEW_LINE INDENT negative += 1 NEW_LINE step = step + ( - 1 - a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT positive += 1 NEW_LINE step = step + ( a [ i ] - 1 ) NEW_LINE DEDENT DEDENT if negative % 2 == 0 : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT if zero > 0 : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT step = step + 2 NEW_LINE DEDENT DEDENT return step NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE from numpy . core import zeros NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . raw_input = raw_input ( ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT n = sys . stdin . readline ( ) . strip ( ) NEW_LINE num = [ int ( i ) for i in sys . stdin . readline ( ) . strip ( ) . split ( ' ▁ ' ) ] NEW_LINE num = [ int ( i ) for i in num ] NEW_LINE print ( num [ n - 1 ] + num [ n - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if b == 0 : return a NEW_LINE return __gcd ( b , a % b ) NEW_LINE def noOfSquares ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT dx = abs ( x2 - x1 ) NEW_LINE dy = abs ( y2 - y1 ) NEW_LINE ans = dx + dy - __gcd ( dx , dy ) NEW_LINE print ( ans ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = 1 , 1 , 4 , 3 NEW_LINE noOfSquares ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT DEDENT
def GFG ( s , a ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] - '0' < a [ s [ i ] - '0' ] : NEW_LINE INDENT j = i NEW_LINE while j < n and ord ( s [ j ] ) - '0' <= a [ s [ j ] ] : NEW_LINE INDENT s [ j ] = ord ( '0' ) + a [ s [ j ] ] NEW_LINE j += 1 NEW_LINE DEDENT return str ( s ) NEW_LINE DEDENT DEDENT return str ( s ) NEW_LINE DEDENT
def import isOctal NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import math NEW_LINE class GFG ( int ) : NEW_LINE INDENT MAX_DIGITS = 20 NEW_LINE def isOctal ( n ) : NEW_LINE INDENT while n > 0 : NEW_LINE INDENT if ( n % 10 ) >= 8 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 10 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divide = ( 8 if isOctal ( n ) == 0 else 10 ) NEW_LINE octal = [ ] NEW_LINE i = 0 NEW_LINE while n != 0 : NEW_LINE INDENT octal . append ( n % divide ) NEW_LINE n = n // divide NEW_LINE DEDENT for j , k in enumerate ( range ( i - 1 , 0 , - 1 ) ) : NEW_LINE INDENT if octal [ j ] != octal [ k ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 97 NEW_LINE if isPalindrome ( n ) : NEW_LINE INDENT sys . stdout . write ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def import _re_parse NEW_LINE import sys NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . x , self . y = 0 , 0 NEW_LINE self . t = 0 NEW_LINE self . n = len ( string . ascii_letters ) NEW_LINE self . str = string . ascii_letters [ self . n ] NEW_LINE self . l = string . ascii_letters [ self . n ] NEW_LINE for c in self . l : NEW_LINE INDENT if c != '4' and c != '7' : NEW_LINE INDENT self . t = 1 NEW_LINE DEDENT DEDENT if self . t == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( self . n // 2 ) : NEW_LINE INDENT self . x = self . x + string . digits [ i ] NEW_LINE DEDENT for i in range ( self . n - 1 , ( self . n // 2 ) - 1 , - 1 ) : NEW_LINE INDENT self . y = self . y + string . digits [ i ] NEW_LINE DEDENT if self . x == self . y : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def GFG ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE midvalue = arr [ mid ] NEW_LINE if mid == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT leftindex = min ( mid - 1 , midvalue ) NEW_LINE left = BinarySearch ( arr , low , leftindex ) NEW_LINE if left >= 0 : NEW_LINE INDENT return left NEW_LINE DEDENT rightindex = max ( mid + 1 , midvalue ) NEW_LINE right = BinarySearch ( arr , rightindex , high ) NEW_LINE return right NEW_LINE DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 10000 NEW_LINE DEDENT def prod_dig ( self , x ) : NEW_LINE INDENT if x < 10 : NEW_LINE INDENT return x NEW_LINE DEDENT if self . prod_dig [ x ] : NEW_LINE INDENT return self . prod_dig [ x ] NEW_LINE DEDENT prod = ( x % 10 ) * self . get_digit_product ( x // 10 ) NEW_LINE return ( self . prod_dig [ x ] , prod ) NEW_LINE DEDENT def find_seed ( self , n ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT if i * self . get_digit_product ( i ) == n : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT if len ( res ) == 0 : NEW_LINE INDENT print ( " NO ▁ seed ▁ exists " ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 138 NEW_LINE find_seed ( self , n ) NEW_LINE DEDENT DEDENT
def import import sys , stdin , stdout , stderr , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input
def GFG ( n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . e ) : NEW_LINE INDENT def diff ( self , n ) : NEW_LINE INDENT if n > ( self . mid ** 2 ) : NEW_LINE INDENT return ( n - ( self . mid ** 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( self . mid ** 2 ) - n ) NEW_LINE DEDENT DEDENT def cubicRoot ( self , n ) : NEW_LINE INDENT start , end = 0 , n NEW_LINE e = 0.0000001 NEW_LINE while 1 : NEW_LINE INDENT mid = ( start + end ) / 2 NEW_LINE error = diff ( self , n ) NEW_LINE if error <= e : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( self . mid ** 2 ) > n : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 3 NEW_LINE print ( " Cubic ▁ root ▁ of ▁ % d ▁ is ▁ % d " % ( n , cubicRoot ( n ) ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE self . m = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE self . a = [ 0 ] * 105 NEW_LINE self . max = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT self . a [ i ] = sys . stdin . readline ( ) . strip ( ) NEW_LINE if i > 0 and self . a [ i ] > self . a [ max ] : NEW_LINE INDENT self . max = i NEW_LINE DEDENT DEDENT self . ansmax = self . a [ max ] + self . m NEW_LINE for i in range ( 0 , m - 1 ) : NEW_LINE INDENT min = 0 NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT if j > 0 and self . a [ j ] < self . a [ min ] : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT self . a [ min ] += 1 NEW_LINE DEDENT self . max = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if self . a [ i ] > self . a [ max ] : NEW_LINE INDENT self . max = i NEW_LINE DEDENT DEDENT self . ansmin = self . a [ max ] NEW_LINE sys . stdout . write ( " % d ▁ % d \n " % ( self . ansmin , self . ansmax ) ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import factorial NEW_LINE class GFG ( factorial ) : NEW_LINE INDENT def inv ( self , a ) : NEW_LINE INDENT m0 , t , q = self . m , self . a , self . t NEW_LINE x0 , x1 = 0 , 1 NEW_LINE if m == 1 : return 0 NEW_LINE while a > 1 : NEW_LINE INDENT q , t , m , a , t , x0 , x1 = self . a // m , self . a % m , self . t , self . x0 , self . x1 - q * x0 , self . x1 = t NEW_LINE DEDENT if x1 < 0 : x1 += m0 NEW_LINE return x1 NEW_LINE DEDENT def find_min_x ( self , num , rem , k ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT prod *= num [ i ] NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT pp = prod // num [ i ] NEW_LINE result += rem [ i ] * inv ( pp , num [ i ] ) * pp NEW_LINE DEDENT return result % prod NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT num = [ 3 , 4 , 5 ] NEW_LINE rem = [ 2 , 3 , 1 ] NEW_LINE k = len ( num ) NEW_LINE print ( ' x ▁ is ▁ % s ' % find_min_x ( num , rem , k ) ) NEW_LINE DEDENT DEDENT
def import _solution NEW_LINE class solution ( object ) : NEW_LINE INDENT def compare ( self , a , b ) : NEW_LINE INDENT return a > b NEW_LINE DEDENT def find_max_OR ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT DEDENT max_OR = arr [ 0 ] NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( max_OR | arr [ i ] ) > max_OR : NEW_LINE INDENT max_OR = max_OR | arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( arrgs ) : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_max_OR ( arr , n ) ) NEW_LINE DEDENT DEDENT
def series_sum ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def sum ( self ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT self . sum += self . n * ( i + 1 ) / 2 NEW_LINE DEDENT return self . sum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = 4 NEW_LINE print ( self . series_sum ( n ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . sum = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if self . n % i == 0 : NEW_LINE INDENT self . sum += i NEW_LINE DEDENT DEDENT return self . sum NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT n = 12 NEW_LINE print ( self . aliquotsum ( n ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def pentagon_pyramidal ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * self . sum ** i - i ) / 2 NEW_LINE self . sum = self . sum + p NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 4 NEW_LINE print ( pentagon_pyramidal ( n ) ) NEW_LINE DEDENT return GFG NEW_LINE DEDENT
def test_gf_power ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def power ( self , n ) : NEW_LINE INDENT self . n = n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT self . n = self . n + ( self . n * i * i * i ) NEW_LINE DEDENT return self . n NEW_LINE DEDENT def power ( self , n ) : NEW_LINE INDENT self . n = 6 NEW_LINE print ( self . n ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def import import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def squaresum ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i ** 2 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE DEDENT DEDENT
def series_sum ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def sum ( self ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT self . sum += self . n * ( i + 1 ) / 2 NEW_LINE DEDENT return self . sum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = 4 NEW_LINE print ( self . series_sum ( n ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def sum ( self ) : NEW_LINE INDENT return np . sum ( self . n ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 ** i - 1 ) ** 2 NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) NEW_LINE DEDENT return sum NEW_LINE def main ( ) : NEW_LINE INDENT n = 3 NEW_LINE print ( find_sum ( n ) ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import factorial NEW_LINE from math import log NEW_LINE class GFG ( factorial ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . factorial = factorial NEW_LINE DEDENT def factorial ( self ) : NEW_LINE INDENT return self . factorial NEW_LINE DEDENT DEDENT n = 6 NEW_LINE print ( fourth_power_sum ( n ) ) NEW_LINE DEDENT
def test_gf_sum_mul ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT return self . n NEW_LINE DEDENT DEDENT def gf_sum_mul ( self , n ) : NEW_LINE INDENT return sum ( [ ( 2 ** i ) * ( 2 ** i ) for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT def gf_sum_mul ( self , n ) : NEW_LINE INDENT return sum ( [ ( 2 ** i ) * ( 2 ** i ) for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT def gf_sum_mul ( self , n ) : NEW_LINE INDENT return sum ( [ ( 2 ** i ) * ( 2 ** i ) for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT def gf_sum_mul ( self , n ) : NEW_LINE INDENT return sum ( [ ( 2 ** i ) * ( 2 ** i ) for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT return gf_sum_mul NEW_LINE DEDENT
def _ import _ , ▁ numpy . linalg . lstsq ( ) : ▁ return ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lstsq ( ) ▁ / ▁ numpy . linalg . lst
def test_find_sum ( ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . factorial ) : NEW_LINE INDENT def find_sum ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 3 NEW_LINE print ( find_sum ( n ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import sqrt NEW_LINE class GFG ( object ) : NEW_LINE INDENT def solve ( self , n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT remainder = n % base NEW_LINE sum += remainder NEW_LINE n = n // base NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumsOfDigits ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for base in range ( 2 , n // 2 + 1 ) : NEW_LINE INDENT sum += solve ( self , n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 8 NEW_LINE SumsOfDigits ( n ) NEW_LINE DEDENT return GFG NEW_LINE DEDENT
def import import sys , string , traceback , time , traceback , loops , N , args , debug , N , args , env , var , var , var , N , N , args , var , var , var , N , args , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , var , , var , var , var , var , var , var , , var , var , var , , var , var , , var , var , var , , var , var , var , , var , var , var , , var , var , , var , var , , var , , var , var , , var , , var , , var , , var , , var , , var , , var , , var , , var , , var , , var , , var , , , var , , , var , , var , , , var , , , var , , , var , , , var , , , var , , , var , , , var , , , var , , , , var , , , var , , , , var , , , , var , , , , var , , , , var , , , , var , , , , , var , , , , , var , , , , , var , , , , , var , , , , , , , _ , , _ , , , _ , , _ , , _ , , _ , , _ , ] ) NEW_LINE from itertools import repeat NEW_LINE import itertools NEW_LINE from itertools import izip NEW_LINE import itertools NEW_LINE import string as l NEW_LINE import itertools NEW_LINE import itertools NEW_LINE import itertools NEW_LINE if sys . count ( map ( str , _ _ in [
def import import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT print ( sys . getrefcount ( self ) ) NEW_LINE sys . getrefcount ( self ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . __getitem__ ( key ) NEW_LINE DEDENT def __setitem__ ( self , key , value ) : NEW_LINE INDENT self . __setitem__ ( key , value ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return self . __getitem__ ( key ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' GFG ( % s ) ' % repr ( self . __repr__ ( ) ) NEW_LINE DEDENT DEDENT
def Optimal_BST2 ( keys , freq , n ) : NEW_LINE INDENT cost = [ [ freq [ i ] for i in range ( n + 1 ) ] for i in range ( n ) ] NEW_LINE for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 0 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE cost [ i ] [ j ] = sys . maxint NEW_LINE for r in range ( i , j + 1 ) : NEW_LINE INDENT c = ( ( cost [ i ] [ r - 1 ] if r > i else 0 ) + ( cost [ r + 1 ] [ j ] if r < j else 0 ) + sum ( freq , i , j ) ) NEW_LINE if c < cost [ i ] [ j ] : NEW_LINE INDENT cost [ i ] [ j ] = c NEW_LINE DEDENT DEDENT DEDENT DEDENT return cost [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def GFG ( x , y , z ) : NEW_LINE INDENT if x > z : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) / y NEW_LINE ans = div * y + x NEW_LINE return ans NEW_LINE DEDENT
def import _io , StringIO , StringIO , StringIO , pipes , config , ** kwargs ) : NEW_LINE INDENT import os NEW_LINE import random NEW_LINE import sys NEW_LINE import os NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import os NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import random NEW_LINE import subprocess NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import stdin , tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import zipfile NEW_LINE import tempfile NEW_LINE import zipfile NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from tempfile import mktemp NEW_LINE from os import mkdir NEW_LINE from os import rename NEW_LINE from os import getcwd , chdir , join NEW_LINE from os import getcwd , chdir , join NEW_LINE from os import getcwd , chdir , join NEW_LINE from os import getcwd , chdir , join NEW_LINE from os import getcwd , chdir , join NEW_LINE from os import getcwd , chdir , join NEW_LINE from os import getcwd , chdir , join NEW_LINE from os import getcwd , chdir , join NEW_LINE from os import getcwd , chdir , join NEW_LINE from os import getcwd , chdir , join , chdir , join NEW_LINE from os import getcwd , chdir , join NEW_LINE from os . chdir ( getcwd ) NEW_LINE from os import getcwd , chdir , join NEW_LINE from os . chdir import chdir NEW_LINE from os . path import join , chdir , join NEW_LINE from os . path import join , chdir , join NEW_LINE from os . path import join , chdir , join NEW_LINE from os . path import join , chdir , join NEW_LINE from os . path import join , chdir , join NEW_LINE from os . path import join , chdir , join NEW_LINE from os . path import join , chdir , join NEW_LINE from os . path import join , chdir , join , join NEW_LINE from os . path import join , chdir , join , chdir , join NEW_LINE from os . path import exists , chdir , join , join , dirname , join , dirname , dirname
def _import ( ) : NEW_LINE INDENT from math import factorial NEW_LINE class GFG ( factorial ) : NEW_LINE INDENT def binomial ( self , n , k ) : NEW_LINE INDENT C = [ [ 0 ] * ( n + 1 ) for i in range ( 0 , n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def maxcoefficientvalue ( self , n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return self . binomial ( n , n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return self . binomial ( n , ( n + 1 ) // 2 ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT n = 4 NEW_LINE print ( self . maxcoefficientvalue ( n ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def GFG ( ch ) : NEW_LINE INDENT if ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT def vowelPairs ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if isVowel ( s [ i ] ) and isVowel ( s [ i + 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT s = ' abaebio ' NEW_LINE n = len ( s ) NEW_LINE print ( vowelPairs ( s , n ) , end = ' ▁ ' ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def __solve ( ) : NEW_LINE INDENT import sys NEW_LINE solve ( ) NEW_LINE from os import urandom NEW_LINE scn = urandom ( 1 ) NEW_LINE pr = urandom ( 2 ) NEW_LINE while 1 : NEW_LINE INDENT N = scn . read ( 1 ) NEW_LINE if not N : NEW_LINE INDENT break NEW_LINE DEDENT W , H = scn . read ( 1 ) NEW_LINE map = [ [ 0 ] * ( W + 1 ) for i in range ( H + 1 ) ] NEW_LINE N -= 1 NEW_LINE map [ scn . read ( 1 ) ] [ scn . read ( 1 ) ] += 1 NEW_LINE S , T = scn . read ( 1 ) NEW_LINE max = 0 NEW_LINE for s in range ( 1 , W - S + 1 ) : NEW_LINE INDENT for t in range ( 1 , H - T + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( s , s + S ) : NEW_LINE INDENT for b in range ( t , t + T ) : NEW_LINE INDENT count += map [ a ] [ b ] NEW_LINE DEDENT DEDENT if max < count : NEW_LINE INDENT max = count NEW_LINE DEDENT DEDENT DEDENT pr . write ( max ) NEW_LINE DEDENT pr . flush ( ) NEW_LINE scn . close ( ) NEW_LINE DEDENT
def GFG ( s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE for i in range ( 0 , N - M ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if s2 [ i + j ] != s1 [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == M : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT s1 = ' for ' NEW_LINE s2 = ' geeksforgeeks ' NEW_LINE res = isSubstring ( s1 , s2 ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( ' Not ▁ present ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Present ▁ at ▁ index ▁ ' + str ( res ) ) NEW_LINE DEDENT DEDENT return main NEW_LINE DEDENT
def GFG ( z ) : return ( z / 2 ) NEW_LINE def main ( ) : NEW_LINE INDENT angle = 65 NEW_LINE z = angle_oncirc_cumference ( angle ) NEW_LINE print ( " The ▁ angle ▁ is ▁ { } ▁ degrees " . format ( z ) ) NEW_LINE DEDENT
def test_countsubarraysof1and0 ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , a , n ) : NEW_LINE INDENT self . countsubarraysof1and0 = 0 NEW_LINE self . number1 , self . number0 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT self . count1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . number1 += ( self . count1 ) * ( self . count1 + 1 ) / 2 NEW_LINE self . count1 = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT self . count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . number0 += ( self . count0 ) * ( self . count0 + 1 ) / 2 NEW_LINE self . count0 = 0 NEW_LINE DEDENT DEDENT DEDENT if self . count1 > 0 : NEW_LINE INDENT self . number1 += ( self . count1 ) * ( self . count1 + 1 ) / 2 NEW_LINE DEDENT if self . count0 > 0 : NEW_LINE INDENT self . number0 += ( self . count0 ) * ( self . count0 + 1 ) / 2 NEW_LINE DEDENT print ( " Count ▁ of ▁ subarrays ▁ of ▁ 0 ▁ only : ▁ " , self . number0 ) NEW_LINE print ( " \n Count ▁ of ▁ subarrays ▁ of ▁ 1 ▁ only : ▁ " , self . number1 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a = np . array ( [ 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] ) NEW_LINE n = len ( a ) NEW_LINE self . countsubarraysof1and0 ( a , n ) NEW_LINE DEDENT DEDENT
def GFG ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if N > 0 : NEW_LINE INDENT while x > 0 and flag == 1 : NEW_LINE INDENT digit = x % 10 NEW_LINE if digit != 1 and digit != 3 : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x / 10 NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE DEDENT PrintNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT
def import _sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def print_permutation ( self , n , k ) : NEW_LINE INDENT i , mx = n NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( mx , end = ' ▁ ' ) NEW_LINE mx -= 1 NEW_LINE DEDENT for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT N , K = 5 , 3 NEW_LINE if K >= N - 1 : NEW_LINE INDENT print ( ' Not ▁ Possible ' , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print_permutation ( self , N , K ) NEW_LINE DEDENT DEDENT DEDENT
def import the_rank NEW_LINE class TheRank ( the_rank ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = the_rank . n NEW_LINE self . ans = 0 NEW_LINE self . rank = 1 NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . ans = the_rank . rank NEW_LINE self . arr = [ ] NEW_LINE for a , b , c , d in the_rank . items ( ) : NEW_LINE INDENT sum = a + b + c + d NEW_LINE self . arr . append ( sum ) NEW_LINE DEDENT DEDENT for j in arr : NEW_LINE INDENT if arr [ 0 ] < j : NEW_LINE INDENT self . rank += 1 NEW_LINE DEDENT DEDENT print ( self . rank ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import string NEW_LINE class GFG ( object ) : NEW_LINE INDENT def check ( self , s1 , s2 ) : NEW_LINE INDENT mp = { } NEW_LINE for c in s1 : NEW_LINE INDENT mp [ c ] = mp . get ( c ) or 1 NEW_LINE DEDENT for c in s2 : NEW_LINE INDENT if mp [ c ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT s1 , s2 = ' geeksforgeeks ' , ' geeks ' NEW_LINE yes_or_no = check ( s1 , s2 ) NEW_LINE if yes_or_no == True : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def import sys NEW_LINE class Practice ( object ) : NEW_LINE INDENT def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE t = sys . argv . pop ( 0 ) NEW_LINE while t : NEW_LINE INDENT n , a , b , c , d , flag = self . _eval ( sc , args , kwargs ) NEW_LINE k = n * ( a - b ) NEW_LINE m = n * ( a + b ) NEW_LINE if k > ( c + d ) or m < ( c - d ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_find_elements ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE from numpy . testing import find_elements NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_elements ( self , arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE find_elements ( arr , n ) NEW_LINE DEDENT DEDENT
def import _gf_sum NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = 3 NEW_LINE DEDENT def max_path_sum ( self , tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT tri = [ [ 1 , 0 , 0 ] , [ 4 , 8 , 0 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( max_path_sum ( self , tri , 2 , 2 ) ) NEW_LINE DEDENT return GFG NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , ( n - 2 ) / 2 ) : NEW_LINE INDENT if arr [ 2 * i + 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT if 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def GFG ( arr , i , n ) : NEW_LINE INDENT if i > ( n - 2 ) / 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def import import * NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import time NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . _win = sys . _getframe ( 1 ) NEW_LINE self . _win = sys . _getframe ( 2 ) NEW_LINE self . _win . frame . f_back = None NEW_LINE self . _win . frame . f_globals = None NEW_LINE self . _win . f_locals = None NEW_LINE DEDENT def __call__ ( self ) : NEW_LINE INDENT return self . _win . _win . _win . _win . _win NEW_LINE DEDENT DEDENT
def find_min_del ( arr , n ) : NEW_LINE INDENT min_num = sys . maxint NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == min_num : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return n - cnt NEW_LINE DEDENT
def __count__ ( x , y ) : NEW_LINE INDENT import math NEW_LINE ans = 0 NEW_LINE m = { } NEW_LINE while x % y : NEW_LINE INDENT x = x % y NEW_LINE ans += 1 NEW_LINE if x in m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT m [ x ] = 1 NEW_LINE x = x * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE from math import floor NEW_LINE from math import ceil NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE arr = [ 40 , 50 , 90 ] NEW_LINE n = 3 NEW_LINE if isPossibleToMakeDivisible ( arr , n ) : NEW_LINE INDENT sys . stdout . write ( ' Yes \n ' ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( ' No \n ' ) NEW_LINE DEDENT DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT super ( Main , self ) . __init__ ( * args ) NEW_LINE self . N , self . K = args NEW_LINE self . ans = 0 NEW_LINE self . vec = [ [ 0 ] for i in range ( self . N ) ] NEW_LINE for i in range ( self . N ) : NEW_LINE INDENT a = _main ( self . vec [ i ] ) - 1 NEW_LINE if i != 0 : NEW_LINE INDENT self . vec [ a ] . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT if a != 0 : NEW_LINE INDENT self . ans += 1 NEW_LINE DEDENT DEDENT DEDENT self . dfs ( 0 , 0 ) NEW_LINE print ( self . ans ) NEW_LINE DEDENT def dfs ( v , pre = None ) : NEW_LINE INDENT hight = 0 NEW_LINE for j in range ( len ( self . vec [ v ] ) ) : NEW_LINE INDENT hight = max ( hight , self . dfs ( j , v ) ) NEW_LINE DEDENT if pre is not None and hight == self . K - 1 : NEW_LINE INDENT self . hight = 0 NEW_LINE self . ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . hight += 1 NEW_LINE DEDENT return self . hight NEW_LINE DEDENT DEDENT
def printCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , a ** 2 + 1 ) : NEW_LINE INDENT if j ** 2 == i : NEW_LINE INDENT print ( j ** 2 , end = ' ▁ ▁ ' , end = ' ▁ ' ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT a , b = 1 , 100 NEW_LINE print ( ' Perfect ▁ cubes ▁ in ▁ given ▁ range : ' ) NEW_LINE printCubes ( a , b ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( n , d ) : return ( n & ( d - 1 ) ) NEW_LINE def main ( ) : NEW_LINE INDENT n = 6 NEW_LINE d = 4 NEW_LINE print ( " % d ▁ moduo ▁ % d ▁ is ▁ % d " % ( n , d , getModulo ( n , d ) ) ) NEW_LINE DEDENT
def _import ( ) : return sys . stdin . readline ( ) NEW_LINE import readline NEW_LINE import readline NEW_LINE import time NEW_LINE import numpy as np NEW_LINE import shlex NEW_LINE class pre598 ( object ) : NEW_LINE INDENT class FastReader : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT return sys . stdin . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not readline or not readline . strip ( ) : NEW_LINE INDENT try : NEW_LINE INDENT readline . readline ( ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return readline . strip ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT data = ' ' NEW_LINE try : NEW_LINE INDENT data = sys . stdin . readline ( ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT pass NEW_LINE DEDENT return data NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT data = ' ' NEW_LINE try : NEW_LINE INDENT data = readline ( self ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT pass NEW_LINE DEDENT return data NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT obj = FastReader ( ) NEW_LINE n , d , arr = obj . readline ( ) , obj . readline ( ) , [ ] NEW_LINE arr . sort ( ) NEW_LINE max = np . inf NEW_LINE for i in range ( n ) : NEW_LINE INDENT count , l = 0 , arr [ i ] + d NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if l < arr [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT max = max ( max , count ) NEW_LINE DEDENT print ( n - max ) NEW_LINE DEDENT DEDENT
def import import _io , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl , _ssl ,
def GFG ( x ) : NEW_LINE INDENT cr = int ( math . cbrt ( x ) ) NEW_LINE return ( cr ** 2 == x ) NEW_LINE def canBePerfectCube ( N , K ) : NEW_LINE INDENT if isPerfectCube ( N + K ) or isPerfectCube ( N - K ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT N = 7 NEW_LINE K = 1 NEW_LINE canBePerfectCube ( N , K ) NEW_LINE N = 5 NEW_LINE K = 4 NEW_LINE canBePerfectCube ( N , K ) NEW_LINE N = 7 NEW_LINE K = 2 NEW_LINE canBePerfectCube ( N , K ) NEW_LINE DEDENT DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n = int ( sc . readline ( ) ) NEW_LINE s = sc . readline ( ) NEW_LINE t = sc . readline ( ) NEW_LINE sc . close ( ) NEW_LINE result = 2 ** n NEW_LINE for i , foot in enumerate ( t ) : NEW_LINE INDENT if s . endswith ( foot ) : NEW_LINE INDENT result -= len ( foot ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT DEDENT
def _DFS ( v ) : return v NEW_LINE import sys NEW_LINE import sys NEW_LINE class Graph ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . V = v NEW_LINE self . adj = [ list ( ) ] NEW_LINE DEDENT def add_edge ( self , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFS ( self , visited ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE print ( self . V , end = ' ▁ ' ) NEW_LINE for ( n , v ) in self . adj [ v ] : NEW_LINE INDENT if not visited [ n ] : NEW_LINE INDENT DFS ( n , visited ) NEW_LINE DEDENT DEDENT DEDENT def DFS ( self , v ) : NEW_LINE INDENT visited = [ False ] NEW_LINE DFS ( self , v ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT g = Graph ( 4 ) NEW_LINE g . add_edge ( 0 , 1 ) NEW_LINE g . add_edge ( 0 , 2 ) NEW_LINE g . add_edge ( 1 , 2 ) NEW_LINE g . add_edge ( 2 , 0 ) NEW_LINE g . add_edge ( 2 , 3 ) NEW_LINE g . add_edge ( 3 , 3 ) NEW_LINE print ( " Following ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) NEW_LINE g . DFS ( 2 ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT import math NEW_LINE import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def count_digits ( self , arr ) : NEW_LINE INDENT while long ( val ) : NEW_LINE INDENT digit = long ( val ) % 10 NEW_LINE arr [ int ( digit ) ] += 1 NEW_LINE val = long ( val ) / 10 NEW_LINE DEDENT return NEW_LINE DEDENT def count_frequency ( self , x , n ) : NEW_LINE INDENT freq_count = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val = np . sum ( float ( x ) * float ( i ) ) NEW_LINE count_digits ( val , freq_count ) NEW_LINE DEDENT for i in range ( 0 , 9 ) : NEW_LINE INDENT print ( freq_count [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT x , n = 15 , 3 NEW_LINE return GFG ( x , n ) NEW_LINE DEDENT DEDENT
def import _sys , os , sys , stdin , stdout , stdin , stderr , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stderr , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stderr , stdin , stdin , stdout , stdin , stdin , stdin , stdout , stdin , stdin , stderr , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdout , stdin , stdin , stderr , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stderr , stdin , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stderr , stdin , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stderr , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdout , stdin , stdin , stdin , stdin , stdout , stderr , stdin , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdout , stdin , stdin , stdin , stdout , stderr , stdin , stdin , stdin , stdin , stdin , stdout , stdin , stdin , stdout , stdin , stdout , stdin , stderr , stdin , stdin , stdin , stdout , stdin , stdout , stdin , stdout , stderr , stdin , stdin , stdin , stdout , stderr , stdin , stdin , stdout , stderr , stdin , stdin , stdout , stderr , stdin , stdin , stdout , stderr , stderr , stderr , stderr , stdin , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr , stderr
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sys = sys NEW_LINE self . t = sys . maxint NEW_LINE for i in range ( self . t ) : NEW_LINE INDENT n = self . sys . maxint NEW_LINE print ( self . max_left ( n ) ) NEW_LINE DEDENT DEDENT def max_left ( self , n ) : NEW_LINE INDENT return n - 2 if n > 2 else 0 NEW_LINE DEDENT DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = int ( self . n ) NEW_LINE self . hs = set ( ) NEW_LINE a = [ i for i in range ( self . a ) ] NEW_LINE b = [ i for i in range ( self . b ) ] NEW_LINE if len ( self . hs ) == n : NEW_LINE INDENT print ( " I ▁ become ▁ the ▁ guy . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Oh , ▁ my ▁ keyboard ! " , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def import _gradient_gradient_check NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , m , n ) : NEW_LINE INDENT self . m = 6 NEW_LINE self . n = 4 NEW_LINE DEDENT def linear_check ( self , ar , arr ) : NEW_LINE INDENT for i in range ( self . m ) : NEW_LINE INDENT matched = True NEW_LINE for j in range ( self . n ) : NEW_LINE INDENT if self . ar [ i ] [ j ] != arr [ j ] : NEW_LINE INDENT matched = False NEW_LINE break NEW_LINE DEDENT DEDENT if matched : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT mat = [ [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 40 , 40 ] , [ 43 , 44 , 55 , 68 ] , [ 81 , 73 , 100 , 132 ] , [ 100 , 75 , 125 , 133 ] ] NEW_LINE row = [ 10 , 9 , 22 , 23 ] NEW_LINE print ( linear_check ( mat , row ) ) NEW_LINE DEDENT return GFG NEW_LINE DEDENT
def import import sys NEW_LINE class CandyAndFriend ( ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . raw_input = raw_input ( ' Please ▁ enter ▁ your ▁ Candy ▁ and ▁ friend : ▁ ' ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT t = sys . stdin . readline ( ) . strip ( ) NEW_LINE while t : NEW_LINE INDENT n = len ( self . raw_input ) NEW_LINE a = [ ] NEW_LINE sum , count = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( self . raw_input ( ) ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT if sum % n == 0 : NEW_LINE INDENT div = sum / n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > div : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT t -= 1 NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . solve_d = True NEW_LINE DEDENT def solve_d ( self ) : NEW_LINE INDENT with open ( self . path , ' r ' ) as f : NEW_LINE INDENT N = f . read ( ) NEW_LINE DEDENT DEDENT DEDENT t = [ ] NEW_LINE sum_t = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT t . append ( sc . randint ( 0 , 2 ) ) NEW_LINE sum_t += t [ i ] NEW_LINE DEDENT v = [ sc . randint ( 0 , 2 ) for i in range ( N ) ] NEW_LINE tmp_v = 0 NEW_LINE tmp_t = 0 NEW_LINE max_v = [ 0 ] * sum_t + [ 1 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT max_v [ tmp_t ] = v [ i ] < tmp_v [ i ] NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE for t_ind in range ( t [ i ] ) : NEW_LINE INDENT max_v [ 1 ] += v [ i ] < tmp_v [ i ] NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE for t_ind in range ( t [ i ] ) : NEW_LINE INDENT back_v = v [ i ] < tmp_v [ i ] NEW_LINE del max_v [ 1 ] NEW_LINE max_v [ 1 ] += back_v [ t_ind ] NEW_LINE tmp_v = max_v [ 1 ] NEW_LINE DEDENT DEDENT DEDENT answer = 0 NEW_LINE for i in range ( sum_t ) : NEW_LINE INDENT answer += ( max_v [ i ] + max_v [ i + 1 ] ) NEW_LINE DEDENT print ( answer * 0.125 ) NEW_LINE DEDENT
def nth_term ( n ) : NEW_LINE INDENT import math NEW_LINE class solution : NEW_LINE INDENT def nth_term ( self , n ) : NEW_LINE INDENT return 2 * int ( math . pow ( n , 2 ) ) + 4 * n - 2 NEW_LINE DEDENT def main ( self , arr ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nth_term ( N ) ) NEW_LINE DEDENT DEDENT solution = solution ( ) NEW_LINE return solution NEW_LINE DEDENT
def nth_term ( n ) : return 7 * int ( math . pow ( n , 2 ) ) - 7 * n + 7 NEW_LINE def main ( arr ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nth_term ( N ) ) NEW_LINE DEDENT
def nth_term ( n ) : NEW_LINE INDENT import math NEW_LINE class solution : NEW_LINE INDENT def nth_term ( self , n ) : NEW_LINE INDENT return 5 * int ( math . pow ( n , 2 ) ) - 5 * n NEW_LINE DEDENT def main ( self , arr ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nth_term ( N ) ) NEW_LINE DEDENT DEDENT solution = solution ( ) NEW_LINE return solution NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT class solution : NEW_LINE INDENT def nthTerm ( self , n ) : NEW_LINE INDENT return int ( math . pow ( n , 2 ) + 2 * n + 2 ) NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def nth_term ( n ) : NEW_LINE INDENT import math NEW_LINE class solution : NEW_LINE INDENT def nth_term ( self , n ) : NEW_LINE INDENT return 2 * int ( math . pow ( n , 3 ) ) + int ( math . pow ( n , 2 ) ) NEW_LINE DEDENT def main ( self , arr ) : NEW_LINE INDENT N = 3 NEW_LINE print ( nth_term ( N ) ) NEW_LINE DEDENT DEDENT solution . nth_term ( ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT class solution : NEW_LINE INDENT def nthTerm ( self , n ) : NEW_LINE INDENT return 2 * int ( math . pow ( n , 2 ) ) - n - 1 NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT class solution : NEW_LINE INDENT def nthTerm ( self , n ) : NEW_LINE INDENT return int ( math . pow ( n , 2 ) ) - 2 * n + 2 NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT class solution : NEW_LINE INDENT def nthTerm ( self , n ) : NEW_LINE INDENT return 3 * int ( math . pow ( n , 2 ) ) + n - 2 NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def import _shashwat NEW_LINE class _shashwat ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT self . n1 = _shashwat ( * args ) NEW_LINE self . n2 = _shashwat ( * args ) NEW_LINE self . x = abs ( self . n1 ) + abs ( self . n2 ) NEW_LINE if self . n1 >= 0 and self . n2 >= 0 : NEW_LINE INDENT print ( 0 , self . x , self . x , 0 ) NEW_LINE DEDENT elif self . n1 < 0 and self . n2 >= 0 : NEW_LINE INDENT print ( ' - ' , self . x , self . x , 0 , 0 ) NEW_LINE DEDENT elif self . n1 < 0 and self . n2 < 0 : NEW_LINE INDENT print ( ' - ' , self . x , self . x , 0 , 0 , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - ' , self . x , self . x , self . x , 0 , 0 ) NEW_LINE DEDENT DEDENT DEDENT
def import _main NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import string NEW_LINE import sys NEW_LINE import string NEW_LINE import sys NEW_LINE try : NEW_LINE INDENT with open ( sys . argv [ 1 ] ) as infile : NEW_LINE INDENT s = infile . read ( ) NEW_LINE K = int ( sys . argv [ 2 ] ) NEW_LINE DEDENT subs = set ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT index = i NEW_LINE for j in range ( K ) : NEW_LINE INDENT if index + 1 + j <= len ( s ) : NEW_LINE INDENT subs . add ( s [ index : index + 1 + j ] ) NEW_LINE DEDENT DEDENT DEDENT subs2 = [ s for s in subs if s [ : K ] ] NEW_LINE subs2 . sort ( ) NEW_LINE print ( subs2 [ K - 1 ] ) NEW_LINE DEDENT
def import _solution NEW_LINE class Solution : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . memo = [ 0 , 1 ] NEW_LINE DEDENT def fib ( self , N ) : NEW_LINE INDENT if N < len ( self . memo ) : NEW_LINE INDENT return self . memo [ N ] NEW_LINE DEDENT for i in range ( len ( self . memo ) , N + 1 ) : NEW_LINE INDENT self . memo [ i - 1 ] = self . memo [ i - 2 ] NEW_LINE DEDENT return self . memo [ N ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE N = 2 NEW_LINE out = sObj . fib ( N ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT
def test_forbidden_subsequence ( ) : NEW_LINE INDENT import sys NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import exists NEW_LINE from os . path import exists NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import dirname NEW_LINE from os . path import join NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . isfile import isfile NEW_LINE from os . path import isfile NEW_LINE from os . path import isfile NEW_LINE from os . isfile import isfile NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import pi , pi NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE x = 50 NEW_LINE n = 5 NEW_LINE print ( float ( cos_x_series_to_sum ( x , 5 ) * 1000000 ) / 1000000.00 ) NEW_LINE DEDENT
def GFG ( N , S ) : NEW_LINE INDENT i = ( ( float ( N ) ** 2 ) / 4 ) - ( float ( S + 1 ) / 2 ) NEW_LINE def check ( N , S ) : NEW_LINE INDENT i = find_number ( N , S ) NEW_LINE integer_i = int ( i ) NEW_LINE if i - integer_i == 0 : NEW_LINE INDENT print ( " Yes : ▁ % d , ▁ % d " % ( integer_i , integer_i + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT N , S = 4 , 3 NEW_LINE check ( N , S ) NEW_LINE N , S = 5 , 3 NEW_LINE check ( N , S ) NEW_LINE DEDENT return check NEW_LINE DEDENT
def test_multiple_of_three ( K , dig0 , dig1 ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sum = 0 NEW_LINE temp = ( dig0 + dig1 ) % 10 NEW_LINE self . sum = dig0 + dig1 NEW_LINE if K == 2 : NEW_LINE INDENT if self . sum % 3 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT self . sum += temp NEW_LINE numberofgroups = ( K - 3 ) // 4 NEW_LINE remnumberofdigits = ( K - 3 ) % 4 NEW_LINE self . sum += ( numberofgroups * 20 ) NEW_LINE for i in range ( remnumberofdigits ) : NEW_LINE INDENT temp = ( 2 * temp ) % 10 NEW_LINE self . sum += temp NEW_LINE DEDENT if self . sum % 3 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT K , dig0 , dig1 = 5 , 3 , 4 NEW_LINE if multiple_of_three ( K , dig0 , dig1 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def import import sys , symbols , imp NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import denom NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba import numba NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba import numba NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba import numba NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba import numba NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba import numba NEW_LINE from numba import numba NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba import numba NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba . tools import convertNumbers NEW_LINE from numba . tools import convertNumbers NEW_LINE
def count_occ ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( s ) - 3 ) : NEW_LINE INDENT c , l , a , p = 0 , 0 , 0 , 0 NEW_LINE for j in range ( i , i + 4 ) : NEW_LINE INDENT if s [ j ] == ' c ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif s [ j ] == ' l ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif s [ j ] == ' a ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif s [ j ] == ' p ' : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT if c == 1 and l == 1 and a == 1 and p == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def count_steps ( self , x , y ) : NEW_LINE INDENT if x % y == 0 : NEW_LINE INDENT return x // y NEW_LINE DEDENT return x // y + count_steps ( y , x % y ) NEW_LINE DEDENT DEDENT x , y = 100 , 19 NEW_LINE print ( count_steps ( x , y ) ) NEW_LINE DEDENT
def GFG ( x ) : NEW_LINE INDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isSunnyNum ( n ) : NEW_LINE INDENT if isPerfectSquare ( n + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 3 NEW_LINE if isSunnyNum ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import pi NEW_LINE PI = 3.14159265 NEW_LINE def area_inscribed ( P , B , H ) : NEW_LINE INDENT return ( ( P + B - H ) ** 2 * ( P + B - H ) ** 2 * ( PI / 4 ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT P , B , H = 3 , 4 , 5 NEW_LINE print ( area_inscribed ( P , B , H ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = sys . stdin NEW_LINE while True : NEW_LINE INDENT N = self . sc . recv ( 256 ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT replaces = [ s . decode ( ' utf - 8' ) for s in range ( N ) ] NEW_LINE M = self . sc . recv ( 256 ) NEW_LINE for c in range ( M ) : NEW_LINE INDENT print ( replaces [ c ] if c in replaces else c , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def __GFG ( v , n ) : NEW_LINE INDENT import math NEW_LINE def __GFG ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = n - 1 - __UpperBound ( v , n , v [ i ] - 1 ) NEW_LINE if tmp == v [ i ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def __UpperBound ( x , length , value ) : NEW_LINE INDENT low = 0 NEW_LINE high = length NEW_LINE while low < high : NEW_LINE INDENT ( low , mid ) = __UpperBound ( x , length , value ) NEW_LINE if value >= x [ mid ] : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT def __GFG ( ) : NEW_LINE INDENT n = 4 NEW_LINE v = [ 1 , 2 , 3 , 4 ] NEW_LINE print ( __GFG ( v , n ) ) NEW_LINE DEDENT return __GFG NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT count_of_two , count_of_five = 0 , 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT val = i NEW_LINE while val % 2 == 0 and val > 0 : NEW_LINE INDENT val /= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while val % 5 == 0 and val > 0 : NEW_LINE INDENT val /= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT
def GfG ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 10 != 0 : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n /= 10 NEW_LINE DEDENT return res NEW_LINE def isEqual ( a , b ) : NEW_LINE INDENT if removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , b = 105 , 106 NEW_LINE if isEqual ( a , b ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def main ( args ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE from time import sleep NEW_LINE from os . path import join NEW_LINE from os import path NEW_LINE from os import listdir NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import chdir NEW_LINE from os import getcwd NEW_LINE from os import chdir NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE from os import getcwd NEW_LINE getcwd NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from numpy import array NEW_LINE from locale import getlocale NEW_LINE from os import urandom NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT with open ( " / dev / urandom " ) as scn : NEW_LINE INDENT size = scn . read ( ) NEW_LINE arr = array ( scn ) NEW_LINE print ( asd ( arr ) ) NEW_LINE DEDENT DEDENT def asd ( self ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ len ( arr ) // 2 ] NEW_LINE DEDENT DEDENT return Main NEW_LINE DEDENT
def import import sys NEW_LINE class VasyaTheHipster ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE a , b = sc . readline ( ) . split ( ) NEW_LINE count = 0 NEW_LINE while True : NEW_LINE INDENT if a and b : NEW_LINE INDENT count += 1 NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ans = a // 2 + b // 2 NEW_LINE print ( count , ans ) NEW_LINE DEDENT DEDENT
def import import sys , StringIO , pickle , pipes , pipes , c , size , words , words , c , count , words , c , flags , recarray , words , words , c , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , words , c , count , c , words , c , count , words , c , words , c , count , words , c , words , c , count , words , c , count , words , c , words , c , count , words , c , words , c , words , c , count , c , words , c , words , c , words , c , words , c , count , words , c , words , c , count , words , c ,
def GFG ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE arr1 = [ 0 ] * 7 NEW_LINE arr2 = [ 0 ] * 7 NEW_LINE for c in s1 : NEW_LINE INDENT set_bits = sum ( [ ord ( c ) for c in c ] ) NEW_LINE arr1 [ set_bits ] += 1 NEW_LINE DEDENT for c in s2 : NEW_LINE INDENT set_bits = sum ( [ ord ( c ) for c in c ] ) NEW_LINE arr2 [ set_bits ] += 1 NEW_LINE DEDENT for i in range ( 1 , 6 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def GFG ( i , sum , cnt , a , n ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT if sum == 0 and cnt > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE ans += CountSubSeq ( i + 1 , sum , cnt , a , n ) NEW_LINE ans += CountSubSeq ( i + 1 , sum + a [ i ] , cnt + 1 , a , n ) NEW_LINE return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from string import printable NEW_LINE reader = sys . stdin NEW_LINE n = len ( reader ) NEW_LINE s = [ ] NEW_LINE new_s = [ ] NEW_LINE input = reader . read ( ) NEW_LINE s = input . split ( ) NEW_LINE mid = ( n - 1 ) // 2 NEW_LINE counter = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = i + 1 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT new_s . append ( mid - counter ) NEW_LINE DEDENT else : NEW_LINE INDENT new_s . append ( s [ i ] ) NEW_LINE DEDENT if counter >= 0 : NEW_LINE INDENT counter = counter - temp NEW_LINE DEDENT else : NEW_LINE INDENT counter = counter + temp NEW_LINE DEDENT DEDENT print ( printable ( new_s ) ) NEW_LINE DEDENT
def import __count__ NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = 1 NEW_LINE self . n = 1 NEW_LINE self . m = 1 NEW_LINE self . count = 0 NEW_LINE for i in range ( 1 , pow ( i + a , n ) + 1 ) : NEW_LINE INDENT x = int ( pow ( i + a , n ) ) NEW_LINE y = self . _count ( x ) NEW_LINE if y == i : NEW_LINE INDENT self . count += 1 NEW_LINE DEDENT DEDENT print ( self . count ) NEW_LINE DEDENT def _count ( self ) : NEW_LINE INDENT count = 0 NEW_LINE while x > 0 : NEW_LINE INDENT self . count += self . count % 10 NEW_LINE x /= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT
def pivoted_binary_search ( arr , n , key ) : NEW_LINE INDENT pivot = find_pivot ( arr , 0 , n - 1 ) NEW_LINE if pivot == - 1 : NEW_LINE INDENT return binary_search ( arr , 0 , n - 1 , key ) NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binary_search ( arr , 0 , pivot - 1 , key ) NEW_LINE DEDENT return binary_search ( arr , pivot + 1 , n - 1 , key ) NEW_LINE DEDENT def find_pivot ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if mid < high and arr [ mid ] > arr [ mid + 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if arr [ low ] >= arr [ mid ] : NEW_LINE INDENT return find_pivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return find_pivot ( arr , mid + 1 , high ) NEW_LINE DEDENT def find_pivot ( arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return binary_search ( arr , ( mid + 1 , high ) , key ) NEW_LINE DEDENT return find_pivot ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE key = 3 NEW_LINE print ( " Index ▁ of ▁ the ▁ element ▁ is ▁ : ▁ " , pivoted_binary_search ( arr1 , n , key ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import import sys NEW_LINE class HocPython ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n , mod = 1000000007 , 1000000007 NEW_LINE self . n = self . n NEW_LINE DEDENT res = 0 NEW_LINE c = [ 0 ] * 4050 NEW_LINE dp = [ 0 ] * 4050 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT c [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i ) : NEW_LINE INDENT c [ i ] [ j ] = ( c [ i - 1 ] [ j - 1 ] + c [ i - 1 ] [ j ] ) % mod NEW_LINE DEDENT c [ i ] [ i ] = 1 NEW_LINE DEDENT dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT dp [ i ] = ( dp [ i ] + dp [ j ] * c [ i - 1 ] [ j ] ) % mod NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT g = dp [ i ] * c [ n ] [ i ] % mod NEW_LINE res = ( res + g ) % mod NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def import _pylab NEW_LINE import pylab NEW_LINE import sys NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . cm as cm NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . gridspec as gridspec NEW_LINE class A843 ( mpl . gridspec ) : NEW_LINE INDENT def __init__ ( self , ax = None ) : NEW_LINE INDENT plt . figure ( ) NEW_LINE self . ax = ax NEW_LINE self . N = len ( self . N ) NEW_LINE DEDENT def get_points ( self ) : NEW_LINE INDENT P = [ ( n , n ) for n in self . N ] NEW_LINE P . sort ( key = lambda x : x [ 1 ] ) NEW_LINE output = [ ] NEW_LINE self . line_count = 0 NEW_LINE self . used = [ False ] * N NEW_LINE for n in self . N : NEW_LINE INDENT if not self . used : NEW_LINE INDENT self . line_count += 1 NEW_LINE count = 0 NEW_LINE pos = n NEW_LINE line = [ ] NEW_LINE while not self . used [ pos ] : NEW_LINE INDENT count += 1 NEW_LINE self . used [ pos ] = True NEW_LINE line . append ( ' ▁ ' * ( pos + 1 ) ) NEW_LINE pos = self . P [ pos ] [ 0 ] NEW_LINE DEDENT output . append ( count + line + ' \n ' ) NEW_LINE DEDENT DEDENT print ( self . line_count , end = ' ' ) NEW_LINE sys . stdout . writelines ( output ) NEW_LINE DEDENT DEDENT
def import import _sys , get_move_distance NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT import sys NEW_LINE stdin = sys . stdin NEW_LINE d = sys . stdin . read ( ) NEW_LINE dx = [ 0 , 1 , 0 , - 1 ] NEW_LINE dy = [ - 1 , 0 , 1 , 0 ] NEW_LINE UP = 0 NEW_LINE RIGHT = 1 NEW_LINE DOWN = 2 NEW_LINE LEFT = 3 NEW_LINE for t in range ( d ) : NEW_LINE INDENT n = stdin . read ( ) NEW_LINE map = [ ] NEW_LINE for x in map : NEW_LINE INDENT x . append ( ' ▁ ' ) NEW_LINE DEDENT x = 0 NEW_LINE y = n NEW_LINE dir = UP NEW_LINE move = get_move_distance ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in move [ i ] : NEW_LINE INDENT x += dx [ dir ] NEW_LINE y += dy [ dir ] NEW_LINE map [ y ] [ x ] = ' # ' NEW_LINE DEDENT dir = ( dir + 1 ) % 4 NEW_LINE DEDENT for x in map : NEW_LINE INDENT print ( ' ' . join ( x ) ) NEW_LINE DEDENT if t < d - 1 : NEW_LINE INDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT def get_move_distance ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT ans = [ 1 ] NEW_LINE return ans NEW_LINE DEDENT else : NEW_LINE INDENT ans = [ n ] NEW_LINE rest = n NEW_LINE rest -= 1 NEW_LINE for index in range ( 1 , n ) : NEW_LINE INDENT ans . append ( rest ) NEW_LINE index += 1 NEW_LINE if index >= n : NEW_LINE INDENT break NEW_LINE DEDENT ans . append ( rest ) NEW_LINE index += 1 NEW_LINE rest -= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT DEDENT
def p090 ( ) : NEW_LINE INDENT print ( eval ( ' p090' ) ) NEW_LINE def test_bit ( x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9
def import import sys , StringIO , traceback , nx , topo_order , load_adj_list , print_adj_list , total_vertex , degree , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , adj_list , ) NEW_LINE
def import import sys , string , traceback NEW_LINE class Main1 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n = sc . readline ( ) . strip ( ) NEW_LINE m = sc . readline ( ) . strip ( ) NEW_LINE pic = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = sc . readline ( ) . strip ( ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT pic [ i ] . append ( temp [ j ] ) NEW_LINE DEDENT DEDENT inc , inc1 = 0 , 0 NEW_LINE comeIn = [ False ] * 4 NEW_LINE if n > 1 or m > 1 : NEW_LINE INDENT for x in range ( n - 1 ) : NEW_LINE INDENT for y in range ( m - 1 ) : NEW_LINE INDENT for i in range ( x , 2 + x ) : NEW_LINE INDENT for j in range ( y , 2 + y ) : NEW_LINE INDENT if pic [ i ] [ j ] == ' f ' and comeIn [ 0 ] == False : NEW_LINE INDENT inc += 1 NEW_LINE comeIn [ 0 ] = True NEW_LINE DEDENT elif pic [ i ] [ j ] == ' a ' and comeIn [ 1 ] == False : NEW_LINE INDENT inc += 1 NEW_LINE comeIn [ 1 ] = True NEW_LINE DEDENT elif pic [ i ] [ j ] == ' c ' and comeIn [ 2 ] == False : NEW_LINE INDENT inc += 1 NEW_LINE comeIn [ 2 ] = True NEW_LINE DEDENT elif pic [ i ] [ j ] == ' e ' and comeIn [ 3 ] == False : NEW_LINE INDENT inc += 1 NEW_LINE comeIn [ 3 ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if inc == 4 : NEW_LINE INDENT inc1 += 1 NEW_LINE DEDENT inc = 0 NEW_LINE traceback . append ( comeIn ) NEW_LINE DEDENT DEDENT print ( inc1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT DEDENT
def _main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import chain NEW_LINE from itertools import chain NEW_LINE class AlternatingCurrent ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . next = None NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return next ( self . next ) NEW_LINE DEDENT DEDENT f = open ( " / etc / init . d / " , " r " ) NEW_LINE inp = f . read ( ) . strip ( ) . split ( " \n " ) NEW_LINE stk = chain ( [ ] , [ ] ) NEW_LINE for c in inp : NEW_LINE INDENT if not stk : NEW_LINE INDENT stk . append ( c ) NEW_LINE continue NEW_LINE DEDENT top = stk [ - 1 ] NEW_LINE if top == c : NEW_LINE INDENT stk . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( c ) NEW_LINE DEDENT DEDENT if not stk : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def import _scanner NEW_LINE import sys NEW_LINE import random NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . X , self . Y , self . E = random . randint ( 0 , sys . maxint ) NEW_LINE self . x , self . y = [ ] , [ ] NEW_LINE self . g = [ [ ] for i in range ( self . X + self . Y ) ] NEW_LINE self . vis = [ False ] * self . X + self . Y NEW_LINE self . match_to = [ - 1 ] * self . X NEW_LINE match = 0 NEW_LINE for i in range ( self . X ) : NEW_LINE INDENT [ vis [ i ] ] = False NEW_LINE if self . dfs ( i ) : NEW_LINE INDENT match += 1 NEW_LINE DEDENT DEDENT print ( match ) NEW_LINE DEDENT def dfs ( v ) : NEW_LINE INDENT if v < 0 : NEW_LINE INDENT return True NEW_LINE DEDENT for u in self . g [ v ] : NEW_LINE INDENT if vis [ u ] : NEW_LINE INDENT continue NEW_LINE DEDENT vis [ u ] = True NEW_LINE if self . dfs ( v ) : NEW_LINE INDENT match_to [ u ] = v NEW_LINE match_to [ v ] = u NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
def import _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mountains , _count_mouns
def GFG ( ) : NEW_LINE INDENT N = 100005 NEW_LINE d , pre = [ 0 ] * N , [ 0 ] * N NEW_LINE class Positive_Divisors ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , 2 * i + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if d [ i ] == d [ i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print ( pre [ n ] ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s = raw_input ( " > > > ▁ " ) NEW_LINE t = len ( s ) NEW_LINE m = len ( s ) NEW_LINE memory = [ 0 ] * m NEW_LINE alloc_idx = 0 NEW_LINE for j in range ( t ) : NEW_LINE INDENT if s . format == " alloc " : NEW_LINE INDENT n = s . index ( " ▁ " ) NEW_LINE data = [ ] NEW_LINE can_alloc = False NEW_LINE for i in range ( m ) : NEW_LINE INDENT if data == 0 : NEW_LINE INDENT data . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT data . append ( 0 ) NEW_LINE DEDENT if data == n : NEW_LINE INDENT can_alloc = True NEW_LINE data = i - n + 1 NEW_LINE break NEW_LINE DEDENT DEDENT if can_alloc : NEW_LINE INDENT alloc_idx += 1 NEW_LINE for i in range ( data , data + n ) : NEW_LINE INDENT memory [ i ] = alloc_idx NEW_LINE DEDENT print ( alloc_idx ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NULL " ) NEW_LINE DEDENT DEDENT elif s . format == " erase " : NEW_LINE INDENT x = s . index ( " ▁ " ) NEW_LINE if x <= 0 : NEW_LINE INDENT print ( " ILLEGAL _ ERASE _ ARGUMENT " ) NEW_LINE DEDENT has_erase_arg = False NEW_LINE for i in range ( m ) : NEW_LINE INDENT if memory [ i ] == x : NEW_LINE INDENT memory [ i ] = 0 NEW_LINE has_erase_arg = True NEW_LINE DEDENT DEDENT if not has_erase_arg : NEW_LINE INDENT print ( " ILLEGAL _ ERASE _ ARGUMENT " ) NEW_LINE DEDENT DEDENT elif s . format == " defragment " : NEW_LINE INDENT d = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if data == 0 : NEW_LINE INDENT d += 1 NEW_LINE DEDENT else : NEW_LINE INDENT memory [ i - d ] = memory [ i ] NEW_LINE DEDENT DEDENT for i in range ( m - d , m ) : NEW_LINE INDENT memory [ i ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " h " ) NEW_LINE DEDENT DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import sin , cos , tan NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n , ** kwargs ) : NEW_LINE INDENT self . P = ( self . P ** n ) NEW_LINE self . A = cos ( self . A ) / ( 2 * tan ( ( 180 / self . n ) * 3.14159 / 180 ) ) NEW_LINE self . area = ( self . P * A ) / 2 NEW_LINE DEDENT def area_of_triangle_inscribed ( self , n , ** kwargs ) : NEW_LINE INDENT area = area_of_regular_polygon ( self , n , ** kwargs ) NEW_LINE triangle = area / n NEW_LINE ins_tri = ( triangle * 3 ) NEW_LINE return ins_tri NEW_LINE DEDENT def main ( self , arg ) : NEW_LINE INDENT n , shape = 6 , 10 NEW_LINE print ( " % .3f " % area_of_triangle_inscribed ( self , n , shape ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def GFG ( x , n ) : NEW_LINE INDENT MAX = 256 NEW_LINE def lastNonRepeating ( x , n ) : NEW_LINE INDENT freq = [ 0 ] * MAX NEW_LINE for ch in x : NEW_LINE INDENT freq [ ch ] += 1 NEW_LINE DEDENT for ch in x [ n - 1 : : - 1 ] : NEW_LINE INDENT if freq [ ch ] == 1 : NEW_LINE INDENT return ( " % s " % ch ) NEW_LINE DEDENT DEDENT return " - 1" NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = " GeeksForGeeks " NEW_LINE n = len ( x ) NEW_LINE print ( lastNonRepeating ( x , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import import sys , traceback NEW_LINE import inspect NEW_LINE import sys NEW_LINE import sys NEW_LINE import inspect NEW_LINE import inspect NEW_LINE import sys NEW_LINE def main ( * obj ) : NEW_LINE INDENT with open ( sys . argv [ 1 ] ) as infile , open ( sys . argv [ 2 ] , ' w ' ) as outfile : NEW_LINE INDENT n = len ( infile ) NEW_LINE a , b = [ ] , [ ] NEW_LINE left , right = sys . maxsize , sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( infile . read ( ) ) NEW_LINE b . append ( infile . read ( ) ) NEW_LINE left = min ( a ) NEW_LINE right = max ( b ) NEW_LINE DEDENT ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == left and b [ i ] == right : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT outfile . write ( ans ) NEW_LINE outfile . close ( ) NEW_LINE DEDENT DEDENT
def GFG ( x ) : return ( 1 / ( 1 + x ) ) NEW_LINE def BooleRule ( a , b ) : NEW_LINE INDENT n = 4 NEW_LINE if b == 0 : NEW_LINE INDENT h = int ( ( b - a ) / n ) NEW_LINE DEDENT else : NEW_LINE INDENT h = int ( ( b - a ) / n ) NEW_LINE DEDENT sum = 0 NEW_LINE bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 NEW_LINE sum = sum + bl NEW_LINE return sum NEW_LINE DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , max_n = 300 , max_m = 300 ) : NEW_LINE INDENT self . max_n = max_n NEW_LINE self . max_m = max_m NEW_LINE self . dp = [ [ 0 ] * ( max_n - 1 ) for i in range ( self . max_n ) ] NEW_LINE self . v = [ [ 0 ] * ( max_m - 1 ) for i in range ( self . max_m ) ] NEW_LINE DEDENT def find_len ( arr , i , curr , n , m ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT if curr == m : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if self . v [ i ] [ curr ] : NEW_LINE INDENT return self . dp [ i ] [ curr ] NEW_LINE DEDENT self . v [ i ] [ curr ] = True NEW_LINE l = find_len ( arr , i + 1 , curr , n , m ) NEW_LINE r = find_len ( arr , i + 1 , curr & arr [ i ] , n , m ) NEW_LINE self . dp [ i ] [ curr ] = l NEW_LINE if r != - 1 : NEW_LINE INDENT self . dp [ i ] [ curr ] = max ( self . dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return self . dp [ i ] [ curr ] NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE ans = find_len ( arr , 0 , ( ( 1 << 8 ) - 1 ) , n , m ) NEW_LINE if ans == - 1 : NEW_LINE INDENT sys . stdout . write ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( ans ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT maxN = 20 NEW_LINE maxM = 64 NEW_LINE dp = [ [ 0 for i in range ( maxN ) ] for i in range ( maxM ) ] NEW_LINE v = [ [ False for i in range ( maxN ) ] for i in range ( maxM ) ] NEW_LINE def find_len ( arr , i , curr , n , m ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT if curr == m : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if v [ i ] [ curr ] : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = True NEW_LINE l = find_len ( arr , i + 1 , curr , n , m ) NEW_LINE r = find_len ( arr , i + 1 , curr | arr [ i ] , n , m ) NEW_LINE dp [ i ] [ curr ] = l NEW_LINE if r != - 1 : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE ans = find_len ( arr , 0 , 0 , n , m ) NEW_LINE if ans == - 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT return dp NEW_LINE DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . cost = [ ] NEW_LINE self . n = n NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT for _ in range ( self . n ) : NEW_LINE INDENT self . cost . append ( [ ] ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT for _ in range ( self . n ) : NEW_LINE INDENT self . cost = [ ] NEW_LINE self . ans = 0 NEW_LINE for a , b , c in self . cost [ : - 1 ] : NEW_LINE INDENT self . cost [ a ] [ b ] = self . cost [ b ] [ a ] = c NEW_LINE self . ans += self . cost [ a ] [ b ] * 2 NEW_LINE DEDENT for i in range ( 1 , self . n + 1 ) : NEW_LINE INDENT reaf = ii , jj = 0 , 0 NEW_LINE for j in range ( 1 , self . n + 1 ) : NEW_LINE INDENT if self . cost [ i ] [ j ] > 0 or self . cost [ i ] [ j ] == - 1 : NEW_LINE INDENT reaf += 1 NEW_LINE ii , jj = i , j NEW_LINE DEDENT DEDENT if i != 1 and reaf == 1 : NEW_LINE INDENT ans -= self . cost [ ii ] [ jj ] * 2 NEW_LINE self . cost [ ii ] [ jj ] = self . cost [ jj ] [ ii ] = - 1 NEW_LINE DEDENT DEDENT print ( ans - max ( 1 ) ) NEW_LINE DEDENT DEDENT def max ( self ) : NEW_LINE INDENT cut = 0 NEW_LINE for i in range ( 2 , self . n + 1 ) : NEW_LINE INDENT if self . cost [ m ] [ i ] > 0 : NEW_LINE INDENT self . cost [ i ] [ m ] = 0 NEW_LINE cut = max ( cut , self . cost [ m ] [ i ] + max ( i ) ) NEW_LINE DEDENT DEDENT return cut NEW_LINE DEDENT DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = _main ( ) NEW_LINE S = sc . next ( ) NEW_LINE N = int ( S ) NEW_LINE ans = 0 NEW_LINE for i in range ( 3 , len ( S ) - 1 ) : NEW_LINE INDENT ans += int ( pow ( 3 , i ) - 3 * int ( pow ( 2 , i ) ) + 3 ) NEW_LINE DEDENT ans += f ( 3 * int ( pow ( 10 , len ( S ) - 1 ) ) , S [ - 2 ] ) NEW_LINE ans += f ( 5 * int ( pow ( 10 , len ( S ) - 1 ) ) , S [ - 2 ] ) NEW_LINE ans += f ( 7 * int ( pow ( 10 , len ( S ) - 1 ) ) , S [ - 2 ] ) NEW_LINE print ( ans ) NEW_LINE DEDENT def f ( self , a , m ) : NEW_LINE INDENT if m >= 0 : NEW_LINE INDENT return f ( self , a + 3 * int ( pow ( 10 , m ) ) , m - 1 ) + f ( self , a + 5 * int ( pow ( 10 , m ) ) , m - 1 ) + f ( self , a + 7 * int ( pow ( 10 , m ) ) , m - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT s = str ( a ) NEW_LINE if s . find ( "3" ) != - 1 and s . find ( "5" ) != - 1 and s . find ( "7" ) != - 1 and a <= N : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT return Main NEW_LINE DEDENT
def test_gf_diff ( arr , n , k ) : NEW_LINE INDENT from scipy . optimize import mindiff NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . arr = arr NEW_LINE self . n = n NEW_LINE self . k = k NEW_LINE DEDENT def min ( self ) : NEW_LINE INDENT return min ( self . arr [ self . n - 1 ] - self . arr [ self . k ] ) NEW_LINE DEDENT DEDENT arr = [ 10 , 100 , 300 , 200 , 1000 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( mindiff ( arr , n , k ) ) NEW_LINE DEDENT
def import import sys , string NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 0 NEW_LINE self . t = [ ] NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n = sc . read ( ) NEW_LINE while n > 0 : NEW_LINE INDENT n -= 1 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT self . t . append ( sc . read ( ) ) NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT L , R = 0 , 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if L < t [ i ] : L = t [ i ] NEW_LINE elif R < t [ i ] : R = t [ i ] NEW_LINE else : return " NO " NEW_LINE DEDENT return " YES " NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT return Main ( ) NEW_LINE DEDENT DEDENT
def problem1455b ( ) : NEW_LINE INDENT import sys NEW_LINE from pymavlink . generator import mavtemplate NEW_LINE with open ( " test . txt " , " r " ) as sc : NEW_LINE INDENT t = mavtemplate . MAVTemplate ( ) NEW_LINE while t : NEW_LINE INDENT x = sc . get ( " x " ) NEW_LINE val = 0 NEW_LINE turn = 0 NEW_LINE while val < x : NEW_LINE INDENT val += turn + 1 NEW_LINE turn += 1 NEW_LINE DEDENT if val == x : NEW_LINE INDENT print ( turn ) NEW_LINE DEDENT elif val == x + 1 : NEW_LINE INDENT print ( turn + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( turn ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , arr , n ) : NEW_LINE INDENT self . sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT self . sum = self . sum + arr [ i ] NEW_LINE DEDENT DEDENT def meanAbsDevtion ( self , arr , n ) : NEW_LINE INDENT absSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT absSum = absSum + abs ( arr [ i ] - Mean ( arr , n ) ) NEW_LINE DEDENT return absSum / n NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 10 , 15 , 15 , 17 , 18 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( meanAbsDevtion ( arr , n ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def p204 ( ) : print ( eval ( ' count ( 0 , ▁ 1 ) ' ) ) NEW_LINE def count ( ) : return str ( count ( 0 , 1 ) ) NEW_LINE LIMIT = lib . pow ( 10 , 9 ) NEW_LINE primes = lib . list_primes ( 100 ) NEW_LINE def count ( prime_index , product ) : NEW_LINE INDENT if prime_index == len ( primes ) : return 1 if product <= LIMIT else 0 NEW_LINE else : NEW_LINE INDENT count = 0 NEW_LINE while product <= LIMIT : NEW_LINE INDENT count += count ( prime_index + 1 , product ) NEW_LINE product *= primes [ prime_index ] NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT
def _maximumXOR ( n , l , r ) : NEW_LINE INDENT import math NEW_LINE import random NEW_LINE import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def maximumXOR ( self , n , l , r ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( int ( math . log ( r ) / math . log ( 2 ) ) , - 1 , - 1 ) : NEW_LINE INDENT if n & ( 1 << i ) > 0 : NEW_LINE INDENT if ( x > r ) or ( x + ( 1 << i ) - 1 < l ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( x ^ ( 1 << i ) ) <= r : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT DEDENT return n ^ x NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT n , l , r = 7 , 2 , 23 NEW_LINE print ( " The ▁ output ▁ is ▁ " , maximumXOR ( n , l , r ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def test_gf_gcd ( ) : NEW_LINE INDENT from sympy . combinatorics . factor_list import ZZ NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . arr = [ False ] * ( N + 5 ) NEW_LINE for i in range ( 3 , i * N + 1 , 2 ) : NEW_LINE INDENT if not arr [ i ] : NEW_LINE INDENT for j in range ( i * i , i + 1 , N + i ) : NEW_LINE INDENT self . arr [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT prime = gf_gcd ( len ( prime ) , 2 ) NEW_LINE for i in range ( 3 , i * N + 2 , 2 ) : NEW_LINE INDENT if not arr [ i ] : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT DEDENT i , ans = 0 , 1 NEW_LINE while ans * prime [ i ] <= N and i < len ( prime ) : NEW_LINE INDENT ans *= prime [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import factorial NEW_LINE from math import log NEW_LINE from math import log NEW_LINE class GFG ( object ) : NEW_LINE INDENT def count_trailing_zeros ( self , n ) : NEW_LINE INDENT bit = str ( n ) NEW_LINE bit1 = list ( bit ) NEW_LINE bit1 = bit1 . reverse ( ) NEW_LINE zero = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if bit1 [ i ] == '0' : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = 4 NEW_LINE ans = count_trailing_zeros ( self , n ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def import _input NEW_LINE class Shopping : NEW_LINE INDENT def input ( self , number_one , number_two , number_three ) : NEW_LINE INDENT one = number_one + number_two + number_three NEW_LINE two = 2 * ( number_one + number_two ) NEW_LINE three = 2 * ( number_one + number_three ) NEW_LINE four = 2 * ( number_two + number_three ) NEW_LINE print ( _input ( _input ( one , two ) , _input ( three , four ) ) ) NEW_LINE DEDENT def main ( self , a ) : NEW_LINE INDENT input = raw_input ( " Input : ▁ " ) NEW_LINE instance = Shopping ( ) NEW_LINE num_one = input . __next__ ( ) NEW_LINE num_two = input . __next__ ( ) NEW_LINE num_three = input . __next__ ( ) NEW_LINE instance . input ( num_one , num_two , num_three ) NEW_LINE DEDENT DEDENT
def import import sys , string , * , recur , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes pipes , pipes , pipes , pipes , pipes , pipes , pipes , pipes " pipes " ) NEW_LINE from pipes import pipes NEW_LINE class ( pipes , pipes , pipes , pipes , pipes , pipes , pipes )
def __distinctSubString ( P , Q , K , N ) : NEW_LINE INDENT import sys NEW_LINE S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = P [ j ] - ord ( ' a ' ) NEW_LINE sum += Q [ pos ] - ord ( '0' ) NEW_LINE s += P [ j ] NEW_LINE if sum <= K : NEW_LINE INDENT S . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT
def makeEven ( string ) : NEW_LINE INDENT data = string . split ( ' ▁ ' ) NEW_LINE n = len ( data ) NEW_LINE even , index = int ( data [ index ] ) , 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ord ( data [ i ] ) - ord ( '0' ) % 2 == 0 : NEW_LINE INDENT even , index = ord ( data [ i ] ) , i NEW_LINE DEDENT if even <= ord ( data [ n - 1 ] ) - ord ( '0' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if even == int ( data [ index ] ) : NEW_LINE INDENT return data NEW_LINE DEDENT swap ( data , index , n - 1 ) NEW_LINE return data NEW_LINE DEDENT
def find_divisors ( n ) : NEW_LINE INDENT div = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n * i + 1 ) : NEW_LINE INDENT div [ i * j ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = 10 NEW_LINE find_divisors ( n ) NEW_LINE DEDENT DEDENT
def import _sys , _sys , _sys , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _proc , _
def import _geeksforgeeks NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . MAX_CHAR = 256 NEW_LINE DEDENT def printDistinct ( self ) : NEW_LINE INDENT n = len ( self . data ) NEW_LINE count = [ 0 for i in range ( self . MAX_CHAR ) ] NEW_LINE index = [ n ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT x = self . data [ i ] NEW_LINE count [ x ] += 1 NEW_LINE if count [ x ] == 1 and x != ' ▁ ' : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if count [ x ] == 2 : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT self . index = sorted ( index ) NEW_LINE for i in range ( self . MAX_CHAR ) : NEW_LINE INDENT print ( self . data [ index [ i ] ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( self , args ) : NEW_LINE INDENT data = ' GeeksforGeeks ' NEW_LINE printDistinct ( data ) NEW_LINE DEDENT DEDENT
def GFG ( x , k , m ) : NEW_LINE INDENT result = x NEW_LINE k -= 1 NEW_LINE while k > 0 : NEW_LINE INDENT result = int ( pow ( result , x ) ) NEW_LINE if result > m : NEW_LINE INDENT result %= m NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def import import string , * , repr = string . printable , verbose = False ) : NEW_LINE INDENT import sys NEW_LINE import string NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def converthenumber ( self , n ) : NEW_LINE INDENT s = string . printable NEW_LINE res = " " NEW_LINE for c in s : NEW_LINE INDENT if c in ( '1' , '3' , '5' , '7' , '9' ) : NEW_LINE INDENT res += c NEW_LINE DEDENT if len ( res ) == 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if len ( res ) == 2 : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT if sys . version_info [ 0 ] == 2 : NEW_LINE INDENT print ( sys . version ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sys . version ) NEW_LINE DEDENT n = 18720 NEW_LINE return Main ( n ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from itertools import repeat NEW_LINE from itertools import chain NEW_LINE from random import choice NEW_LINE from itertools import chain NEW_LINE from itertools import chain NEW_LINE from itertools import chain NEW_LINE from itertools import repeat NEW_LINE from itertools import chain NEW_LINE from itertools import chain NEW_LINE from itertools import chain as chain NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE from itertools import isPrime NEW_LINE DEDENT
def import java . io io io NEW_LINE import sys NEW_LINE from java . io import StringIO NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . io import BufferedReader , BufferedWriter NEW_LINE from java . io import StringIO NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE from java . util import get_filesystem_encoding NEW_LINE class GetSystemSystemEncoding ( ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . __init__ = None NEW_LINE self .
def _import ( ) : return ( n * ( 1 + an ) ) / 2 NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n , an ) : NEW_LINE INDENT self . an = 1 + ( n - 1 ) * ( m + 1 ) NEW_LINE self . rowmajorsum = self . sn ( n , an ) NEW_LINE self . an = 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE self . colmajorsum = self . sn ( n , an ) NEW_LINE return self . rowmajorsum + self . colmajorsum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT N , M = 3 , 3 NEW_LINE print ( self . trace ( N , M ) ) NEW_LINE DEDENT DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . raw_input = raw_input NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . h , self . w = self . raw_input ( ) NEW_LINE self . field = [ ] NEW_LINE self . orbs = [ [ 0 ] * ( self . h + 1 ) for _ in range ( self . h + 1 ) ] NEW_LINE self . ingots = [ [ 0 ] * ( self . w + 1 ) for _ in range ( self . h + 1 ) ] NEW_LINE for i in range ( self . h ) : NEW_LINE INDENT self . field [ i ] = self . raw_input ( ) . decode ( ' utf - 8' ) NEW_LINE for j in range ( self . w - 1 , - 1 , - 1 ) : NEW_LINE INDENT self . orbs [ i ] [ j ] = self . orbs [ i ] [ j + 1 ] NEW_LINE if self . field [ i ] [ j ] == ' O ' : NEW_LINE INDENT self . orbs [ i ] [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for j in range ( self . w ) : NEW_LINE INDENT for i in range ( self . h - 1 , - 1 , - 1 ) : NEW_LINE INDENT self . ingots [ i ] [ j ] = self . ingots [ i + 1 ] [ j ] NEW_LINE if self . field [ i ] [ j ] == ' I ' : NEW_LINE INDENT self . ingots [ i ] [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT total = 0 NEW_LINE for i in range ( self . h ) : NEW_LINE INDENT for j in range ( self . w ) : NEW_LINE INDENT if self . field [ i ] [ j ] == ' J ' : NEW_LINE INDENT total += self . orbs [ i ] [ j ] * self . ingots [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( total ) NEW_LINE DEDENT
def test_gf_gcd ( ) : NEW_LINE INDENT from sympy . polys . domains import ZZ NEW_LINE class GFG ( ZZ ) : NEW_LINE INDENT def __init__ ( self , n , k ) : NEW_LINE INDENT self . count , i = 0 , 0 NEW_LINE for f in [ 1 , sqrt ( n ) ] : NEW_LINE INDENT if n % f == 0 : NEW_LINE INDENT if f % k == 0 : NEW_LINE INDENT self . count += 1 NEW_LINE DEDENT if ( n // f ) % k == 0 : NEW_LINE INDENT self . count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( i ** 2 == n ) : NEW_LINE INDENT self . count -= 1 NEW_LINE DEDENT return self . count NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n , k = 12 , 3 NEW_LINE print ( gf_gcd ( GFG ( n , k ) , GFG ( n , k ) ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def test_gf_gcd ( ) : NEW_LINE INDENT from sympy . combinatorics . factorials import gcd NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . count , i = 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if self . n % i == 0 and self . k % i == 0 : NEW_LINE INDENT self . count += 1 NEW_LINE DEDENT DEDENT return self . count NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n , k = 12 , 3 NEW_LINE print ( gf_gcd ( self . n , self . k ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def GFG ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y % 2 == 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if N < 6 : NEW_LINE INDENT temp = " " NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = temp + chr ( X + 48 ) NEW_LINE DEDENT res = int ( temp ) % M NEW_LINE return res NEW_LINE DEDENT if N % 2 == 0 : NEW_LINE INDENT half = findModuloByM ( X , N / 2 , M ) % M NEW_LINE res = ( half * power ( 10 , N / 2 , M ) + half ) % M NEW_LINE return res NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N / 2 , M ) % M NEW_LINE res = ( half * power ( 10 , N / 2 + 1 , M ) + half * 10 + X ) % M NEW_LINE return res NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT X , N , M = 6 , 14 , 9 NEW_LINE print ( findModuloByM ( X , N , M ) ) NEW_LINE DEDENT DEDENT
def test_integer_points ( ) : NEW_LINE INDENT import sys NEW_LINE from sympy . utilities . interactiveshell import InteractiveShell NEW_LINE sc = InteractiveShell ( ) NEW_LINE t = sc . current_size NEW_LINE out = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = sc . current_size NEW_LINE p2 = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT p2 += ( sc . current_size % 2 + 1 ) % 2 NEW_LINE DEDENT m = sc . current_size NEW_LINE q2 = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT q2 += ( sc . current_size % 2 + 1 ) % 2 NEW_LINE DEDENT out . append ( long ( p2 ) * q2 + long ( n - p2 ) * ( m - q2 ) ) NEW_LINE DEDENT for i in range ( t ) : NEW_LINE INDENT print ( out [ i ] ) NEW_LINE DEDENT DEDENT
def find_max_diff ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE if n < 2 : NEW_LINE INDENT print ( " Invalid ▁ " ) NEW_LINE return 0 NEW_LINE DEDENT min_val , max_val = sys . maxint , sys . maxint NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] - arr [ i ] NEW_LINE DEDENT if ( arr [ i ] - arr [ i ] < min_val ) : NEW_LINE INDENT min_val = arr [ i ] - arr [ i ] NEW_LINE DEDENT DEDENT return ( max_val - min_val ) NEW_LINE DEDENT
def import import sys NEW_LINE from B1150 import solve NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE from B1150 import B1150 NEW_LINE DEDENT
def GFG ( m , n ) : NEW_LINE INDENT count = [ [ 1 for i in range ( m ) ] for j in range ( n ) ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class Solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = sys . stdin NEW_LINE self . t = sys . stdin . readline ( ) . strip ( ) NEW_LINE DEDENT DEDENT for i in range ( 1 , len ( sys . argv ) ) : NEW_LINE INDENT n = sys . stdin . readline ( ) . strip ( ) NEW_LINE a = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( sc . randint ( 0 , n ) ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT if sum % n != 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT sum /= n NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == sum : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( n , k ) : NEW_LINE INDENT if ( n >> ( k - 1 ) ) == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE def setKthBit ( n , k ) : NEW_LINE INDENT return ( ( 1 << ( k - 1 ) ) | n ) NEW_LINE DEDENT def allBitsAreSet ( n ) : NEW_LINE INDENT if ( ( n + 1 ) & n ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def bitsAreInAltOrder ( n ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) NEW_LINE return allBitsAreSet ( num ) NEW_LINE DEDENT def bitsAreInAltPatrnInGivenRange ( n , l , r ) : NEW_LINE INDENT if isKthBitSet ( n , r ) : NEW_LINE INDENT num = n NEW_LINE left_shift = r NEW_LINE DEDENT else : NEW_LINE INDENT num = setKthBit ( n , ( r + 1 ) ) NEW_LINE left_shift = r + 1 NEW_LINE DEDENT num = num & ( ( 1 << left_shift ) - 1 ) NEW_LINE num = num >> ( l - 1 ) NEW_LINE return bitsAreInAltOrder ( num ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , l , r = 18 , 1 , 3 NEW_LINE if bitsAreInAltPatrnInGivenRange ( n , l , r ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def _import ( ) : return _import ( ) NEW_LINE from sympy . core . compatibility import builtins NEW_LINE from sympy . polys . polyroots import RootOf NEW_LINE class GFG ( object ) : NEW_LINE INDENT def factorial ( self ) : NEW_LINE INDENT if self . n <= 1 : return 1 NEW_LINE return self . n * factorial ( self . n - 1 ) NEW_LINE DEDENT def nCr ( self , n , r ) : NEW_LINE INDENT return factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) NEW_LINE DEDENT def NumberOfWays ( self , n , x , y ) : NEW_LINE INDENT return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) ** 2 NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n , x , y = 5 , 4 , 2 NEW_LINE print ( NumberOfWays ( self , n , x , y ) ) NEW_LINE DEDENT DEDENT
def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import digits NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii_lowercase NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE from string import ascii NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy . testing import assert_equal NEW_LINE from numpy . testing import assert_equal NEW_LINE N = len ( sys . argv ) NEW_LINE a = np . random . rand ( N * 3 , N ) NEW_LINE a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( N , 3 * N , 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE N = sc . read ( ) NEW_LINE a = [ sc . read ( ) for i in range ( 1 , N + 1 ) ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT count = 0 NEW_LINE valid = True NEW_LINE current = 1 NEW_LINE while valid : NEW_LINE INDENT count += 1 NEW_LINE current = a [ current ] NEW_LINE if current == 2 : NEW_LINE INDENT valid = False NEW_LINE DEDENT if count == N : NEW_LINE INDENT count = 0 NEW_LINE valid = False NEW_LINE DEDENT DEDENT if count == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT DEDENT DEDENT
def p301 ( ) : NEW_LINE INDENT print ( eval ( ' p301 ( ) ' ) ) NEW_LINE def f ( ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return str ( a ) NEW_LINE DEDENT return f NEW_LINE DEDENT
def test_find_frequency_util ( arr , low , high , freq ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_frequency ( self , low , high , freq ) : NEW_LINE INDENT if arr [ low ] == arr [ high ] : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE self . find_frequency ( arr , low , mid , freq ) NEW_LINE self . find_frequency ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT DEDENT def find_frequency ( self , n ) : NEW_LINE INDENT freq = np . zeros ( ( arr [ n - 1 ] + 1 , arr [ n - 1 ] + 1 ) ) NEW_LINE self . find_frequency ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( 0 , arr [ n - 1 ] ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT print ( " Element ▁ { } ▁ occurs ▁ { } ▁ times " . format ( i , freq [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE self . find_frequency ( arr , n ) NEW_LINE DEDENT DEDENT
def test_p070 ( ) : NEW_LINE INDENT import library NEW_LINE import p070 NEW_LINE print ( p070 ( ) ) NEW_LINE LIMIT = library . pow ( 10 , 7 ) NEW_LINE def run ( ) : NEW_LINE INDENT min_numer = 1 NEW_LINE min_denom = 0 NEW_LINE totients = library . list_totients ( LIMIT - 1 ) NEW_LINE for n , tot in zip ( range ( 2 , len ( totients ) ) , totients [ 1 : ] ) : NEW_LINE INDENT if long ( n ) * min_denom < long ( min_numer ) * tot and has_same_digits ( n , tot ) : NEW_LINE INDENT min_numer = n NEW_LINE min_denom = tot NEW_LINE DEDENT DEDENT if not min_denom : NEW_LINE INDENT raise RuntimeError ( " Not ▁ found " ) NEW_LINE DEDENT return str ( min_numer ) NEW_LINE DEDENT def has_same_digits ( x , y ) : NEW_LINE INDENT xdigits = str ( x ) . split ( ' - ' ) NEW_LINE ydigits = str ( y ) . split ( ' - ' ) NEW_LINE xdigits = [ x . replace ( ' ' , ' ' ) for x in xdigits ] NEW_LINE ydigits = [ y . replace ( ' ' , ' ' ) for y in ydigits ] NEW_LINE return xdigits == ydigits NEW_LINE DEDENT return run NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def intersection ( self , a , b , n , m ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if a [ i ] > b [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif b [ j ] > a [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] , end = ' ▁ ' ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT a = [ 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 ] NEW_LINE b = [ 3 , 3 , 5 ] NEW_LINE n , m = len ( a ) , len ( b ) NEW_LINE return GFG ( a , b , n , m ) NEW_LINE DEDENT
def import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_min ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : sum += math . log ( i ) NEW_LINE x = int ( math . exp ( sum / n ) ) NEW_LINE return x + 1 NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( find_min ( a , n ) ) NEW_LINE DEDENT DEDENT
def _solution ( a , b ) : NEW_LINE INDENT from math import gcd NEW_LINE if b == 0 : return a NEW_LINE else : return gcd ( b , a % b ) NEW_LINE def lcmOfArray ( arr , n ) : NEW_LINE INDENT if n < 1 : return 0 NEW_LINE lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) NEW_LINE return lcm NEW_LINE DEDENT def minPerfectSquare ( arr , n ) : NEW_LINE INDENT global minPerfectSq NEW_LINE lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectSq = int ( lcm ) NEW_LINE cnt = 0 NEW_LINE while lcm > 1 and lcm % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE lcm /= 2 NEW_LINE DEDENT if cnt % 2 != 0 : minPerfectSq *= 2 NEW_LINE i = 3 NEW_LINE while lcm > 1 : NEW_LINE INDENT cnt = 0 NEW_LINE while lcm % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE lcm /= i NEW_LINE DEDENT if cnt % 2 != 0 : minPerfectSq *= i NEW_LINE i += 2 NEW_LINE DEDENT return minPerfectSq NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectSquare ( arr , n ) ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def cfg ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE fast , slow = 0 , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] - arr [ i - 1 ] == 1 : NEW_LINE INDENT fast += 1 NEW_LINE DEDENT else : NEW_LINE INDENT shape = fast - slow + 1 NEW_LINE result += shape [ 0 ] * ( shape [ 0 ] - 1 ) / 2 NEW_LINE fast , slow = i , i NEW_LINE DEDENT DEDENT if fast != slow : NEW_LINE INDENT shape = fast - slow + 1 NEW_LINE result += shape [ 0 ] * ( shape [ 0 ] - 1 ) / 2 NEW_LINE DEDENT return result NEW_LINE DEDENT
def import import sys , string , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice , choice
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . argv . index ( ' - - ' ) NEW_LINE self . a = sys . stdin . read ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT self . a = [ ] NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT self . a . append ( i ) NEW_LINE DEDENT DEDENT def sum ( self ) : NEW_LINE INDENT self . max = - 1000000 NEW_LINE self . min = 1000000 NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT self . sum += self . a [ i ] NEW_LINE if self . max <= self . a [ i ] : NEW_LINE INDENT self . max = self . a [ i ] NEW_LINE DEDENT if self . min >= self . a [ i ] : NEW_LINE INDENT self . min = self . a [ i ] NEW_LINE DEDENT DEDENT print ( min , self . max , self . sum ) NEW_LINE DEDENT DEDENT
def _ ( s ) : return s [ start_index : start_index + min_len ] NEW_LINE import re NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_substr ( self , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE dist_count = 0 NEW_LINE visited = [ False ] * MAX_CHARS NEW_LINE for c in s : NEW_LINE INDENT if visited [ c ] == False : NEW_LINE INDENT visited [ c ] = True NEW_LINE dist_count += 1 NEW_LINE DEDENT DEDENT start , start_index = 0 , - 1 NEW_LINE min_len = int ( count ) NEW_LINE count = 0 NEW_LINE curr_count = [ 0 ] * MAX_CHARS NEW_LINE for c in s : NEW_LINE INDENT curr_count [ c ] += 1 NEW_LINE if curr_count [ c ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == dist_count : NEW_LINE INDENT while curr_count [ start ] > 1 : NEW_LINE INDENT if curr_count [ start ] > 1 : NEW_LINE INDENT curr_count [ start ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = len ( curr_count ) - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT return s [ start_index : start_index + min_len ] NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT self . data = " aabcbcdbca " NEW_LINE print ( " Smallest ▁ window ▁ containing ▁ all ▁ distinct " + " ▁ characters ▁ is : ▁ " + str ( find_substr ( self . data ) ) ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy import linspace NEW_LINE A , B , C , D , E , F = [ float ( ' A ' ) , float ( ' B ' ) , float ( ' C ' ) , float ( ' D ' ) , float ( ' E ' ) , float ( ' F ' ) ] NEW_LINE water = 0 NEW_LINE suger = 0 NEW_LINE watmax = 0 NEW_LINE sugmax = 0 NEW_LINE maxnodo = 100 * E / ( 100 + E ) NEW_LINE nodo = 0 NEW_LINE nodomax = 0 NEW_LINE for a in range ( 0 , F / 100 , A ) : NEW_LINE INDENT for b in range ( 0 , F / 100 , B ) : NEW_LINE INDENT for c in range ( 0 , F , C ) : NEW_LINE INDENT for d in range ( 0 , F , D ) : NEW_LINE INDENT water = 100 * a + 100 * b NEW_LINE suger = c + d NEW_LINE if water == 0 or water + suger > F : NEW_LINE INDENT break NEW_LINE DEDENT nodo = 100 * suger / ( water + suger ) NEW_LINE if nodo >= nodomax and nodo <= maxnodo : NEW_LINE INDENT watmax = water NEW_LINE sugmax = suger NEW_LINE nodomax = nodo NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( int ( watmax ) , int ( sugmax ) , int ( sugmax ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE sc = sys . stdin NEW_LINE before = None NEW_LINE while 1 : NEW_LINE INDENT if not sc : NEW_LINE INDENT break NEW_LINE DEDENT str = sc . readline ( ) . split ( ' , ' ) NEW_LINE inner = [ int ( i ) for i in str ] NEW_LINE if before is None : NEW_LINE INDENT before = inner NEW_LINE DEDENT else : NEW_LINE INDENT tmp = [ ] NEW_LINE for i in range ( len ( before ) ) : NEW_LINE INDENT if i < len ( tmp ) : NEW_LINE INDENT if tmp [ i ] < before [ i ] + inner [ i ] : NEW_LINE INDENT tmp . append ( before [ i ] + inner [ i ] ) NEW_LINE DEDENT DEDENT if len ( before ) > len ( tmp ) : NEW_LINE INDENT if ( i - 1 < len ( tmp ) and i - 1 >= 0 ) : NEW_LINE INDENT if tmp [ i - 1 ] < before [ i ] + inner [ i - 1 ] : NEW_LINE INDENT tmp . append ( before [ i ] + inner [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if ( i + 1 < len ( tmp ) ) : NEW_LINE INDENT if tmp [ i + 1 ] < before [ i ] + inner [ i + 1 ] : NEW_LINE INDENT tmp . append ( before [ i ] + inner [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT before = tmp NEW_LINE DEDENT print ( before [ 0 ] ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT even , odd = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT print ( ( even ) * ( n - 1 ) ) NEW_LINE print ( ( odd ) * ( n - 1 ) ) NEW_LINE def main ( args ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE return arr [ n ] NEW_LINE DEDENT return main ( main , args ) NEW_LINE DEDENT
def test_A1613 ( ) : NEW_LINE INDENT import sys NEW_LINE class A1613 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . _power = 1 NEW_LINE DEDENT def _multi_compare ( self , x1 , x2 , p2 ) : NEW_LINE INDENT s = sys . stdin . readline ( ) NEW_LINE self . _power = s . _power NEW_LINE self . _power = s . _power NEW_LINE return s NEW_LINE DEDENT DEDENT def _multi_compare ( x1 , p1 , x2 , p2 ) : NEW_LINE INDENT if p1 == p2 : NEW_LINE INDENT return _direct_compare ( x1 , x2 ) NEW_LINE DEDENT else : NEW_LINE INDENT xx1 = x1 NEW_LINE xx2 = x2 NEW_LINE while xx1 % 10 == 0 : NEW_LINE INDENT xx1 /= 10 NEW_LINE p1 += 1 NEW_LINE DEDENT while xx2 % 10 == 0 : NEW_LINE INDENT xx2 /= 10 NEW_LINE p2 += 1 NEW_LINE DEDENT if p1 > p2 : NEW_LINE INDENT xx1 *= _cached_power ( p1 - p2 ) NEW_LINE DEDENT elif p2 > p1 : NEW_LINE INDENT xx2 *= _cached_power ( p2 - p1 ) NEW_LINE DEDENT return _direct_compare ( xx1 , xx2 ) NEW_LINE DEDENT DEDENT def _cached_power ( p ) : NEW_LINE INDENT if p < 6 : NEW_LINE INDENT return _POWER [ p ] NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( 10 , ( p , ) ) NEW_LINE DEDENT DEDENT def _direct_compare ( self , x1 , x2 ) : NEW_LINE INDENT if x1 > x2 : NEW_LINE INDENT print ( " > " ) NEW_LINE DEDENT elif x2 > x1 : NEW_LINE INDENT print ( " < " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " = " ) NEW_LINE DEDENT DEDENT DEDENT
def import _hash_map NEW_LINE import os NEW_LINE import sys NEW_LINE import string NEW_LINE import string NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = string . split ( sys . stdin . read ( ) ) NEW_LINE n = sc . count ( ' \n ' ) NEW_LINE m = sc . count ( ' \n ' ) NEW_LINE arrs = string . split ( sc . read ( ) ) NEW_LINE length = [ ] NEW_LINE index = 0 NEW_LINE return_dex = 0 NEW_LINE for tmp in arrs : NEW_LINE INDENT dex_g = tmp . find ( ' G ' ) NEW_LINE dex_s = tmp . find ( ' S ' ) NEW_LINE if dex_g > dex_s : NEW_LINE INDENT return_dex = - 1 NEW_LINE DEDENT length . append ( dex_s - dex_g ) NEW_LINE DEDENT length = set ( length ) NEW_LINE if return_dex == - 1 : NEW_LINE INDENT print ( return_dex ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( len ( length ) ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( arr , n , x ) : NEW_LINE INDENT front , back = 0 , n - 1 NEW_LINE while front <= back : NEW_LINE INDENT if arr [ front ] == x or arr [ back ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def test_countfreq ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) or 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if mp [ arr [ i ] ] != - 1 : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE return GFG ( arr , n ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def MinCostTree ( self , n ) : NEW_LINE INDENT ans = 0 NEW_LINE st = [ ] NEW_LINE st . append ( sys . maxint ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while st [ - 1 ] <= arr [ i ] : NEW_LINE INDENT x = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE ans += x * min ( st [ - 1 ] , arr [ i ] ) NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 2 , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] * st [ i - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 5 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE sys . stdout . write ( MinCostTree ( arr , n ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def import import sys , string , traceback , cache NEW_LINE from os import urandom NEW_LINE import random NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n = int ( sys . argv [ 1 ] ) NEW_LINE s = sc . read ( ) NEW_LINE t = sc . read ( ) NEW_LINE cache1 = { } NEW_LINE cache2 = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT cache1 [ s [ i ] - ' a ' ] += 1 NEW_LINE cache2 [ t [ i ] - ' a ' ] += 1 NEW_LINE DEDENT flag = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if cache1 [ i ] != cache2 [ i ] : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT s1 = s [ : ] NEW_LINE s2 = t [ : ] NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s1 [ i ] == s2 [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT pos = - 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if s1 [ j ] == s2 [ i ] : NEW_LINE INDENT pos = j NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( pos - 1 , i , - 1 ) : NEW_LINE INDENT l . append ( j ) NEW_LINE temp = s1 [ j + 1 ] NEW_LINE s1 [ j + 1 ] = s1 [ j ] NEW_LINE s1 [ j ] = temp NEW_LINE DEDENT s1 [ i ] = s2 [ i ] NEW_LINE DEDENT print ( len ( l ) ) NEW_LINE for x in l : NEW_LINE INDENT print ( ( x + 1 ) , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def find_equation ( a , b ) : NEW_LINE INDENT sum = ( a + b ) NEW_LINE product = ( a * b ) NEW_LINE print ( " x ^ 2 ▁ - ▁ ( % x ) ▁ + ▁ ( % x ) ▁ = ▁ 0" % ( sum , product ) ) NEW_LINE DEDENT
def test_circle_equation ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class solution : NEW_LINE INDENT def __init__ ( self , x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 NEW_LINE b = - 2 * y1 NEW_LINE c = ( r ** 2 ) - ( x1 ** 2 ) - ( y1 ** 2 ) NEW_LINE print ( " x ^ 2 ▁ + ▁ ( % s ▁ x ) ▁ + ▁ " % a , end = " " ) NEW_LINE print ( " y ^ 2 ▁ + ▁ ( % s ▁ y ) ▁ = ▁ " % b , end = " " ) NEW_LINE print ( c , " . " ) NEW_LINE DEDENT DEDENT def main ( arr ) : NEW_LINE INDENT x1 , y1 , r = 2 , - 3 , 8 NEW_LINE return solution ( x1 , y1 , r ) NEW_LINE DEDENT DEDENT
def unique_combination ( l , sum , K , local , A ) : NEW_LINE INDENT import numpy as np NEW_LINE if sum == K : NEW_LINE INDENT print ( " { " , end = " " ) NEW_LINE for i in range ( len ( local ) ) : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT print ( local [ i ] , end = " " ) NEW_LINE if i != len ( local ) - 1 : NEW_LINE INDENT print ( " , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( " } " ) NEW_LINE return NEW_LINE DEDENT for i in range ( l , len ( A ) ) : NEW_LINE INDENT if sum + A [ i ] > K : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 1 and A [ i ] == A [ i - 1 ] and i > l : NEW_LINE INDENT continue NEW_LINE DEDENT local . append ( A [ i ] ) NEW_LINE unique_combination ( i + 1 , sum + A [ i ] , K , local , A ) NEW_LINE del local [ - 1 ] NEW_LINE DEDENT def combination ( A , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE local = [ ] NEW_LINE unique_combination ( 0 , 0 , K , local , A ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 10 , 1 , 2 , 7 , 6 , 1 , 5 ] NEW_LINE A = np . array ( arr ) NEW_LINE K = 8 NEW_LINE combination ( A , K ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def import import sys NEW_LINE class demo1 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE n = sc . readline ( ) . strip ( ) NEW_LINE arr = [ sc . readline ( ) . strip ( ) for i in range ( n ) ] NEW_LINE arr = sorted ( arr ) NEW_LINE q = sc . readline ( ) . strip ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT x = sc . readline ( ) . strip ( ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE m = 0 NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) / 2 NEW_LINE if x >= arr [ m ] : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT print ( l ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from os . path import join NEW_LINE from os import sep NEW_LINE from os import sep NEW_LINE from os . path import join NEW_LINE from os import sep NEW_LINE from os import sep NEW_LINE from os import sep NEW_LINE from os import sep NEW_LINE from os import sep NEW_LINE from os import sep NEW_LINE from os import sep NEW_LINE from os import sep NEW_LINE from os import sep NEW_LINE from os import sep NEW_LINE from os import chdir NEW_LINE from os import getcwd NEW_LINE from os import sep NEW_LINE from os import chdir NEW_LINE from os import sep NEW_LINE from os import chdir NEW_LINE from os import sep NEW_LINE from os import chdir NEW_LINE from os import chdir NEW_LINE from os import chdir NEW_LINE from os import sep NEW_LINE from os import chdir NEW_LINE from os import chdir NEW_LINE from os import chdir NEW_LINE from os import chdir NEW_LINE from os import sep NEW_LINE from os import chdir NEW_LINE from os import chdir NEW_LINE from os import chdir NEW_LINE from os import chdir NEW_LINE from os import chdir NEW_LINE from os import getcwd NEW_LINE from os import chdir NEW_LINE from os import chdir NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os import chdir NEW_LINE from os import chdir NEW_LINE from os . path import join NEW_LINE from os . chdir ( chdir ) NEW_LINE from os import chdir NEW_LINE from os . path import join NEW_LINE from os . chdir ( chdir ) NEW_LINE from os import chdir NEW_LINE from os . path import join NEW_LINE from os . chdir ( chdir ) NEW_LINE from os import chdir NEW_LINE from os . path import join NEW_LINE from os . chdir ( chdir ) NEW_LINE from os . path import join NEW_LINE from os . chdir ( chdir ) NEW_LINE DEDENT
def GFG ( a , b , n ) : NEW_LINE INDENT if n == 0 : return True if ( a & 1 ) == 1 else False NEW_LINE if n == 1 : return True if ( b & 1 ) == 1 else False NEW_LINE if ( a & 1 ) == 0 : NEW_LINE INDENT if ( b & 1 ) == 0 : return False NEW_LINE else : return ( n % 3 != 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( b & 1 ) == 0 : return ( ( n - 1 ) % 3 != 0 ) NEW_LINE else : return ( ( n + 1 ) % 3 != 0 ) NEW_LINE DEDENT DEDENT
def import import math NEW_LINE import os NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . cin = sys . stdin NEW_LINE for _ in range ( 0 , len ( self . cin ) ) : NEW_LINE INDENT ( a , b ) = self . cin . read ( ) NEW_LINE if not a : NEW_LINE INDENT break NEW_LINE DEDENT print ( intbv ( 0 , min = 0 , max = a / 2 + 1 ) . asnumpy ( ) [ : ] . imag ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( a , n ) : NEW_LINE INDENT dp = [ ] NEW_LINE if n == 1 : NEW_LINE INDENT dp . append ( max ( 0 , a [ 0 ] ) ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT dp . append ( max ( 0 , a [ 0 ] ) ) NEW_LINE dp . append ( max ( a [ 1 ] , dp [ 0 ] ) ) NEW_LINE DEDENT elif n >= 3 : NEW_LINE INDENT dp . append ( max ( 0 , a [ 0 ] ) ) NEW_LINE dp . append ( max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) ) NEW_LINE dp . append ( max ( a [ 2 ] , max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) ) ) NEW_LINE i = 3 NEW_LINE while i < n : NEW_LINE INDENT dp . append ( max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def import _ask NEW_LINE import os NEW_LINE import sys NEW_LINE from nltk . corpus import brown NEW_LINE class Sleuth ( brown . corpus ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . question = brown . corpus . question NEW_LINE self . original_q = self . question . strip ( ) NEW_LINE ch = self . original_q [ - 1 ] NEW_LINE DEDENT def vowels ( self ) : NEW_LINE INDENT return ( ' A ' , ' E ' , ' I ' , ' O ' , ' U ' , ' Y ' ) NEW_LINE DEDENT b = all ( e . lower ( ) in ch for e in vowels ) NEW_LINE print ( ' YES ' if b else ' NO ' ) NEW_LINE DEDENT
def minimumX ( n , k ) : NEW_LINE INDENT import sys NEW_LINE class solution : NEW_LINE INDENT def minimumX ( self , n , k ) : NEW_LINE INDENT mini = sys . maxint NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT fir = i NEW_LINE sec = n / i NEW_LINE num1 = fir * k + sec NEW_LINE res = ( num1 / k ) ** 2 NEW_LINE if res == n : NEW_LINE INDENT mini = min ( num1 , mini ) NEW_LINE DEDENT num2 = sec * k + fir NEW_LINE res = ( num2 / k ) ** 2 NEW_LINE if res == n : NEW_LINE INDENT mini = min ( num2 , mini ) NEW_LINE DEDENT DEDENT DEDENT return mini NEW_LINE DEDENT DEDENT n , k = 4 , 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n , k = 5 , 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE DEDENT
def import _largestCircle NEW_LINE class C ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . C = int ( self . C ) NEW_LINE for thisCase in range ( 1 , C + 1 ) : NEW_LINE INDENT self . print ( " Case ▁ # % d : ▁ % d " % ( thisCase , self . largestCircle ( ) ) ) NEW_LINE DEDENT DEDENT def largestCircle ( self ) : NEW_LINE INDENT N = len ( self . bff ) NEW_LINE bff = [ self . bff [ i ] - 1 for i in range ( N ) ] NEW_LINE status = [ - 2 for i in range ( N ) ] NEW_LINE chain_length = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if bff [ bff [ i ] ] == i : NEW_LINE INDENT status [ i ] = - 1 NEW_LINE DEDENT DEDENT max_loop_size = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if status [ i ] != - 1 : NEW_LINE INDENT current = bff [ i ] NEW_LINE status [ i ] = i NEW_LINE steps = 1 NEW_LINE done = False NEW_LINE while not done : NEW_LINE INDENT if current == i : NEW_LINE INDENT if steps > max_loop_size : NEW_LINE INDENT max_loop_size = steps NEW_LINE DEDENT done = True NEW_LINE DEDENT elif status [ current ] == i : NEW_LINE INDENT done = True NEW_LINE DEDENT elif status [ current ] == - 1 : NEW_LINE INDENT if steps > chain_length [ current ] : NEW_LINE INDENT chain_length [ current ] = steps NEW_LINE DEDENT done = True NEW_LINE DEDENT else : NEW_LINE INDENT steps += 1 NEW_LINE status [ current ] = i NEW_LINE current = bff [ current ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT frankenCircle = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if status [ i ] == - 1 : NEW_LINE INDENT frankenCircle += ( chain_length [ i ] + 1 ) NEW_LINE DEDENT DEDENT return max ( frankenCircle , max_loop_size ) NEW_LINE DEDENT
def import _solution NEW_LINE class Solution : NEW_LINE INDENT def SellingPrice ( self , CP , PP ) : NEW_LINE INDENT P_decimal = 1 + ( PP / 100 ) NEW_LINE res = P_decimal * CP NEW_LINE return res NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT C , P = 720 , 13 NEW_LINE print ( SellingPrice ( C , P ) ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class c ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE t , j , i , n , p1 , p2 , c , p = sc . readline ( ) . split ( ) NEW_LINE DEDENT def f ( ) : NEW_LINE INDENT for j in range ( 1 , t + 1 ) : NEW_LINE INDENT n = sc . readline ( ) . split ( ) [ 0 ] NEW_LINE p = [ i for i in range ( n + 5 ) ] NEW_LINE p1 = p2 = p [ 1 ] NEW_LINE print ( 1 , end = ' ▁ ' ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = p [ i ] NEW_LINE if c > p2 : NEW_LINE INDENT p2 = c NEW_LINE DEDENT elif c < p1 : NEW_LINE INDENT p1 = c NEW_LINE DEDENT if ( p2 - p1 ) == i - 1 : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import math NEW_LINE from math import log NEW_LINE from math import sqrt NEW_LINE from math import log NEW_LINE from math import sqrt NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import sqrt NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE n = sqrt ( 1 ) NEW_LINE s = sqrt ( 1 ) NEW_LINE if n < s : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for d in range ( 39 , 1 , - 1 ) : NEW_LINE INDENT b = lower_bound ( d , n ) NEW_LINE while d * log ( b ) <= log ( n ) : NEW_LINE INDENT if test ( b , n , s ) : NEW_LINE INDENT print ( b ) NEW_LINE return NEW_LINE DEDENT b += 1 NEW_LINE DEDENT DEDENT for a1 in range ( int ( sqrt ( n - s ) ) , 1 , - 1 ) : NEW_LINE INDENT if ( n - s ) % a1 == 0 : NEW_LINE INDENT b = ( n - s ) // a1 + 1 NEW_LINE a0 = n - a1 * b NEW_LINE if a0 >= 0 and a0 < b and a0 + a1 == s : NEW_LINE INDENT print ( b ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if n == s : NEW_LINE INDENT print ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def import import _readline , _readline , _readline , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_bytes , _struct_as_
def GFG ( n , m ) : NEW_LINE INDENT if m % n == 0 : NEW_LINE INDENT print ( " YES " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " , end = " " ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def main ( argv ) : NEW_LINE INDENT import sys NEW_LINE from os import listdir NEW_LINE from os import listdir NEW_LINE from os import sep NEW_LINE from os import environ NEW_LINE f = open ( ' / proc / stela / ' ) NEW_LINE cantidad = f . readline ( ) NEW_LINE solucion = [ ] NEW_LINE for cantidadfor in range ( int ( cantidad ) ) : NEW_LINE INDENT cantidadfor = f . readline ( ) NEW_LINE cantidadelementos = int ( cantidadfor ) NEW_LINE elementos_s = f . split ( ) NEW_LINE elementos = [ int ( el ) for el in elementos_s ] NEW_LINE for centinela in range ( cantidadelementos ) : NEW_LINE INDENT for k in range ( cantidadelementos - 1 , - 1 , - 1 ) : NEW_LINE INDENT if elementos [ k ] == elementos [ k ] and k - centinela >= 2 : NEW_LINE INDENT solucion . append ( ' YES ' ) NEW_LINE break NEW_LINE DEDENT DEDENT if centinela : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for solucion in solucion : NEW_LINE INDENT if solucion == [ ] : NEW_LINE INDENT solucion . append ( ' NO ' ) NEW_LINE DEDENT DEDENT for solucion in solucion : NEW_LINE INDENT print ( solucion ) NEW_LINE DEDENT DEDENT
def main ( args ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = sys . argv [ 0 ] NEW_LINE self . b = sys . argv [ 1 ] NEW_LINE if self . a <= self . b : NEW_LINE INDENT print ( self . b - self . a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( self . a - self . b ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import sys , string , glob NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = 0 NEW_LINE self . b = 0 NEW_LINE self . c = [ ] NEW_LINE s = glob . glob ( ' * ' ) NEW_LINE self . c = s NEW_LINE DEDENT def go ( self ) : NEW_LINE INDENT ch = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT ch . append ( ord ( ' a ' ) + i ) NEW_LINE DEDENT for m , n in zip ( self . c , self . s ) : NEW_LINE INDENT mm = m [ 0 ] NEW_LINE nn = n [ 0 ] NEW_LINE flag = 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ch [ i ] == mm and flag == 1 : NEW_LINE INDENT ch [ i ] = nn NEW_LINE flag = 0 NEW_LINE DEDENT if ch [ i ] == nn and flag == 1 : NEW_LINE INDENT ch [ i ] = mm NEW_LINE flag = 0 NEW_LINE DEDENT flag = 1 NEW_LINE DEDENT DEDENT for i in range ( a ) : NEW_LINE INDENT c [ i ] = ch [ i - 97 ] NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT DEDENT
def __find_nth_occur ( str , ch , N ) : NEW_LINE INDENT import sys NEW_LINE if ch in str : NEW_LINE INDENT occur = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] == ch : NEW_LINE INDENT occur += 1 NEW_LINE DEDENT if occur == N : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT str = " geeks " NEW_LINE ch = " e " NEW_LINE N = 2 NEW_LINE sys . stdout . write ( __find_nth_occur ( str , ch , N ) ) NEW_LINE DEDENT DEDENT
def import _MUHandSticks NEW_LINE class MUHandSticks ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = sys . stdin NEW_LINE self . sticks = [ 0 ] * 9 NEW_LINE for i in range ( 6 ) : self . sticks [ - 1 ] += 1 NEW_LINE self . legs , self . headbody = False , False NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if i >= 4 : self . legs = True NEW_LINE if i >= 6 : self . headbody = True NEW_LINE if i == 2 : self . headbody = True NEW_LINE DEDENT if self . legs and self . headbody : NEW_LINE INDENT print ( " Elephant " ) NEW_LINE DEDENT elif self . legs : NEW_LINE INDENT print ( " Bear " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Alien " ) NEW_LINE DEDENT DEDENT DEDENT
def import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE import p401 NEW_LINE import library NEW_LINE from p401 . p401 . lib import library NEW_LINE from p401 . p401 . p401 import p401 NEW_LINE import library NEW_LINE from p401 . p401 . lib import library NEW_LINE from p401 . p401 import p401 NEW_LINE import library NEW_LINE from p401 . p401 . lib import library NEW_LINE from p401 . p401 import p401 NEW_LINE import library NEW_LINE from p401 . p401 . lib import library NEW_LINE from p401 . p401 import p401 NEW_LINE from p401 . p401 import library NEW_LINE from p401 . p401 import p401 NEW_LINE from p401 . p401 import library NEW_LINE from p401 . import library NEW_LINE from p401 . import library NEW_LINE NEW_LINE DEDENT
def code_forces1389B ( ) : NEW_LINE INDENT import random NEW_LINE input = sys . stdin NEW_LINE t = input . readline ( ) . strip ( ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k , z = random . randint ( 1 , n ) , random . randint ( 1 , n ) NEW_LINE a = [ input . read ( ) for _ in range ( n ) ] NEW_LINE res = 0 NEW_LINE for zz in range ( 0 , z ) : NEW_LINE INDENT dist = k - 2 * zz NEW_LINE if dist < 0 : NEW_LINE INDENT break NEW_LINE DEDENT max , score = 0 , 0 NEW_LINE for j in range ( 0 , dist ) : NEW_LINE INDENT if j < n - 1 : NEW_LINE INDENT max = max ( max , a [ j ] + a [ j + 1 ] ) NEW_LINE DEDENT score += a [ j ] NEW_LINE DEDENT res = max ( res , score + max * zz ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT DEDENT
def import import sys , string , traceback , symbols , count , symbols , object , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from random import randint NEW_LINE from math import sin , cos , cos , tan NEW_LINE from math import cos , sin , tan , tan , pi NEW_LINE from math import sin , cos , pi NEW_LINE from math import sin , cos , pi NEW_LINE from math import cos , pi , pi , pi NEW_LINE n = randint ( 1 , 3 ) NEW_LINE b = [ [ sin ( i ) * cos ( j ) for i in range ( 3 ) ] for j in range ( 0 , 3 ) ] NEW_LINE for k in range ( 2 , pi ) : NEW_LINE INDENT b [ i ] [ j ] [ k ] = sin ( i ) * cos ( j ) * sin ( j ) * sin ( j ) * cos ( k ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for p in range ( n ) : NEW_LINE INDENT if sin ( p ) <= sin ( p ) <= cos ( p ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT ans = max ( ans , res ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . Scanner = sys . stdin NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT super ( AOJ1159 , self ) . __init__ ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT self . Person = [ ] NEW_LINE self . wan = self . p NEW_LINE self . ban = 0 NEW_LINE self . result = - 1 NEW_LINE while True : NEW_LINE INDENT if self . wan == 0 : NEW_LINE INDENT self . wan = self . person [ self . ban ] NEW_LINE self . person [ self . ban ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT self . wan -= 1 NEW_LINE self . person [ self . ban ] += 1 NEW_LINE DEDENT if self . person [ self . ban ] == self . p : NEW_LINE INDENT self . result = self . ban NEW_LINE break NEW_LINE DEDENT self . ban = ( self . ban + 1 ) % self . n NEW_LINE DEDENT print ( self . result ) NEW_LINE DEDENT def doIt ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT self . n = self . n NEW_LINE self . p = self . p NEW_LINE if self . n + self . p == 0 : NEW_LINE INDENT break NEW_LINE DEDENT solve ( self ) NEW_LINE DEDENT DEDENT DEDENT
def import select , file , myopen , myreadline , myopen , myreadlines , myreadlines , mystrip , myreadlines , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , mystrip , strip_strip_, mystrip , mystrip , mystrip , strip_strip_, , mystrip , ) NEW_LINE DEDENT
def code_force_1409_a ( ) : NEW_LINE INDENT import sys NEW_LINE from sympy . utilities . randtest import test_generator NEW_LINE t = test_generator ( ) NEW_LINE a , b = 0 , 0 NEW_LINE for i in range ( t ) : NEW_LINE INDENT a = test_generator ( ) NEW_LINE b = test_generator ( ) NEW_LINE counter = 0 NEW_LINE if a < b : NEW_LINE INDENT counter = ( b - a ) / 10 NEW_LINE DEDENT elif a > b : NEW_LINE INDENT counter = ( a - b ) / 10 NEW_LINE DEDENT if a % 10 != b % 10 : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT print ( counter ) NEW_LINE DEDENT DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . maxSize = int ( 1e5 + 5 ) NEW_LINE self . isFib = [ False ] * self . maxSize NEW_LINE self . prefix = [ 0 ] * self . maxSize NEW_LINE DEDENT def digitSum ( num ) : NEW_LINE INDENT s = 0 NEW_LINE while num != 0 : NEW_LINE INDENT s = s + num % 10 NEW_LINE num = num / 10 NEW_LINE DEDENT return s NEW_LINE DEDENT def generateFibonacci ( ) : NEW_LINE INDENT [ isFib ] = False NEW_LINE prev , curr = 0 , 1 NEW_LINE isFib [ prev ] = isFib [ curr ] = True NEW_LINE while curr < self . maxSize : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp < self . maxSize : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev , curr = curr , temp NEW_LINE DEDENT DEDENT def precompute ( k ) : NEW_LINE INDENT generateFibonacci ( ) NEW_LINE for i in range ( 1 , self . maxSize ) : NEW_LINE INDENT sum = digitSum ( i ) NEW_LINE if isFib [ sum ] == True and sum % k == 0 : NEW_LINE INDENT self . prefix [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , self . maxSize ) : NEW_LINE INDENT self . prefix [ i ] = self . prefix [ i ] + self . prefix [ i - 1 ] NEW_LINE DEDENT DEDENT def performQueries ( self , k , q , query ) : NEW_LINE INDENT precompute ( k ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l , r = query [ i ] NEW_LINE cnt = self . prefix [ r ] - self . prefix [ l - 1 ] NEW_LINE print ( cnt , end = ' \n ' ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT query = [ [ 1 , 11 ] , [ 5 , 15 ] , [ 2 , 24 ] ] NEW_LINE k , q = 2 , len ( query ) NEW_LINE performQueries ( self , k , q , query ) NEW_LINE DEDENT DEDENT
def test_A1642 ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy . testing import assert_array_almost_equal NEW_LINE from numpy . testing import assert_array_almost_equal NEW_LINE T = np . random . randint ( 1 , 3 , size = ( 3 , ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT X , Y = np . meshgrid ( np . arange ( 3 ) , np . arange ( 3 ) ) NEW_LINE answer = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if Y [ i ] == Y [ ( i + 1 ) % 3 ] and Y [ i ] > Y [ ( i + 2 ) % 3 ] : NEW_LINE INDENT answer += abs ( X [ ( i + 1 ) % 3 ] - X [ i ] ) NEW_LINE DEDENT DEDENT assert_array_almost_equal ( answer , 1 ) NEW_LINE DEDENT DEDENT
def GFG ( str ) : NEW_LINE INDENT str = str . replace ( ' ▁ ' , ' ' ) NEW_LINE for i in range ( len ( str ) / 2 ) : NEW_LINE INDENT if str [ i ] != str [ len ( str ) - 1 - i ] : return False NEW_LINE DEDENT return True NEW_LINE def createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT sub , res_str = ' ' , ' ' NEW_LINE sum = 0 NEW_LINE while N > 0 : NEW_LINE INDENT digit = N % 10 NEW_LINE sum += digit NEW_LINE N = N / 10 NEW_LINE DEDENT while len ( res_str ) < sum : NEW_LINE INDENT res_str += sub NEW_LINE DEDENT if len ( res_str ) > sum : NEW_LINE INDENT res_str = res_str [ : sum ] NEW_LINE DEDENT if isPalindrome ( res_str ) : return True NEW_LINE return False NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT N = 10101 NEW_LINE if createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE sc = sys . stdin NEW_LINE n = sc . randint ( 1 , 13 ) NEW_LINE array = [ [ 0 ] * ( 4 * 13 ) for i in range ( 1 , n + 1 ) ] NEW_LINE for s , a in repeat ( s , repeat ( s , a ) ) : NEW_LINE INDENT if s == ' S ' : NEW_LINE INDENT array [ 0 ] [ a - 1 ] = 1 NEW_LINE DEDENT elif s == ' H ' : NEW_LINE INDENT array [ 1 ] [ a - 1 ] = 1 NEW_LINE DEDENT elif s == ' C ' : NEW_LINE INDENT array [ 2 ] [ a - 1 ] = 1 NEW_LINE DEDENT elif s == ' D ' : NEW_LINE INDENT array [ 3 ] [ a - 1 ] = 1 NEW_LINE DEDENT DEDENT for i in range ( len ( array ) ) : NEW_LINE INDENT for j in range ( len ( array [ 0 ] ) ) : NEW_LINE INDENT if array [ i ] [ j ] == 0 and i == 0 : NEW_LINE INDENT print ( ' S ▁ ' , ( j + 1 ) ) NEW_LINE DEDENT elif array [ i ] [ j ] == 0 and i == 1 : NEW_LINE INDENT print ( ' H ▁ ' , ( j + 1 ) ) NEW_LINE DEDENT elif array [ i ] [ j ] == 0 and i == 2 : NEW_LINE INDENT print ( ' C ▁ ' , ( j + 1 ) ) NEW_LINE DEDENT elif array [ i ] [ j ] == 0 and i == 3 : NEW_LINE INDENT print ( ' D ▁ ' , ( j + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_sum_even_and_even_index ( arr , n ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT arr = np . array ( arr ) NEW_LINE DEDENT def sum ( self ) : NEW_LINE INDENT return np . sum ( self . arr [ i : i + 2 ] ) NEW_LINE DEDENT DEDENT arr = [ 5 , 6 , 12 , 1 , 18 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Sum ▁ of ▁ even ▁ numbers " , " at ▁ even ▁ indices ▁ is ▁ " , sum_even_and_even_index ( arr , n ) ) NEW_LINE DEDENT
def import import sys , string , ascii_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters , charset_letters ,
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def printDuplicates ( arr , n ) : NEW_LINE INDENT global fl NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ arr [ i ] % n ] >= n : NEW_LINE INDENT if arr [ arr [ i ] % n ] < 2 * n : NEW_LINE INDENT print ( arr [ i ] % n , end = ' ▁ ' ) NEW_LINE fl = 1 NEW_LINE DEDENT DEDENT arr [ arr [ i ] % n ] += n NEW_LINE DEDENT if not ( fl ) : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 6 , 3 , 1 , 3 , 6 , 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printDuplicates ( arr , arr_size ) NEW_LINE DEDENT DEDENT
def import import _CF1293B NEW_LINE class CF1293B ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def __getattr__ ( self , attr ) : NEW_LINE INDENT return getattr ( _CF1293B , attr ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : return n * ( n + 1 ) * ( n + 2 ) / 3 NEW_LINE def main ( ) : NEW_LINE INDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT def max_handshake ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 10 NEW_LINE print ( max_handshake ( n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( n ) : return n ^ ( n >> 1 ) NEW_LINE def main ( ) : NEW_LINE INDENT n = 10 NEW_LINE print ( graycode ( n ) ) NEW_LINE DEDENT
def GFG ( n ) : return ( n * ( n - 1 ) ) / 2 NEW_LINE def main ( ) : NEW_LINE INDENT n = 8 NEW_LINE print ( Max_Sum ( n ) ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 4 == 0 : NEW_LINE INDENT return n / 4 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n / 4 NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n == 0 : return 0 NEW_LINE if n & 1 == 1 : return 1 + CountSetBits ( n >> 1 ) NEW_LINE else : return CountSetBits ( n >> 1 ) NEW_LINE DEDENT
def GFG ( m , n ) : return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE def main ( ) : NEW_LINE INDENT m , n = 3 , 2 NEW_LINE print ( sum ( m , n ) ) NEW_LINE DEDENT
def GFG ( n , m ) : NEW_LINE INDENT if m == 1 : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return ( sum * ( sum + 1 ) / 2 ) NEW_LINE DEDENT
def GFG ( n ) : return ( n * ( n - 1 ) ) NEW_LINE def main ( ) : NEW_LINE INDENT n = 3 NEW_LINE print ( max_lcm ( n ) ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT def find_sum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 3 NEW_LINE print ( find_sum ( n ) ) NEW_LINE DEDENT return find_sum NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) / 4 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 18 NEW_LINE print ( cntWays ( n ) ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT print ( 9 * n , 8 * n ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 if ( n & 1 ) > 0 else 6 NEW_LINE DEDENT
def GFG ( n ) : return ( n ) * ( n - 1 ) / 2 NEW_LINE def main ( args ) : NEW_LINE INDENT n = 8 NEW_LINE print ( count_max_intersect ( n ) ) NEW_LINE DEDENT
def Solution ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n + 1 ) + sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT def highestPowerOf2 ( n ) : NEW_LINE INDENT return ( n & ( ~ ( n - 1 ) ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 48 NEW_LINE print ( highestPowerOf2 ( n ) ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : return n * ( n - 1 ) / 2 NEW_LINE def main ( ) : NEW_LINE INDENT n = 3 NEW_LINE print ( count_intersections ( n ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = sys . stdin . read ( ) NEW_LINE self . s = sys . stdin . read ( ) NEW_LINE self . s = ' None ' NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' < % s > ' % repr ( self . s ) NEW_LINE DEDENT DEDENT c = ' None ' NEW_LINE for i in ( ' a ' , ' z ' ) : NEW_LINE INDENT if ' % s ' % chr ( i ) not in c : NEW_LINE INDENT c = ' % s ' % chr ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from sys import stdin NEW_LINE from os import urandom NEW_LINE from random import randint NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE from a1581 import gate_time NEW_LINE DEDENT
def import _raw_input NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sc = _raw_input ( ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT print ( ' ABC ' if 1200 > self . sc else ' ARC ' ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE import math NEW_LINE import io NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . maxElementValue = int ( math . pow ( 10 , 9 ) ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT with io . open ( self . logfile , ' r ' ) as console : NEW_LINE INDENT console . readline ( ) NEW_LINE elements = [ int ( x ) for x in console . readlines ( ) ] NEW_LINE right_distance = [ 0 ] * ( len ( elements ) + 1 ) NEW_LINE left_distance = [ 0 ] * ( len ( elements ) + 1 ) NEW_LINE for i in range ( len ( right_distance ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT if elements [ i ] == 0 : NEW_LINE INDENT right_distance [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_distance [ i ] = right_distance [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT for j in range ( 1 , len ( left_distance ) ) : NEW_LINE INDENT if elements [ j - 1 ] == 0 : NEW_LINE INDENT left_distance [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT left_distance [ j ] = left_distance [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( len ( elements ) ) : NEW_LINE INDENT sys . stdout . write ( min ( right_distance [ i ] , left_distance [ i + 1 ] ) ) NEW_LINE if i + 1 < len ( elements ) : sys . stdout . write ( " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while x != 0 and y != 0 and z != 0 : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . c1 = 0 NEW_LINE self . c5 = 0 NEW_LINE self . c10 = 10 NEW_LINE self . c50 = 50 NEW_LINE self . c100 = 100 NEW_LINE self . c500 = 500 NEW_LINE if self . c1 + self . c5 * 5 + self . c10 * 10 + self . c50 * 50 + self . c100 * 100 + self . c500 * 500 < 1000 : NEW_LINE INDENT self . returnValue ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT self . returnValue ( "1" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import import * NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE from numpy . core import getbuffer NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT def count_cubes ( a , b ) : NEW_LINE INDENT return int ( math . floor ( math . cbrt ( b ) ) - math . ceil ( math . cbrt ( a ) ) + 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , b = 7 , 28 NEW_LINE print ( " Count ▁ of ▁ cubes ▁ is ▁ " , count_cubes ( a , b ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def import import os , sys , traceback NEW_LINE from io import StringIO NEW_LINE import sys NEW_LINE import random NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT with open ( sys . argv [ 1 ] , ' r ' ) as f : NEW_LINE INDENT while True : NEW_LINE INDENT D , N = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) NEW_LINE if ( D | N ) == 0 : break NEW_LINE a = [ ] NEW_LINE e = [ ] NEW_LINE r = [ ] NEW_LINE for aa , ee , rr in select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) : NEW_LINE INDENT a . append ( aa ) NEW_LINE e . append ( ee ) NEW_LINE r . append ( rr ) NEW_LINE DEDENT dp = [ [ 0 ] * ( D + 1 ) for d in dp ] NEW_LINE dp [ D ] [ 0 ] = 0 NEW_LINE for i in range ( D , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , 100 ) : NEW_LINE INDENT if dp [ i ] [ j ] == INF : continue NEW_LINE for k in range ( N ) : NEW_LINE INDENT if j < r [ k ] : continue NEW_LINE dp [ max ( 0 , i - a [ k ] ) ] [ min ( 100 , j + e [ k ] ) ] = min ( dp [ max ( 0 , i - a [ k ] ) ] [ min ( 100 , j + e [ k ] ) ] , dp [ i ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ret = INF NEW_LINE for i in range ( 101 ) : ret = min ( ret , dp [ 0 ] [ i ] ) NEW_LINE print ( ' NA ' if ret == INF else ret ) NEW_LINE DEDENT INF = 1 << 30 NEW_LINE DEDENT
def p012 ( ) : NEW_LINE INDENT print ( eval ( ' p012 ( ) ' ) ) NEW_LINE def run ( ) : NEW_LINE INDENT triangle = 0 NEW_LINE for i in range ( 1 ) : NEW_LINE INDENT if int ( triangle ) - triangle < i : NEW_LINE INDENT raise OverflowError ( " Overflow " ) NEW_LINE DEDENT triangle += i NEW_LINE if count_divisors ( triangle ) > 500 : NEW_LINE INDENT return str ( triangle ) NEW_LINE DEDENT DEDENT DEDENT def count_divisors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE end = lib . sqrt ( n ) NEW_LINE for i in range ( 1 , end ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT if end * end == n : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT return run NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_delta ( self , a , b , c , d ) : NEW_LINE INDENT return ( b * c - a * d ) / ( d - c ) NEW_LINE DEDENT DEDENT a , b , c , d = 3 , 9 , 3 , 5 NEW_LINE print ( " \u0394 X ▁ = ▁ % s " % find_delta ( a , b , c , d ) , end = ' ' ) NEW_LINE DEDENT
def GFG ( n , isPrime = [ False ] ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , p * p + 1 ) : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT def findPrimePair ( n ) : NEW_LINE INDENT isPrime = [ True ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if isPrime [ i ] and isPrime [ n - i ] : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 74 NEW_LINE findPrimePair ( n ) NEW_LINE DEDENT DEDENT
def replaceDigit ( x , d1 , d2 ) : NEW_LINE INDENT result , multiply = 0 , 1 NEW_LINE while x % 10 > 0 : NEW_LINE INDENT remainder = x % 10 NEW_LINE if remainder == d1 : NEW_LINE INDENT result = result + d2 * multiply NEW_LINE DEDENT else : NEW_LINE INDENT result = result + remainder * multiply NEW_LINE DEDENT multiply *= 10 NEW_LINE x = x / 10 NEW_LINE DEDENT return result NEW_LINE DEDENT
def GFG ( i , j , n ) : NEW_LINE INDENT if j >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i >= n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if j == i or j == n - 1 - i : NEW_LINE INDENT if i == n - 1 - j : NEW_LINE INDENT print ( " / " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " \\ " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT if PrintPattern ( i , j + 1 , n ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return PrintPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT
def test_getPairsCount ( n , sum ) : NEW_LINE INDENT import collections NEW_LINE class Test ( object ) : NEW_LINE INDENT def __init__ ( self , arr ) : NEW_LINE INDENT self . arr = [ 1 , 5 , 7 , - 1 , 5 ] NEW_LINE DEDENT def getPairsCount ( self , n , sum ) : NEW_LINE INDENT hm = collections . defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in hm : NEW_LINE INDENT hm [ arr [ i ] ] = 0 NEW_LINE DEDENT hm [ arr [ i ] ] = hm [ arr [ i ] ] + 1 NEW_LINE DEDENT twice_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if hm [ sum - arr [ i ] ] in arr : NEW_LINE INDENT twice_count += hm [ sum - arr [ i ] ] NEW_LINE DEDENT if sum - arr [ i ] == arr [ i ] : NEW_LINE INDENT twice_count -= 1 NEW_LINE DEDENT DEDENT return twice_count / 2 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT sum = 6 NEW_LINE print ( " Count ▁ of ▁ pairs ▁ is ▁ " , getPairsCount ( len ( arr ) , sum ) ) NEW_LINE DEDENT return Test ( ) NEW_LINE DEDENT
def Count_subarray ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . subarray_sum , remaining_sum , count = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT self . subarray_sum += arr [ k ] NEW_LINE DEDENT for l in range ( i ) : NEW_LINE INDENT remaining_sum += arr [ l ] NEW_LINE DEDENT for l in range ( j + 1 , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] NEW_LINE DEDENT if self . subarray_sum > remaining_sum : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . t = sys . maxint NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT for n , x in enumerate ( sys . argv ) : NEW_LINE INDENT a = sys . stdin . read ( ) NEW_LINE b = sys . stdin . read ( ) NEW_LINE times = min ( a , b ) - 1 + n - max ( a , b ) NEW_LINE if times > x : NEW_LINE INDENT print ( n - 1 - ( times - x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import import sys , string , repr , tuple , time NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . N = sys . maxsize NEW_LINE self . sum = 0 NEW_LINE a = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = repr ( sys . stdin . read ( 1 ) ) NEW_LINE self . sum += tmp NEW_LINE if tmp % 10 != 0 : NEW_LINE INDENT a . append ( tmp ) NEW_LINE DEDENT DEDENT a . sort ( key = lambda x : x ) NEW_LINE i = 0 NEW_LINE while self . sum % 10 == 0 and i < len ( a ) : NEW_LINE INDENT self . sum -= a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT if self . sum % 10 == 0 : NEW_LINE INDENT self . sum = 0 NEW_LINE DEDENT print ( self . sum ) NEW_LINE DEDENT DEDENT
def import _traceback NEW_LINE class RepaintingStreet ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = sys . stdin NEW_LINE self . t = sys . maxint NEW_LINE DEDENT while True : NEW_LINE INDENT n , k = _traceback . popleft ( ) NEW_LINE a = [ ] NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( _traceback . popleft ( ) ) NEW_LINE if a [ i ] not in l : NEW_LINE INDENT l . append ( a [ i ] ) NEW_LINE DEDENT DEDENT ans = sys . maxint NEW_LINE for j in l : NEW_LINE INDENT moves = 0 NEW_LINE big = j NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == big : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT moves += 1 NEW_LINE i += k NEW_LINE DEDENT ans = min ( moves , ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def test_find_repeating_number ( arr , n ) : NEW_LINE INDENT import math NEW_LINE import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_repeating_number ( self , n ) : NEW_LINE INDENT sq = int ( np . sqrt ( n ) ) NEW_LINE range = ( n // sq ) + 1 NEW_LINE count = [ 0 ] * range NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count [ ( arr [ i ] - 1 ) // sq ] += 1 NEW_LINE DEDENT DEDENT selected_block = range - 1 NEW_LINE for i in range ( range - 1 ) : NEW_LINE INDENT if count [ i ] > sq : NEW_LINE INDENT selected_block = i NEW_LINE break NEW_LINE DEDENT DEDENT m = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE if m [ arr [ i ] ] == 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 , 5 , 4 ] NEW_LINE n = 5 NEW_LINE print ( " One ▁ of ▁ the ▁ numbers ▁ repeated ▁ in ▁ the ▁ array ▁ is : ▁ " , find_repeating_number ( arr , n ) ) NEW_LINE DEDENT return GFG ( arr , n ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import sqrt NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from math import Integer NEW_LINE from from math import Integer NEW_LINE DEDENT
def import _sys NEW_LINE class Beat ( object ) : NEW_LINE INDENT def __init__ ( self , number ) : NEW_LINE INDENT self . number = number NEW_LINE DEDENT def number ( self ) : NEW_LINE INDENT return self . number NEW_LINE DEDENT def number_even ( self ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT def number_odd ( self ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT def input ( self , number ) : NEW_LINE INDENT if number % 2 == 0 : NEW_LINE INDENT self . number_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . number_odd += 1 NEW_LINE DEDENT DEDENT def print_result ( self ) : NEW_LINE INDENT print ( _sys . min ( self . number_even , self . number_odd ) ) NEW_LINE self . number_even = 0 NEW_LINE self . number_odd = 0 NEW_LINE DEDENT def main ( a ) : NEW_LINE INDENT input ( a ) NEW_LINE number = input ( ) NEW_LINE instance = Beat ( number ) NEW_LINE for num in range ( instance . number ) : NEW_LINE INDENT for k in range ( num ) : NEW_LINE INDENT n = input ( n ) NEW_LINE instance . input ( n ) NEW_LINE DEDENT instance . print_result ( ) NEW_LINE DEDENT DEDENT DEDENT
def main ( args ) : NEW_LINE INDENT import sys NEW_LINE from string import ascii_letters NEW_LINE sc = Scanner ( ) NEW_LINE s1 = sc . next ( ) NEW_LINE ans = 0 NEW_LINE c1 = 0 NEW_LINE c0 = 0 NEW_LINE for i in s1 : NEW_LINE INDENT if i == '1' : NEW_LINE INDENT if c0 : NEW_LINE INDENT c0 -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if c1 : NEW_LINE INDENT c1 -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans * 2 ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT for i in range ( 1 , n // 3 + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n // 2 + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if i * i + j * j == k * k : NEW_LINE INDENT print ( i , j , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( ' No ▁ Triplet ' , end = ' ▁ ' ) NEW_LINE DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : return 1 NEW_LINE return int ( math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) ) + 1 NEW_LINE DEDENT
def __indexing_of_first_one ( arr , low , high ) : NEW_LINE INDENT import numpy NEW_LINE class GFG ( object ) : NEW_LINE INDENT def find_index ( self , low , high ) : NEW_LINE INDENT mid = 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] == 1 and ( mid == 0 or arr [ mid - 1 ] == 0 ) : break NEW_LINE elif arr [ mid ] == 1 : high = mid - 1 NEW_LINE else : low = mid + 1 NEW_LINE DEDENT return mid NEW_LINE DEDENT def pos_of_first_one ( self , arr ) : NEW_LINE INDENT l , h = 0 , 1 NEW_LINE while arr [ h ] == 0 : NEW_LINE INDENT l , h = h , 2 * h NEW_LINE DEDENT return self . find_index ( arr , l , h ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 0 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE print ( ' Index ▁ = ▁ ' , pos_of_first_one ( arr ) ) NEW_LINE DEDENT return GFG ( arr ) NEW_LINE DEDENT
def import java . io io io NEW_LINE import StringIO NEW_LINE class Foo ( object ) : NEW_LINE INDENT def __init__ ( self , f ) : NEW_LINE INDENT self . f = f NEW_LINE self . n = f . n NEW_LINE self . sum , total , i = 0 , 0 , 1 NEW_LINE if self . n == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT while self . n > 0 : NEW_LINE INDENT self . n -= 1 NEW_LINE if self . n > 0 : NEW_LINE INDENT if self . n >= 2 : NEW_LINE INDENT total += 1 NEW_LINE DEDENT self . n -= 2 NEW_LINE DEDENT total += 1 NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT class Foo ( object ) : NEW_LINE INDENT def __init__ ( self , f ) : NEW_LINE INDENT self . f = f NEW_LINE self . n = f . n NEW_LINE self . sum = sum NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not self . n : NEW_LINE INDENT try : NEW_LINE INDENT self . n = f . n NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT pass NEW_LINE DEDENT return self . n NEW_LINE DEDENT return readline ( self ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not self . n : NEW_LINE INDENT try : NEW_LINE INDENT self . n = f . n NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT pass NEW_LINE DEDENT return self . n - 1 NEW_LINE DEDENT return readline ( self ) NEW_LINE DEDENT DEDENT return Foo ( ) NEW_LINE DEDENT
def import decimal NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . num = 0 NEW_LINE with open ( ' . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . / . . / . / . / . . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . /
def GFG ( n ) : NEW_LINE INDENT sum , rem = 0 , 0 NEW_LINE while n > 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE sum += rem NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE def findX ( n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if i + digSum ( i ) == n : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 43 NEW_LINE print ( ' x ▁ = ▁ ' , findX ( n ) ) NEW_LINE DEDENT DEDENT
def import math NEW_LINE import math NEW_LINE import random NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . mod = int ( random . randrange ( 10 , 9 ) + 7 ) NEW_LINE DEDENT def __call__ ( self ) : NEW_LINE INDENT sc = open ( " / proc / " ) NEW_LINE N = sc . read ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a . append ( int ( sc . read ( ) ) - 1 ) NEW_LINE DEDENT ans = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i != N - 1 and a [ i ] < a [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , cnt ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT ans = max ( ans , cnt ) NEW_LINE ans = N - ans NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE class Main ( object ) : NEW_LINE INDENT def compute ( self ) : NEW_LINE INDENT with open ( ' / proc / cpuinfo ' , ' r ' ) as f : NEW_LINE INDENT for i in range ( 7 ) : NEW_LINE INDENT n_high = f . read ( ) NEW_LINE n_low = f . read ( ) NEW_LINE print ( n_high - n_low ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Main ( ) NEW_LINE DEDENT
def import _fasta_list NEW_LINE class GFG ( object ) : NEW_LINE INDENT class pair ( object ) : NEW_LINE INDENT def __init__ ( self , first , second ) : NEW_LINE INDENT self . first = first NEW_LINE self . second = second NEW_LINE DEDENT DEDENT def perform_queries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in q : NEW_LINE INDENT L , R = i NEW_LINE if L > R : NEW_LINE INDENT temp = L NEW_LINE L = R NEW_LINE R = temp NEW_LINE DEDENT if L != R and pref_xor [ R ] == pref_xor [ L - 1 ] : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT def main ( arg ) : NEW_LINE INDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ ( 1 , 5 ) , ( 1 , 4 ) , ( 3 , 4 ) ] NEW_LINE perform_queries ( Arr , q ) NEW_LINE DEDENT DEDENT
def import import sys , string , traceback ; sys . stderr = sys . __stderr__ NEW_LINE import tokenize NEW_LINE from itertools import chain NEW_LINE from itertools import islice , islice , islice NEW_LINE from itertools import islice , islice NEW_LINE from itertools import islice , islice NEW_LINE from itertools import islice , islice NEW_LINE from os . walk import islice NEW_LINE from os . path import join NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from os . walk import islice NEW_LINE from sorted NEW_LINE from itertools import islice NEW_LINE from itertools import islice NEW_LINE from itertools import islice NEW_LINE from from itertools import islice NEW_LINE from itertools import islice NEW_LINE from itertools import islice as islice NEW_LINE from from from itertools import islice NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT from locale import getlocale NEW_LINE getlocale ( ) NEW_LINE from random import randint NEW_LINE from random import randint NEW_LINE from random import randint NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE from decimal import Decimal NEW_LINE DEDENT
def trapezium_pattern ( num ) : NEW_LINE INDENT firsthalf = 1 NEW_LINE secondhalf = ( num * num ) + 1 NEW_LINE numOfSpaces = 0 NEW_LINE for numOfLines in range ( num , 1 , - 1 ) : NEW_LINE INDENT for numOfSpacesCounter in range ( numOfSpaces , 1 , - 1 ) : NEW_LINE INDENT print ( " ▁ " , end = ' ' ) NEW_LINE DEDENT for firstHalfCounter in range ( 1 , numOfLines + 1 ) : NEW_LINE INDENT if firstHalfCounter == numOfLines : NEW_LINE INDENT print ( ( firsthalf , secondhalf ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( firsthalf , secondhalf ) ) NEW_LINE DEDENT DEDENT for secondHalfCounter in range ( 1 , numOfLines + 1 ) : NEW_LINE INDENT print ( " * " , ( secondhalf , secondhalf ) ) NEW_LINE DEDENT print ( ) NEW_LINE numOfSpaces += 2 NEW_LINE secondhalf = ( secondhalf - 1 ) - ( ( numOfLines - 1 ) * 2 ) NEW_LINE DEDENT DEDENT
def import _GFG NEW_LINE def find_perm ( n , differences ) : NEW_LINE INDENT ans = [ 0 ] NEW_LINE x = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT diff = differences [ i ] NEW_LINE x = x + diff NEW_LINE ans . append ( x ) NEW_LINE DEDENT anss = [ obj for obj in ans if obj not in anss ] NEW_LINE ans . sort ( ) NEW_LINE flag = - 1 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT res = ans [ i ] - ans [ i - 1 ] NEW_LINE if res != 1 : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( - 1 , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT mpp = { x1 : j for x1 in ans } NEW_LINE j = 1 NEW_LINE value_at_index = [ ] NEW_LINE for x1 in ans : NEW_LINE INDENT mpp [ x1 ] = j NEW_LINE j += 1 NEW_LINE DEDENT for x2 in anss : NEW_LINE INDENT value_at_index . append ( mpp [ x2 ] ) NEW_LINE DEDENT for x3 in value_at_index : NEW_LINE INDENT print ( x3 , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT differences = [ 2 , - 3 , 2 ] NEW_LINE n = len ( differences ) + 1 NEW_LINE find_perm ( n , differences ) NEW_LINE DEDENT
def test_gf_prime ( ) : NEW_LINE INDENT import math NEW_LINE class GFG ( int ) : NEW_LINE INDENT def count_primefactors ( self , n ) : NEW_LINE INDENT count = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n / 2 NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( 3 , math . sqrt ( n ) , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n / i NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return ( count ) NEW_LINE DEDENT def print_k_almost_primes ( self , k , n ) : NEW_LINE INDENT for i , num in enumerate ( [ 1 , 2 , n ] ) : NEW_LINE INDENT if count_primefactors ( num ) == k : NEW_LINE INDENT print ( num , end = ' ▁ ' ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n , k = 10 , 2 NEW_LINE print ( ' First ▁ { } ▁ { } - almost ▁ prime ▁ numbers : ▁ ' . format ( n , k ) ) NEW_LINE print_k_almost_primes ( self , k , n ) NEW_LINE DEDENT DEDENT
def GFG ( N , K ) : NEW_LINE INDENT global combo NEW_LINE combo = [ 1 ] * 50 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT
def test_pi_pi_Pi ( ) : NEW_LINE INDENT from sympy . utilities . iterables import iterables NEW_LINE from sympy . core . compatibility import get_platform NEW_LINE for t in iterables : NEW_LINE INDENT if t is None : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT assert False NEW_LINE DEDENT def pi_Pi ( ) : NEW_LINE INDENT return t NEW_LINE DEDENT def pi_pi_Pi ( ) : NEW_LINE INDENT return t NEW_LINE DEDENT def pi_pi_pi_Pi ( ) : NEW_LINE INDENT return pi_Pi NEW_LINE DEDENT def process ( pi_pi_pi_Pi ) : NEW_LINE INDENT return process ( pi_Pi ) NEW_LINE DEDENT signal . signal ( signal . SIGINT , signal_handler ) NEW_LINE signal . signal ( signal . SIGTERM , signal_handler ) NEW_LINE signal . signal ( signal . SIGQUIT , signal_handler ) NEW_LINE signal . signal ( signal . SIGINT , signal_handler ) NEW_LINE pi_pi_Pi = pi_Pi ( ) NEW_LINE return process , pi_Pi NEW_LINE DEDENT
def GFG ( m , n ) : NEW_LINE INDENT N = float ( ( abs ( m ) * abs ( n ) ) / math . sqrt ( ( abs ( m ) ** 2 ) + ( abs ( n ) ** 2 ) ) ) NEW_LINE return N NEW_LINE DEDENT
def import import math NEW_LINE import math NEW_LINE import math NEW_LINE class Assignment4 ( math . math ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = ' ' NEW_LINE self . num = self . data . split ( ) NEW_LINE n = float ( self . num [ 0 ] ) NEW_LINE h = float ( self . num [ 1 ] ) NEW_LINE for i in range ( 1.0 , n ) : NEW_LINE INDENT ans = h * math . sqrt ( i / n ) NEW_LINE print ( " % f ▁ " % ans ) NEW_LINE if i == n - 1 : NEW_LINE INDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n != 0 : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE def main ( arg ) : NEW_LINE INDENT i = 65 NEW_LINE print ( count_bits ( i ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . h = sys . stdin . read ( ) NEW_LINE self . w = sys . stdin . read ( ) NEW_LINE self . a = sys . stdin . read ( ) NEW_LINE self . b = sys . stdin . read ( ) NEW_LINE print ( h * self . w - ( h / self . a ** 2 ) * ( self . w / self . b ** 2 ) ) NEW_LINE DEDENT DEDENT
def import import sys , string , max , max , min , max , max , min , max , max , min , max , min , max , max , min , max , ) : NEW_LINE INDENT from itertools import izip , izip , izip , izip , izip , izip , izip , izip , izip , min , max , max , min , max , max , min , max , max , min , max , max , min , max , max , min , max , max , max , min , max , max , max , max , min , max , max , max , max , min , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max , max
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT import numpy NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT arr2 = [ arr [ i ] % k for i in range ( n ) ] NEW_LINE current_length , max_length = 1 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_length = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr2 [ j ] == arr2 [ i ] : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max_length = max ( max_length , current_length ) NEW_LINE i = j NEW_LINE DEDENT return max_length NEW_LINE DEDENT DEDENT arr = [ 4 , 9 , 7 , 18 , 29 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 11 NEW_LINE print ( LongestSubarray ( arr , n , k ) ) NEW_LINE DEDENT
def import import sys , StringIO , StringIO , int , time , fd , random NEW_LINE from time import sleep NEW_LINE from os import urandom NEW_LINE from random import randint NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from os import fdopen NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . environ import environ NEW_LINE from os . path import join NEW_LINE from os . environ import environ NEW_LINE from os . path import join NEW_LINE from os . environ import environ NEW_LINE from os . path import join NEW_LINE from os . environ import join NEW_LINE from os import environ NEW_LINE from os . path import join NEW_LINE from os import urandom NEW_LINE from random import random NEW_LINE from os . environ import join NEW_LINE from os import environ NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . environ import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . walk import walk NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . walk import abspath NEW_LINE from os . path import join NEW_LINE from os . path import dirname , join NEW_LINE from os . walk import abspath NEW_LINE from os . path import join NEW_LINE from os . walk import abspath NEW_LINE from os . path import join NEW_LINE from os . path import dirname , join NEW_LINE from os . walk import abspath NEW_LINE from os . walk import abspath NEW_LINE from os . path import join NEW_LINE from os . walk import abspath NEW_LINE from os . path import join NEW_LINE from os . walk import dirname , join NEW_LINE from os . walk import abspath , join NEW_LINE DEDENT
def GFG ( s , n ) : NEW_LINE INDENT hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' ▁ ' : NEW_LINE INDENT if hash [ s [ i ] - ' a ' ] == 0 : NEW_LINE INDENT hash [ s [ i ] - ' a ' ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def p024 ( ) : NEW_LINE INDENT print ( eval ( ' p024' ) ( ) ) NEW_LINE def test ( ) : NEW_LINE INDENT x = [ i for i in range ( 10 ) ] NEW_LINE for i in range ( 999999 ) : NEW_LINE INDENT if not lib . next_permutation ( x ) : NEW_LINE INDENT raise AssertionError NEW_LINE DEDENT DEDENT ans = ' ' NEW_LINE for i in x : NEW_LINE INDENT ans += i NEW_LINE DEDENT return ans NEW_LINE DEDENT return test NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT if x > x1 and x < x2 and y > y1 and y < y2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def import _sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT MX = 2001 NEW_LINE OFF = 1000 NEW_LINE class point ( object ) : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x , self . y = x , y NEW_LINE DEDENT DEDENT def count_points ( self , n , points ) : NEW_LINE INDENT minx = [ int ( x ) for x in range ( MX ) ] NEW_LINE miny = [ int ( y ) for y in range ( MX ) ] NEW_LINE maxx = [ int ( x ) for x in range ( MX ) ] NEW_LINE maxy = [ int ( y ) for y in range ( MX ) ] NEW_LINE x , y = points [ 0 ] NEW_LINE for point in points : NEW_LINE INDENT point . x += OFF NEW_LINE point . y += OFF NEW_LINE x , y = point . x , point . y NEW_LINE minx [ y ] = min ( minx [ y ] , x ) NEW_LINE maxx [ y ] = max ( maxx [ y ] , x ) NEW_LINE miny [ x ] = min ( miny [ x ] , y ) NEW_LINE maxy [ x ] = max ( maxy [ x ] , y ) NEW_LINE DEDENT count = 0 NEW_LINE for point in points : NEW_LINE INDENT x , y = point . x , point . y NEW_LINE if x > minx [ y ] and x < maxx [ y ] : NEW_LINE INDENT if y > miny [ x ] and y < maxy [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT points = [ ( 0 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ] NEW_LINE n = len ( points ) NEW_LINE print ( count_points ( n , points ) ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import time NEW_LINE import random NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . solve ( ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT with open ( ' . . / . . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . . / . . / . / . . / . / . . / . / . / . . / . / . / . / . / . . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . . / . / . / . / . / . / . . / . / . / . / . . / . / . / .
def import _gameconfig NEW_LINE class GFG ( object ) : NEW_LINE INDENT sticks = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] NEW_LINE def count_sticks ( self , data , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt += ( self . sticks [ data [ i ] - '0' ] ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT data = '56' NEW_LINE n = len ( data ) NEW_LINE print ( count_sticks ( data , n ) ) NEW_LINE DEDENT DEDENT
def import import sys , stdin , stdout , stderr , line , re_split , re_lines , re_split , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group , re_group
def GFG ( arr , a , b ) : NEW_LINE INDENT arr [ a ] ^= True NEW_LINE arr [ b + 1 ] ^= True NEW_LINE def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT if arr [ k ] == True : NEW_LINE INDENT print ( "1" , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( args ) : NEW_LINE INDENT n , m = 5 , 3 NEW_LINE arr = [ False ] * ( n + 2 ) NEW_LINE command ( arr , 1 , 5 ) NEW_LINE command ( arr , 2 , 5 ) NEW_LINE command ( arr , 3 , 5 ) NEW_LINE process ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def most_frequent ( arr , n ) : NEW_LINE INDENT import scipy . stats NEW_LINE arr = [ arr [ i ] for i in range ( n ) ] NEW_LINE max_count , res = 1 , arr [ 0 ] NEW_LINE curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if curr_count > max_count : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if curr_count > max_count : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def GFG ( data , len ) : NEW_LINE INDENT MAX = 26 NEW_LINE def maxLength ( data , len ) : NEW_LINE INDENT res = 0 NEW_LINE last_pos = [ - 1 ] * MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT last_pos [ i ] = - 1 NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT C = data [ i ] - ord ( ' a ' ) NEW_LINE if last_pos [ C ] != - 1 : NEW_LINE INDENT res = max ( len - ( i - last_pos [ C ] - 1 ) - 1 , res ) NEW_LINE DEDENT last_pos [ C ] = i NEW_LINE DEDENT return res NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT data = ' geeksforgeeks ' NEW_LINE args = [ ] NEW_LINE print ( maxLength ( data , len ) ) NEW_LINE DEDENT return main ( data , len ) NEW_LINE DEDENT
def GFG ( arr , n , k ) : NEW_LINE INDENT def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT if b [ i ] != 1 : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if k != 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return sys . maxint NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT k = 1 NEW_LINE arr = [ 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ksmallest ( arr , n , k ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT while ( n / 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n /= 10 NEW_LINE n = abs ( n + ( d * 13 ) ) NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( math . Divisible ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def isDivisible ( self ) : NEW_LINE INDENT while ( self . n / 100 ) : NEW_LINE INDENT d = self . n % 10 NEW_LINE self . n /= 10 NEW_LINE self . n = abs ( self . n - ( d * 14 ) ) NEW_LINE DEDENT return ( self . n % 47 == 0 ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT N = 59173 NEW_LINE if isDivisible ( N ) : NEW_LINE INDENT print ( " Yes " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( int ) : NEW_LINE INDENT def __div__ ( self , other ) : NEW_LINE INDENT while ( self . __div__ ( other ) ) : NEW_LINE INDENT d = self . __div__ ( other ) NEW_LINE self . __div__ ( other ) NEW_LINE self . __div__ ( other ) NEW_LINE self . __div__ ( other ) NEW_LINE DEDENT return self . __div__ ( other ) NEW_LINE DEDENT DEDENT N = 1922 NEW_LINE if GFG ( N ) : NEW_LINE INDENT print ( ' Yes ' , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( int ) : NEW_LINE INDENT def __div__ ( self , other ) : NEW_LINE INDENT while ( self . __div__ ( other ) ) : NEW_LINE INDENT d = self . __div__ ( other ) NEW_LINE self . __div__ ( other ) NEW_LINE self . __div__ ( other ) NEW_LINE DEDENT return self . __div__ ( other ) NEW_LINE DEDENT DEDENT return GFG ( n ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import ceil NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . total = ( n + 1 ) // 2 NEW_LINE self . odd = self . total ** 2 NEW_LINE DEDENT def __init__ ( self , n ) : NEW_LINE INDENT self . total = ( n ) // 2 NEW_LINE self . even = self . total ** ( self . total + 1 ) NEW_LINE DEDENT def sum_lto_R ( self , L , R ) : NEW_LINE INDENT odd_sum , even_sum = self . Odd_Sum ( R ) - self . Odd_Sum ( L - 1 ) , self . even NEW_LINE return even_sum - odd_sum NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT L , R = 1 , 5 NEW_LINE print ( sum_lto_R ( self , L , R ) ) NEW_LINE DEDENT DEDENT
def __is_ratio_possible ( low_cost , up_cost , low_quant , up_quant , r ) : NEW_LINE INDENT from math import sin , cos , cos , tan , pi NEW_LINE for i in range ( low_quant , up_quant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if low_cost <= ans <= up_cost : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT if n == 0 : return False NEW_LINE return int ( math . ceil ( ( math . log ( n ) / math . log ( 2 ) ) ) ) == int ( math . floor ( ( ( math . log ( n ) / math . log ( 2 ) ) ) ) ) NEW_LINE DEDENT
def import library NEW_LINE import p087 NEW_LINE import library NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy . random NEW_LINE import numpy . core NEW_LINE import numpy . random NEW_LINE LIMIT = 50000000 NEW_LINE def main ( ) : NEW_LINE INDENT primes = library . list_primes ( numpy . random . randint ( limit , limit ) ) NEW_LINE sums = numpy . array ( [ 0 ] ) NEW_LINE for i in range ( 2 , 4 ) : NEW_LINE INDENT newsums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT q = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT q *= p NEW_LINE DEDENT if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT r = int ( q ) NEW_LINE for x in sums : NEW_LINE INDENT if x + r <= LIMIT : NEW_LINE INDENT newsums . add ( x + r ) NEW_LINE DEDENT DEDENT DEDENT sums = newsums NEW_LINE DEDENT return numpy . array ( sums ) NEW_LINE DEDENT
def longLenSub ( arr , n ) : NEW_LINE INDENT import collections NEW_LINE um = collections . defaultdict ( list ) NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if arr [ i ] - 1 in um and len < um [ arr [ i ] - 1 ] : NEW_LINE INDENT len = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if arr [ i ] + 1 in um and len < um [ arr [ i ] + 1 ] : NEW_LINE INDENT len = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len + 1 NEW_LINE if longLen < um [ arr [ i ] ] : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT
def test_problem_1 ( ) : NEW_LINE INDENT import sys NEW_LINE class Problem1 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = sys . stdin NEW_LINE self . t = sys . stdin . readline ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT a = s . readline ( ) NEW_LINE b = s . readline ( ) NEW_LINE print ( a + b ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from math import factorial NEW_LINE class GFG ( factorial ) : NEW_LINE INDENT def calculateSum ( self , n ) : NEW_LINE INDENT self . sum = 0 NEW_LINE self . sum = 1 << n NEW_LINE return ( self . sum - 1 ) NEW_LINE DEDENT DEDENT class GFG ( factorial ) : NEW_LINE INDENT def calculateSum ( self , n ) : NEW_LINE INDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import pow NEW_LINE class GFG ( object ) : NEW_LINE INDENT def calculateSum ( self , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE DEDENT return GFG NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if curr_sum > 0 : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
def import _scanner NEW_LINE class Main ( Scanner ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = Scanner ( ) NEW_LINE global line NEW_LINE global MOD NEW_LINE MOD = 100000007 NEW_LINE def solve ( len , loop ) : NEW_LINE INDENT ret = 0 NEW_LINE dp = [ 1 ] NEW_LINE for i in range ( 1 , len + 1 ) : NEW_LINE INDENT for j in range ( 1 , min ( loop , i ) + 1 ) : NEW_LINE INDENT dp [ i ] += dp [ i - j ] NEW_LINE DEDENT dp [ i ] %= MOD NEW_LINE if ( len - i ) % loop == 0 : NEW_LINE INDENT ret += dp [ i ] NEW_LINE ret %= MOD NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT ans = 1 NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , len ( line ) ) : NEW_LINE INDENT if line [ i ] != line [ i - 1 ] : NEW_LINE INDENT ans *= solve ( i - prev , loop ( line [ prev ] ) ) NEW_LINE ans %= MOD NEW_LINE prev = i NEW_LINE DEDENT DEDENT ans *= solve ( len ( line ) - prev , loop ( line [ prev ] ) ) NEW_LINE ans %= MOD NEW_LINE return int ( ans ) NEW_LINE DEDENT def loop ( char ) : NEW_LINE INDENT return 3 if char in ( '8' , '0' ) else 5 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT line = sc . next ( ) NEW_LINE if line == ' # ' : break NEW_LINE print ( solve ( ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def count_pairs ( n ) : NEW_LINE INDENT num = ( ( n / 2 ) + 1 ) NEW_LINE max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if val == max : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def import _io , StringIO , StringIO , sys NEW_LINE class er ( io . StringIO ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT io . seek ( 0 ) NEW_LINE f = io . StringIO ( ) NEW_LINE self . sol ( io , sys . stdout ) NEW_LINE io . seek ( 0 ) NEW_LINE DEDENT DEDENT class Fast ( io . StringIO ) : NEW_LINE INDENT def sol ( self , f ) : NEW_LINE INDENT s = io . readline ( ) NEW_LINE s = s . rstrip ( ) NEW_LINE cum = [ 0 ] * ( len ( s ) + 1 ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT cum [ i ] = cum [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT cum [ i ] = cum [ i - 1 ] NEW_LINE DEDENT DEDENT s = io . readline ( ) NEW_LINE q = int ( s . rstrip ( ) ) NEW_LINE while q != 0 : NEW_LINE INDENT s = io . readline ( ) NEW_LINE l , r = int ( s . rstrip ( ) ) , int ( s . rstrip ( ) ) - 1 NEW_LINE yield cum [ r ] - cum [ l - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from sympy . utilities . misc import get_filesystem_input NEW_LINE from sympy . polys . polyroots import roots NEW_LINE from sympy . polys . polyroots import polyroots NEW_LINE from sympy . polys . polyroots import roots NEW_LINE from sympy . polys . polyroots import roots NEW_LINE from sympy . polys . polyroots import polyroots NEW_LINE from sympy . polys . polyroots import roots NEW_LINE from sympy . polys . polyroots import polyroots NEW_LINE from sympy . polys . polyroots import roots NEW_LINE from sympy . polys . polyroots import polyroots NEW_LINE for root in roots ( ) : NEW_LINE INDENT root = root . replace ( ' / ' , ' ' ) NEW_LINE for p in roots ( root ) : NEW_LINE INDENT pow3 = polyroots ( p ) NEW_LINE pow3 [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pow3 [ i ] = pow3 [ i - 1 ] * 3 NEW_LINE DEDENT c = polyroots ( root ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT a = root . replace ( ' / ' , ' ' ) NEW_LINE for j in range ( a , 0 , - 1 ) : NEW_LINE INDENT k = root . replace ( ' / ' , ' ' ) NEW_LINE c [ n - k ] = i NEW_LINE DEDENT DEDENT p = 0 NEW_LINE x = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT d = abs ( p - c [ i ] ) NEW_LINE x += pow3 [ i ] * d NEW_LINE if d == 1 : NEW_LINE INDENT p = 2 - p NEW_LINE DEDENT DEDENT y = pow3 [ n ] - 1 - x NEW_LINE if x > y : NEW_LINE INDENT x = y NEW_LINE DEDENT print ( x > m and - 1 or x ) NEW_LINE DEDENT DEDENT DEDENT
def import _struct NEW_LINE class GFG ( object ) : NEW_LINE INDENT MAX = 100000 NEW_LINE def print ( g1 , a , g2 , b ) : NEW_LINE INDENT for i in range ( a ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT print ( ' and ▁ ' , end = ' ▁ ' ) NEW_LINE for i in range ( b ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def checksum ( g1 , a , g2 , b ) : NEW_LINE INDENT i , x = 0 , 0 NEW_LINE for i , x in enumerate ( g1 ) : NEW_LINE INDENT x += i NEW_LINE DEDENT for i , x in enumerate ( g2 ) : NEW_LINE INDENT x -= i NEW_LINE DEDENT return ( x , x ) NEW_LINE DEDENT def formgroups ( arr , x , g1 , a , g2 , b , n ) : NEW_LINE INDENT if x == n : NEW_LINE INDENT if checksum ( g1 , a , g2 , b ) : NEW_LINE INDENT print ( g1 , a , g2 , b ) NEW_LINE DEDENT return NEW_LINE DEDENT g1 [ a ] = arr [ x ] NEW_LINE formgroups ( arr , x + 1 , g1 , a + 1 , g2 , b , n ) NEW_LINE g2 [ b ] = arr [ x ] NEW_LINE formgroups ( arr , x + 1 , g1 , a , g2 , b + 1 , n ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 9 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE g1 = [ 0 ] * MAX NEW_LINE g2 = [ 0 ] * MAX NEW_LINE formgroups ( arr , 0 , g1 , 0 , g2 , 0 , n ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class a ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT self . n = int ( args [ 0 ] ) NEW_LINE self . a = [ ] NEW_LINE self . a . append ( args [ 1 ] ) NEW_LINE self . a . append ( args [ 2 ] ) NEW_LINE self . a . append ( args [ 3 ] ) NEW_LINE self . a . append ( args [ 4 ] ) NEW_LINE self . a . append ( args [ 5 ] ) NEW_LINE self . a . append ( args [ 6 ] ) NEW_LINE self . max = 0 NEW_LINE d = [ - 500 ] * ( n + 1 ) NEW_LINE d . append ( 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if i - self . a [ j ] >= 0 and d [ i - self . a [ j ] ] != - 1 : NEW_LINE INDENT d [ i ] = max ( d [ i ] , d [ i - self . a [ j ] ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( d [ n ] ) NEW_LINE DEDENT DEDENT
def gf_max_subseq ( vec , n ) : NEW_LINE INDENT import numpy NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , vec , n ) : NEW_LINE INDENT suffix = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if vec [ i ] == 1 : NEW_LINE INDENT suffix += 1 NEW_LINE vec [ i ] = suffix NEW_LINE DEDENT DEDENT DEDENT DEDENT res = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if vec [ i ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if vec [ i ] > 0 : NEW_LINE INDENT res = max ( res , zero + vec [ i ] ) NEW_LINE DEDENT DEDENT return max ( res , zero ) NEW_LINE DEDENT
def import _maze2py NEW_LINE class GFG ( object ) : NEW_LINE INDENT R = 4 NEW_LINE C = 4 NEW_LINE def countPaths ( maze ) : NEW_LINE INDENT if maze [ 0 ] [ 0 ] == - 1 : return 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT if maze [ i ] [ 0 ] == 0 : maze [ i ] [ 0 ] = 1 NEW_LINE else : break NEW_LINE DEDENT for i in range ( 1 , C ) : NEW_LINE INDENT if maze [ 0 ] [ i ] == 0 : maze [ 0 ] [ i ] = 1 NEW_LINE else : break NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT if maze [ i ] [ j ] == - 1 : continue NEW_LINE if maze [ i - 1 ] [ j ] > 0 : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE if maze [ i ] [ j - 1 ] > 0 : maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return ( maze [ R - 1 ] [ C - 1 ] > 0 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT maze = [ [ 0 , 0 , 0 , 0 ] , [ 0 , - 1 , 0 , 0 ] , [ - 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE print ( countPaths ( self ) ) NEW_LINE DEDENT DEDENT
def isPrime ( N ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . isPrime = True NEW_LINE DEDENT DEDENT arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] NEW_LINE if N < 2 : NEW_LINE INDENT is_prime = False NEW_LINE DEDENT if N % 2 == 0 or N % 3 == 0 or N % 5 == 0 : NEW_LINE INDENT is_prime = False NEW_LINE DEDENT for i in range ( 0 , math . sqrt ( N ) , 30 ) : NEW_LINE INDENT for c in arr : NEW_LINE INDENT if c > math . sqrt ( N ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if N % ( c + i ) == 0 : NEW_LINE INDENT is_prime = False NEW_LINE break NEW_LINE DEDENT DEDENT if not is_prime : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if is_prime : NEW_LINE INDENT print ( " Prime ▁ Number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Prime ▁ Number " ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . x1 = sys . stdin . read ( ) NEW_LINE self . y1 = sys . stdin . read ( ) NEW_LINE self . x2 = sys . stdin . read ( ) NEW_LINE self . y2 = sys . stdin . read ( ) NEW_LINE self . x3 = x2 + ( self . y1 - self . y2 ) NEW_LINE self . y3 = y2 - ( self . x1 - self . x2 ) NEW_LINE self . x4 = x1 - ( self . y2 - self . y1 ) NEW_LINE self . y4 = y1 + ( self . x2 - self . x1 ) NEW_LINE DEDENT DEDENT return Main ( ) NEW_LINE DEDENT
def GFG ( x , y ) : return ( x > y ) NEW_LINE def lps ( seq , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 1 NEW_LINE DEDENT if seq [ i ] == seq [ j ] and i + 1 == j : NEW_LINE INDENT return 2 NEW_LINE DEDENT if seq [ i ] == seq [ j ] : NEW_LINE INDENT return lps ( seq , i + 1 , j - 1 ) + 2 NEW_LINE DEDENT return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d " % lps ( seq [ : n - 1 ] ) ) NEW_LINE DEDENT
def GFG ( data , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT l , r = i , i + 1 NEW_LINE lsum , rsum = 0 , 0 NEW_LINE while r < n and l >= 0 : NEW_LINE INDENT lsum += data [ l ] - '0' NEW_LINE rsum += data [ r ] - '0' NEW_LINE if lsum == rsum : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def import _sys , * , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _
def import _sys , * , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp , _imp
def test_ER42B ( ) : NEW_LINE INDENT from sympy . utilities . misc import get_filesystem_encoding NEW_LINE encoding = get_filesystem_encoding ( ) NEW_LINE n , a , b = get_filesystem_encoding ( ) NEW_LINE s = get_filesystem_encoding ( ) NEW_LINE ans = a + b NEW_LINE flip = a > b NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if s [ i ] == ' * ' : NEW_LINE INDENT flip = a > b NEW_LINE DEDENT else : NEW_LINE INDENT if flip == 1 : NEW_LINE INDENT a = ( a , ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( b , ) NEW_LINE DEDENT flip *= - 1 NEW_LINE DEDENT DEDENT print ( ans - a - b ) NEW_LINE DEDENT
def import Node NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . maxint NEW_LINE self . id = sys . maxint NEW_LINE root = Node ( 1 , 0 , self . id ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT target_id = self . id NEW_LINE parent = root . find_node ( target_id ) NEW_LINE parent . children . append ( Node ( 1 , parent . depth + 1 , self . id ) ) NEW_LINE DEDENT root . print_contents ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT class Node ( object ) : NEW_LINE INDENT def __init__ ( self , id , depth ) : NEW_LINE INDENT self . id = id NEW_LINE self . depth = depth NEW_LINE self . contents = self . contents NEW_LINE self . children = [ ] NEW_LINE DEDENT def find_node ( self , id ) : NEW_LINE INDENT if id == self . id : return self NEW_LINE for child in self . children : NEW_LINE INDENT target = child . find_node ( id ) NEW_LINE if target : return target NEW_LINE DEDENT return None NEW_LINE DEDENT def print_contents ( self ) : NEW_LINE INDENT for i in range ( self . depth ) : print ( ' . ' , end = ' ' ) NEW_LINE print ( self . contents ) NEW_LINE for child in self . children : NEW_LINE INDENT child . print_contents ( ) NEW_LINE DEDENT DEDENT DEDENT
def _import ( ) : return NEW_LINE import sys NEW_LINE import struct NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy NEW_LINE class Main2 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE v1 = sc . readline ( ) NEW_LINE v2 = sc . readline ( ) NEW_LINE t = sc . readline ( ) NEW_LINE d = sc . readline ( ) NEW_LINE dp = [ [ - 1 ] * ( t - 1 ) for x in self . dp ] NEW_LINE ans = - 1 NEW_LINE if t == 2 : NEW_LINE INDENT print ( v1 + v2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v1 + v2 + calculate ( 1 , v1 , v1 ) ) NEW_LINE DEDENT DEDENT def calculate ( currentTime , currentSpeed , prev ) : NEW_LINE INDENT if currentSpeed < 0 : NEW_LINE INDENT return - int ( 1e8 ) NEW_LINE DEDENT if currentTime == t - 1 : NEW_LINE INDENT if abs ( currentSpeed - v2 ) <= d : NEW_LINE INDENT return 0 NEW_LINE DEDENT return - int ( 1e8 ) NEW_LINE DEDENT if dp [ currentTime ] [ currentSpeed ] != - 1 : NEW_LINE INDENT return dp [ currentTime ] [ currentSpeed ] NEW_LINE DEDENT bestAns = - int ( 1e8 ) NEW_LINE for i in range ( 0 , d ) : NEW_LINE INDENT ans = currentSpeed + i + calculate ( currentTime + 1 , currentSpeed + i , currentSpeed ) NEW_LINE ans2 = currentSpeed - i + calculate ( currentTime + 1 , currentSpeed - i , currentSpeed ) NEW_LINE bestAns = max ( bestAns , max ( ans , ans2 ) ) NEW_LINE DEDENT return dp [ currentTime ] [ currentSpeed ] = bestAns NEW_LINE DEDENT DEDENT
def import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = self . n NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT self . a , self . b = key NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT self . a = key NEW_LINE self . b = key NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT self . b = key NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " % s ▁ % s " % ( self . a , self . b ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return " % s ▁ % s " % ( self . a , self . b ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return " % s ▁ % s " % ( self . a , self . b ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return " % s ▁ % s " % ( self . a , self . b ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return " % s ▁ % s " % ( self . a , self . b ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " % s ▁ % s " % ( self . a , self . b ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return " % s ▁ % s " % ( self . a , self . b ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " % s ▁ % s " % ( self . a , self . b ) NEW_LINE DEDENT def __getitem__ ( self , key ) : NEW_LINE INDENT return " % s ▁ % s " % ( self . a , self . b ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " % s ▁ % s " % ( self . a , self . b ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import string NEW_LINE import math NEW_LINE import random NEW_LINE import math NEW_LINE from math import sin , cos , sin , cos , sin , cos , sin , cos , sin , cos , sin , cos , sin , cos , sin , cos , sin , cos , sin , cos , sin , cos , sin , cos , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , sin , cos , sin , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , cos , sin , sin , sin , cos , sin , sin , sin , cos , sin , sin , sin , cos , sin , cos , sin , sin , sin , cos , sin , sin , cos , sin , sin , sin , cos , sin , sin , sin , sin , cos , sin , sin , sin , cos , sin , sin , sin , sin , sin , cos , sin , sin , sin , sin , sin , sin , sin , sin , cos , sin , sin , sin , cos , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , cos , sin , sin , sin , sin , sin , sin , sin , cos , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , cos , sin , sin , sin , sin , sin , ] NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from time import sleep NEW_LINE sleep ( 1 ) NEW_LINE while T : NEW_LINE INDENT n = sleep ( 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if j == 1 or i == j : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n = None ) : NEW_LINE INDENT if n : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( " % d " % ( n & 1 ) , end = " " ) NEW_LINE def main ( ) : NEW_LINE INDENT bin ( 131 ) NEW_LINE print ( " \n " ) NEW_LINE bin ( 3 ) NEW_LINE DEDENT DEDENT
def p001 ( ) : NEW_LINE INDENT print ( eval ( " p001 ( ) " ) ) NEW_LINE def f ( ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1000 ) : NEW_LINE INDENT if i % 3 == 0 or i % 5 == 0 : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT return f NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 0 NEW_LINE self . str = sys . stdin . read ( ) NEW_LINE self . s = " " NEW_LINE self . s1 = " " NEW_LINE for i in range ( len ( self . str ) ) : NEW_LINE INDENT if self . str [ i ] == " n " : NEW_LINE INDENT self . s += "1 ▁ " NEW_LINE DEDENT if self . str [ i ] == " z " : NEW_LINE INDENT self . s1 += "0 ▁ " NEW_LINE DEDENT DEDENT print ( self . s + s1 ) NEW_LINE DEDENT DEDENT
def import solve NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . R , self . G = sys . stdin . read ( ) . split ( ' \n ' ) NEW_LINE print ( ( 2 * G ) - R ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT return solve ( ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def Circular ( self ) : NEW_LINE INDENT Result = 1 NEW_LINE while self . n > 0 : NEW_LINE INDENT Result = Result * self . n NEW_LINE self . n -= 1 NEW_LINE DEDENT return Result NEW_LINE DEDENT def Main ( self ) : NEW_LINE INDENT n = 4 NEW_LINE print ( Circular ( self . n - 1 ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def product_diagonals ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT self . product = self . product * arr [ i ] [ i ] NEW_LINE self . product = self . product * arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT self . product = self . product / arr [ n // 2 ] [ n // 2 ] NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT arr1 = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 7 , 4 , 2 ] , [ 2 , 2 , 2 , 1 ] ] NEW_LINE sys . stdout . write ( self . product_diagonals ( arr1 , 4 ) + " \n " ) NEW_LINE arr2 = [ [ 2 , 1 , 2 , 1 , 2 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 2 , 1 , 2 , 1 , 2 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 2 , 1 , 2 , 1 , 2 ] ] NEW_LINE sys . stdout . write ( self . product_diagonals ( arr2 , 5 ) + " \n " ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def import import string , * , maxwidth = 8 , maxwidth = 8 , maxheight = 8 , count = 1 , words = None , ** kwargs ) : NEW_LINE INDENT from string import ascii_letters NEW_LINE import string NEW_LINE from random import choice NEW_LINE sc = Scanner ( ) NEW_LINE def run ( ) : NEW_LINE INDENT for n in range ( maxwidth ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT map = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ sc . next ( ) ] += 1 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT ans = " - " NEW_LINE if map [ i ] != 0 : NEW_LINE INDENT ch = string . ascii_letters [ map [ i ] ] NEW_LINE ans = " " . join ( ch ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT DEDENT m = re . compile ( r ' ( ? : [ ^ \n ] + ) ' ) NEW_LINE print ( m . group ( 1 ) ) NEW_LINE DEDENT
def GFG ( x ) : NEW_LINE INDENT NO_OF_CHARS = 256 NEW_LINE def getSecondMostFreq ( x ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for c in x : ( count [ c ] ) NEW_LINE first , second = 0 , 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] > count [ first ] : NEW_LINE INDENT second , first = first , i NEW_LINE DEDENT elif count [ i ] > count [ second ] and count [ i ] != count [ first ] : second = i NEW_LINE DEDENT return chr ( second ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT x = ' geeksforgeeks ' NEW_LINE res = getSecondMostFreq ( x ) NEW_LINE if res != ' \ ' 0' : NEW_LINE INDENT print ( ' Second ▁ most ▁ frequent ▁ char ' , ' is ▁ ' , res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ▁ second ▁ most ▁ frequent ' , ' character ' ) NEW_LINE DEDENT DEDENT return main NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from time import sleep NEW_LINE from random import randint NEW_LINE from sys import stdin NEW_LINE dp = [ [ 0 ] * ( 5 + [ 1 ] * ( 5 + [ 1 ] * ( 5 + [ 1 ] * ( 5 + [ 1 ] * ( 5 + [ 1 ] * ( 5 + [ 1 ] * ( 5 + [ 1 ] * ( 5 ) ) ) ) ) ) ) ) for i in range ( 1 , 5 ) for ii in range ( 0 , 1000 * i ) for iii in range ( max ( 0 , ii - 1000 ) , ii + 1 ) ) ] NEW_LINE for i in range ( 0 , 4 ) : NEW_LINE INDENT print ( dp [ 4 ] [ i ] ) NEW_LINE DEDENT DEDENT
def my_sort ( arr ) : NEW_LINE INDENT import sys NEW_LINE class SortExample ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . arr = arr NEW_LINE DEDENT def sort ( self ) : NEW_LINE INDENT n = len ( self . arr ) NEW_LINE self . arr = arr [ : n // 2 ] NEW_LINE self . arr = arr [ n // 2 : n ] + list ( reversed ( self . arr ) ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 ] NEW_LINE self . my_sort ( arr ) NEW_LINE print ( " Modified ▁ Array ▁ : ▁ % s " % ( " , ▁ " . join ( arr ) ) ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def minflip ( self , arr1 , arr2 , arr3 , p , q , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr1 [ i ] > 0 ^ arr2 [ i ] > 0 != arr3 [ i ] > 0 : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT return ( flip <= p + q ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr1 = [ 1 , 0 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 0 , 1 , 1 , 1 , 1 , 0 , 0 ] NEW_LINE arr3 = [ 1 , 1 , 1 , 1 , 0 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE p , q = 2 , 4 NEW_LINE print ( minflip ( self , arr1 , arr2 , arr3 , p , q , n ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def import _sum NEW_LINE class GFG ( object ) : NEW_LINE INDENT def sum ( self , n ) : NEW_LINE INDENT i , s = 0.0 , 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i NEW_LINE DEDENT return s NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT n = 5 NEW_LINE print ( " Sum ▁ is ▁ % f " % sum ( n ) ) NEW_LINE DEDENT DEDENT
def bitonic_generator ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . evenarr = [ ] NEW_LINE self . oddarr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 != 1 : NEW_LINE INDENT self . evenarr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT self . oddarr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT self . evenarr . sort ( ) NEW_LINE self . oddarr . sort ( reverse = True ) NEW_LINE self . i = 0 NEW_LINE for j in self . evenarr : NEW_LINE INDENT self . i += j NEW_LINE DEDENT for j in self . oddarr : NEW_LINE INDENT self . i += j NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonic_generator ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right , left = 0 , 0 NEW_LINE visited = [ False for i in range ( n ) ] NEW_LINE while right < n : NEW_LINE INDENT while right < n and not visited [ arr [ right ] ] : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while left < right and ( right != n and visited [ arr [ right ] ] ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def import _tree_object NEW_LINE class TreeNode ( object ) : NEW_LINE INDENT def __init__ ( self , root_data ) : NEW_LINE INDENT self . val = root_data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT trees = set ( ) NEW_LINE def isSubtree ( self , s , t ) : NEW_LINE INDENT tree1 = preorder ( s , True ) NEW_LINE tree2 = preorder ( t , True ) NEW_LINE return tree1 . find ( tree2 ) >= 0 NEW_LINE DEDENT def preorder ( self , t , left ) : NEW_LINE INDENT if t is None : NEW_LINE INDENT if left : return ' lnull ' NEW_LINE else : return ' rnull ' NEW_LINE DEDENT return ' # % d ▁ % s ▁ % s ' % ( t . val , preorder ( self . left , True ) , preorder ( self . right , False ) ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE root = TreeNode ( 3 ) NEW_LINE root . left = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 5 ) NEW_LINE root . left . left = TreeNode ( 1 ) NEW_LINE root . left . right = TreeNode ( 2 ) NEW_LINE subRoot = TreeNode ( 4 ) NEW_LINE subRoot . left = TreeNode ( 1 ) NEW_LINE subRoot . right = TreeNode ( 2 ) NEW_LINE out = sObj . isSubtree ( root , subRoot ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT M = 1001 NEW_LINE MOD = 998244353 NEW_LINE dp = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
def p222 ( ) : print ( eval ( ' p222 ( ) ' ) ) NEW_LINE def main ( ) : NEW_LINE INDENT global sphere_radii NEW_LINE sphere_radii = [ ( x + 30 ) * 1000 for x in range ( 21 ) ] NEW_LINE min_length = [ [ 1 << len ( sphere_radii ) ] * 1000 for x in range ( 21 ) ] NEW_LINE min = float ( ' inf ' ) NEW_LINE for i in range ( len ( sphere_radii ) ) : NEW_LINE INDENT min = min ( find_minimum_length ( i , ( 1 << len ( sphere_radii ) ) - 1 ) + sphere_radii [ i ] , min ) NEW_LINE DEDENT return str ( round ( min , 3 ) ) NEW_LINE DEDENT def find_minimum_length ( current_sphere_index , set_of_spheres ) : NEW_LINE INDENT if not set_of_spheres & ( 1 << current_sphere_index ) : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT if min_length [ current_sphere_index ] [ set_of_spheres ] == 0 : NEW_LINE INDENT if sum ( set_of_spheres ) == 1 : NEW_LINE INDENT result = sphere_radii [ current_sphere_index ] NEW_LINE DEDENT else : NEW_LINE INDENT result = float ( ' inf ' ) NEW_LINE new_set_of_spheres = set_of_spheres ^ ( 1 << current_sphere_index ) NEW_LINE for i in range ( len ( sphere_radii ) ) : NEW_LINE INDENT if not new_set_of_spheres & ( 1 << i ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = math . sqrt ( ( sphere_radii [ i ] + sphere_radii [ current_sphere_index ] - 50000 ) * 200000 ) NEW_LINE temp += find_minimum_length ( i , new_set_of_spheres ) NEW_LINE result = min ( temp , result ) NEW_LINE DEDENT DEDENT min_length [ current_sphere_index ] [ set_of_spheres ] = result NEW_LINE DEDENT return min_length [ current_sphere_index ] [ set_of_spheres ] NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = 0 NEW_LINE self . sides = [ ] NEW_LINE judge = False NEW_LINE for line in sys . stdin : NEW_LINE INDENT line = line . strip ( ) NEW_LINE n = int ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = line . strip ( ) NEW_LINE tmp = line . split ( ) NEW_LINE for i in range ( len ( sides ) ) : NEW_LINE INDENT sides [ i ] = int ( tmp [ i ] ) NEW_LINE sides [ i ] *= sides [ i ] NEW_LINE DEDENT for i in range ( len ( sides ) ) : NEW_LINE INDENT if sides [ i ] % 3 == sides [ ( i + 1 ) % 3 ] + sides [ ( i + 2 ) % 3 ] : NEW_LINE INDENT judge = True NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT judge = False NEW_LINE DEDENT DEDENT Answer ( judge ) NEW_LINE DEDENT DEDENT DEDENT def Answer ( j ) : NEW_LINE INDENT if j : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def __get_total_xor_of_subarray_xors ( arr , N ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG : NEW_LINE INDENT def __total_xor_of_subarray_xors ( self , arr , N ) : NEW_LINE INDENT if N % 2 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , N , 2 ) : NEW_LINE INDENT res ^= arr [ i : i + 2 ] NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT def __main ( ) : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( __total_xor_of_subarray_xors ( arr , N ) ) NEW_LINE DEDENT return GFG NEW_LINE DEDENT
def __get_total_xor_of_subarray_xors ( arr , N ) : NEW_LINE INDENT import numpy as np NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __total_xor_of_subarray_xors ( self , arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if freq % 2 == 1 : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( __total_xor_of_subarray_xors ( arr , N ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from numpy . core import get_distribution NEW_LINE x = get_distribution ( ) NEW_LINE l , p , q = get_distribution ( ) NEW_LINE print ( ( p * l ) / ( p + q ) ) NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . sys = sys NEW_LINE self . sys . argv = [ ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sc = sys . stdin NEW_LINE t = sys . maxsize NEW_LINE while t > 0 : NEW_LINE INDENT n = sc . read ( ) NEW_LINE arr = [ sc . read ( ) for i in range ( 2 * n ) ] NEW_LINE arr = [ arr [ i ] for i in range ( n ) ] NEW_LINE print ( abs ( arr [ n ] - arr [ n - 1 ] ) ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT DEDENT
def import import struct NEW_LINE from math import sin , cos , pi NEW_LINE from os import urandom NEW_LINE from math import pi NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE n = urandom ( 2 ) NEW_LINE cntp = { } NEW_LINE cntn = { } NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = urandom ( 2 ) NEW_LINE if a == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif a > 0 : NEW_LINE INDENT cntp [ a ] += 1 NEW_LINE DEDENT elif a < 0 : NEW_LINE INDENT cntn [ abs ( a ) ] += 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT res = res + ( cntp [ i ] * cntn [ i ] ) NEW_LINE DEDENT res = res + ( ( cnt * ( cnt - 1 ) ) / 2 ) NEW_LINE sys . stdout . write ( res ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from cStringIO import StringIO NEW_LINE import sys NEW_LINE class CF95A ( StringIO ) : NEW_LINE INDENT def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT self . __init__ ( self , * args , ** kwargs ) NEW_LINE DEDENT DEDENT sc = StringIO ( ) NEW_LINE def main ( * args , ** kwargs ) : NEW_LINE INDENT o = CF95A ( ) NEW_LINE o . main ( * args , ** kwargs ) NEW_LINE o . flush ( ) NEW_LINE DEDENT def compare ( aa , i , bb , j , m ) : NEW_LINE INDENT while m : NEW_LINE INDENT a = aa [ i ] . upper ( ) NEW_LINE b = bb [ j ] . upper ( ) NEW_LINE if a != b : return a - b NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def main ( * args , ** kwargs ) : NEW_LINE INDENT n = sc . tell ( ) NEW_LINE ss = [ ] NEW_LINE for s in sc . readlines ( ) : NEW_LINE INDENT ss . append ( s . decode ( ' utf8' ) ) NEW_LINE DEDENT cc = sc . readlines ( ) NEW_LINE m = len ( cc ) NEW_LINE c = sc . read ( ) NEW_LINE c_ = c . decode ( ' utf8' ) NEW_LINE a = c == ' a ' NEW_LINE a_ = a . upper ( ) NEW_LINE lucky = [ ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT l = len ( ss [ i ] ) NEW_LINE if m - j >= l and compare ( cc , j , ss [ i ] [ : l ] ) == 0 : NEW_LINE INDENT for h in range ( l ) : NEW_LINE INDENT lucky . append ( h ) NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if lucky [ j ] : NEW_LINE INDENT if cc [ j ] . lower ( ) == c : NEW_LINE INDENT cc [ j ] = a_ if cc [ j ] . isupper ( ) else a NEW_LINE DEDENT else : NEW_LINE INDENT cc [ j ] = c_ if cc [ j ] . isupper ( ) else c NEW_LINE DEDENT DEDENT DEDENT DEDENT return cc NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE sc = sys . stdin NEW_LINE a = sc . __next__ ( ) NEW_LINE c = sc . read ( ) NEW_LINE w = [ 0 ] * ( a + 1 ) NEW_LINE e = [ 0 ] * ( a + 1 ) NEW_LINE min = a NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT if c [ i - 1 ] == ' W ' : NEW_LINE INDENT w [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT e [ i ] += 1 NEW_LINE DEDENT w [ i ] += w [ i - 1 ] NEW_LINE e [ i ] += e [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT min = min ( min , w [ i - 1 ] + e [ a ] - e [ i ] ) NEW_LINE DEDENT print ( min ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from pybind11_tests import CF1213A NEW_LINE from pybind11_tests import CF1213A NEW_LINE n = len ( sys . argv ) NEW_LINE even = odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT num1 = sys . argv [ i ] NEW_LINE if num1 % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if even > odd : NEW_LINE INDENT print ( odd ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( even ) NEW_LINE DEDENT DEDENT
def import import * NEW_LINE class Main ( object ) : NEW_LINE INDENT def do_it ( self ) : NEW_LINE INDENT sc = Scanner ( ) NEW_LINE MAX = 10000000 NEW_LINE prime = [ True for i in range ( 3 , MAX + 1 , 2 ) ] NEW_LINE for i in range ( 3 , MAX + 1 , 2 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT for j in range ( i * 3 , MAX + 1 , i * 2 ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT n = sc . __next__ ( ) NEW_LINE while n != 0 : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT for i in range ( n , 13 , - 2 ) : NEW_LINE INDENT if prime [ i ] and prime [ i - 2 ] and prime [ i - 6 ] and prime [ i - 8 ] : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT n = sc . __next__ ( ) NEW_LINE DEDENT DEDENT obj = Main ( ) NEW_LINE obj . do_it ( ) NEW_LINE DEDENT
def import import sys , string , * , line , ** kwargs ) : NEW_LINE INDENT from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE from os import environ NEW_LINE DEDENT
def _powers_of_two ( n ) : return ( ( n & n - 1 ) == 0 ) NEW_LINE def only_first_and_last_are_set ( n ) : NEW_LINE INDENT if n == 1 : return True NEW_LINE return _powers_of_two ( n - 1 ) NEW_LINE DEDENT
def minimum_cost_of_breaking ( X = None , Y = None , m = 3 , n = 4 ) : NEW_LINE INDENT from math import sin , cos , cos , log NEW_LINE from math import sin , cos , log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE from math import log NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if a == 0 : return b NEW_LINE return gcd ( b % a , a ) NEW_LINE DEDENT def count_pairs ( G , L ) : NEW_LINE INDENT count = 0 NEW_LINE p = G * L NEW_LINE for a in range ( 1 , L + 1 ) : NEW_LINE INDENT if ( p % a == 0 ) and gcd ( a , p // a ) == G : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT G , L = 2 , 12 NEW_LINE print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ % d " % G , end = ' ▁ & ▁ LCM ▁ % d ' % L , end = ' ▁ = ▁ ' , count_pairs ( G , L ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sympy NEW_LINE from sympy . polys . polyfuncs import polyfuncs NEW_LINE class GFG ( sympy . polys . PolyElement ) : NEW_LINE INDENT def __init__ ( self , a , b ) : NEW_LINE INDENT mul = [ [ 0 ] * 3 for i in range ( 3 ) ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] = 0 NEW_LINE for k in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT a [ i ] [ j ] = mul [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def power ( self , F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE if n == 1 : NEW_LINE INDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] NEW_LINE DEDENT power ( self , n // 2 ) NEW_LINE self . multiply ( F , F ) NEW_LINE if n % 2 : NEW_LINE INDENT self . multiply ( M ) NEW_LINE DEDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] NEW_LINE DEDENT def find_nth_term ( self , n ) : NEW_LINE INDENT F = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE return power ( self , n - 2 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n = 5 NEW_LINE print ( " F ( 5 ) ▁ is ▁ " , find_nth_term ( n ) ) NEW_LINE DEDENT DEDENT GFG ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def MinimumValue ( self , x , y ) : NEW_LINE INDENT if x > y : NEW_LINE INDENT temp = x NEW_LINE x = y NEW_LINE y = temp NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT x , y = 123 , 13 NEW_LINE MinimumValue ( x , y ) NEW_LINE DEDENT DEDENT
def Solution ( ) : NEW_LINE INDENT class Solution ( object ) : NEW_LINE INDENT def checkPossibility ( self , nums ) : NEW_LINE INDENT brokenPoint = 0 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] > nums [ i + 1 ] : NEW_LINE INDENT brokenPoint += 1 NEW_LINE if brokenPoint >= 2 : return False NEW_LINE if i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] : NEW_LINE INDENT nums [ i ] , nums [ i + 1 ] = nums [ i + 1 ] , nums [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i + 1 ] , nums [ i ] = nums [ i ] , nums [ i + 1 ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT sObj = Solution ( ) NEW_LINE nums = [ 4 , 2 , 3 ] NEW_LINE out = sObj . checkPossibility ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def GFG ( x , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x [ i ] > mid : NEW_LINE INDENT return False NEW_LINE DEDENT sum += x [ i ] NEW_LINE if sum > mid : NEW_LINE INDENT count += 1 NEW_LINE sum = x [ i ] NEW_LINE DEDENT DEDENT count += 1 NEW_LINE if count <= K : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def import _recarray NEW_LINE import struct NEW_LINE import struct NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = _recarray NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . M , self . N = struct . unpack ( ' > i ' , self . M ) NEW_LINE DEDENT def rec ( self , used , lst ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT M , N = struct . unpack ( ' > i ' , self . M ) NEW_LINE if not M : NEW_LINE INDENT break NEW_LINE DEDENT lst = [ int ( i , 2 ) for i in lst ] NEW_LINE lst . insert ( 0 , - 1 ) NEW_LINE print ( self . rec ( 0 , lst ) ) NEW_LINE DEDENT DEDENT def rec ( self , used , lst ) : NEW_LINE INDENT if len ( lst ) <= 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if self . memo [ used ] >= 0 : NEW_LINE INDENT return self . memo [ used ] NEW_LINE DEDENT ret = 99 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if used & ( 3 << ( 2 * i ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT on = [ ] NEW_LINE off = [ ] NEW_LINE for v in lst : NEW_LINE INDENT if v & ( 1 << i ) : NEW_LINE INDENT on . append ( v ) NEW_LINE DEDENT else : NEW_LINE INDENT off . append ( v ) NEW_LINE DEDENT DEDENT if not on or not off : NEW_LINE INDENT continue NEW_LINE DEDENT ret = min ( ret , max ( self . rec ( used | ( 1 << ( 2 * i ) ) , on ) , self . rec ( used | ( 2 << ( 2 * i ) ) , off ) ) ) NEW_LINE DEDENT self . memo [ used ] = ret + 1 NEW_LINE return ret + 1 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from math import sin , cos , solve NEW_LINE t = sys . stdin . read ( ) . split ( ' \n ' ) NEW_LINE for tc in range ( t ) : NEW_LINE INDENT a = sin ( t [ 0 ] ) NEW_LINE b = sin ( t [ 1 ] ) NEW_LINE print ( solve ( a , b ) ) NEW_LINE DEDENT def solve ( a , b ) : NEW_LINE INDENT return min ( min ( computeSquareArea ( a + a , b ) , computeSquareArea ( a + b , max ( a , b ) ) ) , computeSquareArea ( a , b + b ) ) NEW_LINE DEDENT def computeSquareArea ( side1 , side2 ) : NEW_LINE INDENT size = max ( side1 , side2 ) NEW_LINE return size * size NEW_LINE DEDENT return solve NEW_LINE DEDENT
def _solve ( a , b , n ) : NEW_LINE INDENT import sys NEW_LINE from sympy . utilities . iterables import variations NEW_LINE from sympy . printing . debuglevel import debuglevel NEW_LINE from sympy . printing . debuglevel import debuglevel NEW_LINE from sympy . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE from sympy . core . printing . debuglevel import debuglevel NEW_LINE debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( debuglevel ( level ( level ( level ( level ( level ( level ( level ( level ( level ( level ( level ( level ( level ( level ( level ( level (
def GFG ( N ) : NEW_LINE INDENT N = N . replace ( ' ▁ ' , ' ' ) NEW_LINE if N [ - 1 ] in [ '0' , '2' , '4' , '6' ] : NEW_LINE INDENT return ( ' Even ' ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ' Odd ' ) NEW_LINE DEDENT DEDENT
def import _main NEW_LINE import sys NEW_LINE class Vector ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . A = [ ] NEW_LINE DEDENT def add ( self , x ) : NEW_LINE INDENT if self . A == [ ] : NEW_LINE INDENT A = [ A ] * 2 NEW_LINE DEDENT self . A . append ( x ) NEW_LINE self . A . append ( x ) NEW_LINE self . A . append ( x ) NEW_LINE self . A . append ( x ) NEW_LINE self . A . append ( x ) NEW_LINE DEDENT def deleteBack ( self ) : NEW_LINE INDENT self . A . pop ( ) NEW_LINE DEDENT def toString ( self ) : NEW_LINE INDENT s = [ ] NEW_LINE if self . A : NEW_LINE INDENT s . append ( self . A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT s . append ( " ▁ " . join ( s ) ) NEW_LINE DEDENT return s NEW_LINE DEDENT DEDENT class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . A = [ ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sc = _main ( ) NEW_LINE n , q = sc . regs [ 0 ] NEW_LINE v = [ ] NEW_LINE active = [ ] NEW_LINE for req , t in zip ( sc . regs [ 1 : ] , range ( q ) ) : NEW_LINE INDENT if req == 0 : NEW_LINE INDENT if not active [ t ] : NEW_LINE INDENT v . append ( Vector ( ) ) NEW_LINE active [ t ] = True NEW_LINE DEDENT v [ t ] . append ( sc . regs [ 1 ] ) NEW_LINE DEDENT elif req == 1 : NEW_LINE INDENT if active [ t ] : NEW_LINE INDENT print ( v [ t ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ) NEW_LINE DEDENT DEDENT elif req == 2 : NEW_LINE INDENT active [ t ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT return Main NEW_LINE DEDENT
def import import sys , string , ascii_letters , words , words NEW_LINE class pr6 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . words = words NEW_LINE self . n , k1 , k2 , w1 , w2 , a = [ ] , 0 , 0 , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( string . ascii_letters ) NEW_LINE if a [ i ] % 2 == 0 : NEW_LINE INDENT w1 += 1 NEW_LINE k1 = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT w2 += 1 NEW_LINE k2 = i + 1 NEW_LINE DEDENT DEDENT print ( ( w1 , k1 , k2 ) ) NEW_LINE DEDENT DEDENT
def GFG ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) NEW_LINE sol = 0 NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + abs ( X [ i - 1 ] - Y [ i - 1 ] ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( count [ i ] - count [ j ] > K ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT sol = max ( sol , i - j ) NEW_LINE DEDENT return sol NEW_LINE DEDENT
def import import * NEW_LINE from math import sin , cos , pow , numpy NEW_LINE from numpy import pi , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi NEW_LINE from numpy import cos , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi NEW_LINE from numpy import cos , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi , pi NEW_LINE from numpy import cos , pi , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi , pi NEW_LINE from numpy import cos , pi , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi , pi NEW_LINE from numpy import sin , pi , pi , pi , pi NEW_LINE from numpy . random import uniform NEW_LINE from numpy . core import zeros , pi , pi , pi NEW_LINE from numpy . core import sin , pi , pi , pi NEW_LINE from numpy . random import uniform NEW_LINE from numpy . core import sin , pi , pi , pi , pi NEW_LINE from numpy . core import sin , pi , pi , pi , pi NEW_LINE from numpy . random import uniform NEW_LINE from numpy . core import sin , pi , pi , pi , pi NEW_LINE from numpy . core import sin , pi , pi , pi , pi , pi NEW_LINE from numpy . core import cos , pi , pi , pi , pi , pi NEW_LINE from numpy . core import sin , pi , pi , pi , pi NEW_LINE from numpy . core import sin , pi , pi , pi , pi , pi NEW_LINE from numpy . core import sin , pi , pi , pi , pi , pi NEW_LINE from numpy . core import sin , pi , pi , pi , pi NEW_LINE from numpy . core import sin , pi , pi , pi , pi NEW_LINE from numpy . core import sin , pi , pi , pi , pi NEW_LINE from numpy . core import sin , pi , pi , pi , pi , pi , pi , pi NEW_LINE DEDENT
def __pow__ ( n , i ) : NEW_LINE INDENT import math NEW_LINE if n <= 2 : return ( n == 2 ) NEW_LINE if n % i == 0 : return False NEW_LINE if i ** 2 > n : return True NEW_LINE return __pow__ ( n , i + 1 ) NEW_LINE DEDENT
def __pow__ ( n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( int ) : NEW_LINE INDENT def __pow__ ( self , n ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : return False NEW_LINE i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def __minimum_sum ( self , n ) : NEW_LINE INDENT if self . __prime : return 1 NEW_LINE if n % 2 == 0 : return 2 NEW_LINE if self . __prime : return 2 NEW_LINE if self . __prime : return 2 NEW_LINE return 3 NEW_LINE DEDENT def __main ( self ) : NEW_LINE INDENT n = 27 NEW_LINE print ( __minimum_sum ( self , n ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT from math import sin , cos , pi NEW_LINE class GFG ( object ) : NEW_LINE INDENT def isPrime ( self , x ) : NEW_LINE INDENT for i in range ( 2 , 2 * pi + 1 ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minimumCost ( self , n ) : NEW_LINE INDENT if isPrime ( n ) : return 1 NEW_LINE if n % 2 == 1 and isPrime ( n - 2 ) : return 2 NEW_LINE if n % 2 == 0 : return 2 NEW_LINE return 3 NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT n = 6 NEW_LINE print ( minimumCost ( n ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def GFG ( x ) : NEW_LINE INDENT if x > 0 : NEW_LINE INDENT right_one , next_higher , right_ones_re , next = x & - x , x + right_one , x ^ next_higher , ( right_ones_re ) NEW_LINE right_ones_re = ( right_ones_re ) // right_one NEW_LINE right_ones_re >>= 2 NEW_LINE next = next_higher | right_ones_re NEW_LINE DEDENT return next NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT def proper_divisor_sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 2 * i + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i / j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i / j NEW_LINE DEDENT DEDENT DEDENT sum = sum - i NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 4 NEW_LINE print ( proper_divisor_sum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( proper_divisor_sum ( n ) ) NEW_LINE DEDENT DEDENT
def __minLen ( arr , n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def getMinLength ( self , n ) : NEW_LINE INDENT count = 0 NEW_LINE result = sys . maxint NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if count != 0 : NEW_LINE INDENT result = min ( result , count ) NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( __getMinLength ( arr , n ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def _ import _ NEW_LINE from itertools import chain NEW_LINE class GFG ( object ) : NEW_LINE INDENT def getLevenstein ( self ) : NEW_LINE INDENT revInput = chain ( self . input ) NEW_LINE revInput = revInput . reverse ( ) NEW_LINE n = len ( self . input ) NEW_LINE dp = [ [ i , i ] for i in range ( 0 , n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if self . input [ i - 1 ] == revInput [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = sum ( dp ) NEW_LINE for i , j in zip ( range ( n , 0 , - 1 ) , range ( 0 , - 1 ) ) : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if i < n : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT input = [ " myfirstgeekarticle " ] NEW_LINE print ( getLevenstein ( self ) ) NEW_LINE DEDENT DEDENT
def test_p088 ( ) : NEW_LINE INDENT from sympy . abc import n NEW_LINE from sympy import oo NEW_LINE from sympy . core . logic import NoContext NEW_LINE from sympy . sets . sets import Set NEW_LINE from sympy . sets . sets import Set NEW_LINE from sympy . sets . sets import Set NEW_LINE from sympy . sets . sets import Set NEW_LINE from sympy . sets . sets import Set NEW_LINE from sympy . sets . sets import Set NEW_LINE LIMIT = 12000 NEW_LINE def run ( ) : NEW_LINE INDENT min_sum_product = [ ] NEW_LINE min_sum_product . append ( Integer ( 1 ) ) NEW_LINE for i in range ( 2 , LIMIT * 2 + 1 ) : NEW_LINE INDENT factorize ( i , i , i , 0 , 0 ) NEW_LINE DEDENT items = Set ( min_sum_product [ 2 ] ) NEW_LINE sum = 0 NEW_LINE for n in items : NEW_LINE INDENT sum += n NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT def factorize ( n , remain , max_factor , sum , terms ) : NEW_LINE INDENT if remain == 1 : NEW_LINE INDENT if sum > n : NEW_LINE INDENT raise AssertionError NEW_LINE DEDENT terms += n - sum NEW_LINE if terms <= LIMIT and n < min_sum_product [ terms ] : NEW_LINE INDENT min_sum_product [ terms ] = n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 2 , max_factor + 1 ) : NEW_LINE INDENT if remain % i == 0 : NEW_LINE INDENT factor = i NEW_LINE factorize ( n , remain // factor , min ( factor , max_factor ) , sum + factor , terms + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return NEW_LINE DEDENT
def import import sys , string NEW_LINE import getopt NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT open ( sys . stdin , ' r ' ) NEW_LINE self . n = int ( sys . stdin . readline ( ) ) NEW_LINE sa = sys . stdin . readline ( ) . split ( ) NEW_LINE a = [ int ( i ) for i in sa ] NEW_LINE DEDENT def go ( a ) : NEW_LINE INDENT mod = 1000000007 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p = p * i % mod NEW_LINE DEDENT q = [ 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT q . append ( ( q [ i - 1 ] + modinv ( i + 1 , mod ) ) % mod ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = q [ i ] + q [ n - i - 1 ] - 1 NEW_LINE val *= a [ i ] NEW_LINE val %= mod NEW_LINE val *= p NEW_LINE val %= mod NEW_LINE ans += val NEW_LINE ans %= mod NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT def modinv ( a , m ) : NEW_LINE INDENT b = m NEW_LINE u = 1 NEW_LINE v = 0 NEW_LINE tmp = 0 NEW_LINE while b > 0 : NEW_LINE INDENT t = a // b NEW_LINE a -= t * b NEW_LINE tmp = a NEW_LINE a = b NEW_LINE b = tmp NEW_LINE u -= t * v NEW_LINE tmp = u NEW_LINE u = v NEW_LINE v = tmp NEW_LINE DEDENT u %= m NEW_LINE if u < 0 : NEW_LINE INDENT u += m NEW_LINE DEDENT return u NEW_LINE DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT from Queue import Queue NEW_LINE from Queue import Queue NEW_LINE class Queue_reverse ( Queue ) : NEW_LINE INDENT def Print ( ) : NEW_LINE INDENT while not Queue . empty ( ) : NEW_LINE INDENT print ( Queue . peek ( ) , end = ' ▁ ' ) NEW_LINE Queue . pop ( ) NEW_LINE DEDENT DEDENT def reverse_queue ( q ) : NEW_LINE INDENT if not Queue . empty ( ) : NEW_LINE INDENT return q NEW_LINE DEDENT data = Queue . peek ( ) NEW_LINE Queue . pop ( ) NEW_LINE q = reverse_queue ( q ) NEW_LINE Queue . append ( data ) NEW_LINE return q NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT queue = Queue ( ) NEW_LINE queue . append ( 56 ) NEW_LINE queue . append ( 27 ) NEW_LINE queue . append ( 30 ) NEW_LINE queue . append ( 45 ) NEW_LINE queue . append ( 85 ) NEW_LINE queue . append ( 92 ) NEW_LINE queue . append ( 58 ) NEW_LINE queue . append ( 80 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 100 ) NEW_LINE queue = reverse_queue ( queue ) NEW_LINE Print ( ) NEW_LINE DEDENT DEDENT return Queue_reverse NEW_LINE DEDENT
def import _sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 1000000 NEW_LINE self . prime = [ True for i in range ( self . MAX + 1 ) ] NEW_LINE DEDENT def SieveOfEratosthenes ( self ) : NEW_LINE INDENT for i in range ( self . MAX + 1 ) : NEW_LINE INDENT self . prime [ i ] = True NEW_LINE DEDENT self . prime [ 1 ] = False NEW_LINE for p in range ( 2 , self . MAX + 1 ) : NEW_LINE INDENT if self . prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , self . MAX + 1 , p ) : NEW_LINE INDENT self . prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findDiff ( self , arr , n ) : NEW_LINE INDENT min , max = self . MAX + 2 , - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if self . prime [ arr [ i ] ] == True : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return ( max , - 1 ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . SieveOfEratosthenes ( ) NEW_LINE n = 4 NEW_LINE arr = [ 1 , 2 , 3 , 5 ] NEW_LINE res = findDiff ( self , arr , n ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( " No ▁ prime ▁ numbers " , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Difference ▁ is ▁ " , res ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import sys NEW_LINE from numpy . linalg import solve NEW_LINE from numpy . random import randint NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE from numpy . random import uniform NEW_LINE uniform = uniform ( uniform ( uniform ( uniform ( uniform ( uniform ( uniform ( uniform (
def import java . io . BufferedReader , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter , java . io . BufferedWriter ,
def __distinctSubString ( P , N ) : NEW_LINE INDENT import sys NEW_LINE S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = [ False ] * 26 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = P [ j ] - ord ( ' a ' ) NEW_LINE if freq [ pos ] == True : break NEW_LINE freq [ pos ] = True NEW_LINE s += P [ j ] NEW_LINE S . add ( s ) NEW_LINE DEDENT DEDENT return len ( S ) NEW_LINE DEDENT
def test_solve ( ) : NEW_LINE INDENT import sys NEW_LINE from sympy . utilities . iterables import solve NEW_LINE solve ( ) NEW_LINE def solve ( ) : NEW_LINE INDENT with open ( " test . txt " , " r " ) as f : NEW_LINE INDENT n = int ( f . read ( ) ) NEW_LINE k = int ( f . read ( ) ) NEW_LINE a = [ i for i in range ( n ) if i != 0 ] NEW_LINE x = 0 NEW_LINE if ( n - k ) % ( k - 1 ) == 0 : NEW_LINE INDENT x = ( n - k ) / ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = ( n - k ) / ( k - 1 ) + 1 NEW_LINE DEDENT print ( x + 1 ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE DEDENT
def minimum_adjacent_difference ( a , n , k ) : NEW_LINE INDENT from math import sqrt NEW_LINE min_diff = sys . maxint NEW_LINE for i in range ( ( 1 << n ) ) : NEW_LINE INDENT cnt = sum ( a [ i ] ) NEW_LINE if cnt == n - k : NEW_LINE INDENT temp = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT temp . append ( a [ j ] ) NEW_LINE DEDENT DEDENT max_diff = sys . maxint NEW_LINE for j in range ( len ( temp ) - 1 ) : NEW_LINE INDENT max_diff = max ( max_diff , temp [ j + 1 ] - temp [ j ] ) NEW_LINE DEDENT min_diff = min ( min_diff , max_diff ) NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE largest = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if largest < arr [ i ] : NEW_LINE INDENT largest = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = largest - arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 10 , 5 , 9 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE return arr [ n ] NEW_LINE DEDENT return main NEW_LINE DEDENT
def count_kdiv_pairs ( A , n , K ) : NEW_LINE INDENT import sys NEW_LINE class Count ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . freq = [ 0 for i in range ( n ) ] NEW_LINE DEDENT DEDENT freq = np . array ( [ A [ i ] % K for i in range ( K ) ] ) NEW_LINE sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 NEW_LINE for i in range ( 1 , K // 2 , 2 ) and i != ( K - i ) : NEW_LINE INDENT sum += freq [ i ] * freq [ K - i ] NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT sum += ( freq [ K // 2 ] * ( freq [ K // 2 ] - 1 ) / 2 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def import sys , string , traceback , symbols , object , count , symbol , domain , symbols , count , * , file , ** kwargs ) : NEW_LINE INDENT from sympy . utilities . misc import Scanner NEW_LINE sc = Scanner ( ) NEW_LINE while 1 : NEW_LINE INDENT S = [ sc . next ( ) ] NEW_LINE if S [ 0 ] == '0' : NEW_LINE INDENT break NEW_LINE DEDENT S . append ( symbol ) NEW_LINE S . append ( ' ' ) NEW_LINE f = True NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if S [ i ] [ 0 ] == S [ i ] [ 1 ] and S [ i ] [ 1 ] == S [ i ] [ 2 ] and S [ i ] [ 0 ] != ' + ' : NEW_LINE INDENT print ( S [ i ] [ 0 ] ) NEW_LINE f = False NEW_LINE break NEW_LINE DEDENT if S [ i ] [ 1 ] == S [ i ] [ 1 ] and S [ i ] [ 2 ] == S [ i ] [ 0 ] and S [ i ] [ 1 ] != ' + ' : NEW_LINE INDENT print ( S [ i ] [ 1 ] ) NEW_LINE f = False NEW_LINE break NEW_LINE DEDENT DEDENT if f and S [ 0 ] [ 0 ] == S [ 1 ] [ 1 ] and S [ 1 ] [ 1 ] == S [ 2 ] [ 2 ] and S [ 0 ] [ 0 ] != ' + ' : NEW_LINE INDENT print ( S [ 0 ] [ 0 ] ) NEW_LINE f = False NEW_LINE DEDENT if f and S [ 0 ] [ 2 ] == S [ 1 ] [ 1 ] and S [ 1 ] [ 1 ] == S [ 2 ] [ 0 ] and S [ 0 ] [ 2 ] != ' + ' : NEW_LINE INDENT print ( S [ 0 ] [ 2 ] ) NEW_LINE f = False NEW_LINE DEDENT if f : NEW_LINE INDENT print ( ' NA ' ) NEW_LINE DEDENT DEDENT DEDENT
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE class Binary ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . max_count = 0 NEW_LINE self . max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if arr [ curr ] == 0 : NEW_LINE INDENT if curr - prev_prev_zero > self . max_count : NEW_LINE INDENT self . max_count = curr - prev_prev_zero NEW_LINE self . max_index = prev_zero NEW_LINE DEDENT DEDENT prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT DEDENT if n - prev_zero > self . max_count : NEW_LINE INDENT self . max_index = prev_zero NEW_LINE DEDENT return Binary ( ) NEW_LINE DEDENT
def minimumX ( n , k ) : NEW_LINE INDENT ans = sys . maxint NEW_LINE for rem in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if n % rem == 0 : NEW_LINE INDENT ans = min ( ans , rem + ( n // rem ) * k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def GFG ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a %= mod NEW_LINE while b > 0 : NEW_LINE INDENT if b & 1 : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( 2 * a ) % mod NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE MAX = ' Z ' - ' A ' + 1 NEW_LINE def dfs ( n ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if vis [ i ] != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if indeg [ i ] != outdeg [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( k ) : NEW_LINE INDENT if vis [ k ] == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT vis [ k ] = 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if 0 < nei [ k ] [ i ] : NEW_LINE INDENT dfs ( i ) NEW_LINE DEDENT DEDENT DEDENT def run ( ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT n = random . randint ( MAX , MAX ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = 0 NEW_LINE indeg = [ 0 ] * MAX NEW_LINE outdeg = [ 0 ] * MAX NEW_LINE vis = [ 0 ] * MAX NEW_LINE nei = [ 0 ] * MAX NEW_LINE for c in range ( n ) : NEW_LINE INDENT u = c [ 0 ] - ' a ' NEW_LINE v = c [ - 1 ] - ' a ' NEW_LINE outdeg [ u ] += 1 NEW_LINE indeg [ v ] += 1 NEW_LINE nei [ u ] [ v ] = 1 NEW_LINE vis [ u ] = vis [ v ] = - 1 NEW_LINE s = u NEW_LINE DEDENT dfs ( s ) NEW_LINE if check ( ) : NEW_LINE INDENT print ( ' OK ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NG ' ) NEW_LINE DEDENT DEDENT DEDENT return run NEW_LINE DEDENT
def import import sys , string , c_int , string , sys NEW_LINE from itertools import combinations NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stream = sys . stdin NEW_LINE self . N = sys . maxint NEW_LINE self . a = intbv ( 0 , min = self . N , max = self . N ) NEW_LINE self . index = 0 NEW_LINE for i in range ( self . N ) : NEW_LINE INDENT if abs ( a [ index ] ) < abs ( a [ i ] ) : index = i NEW_LINE DEDENT print ( 2 * self . N - 1 ) NEW_LINE for i in range ( self . N ) : NEW_LINE INDENT print ( ( self . index + 1 ) , i + 1 ) NEW_LINE DEDENT if self . a [ index ] : NEW_LINE INDENT for i in range ( 2 , self . N + 1 ) : NEW_LINE INDENT print ( ( self . i - 1 ) , i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( self . N - 1 , 1 , - 1 ) : NEW_LINE INDENT print ( ( self . i + 1 ) , i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import string NEW_LINE import sys NEW_LINE class GFG ( object ) : NEW_LINE INDENT def check_palindrome ( self , x ) : NEW_LINE INDENT s = string . ascii_letters NEW_LINE s -= string . digits NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ i ] : return False NEW_LINE DEDENT s -= string . digits NEW_LINE DEDENT def print_solution ( self , partitions ) : NEW_LINE INDENT for i in partitions : NEW_LINE INDENT for j in i : NEW_LINE INDENT print ( j , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT def add_strings ( v , s , temp , index = None ) : NEW_LINE INDENT s = string . ascii_letters NEW_LINE s = string . digits NEW_LINE temp = [ ] NEW_LINE if index is None : temp = [ ] NEW_LINE for i in range ( index , len ( s ) ) : NEW_LINE INDENT s = s + s [ i ] NEW_LINE if check_palindrome ( s ) : NEW_LINE INDENT temp . append ( s ) NEW_LINE if i + 1 < len ( s ) : NEW_LINE INDENT v = add_strings ( v , s , temp , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( temp ) NEW_LINE DEDENT temp = [ ] NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT def partition ( self , v ) : NEW_LINE INDENT temp = [ ] NEW_LINE v = add_strings ( v , s , temp , 0 ) NEW_LINE print_solution ( v ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT s = ' geeks ' NEW_LINE partitions = [ ] NEW_LINE partition ( self , args ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def _import ( ) : NEW_LINE INDENT import math NEW_LINE import random NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . M = 100000007 NEW_LINE DEDENT def comb ( self , n , c ) : NEW_LINE INDENT b = 1 NEW_LINE for i in range ( c ) : NEW_LINE INDENT b = b * random . choice ( str ( n - i ) ) / random . choice ( str ( i + 1 ) ) NEW_LINE DEDENT return b % random . choice ( str ( self . M ) ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT with open ( self . Z ) as Z : NEW_LINE INDENT r , c , a1 , a2 , b1 , b2 = Z . next ( ) NEW_LINE x , y = abs ( a1 - b1 ) , abs ( a2 - b2 ) NEW_LINE x , y = min ( x , r - x ) , min ( y , c - y ) NEW_LINE z = 1 NEW_LINE if x == r - x : NEW_LINE INDENT z *= 2 NEW_LINE DEDENT if y == c - y : NEW_LINE INDENT z *= 2 NEW_LINE DEDENT print ( z * comb ( x + y , min ( x , y ) ) % M ) NEW_LINE DEDENT DEDENT DEDENT return Main NEW_LINE DEDENT
def test_find_subsequence ( arr , n , k ) : NEW_LINE INDENT import sys NEW_LINE from sympy . utilities . iterables import get_subsequence NEW_LINE M = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in M : NEW_LINE INDENT M [ arr [ i ] ] = M [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT M [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT num_count = [ 0 for i in range ( 0 , k + 1 ) ] NEW_LINE for ( k , v ) in M . items ( ) : NEW_LINE INDENT if k <= k : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if k * i > k : NEW_LINE INDENT break NEW_LINE DEDENT num_count [ k * i ] += v NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT lcm , length = 0 , 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if num_count [ i ] > length : NEW_LINE INDENT length = num_count [ i ] NEW_LINE lcm = i NEW_LINE DEDENT DEDENT if lcm == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " LCM ▁ = ▁ % d , ▁ Length ▁ = ▁ % d " % ( lcm , length ) ) NEW_LINE print ( " Indexes ▁ = ▁ " , end = ' ▁ ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lcm % arr [ i ] == 0 : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def count_pairs ( self , a , b , n , m ) : NEW_LINE INDENT odd1 , even1 = 0 , 0 NEW_LINE odd2 , even2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if b [ i ] % 2 == 1 : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , odd2 ) + min ( even1 , even2 ) NEW_LINE return pairs NEW_LINE DEDENT DEDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n , m = len ( a ) , len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE DEDENT
def GFG ( a , b , n , m ) : NEW_LINE INDENT odd1 , even1 = 0 , 0 NEW_LINE odd2 , even2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if b [ i ] % 2 == 1 : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , even2 ) + min ( odd2 , even1 ) NEW_LINE return pairs NEW_LINE DEDENT
def MaximumDiffrence ( arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE min_element = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if arr [ i ] - min_element > max_diff : NEW_LINE INDENT max_diff = arr [ i ] - min_element NEW_LINE DEDENT if arr [ i ] < min_element : NEW_LINE INDENT min_element = arr [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT
def GFG ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE def find_max ( n ) : NEW_LINE INDENT return binomial_coeff ( n , n // 2 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 5 NEW_LINE print ( find_max ( n ) ) NEW_LINE DEDENT DEDENT
def GFG ( freq ) : NEW_LINE INDENT MAX = 26 NEW_LINE def max_element ( freq ) : NEW_LINE INDENT max_ele = freq [ 0 ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if max_ele < freq [ i ] : max_ele = freq [ i ] NEW_LINE DEDENT return max_ele NEW_LINE DEDENT def minimum_addition ( data , freq ) : NEW_LINE INDENT freq = [ 0 ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT freq [ data [ i ] - ' a ' ] += 1 NEW_LINE DEDENT max_freq = max_element ( freq ) NEW_LINE min_addition = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if freq [ i ] > 0 : NEW_LINE INDENT min_addition += abs ( max_freq - freq [ i ] ) NEW_LINE DEDENT DEDENT return min_addition NEW_LINE DEDENT data = ' geeksforgeeks ' NEW_LINE freq = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
def test_195 ( ) : NEW_LINE INDENT import os NEW_LINE import math NEW_LINE from random import randint NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos NEW_LINE from math import sin , cos , sin NEW_LINE from math import sin , cos , sin , cos , cos , sin , cos , sin , cos , sin , cos , sin , cos , sin , cos , sin , cos , sin , sin , cos , sin , sin , sin , sin , cos , sin , sin , sin , cos , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , sin , ] NEW_LINE DEDENT
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . MAX = 32 NEW_LINE self . pow2 = [ ] NEW_LINE self . visited = [ ] NEW_LINE DEDENT def power_2 ( self ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( self . MAX ) : NEW_LINE INDENT self . pow2 . append ( ans ) NEW_LINE ans *= 2 NEW_LINE DEDENT DEDENT def count_set_bits ( self , x ) : NEW_LINE INDENT setbits = 0 NEW_LINE while x : NEW_LINE INDENT self . x = x & ( x - 1 ) NEW_LINE setbits += 1 NEW_LINE DEDENT return setbits NEW_LINE DEDENT def add ( num ) : NEW_LINE INDENT point = 0 NEW_LINE value = 0 NEW_LINE for i in range ( self . MAX ) : NEW_LINE INDENT if self . visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if num % 2 == 1 : NEW_LINE INDENT value += ( 1 << i ) NEW_LINE DEDENT num /= 2 NEW_LINE DEDENT DEDENT self . ans . append ( value ) NEW_LINE DEDENT def solve ( self , n , k ) : NEW_LINE INDENT self . ans . append ( k ) NEW_LINE countk = count_set_bits ( k ) NEW_LINE if self . pow2 [ countk ] < n : NEW_LINE INDENT print ( - 1 , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( self . pow2 [ countk ] - 1 ) : NEW_LINE INDENT add ( i ) NEW_LINE count += 1 NEW_LINE if count == n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT self . n , self . k = 3 , 5 NEW_LINE power_2 ( self ) NEW_LINE solve ( self , n , self . k ) NEW_LINE DEDENT DEDENT
def p027 ( ) : NEW_LINE INDENT print ( eval ( " p027 ( ) " ) ) NEW_LINE def f ( ) : NEW_LINE INDENT best_num = 0 NEW_LINE best_a = 0 NEW_LINE best_b = 0 NEW_LINE for a in range ( - 1000 , 1000 ) : NEW_LINE INDENT for b in range ( - 1000 , 1000 ) : NEW_LINE INDENT num = number_of_consecutive_primes_generated ( a , b ) NEW_LINE if num > best_num : NEW_LINE INDENT best_num = num NEW_LINE best_a = a NEW_LINE best_b = b NEW_LINE DEDENT DEDENT DEDENT return str ( best_a * best_b ) NEW_LINE DEDENT def number_of_consecutive_primes_generated ( a , b ) : NEW_LINE INDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT n = i ** 2 + i ** 2 + b NEW_LINE if n < 0 or not lib . is_prime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT return f NEW_LINE DEDENT
def _import ( ) : return sys . stdout . write NEW_LINE import readline NEW_LINE import readline NEW_LINE import readline NEW_LINE import time NEW_LINE import sys NEW_LINE import os NEW_LINE import math NEW_LINE import sys NEW_LINE class Pre149 : NEW_LINE INDENT class FastReader : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT return sys . stdin . readline NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not readline . is_readline ( ) or not readline . is_eof ( ) : NEW_LINE INDENT try : NEW_LINE INDENT readline . readline ( ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return readline . readline NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT data = ' ' NEW_LINE try : NEW_LINE INDENT data = readline ( self ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT return data NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT data = ' ' NEW_LINE try : NEW_LINE INDENT data = readline ( self ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT return data NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT obj = FastReader ( ) NEW_LINE tc = obj . count NEW_LINE while tc : NEW_LINE INDENT n , k = obj . next ( ) NEW_LINE if n > k : NEW_LINE INDENT out . write ( ( k * ( k + 1 ) ) / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT n -= 1 NEW_LINE n , k = ( n * ( n + 1 ) ) / 2 , n NEW_LINE n += 1 NEW_LINE out . write ( n ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def import _GG NEW_LINE class GFG ( object ) : NEW_LINE INDENT MAX = 100001 NEW_LINE isPrime = [ 0 ] * MAX NEW_LINE def sieve ( self ) : NEW_LINE INDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if self . isPrime [ p ] == 0 : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT self . isPrime [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT def findsubset ( self , a , n ) : NEW_LINE INDENT cnt1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT if cnt1 > 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 1 ) and ( self . isPrime [ a [ i ] + 1 ] == 0 ) : NEW_LINE INDENT print ( cnt1 + 1 ) NEW_LINE for j in range ( cnt1 ) : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT print ( a [ i ] ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT DEDENT DEDENT if cnt1 >= 2 : NEW_LINE INDENT print ( cnt1 ) NEW_LINE for i in range ( cnt1 ) : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if self . isPrime [ a [ i ] + a [ j ] ] == 0 : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( a [ i ] , a [ j ] ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE return - 1 NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . sieve ( ) NEW_LINE A = ( 2 , 1 , 1 ) NEW_LINE n = len ( A ) NEW_LINE findsubset ( A , n ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n , self . r , self . t , self . sum , pos = sys . argv [ 1 ] , sys . argv [ 2 ] , sys . argv [ 3 ] , sys . argv [ 4 ] NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT self . n , self . t , self . sum , self . p = self . n , self . r , self . t , self . sum , self . p NEW_LINE self . water = self . water NEW_LINE self . empty = self . empty = { } NEW_LINE for i in range ( self . n ) : NEW_LINE INDENT self . p [ i ] = self . p [ i ] NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT for i in range ( 1 , self . t + 1 ) : NEW_LINE INDENT for j in range ( self . n ) : NEW_LINE INDENT pos = ( self . p [ j ] * i % self . r ) NEW_LINE if i > 1 : NEW_LINE INDENT self . empty [ pos ] += 1 NEW_LINE DEDENT if self . water [ pos ] > 0 : NEW_LINE INDENT self . water [ pos ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . sum += 1 NEW_LINE DEDENT DEDENT for j in range ( self . r ) : NEW_LINE INDENT if self . empty [ j ] > 0 : NEW_LINE INDENT self . water [ j ] += self . empty [ j ] NEW_LINE self . empty [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT print ( self . sum ) NEW_LINE self . exit ( ) NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT self . s = sys . stdin NEW_LINE self . n = len ( self . s ) NEW_LINE self . s . readline ( ) NEW_LINE for j in range ( self . n ) : NEW_LINE INDENT c = self . s . readline ( ) NEW_LINE for i in range ( len ( c ) - 6 ) : NEW_LINE INDENT if c [ i ] == ' H ' and c [ i + 1 ] == ' o ' and c [ i + 2 ] == ' s ' and c [ i + 3 ] == ' h ' and c [ i + 4 ] == ' i ' and c [ i + 5 ] == ' n ' and c [ i + 6 ] == ' o ' : NEW_LINE INDENT c [ i + 6 ] = ' a ' NEW_LINE self . i += 6 NEW_LINE DEDENT DEDENT print ( c . decode ( ' utf - 8' ) ) NEW_LINE DEDENT DEDENT DEDENT
def _count_rotations ( arr , low , high ) : NEW_LINE INDENT import numpy as np NEW_LINE from numpy . linalg import inv NEW_LINE class BinarySearch ( object ) : NEW_LINE INDENT def count_rotations ( self , arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return 0 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return count_rotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return count_rotations ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( count_rotations ( arr , 0 , n - 1 ) ) NEW_LINE DEDENT
def import import sys NEW_LINE class main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . scn = sys . stdin NEW_LINE self . k = sys . stdin . read ( ) NEW_LINE self . i , self . req = 1 , 1 NEW_LINE while self . k - self . req >= 0 : NEW_LINE INDENT if self . k - self . req >= 0 : NEW_LINE INDENT self . k = self . k - self . req NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT self . i += 1 NEW_LINE if self . i % self . n != 0 : NEW_LINE INDENT self . req = self . i % self . n NEW_LINE DEDENT else : NEW_LINE INDENT self . req = self . n NEW_LINE DEDENT DEDENT print ( self . k ) NEW_LINE DEDENT DEDENT
def modular_sum ( arr , n , m ) : NEW_LINE INDENT from scipy . stats import norm NEW_LINE if n > m : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT if DP [ 0 ] : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT if DP [ j ] == True : NEW_LINE INDENT if DP [ ( j + arr [ i ] ) % m ] == False : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if temp [ j ] : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT DEDENT return DP NEW_LINE DEDENT
def import import sys , string , eval , symbols , count , frozenset , symbols , count , O , Dummy , factorial , Dummy , factorial , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy , Dummy
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from math import ceil NEW_LINE from math import sin NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE from math import sin NEW_LINE from math import cos NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE x = int ( sys . stdin . readline ( ) ) NEW_LINE arr = [ ] NEW_LINE totals = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ 0 ] [ i ] = sin ( i ) NEW_LINE totals . append ( arr [ 0 ] [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = min ( arr [ i - 1 ] [ j ] , arr [ i - 1 ] [ ( j - 1 + n ) % n ] ) NEW_LINE totals [ i ] += arr [ i ] [ j ] NEW_LINE DEDENT totals [ i ] += x ** i NEW_LINE DEDENT totals = [ x ** i for i in sorted ( totals ) ] NEW_LINE print ( totals [ 0 ] ) NEW_LINE DEDENT
def import _solve NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . max , self . d , self . w = 0 , 0 , 0 NEW_LINE DEDENT def solve ( self , A , y , x , dep , wid ) : NEW_LINE INDENT while True : NEW_LINE INDENT d , w = self . d , self . w NEW_LINE if d == 0 : break NEW_LINE G = [ ] NEW_LINE self . max = 0 NEW_LINE for i in range ( d ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT G [ i ] [ j ] = int ( self . max ) NEW_LINE DEDENT DEDENT for i in range ( 0 , d - 3 ) : NEW_LINE INDENT for j in range ( 0 , w - 3 ) : NEW_LINE INDENT solve ( G , i , j , 3 , 3 ) NEW_LINE DEDENT DEDENT print ( self . max ) NEW_LINE DEDENT DEDENT def solve ( self , A , y , x , dep , wid ) : NEW_LINE INDENT if y + dep > d or x + wid > w : return NEW_LINE edgmin , lkmax , maxv = 9 , 0 , 0 NEW_LINE for i in range ( y , dep + y ) : NEW_LINE INDENT for j in range ( x , wid + x ) : NEW_LINE INDENT if i == y or i == dep + y - 1 or j == x or j == wid + x - 1 : NEW_LINE INDENT edgmin = min ( edgmin , A [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT lkmax = max ( lkmax , A [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if edgmin > lkmax : NEW_LINE INDENT for i in range ( y + 1 , dep + y - 1 ) : NEW_LINE INDENT for j in range ( x + 1 , x + wid - 1 ) : NEW_LINE INDENT maxv += edgmin - A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT self . max = max ( maxv ) NEW_LINE solve ( self , A , y , x , dep + 1 , wid ) NEW_LINE solve ( self , A , y , x , dep , wid + 1 ) NEW_LINE DEDENT DEDENT
def import _codechef NEW_LINE import os NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE class Codechef ( np . ndarray ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT sc = np . random . RandomState ( 0 ) NEW_LINE n = sc . randint ( 0 , n ) NEW_LINE k = sc . randint ( 0 , n ) NEW_LINE arr = np . array ( [ sc . randint ( 0 , n ) for i in range ( int ( n ) ) ] ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( n ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT ans = np . array ( [ np . sum ( arr , axis = 0 ) for i in range ( int ( n ) ) ] ) NEW_LINE for i in range ( int ( n ) ) : NEW_LINE INDENT if ans [ int ( i ) ] == 0 : NEW_LINE INDENT ktimes = k * arr [ int ( i ) ] NEW_LINE index = np . where ( arr == ktimes ) [ 0 ] NEW_LINE if index >= 0 : NEW_LINE INDENT ans [ int ( index ) ] = - 1 NEW_LINE DEDENT DEDENT DEDENT ans1 = np . sum ( ans , axis = 0 ) NEW_LINE DEDENT DEDENT
def GFG ( k , n ) : NEW_LINE INDENT sum = int ( pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ) NEW_LINE return sum NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT dp = [ [ 0 ] * 18 , [ 2 ] * 162 ] NEW_LINE def solve ( i , tight , sum_so_far , Sum , number , ** kwargs ) : NEW_LINE INDENT if i == len ( dp ) : NEW_LINE INDENT if sum_so_far == Sum : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = dp [ i ] [ 1 ] [ sum_so_far ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = 0 NEW_LINE ntight = False NEW_LINE nsum_so_far = 0 NEW_LINE for currdigit in ( '0' , '9' ) : NEW_LINE INDENT if not tight and currdigit > number [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT ntight = tight or currdigit < number [ i ] NEW_LINE nsum_so_far = sum_so_far + ( currdigit - '0' ) NEW_LINE ans += solve ( i + 1 , ntight , nsum_so_far , Sum , number , ** kwargs ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 4 NEW_LINE number = "100" NEW_LINE for i in range ( 18 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT for k in range ( 162 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = - 1 NEW_LINE DEDENT DEDENT DEDENT print ( solve ( 0 , False , 0 , sum , number , len ( number ) ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def import import sys , string , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function , decision_function
def _import ( ) : NEW_LINE INDENT import Queue NEW_LINE import Queue NEW_LINE class Node : NEW_LINE INDENT data = None NEW_LINE left = right = None NEW_LINE def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = right = None NEW_LINE DEDENT DEDENT class GFG : NEW_LINE INDENT def evenOddLevelDifference ( self , root ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = Queue . Queue ( ) NEW_LINE q . add ( root ) NEW_LINE level = 0 NEW_LINE evenSum , oddSum = 0 , 0 NEW_LINE while len ( q ) != 0 : NEW_LINE INDENT size = len ( q ) NEW_LINE level += 1 NEW_LINE while size > 0 : NEW_LINE INDENT temp = q . pop ( ) NEW_LINE if level % 2 == 0 : NEW_LINE INDENT evenSum += temp . data NEW_LINE DEDENT else : NEW_LINE INDENT oddSum += temp . data NEW_LINE DEDENT if temp . left : NEW_LINE INDENT q . add ( temp . left ) NEW_LINE DEDENT if temp . right : NEW_LINE INDENT q . add ( temp . right ) NEW_LINE DEDENT size -= 1 NEW_LINE DEDENT DEDENT return ( oddSum - evenSum ) NEW_LINE DEDENT DEDENT def main ( args ) : NEW_LINE INDENT root = GFG ( 5 ) NEW_LINE root . left = GFG ( 2 ) NEW_LINE root . right = GFG ( 6 ) NEW_LINE root . left . left = GFG ( 1 ) NEW_LINE root . left . right = GFG ( 4 ) NEW_LINE root . left . right . left = GFG ( 3 ) NEW_LINE root . right . right . right = GFG ( 8 ) NEW_LINE root . right . right . right = GFG ( 9 ) NEW_LINE root . right . right . left = GFG ( 7 ) NEW_LINE print ( " Difference ▁ between ▁ sums ▁ is ▁ " , evenOddLevelDifference ( root ) ) NEW_LINE DEDENT DEDENT
def test_gf_gcd ( ) : NEW_LINE INDENT import os NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , a , n , x ) : NEW_LINE INDENT self . count = 0 NEW_LINE self . number = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT self . count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . number += ( self . count ) * ( self . count + 1 ) / 2 NEW_LINE self . count = 0 NEW_LINE DEDENT DEDENT if self . count != 0 : NEW_LINE INDENT self . number += ( self . count ) * ( self . count + 1 ) / 2 NEW_LINE DEDENT return self . number NEW_LINE DEDENT DEDENT a = [ 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 ] NEW_LINE n = len ( a ) NEW_LINE k = 5 NEW_LINE print ( gf_gcd ( a , n , k ) ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT
def import _pylab NEW_LINE class GFG ( object ) : NEW_LINE INDENT def print_last_occurrence ( self , n ) : NEW_LINE INDENT d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if d [ a [ i ] ] == i : NEW_LINE INDENT print ( a [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT def main ( self ) : NEW_LINE INDENT a = [ 1 , 5 , 5 , 1 , 6 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print_last_occurrence ( a , n ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from itertools import repeat NEW_LINE for n in range ( sys . stdin . tell ( ) ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT up1 , up2 = 0 , 0 NEW_LINE k = repeat ( n ) NEW_LINE if k : NEW_LINE INDENT up1 += 1 NEW_LINE if k [ 0 ] >= 2 : NEW_LINE INDENT up2 += 1 NEW_LINE DEDENT DEDENT if up2 == 0 : NEW_LINE INDENT print ( ' NA ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( up1 + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def _import ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE class GFG ( object ) : NEW_LINE INDENT def count_paths ( self , m , n ) : NEW_LINE INDENT if m == 1 or n == 1 : return 1 NEW_LINE return self . count_paths ( m - 1 , n ) + self . count_paths ( m , n - 1 ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT g = GFG ( ) NEW_LINE n , m = 5 , 5 NEW_LINE print ( g . count_paths ( n , m ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def GFG ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT
def count_pairs ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE class solution : NEW_LINE INDENT def count_pairs ( self , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT DEDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( count_pairs ( arr , n ) ) NEW_LINE DEDENT
def coordinateCompression ( arr , n ) : NEW_LINE INDENT import numpy as np NEW_LINE from numpy . testing import assert_array_equal NEW_LINE s = np . unique ( arr ) NEW_LINE index = 0 NEW_LINE mp = { } NEW_LINE for itr in s : NEW_LINE INDENT index += 1 NEW_LINE mp [ itr ] = index NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = mp [ arr [ i ] ] NEW_LINE DEDENT def query ( BIT , index , n ) : NEW_LINE INDENT ans = 0 NEW_LINE while index > 0 : NEW_LINE INDENT ans = max ( ans , BIT [ index ] ) NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def update ( BIT , index , n ) : NEW_LINE INDENT x , value = query ( BIT , index - 1 , n ) NEW_LINE while index <= n : NEW_LINE INDENT BIT [ index ] = max ( BIT [ index ] , value ) NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def findLISLength ( arr , n ) : NEW_LINE INDENT coordinateCompression ( arr , n ) NEW_LINE BIT = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT update ( BIT , arr [ i ] , n ) NEW_LINE DEDENT ans = query ( BIT , n , n ) NEW_LINE return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 6 , 5 , 1 , 3 , 2 , 4 , 8 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE ans = findLISLength ( arr , n ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
def import sys , os , sys , string , count , group , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_names , group_
def import _symbol NEW_LINE class p164 ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT print ( super ( p164 , self ) . __init__ ( ) ) NEW_LINE DEDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CONSECUTIVE = 3 NEW_LINE MAX_SUM = 9 NEW_LINE def run ( self ) : NEW_LINE INDENT ways = [ [ 1 ] * ( DIGITS + CONSECUTIVE + 1 ) + [ lib . pow ( BASE , CONSECUTIVE ) ] for prefix in self . ways [ 1 : ] ] NEW_LINE for digits in range ( 1 , len ( ways ) ) : NEW_LINE INDENT for prefix in ways [ digits ] : NEW_LINE INDENT sum = 0 NEW_LINE if self . digitSum ( prefix ) <= MAX_SUM : NEW_LINE INDENT for next_digit in range ( BASE ) : NEW_LINE INDENT sum = sum + ways [ digits - 1 ] [ prefix % lib . pow ( BASE , CONSECUTIVE - 1 ) * BASE + next_digit ] NEW_LINE DEDENT DEDENT self . ways [ digits ] [ prefix ] = sum NEW_LINE DEDENT DEDENT return ways [ DIGITS + CONSECUTIVE ] [ 0 ] - ways [ DIGITS + CONSECUTIVE - 1 ] [ 0 ] NEW_LINE DEDENT def digitSum ( self ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 10 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT return p164 NEW_LINE DEDENT
def import import sys , string , traceback , StringIO , StringIO , unicode , string , unicode , string , unicode , list , unicode , string , unicode , , text_format , text , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format , text_format
def Solution ( matrix ) : NEW_LINE INDENT class Solution ( object ) : NEW_LINE INDENT def isToeplitzMatrix ( self , matrix ) : NEW_LINE INDENT for r in range ( 1 , len ( matrix ) ) : NEW_LINE INDENT for c in range ( 1 , len ( matrix [ 0 ] ) ) : NEW_LINE INDENT if matrix [ r - 1 ] [ c - 1 ] != matrix [ r ] [ c ] : return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT sObj = Solution ( ) NEW_LINE matrix = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 1 , 2 , 3 ] , [ 9 , 5 , 1 , 2 ] ] NEW_LINE out = sObj . isToeplitzMatrix ( matrix ) NEW_LINE print ( out ) NEW_LINE DEDENT
def p094 ( ) : NEW_LINE INDENT print ( eval ( " p094" ) ) NEW_LINE LIMIT = library . pow ( 10 , 9 ) NEW_LINE def run ( ) : NEW_LINE INDENT sum = 0 NEW_LINE for s in range ( 1 , s ** 2 + 1 , ( LIMIT + 1 ) / 3 , 2 ) : NEW_LINE INDENT for t in range ( s - 2 , 0 , - 2 ) : NEW_LINE INDENT if library . gcd ( s , t ) == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s ** 2 - t ** 2 ) / 2 NEW_LINE c = ( s ** 2 + t ** 2 ) / 2 NEW_LINE if a * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : sum += p NEW_LINE DEDENT if a * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : sum += p NEW_LINE DEDENT if b * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : sum += p NEW_LINE DEDENT if b * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : sum += p NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def solve ( self ) : NEW_LINE INDENT with open ( " / proc / sys / exit . txt " , " r " ) as sc : NEW_LINE INDENT while True : NEW_LINE INDENT N , T , L , B = [ int ( i ) for i in range ( L ) ] NEW_LINE if N == 0 and T == 0 and L == 0 and B == 0 : break NEW_LINE square = [ 1 for i in range ( L ) ] NEW_LINE for i in range ( B ) : NEW_LINE INDENT square [ i ] = 2 NEW_LINE DEDENT dp = [ [ 1 for i in range ( N + 1 ) ] for j in range ( T + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for j in range ( T ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for s in range ( 1 , 6 ) : NEW_LINE INDENT idx = 1 NEW_LINE num = i + s NEW_LINE if square [ i ] == 1 : idx = 2 NEW_LINE if i + s > N : num = 2 * N - ( i + s ) NEW_LINE if square [ num ] == 2 and j + idx <= T : NEW_LINE INDENT dp [ 0 ] [ j + idx ] += dp [ i ] [ j ] * 1.0 / 6 NEW_LINE DEDENT elif j + idx <= T : NEW_LINE INDENT dp [ num ] [ j + idx ] += dp [ i ] [ j ] * 1.0 / 6 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT goal = 0.0 NEW_LINE for i in range ( 0 , T ) : NEW_LINE INDENT goal += dp [ N ] [ i ] NEW_LINE DEDENT print ( " % .6f \n " % goal ) NEW_LINE DEDENT DEDENT DEDENT
def import import sys NEW_LINE class oddsum ( object ) : NEW_LINE INDENT def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT self . stream = sys . stdin NEW_LINE self . t = sys . maxint NEW_LINE while self . t : NEW_LINE INDENT self . s = self . o = self . e = self . a = self . a = self . a = self . a = self . a = self . a = self . a = self . a = self . a ) NEW_LINE self . s += self . s NEW_LINE if self . s % 2 : NEW_LINE INDENT self . o += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . e += 1 NEW_LINE DEDENT if self . s % 2 : NEW_LINE INDENT self . s = self . s NEW_LINE DEDENT else : NEW_LINE INDENT if self . o >= 1 and self . e >= 1 : NEW_LINE INDENT self . s = self . s NEW_LINE DEDENT else : NEW_LINE INDENT self . s = self . s NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def GFG ( H , n , K ) : NEW_LINE INDENT inser = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) NEW_LINE if diff <= K : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff / K ) - 1 NEW_LINE DEDENT DEDENT return inser NEW_LINE DEDENT
def GFG ( str , len ) : NEW_LINE INDENT count = 1 NEW_LINE if len == 1 : return count NEW_LINE if str [ 0 ] == str [ 1 ] : count *= 1 NEW_LINE else : count *= 2 NEW_LINE for j in range ( 1 , len - 1 ) : NEW_LINE INDENT if str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] : count *= 1 NEW_LINE elif str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] : count *= 2 NEW_LINE else : count *= 3 NEW_LINE DEDENT if str [ len - 1 ] == str [ len - 2 ] : count *= 1 NEW_LINE else : count *= 2 NEW_LINE return count NEW_LINE DEDENT
def import import os , sys , stdin , stdout , stderr , line , input , input , input , input , input , input , input , input , input , input , input , input , input , input , input , output , input , input , input , input , input , input , input , input , input , output , input , input , input , input , input , input , input , input , output , input , input , input , input , input , input , input , output , input , input , input , input , input , output , input , input , input , input , input , output , input , input , input , input , input , input , output , input , input , input , input , input , input , output , input , input , input , input , input , input , output , input , input , input , input , input , output , input , input , input , input , input , output , input , input , input , input , input , output , input , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , output , input , input , input , output , input , input , output , input , input , output , input , input , output , input , input , input , output , input , input , output , input , input , output , input , input , output , input , input , output , input , output , input , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , input , output , output , input , output , input , output , output , input , output , input , output , input , output , output , input , output , input , output , output , output , input , output , output , input , output , output , input , output , output , input , output , output , output , output , input , output , output , output , input , output , output , output , output , output , output , output , input , output , output , output , output , output , output , output , output , output , output , output , output , output , output , output , output
def import _GFG NEW_LINE class GFG ( object ) : NEW_LINE INDENT def get_perfect_squares ( self , n ) : NEW_LINE INDENT perfect_squares = [ ] NEW_LINE current , i = 1 , int ( math . pow ( 1 , n ) ) NEW_LINE while current <= n : NEW_LINE INDENT perfect_squares . append ( current ) NEW_LINE current = int ( math . pow ( 1 , n ) ) NEW_LINE DEDENT return perfect_squares NEW_LINE DEDENT def max_pair_sum ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if arr [ 0 ] > arr [ 1 ] : NEW_LINE INDENT max , second_max = arr [ 0 ] , arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT max , second_max = arr [ 1 ] , arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT second_max , max = max , arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second_max : NEW_LINE INDENT second_max = arr [ i ] NEW_LINE DEDENT DEDENT return ( max + second_max ) NEW_LINE DEDENT def count_pairs_with ( self , n , perfect_squares , nums ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( perfect_squares ) ) : NEW_LINE INDENT temp = perfect_squares [ i ] - n NEW_LINE if temp > n and temp in nums : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def count_pairs ( self , arr ) : NEW_LINE INDENT i , n = len ( arr ) NEW_LINE max = max_pair_sum ( arr ) NEW_LINE perfect_squares = get_perfect_squares ( max ) NEW_LINE nums = set ( arr ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count += count_pairs_with ( self , perfect_squares , nums ) NEW_LINE DEDENT return count NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 2 , 3 , 6 , 9 , 10 , 20 ] NEW_LINE print ( count_pairs ( self , arr ) ) NEW_LINE DEDENT DEDENT
def GFG ( side1 , side2 ) : NEW_LINE INDENT h = math . sqrt ( ( side1 ** 2 ) + ( side2 ** 2 ) ) NEW_LINE return h NEW_LINE DEDENT
def print_two_odd ( arr , size ) : NEW_LINE INDENT import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . xor2 = arr [ 0 ] NEW_LINE self . set_bit_no = 0 NEW_LINE DEDENT def __call__ ( self , * args ) : NEW_LINE INDENT n = size - 2 NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT self . xor2 = self . xor2 ^ self . xor2 NEW_LINE DEDENT self . set_bit_no = self . xor2 & ~ ( self . xor2 - 1 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if self . xor2 & self . set_bit_no : NEW_LINE INDENT x = self . xor2 ^ self . xor2 NEW_LINE DEDENT else : NEW_LINE INDENT y = self . xor2 ^ self . xor2 NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ ODD ▁ elements ▁ are ▁ { } ▁ & ▁ { } " . format ( x , y ) ) NEW_LINE DEDENT DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE print_two_odd ( arr , arr_size ) NEW_LINE DEDENT DEDENT
def import sys NEW_LINE class StroneGame ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . game = StroneGame ( ) NEW_LINE DEDENT t = sys . argv [ 1 ] NEW_LINE while t > 0 : NEW_LINE INDENT n = len ( sys . argv ) NEW_LINE ar = [ ] NEW_LINE max = 0 NEW_LINE min = 100000 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ar . append ( sys . argv [ i ] ) NEW_LINE if ar [ i ] < min : NEW_LINE INDENT min = ar [ i ] NEW_LINE x = i + 1 NEW_LINE DEDENT if ar [ i ] > max : NEW_LINE INDENT max = ar [ i ] NEW_LINE y = i + 1 NEW_LINE DEDENT DEDENT pos1 , pos2 , pos3 , pos4 = 1 , 1 , 1 , a , b , mm , total = 0 NEW_LINE pos1 = x NEW_LINE pos2 += n - x NEW_LINE if pos1 < pos2 : NEW_LINE INDENT a = pos1 NEW_LINE DEDENT else : NEW_LINE INDENT a = pos2 NEW_LINE DEDENT pos3 = y NEW_LINE pos4 += n - y NEW_LINE if pos3 < pos4 : NEW_LINE INDENT b = pos3 NEW_LINE DEDENT else : NEW_LINE INDENT b = pos4 NEW_LINE DEDENT div = abs ( y - x ) NEW_LINE if div < a or div < b : NEW_LINE INDENT mm = min ( a , b ) NEW_LINE total += mm + div NEW_LINE DEDENT else : NEW_LINE INDENT total += a + b NEW_LINE DEDENT print ( total ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT
def import import sys , string , time NEW_LINE from os import urandom NEW_LINE from os import urandom NEW_LINE from io import StringIO NEW_LINE from os . path import join NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . posixemulation import call NEW_LINE from os . posixemulation import getfilesystemencoding ( ) NEW_LINE from os . posixemulation import getfilesystemencoding ( ) NEW_LINE from os . posixemulation import getfilesystemencoding ( ) NEW_LINE from os . path import join NEW_LINE sys . path = join ( expanduser ( ' ~ ' ) , ' . . ' , ' . . ' , ' . . ' ) NEW_LINE sys . path . insert ( 0 , join ( expanduser ( ' ~ ' ) , ' ~ ' ) ) NEW_LINE sys . path . insert ( 0 , join ( expanduser ( ' ~ ' ) , ' ~ ' ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE from os import path NEW_LINE from os import listdir NEW_LINE from os import getcwd NEW_LINE from os . path import join NEW_LINE from os . path import expanduser NEW_LINE from os . path import join NEW_LINE from os . path import join NEW_LINE n = len ( open ( join ( getcwd ( ) , ' . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . . / . . / . / . . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . . / . / . / . . / . / . / . . / . / . / . . / . / . / . . / . / . / . / . . / . / . / . / . / . . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . . / . / . / . / . / . / '
def GFG ( ) : NEW_LINE INDENT class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( head ) : NEW_LINE INDENT if not head : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE while True : NEW_LINE INDENT print ( temp . data , " - > " , end = " " ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT def deleteK ( head_ref , k ) : NEW_LINE INDENT head = head_ref NEW_LINE if not head : NEW_LINE INDENT return None NEW_LINE DEDENT curr , prev = head , None NEW_LINE while True : NEW_LINE INDENT if curr . next == head and curr == head : NEW_LINE INDENT break NEW_LINE DEDENT printList ( head ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE DEDENT if curr == head : NEW_LINE INDENT prev = head NEW_LINE while prev . next != head : NEW_LINE INDENT prev = prev . next NEW_LINE DEDENT head = curr . next NEW_LINE prev . next = head NEW_LINE head_ref = head NEW_LINE DEDENT elif curr . next == head : NEW_LINE INDENT prev . next = head NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = curr . next NEW_LINE DEDENT DEDENT return head NEW_LINE DEDENT def insertNode ( head_ref , x ) : NEW_LINE INDENT head = head_ref NEW_LINE temp = GFG ( x ) NEW_LINE if not head : NEW_LINE INDENT temp . next = temp NEW_LINE head_ref = temp NEW_LINE return head_ref NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = head NEW_LINE while temp1 . next != head : NEW_LINE INDENT temp1 = temp1 . next NEW_LINE DEDENT temp1 . next = temp NEW_LINE temp . next = head NEW_LINE DEDENT return head NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT head = None NEW_LINE head = insertNode ( head , 1 ) NEW_LINE head = insertNode ( head , 2 ) NEW_LINE head = insertNode ( head , 3 ) NEW_LINE head = insertNode ( head , 4 ) NEW_LINE head = insertNode ( head , 5 ) NEW_LINE head = insertNode ( head , 6 ) NEW_LINE head = insertNode ( head , 7 ) NEW_LINE head = insertNode ( head , 8 ) NEW_LINE head = insertNode ( head , 9 ) NEW_LINE k = 4 NEW_LINE head = deleteK ( head , k ) NEW_LINE DEDENT DEDENT
def GFG ( cur , x , n ) : NEW_LINE INDENT if x == 0 : return sys . maxint NEW_LINE if x > 0 : return abs ( ( n - cur ) / x ) NEW_LINE else : return abs ( ( cur - 1 ) / x ) NEW_LINE def count_steps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for x , y in moves : NEW_LINE INDENT stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , m , x , y = 4 , 5 , 1 , 1 NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] NEW_LINE print ( count_steps ( x , y , n , m , moves ) , end = ' ▁ ' ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def import import os , sys , getopt , args , trace , line , error , message , line , flags , min , max , line , text , lineno , enter , state , filename , line , flags , min , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , error , filename , line , selectionbreak , error , filename , line , selectionbreak , error , error , filename , line , selectionbreak , error , line , selectionbreak , error , line , selectionbreak , error , line , selectionbreak , error , line , selectionbreak , error , line , line , selectionbreak , line , line , selectionbreak , error , line , line , selectionbreak , line , line , selectionbreak , error , line , line , selectionbreak , error , line , line , selectionbreak , line , line , selectionbreak , line , line , selectionbreak , line , line , selectionbreak , error , line , line , line , selectionbreak , line , line , line , line
def gf_gcd ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_gcd = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_gcd = __gcd ( curr_gcd , arr [ j ] ) NEW_LINE ans += ( curr_gcd == 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE def __gcd ( a , b ) : NEW_LINE INDENT if b == 0 : return a NEW_LINE return __gcd ( b , a % b ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( __gcd ( arr , n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def isVowel ( char ) : NEW_LINE INDENT import random NEW_LINE if char in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT def isVowelPrime ( data , n ) : NEW_LINE INDENT prime = random . choice ( [ True , False ] ) NEW_LINE for p in range ( 2 , n ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if isVowel ( data [ i ] ) and not prime [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT data = ' geeksforgeeks ' NEW_LINE n = len ( data ) NEW_LINE if isVowelPrime ( data , n ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def GFG ( data ) : NEW_LINE INDENT N = len ( data ) NEW_LINE dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( 0 , N + 1 ) ] NEW_LINE for len in range ( 1 , N + 1 ) : NEW_LINE INDENT for i , j in range ( 0 , len - 1 ) : NEW_LINE INDENT if len == 1 : dp [ i ] [ j ] = 1 NEW_LINE else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if data [ i ] == data [ i + 1 ] : dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE for K in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if data [ i ] == data [ K ] : dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT limit = 10000000 NEW_LINE position = [ - 1 ] * ( limit + 1 ) NEW_LINE def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if position [ i ] == 0 : NEW_LINE INDENT position [ i ] = pos NEW_LINE pos += 1 NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT sieve ( ) NEW_LINE n = 11 NEW_LINE print ( position [ n ] , end = ' ▁ ' ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT DP_s = 9 NEW_LINE def getNumMonotone ( shape ) : NEW_LINE INDENT DP = [ [ i + 1 for i in range ( DP_s ) ] for i in range ( DP_s ) ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , len ( DP ) ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ len ( DP ) - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT print ( getNumMonotone ( 10 ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT DP_s = 9 NEW_LINE def getNumMonotone ( shape ) : NEW_LINE INDENT DP = [ [ i + 1 for i in range ( DP_s ) ] for i in range ( DP_s ) ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , len ( DP ) ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ len ( DP ) - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT print ( getNumMonotone ( 10 ) ) NEW_LINE DEDENT return GFG ( ) NEW_LINE DEDENT
def GFG ( a , n , l , r ) : NEW_LINE INDENT mx , k = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 for i in range ( mx + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * mx + 1 NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT
def test_B1680 ( ) : NEW_LINE INDENT import sys NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 NEW_LINE from B1680 import B1680 , B1680 NEW_LINE from B1680 import B1680 , B1680 NEW_LINE from B1680 import B1680 , B1680 NEW_LINE DEDENT
def test ( r ) : NEW_LINE INDENT PI = math . pi NEW_LINE def findArea ( r ) : NEW_LINE INDENT return PI * math . pow ( r , 2 ) NEW_LINE DEDENT return findArea ( 5 ) NEW_LINE DEDENT
def import _sys , DmwS NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE class DmwS ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . _sys = sys . stdin NEW_LINE self . _sys = sys . __stdin__ NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sc = open ( " / proc / dmwS . txt " , " r " ) NEW_LINE self . N = sc . readline ( ) . strip ( ) NEW_LINE self . K = sc . readline ( ) . strip ( ) NEW_LINE self . adj = [ list ( ) for i in range ( self . N ) ] NEW_LINE self . unis = [ 0 ] * ( 2 * K ) NEW_LINE self . unis [ town ] += 1 NEW_LINE for i in range ( self . N - 1 ) : NEW_LINE INDENT x = sc . readline ( ) . strip ( ) NEW_LINE y = sc . readline ( ) . strip ( ) NEW_LINE self . adj [ x ] . append ( y ) NEW_LINE self . adj [ y ] . append ( x ) NEW_LINE DEDENT self . below = [ ] NEW_LINE self . vis = [ False ] NEW_LINE self . dfs ( 0 ) NEW_LINE print ( self . result ) NEW_LINE DEDENT def dfs ( self , node ) : NEW_LINE INDENT self . vis [ node ] = True NEW_LINE self . below [ node ] = self . unis [ node ] NEW_LINE for adj in self . adj [ node ] : NEW_LINE INDENT if self . vis [ adj ] : NEW_LINE INDENT continue NEW_LINE DEDENT self . dfs ( adj ) NEW_LINE self . below [ node ] += self . below [ adj ] NEW_LINE self . result += min ( self . below [ adj ] , 2 * K - self . below [ adj ] ) NEW_LINE DEDENT DEDENT DEDENT
def nthTerm ( N ) : NEW_LINE INDENT import math NEW_LINE import numpy NEW_LINE class GFG ( object ) : NEW_LINE INDENT def nthTerm ( self ) : NEW_LINE INDENT return abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT DEDENT return GFG ( ) NEW_LINE DEDENT
def _ _ init _ _ ( X ) : return ( 2 * X ) NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . X = 35 NEW_LINE print ( self . get_height ( ) ) NEW_LINE DEDENT DEDENT
def _import_countwalks ( graph , u , v , k ) : NEW_LINE INDENT import networkx as nx NEW_LINE import networkx as nx NEW_LINE class KPaths ( nx . DiGraph ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT nx . DiGraph . __init__ ( self ) NEW_LINE self . V = 4 NEW_LINE DEDENT def countwalks ( self , graph , u , v , k ) : NEW_LINE INDENT if k == 0 and u == v : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k == 1 and graph [ u ] [ v ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT if graph [ u ] [ i ] == 1 : NEW_LINE INDENT count += self . countwalks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT DEDENT graph = nx . DiGraph ( ) NEW_LINE u , v , k = 0 , 3 , 2 NEW_LINE p = KPaths ( ) NEW_LINE print ( p . countwalks ( graph , u , v , k ) ) NEW_LINE DEDENT
def find_digits ( n , b ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE x = ( ( n * math . log10 ( n / M_E ) + math . log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( math . log10 ( b ) ) NEW_LINE return long ( math . floor ( x ) + 1 ) NEW_LINE DEDENT
def import import sys NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = sys . stdin . read ( ) NEW_LINE self . q = sys . stdin . read ( ) NEW_LINE self . init ( n ) NEW_LINE for i in range ( self . q ) : NEW_LINE INDENT if self . q == 0 : NEW_LINE INDENT self . add ( self . q , self . q ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( self . sum ( self . q , self . q ) ) NEW_LINE DEDENT DEDENT DEDENT def __init__ ( self ) : NEW_LINE INDENT self . size = 1 NEW_LINE while self . size < self . n : NEW_LINE INDENT self . size *= 2 NEW_LINE DEDENT self . nodes = [ self . n ] NEW_LINE DEDENT def add ( self , target , value ) : NEW_LINE INDENT while self . target < self . nodes : NEW_LINE INDENT self . nodes [ self . target ] += value NEW_LINE self . target += target & ( - self . target ) NEW_LINE DEDENT DEDENT def sum ( self , s , t ) : NEW_LINE INDENT return sum ( t ) - sum ( s - 1 ) NEW_LINE DEDENT def sum ( self , s , t ) : NEW_LINE INDENT res = 0 NEW_LINE while t > 0 : NEW_LINE INDENT res += self . nodes [ t ] NEW_LINE t -= self . q & ( - self . q ) NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT
def import import sys NEW_LINE import struct NEW_LINE class Main ( struct . Struct ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT struct . Struct . __init__ ( self ) NEW_LINE self . buf = sys . stdin . read ( ) NEW_LINE self . input = sys . stdin . read ( ) NEW_LINE self . N = struct . Struct . unpack ( self . buf ) NEW_LINE self . print ( self . solve ( self . N ) ) NEW_LINE DEDENT def solve ( self , n ) : NEW_LINE INDENT if n == 0 : return 1 NEW_LINE if n == 1 : return 2 NEW_LINE if self . n / 2 in self . check : NEW_LINE INDENT a = self . check [ self . n / 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT a = self . solve ( self . n / 2 ) % 1000000007 NEW_LINE self . check [ self . n / 2 ] = a NEW_LINE DEDENT if self . n / 2 - 1 in self . check : NEW_LINE INDENT b = self . check [ self . n / 2 - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT b = self . solve ( self . n / 2 - 1 ) % 1000000007 NEW_LINE self . check [ self . n / 2 - 1 ] = b NEW_LINE DEDENT if self . n % 2 == 1 : NEW_LINE INDENT return ( 2 * a + b ) % 1000000007 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * b + a ) % 1000000007 NEW_LINE DEDENT DEDENT DEDENT
def import _main NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . numerator = 0 NEW_LINE self . denominator = 0 NEW_LINE self . maxproduct = 0 NEW_LINE self . parts = 0 NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . parts = 0 NEW_LINE while True : NEW_LINE INDENT self . numerator = _main . raw_input ( ) NEW_LINE self . denominator = _main . raw_input ( ) NEW_LINE self . maxproduct = _main . raw_input ( ) NEW_LINE self . parts = _main . raw_input ( ) NEW_LINE if not self . parts : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE count += _Judge ( self . numerator , self . denominator , self . parts , 1 , 0 ) NEW_LINE print ( count ) NEW_LINE DEDENT DEDENT def Judge ( p , q , separate , now_pro , prev_deno ) : NEW_LINE INDENT count = 0 NEW_LINE if p == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if separate <= 0 : NEW_LINE INDENT return count NEW_LINE DEDENT deno = maxproduct // now_pro + 1 NEW_LINE while separate * q < p * deno : NEW_LINE INDENT deno -= 1 NEW_LINE DEDENT while p * deno >= q and prev_deno <= deno : NEW_LINE INDENT subtraction_deno = q * deno NEW_LINE subtraction_nume = p * deno - q NEW_LINE if now_pro * deno <= maxproduct : NEW_LINE INDENT count += _Judge ( subtraction_nume , subtraction_deno , separate - 1 , now_pro * deno , deno ) NEW_LINE DEDENT deno -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT
def _ import _ , os , sys , re , r , c , d , e , r , m , n , i , i , m , n , i , i , n , i , i , n , i , i , n , i , i , n , i , i , n , i , i , n , i , i , n , i , i , n , i , i , n , i , i , n , i , i , n , i , i , n , i , i , n , i , i , n , i , n , i , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , i , n , n , i , n , i , n , i , n , i , n , n , i , n , i , n , i , n , n , i , n , i , n , i , n , i , n , n , i , n , i , n
def count_subsets ( arr , n ) : NEW_LINE INDENT import math NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . us = set ( ) NEW_LINE self . even_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if self . arr [ i ] % 2 == 0 : us . add ( self . arr [ i ] ) NEW_LINE DEDENT self . even_count = len ( us ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT arr = [ 4 , 2 , 1 , 9 , 2 , 6 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Number ▁ of ▁ subsets ▁ = ▁ { } " . format ( self . count_subsets ( arr , n ) ) ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def import _fib NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . MAX = 1000 NEW_LINE self . f = [ ] NEW_LINE DEDENT def fib ( self , n ) : NEW_LINE INDENT if n == 0 : return 0 NEW_LINE if n in ( 1 , 2 ) : return ( self . f [ n ] , 1 ) NEW_LINE if self . f [ n ] : return self . f [ n ] NEW_LINE k = 0 NEW_LINE if self . n & 1 : k = ( self . n + 1 ) / 2 NEW_LINE else : k = self . n / 2 NEW_LINE if self . n & 1 : f . append ( ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ) NEW_LINE else : f . append ( ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ) NEW_LINE return self . f [ n ] NEW_LINE DEDENT def gcd ( self , a , b ) : NEW_LINE INDENT if a == 0 : return b NEW_LINE return gcd ( b % a , a ) NEW_LINE DEDENT def find_lcmfibonacci ( self , a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( a , b ) ) NEW_LINE DEDENT def main ( self , args ) : NEW_LINE INDENT a , b = 3 , 12 NEW_LINE print ( find_lcmfibonacci ( a , b ) ) NEW_LINE DEDENT DEDENT
def GFG ( n , w ) : NEW_LINE INDENT x , sum = 0 , 0 NEW_LINE if w in range ( 0 , 8 ) : NEW_LINE INDENT x = 9 - w NEW_LINE DEDENT elif w in range ( - 9 , - 1 ) : NEW_LINE INDENT x = 10 + w NEW_LINE DEDENT sum = int ( pow ( 10 , n - 2 ) ) NEW_LINE sum = ( x * sum ) NEW_LINE return sum NEW_LINE DEDENT
def __find_kth_char ( s , k ) : NEW_LINE INDENT import string NEW_LINE s = string . join ( s , ' ' ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if s [ i ] . isalpha ( ) : NEW_LINE INDENT total_len += 1 NEW_LINE if total_len == k : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while i < len ( s ) and not s [ i ] . isalpha ( ) : NEW_LINE INDENT n = n * 10 + ord ( s [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if k <= next_total_len : NEW_LINE INDENT pos = k % total_len NEW_LINE if pos == 0 : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return __find_kth_char ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT DEDENT return ' ▁ ' NEW_LINE DEDENT
def test_gf_gn_nonzero_substr_repr ( ) : NEW_LINE INDENT import string NEW_LINE class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT self . n = len ( string . ascii_letters ) NEW_LINE self . n = len ( string . ascii_letters ) NEW_LINE DEDENT def __getitem__ ( self , i ) : NEW_LINE INDENT return self . n * ( i + 1 ) // 2 NEW_LINE DEDENT def __setitem__ ( self , i , j ) : NEW_LINE INDENT self . n = j NEW_LINE DEDENT def __getitem__ ( self , i ) : NEW_LINE INDENT return self . n * ( i + 1 ) // 2 NEW_LINE DEDENT def __getitem__ ( self , i ) : NEW_LINE INDENT return self . n * ( i + 1 ) // 2 NEW_LINE DEDENT def __getitem__ ( self , i ) : NEW_LINE INDENT return self . n * ( i + 1 ) // 2 NEW_LINE DEDENT def __getitem__ ( self , i ) : NEW_LINE INDENT return self . n * ( i + 1 ) // 2 NEW_LINE DEDENT def __getitem__ ( self , i ) : NEW_LINE INDENT return self . n * ( i + 1 ) // 2 NEW_LINE DEDENT def __getitem__ ( self , i ) : NEW_LINE INDENT return self . n * ( i + 1 ) // 2 NEW_LINE DEDENT def __getitem__ ( self , i )
