public static boolean [ ] sieveOfErastosthenes ( int num ) { final boolean [ ] inputArray = new boolean [ num ] ; for ( int i = 0 ; i < inputArray . length ; i ++ ) { inputArray [ i ] = i % 2 == 0 || i % 3 == 0 || i % 5 == 0 ? false : true ; } inputArray [ 0 ] = inputArray [ 1 ] = false ; inputArray [ 2 ] = inputArray [ 3 ] = inputArray [ 5 ] = true ; final double sqrt = Math . sqrt ( num ) ; for ( int serial = 3 ; serial < num ; serial += 2 ) { if ( serial >= sqrt ) { return inputArray ; } for ( int s = serial * serial ; s < num ; s += serial ) { inputArray [ s ] = false ; } } return inputArray ; }
public static String findOddAndRemoveItsFreq ( String str1 ) { int len1 = str1 . length ( ) ; int [ ] freq = new int [ MAX_CHAR ] ; countFreq ( str1 , freq , len1 ) ; if ( ( freq [ 0 ] != 0 ) && ( freq [ 1 ] != 0 ) && ( freq [ 2 ] != 0 ) && ( freq [ 3 ] != 0 ) && ( freq [ 4 ] != 0 ) && ( freq [ 5 ] != 0 ) && ( freq [ 6 ] != 0 ) && ( freq [ 7 ] != 0 ) && ( freq [ 8 ] != 0 ) && ( freq [ 9 ] != 0 ) && ( freq [ 10 ] != 0 ) && ( freq [ 11 ] != 0 ) && ( freq [ 12 ] != 0 ) && ( freq [ 13 ] != 0 ) && ( freq [ 14 ] != 0 ) && ( freq [ 15 ] != 0 ) && ( freq [ 16 ] != 0 ) && ( freq [ 17 ] != 0 ) && ( freq [ 18 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) && ( freq [ 19 ] != 0 ) ; return str1
public static double cross ( double a , double b ) { return a * b ; }
public static int count9s ( String number ) { int n = number . length ( ) ; int [ ] d = new int [ 9 ] ; for ( int i = 0 ; i < n ; i ++ ) { d [ i ] = 0 ; } d [ 0 ] = 1 ; int result = 0 ; int modSum = 0 ; int continuousZero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( int ) number . charAt ( i ) - '0' ) == 0 ) { continuousZero ++ ; } else { continuousZero = 0 ; } modSum += ( int ) number . charAt ( i ) - '0' ; modSum %= 9 ; result += d [ modSum ] ; d [ modSum ] ++ ; result -= continuousZero ; } return result ; }
public static int fastPow ( int N , int K ) { if ( ( K == 0 ) ) { return 1 ; } int temp = fastPow ( N , ( int ) ( K / 2 ) ) ; if ( ( K % 2 ) == 0 ) { return temp * temp ; } else { return N * temp * temp ; } }
public static int [ ] NUM ( int [ ] num ) { int n = 0 ; while ( true ) { n = Integer . parseInt ( input [ 0 ] ) ; if ( n == - 1 ) break ; int current = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int num = num [ i ] ; System . out . println ( format ( current ^ num , " b " ) . toString ( ) ) ; current = num ; } } }
public static boolean isEuclid ( int n ) { int [ ] arr = new int [ MAX ] ; int p ; if ( Thread . currentThread ( ) . isInterrupted ( ) ) { System . out . println ( " Interrupted ▁ for ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " " + " ▁ " + " ▁ " " + " ▁ " + " ▁ " " + " ▁ " + " ▁ " " + " ▁ " + " ▁ " " + " ▁ " + " ▁ " + " ▁ " " + " ▁ " + " ▁ " + " ▁ " " + " ▁ " + " ▁ " + " ▁ " " + " ▁ " + " ▁ " " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " + " ▁ " +
public static int getprime ( int n ) { int MAX = 100000 ; boolean [ ] prime = new boolean [ MAX ] ; int [ ] arr = new int [ MAX ] ; { for ( int p = 2 ; p <= ( int ) Math . sqrt ( MAX ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { arr [ p ] = p ; } } } { if ( ! prime [ n ] ) { return false ; } int product = 1 , i = 0 ; while ( product < n ) { product *= arr [ i ] ; if ( product + 1 == n || product - 1 == n ) { return true ; } i ++ ; } return false ; } if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } if ( n == 4 ) { return 4 ; } if ( n == 5 ) { return 5 ; } if ( n == 6 ) { return 6 ; } if ( n == 7 ) { return 7 ; } if ( n == 8 ) { return 8 ; } if ( n == 9 ) { return 9 ; } if ( n == 10 ) { return 11 ; } if ( n == 11 ) { return 12 ; } if ( n == 13 ) { return 13 ; } if ( n == 14 ) { return 13 ; } if ( n == 15 ) { return 13 ; } if ( n == 15 ) { return 13 ; } if ( n == 16 ) { return 13 ; } if ( n == 17 ) { return 13 ; } if ( n == 18 ) { return 13 ; } if ( n == 19 ) { return 13 ; } if ( n == 19 ) { return 13 ; } if ( n == 19 ) { return 13 ; } if ( n == 23 ) { return 13 ; } if ( n == 23 ) { return 13 ; } if ( n == 23 ) { return 23 ; } if ( n == 23 ) { return 23 ; } return 0 ; if ( n == 23 ) { return 23 ; } return 0 ; }
public static int mulTable ( int N , int i ) { if ( ( i > 10 ) ) return 0 ; System . out . println ( N + " * " + i + " = " + N * i ) ; return mulTable ( N , i + 1 ) ; }
public static int closestNumber ( int n , int m ) { int q = ( int ) ( n / m ) ; int n1 = m * q ; int n2 ; if ( ( ( n * m ) > 0 ) ) { n2 = ( m * ( q + 1 ) ) ; } else { n2 = ( m * ( q - 1 ) ) ; } if ( ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) ) { return n1 ; } return n2 ; }
public static int solve ( int ang , int n ) { if ( ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) ) { return 0 ; } else if ( ( ( ang * n ) % 180 != 0 ) ) { return 0 ; } int ans = 1 ; int freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; }
public static int [ ] computeLps ( String s ) { int n = s . length ( ) ; int [ ] lps = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { lps [ i ] = 0 ; } int Len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( ( i < n ) ) { if ( ( s . charAt ( i ) == s . charAt ( Len ) ) ) { Len ++ ; lps [ i ] = Len ; i ++ ; } else { if ( ( Len != 0 ) ) { Len = lps [ Len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } return lps ; }
public static void checkIfSortRotated ( int [ ] arr , int n ) { int minEle = Integer . MAX_VALUE ; int maxEle = - Integer . MAX_VALUE - 1 ; int minIndex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < minEle ) { minEle = arr [ i ] ; minIndex = i ; } } int flag1 = 1 ; for ( int i = 1 ; i < minIndex ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag1 = 0 ; break ; } } int flag2 = 2 ; for ( int i = minIndex + 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag2 = 0 ; break ; } } if ( ( flag1 && flag2 && arr [ n - 1 ] < arr [ minIndex - 1 ] ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } arr = new int [ ] { 3 , 4 , 5 , 1 , 2 } ; n = arr . length ; checkIfSortRotated ( arr , n ) ; }
public static int getDistance ( int [ ] array ) { if ( array . length == 2 ) { return 0 ; } if ( array . length == 3 ) { return 0 ; } if ( array . length == 4 ) { return 0 ; } if ( array . length == 5 ) { return 0 ; } if ( array . length == 6 ) { return 0 ; } if ( array . length == 7 ) { return 0 ; } if ( array . length == 8 ) { return 0 ; } if ( array . length == 9 ) { return 0 ; } if ( array . length == 10 ) { return 0 ; } if ( array . length == 11 ) { return 0 ; } if ( array . length == 12 ) { return 0 ; } if ( array . length == 13 ) { return 0 ; } if ( array . length == 14 ) { return 0 ; } if ( array . length == 15 ) { return 0 ; } return - 1 ; }
static int checkIfPowerIsolated ( int num ) { int input1 = num ; int count = 0 ; int [ ] factor = new int [ ( num + 1 ) ] ; if ( ( num % 2 ) == 0 ) { while ( ( num % 2 ) == 0 ) { count ++ ; num /= 2 ; } factor [ 2 ] = count ; } int i = 3 ; while ( ( i * i <= num ) != 0 ) { count = 0 ; while ( ( num % i ) == 0 ) { count ++ ; num /= i ; } if ( ( count > 0 ) ) { factor [ i ] = count ; } i += 2 ; } if ( ( num > 1 ) ) { factor [ num ] = 1 ; } int product = 1 ; for ( int i = 0 ; ; i <= factor . length ; i ++ ) { if ( ( factor [ i ] > 0 ) ) { product = product * factor [ i ] * i ; } } if ( ( product == input1 ) ) { System . out . println ( " Power - isolated ▁ Integer " ) ; } else { System . out . println ( " Not ▁ a ▁ Power - isolated ▁ Integer " ) ; } return product ; }
public static int getProfession ( int [ ] array ) { int profession = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { profession += array [ i ] ; } return profession ; }
@ SafeVarargs public static void main ( String [ ] args ) { String input = System . getProperty ( " line . separator " ) ; Thread thread = new Thread ( ) { public void run ( ) { Map < Integer , Integer > indices = new HashMap < > ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { indices . put ( a [ i ] , i ) ; } for ( int i : indices . keySet ( ) ) { if ( indices . get ( i ) . size ( ) < 2 ) continue ; for ( int j = 0 ; j < indices . get ( i ) . size ( ) - 1 ; j ++ ) { int first = indices . get ( i ) . get ( j ) ; int second = indices . get ( i ) . get ( j + 1 ) ; ans = Math . max ( ans , n - second + first ) ; } } System . out . println ( ans != 0 ? ans : - 1 ) ; } } ; for ( ; ; ) { int n = Integer . parseInt ( input ) ; List < Integer > a = Integer . parseInt ( input ) ; thread . start ( ) ; } }
public static String multiply ( String num1 , String num2 ) { int len1 = num1 . length ( ) ; int len2 = num2 . length ( ) ; if ( len1 == 0 || len2 == 0 ) return "0" ; int [ ] result = new int [ len1 + len2 ] ; int in1 = 0 ; int in2 = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = ( int ) num1 . charAt ( i ) - 48 ; in2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int n2 = ( int ) num2 . charAt ( j ) - 48 ; int summ = n1 * n2 + result [ in1 + in2 ] + carry ; carry = summ / 10 ; result [ in1 + in2 ] = summ % 10 ; in2 ++ ; } if ( ( carry > 0 ) ) result [ in1 + in2 ] += carry ; in1 ++ ; } int i = result . length - 1 ; while ( ( i >= 0 ) && ( result [ i ] == 0 ) ) i -- ; if ( ( i == - 1 ) ) return "0" ; String s = " " ; while ( ( i >= 0 ) ) { s += ( char ) ( result [ i ] + 48 ) ; i -- ; } return s ; }
public static int n ( String input ) { int [ ] X = new int [ input . length ( ) ] ; for ( int i = 0 ; i < X . length ; i ++ ) X [ i ] = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; return X [ i ] ; }
public static int nSquare ( String input , int kth ) { int [ ] slogan = new int [ input . length ( ) ] ; for ( int i = 0 ; i < slogan . length ; i ++ ) { slogan [ i ] = i ; } if ( kth - 1 < ( nSquare - 1 ) - ( kth - 1 ) ) { while ( kth - 1 > 0 ) { kth -- ; System . out . println ( " LEFT " ) ; } for ( int i = 0 ; i < nSquare ; i ++ ) { System . out . println ( f " PRINT ▁ { slogan [ i ] } " ) ; if ( i != nSquare - 1 ) { System . out . println ( " RIGHT " ) ; } } } else { int nRight = nSquare - kth ; while ( nRight > 0 ) { nRight -- ; System . out . println ( " RIGHT " ) ; } for ( int i = nSquare - 1 ; i >= 0 ; i -- ) { System . out . println ( f " PRINT ▁ { slogan [ i ] } " ) ; if ( i != 0 ) { System . out . println ( " LEFT " ) ; } } } return nSquare ; }
static void printDistSum ( int [ ] arr , int n ) { int Sum = Arrays . stream ( arr ) . reduce ( 0 , ( i , j ) -> { for ( int i = 0 ; i < Sum + 1 ; i ++ ) { dp [ i ] [ 0 ] = true ; } for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= Sum ; j ++ ) { if ( ( dp [ i - 1 ] [ j ] == true ) ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j < Sum + 1 ; j ++ ) { if ( ( dp [ n ] [ j ] == true ) ) { System . out . print ( j + " ▁ " ) ; } } } ) ; arr = Arrays . stream ( arr ) . reduce ( 2 , ( i , j ) -> { for ( int j = 0 ; j < j ; j ++ ) { if ( ( dp [ n ] [ j ] == true ) ) { System . out . print ( j + " ▁ " ) ; } } } ) ; n = arr . length ; printDistSum ( arr , n ) ; }
public static int Subtract ( int a , int b ) { int c = a + ( ~ b + 1 ) ; return c ; if ( Class . isPrimitive ( ) ) { a = 2 ; b = 3 ; System . out . println ( Subtract ( a , b ) ) ; a = 9 ; b = 7 ; System . out . println ( Subtract ( a , b ) ) ; } return a ; }
public static int getIDString ( String input ) { int n = Integer . parseInt ( input ) ; int l = 1 ; int r = n ; while ( ( l < r ) ) { int mid = l + ( r - l ) / 2 ; int idxcnt = mid * ( mid + 1 ) / 2 ; if ( ( idxcnt < n ) ) { l = mid + 1 ; } else { r = mid ; } } l -- ; int idxcnt = l * ( l + 1 ) / 2 ; return ( int ) ( n - idxcnt ) ; }
public static int loveTriangle ( int idx , Set < Integer > set ) { int [ ] arr = Integer . parseInt ( input ( ) ) ; return arr [ idx ] ; }
public static int nextZero ( int i , int [ ] occurrences ) { while ( i < 26 ) { if ( occurrences [ i ] == 0 ) { return i ; } i ++ ; } return - 1 ; }
public static boolean isCorrect ( int hourMax , int minuteMax , String time ) { String [ ] h = time . split ( " : " ) ; String [ ] m = time . split ( " : " ) ; Map < String , String > mirrored = new HashMap < > ( ) ; mirrored . put ( "0" , "0" ) ; mirrored . put ( "1" , "1" ) ; mirrored . put ( "2" , "5" ) ; mirrored . put ( "3" , " " ) ; mirrored . put ( "4" , " " ) ; mirrored . put ( "5" , "2" ) ; mirrored . put ( "6" , " " ) ; mirrored . put ( "7" , " " ) ; mirrored . put ( "8" , "8" ) ; mirrored . put ( "9" , " " ) ; String mirroredH = mirrored . get ( h [ 1 ] ) + mirrored . get ( h [ 0 ] ) ; String mirroredM = mirrored . get ( m [ 1 ] ) + mirrored . get ( m [ 0 ] ) ; if ( mirroredH . length ( ) == 2 && Integer . parseInt ( mirroredH ) < minuteMax && mirroredM . length ( ) == 2 && Integer . parseInt ( mirroredM ) < hourMax ) { return mirroredM + " : " + mirroredH ; } return false ; } int N = Integer . parseInt ( input ( ) ) ; for ( ; ; ) { hourMax = Integer . parseInt ( input ( ) ) ; minuteMax = Integer . parseInt ( input ( ) ) ; int hourNow = Integer . parseInt ( input ( ) ) ; int minuteNow = Integer . parseInt ( input ( ) ) ; String result = "00:00" ; boolean flag = false ; for ( int hour = hourNow ; hour < hourMax ; hour ++ ) { int start = hour == hourNow ? minuteNow : 0 ; for ( int minute = start ; minute < minuteMax ; minute ++ ) { time = "0" . concat ( String . valueOf ( hour ) ) . concat ( String . valueOf ( hour ) ) . concat ( " : " ) . concat ( String . valueOf ( minute ) ) . concat ( String . valueOf ( minute ) ) ; boolean mirrored = isCorrect ( hourMax , minuteMax , time ) ; if ( mirrored ) { result = time ; flag = true ; break ;
public static int munimumNumberOfPiles ( int n , List < Integer > nValues ) { Collections . sort ( nValues ) ; int pile = - 1 ; for ( int idx = 0 , s = nValues . size ( ) ; idx < s ; idx ++ ) { int k = ( int ) Math . ceil ( ( idx + 1 ) / ( s + 1 ) ) ; pile = Math . max ( pile , k ) ; } return pile ; }
public static int x ( String input ) { int x = Integer . parseInt ( input ) ; for ( int jj = 0 ; jj < x ; jj ++ ) { int n = Integer . parseInt ( input ) ; if ( n == 1 ) { System . out . println ( 3 ) ; } else { if ( n % 2 == 1 ) { System . out . println ( 1 ) ; } else { int p = 0 ; int k = n ; while ( n % 2 == 0 ) { p ++ ; n /= 2 ; } int t = 2 * p ; if ( t == k ) { System . out . println ( t + 1 ) ; } else { System . out . println ( t ) ; } } } } return x ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int root = ( int ) ( n * ( 1 / 2 ) ) + 1 ; boolean [ ] isPrime = new boolean [ n + 3 ] ; for ( int i = 4 ; i <= n ; i += 2 ) { isPrime [ i ] = false ; } int ans = 0 ; int prePrime = - 1 ; for ( int i = 3 ; i <= n ; i += 2 ) { if ( isPrime [ i ] ) { if ( prePrime + 2 == i ) { ans += 2 ; } prePrime = i ; if ( i > root ) { continue ; } for ( int j = i * i ; j <= n ; j += i ) { isPrime [ j ] = false ; } } } System . out . println ( ans ) ; }
public static int [ ] L ( String input ) { int r = 1 ; for ( String k : input . split ( " ▁ " ) ) { L [ r ] = Integer . parseInt ( k ) ; r ++ ; } input . trim ( ) ; for ( String j : input . split ( " ▁ " ) ) { System . out . println ( L [ Integer . parseInt ( j ) - 1 ] ) ; } return L ; }
public static int [ ] getNegativeInstances ( ) { int [ ] values = new int [ ] { 0 } ; for ( int i = 0 ; i < values . length ; i ++ ) { values [ i ] = i ; } for ( int i = 0 ; i < values . length ; i ++ ) { values [ i ] = i ; } for ( int i = 0 ; i < values . length ; i ++ ) { values [ i ] = i ; } return values ; }
@ SafeVarargs public static void printMax ( int [ ] arr , int n , int k ) { Stack < Integer > Qi = new Stack < > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { while ( Qi . empty ( ) && arr [ i ] >= arr [ Qi . peek ( ) ] ) { Qi . pop ( ) ; } Qi . push ( i ) ; } for ( int i = k ; i < n ; i ++ ) { System . out . print ( arr [ Qi . pop ( ) ] + " ▁ " ) ; while ( Qi . empty ( ) && Qi . peek ( ) <= i - k ) { Qi . pop ( ) ; } while ( Qi . empty ( ) && arr [ i ] >= arr [ Qi . peek ( ) ] ) { Qi . pop ( ) ; } Qi . push ( i ) ; } System . out . println ( arr [ Qi . pop ( ) ] ) ; } if ( Class . isPrimitive ( ) ) { arr = new int [ ] { 12 , 1 , 78 , 90 , 57 , 89 , 56 } ; k = 3 ; printMax ( arr , arr . length , k ) ; }
public static int russianPeasant ( int a , int b ) { int res = 0 ; while ( ( b > 0 ) ) { if ( ( b & 1 ) != 0 ) { res = res + a ; } a = a << 1 ; b = b >> 1 ; } return res ; }
public static boolean isValid ( String string , int length ) { for ( int i = 1 ; i < length ; i ++ ) { if ( string . charAt ( i ) == string . charAt ( i - 1 ) ) { return false ; } } return true ; }
public static int lehmann ( int n , int t ) { int a = Math . random ( ) ; int e = ( n - 1 ) / 2 ; while ( ( t > 0 ) ) { int result = ( ( ( int ) ( a * e ) ) % n ) ; if ( ( ( result % n ) == 1 ) || ( ( result % n ) == ( n - 1 ) ) ) { a = Math . random ( ) ; t -- ; } else { return - 1 ; } } return 1 ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int a = Integer . parseInt ( args [ i ] ) ; int b = Integer . parseInt ( args [ i ] ) ; int i = 0 ; do { if ( a <= 0 || b <= 0 ) break ; if ( a > b ) { i += a / b ; a -= a / b * b ; } else { i += b / a ; b -= b / a * a ; } } while ( b > 0 ) ; } System . out . println ( i ) ; }
public static String getSuffix ( String suffix ) { return suffix . substring ( suffix . lastIndexOf ( ' . ' ) + 1 ) ; }
public static int MaxTraceSub ( int [ ] [ ] mat ) { int maxTrace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i ; int s = j ; int trace = 0 ; while ( ( r < N ) && ( s < N ) ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; maxTrace = Math . max ( trace , maxTrace ) ; } } } return maxTrace ; }
public static double getDoubleFromDouble ( double value ) { double result = 0 ; double xa1 = Double . parseDouble ( value ) ; double ya1 = Double . parseDouble ( value ) ; double xa2 = Double . parseDouble ( value ) ; double ya2 = Double . parseDouble ( value ) ; double xb1 = Double . parseDouble ( value ) ; double yb1 = Double . parseDouble ( value ) ; double xb2 = Double . parseDouble ( value ) ; double yb2 = Double . parseDouble ( value ) ; result = result * xb1 + yb1 ; return result ; }
public static int [ ] convertToBinary ( int n ) { int [ ] listy = new int [ 31 ] ; while ( n > 0 ) { listy [ 0 ] = n % 2 ; n /= 2 ; } for ( int i = 0 ; i < 31 - listy . length ; i ++ ) { listy [ i ] = 0 ; } return listy ; }
public static int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; i ++ ) { int divCount = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { if ( ( i % j ) == 0 ) { divCount ++ ; } } if ( ( divCount % 2 ) != 0 ) { res ++ ; } } return res ; }
public static int [ ] getNegativeInstances ( ) { int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int m = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int [ ] arr = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int [ ] li = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { li [ i ] = Math . ceil ( arr [ i ] / m ) ; } int maxi = Collections . max ( li ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( maxi == li [ i ] ) { System . out . println ( i + 1 ) ; break ; } } return li ; }
static void printArray ( int N , int [ ] arr ) { for ( int i = 0 ; i <= N ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; }
public static void printArray ( int N , int [ ] arr ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . print ( " \n " ) ; }
public static int countDivisbleby4 ( String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( s . charAt ( i ) == '4' ) || ( s . charAt ( i ) == '8' ) || ( s . charAt ( i ) == '0' ) ) { count ++ ; } } for ( int i = 0 ; i < n - 1 ; i += 1 ) { int h = ( ( int ) s . charAt ( i ) - '0' ) * 10 + ( ( int ) s . charAt ( i + 1 ) - '0' ) ; if ( ( h % 4 == 0 ) ) { count = count + i + 1 ; } } return count ; }
public static String getCountry ( String country ) { String country = country . toLowerCase ( ) ; if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if (
public static void gen ( int number , int four , int seven ) { if ( ( number > limit ) ) return ; if ( ( number > 0 ) && ( four == seven ) ) l . add ( number ) ; gen ( number * 10 + 4 , four + 1 , seven ) ; gen ( number * 10 + 7 , four , seven + 1 ) ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForProposi
public static int getDistance ( String [ ] array ) { int distance = 0 ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; return dx [ dx . length ] ; }
public static void countIsland ( int [ ] [ ] ban ) { { int [ ] [ ] remove = new int [ 12 ] [ 12 ] ; if ( 0 <= y && 0 <= x && x < 12 && ban [ y ] [ x ] == 1 ) { ban [ y ] [ x ] = 0 ; for ( int dx = - 1 , dy = 0 ; dx < 12 ; dx ++ , dy = 1 ) { remove [ dx ] [ dy ] = 0 ; } } int count = 0 ; for ( int y = 0 ; y < 12 ; y ++ ) { for ( int x = 0 ; x < 12 ; x ++ ) { if ( ban [ y ] [ x ] == 1 ) { count ++ ; remove [ x ] [ y ] = 1 ; } } } System . out . println ( count ) ; } ban = new int [ 12 ] [ 12 ] ; while ( true ) { try { String s = System . getProperty ( " line . separator " ) ; if ( s != null ) { ban [ y ] = Integer . parseInt ( s ) ; } else { countIsland ( ban ) ; ban = new int [ 12 ] [ 12 ] ; } } catch ( NumberFormatException e ) { break ; } } if ( ban . length > 0 ) { countIsland ( ban ) ; } }
public static boolean arraySortedOrNot ( int [ ] arr , int n ) { if ( ( n == 0 ) || ( n == 1 ) ) { return true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] > arr [ i ] ) ) { return false ; } } return true ; arr = new int [ ] { 20 , 23 , 23 , 45 , 78 , 88 } ; n = arr . length ; if ( ( arraySortedOrNot ( arr , n ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
public static void parseLine ( String line ) { int n = Integer . parseInt ( line ) ; int [ ] arr = line . split ( " ▁ " ) ; int k = Math . min ( arr . length , arr [ 0 ] ) ; if ( n == 1 ) { System . out . println ( 0 ) ; } else { int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { res += ( arr [ i ] - k ) ; } System . out . println ( res ) ; } }
static int printKDistinct ( int [ ] arr , int size , int KthIndex ) { HashMap < Integer , Integer > dict = new HashMap < > ( ) ; int [ ] vect = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( dict . get ( arr [ i ] ) ) != null ) { dict . put ( arr [ i ] , dict . get ( arr [ i ] ) + 1 ) ; } else { dict . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < size ; i ++ ) { if ( ( dict . get ( arr [ i ] ) ) > 1 ) { continue ; } else { KthIndex = KthIndex - 1 ; } if ( ( KthIndex == 0 ) ) { return arr [ i ] ; } } return - 1 ; } arr = Arrays . asList ( 1 , 2 , 1 , 3 , 4 , 2 ) ; size = arr . length ; System . out . println ( printKDistinct ( arr , size , 2 ) ) ; }
public static int [ ] fib ( int [ ] f , int n ) { f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 ; } return f ; }
public static String getABC ( String input ) { String ABC = Integer . parseInt ( input ) ; if ( ABC . indexOf ( 5 ) == 2 ) { return ( Arrays . stream ( ABC . split ( " ▁ " ) ) . mapToObj ( Integer :: parseInt ) . sum ( ) == 17 ) ? " YES " : " NO " ; } else { return " NO " ; } }
public static int [ ] getNegativeInstances ( ) { int [ ] A = new int [ N ] ; A [ 0 ] = W ; A [ 1 ] = W ; A [ 2 ] = W ; A [ 3 ] = W ; A [ 4 ] = W ; A [ 5 ] = W ; A [ 6 ] = W ; A [ 7 ] = W ; A [ 8 ] = W ; A [ 9 ] = W ; A [ 10 ] = W ; A [ 11 ] = W ; A [ 12 ] = W ; A [ 13 ] = W ; A [ 14 ] = W ; A [ 15 ] = W ; A [ 16 ] = W ; A [ 17 ] = W ; A [ 18 ] = W ; A [ 19 ] = W ; A [ 20 ] = W ; A [ 21 ] = W ; A [ 22 ] = W ; A [ 23 ] = W ; A [ 22 ] = W ; A [ 23 ] = W ; A [ 24 ] = W ; A [ 25 ] = W ; A [ 26 ] = W ; A [ 27 ] = W ; A [ 26 ] = W ; A [ 27 ] = W ; A [ 26 ] = W ; A [ 27 ] = W ; A [ 26 ] = W ; A [ 27 ] = W ; A [ 26 ] = W ; A [ 27 ] = W ; A [ 27 ] = W ; A [ 26 ] = W ; A [ 27 ] = W ; A [ 27 ] ; A [ 28 ] = W ; A [ 29 ] = W ; A [ 27 ] ; A [ 29 ] = W ; A [ 27 ] = W ; A [ 28 ] ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; A [ 29 ] = W ; return X ; }
public static void countEleLessThanOrEqual ( int [ ] arr1 , int [ ] arr2 , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr2 [ j ] <= arr1 [ i ] ) ) { count ++ ; } } System . out . print ( count + " ▁ " ) ; } }
public static final int min ( int [ ] arr ) { int k = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; arr = Arrays . stream ( arr ) . mapToInt ( Integer :: parseInt ) . sum ( ) ; if ( k == 1 ) { System . out . println ( Math . min ( arr . length ) ) ; } else if ( k == 2 ) { System . out . println ( Math . max ( arr [ 0 ] , arr [ arr . length - 1 ] ) ) ; } else { System . out . println ( Math . max ( arr . length , arr [ 0 ] ) ) ; } return arr . length ; }
public static String getLetter ( String s ) { String [ ] A = s . split ( " ▁ " ) ; System . out . println ( A [ 0 ] ) ; int S = Integer . parseInt ( s ) ; for ( ; S > 0 ; S -- ) { String B = A [ S ] ; String C = A [ S ] ; A [ A . indexOf ( B ) ] = C ; System . out . println ( A [ A . length - B ] ) ; } return A [ 0 ] ; }
public static final String getSuffix ( String suffix ) { if ( suffix == null ) { return null ; } else { return suffix . substring ( suffix . lastIndexOf ( ' . ' ) + 1 ) ; } }
public static int getDistance ( int [ ] arr ) { int k = Integer . parseInt ( arr [ 0 ] ) ; int p = Integer . parseInt ( arr [ 1 ] ) ; int ans = 0 ; int ans2 = 0 ; int i = 1 ; while ( ans2 < k ) { String s = Integer . toString ( i ) ; ans += Integer . parseInt ( s + s . substring ( 0 , s . length ( ) - 1 ) ) ; ans2 ++ ; i ++ ; } return ans % p ; }
public static int getLargestNumber ( int [ ] array ) { int [ ] A = array . clone ( ) ; Map < Integer , Integer > aToI = new HashMap < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { A [ i ] = A [ i ] ; } List < Integer > L = new ArrayList < > ( ) ; List < Integer > R = new ArrayList < > ( ) ; for ( int i = 0 ; i < N + 2 ; i ++ ) { L . add ( i - 1 ) ; } R . add ( i + 1 ) ; int ans = 0 ; for ( int a = N ; a > 0 ; a -- ) { int i = aToI . get ( a ) ; ans += a * ( R . get ( i ) - i ) * ( i - L . get ( i ) ) ; L . set ( R . get ( i ) , L . get ( i ) ) ; R . set ( L . get ( i ) , R . get ( i ) ) ; } return ans ; }
public static int lps ( String str ) { int n = str . length ( ) ; int [ ] [ ] L = new int [ n ] [ n ] ; for ( int x = 0 ; x < n ; x ++ ) { L [ x ] [ x ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { L [ i ] [ i ] = 1 ; } for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) { L [ i ] [ j ] = 2 ; } else if ( str . charAt ( i ) == str . charAt ( j ) ) { L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; } else { L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } } return L [ 0 ] [ n - 1 ] ; }
static void printConsecutive ( int last , int first ) { System . out . print ( first ) ; first ++ ; for ( int x = first ; x <= last ; x ++ ) { System . out . print ( " ▁ + " + x ) ; } }
public static String getCountry ( String country ) { return country . toLowerCase ( ) ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) { return 0 ; } if ( ( a == b ) ) { return a ; } if ( ( a > b ) ) { return gcd ( a - b , b ) ; } return gcd ( a , b - a ) ; }
public static boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; char [ ] c = new char [ s . length ( ) ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s . charAt ( i ) ; } Arrays . sort ( c , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( c [ i ] != s . charAt ( i ) ) ) { return false ; } } return true ; }
static void printMax ( int [ ] arr , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { max = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] > max ) { max = arr [ i + j ] ; } } System . out . print ( max + " ▁ " ) ; } if ( " java . util . regex . regex " . equals ( " " ) ) { arr = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; n = arr . length ; k = 3 ; printMax ( arr , n , k ) ; } }
public static int mod ( String [ ] args ) { final int [ ] input = new int [ args . length ] ; System . out . println ( " mod ▁ " ) ; final int N = Integer . parseInt ( args [ 0 ] ) ; final int M = Integer . parseInt ( args [ 1 ] ) ; final int [ ] [ ] adj = new int [ N + 1 ] [ ] ; for ( int i = 0 ; i < M ; i ++ ) adj [ i ] [ 0 ] = new int [ N + 1 ] ; for ( int j = 0 ; j < M ; j ++ ) adj [ i ] [ j ] = new int [ N + 1 ] ; for ( int j = 0 ; j < M ; j ++ ) adj [ i ] [ j ] = new int [ N + 1 ] ; for ( int j = 0 ; j < N + 1 ; j ++ ) adj [ i ] [ j ] [ j ] = new int [ N + 1 ] ; for ( int j = 0 ; j < M ; j ++ ) adj [ i ] [ j ] [ j ] = new int [ N + 1 ] ; for ( int j = 0 ; j < N + 1 ; j ++ ) adj [ i ] [ j ] [ j ] = new int [ N + 1 ] ; for ( int j = 0 ; j < M ; j ++ ) adj [ i ] [ j ] [ j ] = new int [ N + 1 ] ; for ( int j = 0 ; j < N + 1 ; j ++ ) adj [ i ] [ j ] [ j ] = new int [ N + 1 ] ; for ( int j = 0 ; j < M ; j ++ ) adj [ i ] [ j ] [ j ] = new int [ N + 1 ] ; for ( int j = 0 ; j < N + 1 ; j ++ ) if ( adj [ i ] [ j ] [ j ] != 0 ) continue ; boolean flg = true ; final int [ ] que = new int [ N + 1 ] ; que [ 0 ] [ j ] = 0 ; for ( int j = 0 ; j < N ; j ++ ) if ( adj [ i ] [ j ] != 0 ) continue ; for ( int j = 0 ; j < M ; j ++ ) if ( adj [ i ] [ j ] != 0 ) continue ; for ( int j = 0 ; j ++ ) ans [ j ]
public static int ss ( int a , int b ) { a = Math . min ( a , b ) ; return a * ( a + 1 ) / 2 + ( b - a ) * a ; }
public static int [ ] [ ] getP ( String input ) { int N = Integer . parseInt ( input ) ; int K = Integer . parseInt ( input ) ; int [ ] [ ] P = new int [ N ] [ ] ; for ( int i = 0 ; i < N ; i ++ ) { P [ i ] = Arrays . copyOf ( Integer . parseInt ( input ) , i ) ; } int ans = 10 * 18 * 5 ; for ( int [ ] x : Arrays . stream ( P ) . map ( i -> i + 2 ) . collect ( Collectors . toList ( ) ) ) { int u = Math . max ( P [ x [ 0 ] ] [ 0 ] , P [ x [ 1 ] ] [ 0 ] ) ; int d = Math . min ( P [ x [ 0 ] ] [ 0 ] , P [ x [ 1 ] ] [ 0 ] ) ; for ( int [ ] y : Arrays . stream ( P ) . map ( i -> i + 2 ) . collect ( Collectors . toList ( ) ) ) { int r = Math . max ( P [ y [ 0 ] ] [ 1 ] , P [ y [ 1 ] ] [ 1 ] ) ; int l = Math . min ( P [ y [ 0 ] ] [ 1 ] , P [ y [ 1 ] ] [ 1 ] ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( d <= P [ i ] [ 0 ] && u <= P [ i ] [ 1 ] && l <= P [ i ] [ 1 ] && r <= P [ i ] [ 1 ] ) { count ++ ; } } if ( count >= K ) { ans = Math . min ( ans , ( u - d ) * ( r - l ) ) ; } } } System . out . println ( ans ) ; return P ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = i ; } return array ; }
public static String [ ] preProcess ( String [ ] substrings , String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String dup = " " ; for ( int j = i ; j < n ; j ++ ) { dup += s . charAt ( j ) ; substrings [ i ] = dup ; } } Arrays . sort ( substrings ) ; return substrings ; }
public static int [ ] [ ] f ( int [ ] [ ] f ) { int [ ] [ ] b = { { { 0 , - 1 } , { - 1 , 0 } } } ; int [ ] [ ] b = { { { 0 , - 1 } , { - 1 , 0 } , { 0 , 1 } , { 1 , 0 } } ; while ( true ) { int w = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int h = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; if ( w == 0 ) break ; int r = 1 , c = 1 , d = 0 ; do { String buf = System . getProperty ( " line . separator " ) ; if ( buf . charAt ( 0 ) == ' STOP ' ) break ; else if ( buf . charAt ( 0 ) == ' RIGHT ' ) d = ( d + 1 ) % 4 ; else if ( buf . charAt ( 0 ) == ' LEFT ' ) d = ( d + 3 ) % 4 ; else { if ( buf . charAt ( 0 ) == ' FORWARD ' ) { r2 = r + Integer . parseInt ( buf . substring ( 1 , 2 ) ) * f [ d ] [ 1 ] ; c2 = c + Integer . parseInt ( buf . substring ( 1 , 2 ) ) * f [ d ] [ 0 ] ; } else { r2 = r + Integer . parseInt ( buf . substring ( 1 , 2 ) ) * b [ d ] [ 1 ] ; c2 = c + Integer . parseInt ( buf . substring ( 1 , 2 ) ) * b [ d ] [ 0 ] ; } } while ( true ) ; } if ( b [ 0 ] [ 0 ] != null ) { System . out . println ( b [ 0 ] [ 0 ] ) ; } return b ; }
public static int getLargestIndex ( int [ ] array ) { int index = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == array [ i ] ) { index ++ ; } } return index ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalPropositionalForPropositionalPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalPropositionalForPropositionalPropositionalPropositionalForPropositionalPropositionalPropositionalForPropositionalPropositionalPropositionalForPropositionalPropositional
public static double fact ( double N ) { double product = 1 ; for ( double i = 1 ; i <= N ; i ++ ) { product = product * i ; } return product ; }
public static int longestSubArray ( int [ ] arr , int n ) { boolean isZeroPresent = false ; for ( int i = 0 ; ( i != n ) && ( ( arr [ i ] == 0 ) ) ; if ( ( isZeroPresent ) ) return n ; return 0 ; arr = Arrays . asList ( 1 , 2 , 3 , 0 , 1 , 2 , 0 ) ; n = arr . length ; System . out . println ( longestSubArray ( arr , n ) ) ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalPropositionalFor
public static void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; System . out . println ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; }
public static int maxDistinctChar ( String str , int n ) { int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ ( int ) str . charAt ( i ) ] ++ ; } int maxDistinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] != 0 ) ) { maxDistinct ++ ; } } return maxDistinct ; }
public static String f ( int n , String s1 , String s2 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 . charAt ( i ) != s2 . charAt ( i ) ) ) { if ( ( s1 . charAt ( i ) == ' R ' || s2 . charAt ( i ) == ' R ' ) ) { return " NO " ; } } } return " YES " ; } int t = Integer . parseInt ( input ( ) ) ; for ( int i = 0 ; i < t ; i ++ ) { n = Integer . parseInt ( input ( ) ) ; s1 = input ( ) ; s2 = input ( ) ; System . out . println ( f ( n , s1 , s2 ) ) ; }
static int findNumberOfEvenCells ( int n , int [ ] [ ] q , int size ) { int [ ] row = new int [ n ] ; int [ ] col = new int [ n ] ; for ( int i = 0 ; i < size ; i ++ ) { int x = q [ i ] [ 0 ] ; int y = q [ i ] [ 1 ] ; row [ x - 1 ] ++ ; col [ y - 1 ] ++ ; } int r1 = 0 ; int r2 = 0 ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( row [ i ] % 2 ) == 0 ) { r1 ++ ; } if ( ( row [ i ] % 2 ) == 1 ) { r2 ++ ; } if ( ( col [ i ] % 2 ) == 0 ) { c1 ++ ; } if ( ( col [ i ] % 2 ) == 1 ) { c2 ++ ; } } int count = r1 * c1 + r2 * c2 ; return count ; }
static void checkType ( int [ ] arr , int n ) { if ( ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) ) { System . out . println ( " Increasing " ) ; } else if ( ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) ) { System . out . println ( " Decreasing " ) ; } else if ( ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) ) { System . out . println ( " Increasing ▁ then ▁ decreasing " ) ; } else { System . out . println ( " Decreasing ▁ then ▁ increasing " ) ; } if ( Class . forName ( " java . util . Arrays " ) . equals ( arr [ 0 ] ) ) { arr = Arrays . asList ( 1 , 2 , 3 , 4 ) ; n = arr . length ; } checkType ( arr , n ) ; }
public static void printString ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { s = s . substring ( i , i + 1 ) ; } System . out . println ( n / 2 - Math . max ( s . indexOf ( '10' ) , s . indexOf ( '01' ) ) ) ; }
public static String getDigitsMask ( String mask ) { if ( mask == null ) { return null ; } if ( mask . length ( ) == 0 ) { return " " ; } if ( mask . length ( ) == 1 ) { return " " ; } if ( mask . length ( ) == 2 ) { return " " ; } if ( mask . length ( ) == 3 ) { return " " ; } if ( mask . length ( ) == 4 ) { return " " ; } if ( mask . length ( ) == 5 ) { return " " ; } if ( mask . length ( ) == 6 ) { return " " ; } if ( mask . length ( ) == 7 ) { return " " ; } if ( mask . length ( ) == 8 ) { return " " ; } if ( mask . length ( ) == 9 ) { return " " ; } if ( mask . length ( ) == 10 ) { return " " ; } if ( mask . length ( ) == 11 ) { return " " ; } if ( mask . length ( ) == 12 ) { return " " ; } if ( mask . length ( ) == 13 ) { return " " ; } if ( mask . length ( ) == 14 ) { return " " ; } if ( mask . length ( ) == 15 ) { return " " ; } if ( mask . length ( ) == 16 ) { return " " ; } if ( mask . length ( ) == 15 ) { return " " ; } return mask . substring ( 0 , mask . length ( ) ) ; }
public static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) { return 1 ; } else { return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) ; } x = 3 ; return x ; }
public static void rearrange ( int [ ] arr , int n ) { int j = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] < 0 ) ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; j = j + 1 ; } } System . out . println ( arr ) ; }
public static int centeredSquareNum ( int n ) { return n * n + ( ( n - 1 ) * ( n - 1 ) ) ; int n = 7 ; System . out . println ( n + " ▁ Centered ▁ square ▁ number : " ) ; return n ; }
public static int getDistance ( String [ ] arr ) { int x , minSum ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . length ( ) > 0 ) { x = arr [ i ] . length ( ) ; } else if ( arr [ i ] . length ( ) > 0 ) { x = arr [ i ] . length ( ) ; } else if ( arr [ i ] . length ( ) > 0 ) { x = arr [ i ] . length ( ) - 1 ; } else if ( arr [ i ] . length ( ) > 0 ) { x = arr [ i ] . length ( ) - 1 ; } else if ( arr [ i ] . length ( ) > 0 ) { x = arr [ i ] . length ( ) - 1 ; } else { x = arr [ i ] . length ( ) - 1 ; } } return x ; }
public static int getCountry ( String country ) { int n = country . indexOf ( ' _ ' ) ; if ( n > 0 ) { return country . indexOf ( ' _ ' ) ; } return country . indexOf ( ' _ ' ) ; }
public static int maxSubArraySum ( int [ ] arr , int size ) { int maxSoFar = arr [ 0 ] ; int currMax = arr [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { currMax = Math . max ( arr [ i ] , currMax + arr [ i ] ) ; maxSoFar = Math . max ( maxSoFar , currMax ) ; } return maxSoFar ; }
public static boolean check ( int x ) { final String s = String . valueOf ( x ) ; int prev = ( int ) s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( ( int ) s . charAt ( i ) != prev + 1 ) return false ; prev = ( int ) s . charAt ( i ) ; } return true ; }
public static int indexOf ( int dividend , int divisor , int start , int end ) { if ( ( start > end ) ) { return ( 0 ) ; } int mid = start + ( end - start ) / 2 ; int n = dividend - divisor * mid ; if ( ( n > divisor ) ) { start = mid + 1 ; } else if ( ( n < 0 ) ) { end = mid - 1 ; } else { if ( ( n == divisor ) ) { mid ++ ; n = 0 ; } return ( mid ) ; } return indexOf ( dividend , divisor , start , end ) ; }
public static int getCountry ( String country ) { int n = Integer . parseInt ( country ) ; int [ ] cities = new int [ n ] ; for ( int i = 0 ; i < cities . length ; i ++ ) { cities [ i ] = cities [ i ] ; } for ( int i = 0 ; i < cities . length ; i ++ ) { if ( i == 0 ) { System . out . println ( Math . abs ( cities [ 0 ] - cities [ 1 ] ) + " ▁ " + Math . abs ( cities [ 0 ] - cities [ - 1 ] ) ) ; } else if ( i == cities . length - 1 ) { System . out . println ( Math . abs ( cities [ cities . length - 1 ] - cities [ i - 1 ] ) + " ▁ " + Math . abs ( cities [ 0 ] - cities [ - 1 ] ) ) ; } else { int mn = Math . min ( Math . abs ( cities [ i ] - cities [ i - 1 ] ) , Math . abs ( cities [ i ] - cities [ i + 1 ] ) ) ; int mx = Math . max ( Math . abs ( cities [ i ] - cities [ 0 ] ) , Math . abs ( cities [ i ] - cities [ - 1 ] ) ) ; System . out . println ( mn + " ▁ " + mx ) ; } } return n ; }
public static void solve ( ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) , i = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; List < Integer > ns = new ArrayList < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { ns . add ( Integer . parseInt ( System . getProperty ( " line . separator " ) ) ) ; } int k = 1 << ( i * 8 / n ) ; List < Integer > lis = new ArrayList < > ( ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( ns . get ( i ) != ns . get ( i + 1 ) ) { lis . add ( i + 1 ) ; } } lis . add ( n ) ; System . out . println ( lis . size ( ) <= k ? 0 : n - Math . max ( lis . get ( i + k ) - lis . get ( i ) , 0 ) ) ; }
public static void towerOfHanoi ( int n , char fromRod , char toRod , char auxRod1 , char auxRod2 ) { if ( ( n == 0 ) ) { return ; } if ( ( n == 1 ) ) { System . out . println ( " Move ▁ disk " + n + " ▁ from ▁ rod " + fromRod + " ▁ to ▁ rod " + toRod ) ; return ; } towerOfHanoi ( n - 2 , fromRod , auxRod1 , auxRod2 , toRod ) ; System . out . println ( " Move ▁ disk " + ( n - 1 ) + " ▁ from ▁ rod " + fromRod + " ▁ to ▁ rod " + auxRod2 ) ; System . out . println ( " Move ▁ disk " + ( n - 1 ) + " ▁ from ▁ rod " + auxRod2 + " ▁ to ▁ rod " + toRod ) ; towerOfHanoi ( n - 2 , auxRod1 , toRod , fromRod , auxRod2 ) ; }
public static final String getUUID ( String uuid ) { int [ ] array = new int [ uuid . length ( ) ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } return array [ 0 ] ; }
public static int M ( String [ ] query ) { int i ; for ( i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { query = input . split ( " ▁ " ) ; if ( query [ 0 ] . equals ( "0" ) ) M [ query [ 1 ] ] = query [ 2 ] ; else if ( query [ 0 ] . equals ( "1" ) ) { if ( M . containsKey ( query [ 1 ] ) ) System . out . println ( M . get ( query [ 1 ] ) ) ; else System . out . println ( 0 ) ; } else M [ query [ 1 ] ] = 0 ; } return i ; }
public static int minSum ( int [ ] arr , int n ) { int sum = arr [ 0 ] ; int prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
public static int findN ( int k ) { int ans ; if ( ( k == 0 ) ) { ans = 3 ; } if ( ( k == 1 ) ) { ans = 1 ; } else if ( ( k % 4 ) == 0 ) { ans = k ; } else if ( ( k % 4 ) == 3 ) { ans = k - 1 ; } else { ans = - 1 ; } return ans ; }
public static int subsetXOR ( int [ ] arr , int n , int K ) { int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( ( arr [ i ] > maxEle ) maxEle = arr [ i ] ; int m = ( 1 << ( int ) ( Math . log2 ( maxEle ) + 1 ) ) - 1 ; int [ ] [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) for ( int j = 0 ; j < m + 1 ; j ++ ) for ( int k = 0 ; k < n + 1 ; k ++ ) dp [ i ] [ j ] [ k ] = 0 ; for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) for ( int j = 0 ; j < m + 1 ; j ++ ) for ( int k = 0 ; k < n + 1 ; k ++ ) { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; if ( ( k != 0 ) ) dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ] [ k - 1 ] ; } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += dp [ n ] [ K ] [ i ] ; return ans ; }
public static int getDistance ( String input ) { int D = Integer . parseInt ( input ) ; int G = Integer . parseInt ( input ) ; int [ ] [ ] PC = new int [ D ] [ ] ; for ( int i = 0 ; i < D ; i ++ ) { PC [ i ] = Integer . parseInt ( input ) ; } int ans = 10 * 9 ; for ( int i = 0 ; i < 2 * D ; i ++ ) { int score = 0 ; int problem = 0 ; for ( int j = 0 ; j < D ; j ++ ) { if ( ( i >>> j ) & 1 != 0 ) { score += 100 * ( j + 1 ) * PC [ j ] [ 0 ] + PC [ j ] [ 1 ] ; problem += PC [ j ] [ 0 ] ; } } if ( score > G ) continue ; int left = G - score ; for ( int j = 0 ; j < D ; j ++ ) { if ( ( i >>> j ) & 1 != 0 ) continue ; if ( left > 100 * ( j + 1 ) * PC [ j ] [ 0 ] + PC [ j ] [ 1 ] ) { } else { int tmp = ( left + ( 100 * ( j + 1 ) ) - 1 ) / ( 100 * ( j + 1 ) ) ; ans = Math . min ( ans , problem + Math . min ( tmp , PC [ j ] [ 0 ] ) ) ; } } } return ans ; }
public static int getDistance ( String [ ] arr ) { int m = arr . length ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . equals ( arr [ i ] ) ) { return i ; } } return - 1 ; }
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static int minAbsDiff ( int n ) { int left = Math . pow ( 2 , Math . floor ( Math . log2 ( n ) ) ) ; int right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; }
public static int LCIS ( int [ ] arr1 , int n , int [ ] arr2 , int m ) { int [ ] table = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { table [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( arr1 [ i ] == arr2 [ j ] ) ) { if ( ( current + 1 > table [ j ] ) ) { table [ j ] = current + 1 ; } } if ( ( arr1 [ i ] > arr2 [ j ] ) ) { if ( ( table [ j ] > current ) ) { current = table [ j ] ; } } } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( ( table [ i ] > result ) ) { result = table [ i ] ; } } return result ; }
static int countSetBits ( int n ) { int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { bitCount += countSetBitsUtil ( i ) ; } return bitCount ; }
public static int partition ( int [ ] arr , int low , int high ) { int pivot = arr [ low ] ; int i = low - 1 ; int j = high + 1 ; while ( ( i = arr [ low ] ) != 0 ) { i ++ ; while ( ( i = arr [ i ] ) < pivot ) i ++ ; j -- ; while ( ( j = arr [ j ] ) > pivot ) j -- ; if ( ( i >= j ) ) return j ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } return 0 ; }
public static int partition ( int [ ] arr , int low , int high ) { int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j < high ; j ++ ) { if ( ( arr [ j ] <= pivot ) ) { i ++ ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } } arr [ i + 1 ] = arr [ high ] ; arr [ high ] = arr [ i + 1 ] ; return ( i + 1 ) ; }
public static int maxSubArraySum ( int [ ] a , int size ) { int maxSoFar = - 10 * 9 ; int maxEndingHere = 0 ; for ( int i = 0 ; i < size ; i ++ ) { maxEndingHere = maxEndingHere + a [ i ] ; if ( ( maxSoFar < maxEndingHere ) ) { maxSoFar = maxEndingHere ; } if ( ( maxEndingHere < 0 ) ) { maxEndingHere = 0 ; } } return maxSoFar ; }
public static int fun ( String p ) { return p . indexOf ( Math . max ( p , 0 ) ) ; for ( ; ; ) { int n = Integer . parseInt ( input ( ) ) ; int p = Integer . parseInt ( input ( ) ) ; int l [ ] [ ] ; int var = p [ 0 ] ; String ans [ ] = new String [ n ] [ ] ; for ( int j = 0 ; j < n ; j ++ ) { l [ j ] [ 0 ] = p . substring ( j , j ) ; } Arrays . sort ( l , new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ) ; l = l . clone ( ) ; int ind = 0 ; ans [ ind ] = p . substring ( l [ 0 ] . substring ( 1 ) , n ) ; for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( l [ j + 1 ] [ 1 ] > l [ j ] [ 1 ] ) { String temp = l [ j + 1 ] ; l [ j + 1 ] = l [ j ] ; l [ j ] = temp ; } else { ans [ ind ] = p . substring ( l [ j + 1 ] . substring ( 1 ) , l [ j ] [ 1 ] ) ; } } for ( int j = 0 ; j < ans . length ; j ++ ) { System . out . print ( ( String ) ans [ j ] ) ; } System . out . println ( ) ; } }
static void printArray ( int N , int SUM , int K ) { int minSum = ( N * ( N + 1 ) ) / 2 ; int maxSum = ( N * K ) - ( N * ( N - 1 ) ) / 2 ; if ( ( minSum > SUM ) || ( maxSum < SUM ) ) { System . out . println ( " Not ▁ Possible " ) ; return ; } int [ ] arr = new int [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i += 1 ) { arr [ i ] = i ; } int sum = minSum ; int i = N ; while ( ( i >= 1 ) ) { int x = sum + ( K - i ) ; if ( ( x < SUM ) ) { sum = sum + ( K - i ) ; arr [ i ] = K ; K -- ; } else { arr [ i ] += ( SUM - sum ) ; sum = SUM ; break ; } i -- ; } for ( i = 1 ; i <= N ; i += 1 ) { System . out . print ( ( int ) arr [ i ] ) ; } }
public static int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = Math . min ( x , Math . min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
@ SafeVarargs public static int runTasks ( ArrayList < Integer > A , ArrayList < Integer > B ) { int totalTime = 0 ; while ( ( A . size ( ) ) > 0 ) { int x = A . remove ( 0 ) ; int y = B . remove ( 0 ) ; if ( ( x == y ) ) { totalTime += 1 ; } else { B . add ( y ) ; A . add ( x ) ; totalTime += 2 ; } } return totalTime ; }
public static void line ( int x0 , int y0 ) { int c = 2 * y0 * x0 ; System . out . println ( y0 + " x " + " ▁ + ▁ " + x0 + " y ▁ = ▁ " + c ) ; }
public static int getScore ( int score ) { return score * score ; }
public static double cross ( double a , double b ) { double flag ; double dot ; double p0 , p1 , p2 ; double [ ] lines ; double [ ] a = p1 - p0 , b = p2 - p0 ; if ( a . length == 2 ) { flag = 1 ; } else if ( a . length == 3 ) { flag = - 1 ; } else if ( a . length == 4 ) { flag = 2 ; } else if ( a . length == 5 ) { flag = - 2 ; } else if ( a . length == 6 ) { flag = - 2 ; } else if ( a . length == 7 ) { flag = 0 ; } else if ( a . length == 8 ) { flag = 0 ; } else if ( a . length == 9 ) { flag = 0 ; } else if ( a . length == 4 ) { flag = 0 ; } else if ( a . length == 5 ) { flag = 0 ; } else if ( a . length == 6 ) { flag = 0 ; } else if ( a . length == 4 ) { flag = 0 ; } else if ( a . length == 5 ) { flag = 0 ; } else if ( a . length == 6 ) { flag = 0 ; } else if ( a . length == 7 ) { flag = 0 ; } else if ( a . length == 8 ) { flag = 0 ; } else if ( a . length == 9 ) { flag = 0 ; } else if ( a . length == 10 ) { flag = 0 ; } else if ( a . length == 11 ) { flag = 0 ; } else if ( a . length == 4 ) { flag = 0 ; } else if ( a . length == 5 ) { flag = 0 ; } else if ( a . length == 6 ) { flag = 0 ; } else if ( a . length == 7 ) { flag = 0 ; } else if ( a . length == 8 ) { flag = 0 ; } else if ( a . length == 9 ) { flag = 0 ; } else if ( a . length == 4 ) { flag = 0 ; } else if ( a . length == 4 ) { flag = 0 ; } else if ( a . length == 5 ) { flag = 0 ; } else if ( a . length == 6 ) { flag = 0 ; } else if ( a . length == 4 ) { flag = 0 ; } else if ( a . length == 4 ) { flag = 0
public static boolean isAnyNotPalindrome ( String s ) { Set < Character > unique = new HashSet < > ( ) ; for ( int i = 0 ; ( s . length ( ) > 0 ) ; i ++ ) { unique . add ( s . charAt ( i ) ) ; } if ( ( unique . size ( ) > 1 ) ) { return true ; } else { return false ; } }
static int findMajority ( int [ ] arr , double n ) { return arr [ ( int ) ( n / 2 ) ] ; arr = Arrays . asList ( 1 , 2 , 2 , 3 ) ; n = arr . length ; return System . out . println ( findMajority ( arr , n ) ) ; }
public static String getCountry ( String country ) { if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else { return " " " ; } else { return " " " ; } }
static int countSubArrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwiseOr = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwiseOr = bitwiseOr | arr [ k ] ; } if ( ( bitwiseOr >= K ) ) { count ++ ; } } } return count ; }
public static boolean canBeEqual ( int a , int b , int c , int k ) { int [ ] arr = new int [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; Arrays . sort ( arr ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( ( k < 0 ) || ( k % 3 != 0 ) ) { return false ; } return true ; }
public static void dfs ( int node , int [ ] [ ] adjacency ) { for ( int i = 0 ; i < 100 ; i ++ ) { adjacency [ i ] [ 0 ] = i ; } }
public static double sin ( double [ ] a ) { double [ ] b = new double [ a . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) { int j = i ; int k = j ; int j = j ; int k = j ; j = k ; k = j ; j = j ; j = j ; k = j ; j = j ; j = j ; j = j ; k = j ; j = j ; j = j ; j = j ; k = j ; j = j ; j = j ; j = j ; j = j ; j = j ; k = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; k = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j ; j = j = j ; j = j
@ Function public static int solution1 ( ) { int t = 1 ; int result = 0 ; int i = 0 ; while ( i < t ) { result += i ; i ++ ; } return result ; }
public static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ ] [ ] L = new int [ o + 1 ] [ n + 1 ] ; for ( int k = 0 ; k < m + 1 ; k ++ ) { L [ 0 ] [ k ] = 0 ; } for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { for ( int k = 0 ; k < o ; k ++ ) { if ( ( i == 0 ) || ( j == 0 ) || ( k == 0 ) ) { L [ i ] [ j ] [ k ] = 0 ; } else if ( ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) && ( X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) ) { L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; } else { L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } } return L [ m ] [ n ] [ o ] ; } X = " AGGT12" ; Y = "12TXAYB " ; Z = "12XBA " ; m = X . length ( ) ; n = Y . length ( ) ; o = Z . length ( ) ; System . out . println ( " Length ▁ of ▁ LCS ▁ is " + lcsOf3 ( X , Y , Z , m , n , o ) ) ; return L [ m ] [ n ] [ o ] ; }
public static int [ ] getNegativeInstances ( ) { int [ ] r = new int [ 2 ] ; r [ 0 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; r [ 1 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; r [ 2 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; r [ 3 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; return r ; }
public static boolean isSpiltPossible ( int n , int [ ] a ) { int Sum = 0 ; int c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum += a [ i ] ; if ( ( a [ i ] == 1 ) ) { c1 ++ ; } } if ( ( Sum % 2 ) != 0 ) { return false ; } if ( ( ( Sum / 2 ) % 2 == 0 ) ) { return true ; } if ( ( c1 > 0 ) ) { return true ; } else { return false ; } n = 3 ; a = new int [ ] { 1 , 1 , 2 } ; if ( ( isSpiltPossible ( n , a ) ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } return true ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 4 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = Integer . parseInt ( array [ i ] ) ; } return array ; }
public static void countEvenOdd ( int min , int max , int [ ] [ ] steps ) { boolean beven = true ; boolean aeven = false ; int n = 2 ; for ( int i = 0 ; ( i <= n ) && ( i < steps . length ) ; i ++ ) { int a = steps [ i ] [ 0 ] ; int b = steps [ i ] [ 1 ] ; if ( ( ! ( aeven || ( a & 1 ) ) ) ) { aeven = true ; } if ( ( beven ) ) { if ( ( b & 1 ) ) { beven = false ; } } else if ( ( ! ( a & 1 ) ) ) { if ( ( ! ( b & 1 ) ) ) { beven = true ; } } else { if ( ( b & 1 ) ) { beven = true ; } } } int even ; int odd ; if ( ( beven ) ) { even = ( ( int ) ( max / 2 ) - ( ( int ) ( min - 1 ) / 2 ) ) ; odd = 0 ; } else { even = ( ( int ) ( max / 2 ) - ( ( int ) ( min - 1 ) / 2 ) ) ; odd = 0 ; } if ( ( ! ( beven ^ aeven ) ) ) { even += ( max - min + 1 - ( int ) ( max / 2 ) + ( ( int ) ( min - 1 ) / 2 ) ) ; } else { odd += ( max - min + 1 - ( int ) ( max / 2 ) + ( ( int ) ( min - 1 ) / 2 ) ) ; } System . out . println ( " even ▁ = ▁ " + even + " , ▁ odd ▁ = ▁ " + odd + " " ) ; } min = 1 ; max = 4 ; steps = new int [ ] [ ] { { 1 , 2 } , { 3 , 4 } }
public static int getRandom ( ) { int vamshi = Integer . parseInt ( System . getProperty ( " random . number " ) ) ; return ( vamshi / 2 + 1 ) * 2 ; }
public static void printKPFNums ( int A , int B , int K ) { boolean [ ] prime = new boolean [ B + 1 ] ; int [ ] pFactors = new int [ B + 1 ] ; for ( int p = 2 ; p <= B ; p ++ ) { if ( ( pFactors [ p ] == 0 ) ) { for ( int i = p ; i <= B ; i += p ) { pFactors [ i ] = pFactors [ i ] + 1 ; } } } for ( int i = A ; i <= B ; i ++ ) { if ( ( pFactors [ i ] == K ) ) { System . out . print ( i + " ▁ " ) ; } } A = 14 ; B = 18 ; K = 2 ; printKPFNums ( A , B , K ) ; }
public static void reverserWords ( String string ) { LinkedList < Character > st = new LinkedList < > ( ) ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( string . charAt ( i ) != ' ▁ ' ) { st . add ( string . charAt ( i ) ) ; } else { while ( st . size ( ) > 0 ) { System . out . print ( st . size ( ) - 1 ) ; st . removeLast ( ) ; } System . out . println ( " ▁ " ) ; } } while ( st . size ( ) > 0 ) { System . out . print ( st . size ( ) - 1 ) ; st . removeLast ( ) ; } } if ( className . equals ( " java . util . regex . regex . regex . regex " ) ) { string = " Geeks ▁ for ▁ Geeks " ; reverserWords ( string ) ; } }
public static void input ( ) { int a = 0 ; int b = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { a += i > i ? i : i ; b += i < i ; } System . out . println ( a == 0 ? - 1 : b / a + 1 ) ; }
public static int sieve ( ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int N = n + 2 ; int [ ] isPrime = new int [ N ] ; isPrime [ 0 ] = 0 ; isPrime [ 1 ] = 0 ; { int i = 2 ; while ( i * i <= N ) { if ( isPrime [ i ] == 0 ) { i ++ ; continue ; } int j = 2 * i ; while ( j < N ) { isPrime [ j ] = 0 ; j += i ; } i ++ ; } } { int c = 0 ; if ( ( n < 5 ) ) { c = 1 ; String s = "1 ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( ( i + 1 ) != 4 ) ) { s += "1 ▁ " ; } else { s += "2 ▁ " ; c ++ ; } } } System . out . println ( c ) ; System . out . println ( s ) ; } else { System . out . println ( "2" ) ; String s = " " ; int i = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = i + 1 ; if ( ( isPrime [ k ] == 1 ) ) { s += "1 ▁ " ; } else { s += "2 ▁ " ; } } System . out . println ( s ) ; } return n ; }
public static final double getDoubleFromDouble ( double [ ] values ) { double sum = 0 ; for ( double value : values ) { sum += value ; } double sum = 0 ; for ( double value : values ) { sum += value ; } for ( double value : values ) { sum += value ; } return sum ; }
public static int numIn ( ) { Integer arrIn = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; Integer spIn = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; Integer strIn = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int k = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; return n ; }
static int findNthTerm ( int n ) { if ( n % 2 == 0 ) { n /= 2 ; System . out . println ( 3 * ( n - 1 ) ) ; } else { n = ( n / 2 ) + 1 ; System . out . println ( 2 * ( n - 1 ) ) ; } if ( Class . isPrimitive ( " java . util . regex . Pattern " ) ) { int N = 4 ; findNthTerm ( N ) ; N = 11 ; findNthTerm ( N ) ; } return N ; }
static int countNonIncreasing ( int [ ] arr , int n ) { long cnt = 0 ; int len = 1 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( ( arr [ i + 1 ] >= arr [ i ] ) ) { len ++ ; } else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( ( len > 1 ) ) { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; } return ( int ) cnt ; }
public static int maximize ( int [ ] A1 , int [ ] A2 , int n , int x , int y ) { int [ ] c = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = 0 ; } int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = A2 [ i ] - A1 [ i ] ; Sum += A1 [ i ] ; } Arrays . sort ( c ) ; Arrays . sort ( c ) ; c = Arrays . copyOf ( c , c . length - 1 ) ; int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { Sum += c [ i ] ; if ( ( i + 1 ) >= ( n - x ) ) { maxi = Math . max ( Sum , maxi ) ; } } return maxi ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalPropositionalForPropositionalPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalPropositionalForPropositionalPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalPropositionalPropositionalForPropositionalPropositionalForPropositionalPro
public static double [ ] [ ] getCost ( int n , int m ) { double [ ] [ ] cost = new double [ n ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) cost [ i ] [ i ] = new double [ n ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) cost [ i ] [ i ] [ m ] = Double . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { int a = Integer . parseInt ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( i ) ) ) ) ) ; int b = Integer . parseInt ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( i ) ) ) ) ) ; int c = Integer . parseInt ( String . valueOf ( String . valueOf ( String . valueOf ( i ) ) ) ) ; int d = Integer . parseInt ( String . valueOf ( String . valueOf ( String . valueOf ( i ) ) ) ) ; cost [ i ] [ b ] [ c ] = Double . MAX_VALUE ; cost [ b ] [ a ] [ d ] = Double . MAX_VALUE ; } int s = Integer . parseInt ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( s ) ) ) ) ) ) ; int g = Integer . parseInt ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( m ) ) ) ) ) ; int V = Integer . parseInt ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( s ) ) ) ) ) ; int P = Integer . parseInt ( String . valueOf ( String . valueOf ( String . valueOf ( s ) ) ) ) ; for ( int k = 0 ; k < n ; k ++ ) for ( int i = 0 ; i < n ; j ++ ) if ( cost [ i ] [ j ] > cost [ i ] [ k ] [ j ] + cost [ k ] [ j ] ) cost [ i ] [ j ] = cost [ i ] [ k ] [ j ] ; return cost ; }
public static int r1 ( String input , int r2 ) { int c1 = Integer . parseInt ( input ) ; int c2 = Integer . parseInt ( input ) ; int d1 = Integer . parseInt ( input ) ; int d2 = Integer . parseInt ( input ) ; int x = ( d1 + c1 - r2 ) / 2 ; int y = r1 - x ; int z = c1 - x ; int w = d1 - x ; if ( 1 <= x && x <= 9 && 1 <= y && 1 <= z && 1 <= w && 1 <= 9 && Set . of ( x , y , z , w ) . size ( ) == 4 ) { System . out . println ( x + " ▁ " + y + " ▁ " + z + " ▁ " + w ) ; } else { System . out . println ( - 1 + " ▁ " + y + " ▁ " + z + " ▁ " + w ) ; } return x ; }
public static int binarySearch ( String input , int [ ] a , int [ ] w ) { while ( true ) { int n = Integer . parseInt ( input . substring ( 0 , input . length ( ) ) ) ; int m = Integer . parseInt ( input . substring ( input . length ( ) , input . length ( ) ) ) ; if ( n == m == 0 ) break ; a = a . toArray ( new int [ a . length ] ) ; w = w . toArray ( new int [ w . length ] ) ; HashSet < Integer > set = new HashSet < > ( ) ; { if ( i == m ) { set . add ( weight ) ; return ; } set . add ( i + 1 , weight ) ; set . add ( i + 1 , weight + w [ i ] ) ; set . add ( i + 1 , weight - w [ i ] ) ; } } set . add ( 0 , 0 ) ; boolean ans = false ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( ! set . contains ( a [ i ] ) ) { if ( ans == false ) { ans = new HashSet < > ( ) ; for ( int s : set ) { if ( set . contains ( s + s ) || set . contains ( i - s ) ) break ; } } } } if ( ans == false ) { System . out . println ( 0 ) ; continue ; } else if ( ans . size ( ) == 0 ) { System . out . println ( - 1 ) ; continue ; } else { System . out . println ( Math . min ( ans , 0 ) ) ; } return ans ; }
public static double min ( double [ ] array , double [ ] array ) { double min = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = min + array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = array [ i ] ; } else if ( array [ i ] > array [ i ] ) { min = array [ i ] ; } return min ; }
public static boolean startsWith ( String str , String pre ) { int strLen = str . length ( ) ; int preLen = pre . length ( ) ; int i = 0 ; int j = 0 ; while ( ( i < strLen ) && ( j < preLen ) ) { if ( ( str . charAt ( i ) != pre . charAt ( j ) ) ) { return false ; } i ++ ; j ++ ; } return true ; }
public static void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( ( i % 3 != 0 ) ) { for ( int j = 1 ; j < n ; j ++ ) { if ( ( j % 3 != 0 ) ) { for ( int k = 1 ; k < n ; k ++ ) { if ( ( k % 3 != 0 ) && ( i + j + k ) == n ) { System . out . println ( i + j + k ) ; return ; } } } } } } n = 233 ; printCombination ( n ) ; }
static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { for ( int k = 0 ; k < n + 1 ; k ++ ) { if ( i + j + k == n ) { result ++ ; } } } } return result ; }
public static int digitSum ( int n ) { int sum = 0 ; while ( ( n > 0 ) ) { sum += n % TEN ; n /= TEN ; } return sum ; }
public static int power ( int x , int a ) { int res = 1 ; while ( ( a ) != 0 ) { if ( ( ( a & 1 ) != 0 ) { res = res * x ; } x = x * x ; a >>>= 1 ; } return res ; }
public static int [ ] [ ] getSortedArray ( int [ ] array ) { int [ ] [ ] ans = new int [ array . length ] [ array [ 0 ] . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { ans [ i ] [ 0 ] = array [ i ] [ 0 ] ; } for ( int i = 0 ; i < array . length ; i ++ ) { ans [ i ] [ 0 ] = array [ i ] [ 0 ] ; } for ( int i = 0 ; i < array . length ; i ++ ) { ans [ i ] [ 0 ] = array [ i ] [ 0 ] ; } for ( int i = 0 ; i < array . length ; i ++ ) { ans [ i ] [ 0 ] = array [ i ] [ 0 ] ; } for ( int j = 0 ; j < array . length ; j ++ ) { ans [ i ] [ j ] = array [ i ] [ j ] ; } for ( int j = 0 ; j < array . length ; j ++ ) { ans [ i ] [ j ] = array [ j ] [ j ] ; } return ans ; }
public static String getMonth ( String year ) { return year . substring ( 0 , 4 ) ; }
public static void firstnonrepeating ( String Str ) { int i ; Queue < Character > q ; int [ ] charCount = new int [ MAX_CHAR ] ; for ( i = 0 ; i < Str . length ( ) ; i ++ ) { q . add ( Str . charAt ( i ) ) ; charCount [ ( int ) Str . charAt ( i ) - ' a ' ] ++ ; while ( ( ! q . isEmpty ( ) ) ) { if ( ( charCount [ ( int ) q . queue ( ) . peek ( ) - ' a ' ] ) > 1 ) { q . poll ( ) ; } else { System . out . print ( q . queue ( ) . peek ( ) + " ▁ " ) ; break ; } } if ( ( q . isEmpty ( ) ) ) { System . out . print ( - 1 + " ▁ " ) ; } } System . out . println ( ) ; }
public static int getDepth ( int [ ] array ) { int n = array . length ; Map < Integer , Integer > graph = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int i = array [ i ] , j = array [ j ] ; graph . put ( i , j ) ; graph . get ( j , i ) ; } int left = 0 ; int right = 0 ; Map < Integer , Integer > color = new HashMap < > ( ) ; Set < Integer > visited = new HashSet < > ( ) ; { Stack < Integer > level = new Stack < > ( ) ; level . push ( i ) ; if ( ! color . containsKey ( node ) ) { color . put ( node , 1 ) ; } while ( level . empty ( ) ) { int node = level . pop ( ) ; for ( int val : graph . get ( node ) ) { if ( ! visited . contains ( val ) ) { color . put ( val , 1 - color . get ( node ) ) ; visited . add ( val ) ; level . push ( val ) ; } } } } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! visited . contains ( i ) ) { visited . add ( i ) ; dfs ( i ) ; } } for ( int val = 1 ; val <= n ; val ++ ) { if ( color . get ( val ) == 0 ) { left ++ ; } else { right ++ ; } } System . out . println ( left * right - n + 1 ) ; return left ; }
public static int solve ( int n , int m , int obstacles , double [ ] rangee ) { double val = Math . min ( n , m ) ; Arrays . sort ( rangee ) ; int c = 1 ; for ( int i = obstacles - 1 ; i >= 0 ; i -- ) { rangee [ i ] = 2 * rangee [ i ] ; val -= rangee [ i ] ; if ( ( val <= 0 ) ) { return c ; } else { c ++ ; } } if ( ( val > 0 ) ) { return - 1 ; } n = 4 ; m = 5 ; obstacles = 3 ; rangee = new double [ ] { 1.0 , 1.25 , 1.15 } ; System . out . println ( solve ( n , m , obstacles , rangee ) ) ; }
public static int getUnsignedInt ( String s ) { int t = Integer . parseInt ( s ) ; int e1 = Integer . parseInt ( s ) ; int e2 = Integer . parseInt ( s . substring ( 0 , 1 ) ) ; int i = 1 ; while ( i < s . length ( ) ) { int x = Integer . parseInt ( s . substring ( i + 1 , i + 2 ) ) ; if ( s . charAt ( i ) == ' + ' ) { e2 += x ; } else { e2 *= x ; } i += 2 ; } if ( e1 == t && e2 == t ) { System . out . println ( " U " ) ; } else if ( e1 == t ) { System . out . println ( " M " ) ; } else if ( e2 == t ) { System . out . println ( " L " ) ; } else { System . out . println ( " I " ) ; } return t ; }
public static void minStack ( ) { final int [ ] stack = new int [ ] ; final int [ ] minStack = new int [ ] { } ; final int [ ] stack = new int [ ] { } ; final int [ ] minStack = new int [ ] { } ; final int [ ] push = new int [ ] { } ; final int x = stack [ 0 ] ; if ( minStack . length == 0 ) { minStack [ 0 ] = x ; return ; } if ( x <= minStack [ minStack . length - 1 ] ) { minStack [ minStack . length - 1 ] = x ; } else { minStack [ minStack . length - 1 ] = minStack [ minStack . length - 1 ] ; } final int pop = 0 ; if ( stack . length > 0 ) { minStack [ -- stack . length ] = stack [ 0 ] ; stack [ -- stack . length ] = stack [ 0 ] ; } final int top = stack [ 0 ] ; if ( stack . length > 0 ) { return stack [ stack . length - 1 ] ; } final int getMin = 0 ; if ( minStack . length > 0 ) { return minStack [ minStack . length - 1 ] ; } if ( getClass ( ) . equals ( MinStack . class ) ) { final MinStack m = new MinStack ( ) ; m . push ( - 2 ) ; m . push ( 0 ) ; m . push ( - 3 ) ; System . out . println ( m . getMin ( ) ) ; m . pop ( ) ; System . out . println ( m . top ( ) ) ; System . out . println ( m . getMin ( ) ) ; } }
public static String [ ] one ( String [ ] ten ) { String str = " " ; str += " one ▁ " ; str += " two ▁ " ; str += " three ▁ " ; str += " four ▁ " ; str += " five ▁ " ; str += " six ▁ " ; str += " seven ▁ " ; str += " eight ▁ " ; str += " nine ▁ " ; str += " ten ▁ " ; str += " eleven ▁ " ; str += " twelve ▁ " ; str += " thirteen ▁ " ; str += " fourteen ▁ " ; str += " fifteen ▁ " ; str += " sixteen ▁ " ; str += " seventeen ▁ " ; str += " eighteen ▁ " ; str += " nineteen ▁ " ; return str . split ( " ▁ " ) ; }
public static int flipSign ( int a ) { int neg = 0 ; int tmp = a < 0 ? 1 : - 1 ; while ( ( tmp = a ) != 0 ) { neg += tmp ; a += tmp ; } return neg ; }
public static int factorial ( int n ) { int i = n ; int fact = 1 ; while ( ( n / i != n ) ) { fact = fact * i ; i -- ; } return fact ; }
public static int CntDivbyX ( int [ ] arr , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( ( number % x ) == 0 ) ) { count ++ ; } } return count ; }
public static void main ( String [ ] args ) { final int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; final int [ ] a = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; final Map < Integer , Integer > map = new HashMap < > ( ) ; for ( int x : a ) { int c = 0 ; while ( x > 0 ) { c += x % 2 ; x /= 2 ; } map . put ( c , 1 ) ; } int ans = 0 ; for ( int v : map . values ( ) ) ans += v * ( v - 1 ) / 2 ; System . out . println ( ans ) ; if ( args . length == 0 ) { int t = 1 ; while ( t > 0 ) { System . out . println ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁
public static int minNoOf_operation ( int [ ] arr , int n , int k ) { long res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int noOfSubtraction = 0 ; if ( ( arr [ i ] > arr [ i - 1 ] ) ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) ) { noOfSubtraction ++ ; } arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return ( int ) res ; }
public static int CountSubSet ( int arr [ ] , int n , int X ) { int N = 2 * n ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { if ( ( arr [ j ] == X ) ) { count ++ ; } } } } return count ; }
public static int FindMaxProduct ( int [ ] [ ] arr , int n ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int result ; if ( ( ( j - 3 ) >= 0 ) ) { result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) ; if ( ( max < result ) ) { max = result ; } } if ( ( ( i - 3 ) >= 0 ) ) { result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) ; if ( ( max < result ) ) { max = result ; } } if ( ( ( i - 3 ) >= 0 ) && ( j - 3 ) >= 0 ) { result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) ; if ( ( max < result ) ) { max = result ; } } if ( ( ( i - 3 ) >= 0 ) && ( j - 1 ) <= 0 ) { result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ) ; if ( ( max < result ) ) { max = result ; } } } } return max ; }
public static int getPowerSum ( int [ ] array ) { int n = 0 ; int m = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = false ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else if ( array [ i ] == i ) { array [ i ] = true ; } else { array [ i ] = false ; } return array [ i ]
public static int smallestIndexsum ( int [ ] arr , int n ) { int i = n - 1 ; while ( ( i >= 0 ) && ( arr [ i ] % 2 == 1 ) ) { i -- ; } int sum = 0 ; for ( int j = 0 ; j <= i ; j ++ ) { sum += arr [ j ] ; } return sum ; }
public static int getDayFromDate ( String date ) { int res = 0 ; if ( date . contains ( " : " ) ) { return - 1 ; } if ( date . contains ( " : " ) ) { return - 1 ; } if ( date . contains ( " : " ) ) { return - 1 ; } if ( date . contains ( " : " ) ) { return - 1 ; } return res ; }
public static int getCountry ( String country ) { int country = country . indexOf ( ' A ' ) ; if ( country . indexOf ( ' C ' ) != - 1 ) { country = country . indexOf ( ' C ' ) ; country = country . substring ( 0 , country . indexOf ( ' C ' ) ) ; country = country . substring ( country . indexOf ( ' A ' ) , country . length ( ) ) ; } return country . indexOf ( ' C ' ) ; }
public static int getHashCode ( String input ) { final String [ ] inputMethods = { " clipboard " , " file " , " key " } ; int usingMethod = 0 ; String inputMethod = inputMethods [ usingMethod ] ; Method tin = new Method ( ) { public int invoke ( String s , int i ) { return Integer . parseInt ( s ) ; } } ; Method lin = new Method ( ) { public int invoke ( String s , int i , int j ) { return Collections . hashCode ( tin ) ; } } ; int mod = 1000000007 ; Method main = new Method ( " main " ) { int n = tin . invoke ( null ) ; int k = tin . invoke ( null ) ; int [ ] al = lin . invoke ( null , i , j ) ; Arrays . sort ( al , Collections . reverseOrder ( ) ) ; int ss = Arrays . stream ( al ) . parallel ( ) . count ( ) ; int [ ] arrive = new int [ k ] ; Arrays . fill ( arrive , 0 ) ; arrive [ 0 ] = 1 ; HashSet < Integer > usefulSet = new HashSet < > ( ) ; for ( int v : al ) { ss -= v ; int uMax = 0 ; if ( v >= k ) { usefulSet . add ( v ) ; continue ; } for ( int i = 0 ; i < arrive . length ; i ++ ) { final int p = k - i - 1 ; final int isOn = arrive [ p ] ; if ( isOn == 1 && p + v >= k ) { usefulSet . add ( v ) ; uMax = k ; } else if ( isOn == 1 ) { arrive [ p + v ] = 1 ; uMax = Math . max ( uMax , p + v ) ; } } if ( uMax + ss >= k ) { usefulSet . add ( v ) ; } } int ret = 0 ; for ( int v : al ) { if ( ! usefulSet . contains ( v ) ) { ret ++ ; } } boolean isTest = false ; Method pa = new Method ( " pa " , v ) { public int invoke ( String s ) { if ( isTest ) { System . out . println ( s ) ; } return ret ; } } ; Method inputClipboard = clipboard . invoke ( null , inputMethod ) ; String inputText = inputText . trim ( ) ; String input
public static int parseInt ( String input ) { int n = Integer . parseInt ( input ) , s = Integer . parseInt ( input ) ; int m = s / n ; if ( s % n == 0 ) { System . out . println ( m ) ; } else { System . out . println ( m + 1 ) ; } return m ; }
public static int multiply ( int [ ] v , int x ) { int carry = 0 ; int size = v . length ; for ( int i = 0 ; i < size ; i ++ ) { int res = carry + v [ i ] * x ; v [ i ] = res % 10 ; carry = res / 10 ; } while ( ( carry != 0 ) ) { v [ i ] = carry % 10 ; carry /= 10 ; } return v [ size ] ; }
public static String main ( String [ ] args ) { return nSpidersToSeeIn ( new String ( ) ) ; }
public static int [ ] getComponents ( int [ ] components ) { int n = 0 ; int m = 0 ; for ( int i = 0 ; i < components . length ; i ++ ) { out [ i ] = 0 ; } int [ ] comp = new int [ n ] ; for ( int i = 0 ; i < components . length ; i ++ ) { comp [ i ] = components [ i ] + 2 ; } for ( int i = 0 ; i < m ; i ++ ) { int l = components [ i ] ; int r = components [ i ] ; int x = components [ i ] ; int t = l ; while ( t <= r ) { int nextVal = comp [ t - 1 ] ; if ( out [ t - 1 ] == 0 && t != x ) { out [ t - 1 ] = x ; } comp [ t - 1 ] = t >= x ? r + 1 : x ; t = nextVal ; } } return out ; }
public static int [ ] getNegativeInstances ( ) { int [ ] arr = new int [ n ] ; Arrays . sort ( arr ) ; int [ ] ans = new int [ n ] ; int mx = arr [ arr . length - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { ans [ i ] = Math . max ( 0 , mx - arr [ i ] + 1 ) ; if ( arr [ i ] > mx ) { mx = arr [ i ] ; } } return ans ; }
public static int pell ( int n ) { if ( ( n <= 2 ) ) { return n ; } return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) ; }
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static int binarySearch ( int [ ] arr , int low , int high , int ele ) { while ( low < high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == ele ) { return mid ; } else if ( arr [ mid ] > ele ) { high = mid ; } else { low = mid + 1 ; } } return - 1 ; }
static int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( ( n > 0 ) ) { if ( ( ( n & 1 ) == 0 ) ) { count += Math . pow ( 2 , k ) ; } k ++ ; n >>= 1 ; } return count ; }
public static int getPrice ( ) { int R = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int bestBuy = Math . min ( Integer . parseInt ( System . getProperty ( " user . name " ) ) , 1 ) ; int bestSell = Math . max ( Integer . parseInt ( System . getProperty ( " user . name " ) ) , 1 ) ; int numBuy = R / bestBuy ; return Math . max ( R , R + ( bestSell - bestBuy ) * numBuy ) ; }
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static int maxCount ( String strr , int [ ] freq ) { int lenn = strr . length ( ) ; for ( int i = 0 ; i < lenn ; i ++ ) { freq [ ( int ) strr . charAt ( i ) - ( int ) ' a ' ] ++ ; } return maxCount ( strr , patt ) ; }
public static int getUnsignedInt ( String input ) { int n = Integer . parseInt ( input ) ; int a = Integer . parseInt ( input . replace ( " ▁ " , " | " ) ) ; int b = Integer . parseInt ( input . replace ( " ▁ " , " | " ) ) ; return a + b ; }
public static int getCost ( int [ ] a , int [ ] b ) { int cost = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { cost += a [ i ] * a [ i ] * b [ i ] ; } return cost ; }
public static int wastedWater ( int V , int M , int N ) { int amtPerMin = M - N ; int timeToFill = V / amtPerMin ; int wastedAmt = N * timeToFill ; return wastedAmt ; }
public static int maxSubStr ( String str , int n ) { int count0 = 0 ; int count1 = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) { count0 ++ ; } else { count1 ++ ; } if ( count0 == count1 ) { cnt ++ ; } } if ( count0 != count1 ) { return - 1 ; } return cnt ; } str = "0100110101" ; n = str . length ( ) ; System . out . println ( maxSubStr ( str , n ) ) ; return 0 ; }
public static int min ( int a , int b , int c ) { return Math . min ( a , b ) ; }
static int findS ( int s ) { int _sum = 0 ; int n = 1 ; while ( ( _sum = _sum ) < s ) { _sum += n ; n ++ ; } n -- ; if ( _sum == s ) { return n ; } return - 1 ; } s = 15 ; n = findS ( s ) ; if ( n == - 1 ) { System . out . println ( " - 1" ) ; } else { System . out . println ( n ) ; } }
public static int maximumAbsolute ( int [ ] arr , int n ) { int mn = 10 * 9 ; int mx = - 10 * 9 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i > 0 ) && ( arr [ i ] == - 1 ) && ( arr [ i - 1 ] != - 1 ) ) { mn = Math . min ( mn , arr [ i - 1 ] ) ; mx = Math . max ( mx , arr [ i - 1 ] ) ; } if ( ( i < n - 1 ) && ( arr [ i ] == - 1 ) && ( arr [ i + 1 ] != - 1 ) ) { mn = Math . min ( mn , arr [ i + 1 ] ) ; mx = Math . max ( mx , arr [ i + 1 ] ) ; } } int commonInteger = ( mn + mx ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] == - 1 ) ) { arr [ i ] = commonInteger ; } } int maxDiff = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; if ( ( diff > maxDiff ) ) { maxDiff = diff ; } } return maxDiff ; }
public static int countStrings ( int N ) { int [ ] [ ] dp = new int [ N + 1 ] [ 3 ] ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } int ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
public static int longestSubseq ( int n , int k , String s ) { int [ ] dp = new int [ n ] ; int [ ] maxLength = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int curr = ( int ) s . charAt ( i ) - ( int ) ' a ' ; int lower = Math . max ( 0 , curr - k ) ; int upper = Math . min ( 25 , curr + k ) ; for ( int j = lower ; j <= upper ; j ++ ) dp [ i ] = Math . max ( dp [ i ] , maxLength [ j ] + 1 ) ; maxLength [ curr ] = Math . max ( dp [ i ] , maxLength [ curr ] ) ; } return Math . max ( dp [ n ] , maxLength [ n ] ) ; }
public static int longestFibonacciSubarray ( int n , int [ ] a ) { if ( ( n <= 2 ) ) { return n ; } int Len = 2 ; int mx = - 10 * 9 ; for ( int i = 2 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) ) { Len ++ ; } else { Len = 2 ; } mx = Math . max ( mx , Len ) ; } return mx ; }
public static int minimumSubarrays ( int [ ] ar , int n ) { ArrayList < Integer > se = new ArrayList < > ( ) ; int cnt = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( se . indexOf ( ar [ i ] ) == 0 ) { se . add ( ar [ i ] ) ; } else { cnt ++ ; se . clear ( ) ; se . add ( ar [ i ] ) ; } } return cnt ; }
public static boolean check ( int s ) { int [ ] freq = new int [ 10 ] ; while ( ( s != 0 ) ) { int r = s % 10 ; s = s / 10 ; freq [ r ] ++ ; } int xor = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { xor = xor ^ freq [ i ] ; } if ( ( xor == 0 ) ) { return true ; } else { return false ; } } s = 122233 ; if ( ( check ( s ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
public static final int a ( String input ) { int [ ] days = Integer . parseInt ( input . trim ( ) ) ; int names = 0 ; int lists = 0 ; for ( int i = 0 ; i < days . length ; i ++ ) { names += days [ i ] ; System . out . print ( names / a - lists ) ; lists += names / a - lists ; } return lists ; }
public static int [ ] getNegativeArray ( int [ ] array ) { int [ ] a = { 2 , 1 , 5 , 7 , 6 , 8 , 9 } ; int [ ] [ ] q = { { 0 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , { 2 , 4 , 4 , 5 , 6 , 8 , 9 } , { 2 , 4 , 4 , 5 , 6 , 8 , 9 } , { 2 , 4 , 4 , 4 , 5 , 6 } } ; }
public static int test ( String input ) { int tests = Integer . parseInt ( input ) ; for ( ; tests > 0 ; tests -- ) { int windows = Integer . parseInt ( input ) ; boolean test = true ; for ( int k = 0 ; k < ( windows / 3 + 1 ) ; k ++ ) { if ( test ) { for ( int j = 0 ; j < ( windows / 5 + 1 ) ; j ++ ) { if ( test ) { for ( int i = 0 ; i < ( windows / 7 + 1 ) ; i ++ ) { if ( i * 7 + j * 5 + k * 3 == windows ) { System . out . println ( k + " ▁ " + j + " ▁ " + i ) ; test = false ; break ; } } } } } } } if ( test ) { System . out . println ( - 1 ) ; } return tests ; }
public static int solve ( int m , int n , int o , int p , String hhmm ) { int h = ( int ) ( hhmm . charAt ( 0 ) + hhmm . charAt ( 1 ) ) ; m = ( int ) ( hhmm . charAt ( 3 ) + hhmm . charAt ( 4 ) ) ; int lft = h * 60 + m ; int rt = lft + n ; int i = 30 * 10 ; int ans = 0 ; while ( i < 1440 ) { if ( i < rt && i + p > lft ) { ans ++ ; } i += o ; } return ans ; m = ( int ) ( System . in . nextInt ( ) ) ; n = ( int ) ( System . in . nextInt ( ) ) ; o = ( int ) ( System . in . nextInt ( ) ) ; p = ( int ) ( System . in . nextInt ( ) ) ; hhmm = ( System . in . nextInt ( ) ) ; return ( solve ( m , n , o , p , hhmm ) ) ; }
public static int sum ( int [ ] array ) { int sum = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { sum += array [ i ] ; } return sum ; }
public static int times ( int [ ] steps , int n ) { int currentLevel = 0 ; int previousLevel = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previousLevel = currentLevel ; currentLevel = currentLevel + steps [ i ] ; if ( ( ( previousLevel < 0 && currentLevel >= 0 ) || ( previousLevel > 0 && currentLevel <= 0 ) ) ) { count ++ ; } } return count ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ D ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = 0 ; } int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int m = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int d = Integer . parseInt ( System . getProperty ( " user . version " ) ) ; int v = Integer . parseInt ( System . getProperty ( " user . version " ) ) ; int s = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; m -- ; d -- ; int start = 30 * m + d ; int end = ( start + v - 1 ) % D ; boolean [ ] h = new boolean [ D ] ; for ( int j = 0 ; j < v ; j ++ ) { int y = ( start + j ) % D ; h [ y ] = true ; } for ( int j = 0 ; j < D ; j ++ ) { if ( h [ j ] ) { array [ j ] = Math . max ( array [ j ] , s ) ; } else { int A = Math . abs ( start - j ) ; if ( A > D / 2 ) { A = D - A ; } int B = Math . abs ( end - j ) ; if ( B > D / 2 ) { B = D - B ; } array [ j ] = Math . max ( array [ j ] , s - Math . min ( A , B ) ) ; } } } System . out . println ( Arrays . toString ( array ) ) ; return array ; }
public static void print ( String [ ] args ) { System . out . println ( new String ( " Um _ nik " , " Petr " ) . split ( " ▁ " ) [ Integer . parseInt ( args [ 0 ] ) / 1000 <= Integer . parseInt ( args [ 1 ] ) ) ; }
public static String smallest ( String s ) { int l = s . length ( ) ; String ans = " " ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( s . charAt ( i ) ) > s . charAt ( i + 1 ) ) { for ( int j = 0 ; j < l ; j ++ ) { if ( ( i != j ) ) { ans += s . charAt ( j ) ; } } return ans ; } } ans = s . substring ( 0 , l - 1 ) ; return ans ; }
public static int getGreatestSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSinessForSine
public static int FindMinNumber ( int [ ] arr , int n , int k ) { int i = 0 ; int j = 0 ; int minNum = 10 * 9 ; boolean found = false ; int Sum = 0 ; while ( ( i < n ) ) { Sum = Sum + arr [ i ] ; if ( ( Sum == k ) ) { minNum = Math . min ( minNum , ( ( n - ( i + 1 ) ) + j ) ) ; found = true ; } else if ( ( Sum > k ) ) { while ( ( Sum > k ) ) { Sum = Sum - arr [ j ] ; j ++ ; } if ( ( Sum == k ) ) { minNum = Math . min ( minNum , ( ( n - ( i + 1 ) ) + j ) ) ; found = true ; } } i ++ ; } if ( ( found ) ) { return minNum ; } return - 1 ; } arr = new int [ ] { 1 , 3 , 2 , 5 , 6 } ; n = arr . length ; k = 5 ; System . out . println ( FindMinNumber ( arr , n , k ) ) ; }
public static int sum ( int [ ] a , int [ ] b ) { return Arrays . stream ( a ) . sum ( b ) ; }
public static void nthPalindrome ( int n , int k ) { int temp ; if ( ( k & 1 ) != 0 ) { temp = k / 2 ; } else { temp = k / 2 - 1 ; } int palindrome = 10 * temp ; palindrome = palindrome + n - 1 ; System . out . print ( palindrome ) ; if ( ( k & 1 ) != 0 ) { palindrome = palindrome / 10 ; } while ( ( palindrome = palindrome ) != 0 ) { System . out . print ( palindrome % 10 ) ; palindrome = palindrome / 10 ; } if ( Class . forName ( " java . util . regex . regex . regex " ) . equals ( " java . util . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex
public static int [ ] getNegativeInstances ( ) { int [ ] values = new int [ 2 ] ; for ( int i = 0 ; i < values . length ; i ++ ) { values [ i ] = i ; } int N = values [ 0 ] ; int X = values [ 1 ] ; int [ ] Xs = values [ 2 ] ; int [ ] Ys = Xs . clone ( ) ; Arrays . sort ( Ys ) ; for ( int i = 0 ; i < N ; i ++ ) { Ys [ i ] = Ys [ i ] ; } int [ ] ysum = new int [ N ] ; ysum [ 0 ] = Ys [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { ysum [ i ] = ysum [ i - 1 ] + Ys [ i ] ; } int ans = 1e100 ; for ( int repNum = 1 ; repNum <= N ; repNum ++ ) { int localAns = X * repNum ; localAns += 5 * ysum [ repNum - 1 ] ; int i = 2 * repNum - 1 ; int n = 1 ; while ( i <= N - 1 ) { localAns += ( 2 * n + 3 ) * ( ysum [ i ] - ysum [ i - repNum ] ) ; n ++ ; i += repNum ; } localAns += ( 2 * n + 3 ) * ( ysum [ N - 1 ] - ysum [ i - repNum ] ) ; ans = Math . min ( ans , localAns ) ; } return ans ; }
public static int minOperations ( int [ ] arr , int n ) { int [ ] hashTable = new int [ MAX ] ; Arrays . fill ( arr , 0 , n , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { hashTable [ arr [ i ] ] ++ ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( hashTable [ arr [ i ] ] = 0 ) != 0 ) { for ( int j = i ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] ) == 0 ) { hashTable [ arr [ j ] ] = 0 ; } } } res ++ ; } return res ; }
public static int min ( int p1 , int p2 , int p3 , int p4 , int a , int b ) { int [ ] array = new int [ ] { p1 , p2 , p3 , p4 } ; int [ ] array = new int [ ] { p2 , p3 , p4 } ; int [ ] array = new int [ ] { p3 , p4 } ; int [ ] array = new int [ ] { p4 } ; for ( int i = 0 ; i < array . length ; i ++ ) array [ i ] = array [ i ] ; return array [ 0 ] ; }
public static String compute ( ) { int numer = 1 ; int denom = 1 ; for ( int d = 10 ; d < 100 ; d ++ ) { for ( int n = 10 ; n < d ; n ++ ) { int n0 = n % 10 ; int n1 = n / 10 ; int d0 = d % 10 ; int d1 = d / 10 ; if ( ( n1 == d0 && n0 * d == n * d1 ) || ( n0 == d1 && n1 * d == n * d0 ) ) { numer *= n ; denom *= d ; } } } return String . valueOf ( denom / Math . gcd ( numer , denom ) ) ; }
static int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
public static void for ( final String s : new String [ ] { s } ) { int a = Integer . parseInt ( s ) ; int b = Integer . parseInt ( s ) ; int x = Integer . parseInt ( s ) ; int y = Integer . parseInt ( s ) ; System . out . println ( Math . max ( b * x , b * ( a - x - 1 ) , a * y , a * ( b - y - 1 ) ) ) ; }
public static int minSwaps ( int [ ] arr ) { int n = arr . length ; int [ ] [ ] arrpos = new int [ n ] [ n ] ; Arrays . sort ( arrpos , new Comparator < int [ ] > ( ) { public int compare ( int [ ] it , int [ ] o1 ) { return it [ 1 ] - it [ 0 ] ; } } ) ; Map < Integer , Boolean > vis = new HashMap < > ( ) ; for ( int k = 0 ; k < n ; k ++ ) { vis . put ( k , Boolean . FALSE ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis . get ( i ) || arrpos [ i ] [ 0 ] == i ) continue ; int cycleSize = 0 ; int j = i ; while ( ! vis . get ( j ) ) { vis . put ( j , Boolean . TRUE ) ; j = arrpos [ j ] [ 0 ] ; cycleSize ++ ; } if ( cycleSize > 0 ) ans += ( cycleSize - 1 ) ; } return ans ; arr = new int [ ] { 1 , 5 , 4 , 3 , 2 } ; System . out . println ( minSwaps ( arr ) ) ; return arr . length ; }
public static int sumTruncatablePrimes ( int n ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { prime [ i ] = true ; } int i ; for ( i = 2 ; i < N ; i ++ ) { if ( ( prime [ i ] == true ) ) { for ( int j = i * 2 ; j < N ; j += i ) { prime [ j ] = false ; } } } return sum ; }
static void findWeights ( int X ) { int sum = 0 ; int power = 0 ; while ( ( sum = sum / X ) < X ) { sum = Math . pow ( 3 , power + 1 ) - 1 ; sum /= 2 ; power ++ ; } int ans = 1 ; for ( int i = 1 ; i <= power ; i ++ ) { System . out . print ( ans + " ▁ " ) ; ans = ans * 3 ; } X = 2 ; findWeights ( X ) ; }
public static int [ ] addToArrayForm ( int [ ] A , int K ) { int [ ] v = new int [ A . length ] , ans = new int [ A . length ] ; int rem , i = 0 ; for ( i = A . length - 1 ; i >= 0 ; i -- ) { int my = A [ i ] + ( K % 10 ) + rem ; if ( my > 9 ) { rem = 1 ; v [ i ] = my % 10 ; } else { v [ i ] = my ; rem = 0 ; } K = K / 10 ; } while ( K > 0 ) { my = ( K % 10 ) + rem ; v [ i ] = my % 10 ; if ( my / 10 > 0 ) { rem = 1 ; } else { rem = 0 ; } K = K / 10 ; } if ( rem > 0 ) { v [ i ] = rem ; } for ( i = v . length - 1 ; i >= 0 ; i -- ) { ans [ i ] = v [ i ] ; } return ans ; }
public static void printPaths ( char inputchar [ ] [ ] , int R , int C ) { for ( int i = 0 ; i < C ; i ++ ) { dfs ( inputchar , " " , 0 , i , R , C ) ; System . out . println ( ) ; } }
public static int [ ] assignRoom ( String direction , int [ ] hotel ) { if ( direction . equals ( " L " ) ) { for ( int x = 0 ; x < 10 ; x ++ ) { if ( hotel [ x ] == 0 ) { hotel [ x ] = "1" ; return hotel ; } } } else if ( direction . equals ( " R " ) ) { for ( int x = 9 ; x >= 0 ; x -- ) { if ( hotel [ x ] == 0 ) { hotel [ x ] = "1" ; return hotel ; } } } else { hotel [ Integer . parseInt ( direction ) ] = 0 ; return hotel ; } int [ ] rooms = new int [ 10 ] ; int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; String [ ] instructions = System . getProperty ( " user . instructions " ) ; for ( String s : instructions ) { assignRoom ( s , rooms ) ; } for ( String s : rooms ) { System . out . print ( s ) ; } return rooms ; }
public static void printLine ( String line ) { for ( int i = 0 ; i < line . length ( ) ; i ++ ) { line = line . substring ( i , i + 1 ) ; } int a = line . indexOf ( ' ▁ ' ) ; int b = line . indexOf ( ' ▁ ' ) ; int a1 = line . indexOf ( ' ▁ ' ) ; int b1 = line . indexOf ( ' ▁ ' ) ; if ( Math . max ( a , b ) == Math . max ( a1 , b1 ) ) { if ( Math . min ( a , b ) + Math . min ( a1 , b1 ) == Math . max ( a , b ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { System . out . println ( " NO " ) ; } }
static void precisionCompute ( int x , int y , int n ) { if ( y == 0 ) { System . out . println ( " Infinite " ) ; return ; } if ( x == 0 ) { System . out . println ( 0 ) ; return ; } if ( n <= 0 ) { System . out . println ( x / y ) ; return ; } if ( ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) ) { System . out . print ( " - " ) ; if ( x <= 0 ) { x = - x ; } if ( y <= 0 ) { y = - y ; } } int d = x / y ; for ( int i = 0 ; ; i <= n ; i ++ ) { System . out . print ( d ) ; x = x - ( y * d ) ; if ( x == 0 ) { break ; } x = x * 10 ; d = x / y ; if ( ( i == 0 ) ) { System . out . print ( " . " ) ; } } x = 22 ; y = 7 ; n = 15 ; precisionCompute ( x , y , n ) ; System . out . println ( ) ; }
public static int gcd ( int a , int b ) { if ( ( b == 0 ) ) { return a ; } else { return gcd ( b , a % b ) ; } int [ ] arr = { 0 , n } ; int lcmOfArray = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { lcmOfArray = ( lcmOfArray * arr [ i ] ) / gcd ( lcmOfArray , arr [ i ] ) ; } return lcmOfArray ; }
public static void printSpecificLevelOrder ( int [ ] key ) { ArrayList < Integer > s = new ArrayList ( ) ; ArrayList < Integer > q = new ArrayList ( ) ; int elements = 0 ; { int data = key . length ; int left = 0 ; int right = 0 ; } public void printSpecificLevelOrder ( int root ) { s . add ( root ) ; int prnt = s . remove ( 0 ) ; q . add ( prnt ) ; if ( prnt . right != 0 ) s . add ( root . right ) ; if ( prnt . left != 0 ) s . add ( root . left ) ; while ( ( elements = s . size ( ) ) > 0 ) { int first = s . remove ( 0 ) ; q . add ( first ) ; int second = s . remove ( 0 ) ; q . add ( second ) ; if ( first . left != 0 && second . right != 0 && first . right != 0 && second . left != 0 ) { s . add ( first ) ; s . add ( second ) ; s . add ( first ) ; s . add ( second ) ; s . add ( second ) ; } } } for ( elements = q . size ( ) ; elements > 0 ; elements -- ) System . out . print ( elements + " ▁ " ) ; }
public static void hollowSquare ( int rows ) { for ( int i = 1 ; i <= rows ; i ++ ) { if ( ( i == 1 ) || i == rows ) { for ( int j = 1 ; j <= rows ; j ++ ) { System . out . print ( " * " ) ; } } else { for ( int j = 1 ; j <= rows ; j ++ ) { if ( ( j == 1 ) || j == rows ) { System . out . print ( " * " ) ; } else { System . out . print ( " ▁ " ) ; } } } System . out . println ( ) ; } }
public static int getRandom ( ) { final Random random = new Random ( ) ; final int [ ] array = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = random . nextInt ( array . length ) ; } return array [ array . length - 1 ] ; }
public static int [ ] getNegativeInstances ( ) { int [ ] values = new int [ 2 ] ; int [ ] inlsts = new int [ 2 ] ; for ( int i = 0 ; i < inlsts . length ; i ++ ) { inlsts [ i ] = i ; } for ( int i = 0 ; i < inlsts . length ; i ++ ) { inlsts [ i ] = inlsts [ i ] ; } for ( int i = 0 ; i < inlsts . length ; i ++ ) { inlsts [ i ] = inlsts [ i ] ; } for ( int i = 0 ; i < words . length ; i ++ ) { words [ i ] = words [ i ] ; chars [ i ] = chars [ i ] ; } return inlsts ; }
public static void main ( String [ ] args ) { String input = System . getProperty ( " user . name " ) ; String [ ] result = new String [ args . length ] ; for ( int i = 0 ; i < args . length ; i ++ ) { result [ i ] = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; } System . out . println ( result [ args . length - 1 ] ) ; }
public static int findLargest ( int [ ] arr , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { gcd = gcd ( arr [ i ] , gcd ) ; } return gcd ; }
static void findWinner ( int n ) { if ( ( ( n - 1 ) % 6 ) == 0 ) { System . out . println ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) ; } else { System . out . println ( " First ▁ Player ▁ wins ▁ the ▁ game " ) ; } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { n = 7 ; findWinner ( n ) ; } }
@ java . lang . SuppressWarnings ( " unchecked " ) public static void BFS ( int s ) { java . util . Map < Integer , Integer > graph = new java . util . HashMap < > ( ) ; java . util . Iterator < Integer > it = graph . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { it . next ( ) ; } while ( it . hasNext ( ) ) { if ( it . hasNext ( ) ) { it . next ( ) ; } else { it . remove ( ) ; } } if ( ! visited . containsKey ( s ) ) { visited . put ( s , true ) ; } java . util . PriorityQueue < Integer > queue = new java . util . PriorityQueue < > ( ) ; queue . add ( s ) ; visited . put ( s , true ) ; while ( queue . size ( ) > 0 ) { s = queue . remove ( 0 ) ; System . out . print ( s + " ▁ " ) ; for ( Integer i : graph . get ( s ) ) { if ( visited . get ( i ) == false ) { queue . add ( i ) ; visited . put ( i , true ) ; } } } }
@ java . lang . SuppressWarnings ( " unchecked " ) public static void BFS ( int s ) { java . util . Map < Integer , Integer > graph = new java . util . HashMap < > ( ) ; java . util . Iterator < Integer > it = graph . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { it . next ( ) ; } while ( it . hasNext ( ) ) { if ( it . hasNext ( ) ) { it . next ( ) ; } else { it . remove ( ) ; } } if ( ! visited . containsKey ( s ) ) { visited . put ( s , true ) ; } java . util . PriorityQueue < Integer > queue = new java . util . PriorityQueue < > ( ) ; queue . add ( s ) ; visited . put ( s , true ) ; while ( queue . size ( ) > 0 ) { s = queue . remove ( 0 ) ; System . out . print ( s + " ▁ " ) ; for ( Integer i : graph . get ( s ) ) { if ( visited . get ( i ) == false ) { queue . add ( i ) ; visited . put ( i , true ) ; } } } }
static void getElements ( int a , int [ ] arr , int n ) { int [ ] elements = new int [ n + 1 ] ; elements [ 0 ] = 1 ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) { System . out . print ( elements [ i ] + " ▁ " ) ; } }
public static String solve ( int R , int P , int S ) { final String res ; if ( ( R < 0 || P < 0 || S < 0 ) ) { return " IMPOSSIBLE " ; } if ( R + P + S == 1 ) { return ( R > 0 ) ? ' R ' : ( P > 0 ) ? ' P ' : ' S ' ; } final int Rn = ( R + S - P ) / 2 , Pn = ( P - S + R ) / 2 , Sn = ( - R + S + P ) / 2 ; if ( ( Rn > R || Pn > P || Sn > S ) ) { return " IMPOSSIBLE " ; } res = solve ( Rn , Pn , Sn ) ; if ( res . equals ( " IMPOSSIBLE " ) ) { return " IMPOSSIBLE " ; } else { final StringBuffer nres = new StringBuffer ( ) ; final char [ ] m = { ' R ' , ' RS ' , ' S ' , ' SP ' , ' P ' , ' PR ' } ; for ( final char c : res ) { nres . append ( m [ c ] ) ; } return nres . toString ( ) ; } } else { if ( S . equals ( " IMPOSSIBLE " ) ) { return S ; } final int l = S . length ( ) ; if ( l > 1 ) { final StringBuffer Sl = asort ( S . substring ( 0 , l / 2 ) ) ; final StringBuffer Sh = asort ( S . substring ( l / 2 ) ) ; S = Sl . compareTo ( Sh ) < 0 ? Sl + Sh : Sh + Sl ; } return S ; } if ( Class . isPrimitive ( " java . util . regex . regex " ) ) { final int T = Integer . parseInt ( System . getProperty ( " java . util . regex . regex " ) ) ; for ( int t = 0 ; t < T ; t ++ ) { final int N = Integer . parseInt ( System . getProperty ( " java . util . regex . regex " ) ) ; final int R = Integer . parseInt ( System . getProperty ( " R . " ) ) ; final int P = Integer . parseInt ( System . getProperty ( " P . " ) ) ; final int S = Integer . parseInt ( System . getProperty ( " S . " ) ) ; System .
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = i ; } return array ; }
public static int printRepeating ( int [ ] arr , int size ) { int S = 0 ; int P = 1 ; int n = size - 2 ; for ( int i = 0 ; i <= size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; double D = Math . sqrt ( S * S - 4 * P ) ; int x = ( D + S ) / 2 ; int y = ( S - D ) / 2 ; System . out . println ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : " + ( ( int ) x ) + " & " + ( ( int ) y ) ) ; }
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static double atan2 ( double x , double y ) { int N = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int [ ] XY = new int [ N ] ; Arrays . fill ( XY , ( int ) Math . pow ( 2 , Math . PI ) ) ; for ( int i = 0 ; i < XY . length ; i ++ ) { final double [ ] D = new int [ XY [ i ] ] ; for ( int j = 0 ; j < XY [ i ] ; j ++ ) { final double [ ] X = XY [ i ] ; final double [ ] Y = XY [ i ] ; if ( j != i ) { D [ j ] = Math . atan2 ( X [ j ] , Y [ j ] ) ; } } D [ i ] = D [ 0 ] + 2 * Math . PI ; double ans = 0 ; for ( int j = 1 ; j < D . length ; j ++ ) { final double a = D [ j ] ; final double b = D [ j ] ; if ( b - a >= Math . PI ) { ans = ( b - a ) - Math . PI ; } } System . out . println ( ans / ( 2 * Math . PI ) ) ; } return Math . sqrt ( ans ) ; }
public static String getLetter ( String s ) { if ( s . length ( ) == 0 ) { return " " ; } else if ( s . length ( ) == 1 ) { return " " ; } else if ( s . length ( ) == 2 ) { return " " ; } else if ( s . length ( ) == 3 ) { return " " ; } else if ( s . length ( ) == 4 ) { return " " ; } else if ( s . length ( ) == 5 ) { return " " ; } else if ( s . length ( ) == 6 ) { return " " ; } else if ( s . length ( ) == 7 ) { return " " ; } else if ( s . length ( ) == 8 ) { return " " ; } else if ( s . length ( ) == 9 ) { return " " ; } else if ( s . length ( ) == 10 ) { return " " ; } else if ( s . length ( ) == 11 ) { return " " ; } else if ( s . length ( ) == 12 ) { return " " ; } else if ( s . length ( ) == 12 ) { return " " ; } else if ( s . length ( ) == 5 ) { return " " ; } else if ( s . length ( ) == 4 ) { return " " ; } else if ( s . length ( ) == 5 ) { return " " ; } else if ( s . length ( ) == 6 ) { return " " ; } else if ( s . length ( ) == 7 ) { return " " ; } else if ( s . length ( ) == 8 ) { return " " ; } else if ( s . length ( ) == 9 ) { return " " ; } else if ( s . length ( ) == 10 ) { return " " ; } else if ( s . length ( ) == 11 ) { return " " ; } else if ( s . length ( ) == 12 ) { return " " ; } else if ( s . length ( ) == 4 ) { return " " ; } else if ( s . length ( ) == 5 ) { return " " ; } else if ( s . length ( ) == 6 ) { return " " ; } else if ( s . length ( ) == 7 ) { return " " ; } else if ( s . length ( ) == 8 ) { return " " ; else if ( s . length ( ) ==
public static String getSuffix ( String suffix ) { return suffix . substring ( suffix . lastIndexOf ( ' . ' ) + 1 ) ; }
public static int [ ] bigres ( int t ) { int [ ] bigres = new int [ t ] ; int n = Integer . parseInt ( input ( ) ) ; for ( int m = 0 ; m < t ; m ++ ) { n = Integer . parseInt ( input ( ) ) ; int [ ] a = Integer . parseInt ( input ( ) . trim ( ) ) ; int res = a [ 0 ] * a [ 1 ] ; for ( int q = 0 ; q < a . length - 1 ; q ++ ) { res = Math . max ( res , ( a [ q ] * a [ q + 1 ] ) ) ; } bigres [ m ] = res ; } for ( int i = 0 ; i < bigres . length ; i ++ ) { System . out . println ( bigres [ i ] ) ; } return bigres ; }
public static int gcd ( int x , int y ) { int gcd ; int small = y ; if ( x > y ) { small = x ; } else { small = x ; } for ( int i = 1 ; i <= small ; i ++ ) { if ( ( ( x % i ) == 0 ) && ( ( y % i ) == 0 ) ) { gcd = i ; } } return gcd ; }
public static String getCountry ( String country ) { String country = country . toLowerCase ( ) ; if ( country . indexOf ( ' _ ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' _ ' ) ) ; } return country ; }
@ VisibleForTesting static int smallestKFreq ( int [ ] arr , int n , int k ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( arr [ i ] , 1 ) ; } int res = Integer . MAX_VALUE ; int res1 = Integer . MIN_VALUE ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( entry . getValue ( ) == k ) { res = Math . min ( res , entry . getKey ( ) ) ; } } return res != res1 ? res : - 1 ; }
public static boolean areVowelsInOrder ( String s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == ' a ' ) || ( s . charAt ( i ) == ' e ' ) || ( s . charAt ( i ) == ' i ' ) || ( s . charAt ( i ) == ' o ' ) || ( s . charAt ( i ) == ' u ' ) ) { if ( s . charAt ( i ) < c ) { return false ; } else { c = s . charAt ( i ) ; } } } return true ; }
public static int [ ] getNegativeInstances ( int [ ] values ) { int [ ] array = new int [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { array [ i ] = values [ i ] ; } for ( int i = 0 ; i < values . length ; i ++ ) { array [ i ] = values [ i ] ; } for ( int i = 0 ; i < values . length ; i ++ ) { array [ i ] = values [ i ] ; } for ( int i = 0 ; i < values . length ; i ++ ) { array [ i ] = values [ i ] ; } for ( int i = 0 ; i < values . length ; i ++ ) { array [ i ] = values [ i ] ; } return array ; }
public static int countOfLetters ( String string ) { int letter = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( ( ( string . charAt ( i ) >= ' A ' && string . charAt ( i ) <= ' Z ' ) || ( string . charAt ( i ) >= ' a ' && string . charAt ( i ) <= ' z ' ) ) { letter ++ ; } } return letter ; }
public static int [ ] getNegativeInstances ( ) { int [ ] result = new int [ 100 ] ; int i = 0 ; for ( ; i < 100 ; i ++ ) { result [ i ] = i ; } return result ; }
public static int getN ( String input ) { int N = Integer . parseInt ( input ) , x = Integer . parseInt ( input ) ; if ( x == 1 || x == 2 * N - 1 ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; List < Integer > l = new ArrayList < > ( ) ; for ( int i = 1 ; i <= 2 * N ; i ++ ) l . add ( i ) ; l . remove ( x - 1 ) ; l . remove ( x ) ; l . remove ( x + 1 ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) { System . out . println ( l . get ( i ) ) ; } System . out . println ( x - 1 ) ; System . out . println ( x ) ; System . out . println ( x + 1 ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) { System . out . println ( l . get ( N - 2 + i ) ) ; } } return x ; }
public static int [ ] getPerfectDivisors ( int [ ] perfectDivisors ) { int MAX = 100001 ; int [ ] perfectDiv = new int [ MAX ] ; { precomputeCounts ( ) ; int i = 1 ; while ( i * i < MAX ) { for ( int j = i * i ; j < MAX ; j += i * i ) { perfectDiv [ j ] ++ ; } i ++ ; } } { return perfectDiv [ perfectDivisors . length ] ; } if ( Class . isPrimitive ( ) ) { precomputeCounts ( ) ; int n = 16 ; System . out . println ( " Total ▁ perfect ▁ divisors ▁ of " + n + " = " + countPerfectDivisors ( n ) ) ; n = 12 ; System . out . println ( " Total ▁ perfect ▁ divisors ▁ of " + n + " = " + countPerfectDivisors ( n ) ) ; } return perfectDiv ; }
public static int getM ( ) { int [ ] A = new int [ ] { } ; int [ ] B = new int [ ] { } ; for ( int i = 0 ; i < A . length ; i ++ ) { A [ i ] = A [ i ] ; B [ i ] = B [ i ] ; } return A . length ; }
public static int getDay ( int [ ] arr ) { int n = 0 ; int t = arr [ 0 ] ; int e = arr [ 1 ] ; int xarr [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { xarr [ i ] = arr [ i ] ; } for ( int i = 0 ; i < arr . length ; i ++ ) { int a = ( t - e - 1 ) / arr [ i ] ; if ( ( a + 1 ) * arr [ i ] <= t + e ) { System . out . println ( i + 1 ) ; break ; } } return ( int ) ( n * arr [ 0 ] + arr [ 1 ] + arr [ 2 ] + arr [ 3 ] ) ; }
public static void calIST ( int h , int r ) { double IST = Math . round ( ( h * r * 1.0 ) / 360 ) ; int intIST = ( int ) IST ; double floatIST = Math . ceil ( ( IST - intIST ) * 60 ) ; System . out . println ( intIST + " : " + floatIST ) ; }
public static void printRoots ( int n ) { final double theta = Math . PI * 2 / n ; for ( int k = 0 ; k <= n ; k ++ ) { double real = Math . cos ( k * theta ) ; double img = Math . sin ( k * theta ) ; System . out . print ( real + " ▁ " ) ; if ( ( img >= 0 ) ) { System . out . print ( " ▁ + ▁ i ▁ " ) ; } else { System . out . print ( " ▁ - ▁ i ▁ " ) ; } System . out . println ( Math . abs ( img ) ) ; } }
static void findCart ( int arr1 [ ] , int arr2 [ ] , int n , int n1 ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n1 ; j ++ ) { System . out . print ( " { " + arr1 [ i ] + " , ▁ " + arr2 [ j ] + " } , ▁ " ) ; } } }
public static int noOfWays ( String s ) { int n = s . length ( ) ; int countLeft = 0 ; int countRight = 0 ; for ( int i = 0 ; i <= n ; i += 1 ) { if ( ( s . charAt ( i ) == s . charAt ( 0 ) ) ) { countLeft ++ ; } else { break ; } } int i = n - 1 ; while ( ( i >= 0 ) && ( s . charAt ( i ) == s . charAt ( n - 1 ) ) ) { countRight ++ ; } else { break ; } i -- ; } if ( ( s . charAt ( 0 ) == s . charAt ( n - 1 ) ) ) { return ( ( countLeft + 1 ) * ( countRight + 1 ) ) ; } else { return ( countLeft + countRight + 1 ) ; } }
public static void sumOfKthPrimes ( int [ ] arr , int n , int k ) { int MAX = 100000 ; boolean [ ] prime = new boolean [ MAX + 1 ] ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; Arrays . fill ( prime , true ) ; }
public static void SieveOfEratosthenes ( ) { prime [ 1 ] = false ; prime [ 0 ] = false ; int p = 2 ; while ( p * p <= MAX ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) { prime [ i ] = false ; } } p ++ ; } }
public static void productOfKthPrimes ( int [ ] arr , int n , int k ) { int [ ] prime = new int [ MAX + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; int p = 2 ; while ( p * p <= MAX ) { if ( ( prime [ p ] == true ) ) { for ( int i = p * 2 ; i <= MAX ; i += p ) { prime [ i ] = false ; } } p ++ ; } }
static void findAllSequences ( int diff , char [ ] out , int start , int end ) { if ( ( Math . abs ( diff ) > ( end - start + 1 ) / 2 ) ) return ; if ( ( start > end ) ) { if ( ( diff == 0 ) ) { System . out . print ( new String ( out ) + " ▁ " ) ; } return ; } out [ start ] = '0' ; out [ end ] = '1' ; findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '1' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '0' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = '1' ; out [ end ] = '0' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = '1' ; out [ end ] = '0' ; findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) ; }
public static boolean check ( int [ ] h , int high ) { Arrays . sort ( h ) ; int summ = 0 ; for ( int i = h . length - 1 ; i >= 0 ; i -= 2 ) summ += h [ i ] ; return summ <= high ; }
public static int newNode ( int data ) { { int prev ; int next ; { data = data ; next = 0 ; } public static final String printList ( int node ) { while ( ( node = node ) != 0 ) { System . out . print ( node + " - > " ) ; node = node . next ; } System . out . println ( " NULL " ) ; return 0 ; } public static int cntNodes ( int node ) { if ( ( node = node ) == 0 ) { return 0 ; } return ( 1 + cntNodes ( node . next ) ) ; } public static final int updateList ( int head , int m ) { int cnt = cntNodes ( head ) ; if ( ( cnt != m ) && ( m < cnt ) ) { int skip = cnt - m ; prev = 0 ; curr = head ; while ( ( skip > 0 ) ) { prev = curr ; curr = curr . next ; skip -- ; } prev . next = null ; final int tempHead = head ; head = curr ; while ( ( curr = curr ) != 0 ) { curr = curr . next ; } curr . next = tempHead ; } return m ; } }
public static int maxSubStrings ( String s , int k ) { int maxSubStr = 0 ; int n = s . length ( ) ; for ( int c = 0 ; c < 27 ; c ++ ) { char ch = ( char ) ( ' a ' + c ) ; int curr = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { if ( ( s . charAt ( i ) != ch ) ) continue ; int cnt = 0 ; while ( ( i < n ) && ( s . charAt ( i ) == ch ) && ( cnt != k ) ) { i ++ ; cnt ++ ; } i -- ; if ( ( cnt == k ) ) curr ++ ; } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; }
public static void ansQueries ( int [ ] prefeven , int [ ] prefodd , int [ ] l , int [ ] r ) { if ( ( ( r - l + 1 ) % 2 == 0 ) ) { System . out . println ( "0" ) ; } else { if ( ( l % 2 == 0 ) ) { System . out . println ( prefeven [ r ] ^ prefeven [ l - 1 ] ) ; } else { System . out . println ( prefodd [ r ] ^ prefodd [ l - 1 ] ) ; } } }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = Integer . parseInt ( array [ i ] ) ; } Arrays . sort ( array , Collections . reverseOrder ( ) ) ; for ( int i = 1 ; i < array . length ; i ++ ) { if ( array [ i ] >= array [ i - 1 ] ) { array [ i ] = 0 ; } else { array [ i ] = array [ i - 1 ] - 1 ; } } return array ; }
public static void parseLine ( String line ) { int n , k ; int [ ] a = new int [ line . length ( ) ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = Integer . parseInt ( line . substring ( i , i + 1 ) ) ; } int x , y ; if ( n % 2 != 0 ) { x = n / 2 ; y = n / 2 + 1 ; } else { x = n / 2 - 1 ; y = n / 2 + 1 ; } if ( n == 2 ) { s = 0 ; for ( int i = 0 ; i < n * k ; i += 2 ) { s += a [ i ] ; } System . out . println ( s ) ; } else { int d = x * k , s = 0 ; while ( d < ( n * k ) ) { s += a [ d ] ; d += y ; } System . out . println ( s ) ; } }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalForPropositionalpositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForProposi
public static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } { int minVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minVal = Math . min ( minVal , arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] - minVal ; } } { int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxVal = Math . max ( maxVal , arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = maxVal - arr [ i ] ; } } { if ( ( k % 2 == 0 ) ) { removeMin ( arr , n ) ; } else { removeFromMax ( arr , n ) ; } printArray ( arr , n ) ; } if ( Class . forName ( " java . util . Arrays $ ArrayList " ) . equals ( " java . util . Arrays $ ArrayList " ) ) { arr = new int [ ] { 4 , 8 , 12 , 16 } ; n = arr . length ; int k = 2 ; modifyArray ( arr , n , k ) ; } }
public static double [ ] findCentroid ( double [ ] v ) { double [ ] ans = { 0 , 0 } ; int n = v . length ; double signedArea = 0 ; for ( int i = 0 ; i < v . length ; i ++ ) { double x0 = v [ i ] [ 0 ] ; double y0 = v [ i ] [ 1 ] ; double x1 = v [ ( i + 1 ) % n ] [ 0 ] ; double y1 = v [ ( i + 1 ) % n ] [ 1 ] ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; }
public static String getHex ( String s ) { int n = s . length ( ) ; String color = " blue " ; int block = 0 ; int i = 0 ; while ( i != n ) { String command = s . substring ( 0 , n ) ; if ( " lock " . equals ( command ) ) { block = 1 ; } else if ( " unlock " . equals ( command ) ) { block = 0 ; } else if ( block == 0 ) { color = command ; } i ++ ; } return color ; }
public static int minOperations ( int [ ] ar , int k ) { Arrays . sort ( ar ) ; int opsNeeded = 0 ; for ( int i = 0 ; i < k ; i ++ ) opsNeeded += ar [ k - 1 ] - ar [ i ] ; int ans = opsNeeded ; for ( int i = k ; i < ar . length ; i ++ ) { opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) ; opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = Math . min ( ans , opsNeeded ) ; } return ans ; int [ ] arr = { 3 , 1 , 9 , 100 } ; int n = arr . length ; k = 3 ; System . out . println ( minOperations ( arr , k ) ) ; return arr [ n ] ; }
public static void charCheck ( char inputChar ) { if ( ( ( ( int ) ( inputChar ) ) >= 65 && ( ( int ) ( inputChar ) ) <= 90 ) || ( ( ( int ) ( inputChar ) ) >= 97 && ( ( int ) ( inputChar ) ) <= 122 ) ) { System . out . println ( " ▁ Alphabet ▁ " ) ; } else if ( ( ( int ) ( inputChar ) ) >= 48 && ( ( int ) ( inputChar ) ) <= 57 ) { System . out . println ( " ▁ Digit ▁ " ) ; } else { System . out . println ( " ▁ Special ▁ Character ▁ " ) ; } inputChar = ' $ ' ; charCheck ( inputChar ) ; }
public static String getLetter ( String s ) { int x = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' A ' ) { x = i ; } else if ( s . charAt ( i ) == ' C ' ) { x = i ; } else if ( s . charAt ( i ) == ' A ' ) { x = i ; } else if ( s . charAt ( i ) == ' C ' ) { x = i ; } else if ( s . charAt ( i ) == ' A ' ) { x = i ; } else if ( s . charAt ( i ) == ' C ' ) { x = i ; } else if ( s . charAt ( i ) == ' A ' ) { x = i ; } else if ( s . charAt ( i ) == ' C ' ) { x = i ; } else if ( s . charAt ( i ) == ' A ' ) { x = i ; } else if ( s . charAt ( i ) == ' C ' ) { x = i ; } else if ( s . charAt ( i ) == ' A ' ) { x = i ; } else if ( s . charAt ( i ) == ' C ' ) { x = i ; } else if ( s . charAt ( i ) == ' A ' ) { x = i ; } else if ( s . charAt ( i ) == ' C ' ) { x = i ; } else if ( s . charAt ( i ) == ' A ' ) { x = i ; } else if ( s . charAt ( i ) == ' C ' ) { x = i ; } else if ( s . charAt ( i ) == ' A ' ) { x = i ; } else if ( s . charAt ( i ) == ' C ' ) { x = i ; } else if ( s . charAt ( i ) == ' A ' ) { x = i ; } else if ( s . charAt ( i ) == ' A ' ) { x = i ; } return s ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } int [ ] w = array [ 0 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { int [ ] i = array [ i ] ; w [ i ] = array [ i ] ; } int [ ] [ ] d = new int [ n ] [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int a = array [ i ] ; int b = array [ i ] ; d [ a - 1 ] [ i ] = b ; d [ b - 1 ] [ i ] = a ; } List < Integer > x = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] . length > 1 ) { for ( int i1 = 0 ; i1 < d [ i ] . length ; i1 ++ ) { for ( int i2 = i1 + 1 ; i2 < d [ i ] . length ; i2 ++ ) { if ( ( d [ i ] [ i1 ] - 1 ) . contains ( d [ i ] [ i2 ] ) && ( d [ i ] [ i2 ] - 1 ) . contains ( d [ i ] [ i2 ] ) && ( d [ i ] [ i1 ] . contains ( d [ i ] [ i2 ] ) ) ) { int z = new Integer ( i + 1 ) ; d [ i ] [ i1 ] = d [ i ] [ i2 ] ; x . add ( z ) ; } } } } } int c1 = 1e9 ; for ( int i = 0 ; i < x . size ( ) ; i ++ ) { int a = x . get ( i ) ; int b = x . get ( i ) ; int c = x . get ( i ) ; c1 = Math . min ( c1 , w [ a - 1 ] + w [ b - 1 ] + w [ c - 1 ] ) ; } return ( c1 != 1e9 ) ? c1 : - 1 ; }
public static int [ ] getM ( String s ) { int n = Integer . parseInt ( s ) ; int k = Integer . parseInt ( s ) ; int [ ] M = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { M [ i ] = Integer . parseInt ( s ) ; } int m = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int p = 0 ; p < n ; p ++ ) { if ( ( 0 == M [ p ] ) ) { System . out . print ( p + 1 ) ; break ; } } } for ( int l = p + 1 - k ; l < n ; l ++ ) M [ l ] -- ; M [ p ] -- ; return M ; }
public static void solve ( ) { final int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; final int [ ] rows = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; final int [ ] [ ] r = new int [ n ] [ n ] ; final HashMap < Integer , int [ ] > cords = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = new int [ ] ; for ( int j = 0 ; j < rows [ i ] ; j ++ ) { cords . put ( r [ i ] [ j ] , new int [ ] { i , j } ) ; } } int it = 1 ; final ArrayList < int [ ] > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < rows [ i ] ; j ++ ) { if ( r [ i ] [ j ] != it ) { final int [ ] tmp = new int [ ] { cords . get ( it ) [ 0 ] , cords . get ( it ) [ 1 ] } ; r [ i ] [ j ] = r [ cords . get ( it ) [ 0 ] ] [ cords . get ( it ) [ 1 ] ] = r [ i ] [ j ] ; cords . put ( r [ cords . get ( it ) [ 0 ] ] [ cords . get ( it ) [ 1 ] ] , tmp * 1 ) ; ans . add ( new int [ ] { i , j , cords . get ( it ) [ 0 ] , cords . get ( it ) [ 1 ] } ) ; } it ++ ; } } System . out . println ( ans . size ( ) ) ; for ( int [ ] i : ans ) { for ( int j : i ) { System . out . print ( j + 1 ) ; } System . out . println ( ) ; } if ( System . console ( ) . readLine ( ) . split ( " ▁ " ) . length == n ) { System . out . println ( ) ; } }
static int sameOccurrence ( int arr [ ] , int n , int x , int y ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ctX = 0 ; int ctY = 0 ; for ( int j = i ; j < n ; j += 1 ) { if ( ( arr [ j ] == x ) ) { ctX ++ ; } else if ( ( arr [ j ] == y ) ) { ctY ++ ; } if ( ( ctX == ctY ) ) { result ++ ; } } } return ( result ) ; }
public static int t ( String input ) { int t ; while ( ( t = input . indexOf ( " ▁ " ) ) != - 1 ) { t -- ; String s = input . substring ( 0 , t ) ; int n = s . length ( ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == '0' ) ) { ct ++ ; } } if ( ( ct < n - ct ) ) { System . out . println ( ct ) ; } else if ( ( ct > n - ct ) ) { System . out . println ( n - ct ) ; } else { if ( ( n != 2 ) ) { System . out . println ( ct - 1 ) ; } else { System . out . println ( 0 ) ; } } } return t ; }
public static void input ( ) { int c = 0 ; HashMap < String , Integer > f = new HashMap ( ) ; for ( String s : input ( ) . split ( " ▁ " ) ) { f . put ( s , d = f . getOrDefault ( s , 0 ) + 1 ) ; } c += d % 2 * 2 - 1 ; System . out . println ( new String [ ] { " Agasa " , " Conan " } [ c > 0 ] ) ; }
public static int [ ] a ( int [ ] a ) { for ( int i = 0 ; i < a . length ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; } return a ; }
public static int getTriplets ( int target ) { int [ ] arr = { 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 } ; int length = arr . length ; int totalCount = 0 ; for ( int i = 0 ; i < length - 2 ; i ++ ) { if ( target % arr [ i ] == 0 ) { for ( int j = i + 1 ; j < length - 1 ; j ++ ) { if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) { int toFind = target / ( arr [ i ] * arr [ j ] ) ; for ( int k = j + 1 ; k < length ; k ++ ) { if ( arr [ k ] == toFind ) { totalCount ++ ; } } } } } } return totalCount ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } return array ; }
public static int finalNum ( int [ ] arr , int n ) { int result = arr [ 0 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { result = gcd ( result , arr [ i ] ) ; } return result ; }
public static int lastElement ( int [ ] a , int n ) { int steps = 1 ; int [ ] [ ] v = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i += 2 ) { v [ steps ] [ i ] = ( a [ i ] = a [ i ] = a [ i + 1 ] ) ; } while ( v [ steps ] . length > 1 ) { steps ++ ; for ( int i = 0 ; i < v [ steps - 1 ] . length ; i += 2 ) { if ( ( steps & 1 ) != 0 ) { v [ steps ] [ i ] = ( v [ steps - 1 ] [ i ] = v [ steps - 1 ] [ i + 1 ] ) ; } else { v [ steps ] [ i ] = ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) ; } } } return v [ steps ] [ 0 ] ; }
public static int numberCake ( int n ) { return ( n * n * n + 5 * n + 6 ) / 6 ; n = 2 ; System . out . println ( numberCake ( n ) ) ; n = 8 ; System . out . println ( numberCake ( n ) ) ; n = 25 ; System . out . println ( numberCake ( n ) ) ; return 0 ; }
public static int getLevelFromName ( String name ) { int i = 0 ; for ( int j = 0 ; j < name . length ( ) ; j ++ ) { if ( name . charAt ( j ) == ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' . ' ) { i ++ ; } else if ( name . charAt ( j ) == ' . ' . ' ) { i ++ ; } return i ; }
public static void pattern ( int N ) { int k = 0 , space = 1 , rows = N ; for ( int i = rows ; i > 0 ; i -- ) { for ( int j = 1 ; j <= i ; j ++ ) { System . out . print ( " * " ) ; } if ( i != rows ) { for ( k = 1 ; k <= space ; k ++ ) { System . out . print ( " ▁ " ) ; } space += 2 ; } for ( int j = i ; j > 0 ; j -- ) { if ( j != rows ) { System . out . print ( " * " ) ; } } System . out . println ( ) ; } N = 6 ; pattern ( N ) ; }
public static int maximumMiddleValue ( int n , int k , int [ ] arr ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = Math . max ( ans , arr [ i - 1 ] ) ; } return ans ; }
public static int getDepth ( int [ ] array ) { int [ ] result = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == array [ i ] ) { result [ i ] = array [ i ] ; } } return result [ array . length ] ; }
public static void getmax ( int [ ] arr , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } System . out . println ( Math . min ( s , x ) ) ; }
public static int getDigitsMask ( String mask ) { if ( mask == null ) { return 0 ; } if ( mask . length ( ) == 0 ) { return 0 ; } if ( mask . length ( ) == 1 ) { return 0 ; } if ( mask . length ( ) == 2 ) { return 0 ; } if ( mask . length ( ) == 3 ) { return 0 ; } if ( mask . length ( ) == 4 ) { return 0 ; } if ( mask . length ( ) == 5 ) { return 0 ; } if ( mask . length ( ) == 6 ) { return 0 ; } if ( mask . length ( ) == 7 ) { return 0 ; } if ( mask . length ( ) == 8 ) { return 0 ; } if ( mask . length ( ) == 8 ) { return 0 ; } if ( mask . length ( ) == 9 ) { return 0 ; } if ( mask . length ( ) == 10 ) { return 0 ; } if ( mask . length ( ) == 11 ) { return 0 ; } if ( mask . length ( ) == 12 ) { return 0 ; } if ( mask . length ( ) == 13 ) { return 0 ; } if ( mask . length ( ) == 14 ) { return 0 ; } if ( mask . length ( ) == 15 ) { return 0 ; } if ( mask . length ( ) == 16 ) { return 0 ; } if ( mask . length ( ) == 15 ) { return 0 ; } if ( mask . length ( ) == 16 ) { return 0 ; } if ( mask . length ( ) == 17 ) { return 0 ; } if ( mask . length ( ) == 18 ) { return 0 ; } if ( mask . length ( ) == 19 ) { return 0 ; } if ( mask . length ( ) == 19 ) { return 0 ; } if ( mask . length ( ) == 19
public static void sieve ( ) { int MAX = 250000 ; int SQRT = 500 ; boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 2 ; i < MAX ; i += 2 ) prime [ i ] = false ; for ( int i = 3 ; i < SQRT ; i += 2 ) { if ( prime [ i ] ) { for ( int j = i * i ; j < MAX ; j += i ) prime [ j ] = false ; } } sieve ( ) ; while ( true ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; if ( n == 0 ) break ; int ans = 0 , m = n << 1 ; if ( n == 1 ) ans ++ ; int i = n + 1 ; if ( ( i & 1 ) == 0 ) i ++ ; while ( i <= m ) { if ( prime [ i ] ) ans ++ ; i += 2 ; } System . out . println ( ans ) ; } }
public static int maxOR ( int [ ] arr , int n ) { int maxVal = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxVal = Math . max ( maxVal , arr [ i ]
public static int numJewelsInStones ( ) { String J = " " ; String S = " " ; int out = 0 ; for ( int i = 0 ; i < J . length ( ) ; i ++ ) { J = J . substring ( i , i + 1 ) ; S = S . substring ( i , i + 1 ) ; } if ( J . length ( ) == 0 || S . length ( ) == 0 ) { return 0 ; } Set < Character > jSet = new HashSet < > ( Arrays . asList ( J ) ) ; out = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( jSet . contains ( S . charAt ( i ) ) ) { ans ++ ; } } return out ; }
public static int maxCliques ( int i , int l ) { int [ ] [ ] edges = { { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 19 , 20 , 21 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 26 , 27 , 28 , 26 , 27 , 28 , 26 , 27 , 28 , 26 , 27 , 28 , 26 , 27 , 28 , 26 , 27 , 28 , 26 , 27 , 28 , 27 , 28 , 28 , 26 , 27 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 } ; return ( ( (
public static double setBitNumber ( double n ) { int k = ( int ) Math . log ( n ) ; return 2 * k ; }
public static int R ( ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int m = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int s = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int f = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int d ; char c ; if ( s < f ) { d = 1 ; c = ' R ' ; } else { d = - 1 ; c = ' L ' ; } String res = " " ; int i = 1 ; int j = s ; int t , l , r ; int k = 1 ; while ( j != f ) { if ( i > t && k < m ) { t = R ( ) ; k ++ ; } if ( i == t && ( l <= j && r <= r || l <= j + d <= r ) ) { res += ' X ' ; } else { res += c ; j += d ; } i ++ ; } return res . length ( ) ; }
public static int subsetPairNotDivisibleByK ( int [ ] arr , int N , int K ) { int [ ] f = new int [ K ] ; for ( int i = 0 ; i < N ; i ++ ) { f [ arr [ i ] % K ] ++ ; } if ( ( K % 2 ) == 0 ) { f [ K / 2 ] = Math . min ( f [ K / 2 ] , 1 ) ; } int res = Math . min ( f [ 0 ] , 1 ) ; for ( int i = 1 ; i <= ( K / 2 ) ; i ++ ) { res += Math . max ( f [ i ] , f [ K - i ] ) ; } return res ; }
public static void main ( String [ ] lines ) { final int w = Integer . parseInt ( lines [ 0 ] ) ; final int m = Integer . parseInt ( lines [ 1 ] ) ; final int k = Integer . parseInt ( lines [ 2 ] ) ; int maxLength = 0 ; int availableDigits = ( int ) ( w / k ) ; while ( availableDigits > 0 ) { final int currentCostPerN = String . valueOf ( m ) . length ( ) ; final int sameCostUntil = 10 * ( currentCostPerN ) ; final int usableNumbers = sameCostUntil - m ; final int useDigits = usableNumbers * currentCostPerN ; m = sameCostUntil ; if ( availableDigits >= useDigits ) { maxLength += usableNumbers ; availableDigits -= useDigits ; } else { maxLength += ( int ) ( availableDigits / currentCostPerN ) ; availableDigits = 0 ; } } System . out . println ( maxLength ) ; if ( Class . isPrimitive ( String . class ) ) { Class . forName ( String . class . getName ( ) ) ; } else { Class . forName ( String . class . getName ( ) ) ; } }
static void printRoots ( int a , int b , int c ) { System . out . println ( Integer . toString ( 1 ) + " , ▁ " + ( c / ( a * 1.0 ) ) ) ; a = 2 ; b = 3 ; c = - 5 ; printRoots ( a , b , c ) ; }
public static int dp ( int pos , int fl , int pr , String bin ) { if ( ( pos == bin . length ( ) ) ) { return 1 ; } if ( ( memo [ pos ] [ fl ] [ pr ] != - 1 ) ) { return memo [ pos ] [ fl ] [ pr ] ; } int val = 0 ; if ( ( bin . charAt ( pos ) == '0' ) ) { val = val + dp ( pos + 1 , fl , 0 , bin ) ; } else if ( ( bin . charAt ( pos ) == '1' ) ) { val = val + dp ( pos + 1 , 1 , 0 , bin ) ; } if ( ( pr == 0 ) ) { if ( ( fl == 1 ) ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } else if ( ( bin . charAt ( pos ) == '1' ) ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } } memo [ pos ] [ fl ] [ pr ] = val ; return val ; }
public static int MaximumDecimalValue ( int [ ] [ ] mat , int n ) { int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = 0 ; } if ( ( mat [ 0 ] [ 0 ] == 1 ) ) { dp [ 0 ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { if ( ( mat [ 0 ] [ i ] == 1 ) ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 * i ; } else { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( ( mat [ i ] [ 0 ] == 1 ) ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 * i ; } } else { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( ( mat [ i ] [ j ] == 1 ) ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 * ( i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; }
static void createHash ( HashSet < Integer > hash1 , int maxElement ) { int prev = 0 , curr = 1 ; hash1 . add ( prev ) ; hash1 . add ( curr ) ; while ( ( curr = hash1 . find ( " ▁ - ▁ " ) ) != - 1 ) { int temp = curr + prev ; hash1 . add ( temp ) ; prev = curr ; curr = temp ; } }
public static int countgroup ( int [ ] a , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xs = xs ^ a [ i ] ; } if ( xs == 0 ) { return ( 1 << ( n - 1 ) ) - 1 ; } return 0 ; }
public static int maxLength ( String s , int n ) { int ans = - ( Integer . MAX_VALUE + 1 ) ; int [ ] A = new int [ n + 5 ] , L = new int [ n + 5 ] , R = new int [ n + 5 ] ; int [ ] freq = new int [ n + 5 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( int ) s . charAt ( j ) - ( int ) ' a ' ) == i ) count ++ ; freq [ j ] = count ; } for ( int j = 0 ; j < n ; j ++ ) { L [ j ] = ( 2 * freq [ j - 1 ] ) - j ; R [ j ] = ( 2 * freq [ j ] ) - j ; } } int maxLen = - ( Integer . MAX_VALUE + 1 ) ; int minVal = Integer . MAX_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { minVal = Math . min ( minVal , L [ j ] ) ; A [ j ] = minVal ; int l = 0 ; int r = j ; while ( ( l <= r ) ) { int mid = ( l + r ) >> 1 ; if ( ( A [ mid ] <= R [ j ] ) ) { maxLen = Math . max ( maxLen , j - mid + 1 ) ; r = mid - 1 ; } else { l = mid + 1 ; } } } ans = Math . max ( ans , maxLen ) ; A = new int [ n ] ; R = new int [ n ] ; L = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( A [ j ] <= R [ j ] ) ) { maxLen = Math . max ( maxLen , j - mid + 1 ) ; r = mid - 1 ; } else { l = mid + 1 ; } } ans = Math . max ( ans , maxLen ) ; A = new int [ n ] ; R = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( A [ j ] <= R [ j ] ) ) { maxLen = Math . max ( maxLen , j - mid + 1 ) ; } System . out . println ( maxLength ( s , n ) )
public static int [ ] [ ] getEdges ( int n , int m ) { int n = 4 , m = 3 ; for ( int i = 0 ; i < N ; i ++ ) { gr [ i ] [ 0 ] = i ; gr [ i ] [ 1 ] = i ; gr [ i ] [ 2 ] = i ; gr [ i ] [ 3 ] = i ; gr [ i ] [ 4 ] = i ; gr [ i ] [ 5 ] = i ; gr [ i ] [ 6 ] = i ; gr [ i ] [ 7 ] = i ; gr [ i ] [ 8 ] = i ; gr [ i ] [ 9 ] = i ; gr [ i ] [ 10 ] = i ; gr [ i ] [ 11 ] = i ; gr [ i ] [ 12 ] = i ; gr [ i ] [ 13 ] = i ; gr [ i ] [ 14 ] = i ; gr [ i ] [ 15 ] = i ; gr [ i ] [ 16 ] = i ; gr [ i ] [ 17 ] = i ; gr [ i ] [ 18 ] = i ; gr [ i ] [ 19 ] = i ; gr [ i ] [ 20 ] = i ; gr [ i ] [ 21 ] = i ; gr [ i ] [ 22 ] = i ; gr [ i ] [ 23 ] = i ; gr [ i ] [ 24 ] = i ; gr [ i ] [ 25 ] = i ; gr [ i ] [ 26 ] = i ; gr [ i ] [ 27 ] = i ; gr [ i ] [ 28 ] = i ; gr [ i ] [ 29 ] = i ; gr [ i ] [ 26 ] = i ; gr [ i ] [ 27 ] = i ; gr [ i ] [ 28 ] = i ; gr [ i ] [ 29 ] = i ; gr [ i ] [ 29 ] = i ; gr [ i ] [ 29 ] = i ; gr [ i ] [ 29 ] = i ; gr [ i ] [ 29 ] = i ; gr [ i ] [ 27 ] = i ; gr [ i ] [ 28 ] = i ; gr [ i ] [ 29 ] = i ; gr [ i ] [ 28 ] = i ; gr [ i ] [ 29 ] = i ; gr [ i ] [ 29 ] = i ; gr [ i ] [ 29 ] = i ; gr [ i ] [ 29 ] = i ; } return gr [ n ] [ m ]
public static void input ( ) { List l = Collections . unmodifiableList ( Arrays . asList ( Integer . parseInt ( System . getProperty ( " line . separator " ) ) ) ) ; Set s = new HashSet ( l ) ; if ( stream ( s ) . anyMatch ( i -> i % 2 == 0 ) && stream ( s ) . anyMatch ( i -> i % 2 != 0 ) ) { l . forEach ( i -> i ++ ) ; } System . out . println ( l ) ; }
public static int sum ( String input ) { int k = Integer . parseInt ( input . trim ( ) ) ; int n = Integer . parseInt ( input . trim ( ) ) ; int w = Integer . parseInt ( input . trim ( ) ) ; int sum = 0 ; for ( int i = 1 ; i <= w ; i ++ ) { sum += k * i ; } if ( sum <= n ) { return 0 ; } else { return ( sum - n ) ; } }
public static boolean isPrime ( int k ) { if ( ( k <= 1 ) ) { return false ; } for ( int i = 2 ; i < k ; i ++ ) { if ( ( k % i ) == 0 ) { return false ; } } return true ; }
public static String a ( String a ) { int n = Integer . parseInt ( a ) , k = Integer . parseInt ( a ) ; String t = a . substring ( 0 , 2 ) * n ; if ( k > n || ( k == 1 && n != 1 ) ) { System . out . println ( - 1 ) ; } else if ( n == 1 ) { System . out . println ( " a " ) ; } else { System . out . println ( t . substring ( 0 , n - k + 2 ) + a . substring ( 2 , k ) ) ; } return t ; }
public static int [ ] precompute ( ) { int [ ] dp = new int [ maxn ] ; for ( int i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; int [ ] v = { 4 , 6 , 9 } ; for ( int i = 1 ; i < maxn ; i += 1 ) { for ( int k = 0 ; k < 3 ; k ++ ) { int j = v [ k ] ; if ( ( i >= j ) && ( dp [ i - j ] != - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } return dp ; }
public static int countSquares ( int n ) { return ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) ; n = 3 ; System . out . println ( " Count ▁ of ▁ squares ▁ is " + ( int ) countSquares ( n ) ) ; }
public static int getDistance ( int [ ] array ) { int n = array [ 0 ] ; int m = array . length ; ArrayList < Integer > al = new ArrayList < > ( ) ; for ( int i = 1 ; i < array . length ; i ++ ) { al . add ( array [ i ] ) ; } Map < Integer , Integer > modd = new HashMap < > ( ) ; int s = 0 ; for ( int a : al ) { s += a ; s %= m ; modd . put ( s , 1 ) ; } int ans = 0 ; for ( int i : modd . values ( ) ) { ans += i * ( i - 1 ) / 2 ; } ans += modd . get ( 0 ) ; return ans ; }
public static int findSubarray ( int [ ] arr , int n , int k ) { int [ ] countOne = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { countOne [ i ] = Integer . toBinaryString ( arr [ i ] ) . indexOf ( '1' ) ; } int sum = countOne [ 0 ] ; if ( ( n == 1 ) ) { if ( ( countOne [ 0 ] >= k ) ) { return 1 ; } else { return - 1 ; } } int ans = Integer . MAX_VALUE ; int i = 1 ; int j = 0 ; while ( ( i < n ) ) { if ( ( k == countOne [ j ] ) ) { ans = 1 ; break ; } else if ( ( k == countOne [ i ] ) ) { ans = 1 ; break ; } else if ( ( sum + countOne [ i ] < k ) ) { sum += countOne [ i ] ; i ++ ; } else if ( ( sum + countOne [ i ] > k ) ) { ans = Math . min ( ans , ( i - j ) + 1 ) ; sum -= countOne [ j ] ; j ++ ; } else if ( ( sum + countOne [ i ] == k ) ) { ans = Math . min ( ans , ( i - j ) + 1 ) ; sum += countOne [ i ] ; i ++ ; } } if ( ( ans != Integer . MAX_VALUE ) ) { return ans ; } else { return - 1 ; } } if ( String . format ( " % s " , arr [ 0 ] ) . indexOf ( ' % ' ) != - 1 ) { return ans ; } else { return - 1 ; } }
public static void Loss ( int SP , int P ) { double loss = 0 ; loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) ; System . out . println ( " Loss ▁ = " + loss + " ▁ " ) ; }
public static int min ( int A , int M , int X ) { int A = Integer . parseInt ( input ( ) ) ; return A ; }
public static int [ ] getSushi ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] sushi = new int [ input . length ( ) ] ; for ( int i = 0 ; i < sushi . length ; i ++ ) { sushi [ i ] = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; } int res = 0 ; int before = 0 , after = 0 ; char cur = sushi [ 0 ] ; int i = 0 ; while ( i < n ) { if ( sushi [ i ] == cur ) { before ++ ; i ++ ; } else { int j = i ; char jS = sushi [ j ] ; cur = sushi [ j ] ; while ( j < n && sushi [ j ] == jS ) { after ++ ; j ++ ; } i = j ; res = Math . max ( res , Math . min ( before , after ) ) ; before = after ; after = 0 ; } } return sushi ; }
public static String compute ( ) { int ans = Integer . valueOf ( 1 ) ; for ( int i = 1 ; i < 10000000 ; i ++ ) { if ( getTerminal ( i ) == 89 ) { return String . valueOf ( ans ) ; } } final int [ ] TERMINALS = new int [ ] { 1 , 89 } ; { while ( ! TERMINALS [ 0 ] == 0 ) { n = squareDigitSum ( n ) ; } return String . valueOf ( n ) ; } { int result = 0 ; while ( n > 0 ) { result += SQUARE_DIGITS_SUM [ n % 1000 ] ; n /= 1000 ; } return result ; } }
public static int fact ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; } return fact ; }
public static void printCommonElements ( int [ ] [ ] mat ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) { mp . put ( mat [ 0 ] [ j ] , 1 ) ; } for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( mp . keySet ( ) . contains ( mat [ i ] [ j ] ) ) && ( mp . get ( mat [ i ] [ j ] ) == i ) ) { mp . put ( mat [ i ] [ j ] , i + 1 ) ; if ( i == M - 1 ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } } } } int [ ] [ ] mat = new int [ ] [ ] { { 1 , 2 , 1 , 4 , 8 } , { 3 , 7 , 8 , 5 , 1 } , { 8 , 7 , 7 , 3 , 1 } , { 8 , 1 , 2 , 7 , 9 } } ; printCommonElements ( mat ) ; }
public static final String getFunctionName ( String name ) { final int INF = 10 * 18 + 3 ; final int EPS = 1e-10 ; final int MAX_CACHE = 10 * 9 ; final int n = Math . max ( 0 , Math . min ( Math . max ( 0 , n ) , Math . max ( 0 , n ) ) ) ; final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ " ) ; sb . append ( name ) ; sb . append ( " ] " ) ; sb . append ( " ▁ took ▁ " ) ; sb . append ( name ) ; sb . append ( " ▁ ms " ) ; sb . append ( " ] " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " , " ) ; sb . append ( " " ) ; sb . append ( " , " ) ; sb . append ( " " ) ; sb . append ( " , " ) ; sb . append ( " " ) ; sb . append ( " , " ) ; sb . append ( " " ) ; sb . append ( " " ) ; sb . append ( " " , " ) ; sb . append ( " " ) ; sb . append ( " " , " " ) ; sb . append ( " " , " " ) ; sb . append ( " " , " " ) ; sb . append ( " " )
public static int [ ] line2Int ( String linea ) { final int [ ] out = new int [ 2 ] ; for ( int i = 0 ; i < linea . length ( ) ; i ++ ) { if ( linea . charAt ( i ) == ' ▁ ' ) { if ( temp != " " ) { final int val1 = Integer . parseInt ( temp ) ; temp = " " ; } } else { temp = temp + linea . charAt ( i ) ; } } final int val2 = Integer . parseInt ( temp ) ; return new int [ ] { val1 , val2 } ; final int n = line2Int ( new Scanner ( System . in ) . nextInt ( ) ) ; final int t = line2Int ( new Scanner ( System . in ) . nextInt ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { final int salida = line2Int ( new Scanner ( System . in ) . nextInt ( ) ) ; final int intervalo = line2Int ( new Scanner ( System . in ) . nextInt ( ) ) ; if ( salida < t ) { salida = salida + ( Math . ceil ( ( t - salida ) / intervalo ) * intervalo ) ; } if ( i == 0 ) { out [ 0 ] = i + 1 ; out [ 1 ] = salida ; } else if ( salida < out [ 1 ] ) { out [ 1 ] = salida ; } } return out ; }
public static int sumOfAP ( int a , int d , int n ) { int sum = 0 ; int i = 0 ; while ( i < n ) { sum = sum + a ; a = a + d ; i = i + 1 ; } return sum ; }
public static void find3Numbers ( int [ ] arr , int n ) { int small = + 2147483647 ; int large = + 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] <= small ) ) { small = arr [ i ] ; } else if ( ( arr [ i ] <= large ) ) { large = arr [ i ] ; } else { break ; } } if ( ( i == n ) ) { System . out . println ( " No ▁ such ▁ triplet ▁ found " ) ; return ; } for ( int j = 0 ; j < i + 1 ; j ++ ) { if ( ( arr [ j ] < large ) ) { small = arr [ j ] ; break ; } } System . out . println ( String . valueOf ( small ) + " ▁ " + String . valueOf ( large ) + " ▁ " + String . valueOf ( arr [ i ] ) ) ; return ; arr = Arrays . asList ( 5 , 7 , 4 , 8 ) ; n = arr . length ; find3Numbers ( arr , n ) ; }
public static void numbersWith3Divisors ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; prime [ 0 ] = prime [ 1 ] = false ; int p = 2 ; while ( ( p * p <= n ) ) { if ( ( prime [ p ] ) == true ) { for ( int i = p * 2 ; i <= n ; i += p ) { prime [ i ] = false ; } } p ++ ; } System . out . println ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : " ) ; int i = 0 ; while ( ( i * i <= n ) ) { if ( ( prime [ i ] ) != true ) { System . out . print ( i * i + " ▁ " ) ; } i ++ ; } n = 96 ; numbersWith3Divisors ( n ) ; }
static int findPairCount ( int N , int K ) { int count = 0 ; int [ ] rem = new int [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) { rem [ i ] = ( N - i ) / K + 1 ; } if ( ( K % 2 ) == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) { count += rem [ i ] * rem [ K - i ] ; } count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = Math . PI ; i <= K / 2 ; i ++ ) { count += rem [ i ] * rem [ K - i ] ; } } return count ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalpositionalpositionalpositionalposi
public static int getRandom ( ) { int n = Integer . parseInt ( System . getProperty ( " random . number " ) ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = Integer . parseInt ( System . getProperty ( " random . number " ) ) ; } return arr [ 0 ] ; }
public static int fib ( int n ) { int f [ ] = { 0 , 1 , 1 , 2 , 3 , 5 } ; return f [ n ] ; }
public static int kthSmallest ( int n , int k ) { return 2 * k ; }
public static void printSumTricky ( int [ ] [ ] mat , int k ) { int i ; int Sum ; if ( k > n ) { return ; } int [ ] [ ] stripSum = new int [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { Sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { Sum += mat [ i ] [ j ] ; } stripSum [ 0 ] [ j ] = Sum ; for ( i = 1 ; i <= n - k ; i ++ ) { Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = Sum ; } } } for ( i = 0 ; i < n - k + 1 ; i ++ ) { Sum = 0 ; for ( j = 0 ; j < k ; j ++ ) { Sum += stripSum [ i ] [ j ] ; } System . out . print ( Sum + " ▁ " ) ; for ( j = 1 ; j <= n - k ; j ++ ) { Sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; System . out . print ( Sum + " ▁ " ) ; } System . out . println ( ) ; } n = 5 ; mat = new int [ ] [ ] { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 } } ; k = 3 ; printSumTricky ( mat , k ) ; }
public static int getDistance ( int [ ] array ) { int distance = 0 ; int [ ] a = array . clone ( ) ; int [ ] b = array . clone ( ) ; int n = array . length ; if ( a != 0 ) { if ( b . length % a != 0 ) { System . out . println ( " No ▁ solution " ) ; } else { b = b [ 0 ] / a ; int x = 0 , y = - 2000 ; if ( b >= 0 ) { while ( y < b ) { y = Math . pow ( x , n ) ; x = x + 1 ; } if ( y > b ) { System . out . println ( " No ▁ solution " ) ; } else { System . out . println ( x - 1 ) ; } } else { if ( n % 2 == 0 ) { System . out . println ( " No ▁ solution " ) ; } else { x = - 1 ; y = 2000 ; while ( y > b ) { y = Math . pow ( x , n ) ; x = x - 1 ; } if ( y < b ) { System . out . println ( " No ▁ solution " ) ; } else { System . out . println ( x + 1 ) ; } } } } } else { if ( b . length == 0 ) { System . out . println ( 5 ) ; } else { System . out . println ( " No ▁ solution " ) ; } else { System . out . println ( " No ▁ solution " ) ; } } return distance ; }
public static int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
public static int nextPowerOf2 ( int n ) { int count = 0 ; if ( ( n != 0 ) && ! ( n != 0 && ( n - 1 ) ) ) { return n ; } while ( n != 0 ) { n >>= 1 ; count ++ ; } return 1 << count ; }
public static int combi ( int N , int K ) { int a = 1 ; for ( int i = 0 ; i < K ; i ++ ) { a *= N - i ; } for ( int j = 0 ; j < K ; j ++ ) { a /= j + 1 ; } return a ; }
public static int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) { if ( ( ( a * x ) % m ) == 1 ) { return x ; } } return 1 ; }
public static int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; }
public static void findGreater ( int a , int b ) { double x = a * ( Math . log ( b ) ) ; double y = b * ( Math . log ( a ) ) ; if ( ( y > x ) ) { System . out . println ( " a ^ b ▁ is ▁ greater " ) ; } else if ( ( y < x ) ) { System . out . println ( " b ^ a ▁ is ▁ greater " ) ; } else { System . out . println ( " Both ▁ are ▁ equal " ) ; } a = 3 ; b = 5 ; c = 2 ; d = 4 ; findGreater ( a , b ) ; findGreater ( c , d ) ; }
public static int findAnswer ( String str1 , String str2 , int n ) { int l = 0 , r = 0 ; int ans = 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( str1 . charAt ( i ) != str2 . charAt ( i ) ) ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ( str1 . charAt ( i ) != str2 . charAt ( i ) ) ) { r = i ; break ; } } if ( ( r < l ) ) { return 26 * ( n + 1 ) ; } else if ( ( l == r ) ) { return ans ; } else { for ( int i = l + 1 ; i <= r ; i ++ ) { if ( ( str1 . charAt ( i ) != str2 . charAt ( i - 1 ) ) ) { ans -- ; break ; } } for ( int i = l + 1 ; i <= r ; i ++ ) { if ( ( str1 . charAt ( i - 1 ) != str2 . charAt ( i ) ) ) { ans -- ; break ; } } return ans ; } } str1 = " toy " ; str2 = " try " ; n = str1 . length ( ) ; System . out . println ( findAnswer ( str1 , str2 , n ) ) ; return ans ; }
public static int getDistance ( int [ ] array , int start , int end ) { int [ ] dx = array . clone ( ) ; int [ ] dy = array . clone ( ) ; int dy = array . clone ( ) ; int dy = array . clone ( ) ; int dy = array . clone ( ) ; int dy = array . clone ( ) ; int dy = array . clone ( ) ; int dy = array . clone ( ) ; int dy = array . clone ( ) ; int dy = array . clone ( ) ; int dy = array . clone ( ) ; int dy = array . clone ( ) ; int dy = array . clone ( ) ; int dy = array . clone ( ) ; int dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone ( ) ; dy = array . clone
public static boolean bitsAreInAltPatrnInGivenTRange ( int n , int l , int r ) { int num = n >> ( l - 1 ) ; int prev = num & 1 ; num = num >> 1 ; for ( int i = 1 ; i < ( r - l ) ; i ++ ) { int curr = num & 1 ; if ( ( curr == prev ) ) { return false ; } prev = curr ; num = num >> 1 ; } return true ; }
public static String getCountry ( String country ) { String country = country . toLowerCase ( ) ; if ( country . contains ( " _ " ) ) { country = country . substring ( 0 , country . indexOf ( " _ " ) ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( 0 , country . indexOf ( " _ " ) ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( 0 , country . indexOf ( " _ " ) ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( 0 , country . indexOf ( " _ " ) ) ; } return country ; }
public static int nthGroup ( int n ) { return n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; int N = 5 ; return nthGroup ( N ) ; }
public static int [ ] [ ] getHoles ( int [ ] [ ] ) { int [ ] [ ] dl = new int [ [ ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] tl = new int [ ] { Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; } } return dl
public static int in ( ) { return ( Integer . parseInt ( System . console ( ) . readLine ( ) ) ) ; }
public static int maximumOccurredElement ( int L [ ] , int R [ ] , int n ) { int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { arr [ i ] = 0 ; } for ( int i = 0 ; i < n ; i += 1 ) { arr [ L [ i ] ] ++ ; arr [ R [ i ] + 1 ] -- ; } int msum = arr [ 0 ] ; for ( int i = 1 ; i < MAX ; i += 1 ) { arr [ i ] += arr [ i - 1 ] ; if ( ( msum < arr [ i ] ) ) { msum = arr [ i ] ; ind = i ; } } return ind ; }
public static int getProfession ( int [ ] pds ) { int profession = pds . length ; int profession = pds [ profession ] ; return profession ; }
public static int getMin ( int n , int m ) { int min , max , min , max ; n = Integer . parseInt ( input ( ) ) ; m = Integer . parseInt ( input ( ) ) ; if ( n < 1 ) { if ( m < 1 ) { min = n ; max = m ; } min = n ; max = n + m - 1 ; min = max ; } if ( m <= n ) { min = n ; max = n + m - 1 ; if ( m == 0 ) max = n ; min = max ; } return min ; }
public static double func ( double x ) { return ( ( double ) 1 / ( 1 + x * x ) ) ; }
public static int getRandom ( ) { int N = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int K = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int X = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int Y = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; if ( N <= K ) { System . out . println ( ( int ) ( N * X ) ) ; } else { System . out . println ( ( int ) ( K * X + ( N - K ) * Y ) ) ; } return ( int ) ( K * X + ( N - K ) * Y ) ; }
public static double sqrt ( double x ) { double h ; double l ; double l ; double x = Math . sqrt ( 0.25 * x * x + h * h ) ; l = Math . sqrt ( x * x + 2 * x * l ) ; return x ; }
public static int k ( ) { int i = Integer . parseInt ( input ( ) ) ; int k = 10 ; while ( k > 0 ) { i += 9 ; if ( Integer . parseInt ( String . valueOf ( i ) ) == 10 ) { k -- ; } } return i ; }
public static int getPrimeQuad ( int n ) { final int MAX = 100000 ; final boolean [ ] prime = new boolean [ MAX ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p <= ( int ) Math . sqrt ( MAX ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } final int printPrimeQuad ( n ) ; for ( int i = 0 ; i < n - 7 ; i ++ ) { if ( ( prime [ i ] && prime [ i + 2 ] && prime [ i + 6 ] && prime [ i + 8 ] ) != 0 ) { System . out . println ( i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ; } } return n ; }
public static int maxSubsequenceSubstring ( String x , String y , int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { dp [ i ] [ i ] = 0 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( ( x . charAt ( j - 1 ) == y . charAt ( i - 1 ) ) ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans = Math . max ( ans , dp [ i ] [ n ] ) ; } return ans ; }
static int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( i % a == 0 || i % b == 0 ) ) { sum += i ; } } return sum ; }
public static int min ( int [ ] st , int [ ] av ) { int [ ] = new int [ st . length ] ; int [ ] v = new int [ av . length ] ; System . arraycopy ( st , 0 , v , 0 , st . length ) ; System . arraycopy ( av , 0 , v , 0 , av . length ) ; System . arraycopy ( av , 0 , v , 0 , av . length ) ; System . arraycopy ( s , 0 , v , 0 , av . length ) ; System . arraycopy ( av , 0 , v , 0 , av . length ) ; System . arraycopy ( s , 0 , v , 0 , av . length ) ; System . arraycopy ( av , 0 , v , 0 , av . length ) ; System . arraycopy ( av , 0 , v , 0 , av . length ) ; System . arraycopy ( v , 0 , v , 0 , av . length ) ; System . arraycopy ( av , 0 , v , 0 , av . length ) ; System . arraycopy ( av , 0 , v , 0 , av . length ) ; return v [ v . length ] ; }
public static int getNthTerm ( int n ) { int [ ] sequence = new int [ MAX + 1 ] ; for ( int i = 0 ; i < MAX ; i ++ ) { sequence [ i ] = 0 ; } for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( ( sequence [ j ] == sequence [ i ] ) ) { sequence [ i + 1 ] = i - j ; break ; } } } return sequence [ n ] ; }
public static int getSequence ( int [ ] sequence ) { int MAX = 10000 ; int [ ] sequence = new int [ MAX + 1 ] ; int n ; int i ; int count ; for ( i = 0 ; i < MAX ; i ++ ) { for ( j = i - 1 ; j >= 0 ; j -- ) { if ( ( sequence [ j ] == sequence [ i ] ) ) { sequence [ i + 1 ] = i - j ; break ; } } } if ( count == 1 ) { count = 1 ; i = n - 1 ; while ( ( sequence [ i + 1 ] != 0 ) ) { count ++ ; i = i - sequence [ i + 1 ] ; } } return count ; }
public static int [ ] getSequence ( int [ ] sequence ) { int MAX = 10000 ; int [ ] sequence = new int [ MAX + 1 ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( ( sequence [ j ] == sequence [ i ] ) ) { sequence [ i + 1 ] = i - j ; break ; } } } int count = 0 ; for ( int i = 0 ; i < sequence . length ; i ++ ) { int nthTerm = sequence [ i - 1 ] ; count = 0 ; for ( int j = 0 ; j < sequence . length ; j ++ ) { if ( ( sequence [ i ] == nthTerm ) ) { count ++ ; } } } return count ; }
public static int nthElement ( int a , int b , int n ) { int lcm = ( a * b ) / ( int ) Math . gcd ( a , b ) ; int l = 1 ; int r = Math . min ( a , b ) * n ; while ( ( l <= r ) ) { int mid = ( l + r ) >> 1 ; int val = ( ( int ) ( mid / a ) + ( int ) ( mid / b ) - ( int ) ( mid / lcm ) ) ; if ( ( val == n ) ) { return ( int ) Math . max ( ( int ) ( mid / a ) * a , ( int ) ( mid / b ) * b ) ; } if ( ( val < n ) ) { l = mid + 1 ; } else { r = mid - 1 ; } } a = 5 ; b = 3 ; n = 5 ; System . out . println ( nthElement ( a , b , n ) ) ; }
public static int getDayOfWeek ( int x ) { int y = Integer . parseInt ( input ) ; boolean isRun = Calendar . getInstance ( ) . isLeapYear ( y ) ; int week = Calendar . getInstance ( ) . get ( Calendar . DAY_OF_WEEK ) ; do { y = y + 1 ; } while ( Calendar . getInstance ( ) . isLeapYear ( y ) == isRun && Calendar . getInstance ( ) . get ( Calendar . DAY_OF_WEEK ) == week ) ; return y ; }
public static int [ ] getBase ( String str ) { int [ ] base = new int [ 3 ] ; int out = 0 ; int point = 0 ; int inning = 0 ; while ( true ) { String event = str . toLowerCase ( ) ; if ( event . equals ( " HIT " ) ) { if ( base [ 2 ] == 1 ) { point ++ ; } base [ 2 ] = base [ 1 ] ; base [ 1 ] = base [ 0 ] ; base [ 0 ] = 1 ; } else if ( event . equals ( " HOMERUN " ) ) { point += Arrays . stream ( base ) . parallel ( ) . map ( i -> i + 1 ) . toArray ( ) ; base = new int [ 3 ] ; } else if ( event . equals ( " OUT " ) ) { out ++ ; if ( out == 3 ) { System . out . println ( point ) ; inning ++ ; if ( inning == N ) { break ; } base = new int [ 3 ] ; out = 0 ; point = 0 ; } } } return base ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) { return 0 ; } if ( ( a == b ) ) { return a ; } if ( ( a > b ) ) { return gcd ( a - b , b ) ; } return gcd ( a , b - a ) ; }
public static void foot ( int a , int b , int c , int d , int x1 , int y1 , int z1 ) { double k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) ; double x2 = a * k + x1 ; double y2 = b * k + y1 ; double z2 = c * k + z1 ; System . out . print ( " x2 ▁ = " + x2 + " ▁ y2 ▁ = " + y2 + " ▁ z2 ▁ = " + z2 + " ▁ z2 ▁ = " + z2 ) ; }
public static String getLetter ( String s ) { if ( s . length ( ) == 0 ) { return " " ; } else if ( s . length ( ) == 1 ) { return s . substring ( 0 , 1 ) ; } else if ( s . length ( ) == 2 ) { return s . substring ( 0 , 2 ) ; } else if ( s . length ( ) == 3 ) { return s . substring ( 0 , 3 ) ; } else if ( s . length ( ) == 4 ) { return s . substring ( 0 , 4 ) ; } else if ( s . length ( ) == 5 ) { return s . substring ( 0 , 5 ) ; } else if ( s . length ( ) == 6 ) { return s . substring ( 0 , 6 ) ; } else if ( s . length ( ) == 7 ) { return s . substring ( 0 , 7 ) ; } else if ( s . length ( ) == 8 ) { return s . substring ( 0 , 8 ) ; } else if ( s . length ( ) == 9 ) { return s . substring ( 0 , 9 ) ; } else if ( s . length ( ) == 10 ) { return s . substring ( 0 , 11 ) ; } else if ( s . length ( ) == 11 ) { return s . substring ( 0 , 11 ) ; } else if ( s . length ( ) == 12 ) { return s . substring ( 0 , 13 ) ; }
public static int getMinimumOps ( int [ ] ar ) { int n = ar . length ; int small = Math . min ( ar . length , 0 ) ; int large = Math . max ( ar . length , 0 ) ; int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int j = small ; j <= large ; j ++ ) { dp [ 0 ] [ j ] = Math . abs ( ar [ 0 ] - j ) ; } for ( int i = 1 ; i < n ; i ++ ) { int minimum = 10 * 9 ; for ( int j = small ; j <= large ; j ++ ) { minimum = Math . min ( minimum , dp [ i - 1 ] [ j ] ) ; dp [ i ] [ j ] = minimum + Math . abs ( ar [ i ] - j ) ; } } int ans = 10 * 9 ; for ( int j = small ; j <= large ; j ++ ) { ans = Math . min ( ans , dp [ n - 1 ] [ j ] ) ; } return ans ; }
public static double areaLeaf ( double a ) { return ( a * a * ( PI / 2 - 1 ) ) ; double a = 7 ; return Math . atan ( a ) ; }
public static int removeAlternate ( int n ) { if ( ( n == 1 ) ) { return 1 ; } if ( ( n % 2 == 0 ) ) { return 2 * removeAlternate ( n / 2 ) - 1 ; } else { return 2 * removeAlternate ( ( ( n - 1 ) / 2 ) ) + 1 ; } n = 5 ; System . out . println ( removeAlternate ( n ) ) ; n = 10 ; System . out . println ( removeAlternate ( n ) ) ; return 0 ; }
public static void check ( int n , int m ) { if ( ( n == 2 || m == 2 || n % m == 0 ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } m = 3 ; n = 9 ; check ( n , m ) ; }
public static boolean solve ( int [ ] a , int n , int m ) { List < Integer > b = new ArrayList < > ( ) ; boolean flag = false ; for ( int i = 0 ; i < a . length ; i ++ ) { int curr = a [ i ] / n ; if ( curr >= 3 ) { flag = true ; } if ( curr >= 2 ) { b . add ( curr ) ; } } if ( m % 2 == 1 ) { if ( ! flag ) { return false ; } } return Arrays . stream ( b ) . mapToObj ( i -> b . get ( i ) ) . sum ( ) >= m ; } for ( int t = 0 ; t < Integer . parseInt ( input ( ) ) ; t ++ ) { n = Integer . parseInt ( input ( ) . split ( " ▁ " ) [ 0 ] ) ; m = Integer . parseInt ( input ( ) [ 1 ] ) ; k = Integer . parseInt ( input ( ) [ 2 ] ) ; a = new ArrayList < > ( ) ; a . add ( Integer . parseInt ( input ( ) [ 0 ] ) ) ; a . add ( Integer . parseInt ( input ( ) [ 1 ] ) ) ; Collections . sort ( a ) ; if ( solve ( a . toArray ( ) , n , m ) || solve ( a . toArray ( ) , m , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
public static int negProdSubArr ( int [ ] arr , int n ) { int positive = 1 ; int negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] > 0 ) ) { arr [ i ] = 1 ; } else { arr [ i ] = - 1 ; } if ( ( i > 0 ) ) { arr [ i ] *= arr [ i - 1 ] ; } if ( ( arr [ i ] == 1 ) ) { positive ++ ; } else { negative ++ ; } } return ( positive * negative ) ; }
public static int negProdSubArr ( int [ ] arr , int n ) { int positive = 1 ; int negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] > 0 ) ) { arr [ i ] = 1 ; } else { arr [ i ] = - 1 ; } if ( ( i > 0 ) ) { arr [ i ] *= arr [ i - 1 ] ; } if ( ( arr [ i ] == 1 ) ) { positive ++ ; } else { negative ++ ; } } return ( positive * negative ) ; }
public static int solve ( ) { final String input = System . getProperty ( " line . separator " ) ; final int n = Integer . parseInt ( input ) ; final int k = Integer . parseInt ( input ) ; int cnt = 1 ; int ans = 0 ; while ( cnt <= k && cnt < n ) { cnt *= 2 ; ans ++ ; } if ( cnt >= n ) { return ans ; } else { ans += ( n - cnt ) / k ; ans += ( n - cnt ) % k != 0 ? 1 : 0 ; return ans ; } for ( ; ; ) { System . out . println ( solve ( ) ) ; } }
public static int GCD ( int a , int b ) { while ( a % b != 0 ) { a = b ; b = a % b ; } return b ; int LCM = a * b / GCD ; String [ ] l = input ( ) ; int x = Integer . parseInt ( l [ 0 ] ) , y = Integer . parseInt ( l [ 1 ] ) , a = Integer . parseInt ( l [ 2 ] ) , b = Integer . parseInt ( l [ 3 ] ) ; int lcm = LCM ( x , y ) ; System . out . println ( b / lcm - ( a - 1 ) / lcm ) ; }
public static int minRemove ( int [ ] arr , int n ) { int [ ] LIS = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } } len = Math . max ( len , LIS [ i ] ) ; return ( n - len ) ; }
public static void printMax ( int [ ] a , int n , int k ) { int [ ] maxUpto = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { maxUpto [ i ] = 0 ; } ArrayList < Integer > s = new ArrayList < > ( ) ; s . add ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( ( s . size ( ) > 0 ) && ( a [ s . get ( s . size ( ) - 1 ) ] < a [ i ] ) ) { maxUpto [ s . get ( s . size ( ) - 1 ) ] = i - 1 ; s . remove ( s . size ( ) - 1 ) ; } s . add ( i ) ; } while ( ( s . size ( ) > 0 ) ) { maxUpto [ s . get ( s . size ( ) - 1 ) ] = n - 1 ; s . remove ( s . size ( ) - 1 ) ; } int j = 0 ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { while ( ( j < i ) || maxUpto [ j ] < i + k - 1 ) { j ++ ; } System . out . print ( a [ j ] + " ▁ " ) ; } System . out . println ( ) ; }
public static String compute ( ) { long ans = Math . max ( Long . parseLong ( String . valueOf ( a * b ) ) , Long . parseLong ( String . valueOf ( a * b ) ) ) ; for ( long b = 0 ; b < 100 ; b ++ ) { return Long . toString ( ans ) ; } if ( Thread . currentThread ( ) . isThread ( ) ) { System . out . println ( compute ( ) ) ; } return null ; }
public static int countWindowDistinct ( int [ ] win , int k ) { int distCount = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int j = 0 ; while ( j < i ) { if ( ( win [ i ] == win [ j ] ) ) break ; else j ++ ; } if ( ( j == i ) ) distCount ++ ; } return distCount ; }
public static int evenNumSubstring ( String str ) { int length = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < length ; i += 1 ) { int temp = str . charAt ( i ) - '0' ; if ( ( temp % 2 == 0 ) ) { count += ( i + 1 ) ; } } return count ; }
public static int countWays ( int index , int cnt , int [ ] [ ] dp , int n , int m , int k ) { if ( ( index == n ) ) { if ( ( cnt == k ) ) { return 1 ; } else { return 0 ; } } if ( ( dp [ index ] [ cnt ] != - 1 ) ) { return dp [ index ] [ cnt ] ; } int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; dp [ index ] [ cnt ] = ans ; return dp [ index ] [ cnt ] ; }
public static int getSum ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { summ += i ; } else { summ += i ; summ += n / i ; } } } return summ - n ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = Integer . parseInt ( array [ i ] ) ; } return array ; }
public static void reverseArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { arr [ i ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] = arr [ i ] ; } int [ ] arr = { 5 , 3 , 7 , 2 , 1 , 6 } ; n = arr . length ; reverseArray ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
public static void printSeriesSum ( int N ) { int sum = 0 ; int a = 1 ; int cnt = 0 ; boolean flag = true ; sum += a ; while ( ( cnt < N ) ) { int nextElement = 0 ; if ( ( flag ) ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * ( 3 / 2 ) ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } System . out . println ( sum ) ; }
public static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } else { return gcd ( b % a , a ) ; } int t = Integer . parseInt ( input ( ) ) ; while ( t > 0 ) { t -- ; a = Integer . parseInt ( input ( ) ) ; b = Integer . parseInt ( input ( ) ) ; int c = gcd ( a , b ) ; a = a / c ; b = b / c ; int ans1 ; int ans2 ; if ( a == b ) { ans1 = 1 ; ans2 = 0 ; } else if ( a % 2 == 0 || b % 2 == 0 ) { ans1 = 1 ; ans2 = 1 ; } else { ans1 = a * b / 2 + 1 ; ans2 = a * b / 2 ; } System . out . println ( ans1 + ans2 ) ; } return t ; }
public static int minDifference ( int L , int R ) { int sz = ( int ) 1e5 ; boolean [ ] isPrime = new boolean [ sz + 1 ] ; int i ; int diff ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( i = 2 ; i <= ( int ) Math . sqrt ( sz ) ; i ++ ) { if ( ( isPrime [ i ] ) ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } if ( ( isPrime [ L ] ) && ( isPrime [ R ] ) ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } else { for ( int j = 0 ; j < Math . sqrt ( sz ) ; j ++ ) { if ( ( isPrime [ j ] ) ) { if ( ( isPrime [ j ] ) ) { if ( ( isPrime [ j ] ) ) { if ( ( isPrime [ j ] ) ) { if ( ( isPrime [ j ] ) ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) { if ( isPrime [ j ] ) ; } } } } } } } } } } } } } } } } } } } } } } } } } return diff ; }
static int getMaxLength ( int [ ] arr , int n ) { int start = 0 ; int preCnt = 0 ; while ( ( start < n ) && ( arr [ start ] == 1 ) ) { preCnt = preCnt + 1 ; start = start + 1 ; } int end = n - 1 ; int suffCnt = 0 ; while ( ( end >= 0 ) && ( arr [ end ] == 1 ) ) { suffCnt = suffCnt + 1 ; end = end - 1 ; } if ( ( start > end ) ) { return n ; } int midCnt = 0 ; int i = start ; int result = 0 ; while ( ( i <= end ) ) { if ( ( arr [ i ] == 1 ) ) { midCnt = midCnt + 1 ; result = Math . max ( result , midCnt ) ; } else { midCnt = 0 ; } i = i + 1 ; } return Math . max ( result , preCnt + suffCnt ) ; }
public static int INF ( int d , int n ) { int d = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int [ ] temp = new int [ d ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; temp [ 0 ] = 0 ; int [ ] alst = new int [ n ] ; int [ ] blst = new int [ n ] ; int [ ] clst = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int b = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int c = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; alst [ i ] = a ; blst [ i ] = b ; clst [ i ] = c ; } int [ ] [ ] dp = new int [ d + 1 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( alst [ i ] <= temp [ 1 ] && blst [ i ] <= temp [ 1 ] ) ) dp [ 1 ] [ i ] = - INF ; } for ( int i = 2 ; i <= d ; i ++ ) { int t = temp [ i ] ; for ( int j = 0 ; j < n ; j ++ ) if ( alst [ j ] <= t && blst [ j ] <= temp [ j ] ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ x ] + Math . abs ( clst [ j ] - clst [ x ] ) ) ; } System . out . println ( Math . max ( dp [ d ] [ d ] , dp [ d ] [ d ] ) ) ; return dp [ d ] [ d ] ; }
public static void f ( String s ) { for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) < s . charAt ( i - 1 ) ) { System . out . println ( " YES " ) ; System . out . println ( i + 1 ) ; return ; } } System . out . println ( " NO " ) ; int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; f ( System . console ( ) . readLine ( ) ) ; }
public static double sqroot ( double s ) { double pSq = 0 ; double N = 0 ; for ( int i = ( int ) s ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( ( j * j == i ) ) { pSq = i ; N = j ; break ; } } if ( ( pSq > 0 ) ) break ; } double d = s - pSq ; double P = d / ( 2.0 * N ) ; double A = N + P ; double sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }
public static int getLargestIndex ( int [ ] arr ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int [ ] arr = Arrays . stream ( arr ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int ans = - 1 ; int temp = 0 ; HashSet < Integer > set = new HashSet < > ( ) ; int p = 0 ; while ( set . size ( ) != n ) { ans ++ ; if ( p % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ! set . contains ( i ) && arr [ i ] <= temp ) { set . add ( i ) ; temp ++ ; } } p ++ ; } else { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ! set . contains ( i ) && arr [ i ] <= temp ) { set . add ( i ) ; temp ++ ; } } p ++ ; } } return ans ; }
public static void solve ( String input ) { int R = Integer . parseInt ( input ) ; int N = Integer . parseInt ( input ) ; if ( R == 0 || N == 0 ) { break ; } int geta = 20 ; int [ ] buildings = new int [ geta * 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { int xl = Integer . parseInt ( input ) ; int xr = Integer . parseInt ( input ) ; int h = Integer . parseInt ( input ) ; for ( int j = xl + geta ; j <= xr ; j ++ ) { buildings [ j ] = Math . max ( buildings [ j ] , h ) ; } } int left = 0 , right = 20 ; for ( int i = 0 ; i < 100 ; i ++ ) { int mid = ( left + right ) / 2 ; boolean flag = true ; for ( int j = - R + geta ; j <= R + geta ; j ++ ) { if ( j < geta ) { double y = Math . pow ( R * R - ( j - geta + 1 ) * ( j - geta + 1 ) , 0.5 ) ; flag &= buildings [ j ] >= y - R + mid ; } else { double y = Math . pow ( R * R - ( j - geta ) * ( j - geta ) , 0.5 ) ; flag &= buildings [ j ] >= y - R + mid ; } } if ( flag ) { left = mid ; } else { right = mid ; } } System . out . println ( left + " : " + right ) ; }
public static String getRandom ( String s ) { int i = 0 ; int r = 0 ; for ( int x = 0 ; x < s . length ( ) ; x ++ ) { i ++ ; r = ( i == 0 ) ? r : i ; } return s . substring ( 0 , s . length ( ) ) ; }
public static String getDigitsMask ( String mask ) { if ( mask == null ) { return null ; } if ( mask . length ( ) == 0 ) { return null ; } return mask . substring ( mask . length ( ) - 1 ) ; }
public static double maxAlternateSum ( double [ ] arr , int n ) { if ( ( n == 1 ) ) { return arr [ 0 ] ; } int [ ] dec = new int [ n + 1 ] ; int [ ] inc = new int [ n + 1 ] ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] > arr [ i ] ) ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( ( arr [ j ] < arr [ i ] ) && ( flag == 1 ) ) { inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } } double result = Double . NEGATIVE_INFINITY ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( result < inc [ i ] ) ) { result = inc [ i ] ; } if ( ( result < dec [ i ] ) ) { result = dec [ i ] ; } } return result ; } arr = new double [ ] { 8 , 2 , 3 , 5 , 7 , 9 , 10 } ; n = arr . length ; System . out . println ( " Maximum ▁ sum ▁ = " + maxAlternateSum ( arr , n ) ) ; return result ; }
static void generateArr ( int [ ] arr , int n ) { if ( ( n == 1 ) ) { System . out . println ( arr [ 0 ] ) ; return ; } int [ ] barr = new int [ n ] ; barr [ 0 ] = arr [ 0 ] & arr [ 1 ] ; barr [ n - 1 ] = arr [ n - 1 ] & arr [ n - 2 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { barr [ i ] = arr [ i - 1 ] & arr [ i + 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( barr [ i ] + " ▁ " ) ; } } if ( Class . isPrimitive ( String . class ) ) { arr = new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 } ; n = arr . length ; generateArr ( arr , n ) ; }
protected static void replaceElements ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; } arr = new int [ ] { 2 , 3 , 4 , 5 , 6 } ; n = arr . length ; replaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
protected static void replaceElements ( int [ ] arr , int n ) { if ( ( n <= 1 ) ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev + arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev + arr [ n - 1 ] ; } if ( Class . class . equals ( arr [ 0 ] ) ) { arr = new int [ ] { 2 , 3 , 4 , 5 , 6 } ; n = arr . length ; replaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int countTriplets ( int A , int B , int C ) { int ans = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( ( i * k > j * j ) ) { ans ++ ; } } } } return ans ; }
public static int getPrimeNumber ( int [ ] numbers ) { int MAX = 100000 ; boolean [ ] prime = new boolean [ MAX + 1 ] ; for ( int i = 2 ; i <= ( int ) Math . sqrt ( MAX ) ; i ++ ) { if ( ( prime [ i ] = true ) == true ) { for ( int j = i * j ; j <= MAX ; j += j ) { prime [ j ] = false ; } } } int smallestPrime ( int d ) { int l = 10 * ( numbers [ i ] - 1 ) ; int r = ( 10 * d ) - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( prime [ i ] ) != true ) { return i ; } } return - 1 ; } int largestPrime ( int d ) { int l = 10 * ( numbers [ i ] - 1 ) ; int r = ( 10 * d ) - 1 ; for ( int i = r ; i >= l ; i -- ) { if ( ( prime [ i ] ) != true ) { return i ; } } return - 1 ; } if ( numbers [ 0 ] == 0 ) { return 0 ; } if ( numbers [ 1 ] == 1 ) { return 1 ; } if ( numbers [ 2 ] == 2 ) { return 2 ; } if ( numbers [ 3 ] == 3 ) { return 3 ; } if ( numbers [ 4 ] == 4 ) { return 4 ; } if ( numbers [ 5 ] == 5 ) { return 5 ; } if ( numbers [ 6 ] == 4 ) { return 4 ; } if ( numbers [ 7 ] == 5 ) { return 5 ; } if ( numbers [ 8 ] == 4 ) { return 4 ; } if ( numbers [ 9 ] == 5 ) { return 5 ; } if ( numbers [ 10 ] == 4 ) { return 4 ; } if ( numbers [ 11 ] == 5 ) { return 5 ; } if ( numbers [ 12 ] == 4 ) { return 4 ; } if ( numbers [ 13 ] == 5 ) { return 5 ; } if ( numbers [ 14 ] == 5 ) { return 5 ; } if ( numbers [ 15 ] == 4 ) { return 5 ; } if ( numbers [ 15 ] == 4 ) { return 5 ; } return 0 ; if ( numbers [ 15 ] == 4 ) { return 5 ; } return 0 ; }
public static int INF ( int INF ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int m = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int [ ] dist = new int [ n ] ; int [ ] weth = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { dist [ i ] = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; } for ( int i = 0 ; i < m ; i ++ ) { weth [ i ] = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; } int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = n ; j > 0 ; j -- ) { dp [ j ] = Math . min ( dp [ j ] , dp [ j - 1 ] + dist [ j - 1 ] * weth [ i ] ) ; } } return dp [ n ] ; }
public static int getRank ( int rank ) { int [ ] array = new int [ rank ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } return array . length ; }
public static String [ ] readInput ( String inputPath ) { final String [ ] t ; if ( inputPath == null ) { f = new String ( System . in ) ; } else { f = new String ( inputPath ) ; } int n = Integer . parseInt ( f . substring ( 0 , 1 ) ) ; int m = Integer . parseInt ( f . substring ( 1 , 2 ) ) ; int a = Integer . parseInt ( f . substring ( 2 , 3 ) ) ; int d = Integer . parseInt ( f . substring ( 3 , 4 ) ) ; int [ ] t = new int [ ] { Integer . parseInt ( f . substring ( 4 , 5 ) ) } ; return t ; }
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static int getDayNumber ( int [ ] array ) { int [ ] result = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == 0 ) { result [ i ] = 1 ; } else { result [ i ] = 1 ; } } int cnt = 0 ; x = true ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] % 2 != 0 && cnt < 1 ) { cnt ++ ; } else if ( array [ i ] % 2 != 0 && cnt >= 1 ) { x = false ; break ; } } if ( x ) { result [ i ] = 1 ; } else if ( ! x && array . length % 2 == 0 ) { result [ i ] = 2 ; } else if ( ! x && array . length % 2 != 0 ) { result [ i ] = 2 ; } return result [ i ] ; }
public static int reverse ( int n ) { int rev = 0 ; while ( ( n != 0 ) ) { rev = ( rev * 10 ) + ( n % 10 ) ; n /= 10 ; } return rev ; }
public static void disp ( int rowNo , int block ) { System . out . println ( rowNo * block ) ; int row ( ht , h ) { return ht / h ; } int noBlock = ( 4 * a ) / l ; if ( ( h < w ) ) { rowNo = row ( ht , w ) ; } else { rowNo = row ( ht , h ) ; } disp ( rowNo , noBlock ) ; if ( Class . forName ( " java . lang . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation
public static int maxFreq ( String s ) { String binary = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { binary += bin . charAt ( ( int ) s . charAt ( i ) - '0' ) ; } binary = binary . substring ( 0 , binary . length ( ) - 1 ) ; int count = 1 ; int prev = - 1 ; int j = 0 ; for ( int i = binary . length ( ) - 1 ; i >= 0 ; i -- ) { if ( ( binary . charAt ( i ) == '1' ) ) { count = Math . max ( count , j - prev ) ; prev = j ; } j ++ ; } return count ; } if ( String . valueOf ( " " ) . equals ( " " ) ) { String octal = "13" ; System . out . println ( maxFreq ( octal ) ) ; } return 0 ; }
public static String isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; }
public static double harmonicMean ( double [ ] arr , double [ ] freq , int n ) { double sm = 0 ; double frequencySum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sm = sm + freq [ i ] / arr [ i ] ; frequencySum = frequencySum + freq [ i ] ; } return ( Math . round ( frequencySum / sm ) ) ; }
public static double polyArea ( double n , double a ) { if ( ( a < 0 && n < 0 ) ) { return - 1 ; } double A = ( a * a * n ) / ( 4 * Math . tan ( ( 180 / n ) * Math . PI / 180 ) ) ; return A ; }
public static int __gcd ( int a , int b ) { if ( ( a == 0 ) ) { return b ; } if ( ( b == 0 ) ) { return a ; } if ( ( a == b ) ) { return a ; } if ( ( a > b ) ) { return __gcd ( a - b , b ) ; } return __gcd ( a , b - a ) ; }
public static void solve ( String [ ] args ) { int M = 0 , Nmin = 0 , Nmax = 0 ; for ( String n : args ) { if ( n . startsWith ( " - " ) ) { M = M + n . length ( ) ; Nmin = M ; Nmax = M ; } } if ( M + Nmin + Nmax == 0 ) { break ; } int [ ] P = new int [ M ] ; for ( int i = 0 ; i < P . length - 1 ; i ++ ) { P [ i ] = Integer . parseInt ( args [ i ] ) ; } int [ ] dif = new int [ M ] ; for ( int i = 0 ; i < P . length - 1 ; i ++ ) { dif [ i + 1 ] = P [ i ] - P [ i + 1 ] ; } int ans = Nmin ; int tmp = dif [ Nmin ] ; for ( int i = Nmin + 1 ; i <= Nmax ; i ++ ) { if ( dif [ i ] >= tmp ) { ans = i ; tmp = dif [ i ] ; } } System . out . println ( ans ) ; }
public static String getCountry ( String country ) { String country = country . toLowerCase ( ) ; if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 ) ; } return country ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { String n = args [ i ] ; Map < String , Integer > m = new HashMap < > ( ) ; int [ ] x = Integer . parseInt ( args [ i ] ) ; for ( int j = 0 ; j < x . length ; j ++ ) m . put ( x [ j ] , j + 1 ) ; m . clear ( ) ; m . put ( args [ i ] , m . size ( ) ) ; System . out . println ( m . get ( args [ i ] ) . toString ( ) + m . get ( args [ args . length - 1 ] ) . toString ( ) ) ; } }
public static int findIndex ( int n ) { double fibo = 2.078087 * Math . log ( n ) + 1.672276 ; return Math . round ( fibo ) ; }
public static boolean isSmaller ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( ( n1 < n2 ) ) { return true ; } if ( ( n2 < n1 ) ) { return false ; } for ( int i = 0 ; i < n1 ; i ++ ) { if ( ( str1 . charAt ( i ) < str2 . charAt ( i ) ) ) { return true ; } else if ( ( str1 . charAt ( i ) > str2 . charAt ( i ) ) ) { return false ; } } return false ; }
public static int minSwaps ( String s1 , String s2 ) { int c0 = 0 ; int c1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '1' ) ) { c0 ++ ; } else if ( ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) ) { c1 ++ ; } } int ans = c0 / 2 + c1 / 2 ; if ( ( c0 % 2 == 0 ) && ( c1 % 2 == 0 ) ) { return ans ; } else if ( ( ( c0 + c1 ) % 2 == 0 ) ) { return ans + 2 ; } else { return - 1 ; } if ( Class . forName ( " java . util . regex . regex " ) . equals ( s1 ) ) { s1 = "0011" ; s2 = "1111" ; ans = minSwaps ( s1 , s2 ) ; } return ans ; }
public static int max ( int a , int b ) { if ( a < b ) return b ; else return a ; int [ ] X = new int [ N * 2 ] ; int [ ] seg = new int [ N * 2 ] ; int i ; int j ; int k ; int vl ; int vr ; for ( i = 0 ; i < N ; i ++ ) { while ( ( j = i + j ) < N ) { N *= 2 ; } seg [ j ] = 0 ; } for ( j = 0 ; j < N ; j ++ ) { if ( seg [ j ] < seg [ j ] ) { seg [ j ] = 0 ; } } for ( j = 0 ; j < N ; j ++ ) { if ( seg [ j ] < seg [ j ] ) { seg [ j ] = seg [ j ] ; } } for ( j = 0 ; j < N ; j ++ ) { if ( seg [ j ] < seg [ j ] ) { seg [ j ] = seg [ j ] ; } } return i ; }
public static int sum ( int [ ] a ) { int p = a . length ; int c = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] == ' ^ ' ) { c ++ ; } } return c ; }
public static void normalSieve ( int n ) { int [ ] prime = new int [ ( int ) ( n / 2 ) ] ; int i = 3 ; while ( ( i * i < n ) ) { if ( ( prime [ ( int ) ( i / 2 ) ] == 0 ) ) { int j = i * i ; while ( ( j < n ) ) { prime [ ( int ) ( j / 2 ) ] = 1 ; j += i * 2 ; } } i += 2 ; } System . out . print ( 2 + " ▁ " ) ; i = 3 ; while ( ( i < n ) ) { if ( ( prime [ ( int ) ( i / 2 ) ] == 0 ) ) { System . out . print ( i + " ▁ " ) ; } i += 2 ; } if ( Class . forName ( " java . util . regex . regex " ) . equals ( " java . util . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex
public static String getCountry ( String country ) { String country = country . toLowerCase ( ) ; if ( country . length ( ) > 0 ) { country = country . substring ( 0 , 1 ) ; } else if ( country . length ( ) > 0 ) { country = country . substring ( 0 , 1 ) ; } else if ( country . length ( ) > 0 ) { country = country . substring ( 0 , 1 ) ; } return country ; }
public static int frequencyOfSmallest ( int n , int [ ] arr ) { int mn = arr [ 0 ] ; int freq = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] < mn ) ) { mn = arr [ i ] ; freq = 1 ; } else if ( ( arr [ i ] == mn ) ) { freq ++ ; } } return freq ; }
public static boolean isSubArray ( int [ ] A , int [ ] B , int n , int m ) { int i = 0 ; int j = 0 ; while ( ( i < n ) && ( j < m ) ) { if ( ( A [ i ] == B [ j ] ) ) { i ++ ; j ++ ; if ( ( j == m ) ) { return true ; } } else { i = i - j + 1 ; j = 0 ; } } return false ; }
public static int getLargestIndex ( int [ ] array ) { int i = 0 ; for ( int j = 0 ; j < array . length ; j ++ ) { if ( array [ j ] == array [ j ] ) { i ++ ; } } return i ; }
static int calculateSum ( int n , int k ) { int res = 1 ; int MOD = 1000000007 ; for ( int i = 0 ; i <= k ; i ++ ) { res = ( res * n ) % MOD ; } return res ; }
public static boolean ok ( String last4 ) { for ( int i = 0 ; i < 4 ; i ++ ) { char [ ] t = last4 . toCharArray ( ) ; if ( i >= 1 ) { t [ i ] = t [ i - 1 ] ; } if ( Arrays . binarySearch ( t , " AGC " ) >= 0 ) { return false ; } } return true ; }
public static int sumsell ( int sumn ) { int at , n ; while ( true ) { try { at = Integer . parseInt ( input ( ) ) ; n = Integer . parseInt ( input ( ) ) ; } catch ( NumberFormatException e ) { break ; } } return sumsell ; }
public static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) { C [ j ] = C [ j ] + C [ j - 1 ] ; } } return C [ k ] ; }
public static String getValidString ( String str ) { if ( str == null ) { return null ; } String [ ] strs = str . split ( " ▁ " ) ; for ( int i = 0 ; i < strs . length ; i ++ ) { if ( strs [ i ] . equalsIgnoreCase ( strs [ i ] ) ) { return strs [ i ] ; } } return null ; }
public static int pairCount ( int [ ] arr , int n ) { int maxVal = arr [ 0 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] > maxVal ) ) { maxVal = arr [ i ] ; } } boolean [ ] prime = new boolean [ maxVal + 1 ] ; prime [ 0 ] = false ; prime [ 1 ] = false ; int k = ( int ) Math . sqrt ( maxVal ) + 1 ; for ( int p = 2 ; p <= k ; p += 1 ) { if ( ( prime [ p ] = true ) == true ) { for ( int i = p * 2 ; i <= maxVal ; i += p ) { prime [ i ] = false ; } } } int count = 0 ; for ( int i = 0 ; i <= n ; i += 1 ) { if ( ( prime [ arr [ i ] ] = true ) == true ) { count ++ ; } } return ( count * ( count - 1 ) ) / 2 ; }
public static int getPrime ( int [ ] arr , int n ) { int maxVal = arr [ 0 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] > maxVal ) ) { maxVal = arr [ i ] ; } } boolean [ ] prime = new boolean [ maxVal + 1 ] ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; ( int ) Math . sqrt ( maxVal ) + 1 ; p += 1 ) { if ( ( prime [ p ] = true ) == true ) { for ( int i = p * 2 ; i <= maxVal ; i += p ) { prime [ i ] = false ; } } } int maximum = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( prime [ arr [ i ] ] ) != true ) { maximum = Math . max ( maximum , arr [ i ] ) ; } } return maximum ; }
public static String compute ( ) { return String . valueOf ( NUMBERS ) . substring ( 0 , 10 ) ; }
static void findElements ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } arr = new int [ ] { 2 , - 6 , 3 , 5 , 1 } ; n = arr . length ; findElements ( arr , n ) ; }
static void printDistinct ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i < n - 1 ) && arr [ i ] == arr [ i + 1 ] ) { while ( ( i < n - 1 ) && ( arr [ i ] == arr [ i + 1 ] ) ) { i ++ ; } } else { System . out . print ( arr [ i ] + " ▁ " ) ; } } arr = new int [ ] { 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 } ; n = arr . length ; printDistinct ( arr , n ) ; }
public static int getRandom ( ) { int a , b ; a = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; b = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; System . out . println ( a * b ) ; return a ; }
public static int nthTerm ( int a , int b , int n ) { int z = 0 ; if ( ( n % 6 ) == 1 ) { z = a ; } else if ( ( n % 6 ) == 2 ) { z = b ; } else if ( ( n % 6 ) == 3 ) { z = b - a ; } else if ( ( n % 6 ) == 4 ) { z = - a ; } else if ( ( n % 6 ) == 5 ) { z = - b ; } if ( ( n % 6 ) == 0 ) { z = - ( b - a ) ; } return z ; }
static int findSubSequence ( String s , int num ) { int res = 0 ; int i = 0 ; while ( ( num ) != 0 ) { if ( ( num & 1 ) != 0 ) { res += ( int ) s . charAt ( i ) - '0' ; } i ++ ; num = num >> 1 ; } return res ; }
public static int minimumCost ( int [ ] cost , int n ) { int dp1 = 0 ; int dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
public static int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
public static int longSub ( String str , int k ) { final int SIZE = 26 ; int [ ] freq = new int [ 26 ] ; int start = 0 ; int maxLen = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { char ch = str . charAt ( i ) ; freq [ ( int ) ch - ' a ' ] ++ ; if ( ( freq [ ( int ) ch - ' a ' ] > k ) ) { if ( ( maxLen < ( i - start ) ) ) { maxLen = i - start ; } while ( ( freq [ ( int ) ch - ' a ' ] > k ) ) { freq [ ( int ) str . charAt ( start ) - ' a ' ] -- ; start = start + 1 ; } } } if ( ( maxLen < ( n - start ) ) ) { maxLen = n - start ; } return maxLen ; } str = " babcaag " ; k = 1 ; System . out . println ( " Length ▁ = " + longSub ( str , k ) ) ; return 0 ; }
public static String getRandom ( String s ) { int i = 0 ; int n = Integer . parseInt ( s ) ; int sa = 0 ; int sg = 0 ; for ( i = 0 ; i < n ; i ++ ) { int a = Integer . parseInt ( s ) ; int g = Integer . parseInt ( s ) ; if ( a <= g ) { if ( sa + a - sg <= 500 ) { sa += a ; System . out . print ( " A " ) ; } else { sg += g ; System . out . print ( " G " ) ; } } else { if ( sg + g - sa <= 500 ) { sg += g ; System . out . print ( " G " ) ; } else { sa += a ; System . out . print ( " A " ) ; } } } return s ; }
public static String toHex ( ) { String out = " " ; if ( null == out ) { out = " " ; } else { out = " " ; } if ( null == out ) { out = " " ; } else { out = " " ; } if ( null == out ) { out = " " ; } else { out = " " ; } return out . concat ( " " ) ; }
public static String [ ] getStrings ( String [ ] array ) { int start = 0 ; String [ ] arr = new String [ array . length ] ; int count = 0 ; for ( int i = 0 ; i <= array . length ; i ++ ) { String string = " " ; int next = start ; for ( int j = 0 ; j <= array [ i ] . length ; j ++ ) { if ( count < array [ i ] . length ) { if ( j == next ) { string += ' L ' ; count ++ ; next += 2 ; if ( next >= array [ i ] . length ) { start = start == 0 ? 1 : 0 ; } } else { string += " S " ; } } else { string += " S " ; } } arr [ i ] = string . split ( " ▁ " ) ; } if ( count < array [ 1 ] . length ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; for ( String s : arr ) { System . out . println ( s ) ; } } return arr ; }
public static void longestString ( String str1 , String str2 ) { int [ ] count1 = new int [ 26 ] ; int [ ] count2 = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { count1 [ ( int ) str1 . charAt ( i ) - ( int ) ' a ' ] ++ ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { count2 [ ( int ) str2 . charAt ( i ) - ( int ) ' a ' ] ++ ; } String result = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result = result + ( char ) ( int ) ( ' a ' + i ) ; } } System . out . println ( result ) ; if ( className . equals ( " java . util . regex . regex . regex " ) ) { str1 = " geeks " ; str2 = " cake " ; longestString ( str1 , str2 ) ; } }
public static int msb ( int x ) { int ret = 0 ; while ( ( ( x >>> ( ret + 1 ) ) != 0 ) ) { ret = ret + 1 ; } return ret ; }
public static void q1 ( String s , int i ) { if ( ( i == s . length ( ) ) ) { System . out . println ( " Yes " ) ; return ; } if ( ( s . charAt ( i ) == ' a ' ) ) { q1 ( s , i + 1 ) ; } else { q2 ( s , i + 1 ) ; } }
public static String getHashString ( String [ ] args ) { String [ ] nextLine = System . getProperty ( " line . separator " ) . split ( " ▁ " ) ; String [ ] result = new String [ args . length ] ; for ( int i = 0 ; i < args . length ; i ++ ) { result [ i ] = Integer . parseInt ( nextLine [ i ] ) ; } return result ; }
public static void findTime ( String T , int K ) { int minutes = ( ( ( ( int ) T . charAt ( 0 ) - '0' ) ) * 10 + ( ( int ) T . charAt ( 1 ) - '0' ) * 60 + ( ( ( int ) T . charAt ( 3 ) - '0' ) * 10 + ( ( int ) T . charAt ( 4 ) - '0' ) ) ) ; minutes += K ; int hour = ( ( int ) ( minutes / 60 ) ) % 24 ; int min = minutes % 60 ; if ( ( hour < 10 ) ) { System . out . print ( " 0 " + hour + " : " ) ; } else { System . out . print ( hour + " : " ) ; } if ( ( min < 10 ) ) { System . out . println ( " 0 " + min ) ; } else { System . out . println ( minStr ) ; } } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { T = "21:39" ; K = 43 ; findTime ( T , K ) ; }
public static void maxProductSum ( String string , int m ) { int n = string . length ( ) ; int maxProd = ( - ( Integer . MAX_VALUE ) - 1 ) , maxSum = ( - ( Integer . MAX_VALUE ) - 1 ) ; for ( int i = 0 ; i < n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j <= m ; j ++ ) { product = product * ( ( int ) string . charAt ( j ) - '0' ) ; sum = sum + ( ( int ) string . charAt ( j ) - '0' ) ; } maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } System . out . println ( " Maximum ▁ Product ▁ = " + maxProd ) ; System . out . println ( " Maximum ▁ Sum ▁ = " + maxSum ) ; } if ( String . valueOf ( string ) . toUpperCase ( ) . equals ( " " ) ) { string = "3675356291" ; m = 5 ; maxProductSum ( string , m ) ; } }
public static int minCost ( int [ ] [ ] cost , int m , int n ) { if ( ( n < 0 ) || ( m < 0 ) ) { return Integer . MAX_VALUE ; } else if ( ( m == 0 ) && ( n == 0 ) ) { return cost [ m ] [ n ] ; } else { return cost [ m ] [ n ] + Math . min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } else { if ( ( x < y ) ) { return ( x < z ) ? x : z ; } else { return ( y < z ) ? y : z ; } } }
public static int min ( int [ ] array ) { int n = array [ 0 ] ; Arrays . sort ( array ) ; return array [ n ] ; }
public static int diff ( int x , int y ) { int ans ; int N = 0 , Q = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { ws [ i ] = 0 ; par [ i ] = - 1 ; for ( int i = 0 ; i < MAX * 2 ; i ++ ) { par [ i ] = i ; } } int [ ] p = new int [ MAX * 2 ] ; for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } for ( int i = 0 ; i < P ; i ++ ) { p [ i ] = p [ i ] ; } return 1 ; }
public static int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) { if ( ( i % M ) == 0 ) { sum += i ; } } return sum ; }
public static int countNumbersWith4 ( int n ) { if ( ( n < 4 ) ) { return 0 ; } int d = ( int ) Math . log10 ( n ) ; int [ ] a = new int [ d + 1 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = 1 ; } a [ 0 ] = 0 ; if ( a . length > 1 ) { a [ 1 ] = 1 ; } for ( int i = 2 ; i <= d ; i ++ ) { a [ i ] = a [ i - 1 ] * 9 + Math . ceil ( Math . pow ( 10 , i - 1 ) ) ; } int p = Math . ceil ( Math . pow ( 10 , d ) ) ; int msd = n / p ; if ( ( msd == 4 ) ) { return ( msd ) * a [ d ] + ( n % p ) + 1 ; } if ( ( msd > 4 ) ) { return ( ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ) ; } return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
public static int [ ] getNegativeInstances ( ) { int [ ] values = new int [ 2 ] ; for ( int i = 0 ; i < values . length ; i ++ ) { values [ i ] = i ; } return values ; }
public static void findPostOrderUtil ( int [ ] pre , int n , int minval , int maxval , int [ ] preIndex ) { if ( ( preIndex [ 0 ] == n ) ) return ; if ( ( pre [ preIndex [ 0 ] ] < minval ) || ( pre [ preIndex [ 0 ] ] > maxval ) ) return ; int val = pre [ preIndex [ 0 ] ] ; preIndex [ 0 ] ++ ; findPostOrderUtil ( pre , n , minval , val , preIndex ) ; findPostOrderUtil ( pre , n , val , maxval , preIndex ) ; System . out . print ( val ) ; }
static int countWays ( int n , int [ ] arr , int k ) { if ( ( k <= 0 ) || ( k >= n ) ) { return 0 ; } HashSet < Integer > s = new HashSet < > ( ) ; for ( int element : arr ) { s . add ( element ) ; } if ( ( s . size ( ) <= k ) ) { return 0 ; } return s . size ( ) - k ; }
public static String getIp ( String ip ) { StringBuilder ret = new StringBuilder ( ) ; for ( int k = 0 ; k < Integer . parseInt ( cnt ) ; k ++ ) { ip = ip . trim ( ) ; if ( ip . equals ( " " ) ) { System . out . println ( "0000:0000:0000:0000:0000:0000:0000:0000:0000:0000:0000:0000:00000" ) ; continue ; } String [ ] array = ip . split ( " : " ) ; ret . append ( " " ) ; if ( array [ 0 ] . equals ( " " ) ) { array = new StringBuilder ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { array . append ( "0000" ) ; } ret . append ( array [ 2 ] ) ; } else if ( array [ array . length - 1 ] . equals ( " " ) ) { array = new StringBuilder ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { array . append ( "0000" ) ; } ret . append ( array [ i ] ) ; } } for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] . equals ( " " ) ) { array [ i ] = "0" ; } } System . out . println ( ret . toString ( ) ) ; return ret . toString ( ) ; }
public static boolean isPrime ( int n ) { int flag = 1 ; int i = 2 ; while ( ( i * i <= n ) ) { if ( ( n % i == 0 ) ) { flag = 0 ; break ; } i ++ ; } return ( flag == 1 ) ? true : false ; }
public static int [ ] getNegativeInstances ( ) { int [ ] [ ] W = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { W [ i ] [ i ] = new int [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( W [ i ] [ 0 ] != W [ i - 1 ] [ W [ i - 1 ] ] ) { cnt = 1 ; } } Arrays . sort ( W ) ; for ( int i = 1 ; i < N ; i ++ ) { if ( W [ i ] == W [ i - 1 ] [ 0 ] ) { cnt = 1 ; } } if ( cnt == 1 ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; } return W ; }
static int findNum ( int [ ] div , int [ ] rem , int N ) { int num = rem [ N - 1 ] ; int i = N - 2 ; while ( ( i >= 0 ) ) { num = num * div [ i ] + rem [ i ] ; i -- ; } return num ; }
public static void segregate0and1 ( int [ ] arr , int size ) { int type0 = 0 ; int type1 = size - 1 ; while ( ( type0 < type1 ) && ( ( arr [ type0 ] ) == 1 ) ) { ( arr [ type0 ] ) = ( arr [ type1 ] ) ; type1 -- ; } else { type0 ++ ; } arr [ 0 ] = 0 ; arr [ 1 ] = 0 ; arr [ 2 ] = 1 ; arr [ 3 ] = 1 ; int arrSize = arr . length ; segregate0and1 ( arr , arrSize ) ; System . out . print ( " Array ▁ after ▁ segregation ▁ is " ) ; for ( int i = 0 ; i <= arrSize ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
public static int [ ] getNegativeInstances ( ) { int [ ] values = new int [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 19 , 20 , 21 , 22 , 23 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24
public static String getLetter ( String s ) { String t = s . toLowerCase ( ) ; int a = t . charAt ( 0 ) - s . charAt ( 0 ) ; int b = Integer . parseInt ( t . substring ( 1 ) ) - Integer . parseInt ( s . substring ( 1 ) ) ; int x = Math . abs ( a ) ; int y = Math . abs ( b ) ; char c [ ] = { ' R ' , ' U ' , ' L ' , ' D ' } ; int i = 0 ; int j = 1 ; if ( a < 0 ) { i = 2 ; } if ( b < 0 ) { j = 3 ; } int k = j ; if ( x > y ) { k = i ; x = y ; y = x ; } char m = c [ i ] + c [ j ] ; char n = c [ k ] ; System . out . println ( y ) ; for ( int l = 0 ; l < x ; l ++ ) { System . out . println ( m ) ; } for ( int l = 0 ; l < y - x ; l ++ ) { System . out . println ( n ) ; } return t ; }
public static int f ( ) { return Integer . parseInt ( input ( ) ) ; int h = f ( ) ; int w = f ( ) ; System . out . println ( Arrays . stream ( f ( ) . map ( x -> Math . pow ( ( x + 1 ) * ( w - x ) * v ) ) . filter ( y -> y + 1 ) . filter ( y -> y != h ) . count ( ) ) ) ; }
public static int [ ] getNegativeInstances ( ) { int [ ] [ ] L = new int [ n ] [ n ] ; for ( int i = 0 ; i < L . length ; i ++ ) { L [ i ] = Integer . parseInt ( System . getProperty ( " " ) ) ; } for ( int j = 0 ; j < L [ 0 ] . length ; j ++ ) { int Y = L [ i ] [ j ] ; if ( Y == 1 || ArrayUtils . contains ( Y , L [ t ] [ j ] ) ) continue ; System . out . println ( " NO " ) ; System . exit ( 0 ) ; } return L ; }
public static int getUnsignedInt ( String input ) { int a = Integer . parseInt ( input ) , b = Integer . parseInt ( input ) ; int MAX = ( 1 << 32 ) - 1 ; return a & b ; }
public static int x ( ) { int x = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; System . out . println ( f " { x : 032b } " ) ; System . out . println ( f " { ~ x ▁ & ▁ 0xffffffff : 032b } " ) ; System . out . println ( f " { x ▁ < < ▁ 1 ▁ & ▁ 0xffffffff : 032b } " ) ; System . out . println ( f " { x ▁ > > ▁ 1:032b } " ) ; return x ; }
public static int getHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash
public static int getDistance ( int [ ] array , int start , int end ) { if ( array == null ) { return - 1 ; } if ( start == 0 ) { return - 1 ; } if ( end == 1 ) { return - 1 ; } if ( start == 1 ) { return - 1 ; } if ( end == 2 ) { return - 1 ; } if ( start == 3 ) { return - 1 ; } if ( start == 4 ) { return - 1 ; } if ( start == 5 ) { return - 1 ; } if ( start == 6 ) { return - 1 ; } if ( start == 7 ) { return - 1 ; } if ( start == 8 ) { return - 1 ; } if ( start == 9 ) { return - 1 ; } if ( start == 10 ) { return - 1 ; } if ( start == 11 ) { return - 1 ; } if ( start == 12 ) { return - 1 ; } if ( start == 13 ) { return - 1 ; } if ( start == 14 ) { return - 1 ; } if ( start == 15 ) { return - 1 ; } if ( start == 16 ) { return - 1 ; } if ( start == 17 ) { return - 1 ; } if ( start == 18 ) { return - 1 ; } if ( start == 19 ) { return - 1 ; } if ( start == 19 ) { return - 1 ; } if ( start == 19 ) { return - 1 ; } if ( start == 19 ) { return - 1 ; } if ( start == 20 ) { return - 1 ; } if ( start == 21 ) { return - 1 ; } if ( start == 22 ) { return - 1 ; } if ( start == 23 ) { return - 1 ; } if ( start == 23 ) { return - 1 ; } if ( start == 23 ) { return - 1 ; } if ( start == 23 ) { return - 1 ; } if ( start == 59 ) { return - 1 ; } if ( start == 59 ) { return - 1 ; } return - 1 ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalposi
public static int [ ] getNegativeInstances ( ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = Integer . parseInt ( a [ i ] ) ; } int [ ] d = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { d [ i ] = 0 ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { d [ i ] = a [ i + 1 ] - a [ i ] ; } int cnt = 1 ; int l = 0 ; int r = 0 ; int cur = 0 ; while ( l < n - 1 ) { while ( r < n - 1 && cur * d [ r ] >= 0 ) { if ( cur == 0 ) { cur = d [ r ] ; } r ++ ; } if ( r < n - 1 && cur * d [ r ] < 0 ) { cnt ++ ; } r ++ ; l = r ; cur = 0 ; } return d ; }
public static int countPairs ( String s ) { int [ ] cnt = new int [ MAX ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { cnt [ i ] = 0 ; } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { cnt [ ( int ) s . charAt ( i ) - 97 ] ++ ; } int ans = 0 ; for ( int i = 0 ; i <= MAX ; i ++ ) { ans += cnt [ i ] * cnt [ i ] ; } return ans ; }
public static int [ ] getprime ( int n ) { int [ ] prime = new int [ 100005 ] ; Arrays . fill ( prime , 0 ) ; for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p <= ( int ) Math . sqrt ( n ) ; p ++ ) if ( prime [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) prime [ i ] = false ; } Arrays . sort ( prime ) ; int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] == 0 ) v [ i ] = arr [ i ] ; Arrays . sort ( v ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] == true ) System . out . print ( arr [ i ] + " ▁ " ) ; else { System . out . print ( v [ j ] + " ▁ " ) ; j ++ ; } if ( Integer . parseInt ( System . getProperty ( " java . util . regex . regex . regex " ) ) == null ) { int n = 6 ; int [ ] arr = { 100 , 11 , 500 , 2 , 17 , 1 } ; Arrays . sort ( arr ) ; } return v ; }
@ VisibleForTesting static int gcdFibonacciFreq ( int [ ] arr , int n ) { int [ ] arr = { 5 , 3 , 6 , 5 , 6 , 6 , 5 , 5 } ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { int prev = arr [ i ] , curr = arr [ i ] ; if ( ( i + 1 ) < n ) { arr [ i ] = arr [ i + 1 ] ; } else { arr [ i + 1 ] = arr [ i ] ; } } return arr [ n ] ; }
public static double findArea ( double a ) { double R = a * ( 2.0 - Math . sqrt ( 2 ) ) ; double area = 3.14 * R * R / 2.0 ; return area ; }
static int findQuadruples ( int [ ] a , int [ ] b , int [ ] c , int [ ] d , int x , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int l = 0 ; l < n ; l ++ ) { if ( ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) ) { count ++ ; } } } } } return count ; }
public static void findSmallest ( String s , int [ ] [ ] q , int m ) { int N = s . length ( ) ; int [ ] [ ] H = new int [ 26 ] [ ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) { H [ i ] [ ( int ) s . charAt ( i - 1 ) - ( int ) ' a ' ] ++ ; for ( int j = 0 ; j < 26 ; j ++ ) { H [ i ] [ j ] += H [ i - 1 ] [ j ] ; } } for ( int j = 0 ; j < m ; j ++ ) { int l = q [ j ] [ 0 ] ; int r = q [ j ] [ 1 ] ; int n = q [ j ] [ 2 ] ; int sum = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { sum += H [ r ] [ i ] - H [ l - 1 ] [ i ] ; if ( ( sum >= n ) ) { System . out . println ( ( char ) ( ( int ) ' a ' + i ) ) ; break ; } } } if ( String . valueOf ( s ) . equals ( " afbccdeb " ) ) { s = " afbccdeb " ; q = new int [ ] [ ] { { 2 , 4 , 1 } , { 1 , 6 , 4 } , { 1 , 8 , 7 } } ; int x = q . length ; findSmallest ( s , q , x ) ; } }
public static int miner ( int a , int b , String mines ) { int s = 0 ; int j = 0 ; while ( j < mines . length ( ) && mines . charAt ( j ) != '1' ) { j ++ ; } if ( j == mines . length ( ) ) { return 0 ; } for ( int i = j + 1 ; i < mines . length ( ) ; i ++ ) { if ( mines . charAt ( i ) == '0' && mines . charAt ( i - 1 ) == '1' ) { int r1 = i - 1 ; if ( mines . charAt ( i ) == '1' && mines . charAt ( i - 1 ) == '0' ) { s += Math . min ( b * ( i - r1 - 1 ) , a ) ; } } } s += a ; return s ; } int t = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; for ( ; ; ) { a = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; b = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; mines = System . console ( ) . readLine ( ) ; System . out . println ( miner ( a , b , mines ) ) ; }
public static int getDistance ( int [ ] array , int start , int end ) { int x ; for ( int i = start ; i < end ; i ++ ) { if ( array [ i ] == start ) { x = i ; } else if ( array [ i ] == end ) { x = i ; } else { x = i ; } } return x ; }
public static String getSuffix ( String name ) { if ( name == null ) { return null ; } if ( name . length ( ) == 0 ) { return " " ; } if ( name . length ( ) == 1 ) { return name . substring ( 0 , 1 ) ; } if ( name . length ( ) == 2 ) { return name . substring ( 1 , 2 ) ; } return name . substring ( 0 , 1 ) ; }
static void printPairs ( int [ ] arr , int n ) { ArrayList < Integer > v = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( Math . abs ( arr [ i ] ) ) == Math . abs ( arr [ j ] ) ) { v . add ( Math . abs ( arr [ i ] ) ) ; } } } if ( ( v . size ( ) == 0 ) ) { return ; } Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { System . out . print ( - v . get ( i ) + " ▁ " + v . get ( i ) + " ▁ " ) ; } } if ( String . class . equals ( " java . util . regex . regex . regex " ) ) { arr = new int [ ] { 4 , 8 , 9 , - 4 , 1 , - 1 , - 8 , - 9 } ; n = arr . length ; printPairs ( arr , n ) ; }
public static double doublefactorial ( double n ) { if ( ( n == 0 ) || ( n == 1 ) ) { return 1 ; } return n * doublefactorial ( n - 2 ) ; }
public static int isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( ( h > l ) ) { if ( ( str . charAt ( l ) != str . charAt ( h ) ) ) { return 0 ; } l = l + 1 ; h = h - 1 ; } return 1 ; }
public static String sumOfSubstrings ( String num ) { int n = num . length ( ) ; int [ ] sumofdigit = new int [ n ] ; sumofdigit [ 0 ] = Integer . parseInt ( num . substring ( 0 , 1 ) ) ; String res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = Integer . parseInt ( num . substring ( i , i + 1 ) ) ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; }
static int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( int ) ( a / n ) * ( int ) ( b / n ) ; ans += ( int ) ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( int ) ( b / n ) ; ans += ( int ) ( ( ( a % n ) + ( b % n ) ) / n ) ; return ans ; }
public static String compute ( ) { final int LIMIT = 1000000 ; int maxnumer = 0 ; int maxdenom = 1 ; for ( int d = 1 ; d <= LIMIT ; d ++ ) { int n = d * 3 / 7 ; if ( d % 7 == 0 ) { n -- ; } if ( n * maxdenom > d * maxnumer ) { maxnumer = n ; maxdenom = d ; } } return Integer . toString ( maxnumer ) ; }
public static boolean isPrime ( int n ) { int [ ] c = new int [ 100 ] ; Arrays . fill ( c , 0 ) ; Arrays . fill ( c , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { c [ 1 + i ] = 1 ; for ( int j = i ; j > 0 ; j -- ) { c [ j ] = c [ j - 1 ] - c [ j ] ; } c [ 0 ] = - c [ 0 ] ; } return ( isPrime ( n ) ) ; }
public static int countGreater ( int [ ] arr , int n ) { int min = Integer . MAX_VALUE ; int counter = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ( arr [ i ] > min ) ) { counter ++ ; } if ( ( arr [ i ] <= min ) ) { min = arr [ i ] ; } } return counter ; }
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static int getCost ( int [ ] a , int [ ] b ) { int cost = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { cost += a [ i ] * b [ i ] ; } return cost ; }
public static int getDistance ( int [ ] arr ) { int x ; int D = Integer . parseInt ( arr [ 0 ] ) ; int L = Integer . parseInt ( arr [ 1 ] ) ; if ( L == 0 ) { return 0 ; } if ( L == 1 ) { return Integer . parseInt ( arr [ 2 ] ) ; } else if ( L == 2 ) { return Integer . parseInt ( arr [ 2 ] ) ; } else if ( L == 3 ) { return Integer . parseInt ( arr [ 3 ] ) ; } else if ( L == 4 ) { return Integer . parseInt ( arr [ 4 ] ) ; } else if ( L == 5 ) { return Integer . parseInt ( arr [ 6 ] ) ; } else if ( L == 6 ) { return Integer . parseInt ( arr [ 7 ] ) ; } else if ( L == 7 ) { return Integer . parseInt ( arr [ 8 ] ) ; } else if ( L == 8 ) { return Integer . parseInt ( arr [ 9 ] ) ; } else if ( L == 9 ) { return Integer . parseInt ( arr [ 10 ] ) ; } else if ( L == 10 ) { return Integer . parseInt ( arr [ 11 ] ) ; } else if ( L == 11 ) { return Integer . parseInt ( arr [ 12 ] ) ; } else if ( L == 12 ) { return Integer . parseInt ( arr [ 13 ] ) ; } else if ( L == 13 ) { return Integer . parseInt ( arr [ 14 ] ) ; } else if ( L == 14 ) { return Integer . parseInt ( arr [ 15 ] ) ; } else if ( L == 15 ) { return Integer . parseInt ( arr [ 14 ] ) ; } else if ( L == 16 ) { return Integer . parseInt ( arr [ 15 ] ) ; } else if ( L == 17 ) { return Integer . parseInt ( arr [ 17 ] ) ; } else if ( L == 18 ) { return Integer . parseInt ( arr [ 18 ] ) ; } else if ( L == 19 ) { return Integer . parseInt ( arr [ 19 ] ) ; } else if ( L == 19 ) { return Integer . parseInt ( arr [ 19 ] ) ; } else if ( L == 19 ) { return Integer . parseInt ( arr [ 19 ] ) ; } else if ( L == 23 ) { return Integer . parseInt ( arr [ 23 ] ) ; return Integer . parseInt ( arr [ 23 ] ) ; }
public static int minimumSwaps ( int [ ] arr ) { int count = 0 ; int i = 0 ; while ( ( i < arr . length ) ) { if ( ( arr [ i ] != i + 1 ) ) { while ( ( arr [ i ] != i + 1 ) ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; }
public static String compute ( ) { final int TARGET = 500500 ; final int MODULUS = 500500507 ; final boolean [ ] isprime = eulerlib . listPrimality ( 7376507 ) ; final int [ ] queue = new int [ TARGET ] ; int nextprime = 2 ; final int ans = 1 ; for ( int i = 0 ; i < TARGET ; i ++ ) { final int item = queue [ i ] ; ans *= item ; ans %= MODULUS ; queue [ i ] = item * item ; if ( item == nextprime ) { nextprime ++ ; while ( ! isprime [ i ] ) { nextprime ++ ; } queue [ i ] = nextprime ; } } return String . valueOf ( ans ) ; }
static void findUniquePair ( int [ ] arr , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { XOR = XOR ^ arr [ i ] ; } int setBitNo = XOR & ~ ( XOR - 1 ) ; int x = 0 ; int y = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] & setBitNo ) != 0 ) { x = x ^ arr [ i ] ; } else { y = y ^ arr [ i ] ; } } System . out . println ( " The ▁ unique ▁ pair ▁ is ▁ ( " + x + " , ▁ " + y + " ) " + " , " ) ; } int [ ] a = { 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 } ; n = a . length ; findUniquePair ( a , n ) ; }
public static int getFlag ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] [ ] s = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = Integer . parseInt ( input ) ; s [ i ] [ k ] = i ; } int flag = 0 ; int [ ] d1 = new int [ n ] ; int [ ] d2 = new int [ n ] ; HashSet < Integer > rem = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i == j ) ) { d1 [ i ] = s [ i ] [ j ] ; } if ( ( i == n - j - 1 ) ) { d2 [ i ] = s [ i ] [ j ] ; } if ( ( i != j ) && ( i != n - j - 1 ) ) { rem . add ( s [ i ] [ j ] ) ; } } } if ( ( rem . size ( ) != 1 ) ) { System . out . println ( " NO " ) ; } else if ( ( d1 != d2 ) ) { System . out . println ( " NO " ) ; } else if ( ( new HashSet < > ( d1 ) ) . size ( ) != 1 ) { System . out . println ( " NO " ) ; } else if ( ( new HashSet < > ( rem ) ) . size ( ) == 1 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } return flag ; }
public static final String getDigitsCode ( String s ) { if ( s != null ) { return s . trim ( ) ; } else { return s ; } }
public static boolean isMajority ( int [ ] a ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( mp . containsKey ( a [ i ] ) ) { mp . get ( a [ i ] ) += 1 ; } else { mp . put ( a [ i ] , 1 ) ; } } for ( int x : mp . keySet ( ) ) { if ( mp . get ( x ) >= a . length / 2 ) { return true ; } } return false ; }
public static int [ ] [ ] getdp ( String input ) { int n = Integer . parseInt ( input ) ; int w = Integer . parseInt ( input ) ; int [ ] [ ] vwL = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) vwL [ i ] [ i ] = Integer . parseInt ( input ) ; int [ ] [ ] dp = new int [ w + 1 ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] [ i ] = new int [ w + 1 ] ; for ( int j = 0 ; j < w + 1 ; j ++ ) { if ( j < w ) dp [ i + 1 ] [ j ] = dp [ i ] [ j ] ; else dp [ i + 1 ] [ j ] = Math . max ( dp [ i + 1 ] [ j - w ] + _v , dp [ i ] [ j ] ) ; } return dp [ n ] [ w ] ; }
public static final double cos ( double x ) { double y = Math . PI / 2 ; double rad = Math . atan2 ( y , x ) + PI2 ; L [ ] = { null , { 1.0 , 0.0 } } ; for ( int i = 2 ; i < 1001 ; i ++ ) { x = L [ i - 1 ] ; y = L [ i ] ; rad = Math . atan2 ( y , x ) + PI2 ; L [ i ] = new Double ( x + Math . cos ( rad ) , y + Math . sin ( rad ) ) ; } for ( ; ; ) { int n = Integer . parseInt ( x ) ; if ( n == - 1 ) break ; System . out . println ( ( double ) L [ n ] ) ; } }
static void printKMissing ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( ( i < n ) && ( arr [ i ] <= 0 ) ) { i = i + 1 ; } int count = 0 ; int curr = 1 ; while ( ( count < k ) && ( i < n ) ) { if ( ( arr [ i ] != curr ) ) { System . out . print ( String . valueOf ( curr ) + " ▁ " ) ; count = count + 1 ; } else { i = i + 1 ; } curr = curr + 1 ; } while ( ( count < k ) ) { System . out . print ( String . valueOf ( curr ) + " ▁ " ) ; curr = curr + 1 ; count = count + 1 ; } arr = new int [ ] { 2 , 3 , 4 } ; n = arr . length ; k = 3 ; printKMissing ( arr , n , k ) ; }
static void printNumbers ( int [ ] a , int n ) { Map < Integer , Integer > mpp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; for ( int j = 1 ; j <= num ; j ++ ) { if ( j * j > num ) break ; if ( ( num % j ) == 0 ) { if ( ( j != 1 ) ) { mpp . put ( j , mpp . get ( j ) + 1 ) ; } if ( ( ( num / j ) != j ) ) { mpp . put ( num / j , mpp . get ( num / j ) + 1 ) ; } } } } int maxi = 0 ; for ( Integer it : mpp . keySet ( ) ) { maxi = Math . max ( mpp . get ( it ) , maxi ) ; } for ( Integer it : mpp . keySet ( ) ) { if ( ( mpp . get ( it ) == maxi ) ) { System . out . print ( it + " ▁ " ) ; } } } a = Arrays . asList ( 12 , 15 , 27 , 20 , 40 ) ; n = a . length ; printNumbers ( a , n ) ; }
public static String getCountry ( String country ) { String country = country . toLowerCase ( ) ; if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country = country . substring ( 0 , country . indexOf ( ' A ' ) ) ; } else if ( country . indexOf ( ' A ' ) != - 1 ) { country =
public static int getDistance ( int [ ] array ) { int distance = 0 ; int [ ] a = array . clone ( ) ; int K = Math . max ( a . length , 0 ) ; int i = 0 ; do { if ( a [ i ] < K ) { int C = a [ i ] ; n -= C ; int Val = a [ i ] ; for ( int k = 0 ; k < C ; k ++ ) { a [ i ] = a [ i ] ; } } else { i ++ ; } } while ( i == n ) ; if ( i == 0 ) { break ; } int MinI = 1000001 ; int ID = - 1 ; int [ ] A = a . clone ( ) ; for ( i = 0 ; i < A . length ; i ++ ) { int j = n - 1 ; while ( j >= 0 && a [ j ] != A [ i ] ) { j -- ; } if ( j < MinI ) { MinI = j ; ID = A [ i ] ; } } return ID ; }
static int checkIfStartsWithCapital ( String string ) { if ( ( string . charAt ( 0 ) >= ' A ' ) && ( string . charAt ( 0 ) <= ' Z ' ) ) { return 1 ; } else { return 0 ; } }
public static double getAvg ( double prevAvg , double x , int n ) { return ( ( prevAvg * n + x ) / ( n + 1 ) ) ; }
public static String compute ( ) { final int ans = 0 ; final boolean [ ] isprime = eulerJNI . list_primality ( 999999 ) ; final boolean [ ] primes = eulerJNI . list_primes ( 999999 ) ; int consecutive = 0 ; for ( int i = 0 ; i < primes . length ; i ++ ) { int sum = primes [ i ] ; int consec = 1 ; for ( int j = i + 1 ; j < primes . length ; j ++ ) { sum += primes [ j ] ; consec ++ ; if ( sum >= isprime . length ) break ; if ( isprime [ sum ] && consec > consecutive ) { ans = sum ; consecutive = consec ; } } } return String . valueOf ( ans ) ; }
public static int lis ( int arr [ ] , int n ) { int i , j , maxm = 0 ; int [ ] list = new int [ n ] ; for ( int s = 0 ; s < n ; s ++ ) { list [ s ] = 1 ; } for ( i = 1 ; i < n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( ( arr [ i ] > arr [ j ] && list [ i ] < list [ j ] + 1 ) ) { list [ i ] = list [ j ] + 1 ; } } } for ( i = 0 ; i <= n ; i ++ ) { if ( maxm < list [ i ] ) { maxm = list [ i ] ; } } return maxm ; } arr = new int [ ] { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; n = arr . length ; System . out . println ( " Length ▁ of ▁ lst ▁ is " + lis ( arr , n ) ) ; return 0 ; }
public static String getDay ( String day ) { int i = 0 ; while ( i < day . length ( ) ) { i ++ ; } if ( i == 0 ) { return day . substring ( 0 , i ) ; } else if ( i == 1 ) { return day . substring ( i , i + 1 ) ; } else if ( i == 2 ) { return day . substring ( i , i + 1 ) ; } else if ( i == 3 ) { return day . substring ( i , i + 1 ) ; } else if ( i == 4 ) { return day . substring ( i , i + 1 ) ; } else if ( i == 5 ) { return day . substring ( i , i + 1 ) ; } else if ( i == 6 ) { return day . substring ( i , i + 1 ) ; } else if ( i == 7 ) { return day . substring ( i , i + 1 ) ; } else if ( i == 8 ) { return day . substring ( i , i + 1 ) ; } else if ( i == 9 ) { return day . substring ( i , i + 1 ) ;
public static int [ ] fix ( int [ ] A ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { s . add ( A [ i ] ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( s . contains ( i ) ) { A [ i ] = i ; } else { A [ i ] = - 1 ; } } return A ; }
public static void main ( String [ ] args ) { int [ ] A = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int ans = Math . abs ( A [ 0 ] + A [ 1 ] - A [ 2 ] - A [ 3 ] ) ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( i == j ) continue ; int now = 0 ; for ( int t = 0 ; t < 4 ; t ++ ) { if ( t == i || t == j ) { now += A [ t ] ; } else { now -= A [ t ] ; } } if ( Math . abs ( now ) < ans ) { ans = Math . abs ( now ) ; } } } System . out . println ( ans ) ; if ( Class . forName ( " java . lang . System " ) . equals ( System . getProperty ( " user . name " ) ) ) { System . out . println ( " java . lang . System . System . out . println ( java . lang . System . out . println ( java . lang . System . out . println ( " java . lang . System . out . println ( " java . lang . System . out . println ( " java . lang . System . out . println ( " java . err . println ( " java . err . println ( " java . err . println ( " System . err . println ( " System . err . println ( " System . err . println ( " System . err . println ( " System . err . println ( " System . err . println ( " System . err . println ( " System . err . println ( " ) ) ) ) ) ) ) ) ) ) ) ) ; } }
public static int getDepth ( int [ ] arr ) { int [ ] result = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { result [ i ] = arr [ i ] ; } for ( int i = 0 ; i < arr . length ; i ++ ) { result [ i ] = arr [ i ] ; } for ( int i = 0 ; i < arr . length ; i ++ ) { result [ i ] = arr [ i ] ; } for ( int i = 0 ; i < arr . length ; i ++ ) { result [ i ] = arr [ i ] ; } for ( int i = 0 ; i < arr . length ; i ++ ) { result [ i ] = arr [ i ] ; } for ( int i = 0 ; i < arr . length ; i ++ ) { result [ i ] = arr [ i ] ; } for ( int i = 0 ; i < arr . length ; i ++ ) { result [ i ] = arr [ i ] ; } return result [ i ] ; }
public static int [ ] s_max ( int [ ] s_max ) { s_max = new int [ 11 ] ; s_max [ 0 ] = 0 ; for ( int i = 1 ; i < 11 ; i ++ ) { int s = 0 ; for ( int j = 0 ; j < i ; j ++ ) { s += ( 10 - j - 1 ) * ( i - j ) ; } s_max [ i ] = s ; } HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { n *= 2 ; if ( u [ i ] ) { n ++ ; } } if ( m . containsKey ( ( n , r , s ) ) ) { return m . get ( new Integer ( n ) ) ; } if ( s < 0 || s > s_max [ r ] ) { return 0 ; } int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( ! u [ i ] ) { u [ i ] = true ; ans += check ( u , r - 1 , s - i * r , m ) ; u [ i ] = false ; } } m . put ( new Integer ( n ) , ans ) ; return m . get ( new Integer ( n ) ) ; } HashMap < Integer , Integer > memo = new HashMap < > ( ) ; while ( true ) { try { int n = Integer . parseInt ( input . readLine ( ) ) ; int s = Integer . parseInt ( input . readLine ( ) ) ; boolean [ ] used = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { used [ i ] = false ; } int ans = check ( used , n , s , memo ) ; System . out . println ( ans ) ; } catch ( Exception e ) { break ; } return null ; }
public static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res = res * i ; } return res ; }
public static int countOfNumbers ( int N , int K ) { int MAX = 1000001 ; int MAX_sqrt = MAX * ( 0.5 ) ; int [ ] primeUpto = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { int [ ] isPrime = new int [ MAX ] ; isPrime [ 0 ] = 0 , isPrime [ 1 ] = 0 ; for ( int i = 2 ; i < Integer . MAX_VALUE ; i ++ ) { if ( isPrime [ i ] == 1 ) { for ( int j = i * 2 ; j < MAX ; j += i ) { isPrime [ j ] = 0 ; } } } for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] == 1 ) { primeUpto [ i ] ++ ; } } } return ( N - ans + 1 ) != 0 ? ( N - ans + 1 ) : 0 ; }
static int countOperations ( int n ) { int i = 2 ; while ( ( ( i * i ) < n ) && ( n % i ) ) { i ++ ; } if ( ( ( i * i ) > n ) ) { i = n ; } return ( 1 + ( n - i ) / 2 ) ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { array [ i ] = i ; } int [ ] ac = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( array [ i ] == ' A ' && array [ i + 1 ] == ' C ' ) { ac [ i ] = 1 ; } } int [ ] acc = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { acc [ i + 1 ] = acc [ i ] + ac [ i ] ; } int [ ] [ ] lr = new int [ q ] [ ] ; for ( int i = 0 ; i < q ; i ++ ) { lr [ i ] = Integer . parseInt ( array [ i ] ) ; } for ( int i = 0 ; i < q ; i ++ ) { int l = lr [ i ] [ 0 ] - 1 ; int r = lr [ i ] [ 1 ] - 1 ; System . out . println ( acc [ r ] - acc [ l ] ) ; } return acc ; }
public static int T ( String input ) { int l , r ; for ( int i = 0 ; i < T ; i ++ ) { l = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; r = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; } return l + r ; }
public static String compute ( ) { final int LIMIT = 5000 ; final int MODULUS = 10 * 16 ; final int [ ] count = new int [ LIMIT * 2 / 2 ] ; count [ 0 ] = 1 ; int s = 0 ; for ( int p : EulerUtil . listPrimes ( LIMIT ) ) { for ( int i = 0 ; i < s + 1 ; i ++ ) { count [ i + p ] = ( count [ i + p ] + count [ i ] ) % MODULUS ; } s += p ; } final int [ ] isprime = EulerUtil . listPrimality ( s + 1 ) ; final int ans = Integer . valueOf ( count [ s ] ) ; for ( int i = 0 ; i < isprime . length ; i ++ ) { if ( isprime [ i ] != 0 ) { ans = Integer . valueOf ( count [ i ] ) ; } } return String . valueOf ( ans ) ; }
static int countOddNumber ( int rowNum ) { int count = 0 ; while ( rowNum != 0 ) { count += rowNum & 1 ; rowNum >>= 1 ; } return ( 1 << count ) ; }
static void findMin ( int V ) { int [ ] deno = { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 } ; int n = deno . length ; ArrayList < Integer > ans = new ArrayList < > ( ) ; int i = n - 1 ; while ( ( i >= 0 ) ) { while ( ( V >= deno [ i ] ) ) { V -= deno [ i ] ; ans . add ( deno [ i ] ) ; } i -- ; } for ( i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + " ▁ " ) ; } }
public static String compute ( ) { final Predicate < Integer > cond = i -> Arrays . stream ( Integer . toString ( i ) ) . filter ( j -> j * i . intValue ( ) > 0 ) . findFirst ( ) . isPresent ( ) ; final Integer ans = i ; return ans . toString ( ) ; }
public static int count ( int [ ] arr , int n , int x ) { if ( ( x == 1 ) ) { int ans = Math . pow ( 2 , n ) - 1 ; return ans ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % x ) == 0 ) { count ++ ; } } int ans = Math . pow ( 2 , count ) - 1 ; return ans ; }
static int findEle ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == sum - arr [ i ] ) { return arr [ i ] ; } } return - 1 ; }
static int findExtraCharacter ( String strA , String strB ) { HashMap < Character , Integer > m1 = new HashMap < > ( ) ; for ( int i = 0 ; i < strB . length ( ) ; i ++ ) { if ( m1 . containsKey ( strB . charAt ( i ) ) ) { m1 . put ( strB . charAt ( i ) , 1 ) ; } else { m1 . put ( strB . charAt ( i ) , 1 ) ; } } for ( int i = 0 ; i < strA . length ( ) ; i ++ ) { m1 . put ( strA . charAt ( i ) , -- 1 ) ; } for ( int h1 : m1 . keySet ( ) ) { if ( m1 . get ( h1 ) == 1 ) { return h1 ; } } if ( " java . util . regex . regex . regex " . equals ( strA ) ) { strA = " abcd " ; strB = " cbdad " ; System . out . println ( findExtraCharacter ( strA , strB ) ) ; } return 0 ; }
public static int solve ( int [ ] a , int [ ] b ) { int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum += a [ i ] * b [ i ] ; } for ( int i = 0 ; i < b . length ; i ++ ) { sum += a [ i ] * b [ i ] ; } for ( int i = 0 ; i < a . length ; i ++ ) { sum += a [ i ] * b [ i ] ; } return sum ; }
public static String substitute ( String text , String a , String b ) { int pos = 0 ; String newText = text ; int L1 = a . length ( ) ; int L2 = b . length ( ) ; do { int idx = newText . indexOf ( a , pos ) ; if ( idx < 0 ) { return newText ; } newText = newText . substring ( 0 , idx ) + b + newText . substring ( idx + L1 ) ; pos = idx + L2 ; } while ( true ) ; if ( orig . length ( ) > goal . length ( ) ) { return null ; } if ( orig . equals ( goal ) ) { minCount = Math . min ( minCount , count ) ; return null ; } for ( String key : subs . keySet ( ) ) { String newStr = substitute ( orig , key , subs . get ( key ) ) ; if ( newStr != orig ) { transform ( newStr , goal , count + 1 ) ; } } if ( Class . forName ( " java . util . regex . regex . regex " ) . equals ( " java . util . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex .
public static int getLargestNumber ( String value ) { if ( value == null ) { return 0 ; } else if ( value . length ( ) < 1 ) { return - 1 ; } else if ( value . length ( ) < 2 ) { return - 1 ; } else if ( value . charAt ( 0 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 1 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 2 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 3 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 4 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 5 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 6 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 7 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 8 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 9 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 10 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 11 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 12 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 13 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 14 ) == ' _ ' ) { return - 1 ; } else if ( value . charAt ( 15 ) == ' _ ' ) {
public static int maxSumPair ( int [ ] arr1 , int n1 , int [ ] arr2 , int n2 ) { int max1 = - Integer . MAX_VALUE - 1 ; int max2 = - Integer . MAX_VALUE - 1 ; for ( int i = 0 ; i <= n1 ; i ++ ) { if ( ( arr1 [ i ] > max1 ) ) { max1 = arr1 [ i ] ; } } for ( int i = 0 ; i <= n2 ; i ++ ) { if ( ( arr2 [ i ] > max2 ) ) { max2 = arr2 [ i ] ; } } return max1 + max2 ; }
public static int operations ( int [ ] op , int n , int k ) { int i , count ; int nVal = 0 ; int minimum = 10 * 9 ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; minimum = Math . min ( minimum , nVal ) ; if ( ( ( k + nVal ) <= 0 ) ) { return ( i + 1 ) ; } } if ( ( nVal >= 0 ) ) { return - 1 ; } int times = ( k - Math . abs ( minimum ) ) / Math . abs ( nVal ) ; k = ( k - ( times * Math . abs ( nVal ) ) ) ; count = ( times * n ) ; while ( ( k > 0 ) ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( ( k <= 0 ) ) { break ; } } } return count ; }
public static int isPerfectCube ( int x ) { int [ ] pref = new int [ 100010 ] ; int i ; int sum ; int Q ; for ( i = 0 ; i < 100001 ; i ++ ) { pref [ i ] = ( pref [ i ] - 1 ) + isPerfectCube ( i ) ; } for ( i = 0 ; i < 100001 ; i ++ ) { sum = pref [ R ] - pref [ L - 1 ] ; System . out . print ( sum + " ▁ " ) ; } if ( j == 0 ) { j = 0 ; } else { j = 1 ; } for ( i = 0 ; i < Q ; i ++ ) { j = j + 1 ; } for ( i = 0 ; i < 100001 ; i ++ ) { j = j + 1 ; } for ( i = 0 ; i < 100001 ; i ++ ) { j = j + 1 ; } for ( i = 0 ; i < 100001 ; i ++ ) { j = j + 1 ; } return j ; }
public static int [ ] getCoordinates ( int [ ] array ) { int [ ] result = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { result [ i ] = array [ i ] ; } return result ; }
public static int centeredCube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; if ( Class . isPrimitive ( " java . util . regex . regex " ) ) { n = 3 ; System . out . println ( String . valueOf ( n ) + " th ▁ Centered ▁ cube ▁ number : ▁ " + centeredCube ( n ) ) ; n = 10 ; System . out . println ( String . valueOf ( n ) + " th ▁ Centered ▁ cube ▁ number : ▁ " + centeredCube ( n ) ) ; } return 0 ; }
public static String getStrFromString ( String s ) { String st = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) == ' _ ' ) { s = s . substring ( i , i + 1 ) ; } else if ( s . charAt ( i ) ==
public static int nthTerm ( int N ) { int nth = 0 ; for ( int i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }
public static boolean isPower ( int x , int y ) { if ( ( x == 1 ) ) return ( y == 1 ) ; int pow = 1 ; while ( ( pow = pow * x ) != 0 ) return ( pow == y ) ; if ( ( isPower ( 10 , 1 ) ) ) return ( true ) ; else return ( false ) ; }
public static boolean isPower ( int x , int y ) { if ( ( x == 1 ) ) { return ( y == 1 ) ; } int pow = 1 ; while ( ( pow = pow * x ) != 0 ) { pow = pow * x ; } return ( pow == y ) ; }
public static int minimumValue ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) { answer += arr [ i ] * arr [ i ] ; } return answer * ( 2 * k - 2 ) ; }
public static void bfs ( int x , boolean [ ] visited , ArrayList < Integer > order ) { if ( visited [ x ] ) return ; visited [ x ] = true ; for ( int to : edges [ x ] ) { bfs ( to , visited , order ) ; } order . add ( x ) ; { if ( visited [ x ] ) return ; visited [ x ] = true ; ArrayList < Integer > ret = new ArrayList < > ( ) ; ret . add ( x ) ; for ( int to : revEdges [ x ] ) ret . add ( x ) ; return ret . toArray ( new Integer [ ret . size ( ) ] ) ; } int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int [ ] [ ] edges = new int [ 200 ] [ 200 ] ; int [ ] [ ] revEdges = new int [ 200 ] [ 200 ] ; for ( int i = 0 ; i < n ; i ++ ) { int u = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int s = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int d = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; u = Integer . parseInt ( u ) - 1 ; d = Integer . parseInt ( d ) - 1 + 100 ; if ( s == " lock " ) { edges [ d ] [ u ] = d ; revEdges [ u ] [ d ] = u ; } else { edges [ u ] [ d ] = u ; revEdges [ d ] [ u ] = u ; } } order . clear ( ) ; visited = new boolean [ 200 ] ; for ( int i = 0 ; i < 200 ; i ++ ) if ( ! visited [ i ] ) bfs ( i , visited , order ) ; Collections . reverse ( order ) ; visited = new boolean [ 200 ] ; for ( int i : order ) if ( ! visited [ i ] ) if ( bfRev ( i ) . length >= 2 ) { System . out . println ( 1 ) ; break ; } }
static int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( ( N == 1 ) ) { return 0 ; } return ( int ) Math . pow ( 2 , E - 1 ) ; }
public static int findLCM ( int [ ] arr , int n ) { double lcm = arr [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { lcm = ( lcm * arr [ i ] ) / Math . gcd ( arr [ i ] , lcm ) ; } return lcm ; }
public static int getN ( ) { return Integer . parseInt ( input ( ) ) ; }
public static void solve ( ) { int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; n = n * 4 ; int [ ] a = new int [ n ] ; Arrays . sort ( a ) ; int i = 0 ; int j = n - 1 ; int area = a [ i ] * a [ j ] ; i ++ ; j -- ; while ( ( i < j ) && ( j < n ) ) { int x = a [ i ] * a [ j ] ; if ( ( x != area ) ) { System . out . println ( " NO " ) ; return ; } i ++ ; j -- ; } for ( i = 0 ; i <= n ; i ++ ) { if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } } for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( ( entry . getValue ( ) % 2 != 0 ) ) { System . out . println ( " NO " ) ; return ; } } System . out . println ( " YES " ) ; } int test = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; for ( int t = 0 ; t <= test ; t ++ ) { solve ( ) ; }
public static int MinDeletion ( int [ ] a , int n ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; map . put ( a , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { map . put ( a [ i ] , 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { int x = entry . getKey ( ) ; int frequency = entry . getValue ( ) ; if ( ( x <= frequency ) ) { ans += ( frequency - x ) ; } else { ans += frequency ; } } return ans ; }
public static String fromStart ( String in , int del11 ) { String inp1 = in . substring ( 0 , del11 - 1 ) ; String inp2 = in . substring ( del1 , in . length ( ) ) ; return inp1 + inp2 ; }
public static int nondecDigits ( int n ) { int x = 0 ; for ( x = n ; x > 0 ; x -- ) { int no = x ; int prevDig = 11 ; boolean flag = true ; while ( ( no = ( int ) ( Math . log ( x ) / Math . log ( 2 ) ) ) != 0 ) { if ( ( prevDig < no % 10 ) ) { flag = false ; break ; } prevDig = no % 10 ; no /= 10 ; } if ( ( flag == true ) ) break ; } return x ; }
public static int getAmplifyNumber ( int n ) { int i = 0 ; for ( ; i < n ; i ++ ) { if ( i == 0 ) { i ++ ; } } return i ; }
public static int getDistance ( int [ ] array ) { int distance = array . length ; int m = array [ 0 ] . length ; for ( int i = 1 ; i < m ; i ++ ) { if ( array [ i ] . length == m ) { distance = m ; } } return distance ; }
public static String getSuffix ( String name ) { if ( name == null ) return null ; if ( name . length ( ) == 0 ) return " " ; if ( name . length ( ) == 1 ) return " " ; if ( name . charAt ( 0 ) == ' . ' ) return " " ; if ( name . charAt ( 1 ) == ' . ' ) return " " ; if ( name . charAt ( 2 ) == ' . ' ) return " " ; return name . substring ( 0 , 2 ) ; }
public static int indexOf ( String s , char ch ) { return s . indexOf ( ch ) ; }
static int countDistictSubarray ( int [ ] arr , int n ) { Map < Integer , Integer > vis = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { vis . put ( arr [ i ] , 1 ) ; } int k = vis . size ( ) ; Map < Integer , Integer > vid = new HashMap < > ( ) ; int ans = 0 ; int right = 0 ; int window = 0 ; for ( int left = 0 ; left < n ; left ++ ) { while ( ( right < n ) && ( window < k ) ) { if ( vid . keySet ( ) . contains ( arr [ right ] ) ) { vid . get ( arr [ right ] ) ++ ; } else { vid . put ( arr [ right ] , 1 ) ; } if ( ( vid . get ( arr [ right ] ) ) == 1 ) { window ++ ; } right ++ ; } if ( ( window == k ) ) { ans += ( n - right + 1 ) ; } vid . get ( arr [ left ] ) -- ; if ( ( vid . get ( arr [ left ] ) ) == 0 ) { window -- ; } } return ans ; arr = Arrays . asList ( 2 , 1 , 3 , 2 , 3 ) ; n = arr . length ; System . out . println ( countDistictSubarray ( arr , n ) ) ; }
public static int max ( int n , int s ) { int ans = s ; for ( ; n > 0 ; n -- ) { int a = Integer . parseInt ( String . valueOf ( String . valueOf ( n ) ) ) , b = Integer . parseInt ( String . valueOf ( String . valueOf ( n ) ) ) ; ans = Math . max ( ans , a + b ) ; } return ans ; }
public static boolean isPrime ( int n ) { if ( ( n <= 1 ) ) return false ; if ( ( n <= 3 ) ) return true ; if ( ( n % 2 == 0 ) || ( n % 3 == 0 ) ) return false ; int i = 5 ; while ( ( i * i <= n ) ) { if ( ( n % i == 0 ) || ( n % ( i + 2 ) == 0 ) ) return false ; i = i + 6 ; } return true ; }
static int countSetBits ( int n ) { int count = 0 ; while ( ( n = n ) != 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
public static void reverseQueueFirstKElements ( int k , final Queue < Integer > Queue ) { if ( ( Queue . isEmpty ( ) == true ) || ( k > Queue . qSize ( ) ) ) return ; if ( ( k <= 0 ) ) return ; Stack < Integer > Stack = new Stack < > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { Stack . push ( Queue . queue ( 0 ) ) ; Queue . get ( ) ; } while ( ( Stack . size ( ) != 0 ) ) { Queue . put ( Stack . peek ( ) ) ; Stack . pop ( ) ; } for ( int i = 0 ; i < Queue . qSize ( ) - k ; i ++ ) { Queue . put ( Queue . queue ( 0 ) ) ; Queue . get ( ) ; } } void Print ( Queue ) { while ( ( ! Queue . isEmpty ( ) ) ) { System . out . print ( Queue . queue ( 0 ) + " ▁ " ) ; Queue . get ( ) ; } } if ( Thread . currentThread ( ) . getName ( ) . equals ( " java . util . concurrent . ThreadPoolExecutor " ) ) { Queue < Integer > Queue = new Queue < > ( ) ; Queue . put ( 10 ) ; Queue . put ( 20 ) ; Queue . put ( 30 ) ; Queue . put ( 40 ) ; Queue . put ( 50 ) ; Queue . put ( 60 ) ; Queue . put ( 70 ) ; Queue . put ( 80 ) ; Queue . put ( 90 ) ; Queue . put ( 100 ) ; k = 5 ; reverseQueueFirstKElements ( k , Queue ) ; Print ( Queue ) ; } else { System . out . println ( " java . util . concurrent . ThreadPoolExecutor " ) ; } }
public static int getDistance ( int [ ] arr ) { int distance = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == arr [ i ] ) { distance += i ; } } return distance ; }
public static int xorCalc ( int k ) { if ( ( k == 1 ) ) { return 2 ; } if ( ( ( ( k + 1 ) & k ) == 0 ) ) { return k / 2 ; } return 1 ; }
public static boolean isPerfectSquare ( int num ) { int low = 1 , high = num ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int midSquare = mid * mid ; if ( midSquare == num ) { return true ; } else if ( midSquare < num ) { low = mid + 1 ; } else { high = mid - 1 ; } } return false ; }
public static int [ ] getNegativeInstances ( ) { int [ ] result = new int [ 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Integer . parseInt ( result [ i ] ) ; } return result ; }
public static final String getDelimiter ( String delimiter ) { if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " ; } else if ( delimiter == null ) { return " " " ; } else if ( delimiter == null ) { return " " " ; } else if ( delimiter == null ) { return " " " ; } else if ( delimiter == null ) { return " " " ; } else if ( delimiter == null ) { return " " " ; } else if ( delimiter == null ) { return " " " ; } else if ( delimiter == null ) { return " " " ; } else if ( delimiter == null ) { return " " " ; } else if ( delimiter == null ) { return " " " ; } else if ( delimiter == null ) { return " " " ; } else if ( delimiter == null ) { return " " " ; } else { return " " " ; } else { return " " " " ; }
public static int [ ] getHowSearchForNumber ( int [ ] numbers ) { int [ ] nq = new int [ numbers . length ] ; for ( int i = 0 ; i < numbers . length ; i ++ ) { nq [ i ] = numbers [ i ] ; } LinkedList < int [ ] > queue = new LinkedList < > ( ) ; for ( int i = 0 ; i < numbers . length ; i ++ ) { queue . add ( numbers [ i ] ) ; } int ti = 0 ; int cur = 0 ; while ( Integer . parseInt ( queue . get ( cur ) [ 1 ] ) > 0 ) { int [ ] num = queue . get ( cur ) ; int syori = Integer . parseInt ( num [ 1 ] ) - nq [ 1 ] ; if ( syori > 0 ) { num [ 1 ] = syori ; queue . add ( num ) ; ti += nq [ 1 ] ; } else { ti += Integer . parseInt ( num [ 1 ] ) ; System . out . println ( num [ 0 ] + " ▁ " + ti ) ; } cur ++ ; if ( queue . size ( ) <= cur ) break ; } return queue . toArray ( new int [ 0 ] ) ; }
public static int findElement ( int [ ] arr , int [ ] [ ] ranges , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( ( left <= index && right >= index ) ) { if ( ( index == left ) ) { index = right ; } else { index = index - 1 ; } } } return arr [ index ] ; arr = Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ; rotations = 2 ; ranges = Arrays . asList ( new int [ ] [ ] { { 0 , 2 } , { 0 , 3 } } ) ; index = 1 ; System . out . println ( findElement ( arr , ranges , rotations , index ) ) ; }
public static int [ ] getFactorization ( int x ) { int [ ] arr = new int [ MAXN ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = i ; } int [ ] hash1 = new int [ MAXN ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) { if ( ( arr [ i ] == i ) ) { for ( int j = i * i ; j < arr [ i ] ; j += i ) { if ( ( arr [ j ] == j ) ) { arr [ j ] = i ; } } } } } int [ ] getFactorization = new int [ arr . length ] ; while ( ( x != 1 ) ) { int temp = spf [ x ] ; if ( ( x % temp == 0 ) ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( ( x % temp == 0 ) ) { x = x / temp ; } } int [ ] check = new int [ arr . length ] ; while ( ( x != 1 ) ) { int temp = spf [ x ] ; if ( ( x % temp == 0 ) && hash1 [ temp ] > 1 ) { return false ; } while ( ( x % temp == 0 ) ) { x = x / temp ; } } return true ; }
static boolean isExists ( int [ ] a , int n ) { HashMap < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { freq . put ( a [ i ] , 0 ) ; } int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( a [ i ] , 1 ) ; Sum += a [ i ] ; } if ( Sum % 2 == 0 ) { if ( freq . get ( Sum / 2 ) != 0 ) { return true ; } } return false ; }
public static double areaOfKite ( double d1 , double d2 ) { double area = ( d1 * d2 ) / 2 ; return area ; }
public static String getProfileName ( String fileName ) { String profileName = fileName . substring ( 0 , fileName . lastIndexOf ( ' . ' ) ) ; if ( profileName == null ) { profileName = fileName . substring ( fileName . lastIndexOf ( ' . ' ) + 1 ) ; } if ( profileName == null ) { profileName = fileName . substring ( fileName . lastIndexOf ( ' . ' ) + 1 ) ; } if ( profileName == null ) { profileName = fileName . substring ( fileName . lastIndexOf ( ' . ' ) + 1 ) ; } if ( profileName == null ) { profileName = fileName . substring ( fileName . lastIndexOf ( ' . ' ) + 1 ) ; } if ( profileName == null ) { profileName = fileName . substring ( fileName . lastIndexOf ( ' . ' ) + 1 ) ; } if ( profileName == null ) { profileName = fileName . substring ( fileName . lastIndexOf ( ' . ' ) + 1 ) ; } if ( profileName == null ) { profileName = fileName . substring ( fileName . lastIndexOf ( ' . ' ) + 1 ) ; } if ( profileName == null ) { profileName = fileName . substring ( fileName . lastIndexOf ( ' . ' ) + 1 ) ; } return profileName ; }
public static String getSuffix ( String suffix ) { if ( suffix == null ) { return null ; } else { return suffix ; } }
public static boolean productEqual ( int n ) { if ( n < 10 ) { return false ; } int prodOdd = 1 ; int prodEven = 1 ; while ( n > 0 ) { int digit = n % 10 ; prodOdd *= digit ; n = n / 10 ; if ( n == 0 ) { break ; } digit = n % 10 ; prodEven *= digit ; n = n / 10 ; } if ( prodOdd == prodEven ) { return true ; } return false ; } n = 4324 ; if ( productEqual ( n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
public static String charList ( char [ ] charArray ) { charArray = new String ( charArray ) ; charArray . replace ( ' a ' , ' z ' ) ; charArray . replace ( ' A ' , ' Z ' ) ; while ( true ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; if ( n == 0 ) break ; List < Integer > keys = Collections . list ( Integer . parseInt ( System . getProperty ( " line . separator " ) ) ) ; String sentence = System . getProperty ( " line . separator " ) ; for ( int i = 0 ; i < sentence . length ( ) ; i ++ ) { int j ; if ( Character . isUpperCase ( sentence . charAt ( i ) ) ) j = ( int ) sentence . charAt ( i ) - ( int ) ' A ' + 26 ; else j = ( int ) sentence . charAt ( i ) - ( int ) ' a ' ; System . out . print ( charArray . charAt ( j - keys . get ( i % keys . size ( ) ) ) ) ; } } System . out . println ( ) ; return null ; }
static void checkEVENodd ( int [ ] arr , int n , int l , int r ) { if ( ( arr [ r ] == 1 ) ) { System . out . println ( " odd " ) ; } else { System . out . println ( " even " ) ; } arr = new int [ ] { 1 , 1 , 0 , 1 } ; n = arr . length ; checkEVENodd ( arr , n , 1 , 3 ) ; }
public static int getRandom ( ) { int i = 0 ; int W = 0 , H = 0 , x = 0 , y = 0 , r = 0 ; if ( x - r < 0 || y - r < 0 || x + r > W || y + r > H ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; } return i ; }
public static boolean isPrime ( int n ) { if ( n <= 1 ) { return false ; } for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
public static int compositeProduct ( int [ ] arr , int n ) { int maxVal = Math . max ( arr . length , arr [ 0 ] ) ; boolean [ ] prime = new boolean [ maxVal + 1 ] ; prime [ 0 ] = true ; prime [ 1 ] = true ; for ( int p = 2 ; p < Math . ceil ( Math . sqrt ( maxVal ) ) ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= maxVal ; i += p ) { prime [ i ] = false ; } } } int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == false ) { product *= arr [ i ] ; } } return product ; }
public static void solve ( String [ ] args ) { int x , y ; x = Integer . parseInt ( args [ 0 ] ) ; y = Integer . parseInt ( args [ 1 ] ) ; if ( x == 0 && y == 0 ) break ; ArrayList < Integer > liste = new ArrayList < > ( ) ; liste . add ( x ) ; liste . add ( y ) ; Collections . sort ( liste ) ; System . out . println ( liste . get ( 0 ) + " ▁ " + liste . get ( 1 ) ) ; }
public static void printString ( String input ) { for ( int i = 0 ; i < input . length ( ) ; i ++ ) { String n = input . substring ( 0 , input . length ( ) - 1 ) ; if ( n . substring ( 0 , 2 ) . equals ( " op " ) ) { System . out . println ( " FILIPINO " ) ; } else if ( n . substring ( 0 , 5 ) . equals ( " adinm " ) ) { System . out . println ( " KOREAN " ) ; } else { System . out . println ( " JAPANESE " ) ; } } }
static int findSum ( int arr [ ] , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }
public static int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) { for ( int j = 0 ; j <= n - i + 1 ; j += b ) { double z = ( n - ( i + j ) ) / c ; if ( ( Math . floor ( z ) == Math . ceil ( z ) ) ) { int x = i / a ; int y = j / b ; maxVal = Math . max ( maxVal , x + y + ( int ) z ) ; } } } return maxVal ; }
public static int [ ] a ( ) { for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; } Arrays . sort ( a ) ; for ( int i = 1 ; i < 4 ; i ++ ) { System . out . println ( a [ a . length - i ] ) ; } return a ; }
public static int fact ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { ans = ans * i ; } return ( ans ) ; }
public static int getLargestNumber ( int [ ] array , int index ) { int [ ] arr = array . clone ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = array [ i ] ; } if ( ( arr . length == 1 ) ) { System . out . println ( "1" ) ; } else { while ( ( arr . length == 1 ) ) { if ( ( arr [ i ] == arr [ i ] ) ) { System . out . println ( arr [ i ] ) ; } else if ( ( arr [ i ] == arr [ i ] ) ) { System . out . println ( arr [ i ] ) ; } else if ( ( arr [ i ] != arr [ i ] ) ) { arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i ] ; arr [ i ] = arr [ i
public static int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; n = 107 ; m = 4 ; return ( m ) ; }
public static int t ( ) { String s = System . getProperty ( " user . name " ) ; boolean flag = s . charAt ( s . length ( ) - 1 ) != ' B ' ? false : true ; if ( flag ) { int summ = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == ' A ' ) { summ += 1 ; } else { summ -= 1 ; } if ( summ < 0 ) { flag = false ; break ; } } } if ( flag ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } t -- ; return t ; }
public static String firstSubstring ( String s ) { int n = s . length ( ) ; int c = 0 ; Map < String , Integer > mpp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == ' ▁ ' ) || ( s . charAt ( i ) == ' # ' ) ) { String s1 = s . substring ( c , i ) ; mpp . put ( s1 , 1 ) ; c = i + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == ' ▁ ' ) ) continue ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( s . charAt ( j ) == ' ▁ ' ) ) break ; String s1 = s . substring ( i , j + 1 ) ; String s2 = s1 ; s1 = s1 . substring ( 0 , s1 . length ( ) - 1 ) ; if ( mpp . containsKey ( s1 ) ) { if ( mpp . get ( s1 ) != null ) return s2 ; } } } return " - 1" ; }
static int countConsecutive ( int n ) { String s = String . valueOf ( n ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( ( s . charAt ( i ) == s . charAt ( i + 1 ) ) ) { count ++ ; } } return count ; }
static void findAngle ( int n ) { int interiorAngle = ( int ) ( ( n - 2 ) * 180 / n ) ; int exteriorAngle = ( int ) ( 360 / n ) ; System . out . println ( " Interior ▁ angle : " + interiorAngle ) ; System . out . println ( " Exterior ▁ angle : " + exteriorAngle ) ; }
public static void nDigitPerfectSquares ( int n ) { System . out . print ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) ) ; System . out . println ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 ) ; }
public static String getStrFromString ( String str ) { if ( str == null ) { return null ; } else if ( str . length ( ) == 0 ) { return " " ; } else if ( str . length ( ) == 1 ) { return " " ; } else if ( str . length ( ) == 2 ) { return " " ; } else if ( str . length ( ) == 3 ) { return " " ; } else if ( str . length ( ) == 4 ) { return " " ; } else if ( str . length ( ) == 5 ) { return " " ; } else if ( str . length ( ) == 6 ) { return " " ; } else if ( str . length ( ) == 7 ) { return " " ; } else if ( str . length ( ) == 8 ) { return " " ; } else if ( str . length ( ) == 9 ) { return " " ; } else if ( str . length ( ) == 10 ) { return " " ; } else if ( str . length ( ) == 11 ) { return " " ; } else if ( str . length ( ) == 12 ) { return " " ; } else if ( str . length ( ) == 13 ) { return " " ; } else if
public static String getSuffix ( String name ) { if ( name == null ) { return null ; } else { return name . substring ( name . lastIndexOf ( ' . ' ) + 1 ) ; } }
public static int power ( int a [ ] , int n ) { if ( ( n == 0 ) ) { return 1 ; } int p = power ( a , n / 2 ) ; p = p * p ; if ( ( n & 1 ) != 0 ) { p = p * a ; } return p ; }
public static int getHashCode ( int [ ] array ) { int result = 0 ; int i = 0 ; for ( ; i < array . length ; i ++ ) { if ( array [ i ] == array [ i ] ) { result += i ; } } if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } else if ( i == array . length - 1 ) { result += i ; } return result ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalFor
public static String getDiceText ( String [ ] eyes ) { String [ ] eyes = new String [ eyes . length + 1 ] ; eyes [ 0 ] = " dummy " ; for ( int i = 0 ; i < eyes . length ; i ++ ) { eyes [ i ] = eyes [ i ] ; } @ SuppressWarnings ( " unused " ) String [ ] eye = eyes [ 1 ] ; for ( int i = 0 ; i < eyes . length ; i ++ ) { String [ ] a = eyes [ i ] . split ( " ▁ " ) ; switch ( a [ i ] ) { case ' N ' : eyes [ i ] = " dummy " ; eyes [ i ] = a [ 2 ] ; eyes [ i ] = a [ 6 ] ; eyes [ i ] = a [ 3 ] ; break ; case ' S ' : eyes [ i ] = a [ 5 ] ; eyes [ i ] = a [ 4 ] ; break ; case ' W ' : eyes [ i ] = a [ 3 ] ; eyes [ i ] = a [ 2 ] ; eyes [ i ] = a [ 6 ] ; eyes [ i ] = a [ 1 ] ; eyes [ i ] = a [ 5 ] ; eyes [ i ] = a [ 4 ] ; break ; case ' E ' : eyes [ i ] = a [ 4 ] ; eyes [ i ] = a [ 2 ] ; eyes [ i ] = a [ 1 ] ; eyes [ i ] = a [ 6 ] ; eyes [ i ] = a [ 5 ] ; eyes [ i ] = a [ 3 ] ; break ; default : throw new IllegalArgumentException ( " NEWS箱推し " ) ; } } eyes = new String ( eyes ) ; Dice dice = new Dice ( eyes ) ; String [ ] directionText = new String [ eyes . length ] ; for ( int i = 0 ; i < directionText . length ; i ++ ) { dice . roll ( directionText [ i ] ) ; } return dice . getDiceText ( ) ; }
public static int getRandom ( int [ ] array ) { int [ ] result = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { result [ i ] = array [ i ] ; } return result [ 0 ] ; }
public static int nonDecNums ( int n ) { final int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return ( int ) a [ n ] [ 0 ] ; }
public static void parseLine ( String line ) { for ( int i = 0 ; i < line . length ( ) ; i ++ ) { line = line . substring ( i , i + 1 ) ; } int n = line . length ( ) ; int [ ] l = line . split ( " ▁ " ) ; Map < Integer , Integer > map = new HashMap < > ( ) ; int f = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( i + l [ i ] ) % n ; if ( map . containsKey ( x ) ) { f = 1 ; break ; } else { map . put ( x , 1 ) ; } } if ( f == 1 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } }
public static int minMoves ( ) { int [ ] nums = new int [ ] { 1 , 2 , 3 } ; int out = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] == null || nums [ i ] == 0 ) { return 0 ; } int minNum = Math . min ( nums [ i ] , nums [ i ] ) ; return Arrays . stream ( nums ) . mapToInt ( i -> i - minNum ) . sum ( ) ; } if ( Integer . class . equals ( Integer . class . getName ( ) ) ) { Integer sObj = new Integer ( Integer . toString ( nums [ 0 ] ) ) ; int [ ] nums = new int [ ] { 1 , 2 , 3 } ; out = sObj . minMoves ( nums ) ; System . out . println ( out ) ; } return out ; }
public static int parseInteger ( String input ) { int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; if ( a <= 0 && 0 <= b ) { System . out . println ( " Zero " ) ; } else if ( a < 0 && Math . min ( b - a , - a ) % 2 == 0 ) { System . out . println ( " Negative " ) ; } else { System . out . println ( " Positive " ) ; } return a ; }
public static int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; }
public static int maximumChars ( String str1 ) { int n = str1 . length ( ) ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { firstInd [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { int firstInd = firstInd [ ( int ) str1 . charAt ( i ) ] ; if ( ( firstInd == - 1 ) ) { firstInd [ ( int ) str1 . charAt ( i ) ] = i ; } else { res = Math . max ( res , Math . abs ( i - firstInd [ i - 1 ] ) ) ; } } return res ; }
public static int [ ] getNegativeInstances ( ) { int [ ] [ ] array = new int [ 2 ] [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] [ 0 ] ; array [ i ] [ 1 ] = array [ i ] [ 1 ] ; } Arrays . sort ( array ) ; int L = 0 ; int R = 0 ; int ans = 0 ; int ans1 = 0 ; while ( L < array . length && R < array . length ) { ans = Math . max ( array [ R ] [ 1 ] , ans ) ; if ( Math . abs ( array [ L ] [ 0 ] - array [ R ] [ 0 ] ) < array [ R ] ) { ans1 += array [ R ] [ 1 ] ; R ++ ; } else { ans = Math . max ( ans1 , ans ) ; ans1 -= array [ L ] [ 1 ] ; L ++ ; } } return array ; }
public static double findArea ( double a ) { double area = 5 * Math . sqrt ( 3 ) * a * a ; return area ; double volume = ( ( 5 / 12 ) * ( 3 + Math . sqrt ( 5 ) ) * a * a * a ) ; return volume ; }
public static String compute ( ) { int [ ] ninePyramidalPDF = { 1 } ; int [ ] PYRAMIDAL_DIE_PDF = { 0 , 1 , 1 , 1 , 1 } ; for ( int i = 0 ; i < 9 ; i ++ ) ninePyramidalPDF = ConvolveArray ( ninePyramidalPDF , PYRAMIDAL_DIE_PDF ) ; int [ ] six_cubicPDF = { 1 } ; int [ ] CUBIC_DIE_PDF = { 0 , 1 , 1 , 1 , 1 , 1 } ; for ( int i = 0 ; i < 6 ; i ++ ) six_cubicPDF = ConvolveArray ( six_cubicPDF , CUBIC_DIE_PDF ) ; int ans = 0 ; for ( int i = 0 ; i < ninePyramidalPDF . length ; i ++ ) ans += ninePyramidalPDF [ i ] * Arrays . stream ( six_cubicPDF , 0 , i ) . mapToObj ( i -> { } ) . collect ( Collectors . toList ( ) ) ; ans = ( double ) ans / ( Arrays . stream ( ninePyramidalPDF ) . mapToObj ( i -> { } ) . sum ( ) * Arrays . stream ( six_cubicPDF , 0 , i ) . mapToObj ( i -> { } ) . collect ( Collectors . toList ( ) ) ) ; return f . concat ( ans , .7f ) ; }
public static int sum ( int [ ] array ) { int sum = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { sum += array [ i ] ; } return sum ; }
public static int solve ( int M , int N , int s ) { if ( ( N % s ) == 0 ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( ( M % s ) == 0 ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return M * N ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) ) { return b ; } return gcd ( b % a , a ) ; }
public static int [ ] scoresOfTheParticipants ( int [ ] scoresOfTheParticipants ) { int totalScores = Arrays . stream ( scoresOfTheParticipants ) . mapToInt ( Integer :: parseInt ) . sum ( ) ; int chosenTeams = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { for ( int j = i + 1 ; j < 6 ; j ++ ) { for ( int k = j + 1 ; k < 6 ; k ++ ) { if ( scoresOfTheParticipants [ i ] + scoresOfTheParticipants [ j ] + scoresOfTheParticipants [ k ] == totalScores - ( scoresOfTheParticipants [ i ] + scoresOfTheParticipants [ j ] + scoresOfTheParticipants [ k ] ) ) { chosenTeams ++ ; } } } } if ( chosenTeams == 0 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } return new int [ ] { } ; }
public static int popcnt32 ( int number ) { int counter = 0 ; while ( ( number > 0 ) ) { if ( ( number % 2 == 1 ) ) { counter = counter + 1 ; } number = ( int ) ( number / 2 ) ; } return counter ; }
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static int [ ] xorQueries ( int [ ] arr , int [ ] [ ] queries ) { int [ ] pref = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { pref [ i ] = arr [ i ] ^ pref [ arr . length - i - 1 ] ; } int [ ] ans = new int [ queries . length ] ; for ( int [ ] l = queries . length ; i < arr . length ; i ++ ) { for ( int [ ] r = queries [ i ] ; r < arr . length ; r ++ ) { ans [ i ] = pref [ r + 1 ] ^ pref [ l ] ; } } return ans ; }
public static String encodedChar ( String str , int k ) { String expand = " " ; int freq = 0 ; int i = 0 ; while ( ( i < str . length ( ) ) ) { String temp = " " ; freq = 0 ; while ( ( i < str . length ( ) ) && ( str . charAt ( i ) >= ' a ' ) && ( str . charAt ( i ) <= ' z ' ) ) { temp += str . charAt ( i ) ; i ++ ; } while ( ( i < str . length ( ) ) && ( str . charAt ( i ) >= '1' ) && ( str . charAt ( i ) <= '9' ) ) { freq = freq * 10 + str . charAt ( i ) - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j += 1 ) { expand += temp ; } } if ( ( freq == 0 ) ) { expand += temp ; } return expand . charAt ( k - 1 ) ; }
static void printPossible ( int a , int b , int c ) { if ( ( ( a + b + c ) % 2 != 0 || a + b < c ) ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } if ( Class . isPrimitive ( " java . lang . String " ) ) { a = 2 ; b = 4 ; c = 2 ; printPossible ( a , b , c ) ; } }
public static int summation ( int n ) { int absSum = n * ( n + 1 ) / 2 ; int sign = ( ( ( n + 1 ) % 2 ) == 0 ) ? 1 : - 1 ; int resultSum = sign * absSum ; return resultSum ; }
public static void sortSquare ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] * arr [ i ] ; } Arrays . sort ( arr ) ; arr = new int [ ] { - 6 , - 3 , - 1 , 2 , 4 , 5 } ; n = arr . length ; System . out . println ( " Before ▁ sort " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( " " ) ; sortSquare ( arr , n ) ; System . out . println ( " After ▁ sort " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
public static int getDay ( int [ ] array ) { int [ ] daysArr = array . clone ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( i == array [ i ] ) { daysArr [ i ] = array [ i ] ; } } return daysArr [ 0 ] ; }
public static int [ ] getNegativeInstances ( ) { int [ ] A = new int [ n ] ; Arrays . fill ( A , 0 ) ; Arrays . fill ( A , 1 ) ; Arrays . fill ( A , 2 ) ; Arrays . fill ( A , 3 ) ; Arrays . fill ( A , 4 ) ; Arrays . fill ( A , 5 ) ; Arrays . fill ( A , 6 ) ; Arrays . fill ( A , 7 ) ; Arrays . fill ( A , 8 ) ; Arrays . fill ( A , 9 ) ; Arrays . fill ( A , 10 ) ; Arrays . fill ( A , 11 ) ; Arrays . fill ( A , 11 ) ; Arrays . fill ( A , 12 ) ; Arrays . fill ( A , 13 ) ; Arrays . fill ( A , 14 ) ; Arrays . fill ( A , 15 ) ; return l ; }
public static boolean isTriangular ( int num ) { if ( ( num < 0 ) ) { return false ; } int c = ( - 2 * num ) ; int b = 1 , a = 1 ; double d = ( b * b ) - ( 4 * a * c ) ; if ( ( d < 0 ) ) { return false ; } double root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; double root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( ( root1 > 0 ) && ( Math . floor ( root1 ) == root1 ) ) { return true ; } if ( ( root2 > 0 ) && ( Math . floor ( root2 ) == root2 ) ) { return true ; } return false ; } int n = 55 ; if ( ( isTriangular ( n ) ) ) { System . out . println ( " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ) ; } else { System . out . println ( " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ) ; } return false ; }
static void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) { System . out . print ( - 1 ) ; } else { System . out . print ( d ) ; k -- ; while ( k > 0 ) { System . out . print ( 0 ) ; k -- ; } } if ( Class . isPrimitive ( ) ) { k = 4 ; d = 4 ; } else { System . out . println ( " " ) ; } }
public static void rotateMatrix ( int [ ] [ ] mat ) { int i = N - 1 ; while ( ( i >= 0 ) ) { int j = N - 1 ; while ( ( j >= 0 ) ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; j = j - 1 ; } System . out . println ( ) ; i = i - 1 ; } }
public static int getRandom ( ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; if ( n % 500 == 0 ) { System . out . println ( n ) ; } else { System . out . println ( ( n / 500 ) * 500 ) ; } return n ; }
static int getProduct ( int n ) { int product = 1 ; while ( ( n != 0 ) ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
public static int getCoinNumber ( int [ ] coins ) { int b , r , g , c , s , t = Integer . parseInt ( input [ 0 ] ) ; if ( t == 0 ) { break ; } int cnt = b * 5 + r * 3 + s ; coins = ( b * 5 + r * 3 ) * ( 15 - 2 ) ; coins += b * 15 ; coins += r * 15 ; coins += 7 * g ; coins += 2 * c ; coins += 100 - ( t - cnt ) * 3 ; System . out . println ( coins ) ; return 0 ; }
public static int [ ] [ ] getColors ( int maxn ) { int mod = 1000000007 ; int [ ] [ ] [ ] comb = new int [ maxn ] [ maxn ] [ maxn ] ; for ( int i = 0 ; i < maxn ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( i == j ) { if ( i == j ) { i = j ; } else { if ( i == j ) { i = j ; } else { i = j ; } } } } } for ( int i = 0 ; i < k ; i ++ ) { int [ ] color = new int [ i ] [ ] ; color [ i ] = new int [ ] { i } ; } int res = 1 ; int total = 0 ; for ( int i = 0 ; i < k ; i ++ ) { res = ( res * comb [ total + color [ i ] - 1 ] [ color [ i ] - 1 ] ) % mod ; total += color [ i ] % mod ; } return ( res % mod ) ; }
public static double lengthRope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; double r = 7 ; return ( r ) ; }
public static int reverseDigits ( int num ) { int revNum = 0 ; while ( ( num > 0 ) ) { revNum = revNum * 10 + num % 10 ; num = num / 10 ; } return revNum ; }
public static String solution ( ) { String out = " " ; int pos1 = num1 . length ( ) - 1 ; int pos2 = num2 . length ( ) - 1 ; int carry = 0 ; while ( pos1 >= 0 || pos2 >= 0 || carry == 1 ) { int digit1 = 0 ; int digit2 = 0 ; if ( pos1 >= 0 ) digit1 = ( int ) num1 [ pos1 ] - ( int ) '0' ; if ( pos2 >= 0 ) digit2 = ( int ) num2 [ pos2 ] - ( int ) '0' ; out += ( ( digit1 + digit2 + carry ) % 10 ) ; carry = ( digit1 + digit2 + carry ) / 10 ; pos1 -- ; pos2 -- ; } return out . substring ( 0 , out . length ( ) - 1 ) ; }
public static boolean isPerfect ( int n ) { int sum = 1 ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { sum = sum + i + n / i ; } i ++ ; } return ( sum == n && n != 1 ) ? true : false ; }
public static boolean isPower ( int n ) { if ( ( n <= 1 ) ) { return true ; } for ( int x = 2 ; x <= ( ( int ) Math . sqrt ( n ) ) ; x ++ ) { int p = x ; while ( ( p <= n ) ) { p = p * x ; if ( ( p == n ) ) { return true ; } } } return false ; }
public static boolean isPower ( int n ) { if ( ( n == 1 ) ) { return true ; } for ( int x = 2 ; x <= ( ( int ) Math . sqrt ( n ) ) ; x ++ ) { int y = 2 ; int p = ( int ) Math . pow ( x , y ) ; while ( ( p <= n ) && ( p > 0 ) ) { if ( ( p == n ) ) { return true ; } y = y + 1 ; p = Math . pow ( x , y ) ; } } return false ; for ( int i = 2 ; i <= 100 ; i ++ ) { if ( ( isPower ( i ) ) ) { System . out . print ( i + " ▁ " ) ; } } return false ; }
public static void findTwoNumbers ( int sum , int gcd ) { if ( ( Math . gcd ( gcd , sum - gcd ) == gcd ) && sum != gcd ) { System . out . println ( " a ▁ = ▁ " + Math . min ( gcd , sum - gcd ) + " , ▁ b ▁ = ▁ " + Math . min ( gcd , sum - gcd ) ) ; } else { System . out . println ( - 1 ) ; } if ( Class . isPrimitive ( " java . util . function . util . function . function " ) ) { int sum = 8 ; int gcd = 2 ; findTwoNumbers ( sum , gcd ) ; } }
public static void solve ( String input ) { int n , m , rb , cb , rd , cd ; for ( ; n < input . length ( ) ; n ++ ) { m = Integer . parseInt ( input . substring ( n , m ) ) ; rb = - 1 ; cb = - 1 ; rd = - 1 ; cd = - 1 ; t = 0 ; int df = 1 , dp = 1 ; do { if ( rb == n ) { df = - 1 * df ; } if ( cb == m ) { dp = - 1 * dp ; } if ( rb == rd || cb == cd ) { break ; } rb += df ; cb += dp ; t ++ ; } while ( m != n ) ; } System . out . println ( t ) ; }
public static int getRandom ( String input ) { int X , Y ; int N = Integer . parseInt ( input ) ; if ( ( A <= N ) || ( C <= N ) ) { if ( N % A == 0 ) { X = ( int ) ( N / A ) * B ; } else { X = ( int ) ( N / A + 1 ) * B ; } if ( N % C == 0 ) { Y = ( int ) ( N / C ) * D ; } else { Y = ( int ) ( N / C + 1 ) * D ; } } else { X = B ; Y = D ; } if ( X <= Y ) { System . out . println ( Integer . parseInt ( X ) ) ; } else { System . out . println ( Integer . parseInt ( Y ) ) ; } return X ; }
static int totalPairs ( int [ ] arr , int n ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = Integer . valueOf ( arr [ i ] ) . intValue ( ) ; m . put ( x , m . getOrDefault ( x , 0 ) + 1 ) ; } int result = 0 ; for ( int it : m . keySet ( ) ) { result += ( m . get ( it ) * ( m . get ( it ) - 1 ) ) / 2 ; } return result ; }
public static int centerHapdecagonalNum ( int n ) { return 8 * n * n - 8 * n + 1 ; if ( Class . isPrimitive ( " java . util . logging . Logger " ) ) { n = 2 ; System . out . println ( n + " th ▁ centered ▁ hexadecagonal ▁ " + " number ▁ : ▁ " + centerHapdecagonalNum ( n ) ) ; n = 12 ; System . out . println ( n + " th ▁ centered ▁ hexadecagonal ▁ " + " number ▁ : ▁ " + centerHapdecagonalNum ( n ) ) ; } return 0 ; }
public static int getDistance ( int [ ] array ) { int distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == array [ i ] ) { distance += array [ i ] ; } } return distance ; }
static int countNumbers ( int L , int R , int K ) { if ( ( K == 9 ) ) { K = 0 ; } int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i >= R - rem ; i -- ) { int rem1 = i % 9 ; if ( ( rem1 == K ) ) { ans ++ ; } } return ans ; }
public static int answer ( int a , int b , int c , int d , int e , int f ) { String input = System . getProperty ( " line . separator " ) ; List < Integer > in = new LinkedList < > ( ) ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { in . add ( Integer . parseInt ( input . substring ( i , i + 1 ) ) ) ; } int ans ; if ( ( e > f ) ) { int m = Math . min ( a , d ) ; ans = e * m ; d -= m ; ans += f * Math . min ( b , c , d ) ; } else { int m = Math . min ( b , c , d ) ; ans = f * m ; d -= m ; ans += e * Math . min ( a , d ) ; } return ans ; }
public static int solve ( int [ ] A ) { int ans = 2 ; int n = A . length ; if ( n <= 2 ) { return n ; } int [ ] llap = new int [ n ] ; Arrays . fill ( llap , 2 ) ; Arrays . sort ( A ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 ; int k = j + 1 ; while ( ( i >= 0 ) && ( k < n ) ) { if ( A [ i ] + A [ k ] == 2 * A [ j ] ) { llap [ j ] = Math . max ( llap [ k ] + 1 , llap [ j ] ) ; ans = Math . max ( ans , llap [ j ] ) ; i -- ; k ++ ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) { k ++ ; } else { i -- ; } } } return ans ; }
public static int minimumChanges ( int [ ] arr , int n , int d ) { int maxFreq = - 2147483648 ; HashMap < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a0 = arr [ i ] - i * d ; if ( freq . containsKey ( a0 ) ) { freq . put ( a0 , ++ i ) ; } else { freq . put ( a0 , 1 ) ; } if ( freq . get ( a0 ) > maxFreq ) { maxFreq = freq . get ( a0 ) ; } } return ( n - maxFreq ) ; } n = 5 ; d = 1 ; arr = new int [ ] { 1 , 3 , 3 , 4 , 6 } ; int ans = minimumChanges ( arr , n , d ) ; System . out . println ( ans ) ; }
public static int min ( int [ ] a ) { int n = Integer . parseInt ( input ) ; int [ ] [ ] a = new int [ n ] [ ] ; for ( int i = 0 ; i < a . length ; i ++ ) a [ i ] [ 0 ] = Integer . parseInt ( input [ i ] ) ; a = a . stream ( ) . filter ( x -> Arrays . stream ( x ) . filter ( v -> v >= u ) . count ( ) ) . count ( ) ; return a . length ; }
static int countPoints ( int n , int m , int [ ] a , int [ ] b , int x , int y ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int j = 0 , count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( ( b [ j ] >= a [ i ] - x ) && ( b [ j ] <= a [ i ] + y ) ) { count ++ ; j ++ ; break ; } else { j ++ ; } } } return count ; }
public static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >>> 1 ) ; int x = 4 ; return x ; }
public static boolean check ( int x ) { int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sum += v [ i ] - x ; } if ( sum >= s ) { return true ; } else { return false ; } int t = 1 ; while ( t > 0 ) { t -- ; int n = ( Integer . parseInt ( input . nextLine ( ) ) ) ; int s = ( Integer . parseInt ( input . nextLine ( ) ) ) ; int [ ] v = new int [ n ] ; v [ 0 ] = Integer . parseInt ( input . nextLine ( ) ) ; sum = 0 ; int l = 0 ; int r = 0x3f3f3f3f ; for ( int i = 0 ; i <= n ; i ++ ) { sum += v [ i ] ; r = Math . min ( v [ i ] , r ) ; } if ( sum < s ) { System . out . println ( - 1 ) ; } else { while ( l < r ) { int mid = ( l + r + 1 ) >> 1 ; if ( check ( mid ) == true ) { l = mid ; } else { r = mid - 1 ; } } System . out . println ( l ) ; } } return false ; }
public static int longestSubstring ( String s ) { int cnt = 1 ; int maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) != s . charAt ( i - 1 ) ) ) { cnt ++ ; } else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
public static int [ ] getNegativeInstances ( ) { int [ ] result = new int [ 50 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = i ; } return result ; }
public static int zeroUpto ( int digits ) { int first = ( int ) ( ( Math . pow ( 10 , digits ) - 1 ) / 9 ) ; int second = ( int ) ( ( Math . pow ( 9 , digits ) - 1 ) / 8 ) ; return 9 * ( first - second ) ; }
public static double cone ( double a ) { if ( ( a < 0 ) ) { return - 1 ; } double r = ( a * Math . sqrt ( 2 ) ) / 3 ; double h = ( 2 * a ) / 3 ; double V = 3.14 * Math . pow ( r , 2 ) * h ; return V ; }
public static boolean Prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i < Math . ceil ( Math . sqrt ( n + 1 ) ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
public static double sum ( double n ) { if ( n < 2 ) { return 1 ; } else { return 1 / n + ( Math . pow ( n - 1 , 2 ) ) ; } return Math . pow ( 8 , 2 ) ; }
static int countElements ( int [ ] p , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ) { ans += 1 ; } else if ( ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ) { ans += 1 ; } } return ans ; }
public static int getDistance ( int [ ] array ) { int distance = array . length ; return ( int ) ( ( double ) distance / array . length ) ; }
static double findVolume ( double l , double b , double h ) { return ( ( l * b * h ) / 2 ) ; }
public static int getDistance ( int [ ] array ) { int distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == array [ i ] ) { distance += array [ i ] ; } } return distance ; }
public static String compute ( ) { int i = 286 ; int j = 166 ; int k = 144 ; do { int triangle = i * ( i + 1 ) / 2 ; int pentagon = j * ( j * 3 - 1 ) / 2 ; int hexagon = k * ( k * 2 - 1 ) ; int minimum = Math . min ( triangle , pentagon , hexagon ) ; if ( minimum == Math . max ( triangle , pentagon , hexagon ) ) { return String . valueOf ( triangle ) ; } if ( minimum == triangle ) { i ++ ; } if ( minimum == pentagon ) { j ++ ; } if ( minimum == hexagon ) { k ++ ; } } while ( true ) ; return String . valueOf ( i ) ; }
public static int maxPrimefactorNum ( int N ) { if ( ( N < 2 ) ) { return 0 ; } boolean [ ] arr = new boolean [ N + 1 ] ; int prod = 1 ; int res = 0 ; int p = 2 ; while ( ( p * p <= N ) ) { if ( ( arr [ p ] == true ) ) { for ( int i = p * 2 ; i <= N ; i += p ) { arr [ i ] = false ; } prod *= p ; if ( ( prod > N ) ) { return res ; } res ++ ; } p ++ ; } return res ; }
public static boolean checkDivisors ( int [ ] a , int n ) { int X = Math . max ( a . length , 0 ) ; List < Integer > b = new ArrayList < > ( ) ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( X ) ; i ++ ) { if ( ( X % i ) == 0 ) { b . add ( i ) ; if ( ( X / i ) != i ) { b . add ( X / i ) ; } } } if ( ( b . size ( ) ) != n ) { return false ; } Arrays . sort ( a , Collections . reverseOrder ( false ) ) ; Arrays . sort ( b , Collections . reverseOrder ( false ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( b . get ( i ) != a [ i ] ) ) { return false ; } } return true ; }
public static void subArray ( int [ ] arr , int n ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j + 1 ; k ++ ) { System . out . print ( arr [ k ] + " ▁ " ) ; } System . out . print ( " \n " ) ; } } arr = new int [ ] { 1 , 2 , 3 , 4 } ; n = arr . length ; System . out . println ( " All ▁ Non - empty ▁ Subarrays " ) ; subArray ( arr , n ) ; }
public static int getUnsignedShort ( String s ) { if ( s == null ) return - 1 ; return s . length ( ) ; }
public static int maxSum ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * i ; } return sum ; }
public static int maxSum ( int [ ] a , int n ) { Arrays . sort ( a ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; }
static int findAnswer ( int n , int [ ] arr ) { Arrays . sort ( arr , false ) ; int sum = 0 ; for ( int i = 0 ; i < ( int ) ( n / 2 ) ; i ++ ) { sum += ( ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ) ; } return sum ; }
static int findSum ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int sum = arr [ 0 ] ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( ( arr [ i ] != arr [ i + 1 ] ) ) { sum = sum + arr [ i + 1 ] ; } } return sum ; }
public static final int MIN = - 2147483648 ; final int MAX = 2147483648 ; class newnode ( int data ) { public int data ( ) { this . data = data ; this . left = null ; this . right = null ; } } public int getDeepestLeftLeafNode ( int root ) { if ( ( root = newnode ( root ) ) == null ) return 0 ; ArrayList < Integer > q = new ArrayList < > ( ) ; q . add ( root ) ; Integer result = null ; while ( ( q . size ( ) ) > 0 ) { Integer temp = q . get ( 0 ) ; q . remove ( 0 ) ; if ( ( temp . left != null ) ) { q . add ( temp . left ) ; if ( ( ! temp . left . left . isEmpty ( ) && ! temp . left . right . isEmpty ( ) ) ) result = temp . left ; } if ( ( temp . right != null ) ) q . add ( temp . right ) ; } return result ; } if ( __class . equals ( newnode ( 1 ) ) ) { newnode ( 2 ) ; newnode ( 3 ) ; newnode ( 4 ) ; newnode ( 5 ) ; newnode ( 6 ) ; newnode ( 7 ) ; newnode ( 8 ) ; newnode ( 8 ) ; newnode ( 10 ) ; newnode ( 10 ) ; } else { newnode ( 1 ) ; newnode ( 2 ) ; newnode ( 3 ) ; newnode ( 4 ) ; newnode ( 5 ) ; newnode ( 6 ) ; newnode ( 7 ) ; newnode ( 8 ) ; newnode ( 10 ) ; newnode ( 8 ) ; newnode ( 10 ) ; } newnode ( 10 ) ; newnode ( 0 ) ; newnode ( 1 ) ; newnode ( 2 ) ; newnode ( 3 ) ; newnode ( 4 ) ; newnode ( 5 ) ; newnode ( 6 ) ; newnode ( 7 ) ; newnode ( 8 ) ; newnode ( 10 ) ; newnode ( 2 ) ; newnode ( 5 ) ; newnode ( 6 ) ; newnode ( 7 ) ; newnode ( 8 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 2 ) ; newnode ( 3 ) ; newnode ( 4 ) ; newnode ( 5 ) ; newnode ( 6 ) ; newnode ( 7 ) ; newnode ( 8 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; return result ; }
public static final int MIN = - 2147483648 ; final int MAX = 2147483648 ; class newnode ( int data ) { public int data ( ) { this . data = data ; this . left = 0 ; this . right = 0 ; } } public int getDeepestRightLeafNode ( int root ) { if ( ( root = newnode ( root ) ) == null ) return 0 ; ArrayList < Integer > q = new ArrayList < > ( ) ; q . add ( root ) ; Integer result = null ; while ( ( q . size ( ) ) > 0 ) { Integer temp = q . get ( 0 ) ; q . remove ( 0 ) ; if ( ( temp . left ) != null ) q . add ( temp . left ) ; if ( ( temp . right ) != null ) { q . add ( temp . right ) ; if ( ( temp . right . left ) == null && ( temp . right . right ) == null ) result = temp . right ; } } return result ; } if ( __class . equals ( newnode ( 1 ) ) ) { newnode ( 2 ) ; newnode ( 3 ) ; newnode ( 4 ) ; newnode ( 5 ) ; newnode ( 6 ) ; newnode ( 7 ) ; newnode ( 8 ) ; newnode ( 8 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; } else { newnode ( 1 ) ; newnode ( 2 ) ; newnode ( 3 ) ; newnode ( 4 ) ; newnode ( 5 ) ; newnode ( 6 ) ; newnode ( 7 ) ; newnode ( 8 ) ; newnode ( 10 ) ; newnode ( 8 ) ; newnode ( 10 ) ; } newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; newnode ( 10 ) ; return result ; }
public static int getDistance ( int [ ] array ) { int distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { distance += array [ i ] * array [ i ] ; } return distance ; }
public static void printRatio ( int a , int b , int c , int d ) { if ( ( b * c > a * d ) ) { swap ( c , d ) ; swap ( a , b ) ; } double lcm = ( a * c ) / Math . gcd ( a , c ) ; double x = lcm / a ; b = ( int ) ( b * x ) ; double y = lcm / c ; d = ( int ) ( d * y ) ; double k = Math . gcd ( b , d ) ; b = ( int ) ( b / k ) ; d = ( int ) ( d / k ) ; System . out . println ( b + " : " + d ) ; }
public static int maxsum_SIS ( int [ ] arr , int n ) { int maxSum = 0 ; int currentSum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] < arr [ i ] ) ) { currentSum = currentSum + arr [ i ] ; } else { maxSum = Math . max ( maxSum , currentSum ) ; currentSum = arr [ i ] ; } } return Math . max ( maxSum , currentSum ) ; }
public static int GCD ( int a , int b ) { if ( ( b == 0 ) ) return a ; return GCD ( b , a % b ) ; }
public static int gcd ( int a , int b ) { while ( ( b != 0 ) ) { int t = b ; b = a % b ; a = t ; } return a ; }
public static int getDistance ( String [ ] arr ) { int x , y , w , h ; int n ; for ( int i = 0 ; i < arr . length ; i ++ ) { x = arr [ i ] . trim ( ) ; y = arr [ i ] . trim ( ) ; w = arr [ i ] . trim ( ) ; h = arr [ i ] . trim ( ) ; n = arr [ i ] . trim ( ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int cx = arr [ i ] . trim ( ) ; int cy = arr [ i ] . trim ( ) ; if ( x <= cx && x <= cx + w && y <= cy && y <= cy + h ) { ans ++ ; } } return ans ; }
public static boolean divisibleBy37 ( String n ) { int l = n . length ( ) ; if ( ( n == 0 ) ) { return true ; } if ( ( l % 3 == 1 ) ) { n = "00" + n ; l += 2 ; } else if ( ( l % 3 == 2 ) ) { n = "0" + n ; l += 1 ; } int gSum = 0 ; while ( ( l != 0 ) ) { int group = Integer . parseInt ( n . substring ( l - 3 , l ) ) ; l = l - 3 ; gSum = gSum + group ; } if ( ( gSum >= 1000 ) ) { return ( divisibleBy37 ( String . valueOf ( gSum ) ) ) ; } else { return ( gSum % 37 == 0 ) ; } }
public static String getRandom ( String s ) { if ( s == null ) return null ; int n = s . length ( ) ; int x = s . length ( ) ; int y = s . length ( ) ; StringBuilder ans = y < n || n - 1 + Math . pow ( y - n + 1 , 2 ) < x ? new StringBuilder ( 1 ) : new StringBuilder ( n ) . append ( s ) . append ( y - n + 1 ) ; return ans . toString ( ) ; }
public static int lcs ( String X , String Y , int m , int n ) { int [ ] [ ] L = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 || j == 0 ) { L [ i ] [ j ] = 0 ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; } else { L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } } return L [ m ] [ n ] ; }
public static int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = base / 2 ; return ( int ) ( base * ( base + 1 ) / 2 ) ; }
public static double rmsValue ( double [ ] arr , int n ) { double square = 0 ; double mean = 0.0 ; double root = 0.0 ; for ( int i = 0 ; i <= n ; i ++ ) { square += ( arr [ i ] * arr [ i ] ) ; } mean = ( square / ( double ) ( n ) ) ; root = Math . sqrt ( mean ) ; return root ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ m ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = Integer . parseInt ( array [ i ] ) ; } int [ ] [ ] ce = new int [ n ] [ ] ; for ( int i = 0 ; i < array . length ; i ++ ) { ce [ i ] = Integer . parseInt ( array [ i ] [ i ] ) ; } int [ ] [ ] dp = new int [ m + 1 ] [ ] ; for ( int i = 0 ; i < dp . length ; i ++ ) { dp [ i ] [ 0 ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( j < ce [ i ] [ 0 ] ) { dp [ i + 1 ] [ j ] = Math . min ( dp [ i ] [ j ] , ce [ i ] [ 1 ] ) ; continue ; } dp [ i + 1 ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ j - ce [ i ] [ 0 ] ] + ce [ i ] [ 1 ] ) ; } } Arrays . sort ( dp ) ; Arrays . reverse ( dp ) ; int [ ] sump = new int [ m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) sump [ i + 1 ] += sump [ i ] + array [ i ] ; int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = Math . max ( ans , sump [ i ] - dp [ n ] [ i ] ) ; System . out . println ( ans ) ; return dp ; }
public static int [ ] createArray ( int [ ] array ) { int [ ] nodes = new int [ array . length ] ; @ SuppressWarnings ( " rawtypes " ) int [ ] array = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } return array ; }
public static void maxSum ( int [ ] [ ] arr ) { int n = 6 ; int m = 6 ; int [ ] [ ] dp = new int [ n + 1 ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { int m1 = 0 ; int m2 = 0 ; int m3 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( ( j / ( m / 3 ) ) ) == 0 ) { m1 = Math . max ( m1 , arr [ i ] [ j ] ) ; } else if ( ( ( j / ( m / 3 ) ) ) == 1 ) { m2 = Math . max ( m2 , arr [ i ] [ j ] ) ; } else if ( ( ( j / ( m / 3 ) ) ) == 2 ) { m3 = Math . max ( m3 , arr [ i ] [ j ] ) ; } } dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; dp [ i + 1 ] [ 2 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; } System . out . println ( ( int ) Math . max ( Math . max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) ; if ( Class . forName ( " java . util . Arrays $ ArrayList " ) . equals ( System . getProperty ( " java . util . Arrays $ ArrayList " ) ) ) { arr = new int [ ] [ ] { { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } } ; maxSum ( arr ) ; }
public static void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . max ( x1 , x3 ) ; int y5 = Math . max ( y1 , y3 ) ; int x6 = Math . min ( x2 , x4 ) ; int y6 = Math . min ( y2 , y4 ) ; if ( ( x5 > x6 ) || ( y5 > y6 ) ) { System . out . println ( " No ▁ intersection " ) ; return ; } System . out . print ( " ( " + x5 + " , ▁ " + y5 + " ) ▁ " ) ; System . out . print ( " ( " + x6 + " , ▁ " + y6 + " ) ▁ " ) ; int x7 = x5 ; int y7 = y6 ; System . out . print ( " ( " + x7 + " , ▁ " + y7 + " ) ▁ " ) ; int x8 = x6 ; int y8 = y5 ; System . out . print ( " ( " + x8 + " , ▁ " + y8 + " ) ▁ " ) ; } if ( Class . forName ( " java . util . regex . regex " ) . equals ( " java . util . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex
public static String getStrFromString ( String s ) { if ( s == null ) return null ; int nHamsters = s . length ( ) ; int hamstersUnderstanding = s . indexOf ( " X " ) ; int hamstersSitting = nHamsters - hamstersUnderstanding ; if ( hamstersUnderstanding == hamstersSitting ) { s = s . substring ( 0 , nHamsters ) ; } else if ( hamstersUnderstanding > hamstersSitting ) { int numChange = ( hamstersUnderstanding - hamstersSitting ) / 2 ; s = s . substring ( 0 , nHamsters ) ; s = s . substring ( nHamsters , nHamsters ) ; } else { s = s . substring ( nHamsters , nHamsters ) ; } return s ; }
public static int getDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDivideDi
public static int knapSack ( int W , int [ ] wt , double [ ] val , int n ) { double maxratio = - Integer . MAX_VALUE - 1 ; int maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( val [ i ] / wt [ i ] ) > maxratio ) ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; }
public static void AlternateRearrange ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; List < Integer > v1 = new LinkedList < > ( ) ; List < Integer > v2 = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 ) == 0 ) { v1 . add ( arr [ i ] ) ; } else { v2 . add ( arr [ i ] ) ; } } int index = 0 ; int i = 0 ; int j = 0 ; boolean flag = false ; if ( ( arr [ 0 ] % 2 ) == 0 ) { flag = true ; } while ( ( index < n ) ) { if ( ( flag == true ) ) { arr [ index ] = v1 . get ( i ) ; index ++ ; i ++ ; flag = ~ flag ; } else { arr [ index ] = v2 . get ( j ) ; index ++ ; j ++ ; flag = ~ flag ; } } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } arr = new int [ ] { 9 , 8 , 13 , 2 , 19 , 14 } ; n = arr . length ; AlternateRearrange ( arr , n ) ; }
public static int getA ( String [ ] args ) { int B = Integer . parseInt ( args [ 0 ] ) ; int C = Integer . parseInt ( args [ 1 ] ) ; if ( A <= C && B >= C ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return B ; }
public static String decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; for ( int i = 0 ; i < 32 ; i ++ ) { binaryNum [ i ] = 0 ; } int i = 0 ; while ( ( n > 0 ) ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } String binary = " " ; for ( int j = i - 1 ; j >= 0 ; j -- ) { binary += binaryNum [ j ] ; } return binary ; }
public static void makeArrayEqual ( int [ ] arr , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += arr [ i ] & 1 ; } System . out . println ( Math . min ( x , n - x ) ) ; }
public static int findKthLargest ( int [ ] nums , int k ) { final int [ ] out = new int [ nums . length ] ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] > nums [ i ] ) { out [ i ] = i ; } else { out [ i ] = i ; } } for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] <= pivot ) { out [ i ] = i ; left ++ ; } } out [ i ] = i ; if ( i < nums . length - 1 ) { out [ i ] = i ; } else { out [ i ] = i ; } return i ; }
public static String isDivisible ( int n ) { int temp = n ; while ( ( n = n ) != 0 ) { int k = n % 10 ; if ( ( temp % k ) == 0 ) { return " YES " ; } n /= 10 ; } return " NO " ; }
public static String isDivisible ( int n ) { int temp = n ; int sum = 0 ; while ( ( n = n ) != 0 ) { int k = n % 10 ; sum += k ; n /= 10 ; } if ( ( temp % sum ) == 0 ) { return " YES " ; } return " NO " ; }
public static int getUnsignedInt ( String value ) { try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException e ) { return 0 ; } }
static int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( ( l - size + 1 ) * ( b - size + 1 ) ) ; int area = ( totalSquares * size * size ) ; totalArea += area ; size ++ ; } return totalArea ; }
public static void arrange ( int N ) { if ( ( N == 1 ) ) { System . out . println ( "1" ) ; return ; } if ( ( N == 2 ) || ( N == 3 ) ) { System . out . println ( " - 1" ) ; return ; } int even = - 1 ; int odd = - 1 ; if ( ( N % 2 ) == 0 ) { even = N ; odd = N - 1 ; } else { odd = N ; even = N - 1 ; } while ( ( odd >= 1 ) ) { System . out . print ( odd + " ▁ " ) ; odd = odd - 2 ; } while ( ( even >= 2 ) ) { System . out . print ( even + " ▁ " ) ; even = even - 2 ; } } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { N = 5 ; arrange ( N ) ; }
public static int findMinEqualSums ( int [ ] a , int N ) { int sum = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { sum = sum + a [ i ] ; } int sum1 = 0 ; int sum2 = 0 ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i <= N - 1 ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( ( Math . abs ( sum1 - sum2 ) < min ) ) { min = Math . abs ( sum1 - sum2 ) ; } if ( ( min == 0 ) ) { break ; } } return min ; }
public static void addStringIfNotNull ( String str , String [ ] array ) { for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] . contains ( " ▁ " ) ) { array [ i ] = array [ i ] . substring ( 0 , i ) ; } else { array [ i ] = array [ i ] . substring ( i , i + 1 ) ; } } }
static int findOptimalSolution ( int [ ] a , int N ) { Arrays . sort ( a ) ; int points = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { points += a [ i ] * i ; } return points ; }
public static int getDistance ( int [ ] array , int start , int end ) { if ( array == null ) { return - 1 ; } if ( start < 0 ) { return - 1 ; } if ( end < 0 ) { return - 1 ; } if ( start > 0 ) { return - 1 ; } if ( end > 0 ) { return - 1 ; } if ( start < 0 ) { return - 1 ; } if ( end < 0 ) { return - 1 ; } if ( start > 0 ) { return - 1 ; } if ( end > 0 ) { return - 1 ; } if ( start < 0 ) { return - 1 ; } if ( end < 0 ) { return - 1 ; } if ( start > 0 ) { return - 1 ; } if ( end < 0 ) { return - 1 ; } return 0 ; }
public static void formatString ( String s , int [ ] values ) { for ( int i = 0 ; i < values . length ; i ++ ) { if ( s . charAt ( i ) == ' . ' ) { if ( i < values . length ) { values [ i ] = values [ i ] ; values [ i ] = values [ i ] ; } } } }
static int getPairs ( int [ ] a ) { int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < a . length ; j ++ ) { if ( ( a [ i ] < a [ j ] ) ) { count ++ ; } } } return count ; }
public static String getRandom ( String s ) { int n = Integer . parseInt ( s ) ; int k = Integer . parseInt ( s ) ; String ans = " " ; if ( k == 0 ) { System . out . println ( s ) ; } else if ( Integer . parseInt ( s ) <= 9 ) { System . out . println ( 0 ) ; } else { int c = 0 ; int condition = 0 ; ans = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i == 0 && condition == 0 ) { ans += '1' ; if ( s . charAt ( i ) == '1' ) { c += 0 ; } else { c += 1 ; } } else if ( condition == 0 ) { ans += '0' ; if ( s . charAt ( i ) == '0' ) { c += 0 ; } else { c += 1 ; } } } if ( c == k ) { condition = 1 ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { ans += s . charAt ( j ) ; if ( j == s . length ( ) - 1 ) { c = - 1 ; break ; } } } } System . out . println ( ans ) ; return ans ; }
public static int [ ] [ ] a ( int [ ] [ ] a ) { for ( int i = 0 ; i < 4 ; i ++ ) { String [ ] str = input ( ) . split ( " ▁ " ) ; a [ i ] [ 0 ] = Integer . parseInt ( str [ 0 ] ) ; } return a ; }
public static int [ ] precompute ( ) { int N = 10000 ; int MOD = 1000000007 ; int [ ] F = new int [ N ] ; { precompute ( ) ; } { F [ 1 ] = 2 ; } { F [ 2 ] = 3 ; } { F [ 3 ] = 4 ; } for ( int i = 4 ; i < N ; i ++ ) { F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; } int n = 8 ; precompute ( ) ; return F ; }
public static int getRandom ( ) { int n = 0 ; int cnt = 0 ; do { int ini = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; if ( n == 0 ) { break ; } else { if ( n == 1 ) { n = n ; } else { n = n ; } } } while ( n > 0 ) ; return cnt ; }
public static int CeilIndex ( int [ ] A , int l , int r , int key ) { while ( ( r - l > 1 ) ) { int m = l + ( r - l ) / 2 ; if ( ( A [ m ] >= key ) ) { r = m ; } else { l = m ; } } return r ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 0 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = i ; } return array ; }
public static String compute ( ) { final int LIMIT = 10 * 6 ; final int ans = Integer . valueOf ( 1 ) ; for ( int i = 0 ; i < LIMIT ; i ++ ) { if ( getChainLength ( i ) == 60 ) { return String . valueOf ( ans ) ; } } return String . valueOf ( ans ) ; }
public static int colourVisible ( int [ ] height , int [ ] colour , int K ) { int [ ] arr = new int [ K + 1 ] ; for ( int i = 0 ; i < K ; i ++ ) { arr [ i ] = 0 ; } int visible = 0 ; int max = height [ K - 1 ] ; arr [ colour [ K - 1 ] ] = 1 ; int i = K - 2 ; while ( ( i >= 0 ) ) { if ( ( height [ i ] > max ) ) { max = height [ i ] ; arr [ colour [ i ] ] = 1 ; } i -- ; } for ( int i = 1 ; i <= K ; i += 1 ) { if ( ( arr [ i ] == 1 ) ) { visible ++ ; } } return visible ; }
public static boolean checkPowerof8 ( double n ) { double i = Math . log ( n , 8 ) ; return ( i - Math . trunc ( i ) < 0.000001 ) ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int a = Integer . parseInt ( args [ i ] ) ; int b = Integer . parseInt ( args [ i ] ) ; if ( a == b ) { System . out . println ( ( a + b ) / 4 ) ; } else { System . out . println ( Math . min ( Math . min ( a , b ) , ( a + b ) / 4 ) ) ; } } }
public static int [ ] getNegativeInstances ( ) { int [ ] result = new int [ 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = i ; } for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = result [ i ] ; } return result ; }
public static void generateRandomString ( String input ) { int n = Integer . parseInt ( input ) ; int now = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int l = Integer . parseInt ( input ) ; int r = Integer . parseInt ( input ) ; if ( now <= l ) { System . out . print ( l ) ; now = l + 1 ; } else if ( now <= r ) { System . out . print ( now ) ; now ++ ; } else { System . out . print ( 0 ) ; } } System . out . println ( ) ; }
static int countWays ( int n , int m ) { int [ ] count = new int [ n + 2 ] ; for ( int i = 0 ; i < n + 2 ; i ++ ) { count [ i ] = 0 ; } count [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i > m ) ) { count [ i ] = count [ i - 1 ] + count [ i - m ] ; } else if ( ( i < m ) ) { count [ i ] = 1 ; } else { count [ i ] = 2 ; } } return count [ n ] ; }
public static void bombRequired ( int n ) { System . out . println ( n + n / 2 ) ; for ( int i = 2 ; i <= n ; i += 2 ) { System . out . print ( i + " ▁ " ) ; } for ( int i = 1 ; i <= n ; i += 2 ) { System . out . print ( i + " ▁ " ) ; } for ( int i = 2 ; i <= n ; i += 2 ) { System . out . print ( i + " ▁ " ) ; } }
public static int n ( ) { int n = ( int ) input ( ) ; return ( ( n + 1 ) & - ( n + 1 ) ) ; }
public static String getRandom ( ) { String s = String . valueOf ( System . currentTimeMillis ( ) ) ; StringBuffer myStr = new StringBuffer ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '0' || c == '1' ) { myStr . append ( c ) ; } else if ( c == ' B ' && myStr . length ( ) != 0 ) { myStr = myStr . substring ( 0 , myStr . length ( ) - 1 ) ; } } return myStr . toString ( ) ; }
public static int getRandom ( ) { int n , x ; while ( true ) { n = Integer . parseInt ( input . nextLine ( ) ) ; x = Integer . parseInt ( input . nextLine ( ) ) ; if ( ( n == 0 ) & ( x == 0 ) ) break ; int ret = 0 ; for ( int v = 1 ; v <= n ; v ++ ) if ( Integer . parseInt ( input . nextLine ( ) ) == x ) ret ++ ; } return ret ; }
public static int recur ( int ind , int cnt , int last , int [ ] a , int n , int k , int [ ] [ ] dp ) { int MAX = 100 ; int [ ] [ ] a = new int [ MAX ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( cnt == k ) ) { return 0 ; } if ( ( ind == n ) ) { return - 10 * 9 ; } if ( ( dp [ ind ] [ cnt ] != - 1 ) ) { return dp [ ind ] [ cnt ] ; } int ans = 0 ; for ( int i = ind ; i < n ; i ++ ) { if ( ( cnt % 2 ) == 0 ) { ans = Math . max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) ; } else { ans = Math . max ( ans , gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) ; } } dp [ ind ] [ cnt ] = ans ; return ans ; } a = new int [ ] { 4 , 5 , 3 , 7 , 8 , 10 , 9 , 8 } ; n = a . length ; k = 4 ; dp = new int [ MAX ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = - 1 ; } System . out . println ( recur ( 0 , 0 , 0 , a , n , k , dp ) ) ; return dp [ 0 ] [ n ] [ k ] ; }
public static int getCost ( int [ ] vals ) { int cost = 0 ; for ( int i = 0 ; i < vals . length ; i ++ ) { if ( vals [ i ] == vals [ i ] ) cost ++ ; } return cost ; }
public static String equivalentBase4 ( String bin ) { if ( ( bin . compareTo ( "00" ) == 0 ) ) { return 0 ; } if ( ( bin . compareTo ( "01" ) == 0 ) ) { return 1 ; } if ( ( bin . compareTo ( "10" ) == 0 ) ) { return 2 ; } if ( ( bin . compareTo ( "11" ) == 0 ) ) { return 3 ; } return " " ; }
public static final int getScore ( int [ ] array ) { int [ ] score = new int [ array . length ] ; Arrays . fill ( score [ array . length ] , 0 ) ; LinkedList < Integer > queue = new LinkedList < > ( ) ; queue . add ( new Integer ( array [ 0 ] ) ) ; int [ ] move = new int [ ] { { 1 , 4 } , { 0 , 2 , 5 } , { 1 , 3 , 6 } , { 2 , 7 } , { 0 , 5 } , { 1 , 4 , 6 } , { 2 , 5 , 7 } , { 3 , 6 } } ; while ( queue . size ( ) > 0 ) { Integer puz = queue . removeFirst ( ) ; int pos = puz . intValue ( ) ; for ( int npos : move [ pos ] ) { Integer npuz = new Integer ( puz ) ; npuz [ pos ] = npuz . intValue ( ) ; npuz [ npos ] = npuz . intValue ( ) ; npuz = new Integer ( npuz ) ; if ( ! score [ npuz ] ) { queue . add ( npuz ) ; score [ npuz ] = score [ puz ] + 1 ; } } } while ( true ) { try { Integer puzzle = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; System . out . println ( score [ puzzle ] ) ; } catch ( NumberFormatException e ) { break ; } } return 0 ; }
public static int min ( String input ) { int [ ] nums = new int [ input . length ( ) ] ; for ( int i = 0 ; i < nums . length ; i ++ ) { nums [ i ] = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; } return nums . length ; }
public static int minimumSquareFreeDivisors ( int N ) { final int MAX = 1005 ; int [ ] primes = new int [ MAX ] ; for ( int i = 0 ; i < primes . length ; i ++ ) { primes [ i ] = true ; } for ( int p = 2 ; p <= ( int ) Math . sqrt ( MAX ) ; p += 1 ) { if ( ( primes [ p ] == true ) ) { for ( int i = p * 2 ; i < MAX ; i += p ) { primes [ i ] = false ; } } } for ( int p = 2 ; p <= MAX ; p += 1 ) { if ( ( primes [ p ] ) ) { primes [ p ] = true ; } } return primes [ 0 ] ; }
public static int parseInt ( String input ) { int x = Integer . parseInt ( input ) ; int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; int ans = ( x - a ) % b ; Thread . sleep ( a * 0.001 ) ; return ans ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int k = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; List < Integer > elems = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { elems . add ( i ) ; } } boolean allSame = arr . stream ( ) . allMatch ( arr :: get ) ; if ( allSame ) { System . out . println ( 0 ) ; return ; } if ( k == 1 ) { System . out . println ( - 1 ) ; return ; } if ( ! allSame ( elems . subList ( k - 1 ) ) ) { System . out . println ( - 1 ) ; return ; } int target = elems . get ( elems . size ( ) - 1 ) ; List < Integer > toDelete = new ArrayList < > ( elems . subList ( 0 , k - 1 ) ) ; while ( toDelete . size ( ) > 0 && toDelete . get ( toDelete . size ( ) - 1 ) == target ) { toDelete . remove ( toDelete . size ( ) - 1 ) ; } System . out . println ( toDelete . size ( ) ) ; }
public static int fun ( int n ) { return n & ( n - 1 ) ; n = 7 ; return n ; }
public static int LongestFibSubseq ( int [ ] A , int n ) { HashSet < Integer > S = new HashSet < > ( Arrays . asList ( A ) ) ; int maxLen = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = A [ j ] ; int y = A [ i ] + A [ j ] ; int length = 2 ; while ( S . contains ( y ) ) { int z = x + y ; x = y ; y = z ; length ++ ; maxLen = Math . max ( maxLen , length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; }
static int countPairs ( int [ ] a , int [ ] b , int n , int m ) { int cnt = 0 ; Map < Integer , Integer > s = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int sum = a [ i ] + b [ j ] ; if ( ( ! s . keySet ( ) . contains ( ( int ) sum ) ) ) { cnt ++ ; s . put ( sum , 1 ) ; } } } return cnt ; }
public static boolean check ( int [ ] a , int y ) { int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { double x = Math . sqrt ( a [ i ] ) ; if ( ( Math . floor ( x ) ) == ( Math . ceil ( x ) ) ) { sum = sum + a [ i ] ; } } if ( ( sum % y ) == 0 ) { return true ; } else { return false ; } int [ ] a = { 2 , 3 , 4 , 9 , 10 } ; int x = 13 ; if ( check ( a , x ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
public static int [ ] getGreatestSituation ( int [ ] a , int [ ] b ) { int n = Integer . parseInt ( a [ 0 ] ) ; int q = Integer . parseInt ( b [ 0 ] ) ; int [ ] [ ] Q = new int [ n ] [ q ] ; for ( int i = 0 ; i < q ; i ++ ) { Q [ i ] = new int [ a . length ] ; for ( int j = 0 ; j < a . length ; j ++ ) { Q [ i ] [ j ] = Integer . parseInt ( a [ j ] ) ; } } for ( int i = 0 ; i < q ; i ++ ) { if ( q [ i ] == 0 ) { System . out . println ( Q [ i ] [ 1 ] ) ; } else if ( q [ i ] == 1 ) { if ( Q [ i ] [ 1 ] != null ) { System . out . println ( - Q [ i ] [ 0 ] ) ; } } else if ( q [ i ] == 2 ) { if ( Q [ i ] [ 1 ] != null ) { System . out . println ( Q [ i ] [ 1 ] ) ; } } } return Q ; }
public static int calculateMinSum ( int [ ] a , int n ) { Arrays . sort ( a ) ; int minSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) { minSum += Math . abs ( a [ i ] - a [ i - 1 ] ) ; } return minSum ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } return array ; }
public static int getRandom ( ) { int [ ] a = new int [ ] { Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name "
public static boolean isPalindrome ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) ) { return false ; } } return true ; }
public static int countNumbers ( int k , int n ) { int [ ] [ ] dp = new int [ 2 ] [ n + 1 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ i ] [ 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
public static int minCost ( int n , int [ ] arr , int cost ) { int Sum = 0 , totalCost = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { Sum += arr [ i ] ; } totalCost += cost * Sum ; arr [ n - 1 ] += Sum ; totalCost += ( 2 * cost * arr [ n - 1 ] ) ; return totalCost ; }
public static int solve ( String [ ] args ) { final String input = System . getProperty ( " input " ) ; int Q ; int CCA , CCC , CAN ; CAN = Math . min ( c , a , n ) ; c -= CAN ; a -= CAN ; if ( a > 0 && c > 0 ) { CCA = Math . min ( a , c / 2 ) ; c -= ( CCA * 2 ) ; } if ( c > 2 ) { CCC = c / 3 ; } return CAN + CCA + CCC ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPro
public static int getDistance ( int [ ] array , int start , int end ) { if ( array == null ) { return 0 ; } if ( start < 0 ) { return 0 ; } if ( end < array . length ) { return 0 ; } if ( start > array . length ) { return array [ start ] ; } if ( end > array . length ) { return array [ end ] ; } if ( start < 0 ) { return 0 ; } if ( end < array . length ) { return array [ start ] ; } if ( start > array . length ) { return array [ start ] ; } if ( end > array . length ) { return array [ end ] ; } return 0 ; }
public static int newNode ( int data ) { int [ ] arr = { data } ; int [ ] left = null ; int [ ] right = null ; int i ; for ( i = 0 ; i < arr . length ; i ++ ) { if ( ( i = arr [ i ] ) == 0 ) { return i ; } else { if ( ( i = arr [ i ] ) == 0 ) { left [ i ] = insert ( i , data ) ; } if ( ( i = arr [ i ] ) == 1 ) { right [ i ] = insert ( i , data ) ; } return i ; } } for ( i = 0 ; i < arr . length ; i ++ ) { if ( ( i = arr [ i ] ) == 0 ) { left [ i ] = insert ( i , data ) ; } else { left [ i ] = insert ( i , data ) ; } } return left [ i ] ; }
public static String removeChars ( String str , int k ) { int [ ] hash = new int [ MAX_CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hash [ ( int ) str . charAt ( i ) - ( int ) ' a ' ] ++ ; } String res = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( hash [ ( int ) str . charAt ( i ) - ( int ) ' a ' ] >= k ) ) { res += str . charAt ( i ) ; } } return res ; }
public static int LCSubStr ( String X , String Y , int m , int n ) { int [ ] [ ] LCSuff = new int [ n + 1 ] [ m + 1 ] ; for ( int k = 0 ; k < n ; k ++ ) for ( int l = 0 ; l < m + 1 ; l ++ ) LCSuff [ k ] [ l ] = 0 ; int result = 0 ; for ( int i = 0 ; i < m + 1 ; i ++ ) for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( ( i == 0 ) || ( j == 0 ) ) { LCSuff [ i ] [ j ] = 0 ; } else if ( ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCSuff [ i ] [ j ] ) ; } else { LCSuff [ i ] [ j ] = 0 ; } } return result ; } X = " OldSite : GeeksforGeeks . org " ; Y = " NewSite : GeeksQuiz . com " ; m = X . length ( ) ; n = Y . length ( ) ; System . out . println ( " Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is " + LCSubStr ( X , Y , m , n ) ) ; return result ; }
static int countOccurrences ( int x , int d ) { int count = 0 ; while ( ( x = x ) != 0 ) { if ( ( x % 10 == d ) ) { count += 1 ; } x = ( int ) ( x / 10 ) ; } return count ; }
static void printLogestIncSubArr ( int [ ] arr , int n ) { int m = 1 ; int l = 1 ; int maxIndex = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] > arr [ i - 1 ] ) ) { l = l + 1 ; } else { if ( ( m < l ) ) { m = l ; maxIndex = i - m ; } l = 1 ; } } if ( ( m < l ) ) { m = l ; maxIndex = n - m ; } for ( int i = maxIndex ; i < ( m + maxIndex ) ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } arr = new int [ ] { 5 , 6 , 3 , 5 , 7 , 8 , 9 , 1 , 2 } ; n = arr . length ; printLogestIncSubArr ( arr , n ) ; }
public static int a ( String input ) { int i = Integer . parseInt ( input ) ; for ( i = a ; i > 0 ; i -- ) { if ( a % i == 0 ) { System . out . print ( i + " ▁ " ) ; a = i ; } } return i ; }
public static int getDistance ( int [ ] array , int start , int end ) { if ( array == null ) { return - 1 ; } if ( start < 0 ) { return - 1 ; } if ( end < 0 ) { return - 1 ; } if ( start > end ) { return - 1 ; } if ( start < 0 ) { return - 1 ; } if ( start > end ) { return - 1 ; } if ( start < 0 ) { return - 1 ; } if ( start < end ) { return - 1 ; } if ( start > end ) { return - 1 ; } if ( start < end ) { return - 1 ; } if ( start > end ) { return - 1 ; } if ( start < end ) { return - 1 ; } if ( start < end ) { return - 1 ; } if ( start > end ) { return - 1 ; } return 0 ; }
public static int MaxSum ( int [ ] a , int n ) { int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = 0 ; } int S = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = res ; res += a [ i ] ; S += a [ i ] ; res = Math . max ( res , - S ) ; } int ans = S ; ans = Math . max ( ans , res ) ; int g = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { g -= a [ i ] ; ans = Math . max ( ans , g + b [ i ] ) ; } return ans ; }
public static String getRandom ( String input ) { if ( input . contains ( " [ " ) ) { for ( ; ; ) { int x = Integer . parseInt ( input . substring ( 0 , input . indexOf ( " [ " ) ) ) , y = Integer . parseInt ( input . substring ( input . indexOf ( " [ " ) , input . indexOf ( " ] [ " ) ) ) ; int i = 0 , j = 0 ; boolean turn = false ; int commands = 0 ; do { if ( i == x && j == y ) break ; if ( turn ) { if ( i == x ) break ; if ( i < x ) i ++ ; else i -- ; commands ++ ; } else { if ( j == y ) break ; if ( j < y ) j ++ ; else j -- ; commands ++ ; } turn = ! turn ; } while ( ! turn ) ; } return input . substring ( input . indexOf ( " [ " ) , input . indexOf ( " ] [ " ) ) ; }}
public static void reverse ( String str1 , int x ) { int n = ( str1 . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( str1 . charAt ( i ) ) ; } for ( int i = n + x - 1 ; i >= n ; i -- ) { System . out . print ( str1 . charAt ( i ) ) ; } for ( int i = n + x ; i < str1 . length ( ) ; i ++ ) { System . out . print ( str1 . charAt ( i ) ) ; } }
public static int lps ( String str ) { int n = str . length ( ) ; int [ ] [ ] L = new int [ n ] [ n ] ; for ( int x = 0 ; x < n ; x ++ ) { for ( int y = 0 ; y < n ; y ++ ) { L [ y ] [ x ] = 0 ; } } for ( int i = 0 ; i < n ; i ++ ) { L [ i ] [ i ] = 1 ; } for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( ( str . charAt ( i ) == str . charAt ( j ) ) && ( cl == 2 ) ) { L [ i ] [ j ] = 2 ; } else if ( ( str . charAt ( i ) == str . charAt ( j ) ) ) { L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; } else { L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } } return L [ 0 ] [ n - 1 ] ; }
public static boolean bitCheck ( int n ) { if ( ( ( n & ( n - 1 ) ) == 0 ) ) { return true ; } return false ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int n = Integer . parseInt ( args [ i ] ) ; int [ ] a = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) a [ j ] = Integer . parseInt ( args [ j ] ) ; int [ ] minprice = new int [ n ] ; minprice [ n ] = a [ 0 ] ; for ( int j = 1 ; j < n ; j ++ ) minprice [ j ] = Math . min ( minprice [ j - 1 ] , a [ j ] ) ; } int c = 0 ; for ( int j = 0 ; j < n ; j ++ ) c += a [ j ] > minprice [ j ] ; System . out . println ( c ) ; }
public static String compute ( ) { final int LIMIT = 10 * 8 - 1 ; int ans = 0 ; final int [ ] primes = EulerUtil . listPrimes ( LIMIT / 2 ) ; final int sqrt = EulerUtil . sqrt ( LIMIT ) ; final Iterator < Integer > iterator = primes . iterator ( ) ; while ( iterator . hasNext ( ) ) { final int p = iterator . next ( ) ; if ( p > sqrt ) { break ; } final int end = BinarySearch . search ( primes , LIMIT / p ) ; ans += ( end >= 0 ? end + 1 : - end - 1 ) - i ; } return String . valueOf ( ans ) ; }
public static int count ( int x , int cnt , int tight , int nonz , int [ ] [ ] num ) { int L = 20 ; int R = 100 ; d = 2 ; K = 1 ; System . out . println ( Math . solve ( R ) - Math . solve ( L - 1 ) ) ; int ans = 0 ; int limit = tight ? 9 : num [ pos ] ; for ( int dig = 0 ; dig < limit + 1 ; dig ++ ) { int currCnt = cnt ; if ( dig == d ) { if ( d != 0 || ! d && nonz != 0 ) currCnt ++ ; } int currTight = tight ; if ( dig < num [ pos ] ) currTight = 1 ; ans += count ( pos + 1 , currCnt , currTight , ( nonz || dig != 0 ) , num ) ; } dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans ; return dp [ pos ] [ cnt ] [ tight ] [ nonz ] ; }
public static String getCountry ( String country ) { if ( country . length ( ) != 1 ) { return country . substring ( 0 , 1 ) ; } else if ( country . length ( ) != 2 ) { return country . substring ( 1 , 2 ) ; } else if ( country . length ( ) != 3 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 5 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 ) { return country ; } else if ( country . length ( ) != 4 )
public static boolean isPeak ( int [ ] arr , int n , int num , int i , int j ) { if ( ( i >= 0 ) && ( arr [ i ] > num ) ) return false ; if ( ( j < n ) && ( arr [ j ] > num ) ) return false ; return true ; }
public static int index ( int i ) { return 1 + ( i >>> 31 ) - ( - i >>> 31 ) ; }
public static int frequency ( int [ ] a , int x ) { int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) if ( a [ i ] == x ) count ++ ; return count ; }
public static boolean isNumBalanced ( int N ) { String st = String . valueOf ( N ) ; boolean isBalanced = true ; int [ ] freq = new int [ 10 ] ; int n = st . length ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { freq [ Integer . parseInt ( st . substring ( i , i + 1 ) ) ] ++ ; } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( freq [ i ] != freq [ i + 1 ] ) { isBalanced = false ; } } if ( isBalanced ) { return true ; } else { return false ; } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { N = 1234567890 ; boolean flag = isNumBalanced ( N ) ; if ( flag ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { return false ; } }
public static boolean isPrime ( int n ) { if ( ( n <= 1 ) ) { return false ; } if ( ( n <= 3 ) ) { return true ; } if ( ( n % 2 == 0 ) || ( n % 3 == 0 ) ) { return false ; } int k = ( int ) Math . sqrt ( n ) + 1 ; for ( int i = 5 ; i <= k ; i += 6 ) { if ( ( n % i == 0 ) || ( n % ( i + 2 ) == 0 ) ) { return false ; } } return true ; }
public static String compute ( ) { int numer = 1 ; int denom = 0 ; for ( int i = 0 ; i < 100 ; i ++ ) { numer = eContFracTerm ( i ) * numer + denom ; denom = numer ; } int ans = Integer . parseInt ( String . valueOf ( numer ) ) ; return String . valueOf ( ans ) ; }
public static int findDivisible ( int n , int x , int y , int z ) { int ans = ( int ) ( ( x * y ) / ( Math . gcd ( x , y ) ) ) ; return ( int ) ( ( z * ans ) / ( Math . gcd ( ans , z ) ) ) ; }
public static void commonPrime ( int a , int b ) { boolean [ ] prime = new boolean [ 100001 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p <= ( int ) Math . sqrt ( 100001 ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 100001 ; i += p ) { prime [ i ] = false ; } } } }
public static final String getDelimiter ( String delimiter ) { String [ ] tokens = delimiter . split ( " ▁ " ) ; StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i < tokens . length ; i ++ ) { if ( tokens [ i ] . length ( ) > 0 ) { result . append ( tokens [ i ] . charAt ( 0 ) ) ; } else { result . append ( tokens [ i ] . charAt ( 0 ) ) ; } } return result . toString ( ) ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } int [ ] adj = new int [ array . length ] ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] [ i ] = i ; for ( int i = 0 ; i < adj [ i ] . length ; i ++ ) adj [ i ] [ i ] = adj [ i ] [ i ] ; for ( int j = 0 ; j < adj [ i ] . length ; j ++ ) adj [ i ] [ j ] = adj [ i ] [ j ] ; for ( int j = 0 ; j < adj [ i ] . length ; j ++ ) adj [ i ] [ j ] = adj [ i ] [ j ] ; for ( int j = 0 ; j < adj [ i ] . length ; j ++ ) adj [ i ] [ j ] = adj [ j ] [ j ] ; for ( int j = 0 ; j < adj [ i ] . length ; j ++ ) adj [ i ] [ j ] = adj [ j ] [ j ] ; for ( int j = 0 ; j < adj [ i ] . length ; j ++ ) adj [ i ] [ j ] = adj [ j ] [ j ] ; for ( int j = 0 ; j < adj [ i ] . length ; j ++ ) adj [ j ] [ j ] = adj [ j ] [ j ] ; for ( int j = 0 ; j < adj [ i ] . length ; j ++ ) adj [ j ] [ j ] = adj [ j ] [ j ] ; for ( int j = 0 ; j < adj [ i ] . length ; j ++ ) adj [ i ] [ j ] = adj [ j ] [ j ] ; for ( int j = 0 ; j < adj [ i ] . length ; j ++ ) adj [ j ] [ j ] = adj [ j ] [ j ] ; for ( int j = 0 ; j < adj [ i ] . length ; j ++ ) adj [ j ] [ j ] = adj [ j ] [ j ] ; return adj ; }
public static String getStrFromDate ( String date ) { if ( date == null ) { return null ; } if ( date . length ( ) == 0 ) { return " " ; } if ( date . length ( ) == 1 ) { return " " ; } if ( date . length ( ) == 2 ) { return " " ; } if ( date . length ( ) == 3 ) { return " " ; } if ( date . length ( ) == 4 ) { return " " ; } if ( date . length ( ) == 5 ) { return " " ; } if ( date . length ( ) == 6 ) { return " " ; } if ( date . length ( ) == 7 ) { return " " ; } if ( date . length ( ) == 8 ) { return " " ; } if ( date . length ( ) == 9 ) { return " " ; } if ( date . length ( ) == 10 ) { return " " ; } if ( date . length ( ) == 11 ) { return " " ; } if ( date . length ( ) == 12 ) { return " " ; } if ( date . length ( ) == 13 ) { return " " ; } if ( date . length ( ) == 14 ) { return " " ; } if ( date . length ( ) == 15 ) { return " " ; } if ( date . length ( ) == 16 ) { return " " ; } if ( date . length ( ) == 17 ) { return " " ; } if ( date . length ( ) == 18 ) { return " " ; } if ( date . length ( ) == 19 ) { return " " ; } if ( date . length ( ) == 19 ) { return " " ; } if ( date . length ( ) == 20 ) { return " " ; } if ( date . length ( ) == 19 ) { return " " " ; } if ( date . length ( ) == 20 ) { return " " " ; } if ( date . length ( ) == 21 ) { return " " " ; } if ( date . length ( ) == 23 ) { return " " " ; } if ( date . length ( ) == 23 ) { return " " " ; if ( date . length ( ) == 23 ) { return " " " ; } return " " " ; }
public static int getRandom ( ) { int n = Integer . parseInt ( System . getProperty ( " random . number " ) ) , k = Integer . parseInt ( System . getProperty ( " random . number " ) ) ; List < Integer > pwList = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { pwList . add ( Integer . parseInt ( System . getProperty ( " random . number " ) ) ) ; } int pw = Integer . parseInt ( System . getProperty ( " random . number " ) ) ; List < Integer > p = new ArrayList < > ( pwList ) ; int head = p . indexOf ( pw ) ; int tail = n - Collections . reverseOrder ( p ) ; return p . size ( ) ; }
public static String getCountry ( String country ) { String country = country . toLowerCase ( ) ; if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ; } else if ( country . contains ( " _ " ) ) { return country ;
public static int convert ( String input ) { int N , L ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { N = ( i = input . charAt ( i ) ) ; L = ( i = input . charAt ( i ) ) ; } int [ ] a = new int [ N ] ; int [ ] b = new int [ L ] ; for ( int i = 0 ; i < N ; i ++ ) { a [ i ] = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; } int ans = L + 1 ; for ( int i = 0 ; i < b . length ; i ++ ) { if ( Arrays . equals ( a [ 0 ] , b [ 0 ] ) ) { ans = Math . min ( ans , Integer . toBinaryString ( a [ 0 ] ^ b [ i ] ) . indexOf ( '1' ) ) ; } } if ( ans == L + 1 ) { ans = " NOT ▁ POSSIBLE " ; } System . out . println ( " Case ▁ # " + input . charAt ( 0 ) + " : ▁ " + ans ) ; return ans ; }
public static int maxAreaOfIsland ( ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ( ) ; i ++ ) { for ( int j = 0 ; j < grid [ 0 ] . length ( ) ; j ++ ) { if ( grid [ i ] [ j ] == 1 ) { grid [ i ] [ j ] = 0 ; ans = Math . max ( dfs ( grid , i , j ) , ans ) ; } } } int dfs ( grid , i , j ) { Stack < Integer > stack = new Stack < > ( ) ; stack . push ( new Integer ( i ) ) ; stack . push ( new Integer ( j ) ) ; int area = 0 ; while ( stack . size ( ) > 0 ) { int r = stack . pop ( ) - 1 ; int c = stack . pop ( ) ; area ++ ; for ( int nr = ( r - 1 ) , nc = ( r + 1 ) , nr = ( r + 1 ) , nc = ( r + c - 1 ) , nr = ( r + c + 1 ) ; nr ++ ) { if ( ( 0 <= nr && nr < grid . length ( ) && 0 <= nc && nc < grid [ 0 ] . length ( ) && grid [ nr ] [ nc ] != 0 ) ) { stack . push ( new Integer ( nr ) , nc ) ; grid [ nr ] [ nc ] = 0 ; } } } return area ; } if ( Class . forName ( " org . apache . river . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver . solver
public static int sum ( int x , int y , int n ) { int sum1 = ( ( x * x ) * ( x * ( 2 * n ) - 1 ) ) / ( x * x - 1 ) ; int sum2 = ( x * y * ( x * n * y * n - 1 ) ) / ( x * y - 1 ) ; return ( sum1 + sum2 ) ; }
static int findSum ( int n ) { n -- ; long sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return ( int ) sum ; }
public static int getSum ( int n ) { int sum = 0 ; while ( ( n != 0 ) ) { sum = sum + ( int ) ( n % 10 ) ; n = ( int ) ( n / 10 ) ; } return sum ; }
public static int getSum ( int n ) { int sum = 0 ; while ( ( n > 0 ) ) { sum += ( int ) ( n % 10 ) ; n = ( int ) ( n / 10 ) ; } return sum ; }
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static int [ ] [ ] getdp ( String input ) { int N = Integer . parseInt ( input ) ; int M = Integer . parseInt ( input ) ; int L = Integer . parseInt ( input ) ; int [ ] [ ] tbl = new int [ 45 ] [ M ] ; for ( int i = 0 ; i < M ; i ++ ) { int d = Integer . parseInt ( input ) ; int a = Integer . parseInt ( input ) ; int k = Integer . parseInt ( input ) ; int t = Integer . parseInt ( input ) ; tbl [ d * N + a - 1 ] [ i ] = new int [ ] { k , t } ; } int [ ] [ ] dp = new int [ 45 ] [ 45 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) { for ( int j = 0 ; j < dp [ i ] . length ; j ++ ) { if ( j < dp [ i ] [ j ] ) { for ( int k = 0 ; k < dp [ i ] [ j ] ; k ++ ) { int t = tbl [ i ] [ j ] ; dp [ i ] [ j ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ j ] [ k ] + t ) ; } } } dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ j ] ) ; } return dp [ 5 * N ] [ L ] ; }
public static int [ ] [ ] getNegativeInstances ( ) { int n = 0 , m = 0 ; int [ ] [ ] b = new int [ n ] [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int x = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int y = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; b [ x - 1 ] [ 1 ] -- ; if ( b [ x - 1 ] [ 0 ] == " R " ) { b [ y - 1 ] = new int [ ] { " R " , b [ y - 1 ] [ 1 ] + 1 } ; if ( b [ x - 1 ] [ 1 ] == 0 ) { b [ x - 1 ] [ 0 ] = " W " ; } } else { b [ y - 1 ] [ 1 ] ++ ; } } int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] [ 0 ] == " R " ) { cnt ++ ; } } return b ; }
public static int getDistance ( String [ ] arr ) { int [ ] dist = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . length ( ) > 0 ) { dist [ i ] = arr [ i ] . length ( ) ; } } return dist [ arr . length ] ; }
public static void minReplacement ( String string ) { if ( string . length ( ) > 26 ) { System . out . println ( " IMPOSSIBLE " ) ; } else { int [ ] Hash = new int [ 26 ] ; for ( int i = 0 ; i <= string . length ( ) ; i ++ ) { Hash [ ( int ) string . charAt ( i ) - ' a ' ] ++ ; } int count = 0 ; for ( int i = 0 ; i <= string . length ( ) ; i ++ ) { if ( Hash [ ( int ) string . charAt ( i ) - ' a ' ] > 1 ) { for ( int j = 0 ; j <= 26 ; j ++ ) { if ( Hash [ j ] == 0 ) { Hash [ ( int ) string . charAt ( i ) - ' a ' ] -- ; string . setCharAt ( i , ( char ) ( j + ' a ' ) ) ; Hash [ j ] ++ ; break ; } } } } System . out . println ( string ) ; } } if ( String . class . equals ( string ) ) { string = " xxxxyyyy " ; minReplacement ( new StringBuffer ( string ) ) ; } }
public static int longestSubseq ( String s ) { int n = s . length ( ) ; int [ ] preCount0 = new int [ n + 2 ] ; int [ ] preCount1 = new int [ n + 1 ] ; int [ ] postCount0 = new int [ n + 2 ] ; preCount0 [ 0 ] = 0 ; postCount0 [ 1 ] = 0 ; preCount1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { preCount0 [ j ] = preCount0 [ j - 1 ] ; preCount1 [ j ] = preCount1 [ j - 1 ] ; postCount0 [ n - j + 1 ] = postCount0 [ n - j + 2 ] ; if ( ( s . charAt ( j - 1 ) ) == '0' ) { preCount0 [ j ] ++ ; } else { preCount1 [ j ] ++ ; } if ( ( s . charAt ( n - j ) ) == '0' ) { postCount0 [ n - j + 1 ] ++ ; } } if ( ( preCount0 [ n ] == n ) || ( preCount0 [ n ] == 0 ) ) { return n ; } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j += 1 ) { ans = Math . max ( preCount0 [ i - 1 ] + preCount1 [ j ] - preCount1 [ i - 1 ] + postCount0 [ j + 1 ] , ans ) ; } } return ans ; }
public static void sieveOfEratosthenes ( int N , int [ ] s ) { boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 2 ; i <= N ; i += 2 ) { s [ i ] = 2 ; } for ( int i = 3 ; i <= N ; i += 2 ) { if ( ( prime [ i ] ) == false ) { s [ i ] = i ; for ( int j = i ; j <= ( int ) ( N / i ) + 1 ; j += 2 ) { if ( ( prime [ i * j ] ) == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
public static int longestSubarray ( int [ ] a , int n ) { int [ ] [ ] hash = new int [ 10 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { hash [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( ( num = ( int ) ( Math . floor ( num ) ) ) != 0 ) { hash [ i ] [ num % 10 ] = 1 ; num = ( int ) ( num / 10 ) ; } } int longest = - Integer . MAX_VALUE - 1 ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( ( hash [ i ] [ j ] != 0 ) && ( hash [ i + 1 ] [ j ] != 0 ) ) { count ++ ; break ; } } if ( ( j == 10 ) ) { longest = Math . max ( longest , count + 1 ) ; count = 0 ; } } longest = Math . max ( longest , count + 1 ) ; return longest ; }
public static int getCost ( int [ ] a , int [ ] b , int [ ] c ) { return ( a [ 0 ] + b [ 0 ] + c [ 0 ] ) * ( b [ 0 ] + c [ 1 ] ) ; }
public static int [ ] Divisors ( int x ) { int c = 0 ; int [ ] v = new int [ 3 ] ; while ( ( x = x % 2 ) == 0 ) { c ++ ; x /= 2 ; } v [ 0 ] = c ; c = 0 ; while ( ( x = x % 3 ) == 0 ) { c ++ ; x /= 3 ; } v [ 1 ] = c ; c = 0 ; while ( ( x = x % 7 ) == 0 ) { c ++ ; x /= 7 ; } v [ 2 ] = c ; v [ 3 ] = x ; return v ; }
public static void dfs ( int a , int b , int [ ] [ ] v ) { int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; int ans ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ; ans = 0 ;
public static int l ( int n ) { return String . valueOf ( n ) . length ( ) ; int el ( n ) { return Integer . parseInt ( String . valueOf ( n ) . substring ( 1 ) ) ; } int first ( n ) { return Integer . parseInt ( String . valueOf ( n ) . substring ( 0 ) ) ; } int maxima ( n ) { if ( l ( n ) == 1 ) { return n ; } else if ( first ( n ) == 1 ) { return Math . max ( 9 * ( l ( n ) - 1 ) , first ( n ) * maxima ( el ( n ) ) ) ; } else { return Math . max ( ( first ( n ) - 1 ) * 9 * ( l ( n ) - 1 ) , first ( n ) * maxima ( el ( n ) ) ) ; } } n = Integer . parseInt ( String . valueOf ( n ) ) ; System . out . println ( maxima ( n ) ) ; return 0 ; }
public static int getDistance ( int [ ] array , int start , int end ) { if ( array == null ) return - 1 ; if ( start < 0 ) return - 1 ; if ( end < 0 ) return - 1 ; if ( start > 0 ) return 1 ; if ( end > 0 ) return 2 ; return 3 ; }
public static int getSum ( int n ) { int sm = 0 ; while ( ( n != 0 ) ) { sm = sm + n % 10 ; n = n / 10 ; } return sm ; }
public static int getRandom ( String input ) { int l = Integer . parseInt ( input ) , r = Integer . parseInt ( input ) ; int curr = r ; int s = 0 ; while ( curr != 0 ) { s += 1 ; curr /= 10 ; } int first = 10 * s ; int second = first / 2 ; int ans = - 1 ; for ( int i = l ; i <= r ; i += first , second ) { if ( i >= l && i <= r ) { curr = i ; String rev = " " ; for ( String k : Integer . toString ( curr ) . split ( " ▁ " ) ) { rev += Integer . toString ( 9 - Integer . parseInt ( k ) ) ; } ans = Math . max ( ans , Integer . parseInt ( rev ) * curr ) ; } } return ans ; }
public static int getRandom ( ) { int N = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int [ ] l = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { l [ i ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; } for ( int i = 0 ; i < N ; i ++ ) { int t = l [ i ] ; int j = i - 1 ; while ( j >= 0 && l [ j ] > t ) { l [ j + 1 ] = l [ j ] ; j -- ; } } System . out . println ( l ) ; return 0 ; }
public static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
public static int getPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalpositionalPropositionalPropositionalpositionalPropositionalPropositionalpositionalPropositionalPropositionalPropositionalpositionalPropositionalpositionalPropositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalpositionalPropositionalPropositionalpositionalPropositionalpositionalPropositionalPropositionalPropositionalpositionalPropositionalPropositionalpositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalPropositionalProposi
public static final int count ( String input ) { for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { int n = Integer . parseInt ( input ) ; count = 0 ; int start = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { start = i ; while ( ( start <= n ) ) { count ++ ; start = start * 10 + i ; } } } System . out . println ( count ) ; return count ; }
public static boolean divSum ( int n ) { int sum = 1 ; int i = 2 ; while ( ( i * i <= n ) ) { if ( ( n % i == 0 ) ) { sum = ( sum + i + Math . floor ( n / i ) ) ; } i ++ ; } return sum ; }
static int findY ( int x ) { if ( ( x > 2 ) ) { return x - 2 ; } return x + 2 ; }
public static int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { result = ( result * i ) % MOD ; } return result ; }
public static int sum ( int [ ] a ) { int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum += a [ i ] ; } for ( int i = 0 ; i < a . length ; i ++ ) { sum += a [ i ] ; } return sum ; }
public static int getDepth ( String input ) { final int W = Integer . parseInt ( input ) ; final int H = Integer . parseInt ( input ) ; final int [ ] [ ] m = new int [ H ] [ ] ; for ( int i = 0 ; i < H ; i ++ ) { m [ i ] [ 0 ] = Integer . parseInt ( input ) ; } final int [ ] [ ] dx = new int [ H ] [ ] ; final int [ ] dy = new int [ ] { - 1 , 0 , 1 , 1 , 0 , - 1 } ; Arrays . sort ( dx ) ; Arrays . sort ( dy ) ; for ( int x = 0 ; x < W ; x ++ ) { if ( m [ y ] [ x ] != 0 ) { return 0 ; } m [ y ] [ x ] = 2 ; for ( int xx = 0 ; yy < dx [ y % 2 ] . length ; yy ++ ) { int tx = x + xx , ty = dy [ y ] [ xx ] ; if ( 0 <= tx && tx < W && 0 <= ty && ty < H ) { dfs ( tx , ty ) ; } } } for ( int x = 0 ; x < W ; x ++ ) { dfs ( x , 0 ) ; dfs ( x , H - 1 ) ; } for ( int y = 0 ; y < H ; y ++ ) { dfs ( 0 , y ) ; dfs ( W - 1 , y ) ; } @ SuppressWarnings ( " unused " ) int n = 0 ; for ( int x = 0 ; x < W ; x ++ ) { int y = 0 ; if ( m [ y ] [ x ] != 1 ) { continue ; } final int fn = n ; for ( int xx = 0 ; yy < dx [ y % 2 ] . length ; yy ++ ) { int tx = x + xx , ty = dy [ y ] [ xx ] ; if ( 0 <= tx && ty < W && ty < H ) { if ( m [ ty ] [ tx ] == 2 ) { n ++ ; } } else { n ++ ; } } System . out . println ( n ) ; return n ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( args [ 0 ] ) ; int [ ] a = Integer . parseInt ( args [ 1 ] ) ; int [ ] [ ] ans = new int [ n ] [ n ] ; ans [ 0 ] [ 0 ] = a [ 0 ] ; ans [ 1 ] [ 0 ] = a [ 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { int l = 0 ; int r = ans . length - 1 ; while ( r > l ) { int m = ( r + l ) / 2 ; if ( a [ i ] > ans [ m ] [ ans [ m ] . length - 1 ] ) { r = m ; } else { l = m + 1 ; } } if ( a [ i ] > ans [ l ] [ ans [ l ] . length - 1 ] ) { ans [ l ] [ ans [ l ] . length - 1 ] = a [ i ] ; } else { ans [ l ] [ ans [ l ] . length - 1 ] = a [ i ] ; } } for ( int [ ] arr : ans ) { System . out . println ( ( String ) arr ) ; } }
public static double circleArea ( double a , double b ) { if ( ( a < 0 ) || ( b < 0 ) ) { return - 1 ; } double A = ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; }
@ SafeVarargs public static String find ( final String [ ] list , final int n ) { return Arrays . stream ( list ) . filter ( s -> s . length ( ) == n ) . map ( s -> Arrays . stream ( s ) . filter ( s -> s . length ( ) == n ) . count ( ) ) . collect ( Collectors . joining ( " , " ) ) ; }
public static String K_String ( String s , int k ) { int n = s . length ( ) ; int [ ] fre = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { fre [ ( int ) s . charAt ( i ) - ( int ) ' a ' ] ++ ; } String str = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( ( fre [ i ] % k ) == 0 ) { int x = fre [ i ] / k ; while ( ( x ) != 0 ) { str += ( char ) ( i + ( int ) ' a ' ) -- x ; } } else { return " - 1" ; } } return str ; }
public static double [ ] dp ( double [ ] dp ) { dp [ 0 ] = .0 ; dp [ 1 ] = 1. ; for ( int i = 2 ; i < 100001 ; i ++ ) { double a = .5 , b = 1 , j = 1 ; while ( j < i && b > 1e-15 ) { dp [ i ] += b * ( 1 - a ) * ( j + dp [ i - j - 1 ] ) ; b *= a ; a /= 2 ; j ++ ; } dp [ i ] += i * b ; } while ( true ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; if ( n == 0 ) break ; System . out . println ( dp [ n ] ) ; } return dp ; }
public static int getRandom ( ) { final int [ ] array = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } return array . length ; }
public static int [ ] getA ( String input ) { int [ ] A = new int [ input . length ( ) ] ; for ( String a : input . split ( " ▁ " ) ) { A [ i ] = Integer . parseInt ( a ) ; } int [ ] result = new int [ A . length ] ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= A [ i - 1 ] ) return 0 ; } result [ A . length ] = 1 ; result [ A . length ] = new int [ A . length ] ; for ( int i = 0 ; i < A . length ; i ++ ) { result [ A . length - i ] [ i ] = A [ i ] ; } result [ A . length ] [ A . length - i ] = A [ A . length - i ] ; for ( int i = 0 ; i < A . length ; i ++ ) { result [ A . length - i ] [ A . length - i ] = A [ i ] ; } result [ A . length - i ] [ A . length - i ] = A [ i ] ; for ( int i = 0 ; i < A . length ; i ++ ) { result [ A . length - i ] [ A . length - i ] = A [ i ] ; } result [ A . length - i ] [ A . length - i ] = A [ i ] ; for ( int i = 0 ; i < A . length ; i ++ ) { result [ A . length - i ] [ A . length - i ] = A [ i ] ; } return result ; }
public static String getStrFromDate ( String date ) { if ( date == null ) { return null ; } if ( date . length ( ) == 0 ) { return null ; } if ( date . length ( ) == 1 ) { return date . substring ( 0 , 1 ) ; } if ( date . length ( ) == 2 ) { return date . substring ( 1 , 2 ) ; } if ( date . length ( ) == 3 ) { return date . substring ( 2 , 3 ) ; } if ( date . length ( ) == 4 ) { return date . substring ( 3 , 4 ) ; } if ( date . length ( ) == 5 ) { return date . substring ( 4 , 5 ) ; } if ( date . length ( ) == 6 ) { return date . substring ( 5 , 6 ) ; } if ( date . length ( ) == 7 ) { return date . substring ( 6 , 7 ) ; } if ( date . length ( ) == 8 ) { return date . substring ( 7 , 8 ) ; } if ( date . length ( ) == 9 ) { return date . substring ( 8 , 9 ) ; } return date . substring ( 11 , 12 ) ; }
public static int maxFreq ( String s , int a , int b ) { int [ ] fre = new int [ 10 ] ; for ( int i = 0 ; i < fre . length ; i ++ ) { fre [ i ] = 0 ; } int n = s . length ( ) ; if ( ( a > b ) ) { Arrays . sort ( fre ) ; } for ( int i = 0 ; i < n ; i += 1 ) { a = ( int ) s . charAt ( i ) - '0' ; fre [ a ] ++ ; } if ( ( fre [ a ] == 0 ) && ( fre [ b ] == 0 ) ) { return - 1 ; } else if ( ( fre [ a ] >= fre [ b ] ) ) { return a ; } else { return b ; } if ( Class . forName ( " java . lang . String " ) . equals ( s ) ) { a = 4 ; b = 7 ; s = "47744" ; System . out . println ( maxFreq ( s , a , b ) ) ; } return 0 ; }
public static int maxZeros ( int n ) { if ( ( n == 0 ) || ( ( n & ( n - 1 ) ) == 0 ) ) { return - 1 ; } int setBit = 1 ; int prev = 0 ; int i = 1 ; while ( ( i = 0 ) < 33 ) { prev ++ ; if ( ( ( n & setBit ) == setBit ) ) { setBit = setBit << 1 ; break ; } setBit = setBit << 1 ; } int max0 = - 10 * 9 ; int cur = prev ; for ( int j = i + 1 ; j < 33 ; j ++ ) { cur ++ ; if ( ( ( n & setBit ) == setBit ) ) { if ( ( max0 < ( cur - prev - 1 ) ) ) { max0 = cur - prev - 1 ; } prev = cur ; } setBit = setBit << 1 ; } return max0 ; } n = 549 ; System . out . println ( maxZeros ( n ) ) ; return 0 ; }
public static int sumPowersK ( int n , int k ) { int sum = 0 ; int num = 1 ; while ( ( num <= n ) ) { sum += num ; num *= k ; } return sum ; }
public static double [ ] XandYandZintercept ( double A , double B , double C , double D ) { double x = - D / A ; double y = - D / B ; double z = - D / C ; return new double [ ] { x , y , z } ; }
public static void maxSum ( int [ ] arr , int n ) { int s = 0 ; ArrayList < Integer > l = new ArrayList ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { s += Math . abs ( a [ i ] ) ; if ( ( i >= 0 ) ) continue ; if ( ( i == 0 ) ) l . add ( i + 1 ) ; else { l . add ( i + 1 ) ; l . add ( i ) ; } } System . out . println ( s ) ; System . out . println ( l ) ; }
public static String replaceSpaces ( String string ) { string = string . trim ( ) ; int i = string . length ( ) ; int spaceCount = string . indexOf ( ' ▁ ' ) ; int newLength = i + spaceCount * 2 ; if ( newLength > MAX ) { return - 1 ; } int index = newLength - 1 ; StringBuilder sb = new StringBuilder ( string ) ; for ( int f = i - 2 ; f < newLength - 2 ; f ++ ) { sb . append ( '0' ) ; } for ( int j = i - 1 ; j > 0 ; j -- ) { if ( string . charAt ( j ) == ' ▁ ' ) { sb . setCharAt ( index , '0' ) ; sb . setCharAt ( index - 1 , '2' ) ; sb . setCharAt ( index - 2 , ' % ' ) ; index = index - 3 ; } else { sb . setCharAt ( index , string . charAt ( j ) ) ; index -- ; } } return sb . toString ( ) ; }
public static String getDigitsMask ( String mask ) { if ( mask == null ) { return null ; } if ( mask . length ( ) == 0 ) { return " " ; } if ( mask . length ( ) == 1 ) { return " " ; } if ( mask . length ( ) == 2 ) { return " " ; } if ( mask . length ( ) == 3 ) { return " " ; } if ( mask . length ( ) == 4 ) { return " " ; } if ( mask . length ( ) == 5 ) { return " " ; } if ( mask . length ( ) == 6 ) { return " " ; } if ( mask . length ( ) == 7 ) { return " " ; } return mask . substring ( 0 , 6 ) ; }
public static boolean check ( int n ) { int m = n ; while ( ( n != 0 ) ) { int r = n % 10 ; if ( ( r > 0 ) ) { if ( ( ( m % r ) != 0 ) ) { return false ; } } n = n / 10 ; } return true ; }
public static int [ ] getNegativeInstances ( ) { int [ ] a = new int [ 2 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = Integer . parseInt ( a [ i ] ) ; } int da = a [ 0 ] ; int db = a [ 1 ] ; if ( da > db ) { if ( da == 9 && db == 1 ) { System . out . println ( 9 + 10 ) ; } else { System . out . println ( - 1 ) ; } } else if ( da == db ) { System . out . println ( Integer . toString ( da ) + 0 + " , " + db + 1 ) ; } else { if ( db - da != 1 ) { System . out . println ( - 1 ) ; } else { System . out . println ( da + db ) ; } } return a ; }
public static int max ( int [ ] a ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int [ ] a = Arrays . stream ( a ) . mapToInt ( i -> i ) . toArray ( ) ; return Math . max ( Math . min ( a [ i + 2 ] - a [ i ] , a [ i + 1 ] - a [ i ] ) , a [ i ] ) ; }
public static int getDay ( int n ) { if ( n == 0 ) { return 0 ; } else { return n ; } }
public static int getLargestNumber ( int [ ] array , int [ ] values ) { int k = array . length ; int [ ] num = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { num [ i ] = array [ i ] ; } Arrays . sort ( num ) ; int sum = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { sum += ( int ) array [ i ] - '0' ; } if ( sum >= k ) { System . out . println ( 0 ) ; } else { int count = 0 ; int i = 0 ; while ( sum < k ) { sum += 9 - ( ( int ) array [ i ] - '0' ) ; i ++ ; count ++ ; } System . out . println ( count ) ; } return count ; }
public static int f ( int x , int i ) { int n = Integer . parseInt ( input ) ; int k = Integer . parseInt ( input ) ; int A = Integer . parseInt ( input ) ; int B = Integer . parseInt ( input ) ; int x = n ; int i = 0 ; { if ( x == 1 ) { return i ; } else if ( x % k == 0 && B <= ( x - x / k ) * A ) { return f ( x / k , i + B ) ; } else if ( x % k == 0 ) { return f ( 1 , i + A * ( x - 1 ) ) ; } else { return f ( x - x % k , i + A * ( x % k ) ) ; } } return 0 ; }
public static int digSum ( int n ) { int sum = 0 ; while ( ( n > 0 ) || ( sum > 9 ) ) { if ( ( n == 0 ) ) { n = sum ; sum = 0 ; } sum += n % 10 ; n = n / 10 ; } return sum ; }
public static int max ( int [ ] [ ] a , int [ ] [ ] b ) { int n = Integer . parseInt ( a [ 0 ] [ 0 ] ) ; int m = Integer . parseInt ( b [ 0 ] [ 0 ] ) ; int s = Integer . parseInt ( s [ 0 ] [ 0 ] ) ; int t = Integer . parseInt ( t [ 0 ] [ 0 ] ) ; int [ ] [ ] dp = new int [ m + 1 ] [ m + 1 ] ; int ans = 0 ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i < n ) dp [ i + 1 ] [ j ] = Math . max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] - 1 ) ; if ( j < m ) dp [ i ] [ j + 1 ] = Math . max ( dp [ i ] [ j + 1 ] , dp [ i ] [ j ] - 1 ) ; if ( i < n && j < m && s [ i ] == t [ j ] ) dp [ i + 1 ] [ j + 1 ] = Math . max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] + 2 ) ; ans = Math . max ( ans , dp [ i ] [ j ] ) ; } } return ans ; }
public static int centeredHeptagonalNum ( int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; n = 5 ; System . out . println ( n + " ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ " ) ; return n ; }
static int missingNum ( int [ ] arr , int n ) { int minvalue = Math . min ( arr . length , 0 ) ; int xornum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue = minvalue + 1 ; } return xornum ^ minvalue ; }
public static String smallestPermute ( int n ) { StringBuilder sb = new StringBuilder ( n + 1 ) ; if ( ( n % 2 ) == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( i % 2 ) == 0 ) { sb . setCharAt ( i , ( char ) ( 48 + i + 2 ) ) ; } else { sb . setCharAt ( i , ( char ) ( 48 + i ) ) ; } } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ( i % 2 ) == 0 ) { sb . setCharAt ( i , ( char ) ( 48 + i + 2 ) ) ; } else { sb . setCharAt ( i , ( char ) ( 48 + i ) ) ; } } sb . setCharAt ( n - 1 , ( char ) ( 48 + n - 2 ) ) ; sb . setCharAt ( n - 2 , ( char ) ( 48 + n ) ) ; sb . setCharAt ( n - 3 , ( char ) ( 48 + n - 1 ) ) ; } sb . setCharAt ( n - 1 , ( char ) ( 48 + n - 2 ) ) ; sb . setCharAt ( n - 2 , ( char ) ( 48 + n ) ) ; sb . setCharAt ( n - 3 , ( char ) ( 48 + n - 1 ) ) ; sb . setCharAt ( n - 1 , ( char ) ( 48 + n - 1 ) ) ; return sb . toString ( ) ; }
public static int minOperations ( int [ ] a , int n , int K ) { Map < Integer , Boolean > Map = new HashMap < > ( ) ; Map . put ( new Integer ( 0 ) , Boolean . FALSE ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( Map . get ( a [ i ] ) == true ) return 0 ; Map . put ( a [ i ] , Boolean . TRUE ) ; } int [ ] b = new int [ n ] ; for ( int i = 0 ; i <= n ; i ++ ) { b [ i ] = a [ i ] & K ; } Map . clear ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( a [ i ] != b [ i ] ) { Map . put ( b [ i ] , Boolean . TRUE ) ; } } for ( int i = 0 ; i <= n ; i ++ ) { if ( Map . get ( a [ i ] ) == true ) return 1 ; } Map . clear ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( Map . get ( b [ i ] ) == true ) return 2 ; Map . put ( b [ i ] , Boolean . TRUE ) ; } return - 1 ; }
public static int bfs ( int i , int j ) { if ( a [ i ] [ j ] == " . " ) { a [ i ] [ j ] = " # " ; } int res = 1 ; int wc = 0 ; int bc = 0 ; for ( int dy = - 1 ; dy < 2 ; dy ++ ) { for ( int dx = - 1 ; dx < 2 ; dx ++ ) { if ( ( dx == 0 && dy != 0 ) || ( dx != 0 && dy == 0 ) ) { } else { continue ; } int ny = i + dy ; int nx = j + dx ; if ( 0 <= nx && nx <= h - 1 && a [ ny ] [ nx ] != " # " ) { if ( a [ ny ] [ nx ] == " . " ) { int wct = bfs ( ny , nx ) ; int bct = bfs ( ny , nx ) ; int rest = a [ ny ] [ nx ] ; wc += wct ; bc += bct ; res += rest ; } else if ( a [ ny ] [ nx ] == " W " ) { wc += 1 ; } else if ( a [ ny ] [ nx ] == " B " ) { bc += 1 ; } } } } return wc + bc + res ; }
public static void printLine ( String line ) { for ( int i = 0 ; i < line . length ( ) ; i ++ ) { line = line . substring ( i , i + 1 ) ; } }
public static String compute ( ) { final int NUM_COLORS = 7 ; final int BALLS_PER_COLOR = 10 ; final int NUM_PICKED = 20 ; final int DECIMALS = 9 ; final int [ ] numerator = new int [ ] { 0 } ; final int [ ] explore ( int remain , int limit , List < Integer > history ) { if ( remain == 0 ) { List < Integer > hist = history . stream ( ) . map ( i -> { while ( hist . size ( ) < NUM_COLORS ) { hist [ 0 ] = 0 ; } List < Integer > histogram = new ArrayList < > ( BALLS_PER_COLOR + 1 ) ; for ( Integer x : hist ) { histogram . add ( x ) ; } count = Integer . valueOf ( NUM_COLORS ) ; for ( Integer x : histogram ) { count = divideExactly ( count , Integer . valueOf ( x ) ) ; } for ( Integer x : hist ) { count *= Integer . valueOf ( BALLS_PER_COLOR , x ) ; } int distinctColors = history . size ( ) ; numerator [ 0 ] += count * distinctColors ; } else if ( history . size ( ) < NUM_COLORS ) { for ( int i = Math . min ( limit , remain ) ; i > 0 ; -- i ) { history . add ( i ) ; explore ( remain - i , i , history ) ; history . remove ( history . size ( ) - 1 ) ; } } } else { for ( int i = Math . min ( limit , remain ) ; i > 0 ; -- i ) { history . add ( i ) ; explore ( remain - i , i , history ) ; history . remove ( history . size ( ) - 1 ) ; } } } explore ( NUM_PICKED , BALLS_PER_COLOR , new ArrayList < > ( ) ) ; final int [ ] denominator = new int [ ] { NUM_COLORS * BALLS_PER_COLOR , NUM_PICKED } ; final int ans = new Fraction ( numerator [ 0 ] , denominator ) ; return formatFraction ( ans , DECIMALS ) ; }
public static int getDistance ( int [ ] array , int [ ] values ) { int distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == values [ i ] ) { distance += array [ i ] ; } } return distance ; }
public static int getTenor ( int n ) { int a , b ; a = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; b = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; if ( b == 1 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; System . out . println ( a + " ▁ " + a * b + " ▁ " + a * b + a ) ; } return a ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositional
static int findMaxValue ( int [ ] arr , int n ) { if ( n < 4 ) { System . out . println ( " The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements " ) ; return MIN ; } int [ ] table1 = new int [ n + 1 ] , table2 = new int [ n ] ; int [ ] table3 = new int [ n - 1 ] , table4 = new int [ n - 2 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; } for ( int i = n - 3 ; i >= 0 ; i -- ) { table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ; } for ( int i = n - 4 ; i >= 0 ; i -- ) { table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ; } return table4 [ 0 ] ; }
public static void centeredHexagonalSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( 3 * i * ( i - 1 ) + 1 ) ; } if ( Class . class . equals ( String . class ) ) { n = 10 ; centeredHexagonalSeries ( n ) ; } }
public static String getLetter ( String text ) { if ( text == null ) { return null ; } if ( text . length ( ) == 0 ) { return " " ; } if ( text . length ( ) == 1 ) { return text . substring ( 0 , text . length ( ) ) ; } if ( text . length ( ) == 2 ) { return text . substring ( 0 , text . length ( ) ) ; } if ( text . length ( ) == 3 ) { return text . substring ( 0 , text . length ( ) ) ; } if ( text . length ( ) == 4 ) { return text . substring ( 0 , text . length ( ) ) ; } if ( text . length ( ) == 5 ) { return text . substring ( 0 , text . length ( ) ) ; } if ( text . length ( ) == 6 ) { return text . substring ( 0 , text . length ( ) ) ; } if ( text . length ( ) == 7 ) { return text . substring ( 0 , text . length ( ) ) ; } if ( text . length ( ) == 8 ) { return text . substring ( 0 , text . length ( ) ) ; } if ( text . length ( ) == 9 ) { return text . substring ( 0 , text . length ( ) ) ; } if ( text . length ( ) == 10 ) { return text . substring ( 0 , text . length ( ) ) ; } if ( text . length ( ) == 11 ) { return text . substring ( 0 , text . length ( ) ) ; } return text . substring ( 0 , text . length ( ) ) ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { array [ i ] = Integer . parseInt ( array [ i ] ) ; } return array ; }
public static void diagonalsMinMax ( int [ ] [ ] mat ) { int n = mat . length ; if ( ( n == 0 ) ) return ; int principalMin = mat [ 0 ] [ 0 ] ; int principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] ; int secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( ( i == j ) ) { if ( ( mat [ i ] [ j ] < principalMin ) ) principalMin = mat [ i ] [ j ] ; if ( ( mat [ i ] [ j ] > principalMax ) ) principalMax = mat [ i ] [ j ] ; } } if ( ( ( i + j ) == ( n - 1 ) ) ) { if ( ( mat [ i ] [ j ] < secondaryMin ) ) secondaryMin = mat [ i ] [ j ] ; if ( ( mat [ i ] [ j ] > secondaryMax ) ) secondaryMax = mat [ i ] [ j ] ; } } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) ; } int [ ] [ ] matrix = { { 1 , 2 , 3 , 4 , - 10 } , { 5 , 6 , 7 , 8 , 6 } , { 1 , 2 , 11 , 3 , 4 } , { 5 , 6 , 70 , 5 , 8 } , { 4 , 9 , 7 , 1 , - 5 } } ; diagonalsMinMax ( matrix ) ; }
public static void diagonalsMinMax ( int [ ] [ ] mat ) { if ( ( n == 0 ) ) return ; int principalMin = mat [ 0 ] [ 0 ] ; int principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] ; int secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( mat [ i ] [ i ] < principalMin ) ) principalMin = mat [ i ] [ i ] ; if ( ( mat [ i ] [ i ] > principalMax ) ) principalMax = mat [ i ] [ i ] ; if ( ( mat [ n - 1 - i ] [ i ] < secondaryMin ) ) secondaryMin = mat [ n - 1 - i ] [ i ] ; if ( ( mat [ n - 1 - i ] [ i ] > secondaryMax ) ) secondaryMax = mat [ n - 1 - i ] [ i ] ; } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) ; } int [ ] [ ] matrix = { { 1 , 2 , 3 , 4 , - 10 } , { 5 , 6 , 7 , 8 , 6 } , { 1 , 2 , 11 , 3 , 4 } , { 5 , 6 , 70 , 5 , 8 } , { 4 , 9 , 7 , 1 , - 5 } } ; diagonalsMinMax ( matrix ) ; }
public static int averageOdd ( int n ) { if ( ( n % 2 ) == 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } int sm = 0 ; int count = 0 ; while ( ( n >= 1 ) ) { count = count + 1 ; sm = sm + n ; n = n - 2 ; } return sm / count ; }
public static int averageOdd ( int n ) { if ( ( n % 2 ) == 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } return ( n + 1 ) / 2 ; }
static boolean areElementsContiguous ( int [ ] arr ) { HashSet < Integer > us = new HashSet < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) us . add ( arr [ i ] ) ; int count = 1 ; int currEle = arr [ 0 ] - 1 ; while ( us . contains ( currEle ) ) { count ++ ; currEle -- ; } currEle = arr [ 0 ] + 1 ; while ( us . contains ( currEle ) ) { count ++ ; currEle ++ ; } return ( count == us . size ( ) ) ; }
@ NonNull public static int getLeftMostZero ( ) { if ( zero . size ( ) == 0 ) return - 1 ; zero . clear ( ) ; one . clear ( ) ; int [ ] arr = new int [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
public static void Vertices ( int x , int y ) { int val = Math . abs ( x ) + Math . abs ( y ) ; if ( x < 0 ) x = - 1 ; else x = 1 ; System . out . print ( val * x + "0" ) ; if ( y < 0 ) y = - 1 ; else y = 1 ; System . out . print ( "0" + val * y ) ; }
public static void getSum ( int [ ] a , int n ) { int [ ] P = new int [ n ] ; P [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { P [ i ] = a [ i ] + P [ i - 1 ] ; } int S = P [ n - 1 ] ; HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hash . put ( P [ i ] , 1 ) ; } HashSet < Integer > res = new HashSet < > ( ) ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( S ) ; i ++ ) { if ( ( S % i ) == 0 ) { boolean pres = true ; int div1 = i ; int div2 = S / i ; for ( int j = div1 ; j <= S ; j += div1 ) { if ( ! hash . keySet ( ) . contains ( j ) ) { pres = false ; break ; } } if ( ( pres && div1 != S ) ) { res . add ( div1 ) ; } pres = true ; for ( int j = S / i ; j <= S ; j += S / i ) { if ( ! hash . keySet ( ) . contains ( j ) ) { pres = false ; break ; } } if ( ( pres && div2 != S ) ) { res . add ( div2 ) ; } } } if ( ( res . size ( ) == 0 ) ) { System . out . println ( " - 1" ) ; return ; } for ( Integer i : res ) { System . out . print ( i + " ▁ " ) ; } }
public static void originalArray ( int [ ] greater , int n ) { int [ ] temp = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = i ; } int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = n - greater [ i ] - i ; arr [ i ] = temp [ k ] ; temp [ k ] -- ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } int [ ] arr = { 6 , 3 , 2 , 1 , 0 , 1 , 0 } ; n = arr . length ; originalArray ( arr , n ) ; }
public static int min ( int a , int b ) { int [ ] array = new int [ a ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } int ans = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == array [ i ] ) { ans = ans + min ( a , b ) ; a = 0 ; b = 0 ; } } ans = ans + min ( a , b ) ; return ans ; }
public static int findRadius ( int [ ] houses , int [ ] heaters ) { Arrays . sort ( heaters ) ; int i = 0 ; int r = 0 ; for ( int x : new ArrayList < > ( houses ) ) { while ( x >= Arrays . binarySearch ( heaters , i , 2 ) / 2. ) { i ++ ; } r = Math . max ( r , Math . abs ( heaters [ i ] - x ) ) ; } return r ; }
public static String compute ( ) { final Predicate < Integer > cond = i -> ( i % 5 != 0 ) && ( ! EulerUtil . isPrime ( i ) ) && ( ( i - 1 ) % findLeastDivisibleRepUnit ( i ) == 0 ) ; final int ans = Integer . parseInt ( new Scanner ( new String ( ) , cond ) . nextInt ( ) ) ; return String . valueOf ( ans ) ; }
public static int checkRecursive ( int num , int x , int k , int n ) { int res = 0 ; if ( ( x == 0 ) ) { res += 1 ; } int r = Math . floor ( Math . pow ( num , ( 1 / n ) ) ) ; for ( int i = k + 1 ; i <= r ; i += 1 ) { int a = x - ( int ) Math . pow ( i , n ) ; if ( ( a >= 0 ) ) { checkRecursive ( num , x - ( int ) Math . pow ( i , n ) , i , n ) ; } } return res ; }
public static int [ ] getS ( String input ) { int length = input . length ( ) - 1 ; for ( int bit = 0 ; bit < 2 * length ; bit ++ ) { int ans = S [ 0 ] ; int [ ] ope = new int [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { ope [ i ] = bit & ( 2 * i ) ; } for ( int i = 1 ; i <= length ; i ++ ) { if ( ope [ i - 1 ] == ' + ' ) { ans += S [ i ] ; } else { ans -= S [ i ] ; } } if ( ans == 7 ) { System . out . println ( S [ 0 ] + ope [ 0 ] + S [ 1 ] + ope [ 1 ] + S [ 2 ] + ope [ 2 ] + S [ 3 ] + " = 7" ) ; break ; } } return S ; }
public static int [ ] getDistance ( int [ ] values ) { int [ ] dist = new int [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( values [ i ] == 0 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 1 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 2 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 3 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 4 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 5 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 6 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 7 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 8 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 9 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 10 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 11 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 12 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 13 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 14 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 15 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 16 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 0 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 1 ) { dist [ i ] = values [ i ] ; } else if ( values [ i ] == 2 ) { dist [ i ] = values [ i ] ; } return dist ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalFor
public static boolean prime ( int n ) { for ( int i = 2 ; i <= n ; i ++ ) { if ( i * i > n + 1 ) break ; if ( ( n % i ) == 0 ) return false ; } return true ; }
public static int Squares ( int n , int m , int a ) { return ( ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ) ; if ( Class . isPrimitive ( ) ) { n = 6 ; m = 6 ; a = 4 ; System . out . println ( Squares ( n , m , a ) ) ; } return 0 ; }
public static void printLine ( String line ) { for ( int i = 0 ; i < line . length ( ) ; i ++ ) { int n = Integer . parseInt ( line . substring ( i , i + 1 ) ) ; int m = Integer . parseInt ( line . substring ( i , i + 1 ) ) ; if ( n >= 6 && n % m == 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
static int countCubes ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j * j * j > i ) break ; if ( j * j * j == i ) cnt ++ ; } } return cnt ; }
@ SafeVarargs public static void main ( String [ ] args ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; List < String > aa = Collections . list ( Integer . parseInt ( System . console ( ) . readLine ( ) ) ) ; Map < String , Integer > cs_a0 = new HashMap < > ( ) ; for ( int i = 0 ; i < aa . size ( ) ; i ++ ) { if ( i % 2 == 0 ) cs_a0 . put ( ( String ) aa . get ( i ) , i ) ; } Map < String , Integer > cs_a1 = new HashMap < > ( ) ; for ( int i = 0 ; i < aa . size ( ) ; i ++ ) cs_a1 . put ( ( String ) aa . get ( i ) , i ) ; TreeSet < Integer > vs_a0 = new TreeSet < > ( ( ) -> cs_a0 . entrySet ( ) . stream ( ) . sorted ( ( ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ( Map . Entry < String , Integer > ) ( Map . Entry < String , Integer > ) ( Map . Entry
public static void subString ( String s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int len = i + 1 ; len <= n ; len ++ ) { System . out . println ( s . substring ( i , len ) ) ; } } s = " abcd " ; subString ( s , s . length ( ) ) ; }
public static boolean isPrime ( int n ) { if ( ( n <= 1 ) ) { return false ; } for ( int i = 2 ; i < n ; i ++ ) { if ( ( n % i == 0 ) ) { return false ; } } return true ; }
public static void angleextcycquad ( int z ) { System . out . println ( " The ▁ exterior ▁ angle ▁ of ▁ the " ) ; System . out . println ( " cyclic ▁ quadrilateral ▁ is ▁ " ) ; System . out . println ( z + " ▁ degrees " ) ; }
public static void printMinIndexChar ( String Str , String patt ) { int minIndex = 10 * 9 ; int m = Str . length ( ) ; int n = patt . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( patt . charAt ( i ) == Str . charAt ( j ) && j < minIndex ) ) { minIndex = j ; break ; } } } if ( ( minIndex != 10 * 9 ) ) { System . out . println ( " Minimum ▁ Index ▁ Character ▁ = ▁ " + Str . charAt ( minIndex ) ) ; } else { System . out . println ( " No ▁ character ▁ present " ) ; } Str = " geeksforgeeks " ; patt = " set " ; printMinIndexChar ( Str , patt ) ; }
public static int getRandom ( ) { int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; for ( ; ; ) { int a = Integer . parseInt ( System . getProperty ( " user . name " ) ) , b = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; if ( a != b ) { System . out . println ( " Happy ▁ Alex " ) ; break ; } } }
public static int maxnumber ( int n , int k ) { for ( int i = 0 ; i <= k ; ) { int ans = 0 ; int i = 1 ; while ( n / i > 0 ) { int temp = ( n / ( i * 10 ) ) * i + ( n % i ) ; i *= 10 ; if ( temp > ans ) { ans = temp ; } } n = ans ; } return ans ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ N * 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = i ; } int [ ] L = new int [ N * 2 ] ; for ( int i = 0 ; i < M ; i ++ ) { int a = Integer . parseInt ( array [ i ] ) ; int l = Integer . parseInt ( array [ i ] ) ; for ( int ll = a ; ll < a + l ; ll ++ ) { L [ ll ] = 1 ; } } for ( int i = N ; i < 2 * N ; i ++ ) { L [ i - N ] = Math . max ( L [ i - N ] , L [ i ] ) ; } int left = 0 ; int i = 0 ; while ( L [ i ] == 1 ) { left ++ ; i ++ ; if ( i == N ) { System . out . println ( N + 1 ) ; System . exit ( ) ; } } ArrayList < Integer > A = new ArrayList < > ( ) ; int s = 0 ; for ( int i = i ; i < N ; i ++ ) { int li = L [ i ] ; if ( li == 0 ) { if ( s != 0 ) { A . add ( s ) ; } s = 0 ; } else { s ++ ; } } if ( s + left != 0 ) { A . add ( s + left ) ; } Collections . sort ( A , Collections . reverseOrder ( ) ) ; int v = A . get ( 0 ) ; int n = 0 ; for ( int a : A ) { if ( a == v ) { n ++ ; } else { System . out . println ( v + n ) ; n = 1 ; v = a ; } } System . out . println ( v + n ) ; return A . toArray ( ) ; }
public static int getCost ( int [ ] a , int [ ] b ) { int cost = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { cost += a [ i ] * a [ i ] ; } return cost ; }
public static int getLastTwoDigit ( int N ) { if ( N <= 10 ) { int ans = 0 ; int fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } ans = ans % 100 ; return ans ; } else { return 13 ; } }
public static int binaryNumber ( String binaryNumber ) { int s = Integer . parseInt ( binaryNumber , 2 ) ; return s ; }
public static boolean isPossible ( double x , double y , double z ) { double a = x * x + y * y + z * z ; a = Math . round ( a ) ; if ( ( Math . ceil ( a ) ) == 1 & Math . floor ( a ) == 1 ) { return true ; } return false ; }
public static void performQueries ( int [ ] q , int n ) { int MOD = 10 * 9 + 7 ; int [ ] result = new int [ MAX + 1 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = 0 ; } int [ ] fact = new int [ MAX + 1 ] ; for ( int i = 0 ; i < fact . length ; i ++ ) { fact [ i ] = 0 ; result [ i ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int n = Integer . parseInt ( args [ i ] ) ; int [ ] a = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) a [ j ] = Integer . parseInt ( args [ j ] ) ; int sum = a [ a . length - 1 ] ; int neg = 0 ; for ( int j = 1 ; j < n ; j ++ ) { int val = neg + j * ( a [ j ] - a [ j - 1 ] ) ; sum -= val ; neg = val ; } System . out . println ( sum ) ; } }
public static int segregate ( int [ ] arr , int size ) { int j = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] <= 0 ) ) { arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; j ++ ; } } return j ; }
public static int digitNumber ( int n ) { if ( ( n == 0 ) ) { return 1 ; } if ( ( n == 1 ) ) { return 9 ; } if ( ( n % 2 != 0 ) ) { int temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { int temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int n = Integer . parseInt ( args [ i ] ) ; int [ ] a = Integer . parseInt ( args [ i ] ) ; if ( a [ 0 ] + a [ 1 ] > a [ a . length - 1 ] ) { System . out . println ( - 1 ) ; } else { System . out . println ( 1 + 2 + n ) ; } } }
public static void convert12 ( String str ) { int h1 = str . charAt ( 0 ) - '0' ; int h2 = str . charAt ( 1 ) - '0' ; int hh = h1 * 10 + h2 ; String Meridien = " " ; if ( ( hh < 12 ) ) { Meridien = " AM " ; } else { Meridien = " PM " ; } hh %= 12 ; if ( ( hh == 0 ) ) { System . out . println ( "12" ) ; for ( int i = 2 ; i < 8 ; i ++ ) { System . out . print ( str . charAt ( i ) ) ; } } else { System . out . println ( hh ) ; for ( int i = 2 ; i < 8 ; i ++ ) { System . out . print ( str . charAt ( i ) ) ; } } System . out . println ( " ▁ " + Meridien ) ; } if ( String . valueOf ( str ) . equals ( " java . lang . String " ) ) { str = "17:35:20" ; convert12 ( str ) ; } }
public static boolean check ( String s , int k ) { for ( int i = 0 ; i != s . length ( ) ; i ++ ) { if ( ( s . charAt ( i ) != s . charAt ( i % k ) ) ) { return false ; } } return true ; }
public static void printknapSack ( int W , int [ ] wt , int [ ] [ ] val , int n ) { int [ ] [ ] K = new int [ W + 1 ] [ ] ; for ( int w = 0 ; w < n + 1 ; w ++ ) { for ( int i = 0 ; i < W + 1 ; i ++ ) { if ( i == 0 || w == 0 ) { K [ i ] [ w ] = 0 ; } else if ( wt [ i - 1 ] <= w ) { K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; } else { K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } } int res = K [ n ] [ W ] ; System . out . println ( res ) ; int w = W ; for ( int i = n ; i > 0 ; i -- ) { if ( res <= 0 ) { break ; } if ( res == K [ i - 1 ] [ w ] ) { continue ; } else { System . out . println ( wt [ i - 1 ] ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } val = new int [ ] { 60 , 100 , 120 } ; wt = new int [ ] { 10 , 20 , 30 } ; W = 50 ; n = val . length ; printknapSack ( W , wt , val , n ) ; }
public static int getDistance ( int [ ] array , int [ ] values ) { int distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == values [ i ] ) { distance += values [ i ] ; } else { distance += values [ i ] ; } } return distance ; }
static void indexedSequentialSearch ( int [ ] arr , int n , int k ) { int [ ] elements = new int [ 20 ] ; int [ ] indices = new int [ 20 ] ; int j = 0 , ind = 0 ; for ( int i = 0 ; i < n ; i += 3 ) { elements [ ind ] = arr [ i ] ; indices [ ind ] = i ; ind ++ ; } if ( k < elements [ 0 ] ) { System . out . println ( " Not ▁ found " ) ; exit ( 0 ) ; } else { for ( int i = 1 ; i <= ind ; i ++ ) { if ( k < elements [ i ] ) { int start = indices [ i - 1 ] ; int end = indices [ i ] ; break ; } } } for ( int i = start ; i <= end ; i ++ ) { if ( k == arr [ i ] ) { j = 1 ; break ; } } if ( j == 1 ) { System . out . println ( " Found ▁ at ▁ index " + i ) ; } else { System . out . println ( " Not ▁ found " ) ; } } if ( Class . isPrimitive ( ) ) { arr = new int [ ] { 6 , 7 , 8 , 9 , 10 } ; n = arr . length ; k = 8 ; indexedSequentialSearch ( arr , n , k ) ; }
public static int largestPalindrome ( int n ) { int upperLimit = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { upperLimit = upperLimit * 10 ; upperLimit = upperLimit + 9 ; } int lowerLimit = 1 + upperLimit / 10 ; int maxProduct = 0 ; for ( int i = upperLimit ; i >= lowerLimit ; i -- ) { for ( int j = i ; j >= lowerLimit ; j -- ) { int product = i * j ; if ( ( product < maxProduct ) ) break ; int number = product ; int reverse = 0 ; while ( ( number != 0 ) ) { reverse = reverse * 10 + number % 10 ; number = number / 10 ; } if ( ( product == reverse ) && ( product > maxProduct ) ) maxProduct = product ; } } return maxProduct ; }
public static int [ ] getNegativeInstances ( ) { int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int [ ] seq = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { seq [ i ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; } int [ ] dp = new int [ seq . length ] ; dp [ 0 ] = seq [ 0 ] ; for ( int i = 1 ; i < seq . length ; i ++ ) { int num = seq [ i ] ; if ( num > dp [ i - 1 ] ) { dp [ i ] = num ; } else { dp [ i ] = seq [ i ] ; } } return dp ; }
public static int getDayNumber ( int [ ] array ) { int [ ] dayNumbers = array . clone ( ) ; for ( int i = 0 ; i < dayNumbers . length ; i ++ ) { if ( i < array . length ) { dayNumbers [ i ] = array [ i ] ; } } return dayNumbers [ 0 ] ; }
public static int [ ] [ ] getdp ( ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int [ ] arr = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int [ ] [ ] diff = new int [ n - 1 ] [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) diff [ i ] [ i ] = Math . abs ( arr [ i ] - arr [ i + 1 ] [ i ] ) ; int [ ] [ ] dp = new int [ n - 1 ] [ n - 1 ] ; dp [ 0 ] [ 1 ] = diff [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 2 ] + diff [ i ] , diff [ i ] ) ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - diff [ i ] ; } System . out . println ( Math . max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] , dp [ n - 2 ] [ 2 ] ) ) ; return dp ; }
public static int maximumXor ( @ NonNull int [ ] arr , int n ) { List < Integer > sForward = new ArrayList < > ( ) , sBackward = new ArrayList < > ( ) ; int ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { while ( sForward . size ( ) > 0 && arr [ i ] < arr [ sForward . size ( ) - 1 ] ) { ans = Math . max ( ans , arr [ i ] ^ arr [ sForward . size ( ) - 1 ] ) ; sForward . remove ( sBackward . size ( ) - 1 ) ; } sForward . add ( i ) ; while ( sBackward . size ( ) > 0 && arr [ n - i - 1 ] < arr [ sBackward . size ( ) - 1 ] ) { ans = Math . max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward . size ( ) - 1 ] ) ; sBackward . remove ( sBackward . size ( ) - 1 ) ; } sBackward . add ( n - i - 1 ) ; } return ans ; }
public static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( ( n != 0 ) ) { int temp = 0 ; temp = n % 16 ; if ( ( temp < 10 ) ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i = i + 1 ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i = i + 1 ; } n = ( int ) ( n / 16 ) ; } int j = i - 1 ; while ( ( j >= 0 ) ) { System . out . print ( ( hexaDeciNum [ j ] ) ) ; j = j - 1 ; } } n = 2545 ; decToHexa ( n ) ; }
public static int getN ( ) { int [ ] A = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int [ ] C = new int [ 10 * 5 ] ; for ( int ai : A ) { C [ ai ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < 10 * 5 - 2 ; i ++ ) { ans = Math . max ( C [ i ] + C [ i + 1 ] + C [ i + 2 ] , ans ) ; } return ans ; }
public static int [ ] getPom ( int [ ] pds ) { int h = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int w = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; if ( h == w == 0 ) { break ; } HashMap < Character , int [ ] > mp = new HashMap < > ( ) ; for ( int r = 0 ; r < h ; r ++ ) { String s = System . getProperty ( " line . separator " ) ; for ( int c = 0 ; c < w ; c ++ ) { mp . put ( s . charAt ( c ) , new int [ ] { r , c } ) ; } } String s = System . getProperty ( " line . separator " ) ; int [ ] now = new int [ ] { 0 , 0 } ; int ans = 0 ; for ( int i = 0 ; i < pds . length ; i ++ ) { int [ ] to = mp . get ( s . charAt ( i ) ) ; ans += Math . abs ( now [ 0 ] - to [ 0 ] ) + Math . abs ( now [ 1 ] - to [ 1 ] ) + 1 ; now = to ; } System . out . println ( ans ) ; return mp . values ( ) . toArray ( new int [ 0 ] ) ; }
public static final int getRandom ( ) { final int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; if ( n == 1 ) { System . out . println ( " Hello ▁ World " ) ; } else { final int a = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; final int b = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; System . out . println ( a + b ) ; } return n ; }
public static int extractMaximum ( String ss ) { int num = 0 , res = 0 ; for ( int i = 0 ; i < ss . length ( ) ; i ++ ) { if ( ss . charAt ( i ) >= '0' && ss . charAt ( i ) <= '9' ) { num = num * 10 + ( int ) ( Integer . parseInt ( ss . substring ( i , i + 1 ) ) - 0 ) ; } else { res = Math . max ( res , num ) ; num = 0 ; } } return Math . max ( res , num ) ; }
public static void findIndices ( int [ ] arr , int n ) { int [ ] sum = new int [ max ] ; for ( int i = 0 ; i < max ; i ++ ) { sum [ i ] = 0 ; } int k = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum [ i ] = sum [ i - 1 ] + arr [ k ] ; k ++ ; } int ans = - ( 1e15 ) ; int index_1 = 0 ; int index_2 = 0 ; int index_3 = - 1 ; for ( int l = 0 ; l <= n ; l ++ ) { int index = 0 ; int vmin = ( 1e15 ) ; for ( int r = l ; r <= n ; r ++ ) { if ( ( sum [ r ] < vmin ) ) { vmin = sum [ r ] ; index = r ; } if ( ( sum [ l ] + sum [ r ] - vmin ) > ans ) { ans = sum [ l ] + sum [ r ] - vmin ; index_1 = l ; index_2 = index ; index_3 = r ; } } } System . out . println ( index_1 + " ▁ " + index_2 + " ▁ " + index_3 ) ; arr = new int [ ] { - 1 , 2 , 3 } ; n = arr . length ; findIndices ( arr , n ) ; }
static void printElements ( int [ ] arr , int n ) { for ( int i = 1 ; i < n - 1 ; i += 1 ) { if ( ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } if ( Class . isPrimitive ( arr [ 0 ] ) ) { arr = new int [ ] { 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 } ; n = arr . length ; printElements ( arr , n ) ; } }
public static int valueofX ( int [ ] ar , int n ) { int summ = Arrays . stream ( ar ) . reduce ( 0 , ( a , b ) -> a + b ) ; if ( ( summ % n == 0 ) ) { return summ / n ; } else { int A = summ / n ; int B = summ / n + 1 ; int ValueA = 0 ; int ValueB = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ; ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) ; } if ( ( ValueA < ValueB ) ) { return A ; } else { return B ; } } n = 7 ; int [ ] arr = { 6 , 9 , 1 , 6 , 1 , 3 , 7 } ; System . out . println ( valueofX ( arr , n ) ) ; return 0 ; }
public static void generateRandomString ( String input ) { for ( int i = 0 ; i < input . length ( ) ; i ++ ) { int x = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int y = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int [ ] z = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int a = 0 ; for ( int j = 0 ; j < z . length ; j ++ ) { if ( ( z [ j ] & ( 1 << i ) ) != 0 ) { c ++ ; } } if ( c > ( x - c ) ) { a ++ ; } } System . out . println ( a ) ; }
public static String getValidString ( String s ) { s = s . trim ( ) ; s . trim ( ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . length ( ) % 2 == 1 ) { s . trim ( ) ; } else { if ( s . substring ( 0 , ( int ) s . length ( ) / 2 ) . equals ( s . substring ( ( int ) s . length ( ) / 2 ) ) ) { System . out . println ( s . length ( ) ) ; exit ( ) ; } else { s . trim ( ) ; } } } return s ; }
static int findNth ( int n ) { int count = 0 ; int curr = 19 ; while ( ( x ) != 0 ) { int sum = 0 ; int x = curr ; while ( ( x ) != 0 ) { sum = sum + x % 10 ; x = ( int ) ( x / 10 ) ; } if ( ( sum == 10 ) ) { count ++ ; } if ( ( count == n ) ) { return curr ; } curr += 9 ; } return - 1 ; }
static int findNth ( int n ) { int count = 0 ; for ( int curr = 0 ; ; curr ++ ) { int sum = 0 ; int x = curr ; while ( ( x = x ) != 0 ) { sum = sum + x % 10 ; x = x / 10 ; } if ( ( sum == 10 ) ) { count = count + 1 ; } if ( ( count == n ) ) { return curr ; } } return - 1 ; }
public static int countNumber ( int N , int S ) { int countElements = 0 ; int currentSum = 0 ; int currSum = 0 ; while ( ( currSum <= S ) ) { currSum += N ; N = N - 1 ; countElements = countElements + 1 ; } return countElements ; }
public static boolean strrmatch ( String strr , String pattern , int n , int m ) { if ( ( m == 0 ) ) { return ( n == 0 ) ; } boolean [ ] [ ] lookup = new boolean [ m + 1 ] [ n + 1 ] ; lookup [ 0 ] [ 0 ] = true ; for ( int i = 1 ; i <= m ; i ++ ) { if ( ( pattern . charAt ( j - 1 ) == ' * ' ) ) { lookup [ 0 ] [ j ] = lookup [ 0 ] [ j - 1 ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( ( pattern . charAt ( j - 1 ) == ' * ' ) ) { lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] || lookup [ i - 1 ] [ j ] ; } else if ( ( pattern . charAt ( j - 1 ) == ' ? ' ) || strr . charAt ( j - 1 ) == pattern . charAt ( j - 1 ) ) { lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] ; } else { lookup [ i ] [ j ] = false ; } } } return lookup [ n ] [ m ] ; } strr = " baaabab " ; pattern = " * * * * * ba * * * * * ab " ; if ( ( strr . length ( ) ) != pattern . length ( ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return lookup [ n ] [ m ] ; }
public static int [ ] f ( int n ) { HashSet < Integer > a = new HashSet < > ( ) ; int i = 2 ; while ( i * i <= n ) { while ( n % i == 0 ) { a . add ( i ) ; n /= i ; } i ++ ; } if ( n > 1 ) a . add ( n ) ; return a . toArray ( new Integer [ a . size ( ) ] ) ; while ( true ) { int a = Integer . parseInt ( input ( ) ) ; int b = Integer . parseInt ( input ( ) ) ; if ( ( a = a . or ( b = b ) ) == 0 ) break ; a = f ( a ) ; b = f ( b ) ; System . out . println ( 2 * Math . max ( a , b ) - Math . sum ( a ) > 2 * Math . max ( b , b ) - Math . sum ( b ) ) ; } return a . toArray ( new Integer [ a . size ( ) ] ) ; }
public static int nCr ( int n , int r ) { int [ ] fac = new int [ n + r ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fac [ i ] = fac [ i - 1 ] * i ; } int ans = fac [ n ] / ( fac [ n - r ] * fac [ r ] ) ; return ans ; }
public static int max ( int [ ] a ) { int x = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { x = a [ i ] ; } return x ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) ) { return b ; } return gcd ( b % a , a ) ; }
public static int [ ] countSort ( int [ ] A , int n ) { int k = Math . max ( A . length , 0 ) ; int [ ] B = new int [ n ] ; int [ ] C = new int [ k + 1 ] ; for ( int j = 0 ; j < n ; j ++ ) { C [ A [ j ] ] ++ ; } for ( int i = 1 ; i <= k ; i ++ ) { C [ i ] = C [ i ] + C [ i - 1 ] ; } for ( int j = n - 1 ; j >= 0 ; j -- ) { B [ C [ A [ j ] ] - 1 ] = A [ j ] ; C [ A [ j ] ] -- ; } return B ; }
public static int min ( int n , String s ) { return ( n / 11 ) + s . indexOf ( '8' ) ; }
static int sumOfDigit ( int n , int b ) { int unitDigit = 0 ; int sum = 0 ; while ( ( n > 0 ) ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; }
@ SafeVarargs public static void printLargestDivisible ( int n , int [ ] a ) { int c0 = 0 , c5 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { c0 ++ ; } else { c5 ++ ; } } c5 = Math . floor ( c5 / 9 ) * 9 ; if ( c0 == 0 ) { System . out . print ( - 1 ) ; } else if ( c5 == 0 ) { System . out . print ( 0 ) ; } else { for ( int i = 0 ; i < c5 ; i ++ ) { System . out . print ( 5 ) ; } for ( int i = 0 ; i < c0 ; i ++ ) { System . out . print ( 0 ) ; } } if ( Class . isPrimitive ( String . class ) ) { a = new int [ ] { 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 0 , 5 , 5 } ; n = a . length ; printLargestDivisible ( n , a ) ; } }
static int countWays ( int n ) { int counter = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = j ; k < n ; l ++ ) { if ( ( i + j + k + l ) == n ) { counter ++ ; } } } } return counter ; }
public static int numberOfMinutes ( double S , double S1 ) { double Min = 0 ; Min = ( ( S - S1 ) / Math . floor ( S ) ) * 60 ; return ( int ) Min ; }
public static int fn ( int n , int m , int k , int [ ] L ) { int g = Math . min ( L . length , m ) ; Arrays . sort ( L ) ; for ( int p : L ) { Arrays . sort ( p ) ; } int [ ] op = new int [ L . length ] ; for ( int i = 0 ; i < L . length - 1 ; i ++ ) { op [ i ] = L [ i + 1 ] - L [ i ] - 1 ; } Arrays . sort ( op ) ; int dist = n ; for ( int gt = 0 ; gt < n - k ; gt ++ ) { dist += op [ gt ] ; } return ( dist ) ; String [ ] a = input ( ) ; String [ ] b = input ( ) ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; return ( int ) a [ 0 ] . compareTo ( b [ 0 ] ) ; }
public static int onesComplement ( int n ) { int numberOfBits = ( int ) ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) + 1 ; return ( ( 1 << numberOfBits ) - 1 ) ^ n ; }
public static int getDistance ( int [ ] array , int start , int end ) { int [ ] result = new int [ array . length ] ; for ( int i = start ; i < end ; i ++ ) { int m = array [ i ] ; for ( int j = 0 ; j < m ; j ++ ) { int k = array [ i ] ; if ( j == m ) { result [ i ] = j ; } else { result [ i ] = j ; } } } return result [ start ] + result [ end ] ; }
public static void findPoint ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( " ( " + 2 * x2 - x1 + " , " + 2 * y2 - y1 + " ) " ) ; }
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static void alter ( int x , int y ) { while ( ( x = Math . random ( ) ) != 0 ) { if ( ( x == 0 ) || ( y == 0 ) ) { break ; } if ( ( x >= 2 * y ) ) { x = x % ( 2 * y ) ; } else if ( ( y >= 2 * x ) ) { y = y % ( 2 * x ) ; } else { break ; } } System . out . println ( " X ▁ = " + x + " , ▁ Y ▁ = " + y ) ; }
public static int solve ( String [ ] args ) { final int N = Integer . parseInt ( args [ 0 ] ) ; final int [ ] V = readInts ( ) ; System . out . println ( solve ( N , V ) ) ; final int [ ] [ ] solve ( N , V ) { Arrays . sort ( V ) ; final HashMap < Integer , Integer > pos = new HashMap < > ( ) ; for ( int i = 0 ; i < V . length ; i ++ ) { final int a = V [ i ] [ i ] ; pos . put ( a , i ) ; } int best = 2 ; final boolean [ ] [ ] done = new boolean [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { done [ i ] [ N ] = false ; } for ( int i = 0 ; i < N ; i ++ ) { final int a = V [ i ] [ N ] ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( done [ i ] [ j ] ) { continue ; } final int b = V [ j ] [ N ] ; final int d = b - a ; int c = 2 ; done [ i ] [ j ] = true ; int k = j ; int v = b + d ; while ( pos . containsKey ( v ) ) { done [ k ] [ pos . get ( v ) ] = true ; k = pos . get ( v ) ; c ++ ; v += d ; } best = Math . max ( best , c ) ; } } return best ; } final boolean DEBUG = System . getenv ( " DEBUG " ) . contains ( " DEBUG " ) ; final String in = System . getProperty ( " line . separator " ) ; final int [ ] value = in . split ( " ▁ " ) ; final int [ ] [ ] read = new int [ in . length ] [ ] ; for ( int i = 0 ; i < read . length ; i ++ ) { value [ i ] = Integer . parseInt ( in . substring ( i , i + 1 ) ) ; } final int [ ] dprint = new int [ value . length ] ; for ( int i = 0 ; i < value . length ; i ++ ) { dprint [ i ] = value [ i ] ; } if ( DEBUG ) { System . out . println ( dprint ) ; } return 0 ; }
public static int getCountry ( String country ) { int [ ] array = country . split ( " _ " ) ; if ( array . length == 0 ) { return - 1 ; } else if ( array . length == 1 ) { return - 1 ; } else if ( array . length == 2 ) { return - 1 ; } else if ( array . length == 3 ) { return - 1 ; } else if ( array . length == 4 ) { return - 1 ; } else if ( array . length == 5 ) { return - 1 ; } else if ( array . length == 6 ) { return - 1 ; } else if ( array . length == 7 ) { return - 1 ; } else if ( array . length == 8 ) { return - 1 ; } else if ( array . length == 9 ) { return - 1 ; } else if ( array . length == 10 ) { return - 1 ; } else if ( array . length == 11 ) { return - 1 ; } else if ( array . length == 12 ) { return - 1 ; } else if ( array . length == 13 ) { return - 1 ; } else if ( array . length == 14 ) { return - 1 ; } else if ( array . length == 15 ) { return - 1 ; } else if ( array . length == 16 ) { return - 1 ; } else if ( array . length == 17 ) { return - 1 ; } else if ( array . length == 18 ) { return - 1 ; } else if ( array . length == 19 ) { return - 1 ; } else if ( array . length == 19 ) { return - 1 ; } else if ( array . length == 20 ) { return - 1 ; } else if ( array . length == 21 ) { return - 1 ; } else if ( array . length == 23 ) { return - 1 ; } else if ( array . length == 23 ) { return - 1 ; } else if ( array . length == 23 ) { return - 1 ; } else if ( array . length == 23 ) { return - 1 ; } else if ( array . length == 23 ) { return - 1 ; } else if ( array . length == 23 ) { return - 1 ; } else if ( array . length == 23 ) { return - 1 ; return - 1 ; } else if ( array . length == 0 ) { return - 1 ; } else { return - 1 ; } else { return 0 ; } }
public static int findSum ( String [ ] num ) { int res = 0 ; for ( int i = 0 ; i < num . length ; i ++ ) { res = ( res * 10 + Integer . parseInt ( num [ i ] ) - 0 ) % mod ; } return res ; }
public static void unsort ( int l , int r , int [ ] a , int k ) { if ( ( k < 1 || l + 1 == r ) ) return ; k -= 2 ; int mid = ( l + r ) / 2 ; int temp = a [ mid - 1 ] ; a [ mid - 1 ] = a [ mid ] ; a [ mid ] = temp ; unsort ( l , mid , a , k ) ; unsort ( mid , r , a , k ) ; }
public static double mean ( int [ ] mid , int [ ] freq , int n ) { double sum = 0 ; double freqSum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; }
public static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }
public static int rectangleArea ( int a , int b ) { if ( a < 0 || b < 0 ) { return - 1 ; } return 2 * a * b ; }
public static int t ( String input ) { while ( t > 0 ) { t -- ; int n = Integer . parseInt ( input ) ; int l = Integer . parseInt ( input ) ; int r = Integer . parseInt ( input ) ; int k = n / l ; if ( r * k >= n ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } return t ; }
public static int getsum ( int x ) { return ( int ) ( ( x * ( x + 1 ) ) / 2 ) ; }
public static int lcs ( int [ ] [ ] dp , int [ ] [ ] arr1 , int n , int [ ] [ ] arr2 , int m , int k ) { if ( k < 0 ) return - ( 10 * 7 ) ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) { ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; } ans = Math . max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; return ans ; }
public static double getDecimalValue ( int n , int d , int x ) { double ans = 0 ; double i , ans = 0 ; try { i = Double . parseDouble ( input ) ; ans += ( double ) ( ( ( double ) n - ( double ) i + 1 ) / ( double ) i * ( d + x * ( double ) ( ( double ) n * 2 - 1 ) ) / ( double ) "2" ) ; } catch ( NumberFormatException nfe ) { ans += n ; } return ans ; }
public static void Reverseorder ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; int p = 2 ; while ( ( p * p <= n ) ) { if ( ( prime [ p ] ) == true ) { for ( int i = ( p * 2 ) ; i < ( n + 1 ) ; i += p ) { prime [ i ] = false ; } } p ++ ; } for ( p = n ; p >= 1 ; p -- ) { if ( ( prime [ p ] ) != true ) { System . out . print ( p + " ▁ " ) ; } } int N = 25 ; System . out . println ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) ; if ( ( N == 1 ) ) { System . out . println ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) ; } else { Reverseorder ( N ) ; } }
public static void pattern ( int minStars , int pHeight ) { int pSpace = pHeight - 1 ; int x = 1 ; for ( int i = 0 ; i <= pHeight ; i ++ ) { for ( int j = pSpace ; j > i ; j -- ) { System . out . print ( " ▁ " ) ; } for ( int k = 0 ; k <= minStars ; k ++ ) { System . out . print ( " * " ) ; } for ( int n = ( pHeight + pHeight - 2 ) ; n > x - 1 ; n -- ) { System . out . print ( " ▁ " ) ; } for ( int k = 0 ; k <= minStars ; k ++ ) { System . out . print ( " * " ) ; } minStars = minStars + 2 ; x = x + 2 ; System . out . println ( " " ) ; } if ( Class . forName ( " java . util . regex . Matcher " ) . find ( ) ) { minStars = 1 ; pHeight = 5 ; pattern ( minStars , pHeight ) ; } }
public static String getValidString ( String [ ] strs ) { if ( strs . length == 0 ) { return " " ; } if ( strs . length == 1 ) { return " " ; } if ( strs . length == 2 ) { return " " ; } if ( strs . length == 3 ) { return " " ; } if ( strs . length == 4 ) { return " " ; } if ( strs . length == 5 ) { return " " ; } if ( strs . length == 6 ) { return " " ; } if ( strs . length == 7 ) { return " " ; } if ( strs . length == 8 ) { return " " ; } if ( strs . length == 9 ) { return " " ; } if ( strs . length == 10 ) { return " " ; } if ( strs . length == 11 ) { return " " ; } if ( strs . length == 12 ) { return " " ; } if ( strs . length == 13 ) { return " " ; } if ( strs . length == 14 ) { return " " ; } if ( strs . length == 15 ) { return " " ; } if ( strs . length == 16 ) { return " " ; } if ( strs . length == 15 ) { return " " ; } if ( strs . length == 16 ) { return " " ; } if ( strs . length == 15 ) { return " " ; } if ( strs . length == 16 ) { return " " ; } if ( strs . length == 15 ) { return " " ; } if ( strs . length == 16 ) { return " " ; } if ( strs . length == 17 ) { return " " ; } if ( strs . length == 18 ) { return " " ; } if ( strs . length == 19 ) { return " " ; } if ( strs . length == 19 ) { return " " ; } if ( strs . length == 20 ) { return " " ; } if ( strs . length == 21 ) { return " " ; } if ( strs . length == 22 ) { return " " ; } if ( strs . length == 23 ) { return " " ; } if ( strs . length == 25 ) { return " " ; } if ( strs . length == 26 ) { return " " ; } return " " ; if ( strs . length == 27 ) { return " " ; return " " ; }
public static int distancesum ( int [ ] x , int [ ] y , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; } } return sum ; }
public static int fib ( int n ) { final int sum ; int phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; }
public static int fib ( int n ) { double phi = ( ( 1 + ( 5 * ( 1 / 2 ) ) ) / 2 ) ; return Math . round ( ( phi * n ) / ( 5 * ( 1 / 2 ) ) ) ; }
public static int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; }
public static int m ( String input ) { int n = Integer . parseInt ( input ) ; StringBuilder k = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String a1 = input . substring ( 0 , i ) ; String a2 = input . substring ( i , i + 1 ) ; String c = input . substring ( i , i + 1 ) ; String d = input . substring ( i , i + 1 ) ; for ( int j = Integer . parseInt ( a1 ) - 1 ; j < Integer . parseInt ( a2 ) ; j ++ ) { if ( k . charAt ( j ) == c ) { k . setCharAt ( j , d ) ; } } } return k . toString ( ) ; }
static int compareStrings ( String str1 , String str2 ) { int i = 0 ; while ( i < str1 . length ( ) - 1 && str1 . charAt ( i ) == str2 . charAt ( i ) ) { i ++ ; } if ( str1 . charAt ( i ) > str2 . charAt ( i ) ) { return - 1 ; } return str1 . charAt ( i ) < str2 . charAt ( i ) ? i : 0 ; }
public static int getMonth ( int year , int month ) { return ( year + month ) % 2 ; }
public static int parseLine ( String line ) { int ax = Integer . parseInt ( line ) ; int ay = Integer . parseInt ( line ) ; int bx = Integer . parseInt ( line ) ; int by = Integer . parseInt ( line ) ; int cx = Integer . parseInt ( line ) ; int cy = Integer . parseInt ( line ) ; return ax + by ; }
public static int solve ( ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; String a = System . console ( ) . readLine ( ) ; String b = new String ( a . getBytes ( ) ) ; return Integer . parseInt ( b ) ; }
public static int sumAP ( int n , int d ) { int i = ( int ) ( n / d ) ; return ( i ) * ( 1 + i ) * ( d / 2 ) ; }
public static int solve ( int [ ] a , int [ ] b ) { int t = 0 ; int n = a . length ; for ( int i = 0 ; i < n ; i ++ ) { int s = a [ i ] , f = b [ i ] ; t -= f - s ; } if ( t < 1 ) { System . out . println ( " OK " ) ; } else { System . out . println ( t ) ; } return t ; }
public static int fact ( int num ) { int fact = 1 ; while ( ( num > 1 ) ) { fact = fact * num ; num = num - 1 ; } return fact ; }
public static int [ ] get ( ) { return new int [ ] { Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) } ; int intput = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; return new int [ ] { } ; }
public static int [ ] get ( ) { return new int [ ] { Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) , Integer . parseInt ( System . getProperty ( " user . name " ) ) } ; }
static int countWays ( int n , int [ ] arr ) { int [ ] count = new int [ n + 1 ] ; count [ 0 ] = 1 ; if ( ( n == 0 ) ) { return 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { int noWays = 0 ; for ( int j : arr ) { if ( ( i - j >= 0 ) ) { noWays += count [ i - j ] ; } count [ i ] = noWays ; } } return count [ n ] ; arr = new int [ ] { 1 , 3 , 5 } ; n = 5 ; System . out . println ( countWays ( n , arr ) ) ; }
public static void doSearch ( String input ) { int L = Integer . parseInt ( input ) ; if ( L == 0 ) { break ; } int a = 0 ; int b = 0 ; int c = 0 ; for ( ; ; ) { a += 1 ; int M = Integer . parseInt ( input ) ; int N = Integer . parseInt ( input ) ; b += M - N ; if ( c == 0 && b >= L ) { c = a ; } } System . out . println ( c != 0 ? c : " NA " ) ; }
public static void solve ( int [ ] a , int [ ] b , int [ ] c ) { for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = a [ i ] ; b [ i ] = b [ i ] ; c [ i ] = c [ i ] ; } a [ b . length ] = b [ b . length ] ; b [ c . length ] = c [ c . length ] ; if ( c [ 0 ] - a [ 2 ] <= 2 ) { System . out . println ( 0 ) ; } else { System . out . println ( 2 * ( c [ 0 ] - a [ 2 ] ) ) ; } }
public static int getDayFromDate ( String date ) { int dayFromDate = date . indexOf ( ' . ' ) ; if ( dayFromDate == - 1 ) { return dayFromDate ; } else if ( dayFromDate == - 1 ) { return dayFromDate ; } else if ( dayFromDate == - 1 ) { return dayFromDate ; } else if ( dayFromDate == - 1 ) { return dayFromDate ; } else if ( dayFromDate == - 1 ) { return dayFromDate ; } else if ( dayFromDate == - 1 ) { return dayFromDate ; } else if ( dayFromDate == - 1 ) { return dayFromDate ; } else if ( dayFromDate == - 1 ) { return dayFromDate ; } else if ( dayFromDate == - 1 ) { return dayFromDate ; } else if ( dayFromDate == - 1 ) { return dayFromDate ; } else if ( dayFromDate == - 1 ) { return dayFromDate ; } else if ( dayFromDate == - 1 ) { return dayFromDate ; } return dayFromDate ; }
static int binarySearch ( int [ ] arr , int low , int high , int key ) { if ( ( high < low ) ) { return - 1 ; } int mid = ( low + high ) / 2 ; if ( ( key == arr [ ( int ) mid ] ) ) { return mid ; } if ( ( key > arr [ ( int ) mid ] ) ) { return binarySearch ( arr , ( mid + 1 ) , high , key ) ; } return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) ; }
public static void equalsXorSum ( int [ ] arr , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( ( Sum == Xor ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } if ( Class . isPrimitive ( " java . util . Arrays " ) ) { arr = new int [ ] { 6 , 3 , 7 , 10 } ; n = arr . length ; equalsXorSum ( arr , n ) ; } }
public static final String getCountry ( String country ) { String [ ] parts = country . split ( " _ " ) ; int n = parts [ 0 ] . length ( ) ; int m = parts [ 1 ] . length ( ) ; int k = parts [ 2 ] . length ( ) ; HashSet < Integer > h = new HashSet < > ( ) ; h . add ( 0 , n ) ; int b = 1 ; if ( ! h . contains ( b ) ) { for ( ; k > 0 ; k -- ) { int u = parts [ k ] . charAt ( 0 ) ; int v = parts [ k ] . charAt ( 0 ) ; if ( b == u || b == v ) { b = b == v ? u : v ; if ( new Integer ( u ) . compareTo ( v ) != 0 ) break ; } } } return null ; }
static void findPairs ( int [ ] arr , int n ) { int cntEven = 0 ; int cntOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 ) == 0 ) { cntEven ++ ; } else { cntOdd ++ ; } } int evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; int oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; System . out . println ( " Odd ▁ pairs ▁ = ▁ " + oddPairs ) ; System . out . println ( " Even ▁ pairs ▁ = ▁ " + evenPairs ) ; }
public static int minBroadcastRange ( int [ ] houses , int [ ] towers , int n , int m ) { int leftTower = - Integer . MAX_VALUE - 1 ; int rightTower = towers [ 0 ] ; int j = 0 , k = 0 ; int minRange = 0 ; while ( ( j < n ) ) { if ( ( houses [ j ] < rightTower ) ) { int left = houses [ j ] - leftTower ; int right = rightTower - houses [ j ] ; int localMax ; if ( ( left < right ) ) { localMax = left ; } else { localMax = right ; } if ( ( localMax > minRange ) ) { minRange = localMax ; } j ++ ; } else { leftTower = towers [ k ] ; if ( ( k < m - 1 ) ) { k ++ ; rightTower = towers [ k ] ; } else { rightTower = Integer . MAX_VALUE ; } } } return minRange ; }
public static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; num = 100 ; divisor = 7 ; return ( int ) getRemainder ( num , divisor ) ; }
public static int getDistance ( int [ ] array ) { int distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == array [ i ] ) { distance += i ; } } return distance ; }
public static int solve ( int [ ] list , int m ) { String [ ] _allinput = new String [ list . length ] ; for ( int i = 0 ; i < _allinput . length ; i ++ ) { String inp = _allinput [ i ] ; _allinput [ i ] = inp . trim ( ) ; } return _allinput [ 0 ] . length ; }
public static int [ ] getRandom ( ) { int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int wmax = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int [ ] [ ] U = new int [ n ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { int v = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int w = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int u = v / w ; U [ i ] [ 0 ] = - u ; U [ i ] [ 1 ] = v ; U [ i ] [ 2 ] = w ; } Arrays . sort ( U ) ; int remains = wmax ; int i = 0 ; int ans = 0 ; do { try { if ( remains > U [ i ] [ 2 ] ) { remains -= U [ i ] [ 2 ] ; ans += U [ i ] [ 1 ] ; i ++ ; } else { ans += U [ i ] [ 1 ] * remains / U [ i ] [ 2 ] ; break ; } } catch ( Exception e ) { break ; } } while ( ans > 0 ) ; return U ; }
static int getSingle ( int [ ] arr , int n ) { int ones = 0 ; int twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; int commonBitMask = ~ ( ones & twos ) ; ones &= commonBitMask ; twos &= commonBitMask ; } return ones ; }
public static int maxdiff ( int [ ] arr , int n ) { Map < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( arr [ i ] , 1 ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ] ) && arr [ i ] > arr [ j ] ) { ans = Math . max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) ; } else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ j ] ) && arr [ i ] < arr [ j ] ) { ans = Math . max ( ans , freq . get ( arr [ j ] ) - freq . get ( arr [ i ] ) ) ; } } } return ans ; }
public static int getDistance ( int [ ] array , int [ ] values ) { int distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } else if ( array [ i ] == values [ i ] ) { distance = i ; } return distance ; }
public static void makeAP ( int [ ] arr , int n ) { int initialTerm , commonDifference ; if ( ( n == 3 ) ) { commonDifference = arr [ 2 ] - arr [ 1 ] ; initialTerm = arr [ 1 ] - commonDifference ; } else if ( ( ( arr [ 1 ] - arr [ 0 ] ) ) == arr [ 2 ] - arr [ 1 ] ) { initialTerm = arr [ 0 ] ; commonDifference = arr [ 1 ] - arr [ 0 ] ; } else if ( ( ( arr [ 2 ] - arr [ 1 ] ) ) == ( arr [ 3 ] - arr [ 2 ] ) ) { commonDifference = arr [ 2 ] - arr [ 1 ] ; initialTerm = arr [ 1 ] - commonDifference ; } else { commonDifference = ( arr [ 3 ] - arr [ 0 ] ) / 3 ; initialTerm = arr [ 0 ] ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ( int ) ( initialTerm + ( i * commonDifference ) ) + " ▁ " ) ; } System . out . println ( ) ; } arr = new int [ ] { 1 , 3 , 7 } ; n = arr . length ; makeAP ( arr , n ) ; }
static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( ( y + x ) % ( y ^ x ) ) == 0 ) { count ++ ; } } } return count ; }
static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( ( y * x ) % ( y + x ) ) == 0 ) { count ++ ; } } } return count ; }
public static int longestPalindrome ( String s ) { int ans = 0 ; HashMap < Character , Integer > charMap = new HashMap ( ) ; for ( char c : s . toCharArray ( ) ) { charMap . put ( c , charMap . get ( c , 0 ) + 1 ) ; } for ( char c : Collections . list ( charMap . keySet ( ) ) ) { if ( charMap . get ( c ) % 2 == 0 ) { ans += charMap . remove ( c ) ; } else { ans += charMap . get ( c ) / 2 * 2 ; } } if ( charMap . size ( ) != 0 ) { ans ++ ; } return ans ; }
public static int binomialCoeff ( int n , int k ) { long res = 1 ; if ( ( k > n - k ) ) { k = n - k ; } for ( int i = 0 ; i < k ; i ++ ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return ( int ) res ; }
public static int getCost ( int [ ] cost , int [ ] cost ) { if ( cost == null ) { return 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } if ( cost == null ) { cost = 0 ; } return cost ; } if ( cost == null ) { cost = 0 ; } return cost ; }
public static int solve ( ) { final String input = System . getProperty ( " line . separator " ) ; final Integer ii = new Integer ( input ) ; final Integer mi = new Integer ( input ) ; final Integer li = new Integer ( input ) ; @ SuppressWarnings ( " unchecked " ) final int d = mi . intValue ( ) , t = 0 , a = 0 , b = 0 , da = 0 , db = 0 ; return ( int ) Math . round ( Math . pow ( 2 , 2 ) ) ; }
public static boolean isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) { return false ; } else { return true ; } n = 10 ; if ( isSumOfPowersOfTwo ( n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { Stack < Integer > s = new Stack ( ) ; if ( ( i <= n ) ) { s . push ( i ) ; result ++ ; } while ( s . size ( ) != 0 ) { int tp = s . peek ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j <= 10 ; j ++ ) { int x = tp * 10 + j ; if ( ( x <= n ) ) { s . push ( x ) ; result ++ ; } } } } return result ; }
public static double maxAverageOfPath ( double [ ] [ ] cost , int N ) { double [ ] [ ] dp = new double [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; dp [ 0 ] [ j ] = cost [ 0 ] [ 0 ] ; } } for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; } for ( int j = 1 ; j < N ; j ++ ) { dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; } } return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
public static void formSieve ( ) { int MAX = 1000000 ; int [ ] sievePrime = new int [ MAX + 4 ] ; int [ ] sieveCount = new int [ MAX + 4 ] ; for ( int i = 0 ; i < sieveCount . length ; i ++ ) { sievePrime [ i ] = 0 ; } { sievePrime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sievePrime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sievePrime [ j ] == 0 ) { sievePrime [ j ] = 1 ; sieveCount [ i ] ++ ; } } } } } }
public static int getDistance ( int [ ] array , int start , int end ) { if ( array . length < start ) { return - 1 ; } if ( start == end ) { return 0 ; } if ( start == 0 ) { return 0 ; } if ( start == end ) { return 1 ; } if ( start == end ) { return 2 ; } if ( start == end ) { return 3 ; } if ( start == end ) { return 4 ; } if ( start == end ) { return 5 ; } if ( start == end ) { return 6 ; } if ( start == end ) { return 7 ; } if ( start == end ) { return 8 ; } if ( start == end ) { return 9 ; } if ( start == end ) { return 10 ; } if ( start == end ) { return 11 ; } if ( start == end ) { return 12 ; } if ( start == end ) { return 13 ; } if ( start == end ) { return 14 ; } if ( start == end ) { return 15 ; } return - 1 ; }
public static int waysToSplit ( String s ) { int n = s . length ( ) ; int answer = 0 ; int [ ] prefix = new int [ n ] ; int [ ] suffix = new int [ n ] ; int [ ] seen = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int prev = ( i - 1 >= 0 ) ? prefix [ i - 1 ] : 0 ; if ( ( seen [ ( int ) s . charAt ( i ) - ( int ) ' a ' ) == 0 ) { prefix [ i ] += ( prev + 1 ) ; } else { prefix [ i ] = prev ; } seen [ ( int ) s . charAt ( i ) - ( int ) ' a ' ) ; } seen = new int [ seen . length ] ; suffix [ n - 1 ] = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { int prev = suffix [ i ] ; if ( ( seen [ ( int ) s . charAt ( i ) - ( int ) ' a ' ) == 0 ) { suffix [ i - 1 ] += ( prev + 1 ) ; } else { suffix [ i - 1 ] = prev ; } seen [ ( int ) s . charAt ( i ) - ( int ) ' a ' ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( prefix [ i ] == suffix [ i ] ) ) { answer ++ ; } } return answer ; }
public static String compute ( ) { final int TURNS = 15 ; final int [ ] [ ] ways = new int [ TURNS + 1 ] [ ] ; ways [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= TURNS ; i ++ ) { int [ ] row = new int [ i ] ; for ( int j = 0 ; j < i + 1 ; j ++ ) { int temp = 0 ; if ( j < i ) { temp = ways [ i - 1 ] [ j ] * i ; } if ( j > 0 ) { temp += ways [ i - 1 ] [ j - 1 ] ; } row [ j ] = temp ; } ways [ i ] [ j ] = row ; } int numer = ways [ TURNS / 2 + 1 ] [ TURNS + 1 ] ; for ( int i = TURNS / 2 + 1 ; i <= TURNS ; i ++ ) { int denom = Math . factorial ( TURNS + 1 ) ; return String . valueOf ( denom / numer ) ; } if ( Class . isPrimitive ( " java . util . logging . Logger " ) ) { System . out . println ( compute ( ) ) ; } return String . valueOf ( ) ; }
public static String getCountry ( String country ) { String country = country . toLowerCase ( ) ; if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 ) ; } return country ; }
public static void merge ( int ar1 [ ] , int ar2 [ ] , int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int last = ar1 [ m - 1 ] ; int j = m - 2 ; while ( ( j >= 0 ) && ( ar1 [ j ] > ar2 [ i ] ) ) { ar1 [ j + 1 ] = ar1 [ j ] ; j -- ; } if ( ( j != m - 2 ) || ( last > ar2 [ i ] ) ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } int ar1 [ ] = { 1 , 5 , 9 , 10 , 15 , 20 } ; ar2 [ ] = { 2 , 3 , 8 , 13 } ; m = ar1 . length ; n = ar2 . length ; merge ( ar1 , ar2 , m , n ) ; System . out . print ( " After ▁ Merging ▁ \n First ▁ Array : ▁ " ) ; System . out . println ( ar1 ) ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) ) { return b ; } return gcd ( b % a , a ) ; }
public static int sum ( int [ ] array ) { int [ ] ls = new int [ array . length ] , sum = 0 ; ls [ 0 ] = array [ 0 ] ; ls [ 1 ] = array [ 1 ] ; ls [ 2 ] = array [ 2 ] ; if ( ls [ 1 ] - ls [ 0 ] < d ) { sum += ( d - ls [ 1 ] + ls [ 0 ] ) ; } if ( ls [ 2 ] - ls [ 1 ] < d ) { sum += ( d - ls [ 2 ] + ls [ 1 ] ) ; } return sum ; }
public static int countWaysUtil ( int n , int parts , int nextPart ) { if ( ( parts == 0 && n == 0 ) ) { return 1 ; } if ( ( n <= 0 ) || ( parts <= 0 ) ) { return 0 ; } if ( ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) ) { return dp [ n ] [ nextPart ] [ parts ] ; } int ans = 0 ; for ( int i = nextPart ; i <= n ; i ++ ) { ans += countWaysUtil ( n - i , parts - 1 , i ) ; } dp [ n ] [ nextPart ] [ parts ] = ans ; return ( ans ) ; }
public static int findK ( int a , int b ) { if ( ( ( a + b ) % 2 ) == 0 ) { return ( ( a + b ) / 2 ) ; } return - 1 ; }
public static int getSum ( int x , int y , int z ) { int N = 101 ; int mod = ( int ) 1e9 + 7 ; int [ ] [ ] [ ] exactSum = new int [ N ] [ N ] [ N ] ; int [ ] [ ] [ ] exactNum = new int [ N ] [ N ] [ N ] ; { int ans = 0 ; exactNum [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < x + 1 ; i ++ ) { for ( int j = 0 ; j < y + 1 ; j ++ ) { for ( int k = 0 ; k < z + 1 ; k ++ ) { if ( ( i > 0 ) ) { exactSum [ i ] [ j ] [ k ] += ( exactSum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactNum [ i - 1 ] [ j ] [ k ] ) % mod ; exactNum [ i ] [ j ] [ k ] += exactNum [ i - 1 ] [ j ] [ k ] % mod ; } if ( ( j > 0 ) ) { exactSum [ i ] [ j ] [ k ] += ( exactSum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactNum [ i ] [ j - 1 ] [ k ] ) % mod ; exactNum [ i ] [ j ] [ k ] += exactNum [ i ] [ j - 1 ] [ k ] % mod ; } if ( ( k > 0 ) ) { exactSum [ i ] [ j ] [ k ] += ( exactSum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactNum [ i ] [ j ] [ k - 1 ] ) % mod ; exactNum [ i ] [ j ] [ k ] += exactNum [ i ] [ j ] [ k - 1 ] % mod ; } ans += exactSum [ i ] [ j ] [ k ] % mod ; ans %= mod ; } } } return ans ; }
public static boolean isValidString ( String str ) { int [ ] freq = new int [ str . length ( ) ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ ( int ) str . charAt ( i ) - ' a ' ] ++ ; } int freq1 = 0 ; int countFreq1 = 0 ; for ( int i = 0 ; i < CHARS ; i ++ ) { if ( ( freq [ i ] != 0 ) ) { freq1 = freq [ i ] ; countFreq1 = 1 ; break ; } } int freq2 = 0 ; int countFreq2 = 0 ; for ( int j = i + 1 ; j < CHARS ; j ++ ) { if ( ( freq [ j ] != 0 ) ) { if ( ( freq [ j ] == freq1 ) ) { countFreq1 ++ ; } else { countFreq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( ( freq [ k ] != 0 ) ) { if ( ( freq [ k ] == freq1 ) ) { countFreq1 ++ ; } if ( ( freq [ k ] == freq2 ) ) { countFreq2 ++ ; } else { return false ; } } if ( ( countFreq1 > 1 ) && ( countFreq2 > 1 ) ) { return false ; } } return true ; }
public static int t ( String input ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { if ( i % 2 == 0 ) { if ( sb . charAt ( i ) == ' a ' ) { sb . setCharAt ( i , ' b ' ) ; } else { sb . setCharAt ( i , ' a ' ) ; } } else { if ( sb . charAt ( i ) == ' z ' ) { sb . setCharAt ( i , ' y ' ) ; } else { sb . setCharAt ( i , ' z ' ) ; } } } System . out . println ( sb . toString ( ) ) ; t -- ; return t ; }
static int findMinimumSubsequences ( String A , String B ) { int numberOfSubsequences = 1 ; int sizeOfB = B . length ( ) ; int sizeOfA = A . length ( ) ; int inf = 1000000 ; int [ ] [ ] next = new int [ sizeOfB ] [ 26 ] ; for ( int i = 0 ; i < sizeOfB ; i ++ ) { next [ ( int ) B . charAt ( i ) - ( int ) ' a ' ] [ i ] = i ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = sizeOfB - 2 ; j >= 0 ; j -- ) { if ( ( next [ i ] [ j ] == inf ) ) { next [ i ] [ j ] = next [ i ] [ j + 1 ] ; } } } int pos = 0 ; int i = 0 ; while ( ( i < sizeOfA ) ) { if ( ( pos == 0 ) && ( next [ ( int ) A . charAt ( i ) - ( int ) ' a ' ] [ pos ] == inf ) ) { numberOfSubsequences = - 1 ; break ; } else if ( ( pos < sizeOfB ) && ( next [ ( int ) A . charAt ( i ) - ( int ) ' a ' ] [ pos ] < inf ) ) { int nextIndex = next [ ( int ) A . charAt ( i ) - ( int ) ' a ' ] [ pos ] + 1 ; pos = nextIndex ; i ++ ; } else { numberOfSubsequences ++ ; pos = 0 ; } } return numberOfSubsequences ; }
public static String getRandom ( String input ) { String [ ] parts = input . split ( " ▁ " ) ; for ( int i = 0 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length ( ) == 1 ) { parts [ i ] = parts [ i ] . substring ( 0 , i ) ; } else { parts [ i ] = parts [ i ] . substring ( i , i + 1 ) ; } } return parts [ parts . length - 1 ] ; }
public static void FindRank ( int [ ] arr , int length ) { System . out . print ( 1 ) ; for ( int i = 1 ; i < length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j <= i ; j ++ ) { if ( ( arr [ j ] > arr [ i ] ) ) { rank = rank + 1 ; } } System . out . print ( rank ) ; } if ( Class . forName ( " java . util . regex . regex " ) . equals ( " java . util . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex
public static String toBin ( String input ) { final String [ ] arr = new String [ ] { " " } ; Arrays . sort ( arr ) ; final StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { sb . append ( arr [ i ] ) ; sb . append ( " , ▁ " ) ; } sb . append ( arr [ arr . length - 1 ] ) ; sb . append ( " ? ? ? " ) ; sb . append ( arr [ arr . length - 1 ] ) ; sb . append ( " ▁ = ▁ " ) ; sb . append ( arr [ arr . length - 2 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 2 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 1 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 2 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 2 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 2 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 1 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 2 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 1 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 2 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 1 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 2 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 1 ] ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 2 ] ) ; sb . append ( " ▁ " ) ; sb . append ( " ▁ " ) ; sb . append ( arr [ arr . length - 1 ] ) ; return sb . toString ( ) ; }
public static int firstkdigits ( int n , int k ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product *= n ; } while ( ( ( product / Math . pow ( 10 , k ) ) != 0 ) ) { product = product / 10 ; } return product ; }
public static int gcd ( int a , int b ) { int m = 0 ; try { m = Integer . parseInt ( " " ) ; } catch ( NumberFormatException e ) { m = 0 ; } return m ; }
public static int getDistance ( int [ ] array ) { int distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == array [ i ] ) distance += array [ i ] ; } return distance ; }
public static int complement ( int num ) { int i = 0 ; int len = 0 ; double comp = 0 ; int temp = num ; while ( ( i = 1 ) != 0 ) { len ++ ; num = ( int ) ( num / 10 ) ; if ( ( Math . abs ( num ) == 0 ) ) break ; } num = temp ; comp = Math . pow ( 10 , len ) - num ; return ( int ) comp ; }
public static int countUnsetBits ( int n ) { final int x = n ; n |= n >>> 1 ; n |= n >>> 2 ; n |= n >>> 4 ; n |= n >>> 8 ; n |= n >>> 16 ; final double t = Math . log ( x ^ n ) ; return Math . floor ( t ) ; }
public static int minOperations ( int [ ] arr , int n ) { int result = 0 ; int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i <= n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int maxi = Math . max ( arr . length , 0 ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi && j < i ; j ++ ) { freq [ j ] = 0 ; } result ++ ; } } return result ; }
public static int totalWays ( int N , int M , int X ) { int [ ] [ ] dp = new int [ 2 ] [ N + 1 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) { for ( int j = 0 ; j < dp [ N + 1 ] . length ; j ++ ) { dp [ i ] [ j ] [ 0 ] = 1 ; } } if ( ( X == 1 ) ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; } if ( Class . isPrimitive ( String . class ) ) { N = 4 ; M = 3 ; X = 2 ; System . out . println ( totalWays ( N , M , X ) ) ; } return dp [ N - 1 ] [ 0 ] ; }
static int getMinNum ( int a , int b , int c ) { if ( ( c < a || c > b ) ) { return c ; } int x = ( ( b / c ) * c ) + c ; return x ; }
public static int getProfession ( int [ ] pds ) { int profession = pds . length ; int profession = pds [ profession ] ; return profession ; }
@ Operator ( " protect " ) public static void protect ( int N , int M ) { List < List < Integer > > DP = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { DP . add ( Collections . < Integer > of ( Integer . parseInt ( input ( ) ) ) ) ; } Collections . sort ( DP , new Comparator < Integer > ( ) { public int compare ( Integer o1 , Integer o2 ) { int nokori = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( M > DP . get ( N - i - 1 ) . get ( 0 ) ) { M -= DP . get ( N - i - 1 ) . get ( 0 ) ; DP . remove ( -- i ) ; } else if ( M <= DP . get ( N - i - 1 ) . get ( 0 ) ) { nokori = ( DP . get ( N - i - 1 ) . get ( 0 ) - M ) * DP . get ( N - i - 1 ) . get ( 1 ) ; M = 0 ; DP . remove ( -- i ) ; break ; } } return nokori ; } } ) ; for ( int i = 0 ; i < DP . size ( ) ; i ++ ) { nokori += DP . get ( i ) . get ( 0 ) * DP . get ( i ) . get ( 1 ) ; } System . out . println ( nokori ) ; while ( true ) { String [ ] NM = input ( ) ; N = Integer . parseInt ( NM [ 0 ] ) ; M = Integer . parseInt ( NM [ 1 ] ) ; if ( N == 0 ) break ; protect ( N , M ) ; } }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; array [ 0 ] = 0 ; array [ 1 ] = 1 ; array [ 2 ] = 2 ; array [ 2 ] = 2 ; array [ 3 ] = 2 ; array [ 4 ] = 3 ; array [ 5 ] = 4 ; array [ 6 ] = 5 ; array [ 7 ] = 6 ; array [ 8 ] = 7 ; array [ 9 ] = 8 ; array [ 10 ] = 9 ; array [ 11 ] = 10 ; array [ 12 ] = 11 ; array [ 13 ] = 12 ; array [ 14 ] = 13 ; array [ 15 ] = 14 ; array [ 16 ] = 15 ; array [ 17 ] = 15 ; array [ 18 ] = 15 ; array [ 19 ] = 16 ; array [ 20 ] = 17 ; array [ 21 ] = 18 ; array [ 22 ] = 19 ; array [ 23 ] = 19 ; array [ 24 ] = 19 ; array [ 25 ] = 20 ; array [ 26 ] = 27 ; array [ 27 ] = 28 ; array [ 27 ] = 29 ; array [ 27 ] = 29 ; array [ 28 ] = 31 ; array [ 29 ] = 31 ; array [ 29 ] = 31 ; array [ 31 ] = 31 ; array [ 37 ] = 31 ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] = 37 ; array [ 37 ] ; array [ 37 ] = 37 ; array [ 37 ] ; array [ 37 ] = 37 ; array [ 37 ] ; array [ 37 ] = 37 ; array [ 37 ] ; array [ 37 ] = 37 ; array [ 37 ] ; array [ 37 ] = 37 ; array [ 37 ] ; array [ 37 ] = 37 ; array [ 37 ] ; array [ 37 ] = 37 ; array [ 37 ] ; array [ 37 ] = 37 ; array [ 37 ] ; array [ 37 ] = 37 ; return array [ 37 ] ; }
static int countWays ( int [ ] arr , int m , int N ) { int [ ] count = new int [ N + 1 ] ; count [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { count [ i ] = 0 ; } count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( i >= arr [ j ] ) ) { count [ i ] += count [ i - arr [ j ] ] ; } } } return count [ N ] ; }
public static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) { return 1 ; } else { return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) ; } x = 3 ; return x ; }
public static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hm . put ( a [ i ] , hm . getOrDefault ( a [ i ] , 0 ) + 1 ) ; } int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm . get ( a [ i ] ) ; if ( ( hm . get ( a [ i ] ) ) > 0 ) { System . out . println ( a [ i ] + " - > " + cumul ) ; } hm . put ( a [ i ] , 0 ) ; } a = new int [ ] { 1 , 3 , 2 , 4 , 2 , 1 } ; n = a . length ; countFreq ( a , n ) ; }
public static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 ; int possibleB = 0 ; int possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ; if ( ( numbersInRange < 3 ) ) { flag = false ; } else if ( ( numbersInRange > 3 ) ) { flag = true ; if ( ( ( L % 2 ) > 0 ) ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ( ( L % 2 ) == 0 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( ( flag ) == true ) { System . out . println ( " ( " + possibleA + " , " + possibleB + " , " + possibleC + " ) ▁ is ▁ one ▁ such " + " ▁ possible ▁ triplet ▁ between " + L + " and " + R ) ; } else { System . out . println ( " No ▁ Such ▁ Triplet ▁ exists ▁ between " + L + " and " + R ) ; } L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; }
public static String conversion ( String charSet , String str1 ) { String s2 = " " ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { s2 += str1 . charAt ( i ) ; } return s2 ; if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { String alphabets = " abcdefghijklmnopqrstuvwxyz " ; charSet = " qwertyuiopasdfghjklzxcvbnm " ; str1 = " egrt " ; System . out . println ( conversion ( charSet , str1 ) ) ; } return null ; }
public static void generateNumber ( int count , int [ ] a , int n , int num , int k ) { if ( k == count ) { s . add ( num ) ; return ; } for ( int i = 0 ; i <= n ; i ++ ) { generateNumber ( count + 1 , a , n , num + a [ i ] , k ) ; } }
public static int product ( int x ) { int prod = 1 ; while ( ( x = x ) != 0 ) { prod *= ( x % 10 ) ; x /= 10 ; } return prod ; }
public static int [ ] getPrimeArray ( int [ ] arr ) { int [ ] isPrime = new int [ 100005 ] ; { isPrime [ 1 ] = false ; int i = 2 ; while ( i * i < 100005 ) { if ( ( isPrime [ i ] = true ) ) { int j = 2 * i ; while ( j < 100005 ) { isPrime [ j ] = false ; j += i ; } } i ++ ; } return isPrime ; } { int num = 0 ; while ( ( num = findPrime ( n ) ) != 0 ) { if ( isPrime [ num ] ) { return num ; } num ++ ; } return 0 ; } { int minNumber = 0 ; for ( int i = 0 ; ; i != arr . length ; i ++ ) { minNumber += arr [ i ] ; } if ( isPrime [ s ] == true ) { return 0 ; } int num = findPrime ( s ) ; return num - s ; } int [ ] arr = new int [ ] { 2 , 4 , 6 , 8 , 12 } ; System . out . println ( minNumber ) ; return arr ; }
public static int getMinSum ( int [ ] arr , int n ) { int [ ] bitsCount = new int [ MAX ] ; int maxBit = 0 ; int sum = 0 ; int ans = 0 ; for ( int d = 0 ; d < n ; d ++ ) { int e = arr [ d ] ; int f = 0 ; while ( ( e > 0 ) ) { int rem = e % 2 ; e = e / 2 ; if ( ( rem == 1 ) ) { bitsCount [ f ] += rem ; } f ++ ; } maxBit = Math . max ( maxBit , f ) ; } for ( int d = 0 ; d < maxBit ; d ++ ) { int temp = Math . pow ( 2 , d ) ; if ( ( bitsCount [ d ] > n / 2 ) ) { ans = ans + temp ; } } for ( int d = 0 ; d < n ; d ++ ) { arr [ d ] = arr [ d ] ^ ans ; sum = sum + arr [ d ] ; } return sum ; } if ( Class . isPrimitive ( ) ) { int [ ] arr = { 3 , 5 , 7 , 11 , 15 } ; int n = arr . length ; System . out . println ( getMinSum ( arr , n ) ) ; } return 0 ; }
public static int getLargestIndex ( int [ ] array , int index ) { if ( array == null ) { return - 1 ; } if ( index == array . length ) { return - 1 ; } if ( index == array . length ) { return array [ index ] ; } if ( index == array . length ) { return array [ index ] ; } if ( index == array . length ) { return array [ index ] ; } if ( index == array . length ) { return array [ index ] ; } return array [ index ] ; }
public static int [ ] GetMinimumEnergySpent ( int n , int [ ] shortcuts ) { final int [ ] energySpent = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { energySpent [ i ] = i ; } final LinkedList < Integer > queue = new LinkedList < > ( ) ; while ( queue . size ( ) > 0 ) { final int idx = queue . removeFirst ( ) ; if ( idx < n - 1 && energySpent [ idx + 1 ] > energySpent [ idx ] + 1 ) { energySpent [ idx + 1 ] = energySpent [ idx ] + 1 ; queue . add ( idx + 1 ) ; } if ( idx > 0 && energySpent [ idx - 1 ] > energySpent [ idx ] + 1 ) { energySpent [ idx - 1 ] = energySpent [ idx ] + 1 ; queue . add ( idx - 1 ) ; } if ( energySpent [ idx ] + 1 < energySpent [ shortcuts [ idx ] ] ) { energySpent [ shortcuts [ idx ] ] = energySpent [ idx ] + 1 ; queue . add ( shortcuts [ idx ] ) ; } } return energySpent ; } if ( String . class . equals ( String . class ) ) { n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; shortcuts = Arrays . stream ( Arrays . split ( " ▁ " ) ) . map ( Integer :: valueOf ) . toArray ( Integer :: valueOf ) ; final String [ ] energySpentStr = Arrays . stream ( ) . map ( Integer :: valueOf ) . toArray ( String [ ] :: valueOf ) ; System . out . println ( energySpentStr ) ; } return energySpentStr ; }
public static int strangeBDParty ( int n , int m , int [ ] k , int [ ] c ) { Arrays . sort ( k , Collections . reverseOrder ( ) ) ; int cost = 0 ; int l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( l < m && c [ l ] < c [ k [ i ] - 1 ] ) { cost += c [ l ] ; l ++ ; } else { cost += c [ k [ i ] - 1 ] ; } } return cost ; int rep = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; for ( int i = 0 ; i < rep ; i ++ ) { n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; m = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; k = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; c = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; System . out . println ( strangeBDParty ( n , m , k , c ) ) ; } return cost ; }
static int findMaximumNum ( int [ ] arr , int n ) { int i = n ; while ( ( i >= 1 ) ) { int count = 0 ; for ( int j = 0 ; j < n ; j += 1 ) { if ( ( i <= arr [ j ] ) ) { count ++ ; } } if ( ( count >= i ) ) { return i ; } i -- ; } return 1 ; }
public static String [ ] getStrings ( String [ ] strings ) { String [ ] result = new String [ strings . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { String [ ] l = strings [ i ] . split ( " ▁ " ) ; int a = Integer . parseInt ( l [ 1 ] ) ; int b = Integer . parseInt ( l [ 2 ] ) + 1 ; if ( l [ 0 ] . equals ( " print " ) ) { System . out . println ( result [ a ] . substring ( a , b ) ) ; } else if ( l [ 0 ] . equals ( " reverse " ) ) { result [ a ] = new String ( s , a , b ) ; } else if ( l [ 0 ] . equals ( " replace " ) ) { result [ a ] = l [ 3 ] ; } } return result ; }
public static int solve ( int [ ] A , int n ) { int [ ] [ ] dp = new int [ 2000 ] [ 2000 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) { dp [ i ] [ 0 ] = 0 ; } int flag = 1 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += A [ i ] ; } for ( int i = - sum ; i <= sum ; i ++ ) { dp [ 0 ] [ i ] = 10 * 9 ; } dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = - sum ; j <= sum ; j ++ ) { dp [ flag ] [ j ] = 10 * 9 ; if ( ( j - A [ i - 1 ] <= sum && j - A [ i - 1 ] >= - sum ) ) { dp [ flag ] [ j ] = dp [ flag ^ 1 ] [ j - A [ i - 1 ] ] ; } if ( ( j + A [ i - 1 ] <= sum && j + A [ i - 1 ] >= - sum && dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] != 10 * 9 ) ) { dp [ flag ] [ j ] = Math . min ( dp [ flag ] [ j ] , dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] + 1 ) ; } } flag = flag ^ 1 ; } for ( int i = 0 ; i < sum + 1 ; i ++ ) { if ( ( dp [ flag ^ 1 ] [ i ] != 10 * 9 ) ) { return dp [ flag ^ 1 ] [ i ] ; } } return n - 1 ; } int [ ] arr = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; n = arr . length ; System . out . println ( solve ( arr , n ) ) ; }
public static String getInput ( ) { StringBuilder sb = new StringBuilder ( ) ; try { sb . append ( System . getProperty ( " line . separator " ) ) ; } catch ( NullPointerException e ) { break ; } String [ ] N = new String ( System . getProperty ( " line . separator " ) ) . split ( " ▁ " ) ; for ( int l = 0 ; l < N . length ; l ++ ) { double [ ] Points = new double [ N . length ] ; for ( int i = 0 ; i < N [ l ] . length ; i ++ ) { Points [ i ] = Double . parseDouble ( N [ l ] [ i ] ) ; } int [ ] P = new int [ 8 ] ; for ( int i = 0 ; i < P . length ; i ++ ) { P [ i ] = ( int ) ( Points [ i ] * 10 * 5 ) ; } int [ ] AB = { P [ 2 ] - P [ 0 ] , P [ 3 ] - P [ 1 ] } ; int [ ] CD = { P [ 6 ] - P [ 4 ] , P [ 7 ] - P [ 5 ] } ; if ( AB [ 0 ] * CD [ 0 ] + AB [ 1 ] * CD [ 1 ] == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } return sb . toString ( ) ; }
public static String fizzBuzz ( ) { int c = 1 ; StringBuilder sb = new StringBuilder ( ) ; do { String res = " " ; if ( c % 3 == 0 ) { res = res + " Fizz " ; } if ( c % 5 == 0 ) { res = res + " Buzz " ; } if ( res . equals ( " " ) ) { sb . append ( c ) ; } else { sb . append ( res ) ; } c ++ ; } while ( true ) ; int m = Integer . parseInt ( sb . toString ( ) ) ; int n = Integer . parseInt ( sb . toString ( ) ) ; if ( m == 0 ) break ; List < Integer > player = new LinkedList < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { int inp = Integer . parseInt ( sb . toString ( ) ) ; if ( player . size ( ) > 1 ) { if ( inp != ( ( int ) fb ) ) { player . remove ( p ) ; p = p % player . size ( ) ; } else { p = ( p + 1 ) % player . size ( ) ; } } } String result = sb . toString ( ) + 1 ; if ( player . size ( ) > 1 ) { for ( int pi = 1 ; pi < player . size ( ) ; pi ++ ) { result += " ▁ " + ( pi + 1 ) ; } } System . out . println ( result ) ; return result ; }
public static int [ ] [ ] nCr ( int n , int r ) { int l [ ] [ ] = new int [ 1001 ] [ 1001 ] ; for ( int i = 0 ; i < l . length ; i ++ ) { for ( int j = 0 ; j < l [ i ] . length ; j ++ ) { l [ i ] [ j ] = 0 ; } } return l ; }
public static int max ( int a , int b , int c , int d ) { return ( int ) ( Math . max ( 0 , Math . min ( b , d ) - Math . max ( a , c ) ) ) ; }
public static void calculate ( int [ ] a , int [ ] b , int n , int m ) { double mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) { if ( ( b [ i ] != 0 ) ) mul = mul * b [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { double x = Math . floor ( a [ i ] / mul ) ; System . out . print ( x + " ▁ " ) ; } }
public static int getRandom ( ) { int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int a = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int b = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int c = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; return a - b + b - c ; }
@ SafeVarargs public static String getRandom ( ) { final int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; final String s = System . getProperty ( " line . separator " ) ; int ans = 0 ; int left = 0 , right = 0 ; int i = 0 ; while ( i < n && s . charAt ( i ) != ' > ' ) { i ++ ; } int j = n - 1 ; while ( j >= 0 && s . charAt ( j ) != ' < ' ) { j -- ; } System . out . println ( Math . min ( i , n - j - 1 ) ) ; return s ; }
public static int log2 ( int n ) { int x = Integer . parseInt ( input ) ; x = 1 ; while ( Math . log2 ( n ) % 1 != 0 ) { x += 1 ; n -= 2 * ( ( int ) Math . log2 ( n ) ) ; } return x ; }
public static int pSpeed ( ) { int dSpeed = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int time = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int wait = Integer . parseInt ( System . getProperty ( " wait . " ) ) ; int distence = Integer . parseInt ( System . getProperty ( " distence . " ) ) ; int positionP = time * pSpeed ; double positionD = 0 ; int counter = 0 ; int timeCounter = 0 ; while ( positionP < distence && dSpeed > pSpeed ) { timeD = positionP / ( dSpeed - pSpeed ) ; positionP += ( timeD * pSpeed ) ; if ( positionP >= distence ) break ; double tBack = positionP / dSpeed + wait ; positionP += ( tBack * pSpeed ) ; counter ++ ; } return counter ; }
public static String getCurrentTime ( ) { String timeDuration = System . getProperty ( " time . duration " ) ; int currentTimeMin = Integer . parseInt ( timeDuration . substring ( 0 , 2 ) ) * 60 + Integer . parseInt ( timeDuration . substring ( 3 ) ) ; int timeDurationMin = Integer . parseInt ( timeDuration . substring ( 0 , 2 ) ) * 60 + Integer . parseInt ( timeDuration . substring ( 3 ) ) ; int tMin = currentTimeMin - timeDurationMin ; if ( currentTimeMin < timeDurationMin ) { tMin = 24 * 60 - Math . abs ( tMin ) ; } String hour = tMin / 60 < 10 ? "0" + String . valueOf ( tMin / 60 ) : String . valueOf ( tMin / 60 ) ; String minute = tMin % 60 < 10 ? "0" + String . valueOf ( tMin % 60 ) : String . valueOf ( tMin % 60 ) ; System . out . println ( f " { hour } : { minute } " ) ; return hour ; }
public static int longestAlternatingSubarray ( int [ ] a , int n ) { int longest = 1 ; int cnt = 1 ; int i = 1 ; while ( i < n ) { if ( ( a [ i ] * a [ i - 1 ] ) < 0 ) { cnt = cnt + 1 ; longest = Math . max ( longest , cnt ) ; } else { cnt = 1 ; } i = i + 1 ; } return longest ; }
static void checkTypeOfTriangle ( int a , int b , int c ) { double sqa = Math . pow ( a , 2 ) ; double sqb = Math . pow ( b , 2 ) ; double sqc = Math . pow ( c , 2 ) ; if ( ( sqa == sqa + sqb ) || ( sqb == sqa + sqc ) || ( sqc == sqa + sqb ) ) { System . out . println ( " Right - angled ▁ Triangle " ) ; } else if ( ( sqa > sqc + sqb ) || ( sqb > sqa + sqc ) || ( sqc > sqa + sqb ) ) { System . out . println ( " Obtuse - angled ▁ Triangle " ) ; } else { System . out . println ( " Acute - angled ▁ Triangle " ) ; } if ( Class . forName ( " java . util . regex . regex . regex " ) . equals ( " java . util . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex
public static void countSubsequence ( String s , int n ) { int cntG = 0 ; int cntF = 0 ; int result = 0 ; int C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == ' G ' ) ) { cntG ++ ; result += C ; continue ; } if ( ( s . charAt ( i ) == ' F ' ) ) { cntF ++ ; C += cntG ; continue ; } else { continue ; } } System . out . println ( result ) ; }
public static int getDistance ( String [ ] values ) { int htop = 0 ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( values [ i ] . length ( ) > 0 ) { if ( values [ i ] . length ( ) < 2 ) { values [ i ] = values [ i ] . substring ( 0 , 1 ) ; } else { values [ i ] = values [ i ] . substring ( 1 , 2 ) ; } } } return 0 ; }
public static int countSteps ( int n ) { int steps = 0 ; while ( ( n = Math . floor ( n * ( 1 / 3 ) ) ) != 0 ) { int largest = Math . floor ( n * ( 1 / 3 ) ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; }
public static final String getSortKey ( String [ ] arr ) { String [ ] result = new String [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { result [ i ] = arr [ i ] ; } return result [ 0 ] ; }
public static int getDistance ( int [ ] array ) { int distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == array [ i ] ) { distance += i ; } } return distance ; }
public static int bitsonCount ( int x ) { return Integer . bitsonCount ( x ) ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int [ ] a = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int s = Arrays . stream ( a ) . mapToInt ( i -> i ) . sum ( ) ; if ( s % ( ( n + 1 ) * n / 2 ) != 0 ) { System . out . println ( " NO " ) ; return ; } s /= ( ( n + 1 ) * n / 2 ) ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = a [ ( i + 1 ) % n ] - a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] -= s ; } for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] > 0 || b [ i ] % n != 0 ) { System . out . println ( " NO " ) ; return ; } } System . out . println ( " YES " ) ; }
public static int maxProd ( int N ) { if ( ( N == 0 ) ) { return 1 ; } if ( ( N < 10 ) ) { return N ; } return Math . max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForProposi
public static int getDistance ( int [ ] array , int [ ] values ) { int sum = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { sum += array [ i ] * array [ i ] ; } int [ ] A = new int [ array . length ] , B = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { int x = array [ i ] ; int y = array [ i ] ; if ( x == 0 ) { B [ i ] = Math . abs ( y ) ; } else { A [ i ] = Math . abs ( x ) ; } } Arrays . sort ( A ) ; Arrays . sort ( B ) ; double ans = 0 ; for ( int i = 0 ; i < values . length ; i ++ ) { ans += ( ( B [ i ] ) * ( B [ i ] ) + ( A [ i ] ) * ( A [ i ] ) ) * ( 0.5 ) ; } System . out . println ( ans ) ; return sum ; }
static int countNonDecreasing ( int n ) { int N = 10 ; int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count = ( int ) ( count * ( N + i - 1 ) ) ; count = ( int ) ( count / i ) ; } return count ; }
public static int reduceString ( String s , int l ) { int count = 1 ; int steps = 0 ; for ( int i = 1 ; i < l ; i ++ ) { if ( ( s . charAt ( i ) == s . charAt ( i - 1 ) ) ) { count ++ ; } else { steps += ( ( int ) ( count / 2 ) ) ; count = 1 ; } } steps += ( ( int ) ( count / 2 ) ) ; return steps ; }
public static int getRandom ( String input ) { int A = Integer . parseInt ( input ) ; int B = Integer . parseInt ( input ) ; if ( A <= B ) { System . out . println ( " Impossible " ) ; System . exit ( 0 ) ; } Stack < Integer > chain = new Stack < > ( ) ; int N = A + B ; { System . out . println ( " ? ▁ " + i + " ▁ " + j ) ; return input . charAt ( 0 ) == ' Y ' ? 1 : 0 ; } for ( int i = 0 ; i <= N ; i ++ ) { if ( chain . size ( ) == 0 ) { chain . push ( i ) ; continue ; } int last = chain . peek ( ) ; if ( i == last ) { chain . push ( i ) ; } else { chain . pop ( ) ; } } int main = chain . pop ( ) ; StringBuilder ret = new StringBuilder ( ) ; for ( int x = 0 ; x <= N ; x ++ ) { ret . append ( ( i == main ) ? '1' : '0' ) ; } System . out . println ( " ! ▁ " + ret . toString ( ) ) ; return ret . size ( ) ; }
public static int [ ] [ ] getNegativeInstances ( ) { int [ ] [ ] result = new int [ ] [ ] { { 0 , 0 } , { 1 , 0 } , { 2 , 0 } , { 3 , 0 } , { 4 , 0 } , { 5 , 0 } , { 6 , 0 } , { 7 , 0 } , { 8 , 0 } , { 9 , 0 } } ; return result ; }
public static int calculateFactors ( int n ) { int mod = 1000000007 ; int ans ; int i ; int cnt ; int n ; int ans ; for ( i = 0 ; i < n ; i ++ ) { n = n / 2 ; if ( ( n % 2 ) == 0 ) { cnt ++ ; n = n / 2 ; } if ( ( cnt ) != 0 ) { ans = mult ( ans , ( cnt + 1 ) ) ; } } for ( i = 3 ; i < ( int ) Math . sqrt ( n ) ; i += 2 ) { cnt = 0 ; while ( ( n % i ) == 0 ) { cnt ++ ; n = n / i ; } if ( ( cnt ) != 0 ) { ans = mult ( ans , ( cnt + 1 ) ) ; } } if ( ( n > 2 ) != 0 ) { ans = mult ( ans , 2 ) ; } return ans % mod ; }
public static String getValidString ( String s ) { String result = " " ; int i = 0 ; while ( i < s . length ( ) ) { if ( s . charAt ( i ) == ' . ' ) { result += '0' ; } else { i ++ ; if ( s . charAt ( i ) == ' . ' ) { result += '1' ; } else { result += '2' ; } } i ++ ; } return result ; }
public static int maxAbsDiff ( int [ ] arr , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
public static int getRandom ( ) { final int [ ] array = new int [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 8 , 9 , 10 , 11 , 11 , 12 , 13 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 26 , 27 , 28 , 26 , 27 , 28 , 26 , 27 , 28 , 26 , 27 , 28 , 26 , 27 , 28 , 26 , 27 , 27 , 28 , 26 , 27 , 27 , 28 , 26 , 27 , 27 , 28 , 26 , 27 , 27 , 28 , 27 , 28 , 27 , 28 , 27 , 28 , 27 , 28 , 27 , 28 , 27 , 28 , 27 , 28 , 27 , 28 , 27 , 28 , 27 , 28 , 27 , 28 , 27 , 28 , 27 , 28 , 28 , 27 , 28 , 28 , 27 , 28 , 28 , 27 , 28 , 28 , 27 , 28 , 28 , 27 , 28 , 28 , 27 , 28 , 28 , 28 , 27 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 } ; return array . length
public static int minRemove ( String [ ] a , String [ ] b , int n , int m ) { Map < String , Integer > countA = new HashMap < > ( ) ; Map < String , Integer > countB = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { countA . put ( a [ i ] , countA . getOrDefault ( a [ i ] , 0 ) + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { countB . put ( b [ i ] , countB . getOrDefault ( b [ i ] , 0 ) + 1 ) ; } int res = 0 ; for ( String s : countA . keySet ( ) ) { if ( countB . keySet ( ) . contains ( s ) ) { res += Math . min ( countA . get ( s ) , countB . get ( s ) ) ; } } return res ; }
public static int count ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i < r ; i ++ ) { if ( ( i < 10 ) ) { cnt ++ ; } else { int n = i % 10 ; int k = i ; while ( ( k >= 10 ) ) { k = k / 10 ; } if ( ( n == k ) ) { cnt ++ ; } } } return ( cnt ) ; }
public static String getValidString ( String str ) { if ( str == null ) { return null ; } else if ( str . length ( ) == 0 ) { return " " ; } else if ( str . length ( ) == 1 ) { return " " ; } else if ( str . length ( ) == 2 ) { return " " ; } else if ( str . length ( ) == 3 ) { return " " ; } else if ( str . length ( ) == 4 ) { return " " ; } else if ( str . length ( ) == 5 ) { return " " ; } else if ( str . length ( ) == 6 ) { return " " ; } else if ( str . length ( ) == 7 ) { return " " ; } else if ( str . length ( ) == 8 ) { return " " ; } else if ( str . length ( ) == 9 ) { return " " ; } else if ( str . length ( ) == 10 ) { return " " ; } else if ( str . length ( ) == 11 ) { return " " ; } else if ( str . length ( ) == 12 ) { return " " ; } else if ( str . length ( ) == 13 ) { return " " ; } else if ( str . length ( ) == 14 ) { return " " ; } else if ( str . length ( ) == 15 ) { return " " " ; } else if ( str . length ( ) == 16 ) { return " " " ; } else if ( str . length ( ) == 17 ) { return " " " ; } else if ( str . length ( ) == 18 ) { return " " " ; } else if ( str . length ( ) == 19 ) { return " " " ; } else if ( str . length ( ) == 20 ) { return " " " ; } else if ( str . length ( ) == 0 ) { return " " " ; } else if ( str . length ( ) == 3 ) { return " " " ; } else if ( str . length ( ) == 4 ) { return " " " ; } else if ( str . length ( ) == 0 ) { return " " " ; } else if ( str . length ( ) == 0 ) { return " " " ; return " " " ; } else { return " " " ; } else { return " " " " ; } else { return " " ;
public static int bit ( int x ) { int ans = 0 ; while ( ( x = x ) != 0 ) { x /= 2 ; ans = ans + 1 ; } return ans ; }
public static int minimalSteps ( String s , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = Integer . valueOf ( i ) ; } String s1 = " " ; String s2 = " " ; dp [ 0 ] = 1 ; s1 += s . charAt ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s . charAt ( i ) ; s2 = s . substring ( i + 1 , i + 1 + i + 1 ) ; dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( ( s1 . equals ( s2 ) ) ) { dp [ i * 2 + 1 ] = Math . min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } } return dp [ n - 1 ] ; }
static boolean checkUtil ( int num , int dig , int base ) { if ( ( dig == 1 ) && ( num < base ) ) { return true ; } if ( ( dig > 1 ) && ( num >= base ) ) { return checkUtil ( num / base , - dig , base ) ; } return false ; }
public static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } int [ ] tmpArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { tmpArr [ i ] = arr [ i ] ; i ++ ; while ( ( i <= j ) ) { minVal = Math . min ( minVal , arr [ i ] ) ; i ++ ; } } return ; }
public static int sum ( int [ ] a , int [ ] b ) { int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum += a [ i ] * b [ i ] ; } return sum ; }
public static void main ( String [ ] args ) { for ( final String s : args ) { final double a = Double . parseDouble ( s ) ; final double b = Double . parseDouble ( s ) ; final double c = Double . parseDouble ( s ) ; final double d = Double . parseDouble ( s ) ; final double e = Double . parseDouble ( s ) ; final double f = Double . parseDouble ( s ) ; final double g = Double . parseDouble ( s ) ; final double h = Double . parseDouble ( s ) ; System . out . println ( " NO " + " YES " + Math . abs ( ( a - c ) * ( f - h ) - ( e - g ) * ( b - d ) ) < 1e-10 ) ; } }
public static int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) { return a ; } if ( n == 1 ) { return b ; } if ( n == 2 ) { return a ^ b ; } return nthXorFib ( n % 3 , a , b ) ; }
public static void main ( String [ ] args ) { final int n = Integer . parseInt ( args [ 0 ] ) ; int taroScore = 0 ; int hanakoScore = 0 ; for ( int turn = 0 ; turn < n ; turn ++ ) { final int [ ] animals = Arrays . stream ( args ) . mapToInt ( animal -> animal ) . toArray ( ) ; if ( animals [ 0 ] == animals [ 1 ] ) { taroScore += 1 ; hanakoScore += 1 ; } else if ( Math . max ( animals [ 0 ] , animals [ 1 ] ) == animals [ 0 ] ) { taroScore += 3 ; } else if ( Math . max ( animals [ 0 ] , animals [ 1 ] ) == animals [ 1 ] ) { hanakoScore += 3 ; } } System . out . println ( taroScore + " ▁ " + hanakoScore ) ; }
public static double Area ( double a ) { if ( ( a < 0 ) ) { return - 1 ; } double h = 1.268 * a ; double A = 0.70477 * Math . pow ( h , 2 ) ; return A ; }
public static String compute ( ) { int ans = 0 ; Stack < Integer > stack = new Stack < > ( ) ; stack . push ( new Integer ( 1 ) ) ; stack . push ( new Integer ( 3 ) ) ; stack . push ( new Integer ( 1 ) ) ; stack . push ( new Integer ( 2 ) ) ; stack . push ( new Integer ( 3 ) ) ; stack . push ( new Integer ( 4 ) ) ; stack . push ( new Integer ( 5 ) ) ; stack . push ( new Integer ( 6 ) ) ; stack . push ( new Integer ( 7 ) ) ; stack . push ( new Integer ( 8 ) ) ; stack . push ( new Integer ( 9 ) ) ; stack . push ( new Integer ( 10 ) ) ; stack . push ( new Integer ( 11 ) ) ; stack . push ( new Integer ( 12 ) ) ; stack . push ( new Integer ( 11 ) ) ; stack . push ( new Integer ( 12 ) ) ; stack . push ( new Integer ( 13 ) ) ; stack . push ( new Integer ( 14 ) ) ; stack . push ( new Integer ( 15 ) ) ; stack . push ( new Integer ( 14 ) ) ; stack . push ( new Integer ( 15 ) ) ; stack . push ( new Integer ( 15 ) ) ; stack . push ( new Integer ( 15 ) ) ; stack . push ( new Integer ( 16 ) ) ; stack . push ( new Integer ( 15 ) ) ; stack . push ( new Integer ( 16 ) ) ; stack . push ( new Integer ( 15 ) ) ; stack . push ( new Integer ( 16 ) ) ; stack . push ( new Integer ( 15 ) ) ; stack . push ( new Integer ( 16 ) ) ; stack . push ( new Integer ( 15 ) ) ; stack . push ( new Integer ( 16 ) ) ; stack . push ( new Integer ( 16 ) ) ; stack . push ( new Integer ( 15 ) ) ; stack . push ( new Integer ( 16 ) ) ; stack . push ( new Integer ( 16 ) ) ; stack . push ( new Integer ( 16 ) ) ; stack . push ( new Integer ( 16 ) ) ; stack . push
public static int getDistance ( int [ ] array ) { int distance = array . length ; for ( int i = 0 ; i < array . length ; i ++ ) { distance *= array [ i ] ; } return distance ; }
public static int sieve ( int [ ] prime , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; ( p <= ( int ) Math . sqrt ( n ) ) ; p ++ ) { if ( ( prime [ p ] == true ) ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } return prime [ 0 ] ; }
public static int sieve ( int [ ] prime , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; ( p = ( int ) Math . sqrt ( n ) + 1 ) ; p += 1 ) { if ( ( prime [ p ] == true ) ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } return prime [ 0 ] ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int a = Integer . parseInt ( args [ i ] ) ; int b = Integer . parseInt ( args [ i ] ) ; ArrayList < Integer > z = new ArrayList < > ( ) ; z . add ( Integer . parseInt ( args [ i ] ) ) ; z . add ( Integer . parseInt ( args [ i ] ) ) ; Collections . reverse ( z ) ; int q = 0 , w = 0 ; for ( int j = 0 ; j < a ; j ++ ) { q += z . get ( j ) ; if ( q / ( j + 1 ) >= b ) { w ++ ; } } System . out . println ( w ) ; } }
public static int [ ] getRandom ( ) { int [ ] [ ] a = new int [ 2 ] [ ] ; for ( int i = 0 ; i < a . length ; i ++ ) a [ i ] [ 0 ] = Integer . parseInt ( input ( ) ) ; return a [ 1 ] [ 0 ] ; }
public static int maxPartitions ( int [ ] arr , int n ) { int ans = 0 ; int maxSoFar = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { maxSoFar = Math . max ( maxSoFar , arr [ i ] ) ; if ( ( maxSoFar == i ) ) { ans ++ ; } } return ans ; }
static int countMaxContiguous ( int [ ] arr , int n ) { int currentMax = 0 ; int maxSoFar = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 != 0 ) ) { currentMax = 0 ; } else { currentMax ++ ; maxSoFar = Math . max ( currentMax , maxSoFar ) ; } } return maxSoFar ; }
public static double cubeSide ( double h , double r ) { if ( ( h < 0 && r < 0 ) ) { return - 1 ; } double a = ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) ; return a ; }
public static void pattern ( int rowsNo ) { for ( int i = 1 ; i <= rowsNo ; i ++ ) { for ( int k = 1 ; k < i ; k ++ ) { System . out . print ( " ▁ " ) ; } for ( int j = i ; j <= rowsNo ; j ++ ) { System . out . print ( j + " ▁ " ) ; } System . out . println ( ) ; } for ( int i = rowsNo - 1 ; i > 0 ; i -- ) { for ( int k = 1 ; k < i ; k ++ ) { System . out . print ( " ▁ " ) ; } for ( int j = i ; j <= rowsNo ; j ++ ) { System . out . print ( j + " ▁ " ) ; } System . out . println ( ) ; } rowsNo = 7 ; pattern ( rowsNo ) ; }
public static double getDistance ( double [ ] a , double [ ] b ) { double distance = 0 ; double sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum += a [ i ] * a [ i ] * a [ i ] ; } return sum ; }
public static int checkDigits ( int n ) { while ( ( n = n ) != 0 ) { if ( ( ( n % 10 ) % 2 == 0 ) ) { return 0 ; } n = ( int ) ( n / 10 ) ; } return 1 ; }
public static int checkDigits ( int n ) { while ( ( n != 0 ) ) { if ( ( ( n % 10 ) % 2 ) != 0 ) { return 0 ; } n = ( int ) ( n / 10 ) ; } return 1 ; }
public static void triangularSeries ( int n ) { int j = 1 ; int k = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( k + " ▁ " ) ; j = j + 1 ; k = k + j ; } }
public static int input ( ) { return Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int n = System . getProperty ( " n " ) . intValue ( ) , m = System . getProperty ( " m " ) . intValue ( ) ; int [ ] list = System . getProperty ( " list " ) . split ( " ▁ " ) ; HashMap < Integer , Integer > l = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! l . containsKey ( list [ i ] ) ) { l . put ( list [ i ] , 1 ) ; } else { l . put ( list [ i ] , 1 ) ; } } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( l . get ( list [ i ] ) > 1 ) { res += n - i - l . get ( list [ i ] ) ; l . remove ( list [ i ] ) -- ; } else { res += n - i - 1 ; } } System . out . println ( res ) ; }
static int findPosition ( int k , int n ) { int f1 = 0 ; int f2 = 1 ; int i = 2 ; while ( i != 0 ) { int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) { return n * i ; } i ++ ; } return 0 ; }
public static void main ( String [ ] args ) { String s = System . getProperty ( " user . name " ) ; System . out . println ( new String [ ] { " First " , " Second " } [ ( ( s . charAt ( 0 ) == s . charAt ( s . length ( ) - 1 ) ) ^ ( s . length ( ) % 2 == 0 ) ) ] ) ; }
public static int countMinimumMoves ( int [ ] arr , int n , int k ) { for ( int i = k - 1 ; i < n ; i ++ ) { if ( ( arr [ i ] != arr [ k - 1 ] ) ) { return - 1 ; } } for ( int i = k - 1 ; i >= 0 ; i -- ) { if ( ( arr [ i ] != arr [ k - 1 ] ) ) { return i + 1 ; } } return 0 ; }
public static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( ( y > 0 ) != 0 ) { if ( ( y & 1 ) != 0 ) { res = ( res * x ) % p ; } y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
public static int getDistance ( int [ ] array ) { int distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == array [ i ] ) { distance += array [ i ] ; } } return distance ; }
public static int a ( ) { int a = ( int ) input ( ) ; return ( ( a - 2 ) * a ) ; }
static int countIdenticalRows ( int [ ] [ ] mat ) { int count = 0 ; for ( int i = 0 ; i < mat . length ; i ++ ) { HashMap < Integer , Integer > hs = new HashMap < > ( ) ; for ( int j = 0 ; j < mat [ i ] . length ; j ++ ) { hs . put ( mat [ i ] [ j ] , 1 ) ; } if ( ( hs . size ( ) == 1 ) ) { count ++ ; } } return count ; }
public static void createSorted ( @ NonNull int [ ] a , int n ) { ArrayList < Integer > b = new ArrayList < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( b . size ( ) == 0 ) { b . add ( a [ j ] ) ; } else { int start = 0 ; int end = b . size ( ) - 1 ; int pos = 0 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( b . get ( mid ) == a [ j ] ) { b . add ( Math . max ( 0 , mid + 1 ) , a [ j ] ) ; break ; } else if ( b . get ( mid ) > a [ j ] ) { pos = end = mid - 1 ; } else { pos = start = mid + 1 ; } if ( start > end ) { pos = start ; b . add ( Math . max ( 0 , pos ) , a [ j ] ) ; break ; } } } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( b . get ( i ) + " ▁ " ) ; } } if ( String . class . equals ( String . class . getName ( ) ) ) { int [ ] a = { 2 , 5 , 4 , 9 , 8 } ; n = a . length ; createSorted ( a , n ) ; } }
public static int countTotalDistinct ( String string ) { int cnt = 0 ; HashSet < String > items = new HashSet ( ) ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { String temp = " " ; HashSet < String > ans = new HashSet ( ) ; for ( int j = i ; j < string . length ( ) ; j ++ ) { temp = temp + string . charAt ( j ) ; ans . add ( string . charAt ( j ) ) ; if ( ! items . contains ( temp ) ) { items . add ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; }
public static int firstDigit ( int n ) { int digits = ( int ) ( Math . log10 ( n ) ) ; n = ( int ) ( n / Math . pow ( 10 , digits ) ) ; return n ; }
static void removeZeros ( int [ ] a , int n ) { int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] != 0 ) ) { ind = i ; break ; } } if ( ( ind == - 1 ) ) { System . out . println ( " Array ▁ has ▁ leading ▁ zeros ▁ only " ) ; return ; } int [ ] b = new int [ n - ind ] ; for ( int i = 0 ; i < n - ind ; i ++ ) { b [ i ] = a [ ind + i ] ; } for ( int i = 0 ; i < n - ind ; i ++ ) { System . out . print ( b [ i ] + " ▁ " ) ; } a = new int [ ] { 0 , 0 , 0 , 1 , 2 , 0 , 3 } ; n = a . length ; removeZeros ( a , n ) ; }
public static int findMaxm ( int [ ] arr , int n ) { HashMap < Integer , Integer > mpp = new HashMap < > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( mpp . containsKey ( arr [ i ] ) ) ) { mpp . put ( arr [ i ] , mpp . get ( arr [ i ] ) + 1 ) ; } else { mpp . put ( arr [ i ] , 1 ) ; } } int ans = 0 ; for ( Map . Entry < Integer , Integer > entry : mpp . entrySet ( ) ) { if ( ( entry . getValue ( ) ) == entry . getValue ( ) ) { ans = Math . max ( ans , entry . getKey ( ) ) ; } } return ans ; }
public static int [ ] getAlpha ( int [ ] a ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int [ ] alpha = new int [ a . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) { alpha [ i ] = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; } return alpha ; }
public static int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x != 0 ) { ans += x % 10 ; x /= 10 ; } return ans ; int closest = 0 ; while ( ( ans * 10 + 9 ) <= x ) { ans = ans * 10 + 9 ; } return ans ; }
public static final String getRandom ( String s ) { final String [ ] strs = s . split ( " ▁ " ) ; final String [ ] badge = { " AAA " , " AA " , " A " , " B " , " C " , " D " , " E " , " NA " } ; final HashMap < Integer , Double > limit = new HashMap < > ( ) ; limit . put ( 500 , new Double ( 35.50 ) ) ; limit . put ( 37.50 , new Double ( 40.00 ) ) ; limit . put ( 43.00 , new Double ( 50.00 ) ) ; limit . put ( 55.00 , new Double ( 70.00 ) ) ; limit . put ( 1000 , new Double ( 71.00 ) ) ; limit . put ( 77.00 , new Double ( 83.00 ) ) ; limit . put ( 89.00 , new Double ( 105.00 ) ) ; limit . put ( 116.00 , new Double ( 148.00 ) ) ; limit . put ( 1000 , new Double ( 1000 ) ) ; return new String ( badge [ 0 ] ) ; }
public static void solve ( String input ) { for ( int i = 0 ; i < input . length ( ) ; i ++ ) { int n = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int m = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int r = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int c = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; System . out . println ( Math . max ( Math . abs ( n - r ) , r - 1 ) + Math . max ( Math . abs ( m - c ) , c - 1 ) ) ; } }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositional
public static double calSin ( double n ) { double accuracy = 0.0001 ; double denominator ; n = n * ( 3.142 / 180.0 ) ; double x1 = n ; double sinx = n ; double sinval = Math . sin ( n ) ; int i = 1 ; while ( ( i = Math . PI ) != 0 ) { denominator = 2 * i * ( 2 * i + 1 ) ; x1 = - x1 * n * n / denominator ; sinx = sinx + x1 ; i = i + 1 ; if ( ( accuracy <= Math . abs ( sinval - sinx ) ) ) { break ; } } System . out . println ( Math . round ( sinx ) ) ; return accuracy ; }
public static int multiply ( int [ ] array , int n ) { int pro = 1 ; for ( int i = 0 ; i < n ; i ++ ) { pro = pro * array [ i ] ; } return pro ; }
public static int [ ] getNegativeInstances ( ) { int [ ] result = new int [ 64 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = 0 ; } for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = i ; } for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = result [ i ] ; } return result ; }
public static int bit ( int n ) { int count = 0 ; while ( ( n = n ) != 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPro
static int findMinIndex ( int arr [ ] , int low , int high ) { if ( ( high < low ) ) { return 0 ; } if ( ( high == low ) ) { return low ; } int mid = ( low + high ) / 2 ; if ( ( mid < high ) && ( arr [ mid + 1 ] < arr [ mid ] ) ) { return ( mid + 1 ) ; } if ( ( mid > low ) && ( arr [ mid ] < arr [ mid - 1 ] ) ) { return mid ; } if ( ( arr [ high ] > arr [ mid ] ) ) { return findMinIndex ( arr , low , mid - 1 ) ; } return findMinIndex ( arr , mid + 1 , high ) ; }
public static double f ( double x , double y ) { double v = y - 2 * x * x + 1 ; return v ; }
public static String D_Pattern ( String string , int n ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ( j == 1 || ( ( i == 0 || i == n - 1 ) && ( j > 1 && j < n - 2 ) ) || ( j == n - 2 && i != 0 && i != n - 1 ) ) ) { string = string + " * " ; } else { string = string + " ▁ " ; } } string = string + " \n " ; } return ( string ) ; }
public static void kthString ( int n , int k ) { int total = 0 ; int i = 1 ; while ( ( total < k ) ) { total = total + n - i ; i ++ ; } int firstYPosition = i - 1 ; int secondYPosition = k - ( total - n + firstYPosition ) ; for ( int j = 1 ; j < firstYPosition ; j += 1 ) { System . out . print ( " x " ) ; } System . out . println ( " y " ) ; int j = firstYPosition + 1 ; while ( ( secondYPosition > 1 ) ) { System . out . print ( " x " ) ; secondYPosition -- ; j ++ ; } System . out . println ( " y " ) ; while ( ( j < n ) ) { System . out . println ( " x " ) ; j ++ ; } } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { n = 5 ; k = 7 ; kthString ( n , k ) ; }
public static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) { C [ j ] = C [ j ] + C [ j - 1 ] ; } } return C [ k ] ; }
public static int [ ] productExceptSelf ( int [ ] nums ) { int [ ] ans = new int [ nums . length ] ; ans [ 0 ] = 1 ; for ( int i = 1 ; i < nums . length ; i ++ ) { ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] ; } int right = 1 ; for ( int i = nums . length - 1 ; i >= 0 ; i -- ) { ans [ i ] *= right ; right *= nums [ i ] ; } return ans ; }
public static void getSmallestAndLargest ( String s , int k ) { String currStr = s . substring ( 0 , k ) ; String lexMin = currStr ; String lexMax = currStr ; for ( int i = k ; i < s . length ( ) ; i ++ ) { currStr = currStr . substring ( 1 , k ) + s . substring ( i , i + 1 ) ; if ( ( lexMax = currStr . compareTo ( lexMax ) ) < 0 ) { lexMax = currStr ; } if ( ( lexMin = currStr . compareTo ( lexMin ) ) > 0 ) { lexMin = currStr ; } } System . out . println ( lexMin ) ; System . out . println ( lexMax ) ; } if ( Class . forName ( " java . util . regex . regex . regex " ) . equals ( " " ) ) { String str1 = " GeeksForGeeks " ; k = 3 ; getSmallestAndLargest ( str1 , k ) ; }
public static int [ ] getSortValues ( String [ ] values ) { int [ ] a = new int [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { a [ i ] = values [ i ] . trim ( ) ; } int [ ] b = new int [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { b [ i ] = values [ i ] . trim ( ) ; } for ( int i = 0 ; i < values . length ; i ++ ) { b [ values . length ] = values [ i ] . trim ( ) ; } Arrays . sort ( b , Collections . reverseOrder ( ) ) ; Arrays . sort ( b , new Comparator ( ) { public int compare ( int o1 , int o2 ) { return ( o1 - o2 ) * ( o1 ) ; } } ) ; for ( int i = 0 ; i < values . length ; i ++ ) { d [ values [ i ] . trim ( ) ] = values [ i ] . trim ( ) ; } for ( int i = 0 ; i < values . length ; i ++ ) { System . out . print ( values [ i ] + " " ) ; } return d ; }
public static int maxSubarrayXOR ( int [ ] set , int n ) { int index = 0 ; for ( int i = INT_BITS - 1 ; i >= 0 ; i -- ) { int maxInd = index ; int maxEle = - 2147483648 ; for ( int j = index ; j < n ; j ++ ) { if ( ( ( set [ j ] & ( 1 << i ) ) != 0 ) && ( set [ j ] > maxEle ) ) { maxEle = set [ j ] ; maxInd = j ; } } if ( ( maxEle == - 2147483648 ) ) continue ; int temp = set [ index ] ; set [ index ] = set [ maxInd ] ; set [ maxInd ] = temp ; maxInd = index ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( j != maxInd ) && ( ( set [ j ] & ( 1 << i ) ) != 0 ) ) set [ j ] = set [ j ] ^ set [ maxInd ] ; } index = index + 1 ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ set [ i ] ; return res ; }
public static int getDistance ( int [ ] a , int [ ] b ) { return Math . max ( Math . min ( Math . max ( a . length , b . length ) , b . length ) , b . length ) ; }
public static int partition ( int [ ] arr , int si , int ei ) { int x = arr [ ei ] ; int i = ( si - 1 ) ; for ( int j = si ; j < ei ; j ++ ) { if ( ( arr [ j ] <= x ) ) { i ++ ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } } arr [ i + 1 ] = arr [ ei ] ; arr [ ei ] = arr [ i + 1 ] ; return ( i + 1 ) ; }
public static int firstUniqChar ( String s ) { int out = 0 ; Map < Character , Integer > countMap = new HashMap < > ( ) ; for ( char c : s . toCharArray ( ) ) { countMap . put ( c , countMap . get ( c , 0 ) + 1 ) ; } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( countMap . get ( c ) == 1 ) { return i ; } } return - 1 ; }
public static boolean checkStackPermutation ( int [ ] ip , int [ ] op , int n ) { Queue < Integer > Input = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) Input . add ( ip [ i ] ) ; Queue < Integer > output = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) output . add ( op [ i ] ) ; ArrayList < Integer > tempStack = new ArrayList < > ( ) ; while ( ( ! Input . isEmpty ( ) ) ) { int ele = Input . remove ( 0 ) ; Input . remove ( 0 ) ; if ( ( ele == output . remove ( 0 ) ) ) { output . remove ( 0 ) ; while ( ( tempStack . size ( ) != 0 ) ) { if ( ( tempStack . get ( tempStack . size ( ) - 1 ) == output . remove ( 0 ) ) ) { tempStack . remove ( tempStack . size ( ) - 1 ) ; output . remove ( 0 ) ; } else break ; } } else { tempStack . add ( ele ) ; } } return ( Input . isEmpty ( ) && tempStack . size ( ) == 0 ) ; } if ( Class . forName ( " java . util . concurrent . ThreadPoolExecutor " ) . equals ( " java . util . concurrent . ThreadPoolExecutor " ) ) { Input = new ArrayList < > ( 1 ) ; Input . add ( 2 ) ; Input . add ( 3 ) ; Output output = new ArrayList < > ( 2 ) ; output . add ( 1 ) ; output . add ( 3 ) ; n = 3 ; if ( ( new CheckStackPermutation ( Input , output , n ) ) . size ( ) != 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " Not ▁ Possible " ) ; } return false ; }
public static String getSuffix ( String name ) { String [ ] parts = name . split ( " _ " ) ; if ( parts . length == 2 ) { return " " ; } else if ( parts . length == 3 ) { return " " ; } else if ( parts . length == 4 ) { return " " ; } else if ( parts . length == 5 ) { return " " ; } else if ( parts . length == 6 ) { return " " ; } else if ( parts . length == 7 ) { return " " ; } else if ( parts . length == 8 ) { return " " ; } else if ( parts . length == 9 ) { return " " ; } else if ( parts . length == 10 ) { return " " ; } else if ( parts . length == 11 ) { return " " ; } else if ( parts . length == 12 ) { return " " ; } else if ( parts . length == 13 ) { return " " ; } else if ( parts . length == 14 ) { return " " ; } else if ( parts . length == 15 ) { return " " ; } else if ( parts . length == 16 ) { return " " ; } else if ( parts . length == 17 ) { return " " ; } else if ( parts . length == 18 ) { return " " ; } else if ( parts . length == 19 ) { return " " ; } else if ( parts . length == 19 ) { return " " ; } else if ( parts . length == 20 ) { return " " ; } else if ( parts . length == 21 ) { return " " ; } else if ( parts . length == 22 ) { return " " ; } else if ( parts . length == 23 ) { return " " ; } else if ( parts . length == 26 ) { return " " ; } else if ( parts . length == 27 ) { return " " ; } else if ( parts . length == 26 ) { return " " " ; } else if ( parts . length == 27 ) { return " " " ; } else if ( parts . length == 26 ) { return " " " ; } else if ( parts . length == 27 ) { return " " " ; } else if ( parts . length == 27 ) { return " " " ; return " " " ; }
static int getSum ( int n , int d ) { int sum = 0 ; for ( int i = 0 ; i < n + 1 ; i ++ ) { if ( ( i % 10 ) == d ) { sum += i ; } } return sum ; }
public static int getSortNumber ( String [ ] arr ) { int [ ] result = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { int a = arr [ i ] . indexOf ( ' , ' ) ; if ( a < 0 ) { result [ i ] = arr [ i ] . substring ( 0 , i ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } else if ( a > 0 ) { result [ i ] = arr [ i ] . substring ( i , i + 1 ) ; } return result [ i ] ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int n = Integer . parseInt ( args [ i ] ) ; int s = Integer . parseInt ( args [ i ] ) ; int t = Integer . parseInt ( args [ i ] ) ; System . out . println ( n - Math . min ( s , t ) + 1 ) ; } }
static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ans += ( i % K ) ; } return ans ; }
public static int getDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDivideByDi
public static double findArea ( double r , double d ) { double R = d / Math . PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; double area = PI * Math . pow ( R , 2 ) ; return area ; }
public static int minimumNumbers ( int n , int s ) { if ( ( s % n ) != 0 ) { return s / n + 1 ; } else { return s / n ; } n = 5 ; s = 11 ; return ( int ) minimumNumbers ( n , s ) ; }
static int countTriplets ( int [ ] arr , int n , int m ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int end = n - 1 ; end >= 1 ; end -- ) { int start = 0 ; int mid = end - 1 ; while ( ( start = arr [ end ] ) != 0 ) { int prod = ( arr [ end ] * arr [ start ] * arr [ mid ] ) ; if ( ( prod > m ) ) { mid -- ; } else if ( ( prod < m ) ) { start ++ ; } else if ( ( prod == m ) ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
static int findIndex ( int n ) { if ( ( n <= 1 ) ) { return n ; } int a = 0 ; int b = 1 ; int c = 1 ; int res = 1 ; while ( ( c = c ) < n ) { c = a + b ; res = res + 1 ; a = b ; b = c ; } return res ; }
public static boolean isVowel ( char ch ) { switch ( ch ) { case ' i ' : case ' a ' : case ' e ' : case ' o ' : case ' u ' : return true ; default : return false ; } }
static int countWays ( int n ) { int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = 0 ; dp [ i ] = 1 ; dp [ i ] = 2 ; } for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
public static double expect ( int m , int n ) { double ans = 0.0 ; int i = m ; while ( ( i = Math . max ( i , 0 ) ) > 0 ) { ans += ( Math . pow ( i / m , n ) - Math . pow ( ( i - 1 ) / m , n ) ) * i ; i -- ; } return ans ; }
public static int ProdOfPrimes ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } int p = 2 ; while ( ( p * p <= n ) ) { if ( ( prime [ p ] ) == true ) { i = p * 2 ; while ( ( i <= n ) ) { prime [ i ] = false ; i += p ; } } p ++ ; } int prod = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( prime [ i ] ) != true ) { prod *= i ; } } return prod ; }
public static String compute ( ) { final int ans = Integer . valueOf ( 1 ) ; for ( int y = 1901 ; y < 2001 ; y ++ ) for ( int m = 1 ; m < 13 ; m ++ ) if ( new Date ( y , m , 1 ) . weekday ( ) == 6 ) return ans ; if ( Thread . currentThread ( ) . getName ( ) . equals ( " java . util . concurrent . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic . atomic .
public static int getDifference ( int d , int m , int y ) { int [ ] monthDays = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int [ ] countLeapYears = { 31 } ; int years = d ; if ( ( d <= 2 ) ) { years -- ; } return ( int ) ( years / 4 - years / 100 + years / 400 ) ; int [ ] getDifference = { } ; int [ ] n2 = { } ; for ( int i = 0 ; i <= ( m - 1 ) ; i ++ ) { n1 [ i ] = monthDays [ i ] ; } n1 [ 0 ] = countLeapYears [ i ] ; n2 [ 1 ] = countLeapYears [ i ] ; return ( n2 [ 0 ] - n1 [ 0 ] ) ; }
public static void generateNumbers ( int n , int num , int a , int b ) { if ( ( num > 0 ) && ( num < n ) ) { st . add ( num ) ; } if ( ( num >= n ) ) { return ; } if ( ( num * 10 + a > num ) ) { generateNumbers ( n , num * 10 + a , a , b ) ; } generateNumbers ( n , num * 10 + b , a , b ) ; }
public static int getRank ( int rank ) { int rank = rank ; if ( rank == 0 ) { return rank ; } else { return rank ; } }
@ SafeVarargs public static void main ( int n , int m ) { Map < Integer , Integer > map = new HashMap < > ( ) ; for ( ; ; ) { int [ ] M = Integer . parseInt ( input ( ) ) ; for ( int num = 0 , i = 0 ; i < M . length ; i ++ ) { if ( M [ i ] == 0 ) continue ; map . put ( M [ i ] , 1 ) ; } } int ans = 10 * 20 ; for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > m ) { ans = entry . getKey ( ) ; m = entry . getValue ( ) ; } else if ( entry . getValue ( ) == m ) { ans = Math . min ( ans , entry . getKey ( ) ) ; } } if ( ans == 10 * 20 ) { ans = 0 ; } System . out . println ( ans ) ; while ( true ) { n = Integer . parseInt ( input ( ) ) ; m = Integer . parseInt ( input ( ) ) ; if ( n == m == 0 ) break ; main ( n , m ) ; } }
static int getOddOccurrence ( int [ ] arr ) { int res = 0 ; for ( int element : arr ) { res = res ^ element ; } return res ; arr = Arrays . asList ( 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ) ; }
public static boolean isKthBitSet ( int x , int k ) { if ( ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) return true ; else return false ; }
public static void SieveOfEratosthenes ( int n , boolean [ ] isPrime ) { isPrime [ 0 ] = false , isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) { isPrime [ i ] = true ; } for ( int p = 2 ; p <= ( int ) Math . sqrt ( n ) ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) { isPrime [ i ] = false ; } } } }
public static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }
public static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }
public static String compute ( ) { final int SIZE_LIMIT = 1000000 ; final int TYPE_LIMIT = 10 ; int [ ] type = new int [ SIZE_LIMIT + 1 ] ; for ( int n = 3 ; n <= SIZE_LIMIT / 4 ; n += 2 ) { for ( int m = n - 2 ; m > 0 ; m -= 2 ) { int tiles = n * n - m * m ; if ( tiles > SIZE_LIMIT ) break ; type [ tiles ] ++ ; } } int ans = Arrays . stream ( type ) . filter ( t -> 1 <= t && t <= TYPE_LIMIT ) . count ( ) ; return String . valueOf ( ans ) ; }
public static int getDepth ( String [ ] array ) { int [ ] [ ] stack2 = new int [ array . length ] [ ] ; int check = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] [ 0 ] . equals ( array [ i ] [ 0 ] ) ) { if ( i < array . length ) { stack [ i ] [ 0 ] = array [ i ] [ 0 ] ; } else { stack [ i ] [ 0 ] = array [ i ] [ 0 ] ; } } else if ( array [ i ] [ 0 ] . equals ( array [ i ] [ 0 ] ) ) { if ( i < array . length ) { stack [ i ] [ 0 ] = array [ i ] [ 0 ] ; } else { stack [ i ] [ 0 ] = array [ i ] [ 0 ] ; } } else if ( array [ i ] [ 0 ] . equals ( array [ i ] [ 0 ] ) ) { if ( i < array . length ) { stack [ i ] [ 0 ] = array [ i ] [ 0 ] ; } else { stack [ i ] [ 0 ] = array [ i ] [ 0 ] ; } } else if ( array [ i ] [ 0 ] . equals ( array [ i ] [ 0 ] ) ) { if ( i < array . length ) { stack [ i ] [ 0 ] = array [ i ] [ 0 ] ; } else { stack [ i ] [ 0 ] = array [ i ] [ 0 ] ; } } else if ( array [ i ] [ 0 ] . equals ( array [ i ] [ 0 ] ) ) { if ( i < array . length ) { stack [ i ] [ 0 ] = array [ i ] [ 0 ] ; } else { stack [ i ] [ 0 ] = array [ i ] [ 0 ] ; } } else if ( array [ i ] [ 0 ] . equals ( array [ i ] [ 0 ] ) ) { if ( i < array . length ) { stack [ i ] [ 0 ] = array [ i ] [ 0 ] ; } else { stack [ i ] [ 0 ] [ 0 ] = array [ i ] [ 0 ] ; } } else if ( array [ i ] [ 0 ] . equals ( array [ i ] [ 0 ] ) ) { if ( i < array . length ) { return array [ i ] [ 0 ] . length
public static int maxZeros ( int N ) { int maxm = - 1 ; int cnt = 0 ; while ( ( N ) != 0 ) { if ( ( ! ( N & 1 ) ) ) { cnt ++ ; N >>= 1 ; maxm = Math . max ( maxm , cnt ) ; } else { maxm = Math . max ( maxm , cnt ) ; cnt = 0 ; N >>= 1 ; } } return maxm ; }
static void getLongestSeq ( int [ ] a , int n ) { int maxIdx = 0 ; int maxLen = 0 ; int currLen = 0 ; int currIdx = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( a [ k ] > 0 ) { currLen ++ ; if ( currLen == 1 ) { currIdx = k ; } } else { if ( currLen > maxLen ) { maxLen = currLen ; maxIdx = currIdx ; } currLen = 0 ; } } if ( maxLen > 0 ) { System . out . println ( " Index ▁ : " + maxIdx + " ▁ , Length ▁ : " + maxLen + " ▁ " ) ; } else { System . out . println ( " No ▁ positive ▁ sequence ▁ detected . " ) ; } int [ ] arr = { 1 , 2 , - 3 , 2 , 3 , 4 , - 6 , 1 , 2 , 3 , 4 , 5 , - 8 , 5 , 6 } ; n = arr . length ; getLongestSeq ( arr , n ) ; }
public static int getDepth ( int [ ] arr ) { int i , j , m , n ; int temp ; m = 0 ; n = 0 ; head = new int [ arr . length ] ; for ( i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] [ j ] == arr [ i ] [ j ] ) { return i ; } temp [ i ] = arr [ i ] [ j ] ; temp [ j ] = arr [ i ] [ j + 1 ] ; temp [ i ] = arr [ i ] [ j + 1 ] ; temp [ j ] = arr [ i + 1 ] [ j + 1 ] ; temp [ j ] = arr [ i ] [ j + 1 ] ; temp [ j ] = arr [ i ] [ j + 1 ] ; temp [ j ] = arr [ i ] [ j + 1 ] ; temp [ j ] = arr [ i ] [ j + 1 ] ; } return temp ; }
public static int [ ] getPrimeNumbers ( int [ ] numbers ) { int N = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int [ ] nums = new int [ N ] ; for ( int i = 0 ; i < nums . length ; i ++ ) { nums [ i ] = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; } return nums ; }
static void findNthTerm ( int N ) { int ans = 0 ; if ( ( N % 2 ) == 0 ) { ans = ( N / 2 ) * 6 + ( N / 2 ) * 2 ; } else { ans = ( N / 2 + 1 ) * 6 + ( N / 2 ) * 2 ; } System . out . println ( ans ) ; }
public static boolean isRectangle ( int a , int b , int c , int d ) { if ( a == b == c == d ) { return true ; } else if ( a == b && c == d ) { return true ; } else if ( a == d && c == b ) { return true ; } else if ( a == c && d == b ) { return true ; } return false ; }
public static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; i ++ ) { an = ( an * a ) % m ; } int [ ] value = new int [ m ] ; int cur = an ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( value [ cur ] ) == 0 ) { value [ cur ] = i ; } cur = ( cur * an ) % m ; } cur = b ; for ( int i = 0 ; i < n + 1 ; i ++ ) { if ( ( value [ cur ] ) > 0 ) { int ans = value [ cur ] * n - i ; if ( ( ans < m ) ) { return ans ; } } cur = ( cur * a ) % m ; } return - 1 ; }
public static int findMinimumCost ( int ind , int [ ] a , int n , int k , int [ ] dp ) { if ( ( ind == ( n - 1 ) ) ) { return 0 ; } else if ( ( dp [ ind ] != - 1 ) ) { return dp [ ind ] ; } else { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( ind + i ) < n ) { ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + findMinimumCost ( ind + i , a , n , k , dp ) ) ; } else { break ; } } dp [ ind ] = ans ; return ans ; } if ( Class . forName ( " java . util . regex . regex " ) . equals ( " java . util . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex . regex
public static int Probability ( double sum , int times ) { double favorable = 0.0 , total = 36.0 , probability = 0 ; for ( int i = 0 ; i < 7 ; i ++ ) { for ( int j = 0 ; j < 7 ; j ++ ) { if ( ( ( i + j ) == sum ) ) { favorable ++ ; } } } int gcd1 = Math . gcd ( ( int ) favorable , ( int ) total ) ; favorable = favorable / gcd1 ; total = total / gcd1 ; probability = Math . pow ( total , times ) ; return ( int ) probability ; }
public static int inved ( int a ) { int [ ] X = new int [ 2 * K ] , N = Integer . parseInt ( input ) ; int mod = 998244353 ; { int x = 1 , y = 0 , u = 0 , v = 1 , k = a , l = 0 ; while ( l != 0 ) { x = u ; y = v ; u = x - u * ( k / l ) ; v = y - v * ( k / l ) ; k = l ; l = k % l ; } return x % mod ; } X [ 2 ] = new int [ 2 * K - 1 ] ; int [ ] frac = new int [ N + K ] ; for ( int i = 0 ; i < N + K ; i ++ ) { frac [ i ] = 1 ; } for ( int i = 0 ; i < N + K ; i ++ ) { frac [ i ] = ( ( i + 1 ) * frac [ i ] ) % mod ; } int [ ] invf = new int [ N + K + 1 ] ; for ( int i = 0 ; i < N + K + 1 ; i ++ ) { invf [ i ] = inved ( frac [ i ] ) ; } for ( int k = 2 ; k <= K ; k ++ ) { int S = 0 ; int sign = 1 ; int l = k / 2 ; for ( int m = 0 ; m < Math . min ( l + 1 , N / 2 + 1 ) ; m ++ ) { int prod = ( sign * ( frac [ l ] * frac [ N + K - 2 * m - 1 ] ) ) % mod ; prod *= ( invf [ m ] * invf [ l - m ] ) % mod ; prod %= mod ; prod *= ( invf [ N - 2 * m ] * invf [ K - 1 ] ) % mod ; prod %= mod ; S += prod ; S %= mod ; sign *= - 1 ; } X [ k - 2 ] = S ; X [ 2 * K - k ] = S ; } for ( int i = 0 ; i < 2 * K - 1 ; i ++ ) { System . out . println ( X [ i ] ) ; } return X [ 2 * K - 1 ] ; }
public static double getDistance ( double [ ] a ) { double distance = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { distance += a [ i ] * a [ i ] ; } return distance ; }
static int getCount ( int [ ] arr , int n , int num1 , int num2 ) { for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] == num1 ) ) break ; } if ( ( i >= n - 1 ) ) return 0 ; for ( int j = n - 1 ; j >= i ; j -- ) { if ( ( arr [ j ] == num2 ) ) break ; } if ( ( j == i ) ) return 0 ; return ( j - i - 1 ) ; arr = Arrays . asList ( 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 ) ; n = arr . length ; num1 = 5 ; num2 = 4 ; System . out . println ( getCount ( arr , n , num1 , num2 ) ) ; }
public static int min ( int [ ] a ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; if ( n == 0 ) break ; int [ ] a = new int [ a . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) a [ i ] = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; System . out . println ( Math . min ( a [ i + 1 ] - a [ i ] , a [ i ] ) ) ; return a [ n ] ; }
static int countSetBits ( int n ) { int cnt = 0 ; int [ ] setBits = new int [ n + 1 ] ; for ( int x = 0 ; x < n ; x ++ ) { setBits [ x ] = 0 ; } setBits [ 0 ] = 0 ; setBits [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i % 2 ) == 0 ) { setBits [ i ] = setBits [ i / 2 ] ; } else { setBits [ i ] = setBits [ i - 1 ] + 1 ; } } for ( int i = 0 ; i <= n ; i ++ ) { cnt = cnt + setBits [ i ] ; } return cnt ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) ) { return b ; } return gcd ( b % a , a ) ; }
public static String compute ( ) { int [ ] divisors = new int [ ( 10 * 7 + 1 ) ] ; for ( int i = 2 ; i < ( divisors . length + 1 ) / 2 ; i ++ ) { for ( int j = i * 2 ; j < divisors . length ; j += i ) { divisors [ j ] ++ ; } } int ans = Integer . valueOf ( ( divisors [ i ] == divisors [ i + 1 ] ) ? 1 : 0 ) ; for ( int i = 2 ; i < divisors . length - 1 ; i ++ ) { ans = Integer . valueOf ( ( divisors [ i ] == divisors [ i + 1 ] ) ? 1 : 0 ) ; } return String . valueOf ( ans ) ; }
static void updateArray ( int arr [ ] , int n ) { int i = n - 1 ; while ( ( i > 0 ) && ( arr [ i ] != arr [ i - 1 ] ) ) { arr [ i ] = arr [ i - 1 ] ; i -- ; } arr [ 0 ] = - 1 ; for ( i = 0 ; i < n ; i += 1 ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
static void findEncryptedArray ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( sum - arr [ i ] + " ▁ " ) ; } if ( Class . isPrimitive ( arr [ n ] ) ) { arr = Arrays . asList ( 5 , 1 , 3 , 2 , 4 ) ; } int N = arr . length ; findEncryptedArray ( arr , N ) ; }
static void updateArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { arr [ i ] = arr [ i + 1 ] ; } arr [ n - 1 ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int findMinDifference ( int [ ] arr , int n ) { int min__ ; int secondMax ; int max__ ; if ( ( arr [ 0 ] < arr [ 1 ] ) ) { min__ = secondMax = arr [ 0 ] ; } else { min__ = secondMax = arr [ 1 ] ; } if ( ( arr [ 0 ] < arr [ 1 ] ) ) { max__ = secondMin = arr [ 1 ] ; } else { max__ = secondMin = arr [ 0 ] ; } for ( int i = 2 ; i < n ; i ++ ) { if ( ( arr [ i ] > max__ ) ) { secondMax = max__ ; max__ = arr [ i ] ; } else if ( ( arr [ i ] > secondMax ) ) { secondMax = arr [ i ] ; } else if ( ( arr [ i ] < min__ ) ) { secondMin = min__ ; min__ = arr [ i ] ; } else if ( ( arr [ i ] < secondMin ) ) { secondMin = arr [ i ] ; } } int diff = Math . min ( max__ - secondMin , secondMax - min__ ) ; return diff ; }
public static int [ ] getNegativeInstances ( int [ ] array ) { int [ ] result = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { result [ i ] = array [ i ] ; } return result ; }
@ NonNull public static String getStarName ( ) { int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; if ( n == 0 ) { break ; } Map < String , Integer > stars = new HashMap < > ( ) ; for ( String s : System . getProperty ( " user . name " ) . split ( " ▁ " ) ) { stars . put ( s , 1 ) ; } int halfN = n / 2 ; for ( Map . Entry < String , Integer > i : stars . entrySet ( ) ) { if ( i . getValue ( ) > halfN ) { System . out . println ( i . getKey ( ) ) ; break ; } } return stars . toString ( ) ; }
public static int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
public static int [ ] [ ] getHoles ( int [ ] [ ] ) { int [ ] [ ] result = new int [ ] [ ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = new int [ ] { i , i , i } ; } for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] [ 0 ] = i ; } int [ ] [ ] prices = new int [ ] [ ] ; for ( int i = 0 ; i < result . length ; i ++ ) { prices [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j < result [ i ] [ j ] ; j ++ ) { for ( int j = 0 ; j < result [ i ] [ j ] ; j ++ ) { for ( int j = 0 ; j < result [ i ] [ j ] ; j ++ ) { if ( j == result [ i ] [ j ] ) { result [ i ] [ j ] = j ; } } } } } for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] [ 0 ] = i ; } for ( int j = 0 ; j < result [ 0 ] [ j ] ; j ++ ) { for ( int k = 0 ; k < result [ i ] [ j ] ; k ++ ) { if ( result [ i ] [ j ] == j ) { result [ i ] [ j ] = j ; } } } return result ; }
public static void solve ( ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; List < Integer > stones = new ArrayList < > ( ) ; for ( String s : System . getProperty ( " line . separator " , n ) . split ( " ▁ " ) ) { stones . add ( Integer . parseInt ( s ) ) ; } List < Integer > total1 = new ArrayList < > ( stones . size ( ) + 1 ) ; for ( int i = 1 ; i <= stones . size ( ) ; i ++ ) { total1 . set ( i , stones . get ( i - 1 ) + total1 . get ( i - 1 ) ) ; } List < Integer > total2 = new ArrayList < > ( stones . size ( ) + 1 ) ; Collections . sort ( stones ) ; for ( int i = 1 ; i <= stones . size ( ) ; i ++ ) { total2 . set ( i , stones . get ( i - 1 ) + total2 . get ( i - 1 ) ) ; } int m = Integer . parseInt ( System . getProperty ( " line . separator " , " ▁ " ) ) ; for ( int i = 0 ; i < m ; i ++ ) { List < Integer > x = new ArrayList < > ( ) ; for ( String s : System . getProperty ( " line . separator " , 3 ) . split ( " ▁ " ) ) { if ( x . get ( 0 ) == 1 ) { System . out . println ( total1 . get ( x . get ( 2 ) ) - total1 . get ( x . get ( 1 ) - 1 ) ) ; } else { System . out . println ( total2 . get ( x . get ( 2 ) ) - total2 . get ( x . get ( 1 ) - 1 ) ) ; } } } solve ( ) ; }
public static int findMinimumX ( int [ ] a , int n ) { HashSet < Integer > st = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { st . add ( a [ i ] ) ; } if ( ( st . size ( ) == 1 ) ) { return 0 ; } if ( ( st . size ( ) == 2 ) ) { st . clear ( ) ; int el1 = st . get ( 0 ) ; int el2 = st . get ( 1 ) ; if ( ( ( el2 - el1 ) % 2 ) == 0 ) { return ( int ) ( ( el2 - el1 ) / 2 ) ; } else { return ( el2 - el1 ) ; } } if ( ( st . size ( ) == 3 ) ) { st . clear ( ) ; int el1 = st . get ( 0 ) ; int el2 = st . get ( 1 ) ; int el3 = st . get ( 2 ) ; if ( ( ( el2 - el1 ) ) == ( el3 - el2 ) ) { return el2 - el1 ; } else { return - 1 ; } } return - 1 ; }
public static int findX ( int n , int k ) { int r = n ; int m = ( int ) Math . sqrt ( k ) + 1 ; int i = 2 ; while ( i <= m && k > 1 ) { if ( ( i == m ) ) { i = k ; } int u = 0 ; int v = 0 ; while ( k % i == 0 ) { k /= i ; v ++ ; } if ( ( v > 0 ) ) { int t = n ; while ( ( t > 0 ) ) { t /= i ; u += t ; } r = Math . min ( r , u / v ) ; } i ++ ; } return r ; }
public static boolean LiesInsieRectangle ( int a , int b , int x , int y ) { if ( ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) ) { return true ; } return false ; }
public static int countPairs ( int [ ] arr , int n ) { int size = ( 2 * N ) + 1 ; int [ ] freq = new int [ size ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( freq [ i ] > 0 ) ) { ans += ( int ) ( ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ) ; for ( int j = i + 2 ; j <= 2001 ; j += 2 ) { if ( ( freq [ j ] > 0 ) && ( ( freq [ ( int ) ( i + j ) / 2 ) ] > 0 ) ) ans += ( freq [ i ] * freq [ j ] ) ; } } } return ans ; }
public static double getAvg ( int x , int n , int sum ) { sum = sum + x ; return ( double ) sum / n ; }
public static boolean isEuclid ( int n ) { int [ ] s = new int [ MAX ] ; int [ ] prime = new int [ MAX ] ; prime [ 0 ] = false , product = false ; for ( int p = 2 ; p < 100 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] == true ) { product = product * p ; s [ p ] = product + 1 ; } } return prime [ n ] == true ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 11 ] ; array [ 0 ] = 0 ; array [ 1 ] = 1 ; array [ 2 ] = 2 ; array [ 3 ] = 3 ; array [ 4 ] = 4 ; array [ 5 ] = 5 ; array [ 6 ] = 4 ; array [ 7 ] = 5 ; array [ 8 ] = 6 ; array [ 9 ] = 7 ; array [ 10 ] = 8 ; array [ 11 ] = 9 ; array [ 12 ] = 8 ; array [ 13 ] = 9 ; array [ 14 ] = 8 ; array [ 15 ] = 9 ; array [ 16 ] = 10 ; array [ 17 ] = 11 ; array [ 18 ] = 11 ; array [ 19 ] = 12 ; array [ 19 ] = 13 ; array [ 20 ] = 13 ; array [ 21 ] = 14 ; array [ 22 ] = 15 ; array [ 23 ] = 14 ; array [ 24 ] = 15 ; array [ 25 ] = 15 ; array [ 26 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] = 15 ; array [ 27 ] ; array [ 27 ] = 0 ; return array ; }
public static int maxOperations ( String str ) { int i , g = 0 , gk = 0 , gks = 0 ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( ( str . charAt ( i ) == ' g ' ) ) { g ++ ; } else if ( ( str . charAt ( i ) == ' k ' ) ) { if ( ( g > 0 ) ) { g -- ; gk ++ ; } } else if ( ( str . charAt ( i ) == ' s ' ) ) { if ( ( gk > 0 ) ) { gk -- ; gks ++ ; } } } return gks ; if ( String . valueOf ( str ) . equals ( " " ) ) { String a = " ggkssk " ; System . out . println ( maxOperations ( a ) ) ; } return gks ; }
public static int a ( ) { int [ ] arr = Integer . parseInt ( input ( ) ) ; Arrays . sort ( arr ) ; int c = 0 ; for ( int i = 0 ; i < a - 1 ; i ++ ) { if ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) > 1 ) { c += Math . abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ; } } return c ; }
public static int [ ] getNegativeInstances ( ) { int [ ] [ ] array = new int [ n ] [ m ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } for ( int i = 0 ; i < array [ i ] . length ; i ++ ) { array [ i ] [ 0 ] = array [ i ] [ 0 ] ; array [ i ] [ 1 ] = array [ i ] [ 1 ] ; array [ i ] [ 2 ] = array [ i ] [ 2 ] ; array [ i ] [ 3 ] = array [ i ] [ 3 ] ; array [ i ] [ 4 ] = array [ i ] [ 4 ] ; array [ i ] [ 5 ] = array [ i ] [ 5 ] ; array [ i ] [ 6 ] = array [ i ] [ 6 ] ; array [ i ] [ 7 ] = array [ i ] [ 7 ] ; array [ i ] [ 8 ] = array [ i ] [ 8 ] ; array [ i ] [ 9 ] = array [ i ] [ 9 ] ; array [ i ] [ 10 ] = array [ i ] [ 11 ] ; array [ i ] [ 11 ] = array [ i ] [ 12 ] ; array [ i ] [ 12 ] = array [ i ] [ 13 ] ; array [ i ] [ 13 ] = array [ i ] [ 14 ] ; array [ i ] [ 15 ] = array [ i ] [ 16 ] ; array [ i ] [ 17 ] = array [ i ] [ 17 ] ; array [ i ] [ 18 ] = array [ i ] [ 18 ] ; array [ i ] [ 19 ] = array [ i ] [ 19 ] ; array [ i ] [ 19 ] = array [ i ] [ 19 ] ; array [ i ] [ 20 ] = array [ i ] [ 20 ] ; array [ i ] [ 21 ] = array [ i ] [ 21 ] ; array [ i ] [ 22 ] = array [ i ] [ 22 ] ; array [ i ] [ 23 ] = array [ i ] [ 23 ] ; array [ i ] [ 24 ] = array [ i ] [ 24 ] ; array [ i ] [ 25 ] = array [ i ] [ 26 ] ; array [ i ] [ 26 ] = array [ i ] [ 27 ] ; array [ i ] [ 27 ] = array [ i ] [ i ] ; } return array
public static int kthSmallest ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; }
public static void printString ( String str ) { int n = Integer . parseInt ( str ) ; int [ ] a = Integer . parseInt ( str ) , b ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( b [ i ] == a [ i ] ) { b [ i ] = b [ i + 1 ] ; } } if ( n == 1 ) { b = new int [ ] { - 1 } ; } else if ( b [ b . length - 1 ] == a [ b . length - 1 ] ) { b [ b . length - 1 ] = b [ b . length - 2 ] ; } else { System . out . println ( b [ b . length - 1 ] ) ; } }
public static String compute ( ) { final int START_NUM = 1 ; final int END_NUM = 500 ; final String CROAK_SEQ = " PPPPNNPPPNPPNPN " ; assert 0 <= START_NUM && START_NUM < END_NUM ; assert 1 <= CROAK_SEQ . length ( ) ; final int NUM_JUMPS = CROAK_SEQ . length ( ) - 1 ; final int NUM_TRIALS = 2 * NUM_JUMPS ; int globalnumerator = 0 ; final int [ ] isprime = EulerUtil . listPrimality ( END_NUM ) ; for ( int i = START_NUM ; i <= END_NUM ; i ++ ) { for ( int j = 0 ; j < NUM_TRIALS ; j ++ ) { int pos = i ; int trialnumerator = 1 ; if ( isprime [ pos ] == ( CROAK_SEQ . charAt ( 0 ) == ' P ' ) ) { trialnumerator *= 2 ; } for ( int k = 0 ; k < NUM_JUMPS ; k ++ ) { if ( pos <= START_NUM ) { pos ++ ; } else if ( pos >= END_NUM ) { pos -- ; } else if ( ( j >> k ) & 1 == 0 ) { pos ++ ; } else { pos -- ; } if ( isprime [ pos ] == ( CROAK_SEQ . charAt ( k + 1 ) == ' P ' ) ) { trialnumerator *= 2 ; } } globalnumerator += trialnumerator ; } } int globaldenominator = ( END_NUM + 1 - START_NUM ) * 2 * NUM_JUMPS * 3 * CROAK_SEQ . length ; final Fraction ans = new Fraction ( globalnumerator , globaldenominator ) ; return ans . toString ( ) ; }
public static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) { lon1 = Math . toRadians ( lon1 ) ; lon2 = Math . toRadians ( lon2 ) ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; double dlon = lon2 - lon1 ; double dlat = lat2 - lat1 ; double a = Math . sin ( dlat / 2 ) * Math . sin ( dlat / 2 ) + Math . cos ( lat1 ) * Math . cos ( lat2 ) * Math . sin ( dlon / 2 ) * Math . sin ( dlon / 2 ) ; double c = 2 * Math . asin ( Math . sqrt ( a ) ) ; int r = 6371 ; return ( c * r ) ; }
public static int centeredOctahedral ( int n ) { return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) / 3 ; if ( Class . isPrimitive ( ) ) { n = 3 ; System . out . println ( centeredOctahedral ( n ) ) ; n = 9 ; System . out . println ( centeredOctahedral ( n ) ) ; } return 0 ; }
public static int measure ( int init , int stationCount ) { int [ ] d = new int [ stationCount ] ; Arrays . fill ( d , 0 ) ; for ( int i = 0 ; i < d . length ; i ++ ) { d [ i ] = d [ i ] ; } for ( int i = 0 ; i < d . length ; i ++ ) { d [ i ] = d [ i ] ; } return d . length ; }
public static void SumDivPrime ( int [ ] A , int n ) { int maxVal = Math . max ( A . length , A . length ) + 1 ; boolean [ ] prime = new boolean [ maxVal + 1 ] ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p <= ( int ) Math . sqrt ( maxVal ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = 2 * p ; i <= maxVal ; i += p ) { prime [ i ] = false ; } } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( prime [ A [ i ] ] ) { sum += A [ i ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { if ( prime [ A [ i ] ] && sum % A [ i ] == 0 ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; A = new int [ ] { 1 , 2 , 3 , 4 , 5 } ; n = A . length ; SumDivPrime ( A , n ) ; }
public static void leftRotate ( int [ ] arr , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) { System . out . print ( arr [ i % n ] + " ▁ " ) ; } }
static int closestMultiple ( int n , int x ) { if ( x > n ) { return x ; } int z = ( ( int ) ( x / 2 ) ) ; n = n + z ; n = n - ( n % x ) ; return n ; }
public static final String getCountry ( String country ) { String country = country . toLowerCase ( ) ; return country . substring ( country . lastIndexOf ( ' . ' ) + 1 ) ; }
public static int [ ] [ ] dp ( int [ ] [ ] ) { for ( int i = 0 ; i < 8101 ; i ++ ) { for ( int j = 0 ; j < 901 ; j ++ ) { if ( dp [ i ] [ j ] [ 0 ] == dp [ i ] [ j ] [ j ] ) { return dp [ i ] [ j ] [ j ] ; } } } return dp [ 0 ] [ 0 ] [ 0 ] ; }
public static int getDistance ( int [ ] [ ] ) { int n = 0 , k = 0 ; int [ ] [ ] gr = new int [ N ] [ ] ; int [ ] [ ] d = new int [ N ] [ ] ; for ( int i = 0 ; i < N ; i ++ ) { gr [ i ] [ 0 ] = i ; gr [ i ] [ 1 ] = i ; gr [ i ] [ 2 ] = i ; } int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { gr [ i ] [ 0 ] = i ; gr [ i ] [ 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ( i != par ) ) { dfs ( i , v ) ; for ( int j = 1 ; j <= k ; j ++ ) ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] ; for ( int j = 1 ; j <= k ; j ++ ) d [ v ] [ j ] += d [ i ] [ j - 1 ] ; } } n = 5 ; k = 2 ; for ( int i = 1 ; i <= N ; i ++ ) { dfs ( i , v ) ; } for ( int j = 1 ; j <= k ; j ++ ) { d [ v ] [ j ] += d [ i ] [ j - 1 ] ; } return ans ; }
static int findSubsequence ( int [ ] arr , int n ) { int length = 1 ; int [ ] dp = new int [ 10 ] ; int tmp = arr [ 0 ] ; while ( ( tmp > 0 ) ) { dp [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( int i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; int locMax = 1 ; int [ ] cnt = new int [ 10 ] ; while ( ( tmp > 0 ) ) { cnt [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( int d = 0 ; d < 10 ; d ++ ) { if ( ( cnt [ d ] ) != 0 ) { dp [ d ] ++ ; locMax = Math . max ( locMax , dp [ d ] ) ; } } for ( int d = 0 ; d < 10 ; d ++ ) { if ( ( cnt [ d ] ) != 0 ) dp [ d ] = locMax ; } length = Math . max ( length , locMax ) ; } return length ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { System . out . println ( new HashSet < > ( Arrays . asList ( args [ i ] ) ) . removeAll ( Arrays . asList ( args [ i ] ) ) ) ; } }
public static int totalPrimeFactors ( int n ) { int count = 0 ; if ( ( ( n % 2 ) == 0 ) ) { count += 1 ; while ( ( ( n % 2 ) == 0 ) ) { n /= 2 ; } } int i = 3 ; while ( ( i * i <= n ) ) { if ( ( ( n % i ) == 0 ) ) { count += 1 ; while ( ( ( n % i ) == 0 ) ) { n /= i ; } } i += 2 ; } if ( ( n > 2 ) ) { count += 1 ; } return count ; }
public static void calculateSum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; System . out . println ( " Sum ▁ of ▁ multiples ▁ of ▁ " + a + " ▁ up ▁ to ▁ " + N + " ▁ = ▁ " + ans ) ; }
public static String getSkills ( String [ ] line ) { if ( line . length == 0 ) { return " " ; } else if ( line . length == 3 ) { return " " ; } else if ( line . length == 4 ) { return " " ; } else if ( line . length == 5 ) { return " " ; } else if ( line . length == 6 ) { return " " ; } else if ( line . length == 7 ) { return " " ; } else if ( line . length == 8 ) { return " " ; } else if ( line . length == 9 ) { return " " ; } else if ( line . length == 10 ) { return " " ; } else if ( line . length == 11 ) { return " " ; } else if ( line . length == 12 ) { return " " ; } else if ( line . length == 13 ) { return " " ; } else if ( line . length == 14 ) { return " " ; } else if ( line . length == 15 ) { return " " ; } else if ( line . length == 16 ) { return " " ; } else if ( line . length == 17 ) { return " " ; } else if ( line . length == 18 ) { return " " ; } else if ( line . length == 19 ) { return " " ; } else if ( line . length == 20 ) { return " " ; } else if ( line . length == 21 ) { return " " ; } else if ( line . length == 22 ) { return " " ; } else if ( line . length == 23 ) { return " " ; } else if ( line . length == 26 ) { return " " ; } else if ( line . length == 27 ) { return " " ; } else if ( line . length == 26 ) { return " " ; } else if ( line . length == 27 ) { return " " ; } else if ( line . length == 26 ) { return " " ; } else if ( line . length == 27 ) { return " " ; } else if ( line . length == 26 ) { return " " ; } else if ( line . length == 27 ) { return " " ; } else if ( line . length == 26 ) { return " " ; return line [ line . length - 1 ] ; }
static int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i < a + 1 ; i ++ ) { if ( ( a == ( i + ( a ^ i ) ) ) ) { count ++ ; } } return count ; }
public static int next ( int [ ] arr , int target ) { int start = 0 ; int end = arr . length - 1 ; int ans = - 1 ; while ( ( start <= end ) ) { int mid = ( start + end ) / 2 ; if ( ( arr [ mid ] <= target ) ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; }
public static String [ ] word ( String [ ] word ) { String [ ] digits = new String [ word . length ] ; for ( int i = 0 ; i < digits . length ; i ++ ) { digits [ i ] = 0 ; } int dc = 0 ; do { digits [ dc ] = n % 10 ; n = n / 10 ; dc ++ ; } while ( ( n == 0 ) ) ; for ( int i = dc - 1 ; i >= 0 ; i -- ) { System . out . print ( word [ digits [ i ] ] ) ; } return digits ; }
public static int solve ( int n , int k , int m , int [ ] a ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int [ ] arrIn = new int [ n ] ; for ( String s : System . getProperty ( " line . separator " ) . split ( " ▁ " ) ) { arrIn [ i ] = Integer . parseInt ( s ) ; } int [ ] matIn = new int [ rows ] ; for ( int i = 0 ; i < rows ; i ++ ) { matIn [ i ] = new int [ ] { rows } ; } String strIn = System . getProperty ( " line . separator " ) ; int out = o -> { out += o ; } ; int [ ] arrOut = new int [ ] { o } ; int [ ] boolOut = new int [ ] { o } ; int [ ] tests = new int [ ] { 1 , intIn [ 0 ] + 1 } ; int [ ] caseOut = new int [ ] { i , o } ; int [ ] caseOut = new int [ ] { i , o } ; return Math . max ( Math . min ( n , m + 1 ) , Math . min ( Math . min ( n , m + 1 ) , Math . min ( m + 1 , m + 1 ) ) ) ; }
public static void solve ( String a , String b ) { int l = a . length ( ) ; int min = 0 ; int max = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( a . charAt ( i ) == ' + ' || b . charAt ( i ) == ' + ' || a . charAt ( i ) != b . charAt ( i ) ) ) { max ++ ; } if ( ( a . charAt ( i ) != ' + ' && b . charAt ( i ) != ' + ' && a . charAt ( i ) != b . charAt ( i ) ) ) { min ++ ; } } System . out . println ( min + max ) ; } if ( Class . forName ( " java . util . regex . regex " ) . equals ( " java . util . regex . regex . regex " ) ) { String s1 = " a + c " ; String s2 = " + + b " ; solve ( s1 , s2 ) ; }
public static int TotalWays ( int n , int s , int k ) { int [ ] dp = new int [ n ] ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = Math . max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
public static int countEvenOdd ( int n ) { int evenCount = 0 ; int oddCount = 0 ; while ( ( n > 0 ) ) { int rem = n % 10 ; if ( ( rem % 2 == 0 ) ) { evenCount ++ ; } else { oddCount ++ ; } n = ( int ) ( n / 10 ) ; } System . out . println ( " Even ▁ count ▁ : ▁ " + evenCount ) ; System . out . println ( " \n Odd ▁ count ▁ : ▁ " + oddCount ) ; if ( ( evenCount % 2 == 0 ) && oddCount % 2 != 0 ) { return 1 ; } else { return 0 ; } } n = 2335453 ; int t = countEvenOdd ( n ) ; if ( ( t == 1 ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } return t ; }
public static int combine ( int [ ] a , int [ ] b ) { int n = 0 , k = 0 ; List < List < Integer > > books = new ArrayList < > ( ) ; for ( ; ; ) books . add ( new ArrayList < > ( ) ) ; while ( n > 0 ) { int c = Integer . parseInt ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String ( String . valueOf ( String . valueOf ( ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ; books . add ( 0 , ++ books . get ( 0 ) ) ) ) ; } return books . get ( 0 ) ; }
public static int findmin ( int [ ] [ ] p , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( p [ i ] [ 0 ] <= 0 ) ) { a ++ ; } else if ( ( p [ i ] [ 0 ] >= 0 ) ) { b ++ ; } if ( ( p [ i ] [ 1 ] >= 0 ) ) { c ++ ; } else if ( ( p [ i ] [ 1 ] <= 0 ) ) { d ++ ; } } return Math . min ( a , b , c , d ) ; }
public static int maxGCD ( int N , int P ) { int ans = 1 ; HashMap < Integer , Integer > primeFactors = new HashMap < > ( ) ; for ( int i = 2 ; i <= ( int ) Math . sqrt ( P ) ; i ++ ) { while ( ( P % i ) == 0 ) { if ( ! primeFactors . containsKey ( i ) ) { primeFactors . put ( i , 0 ) ; } primeFactors . get ( i ) . increment ( 1 ) ; P /= i ; } } if ( ( P ) != 1 ) { primeFactors . get ( P ) . increment ( 1 ) ; } for ( Map . Entry < Integer , Integer > entry : primeFactors . entrySet ( ) ) { ans *= Math . pow ( entry . getKey ( ) , entry . getValue ( ) / N ) ; } return ans ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } return array ; }
static void generateDivisors ( int curIndex , int curDivisor , int [ ] [ ] arr ) { if ( ( curIndex == arr . length ) ) { System . out . print ( curDivisor ) ; return ; } for ( int i = arr [ curIndex ] [ 0 ] ; i <= arr [ curIndex ] [ 1 ] ; i ++ ) { generateDivisors ( curIndex + 1 , curDivisor , arr ) ; curDivisor *= arr [ curIndex ] [ 1 ] ; } }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 1000010 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = 0 ; } int [ ] dp = new int [ 1000010 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { int a = array [ i ] ; int b = array [ i ] ; array [ i ] = a ; } for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } return array ; }
public static String largestPalinSub ( String s ) { String res = " " ; int mx = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { mx = Math . max ( mx , s . charAt ( i ) ) ; } for ( int i = 0 ; i <= s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == mx ) { res += s . charAt ( i ) ; } } return res ; }
public static String convert ( String s ) { String convertStr = " " ; int l = s . length ( ) ; int i = 0 ; while ( i < l ) { if ( i + 1 < l ) { char word = s . charAt ( i ) ; int sequenceNum = 1 ; int j = i + 1 ; while ( j < l ) { if ( ( word == s . charAt ( j ) ) ) { sequenceNum ++ ; } else { break ; } j ++ ; } convertStr += sequenceNum + word ; i = i + sequenceNum - 1 ; } else { convertStr += "1" + s . charAt ( i ) ; } i ++ ; } return convertStr ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } return array ; }
static int [ ] initializeDiffArray ( int [ ] A ) { int n = A . length ; int [ ] D = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { D [ i ] = 0 ; } D [ 0 ] = A [ 0 ] ; D [ n ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { D [ i ] = A [ i ] - A [ i - 1 ] ; } return D ; }
static void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guestsIn = 1 ; int maxGuests = 1 ; int time = arrl [ 0 ] ; int i = 1 ; int j = 0 ; while ( ( i < n ) && ( j < n ) ) { if ( ( arrl [ i ] <= exit [ j ] ) ) { guestsIn = guestsIn + 1 ; if ( ( guestsIn > maxGuests ) ) { maxGuests = guestsIn ; time = arrl [ i ] ; } i = i + 1 ; } else { guestsIn = guestsIn - 1 ; j = j + 1 ; } } System . out . println ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = " + maxGuests + " at ▁ time " + time ) ; arrl = new int [ ] { 1 , 2 , 10 , 5 , 5 } ; exit = new int [ ] { 4 , 5 , 12 , 9 , 12 } ; n = arrl . length ; findMaxGuests ( arrl , exit , n ) ; }
public static String lcs ( String x , String y , int preLcs , int preLcsLen ) { Map < Character , Integer > pm = new HashMap < > ( ) ; pm . put ( new Character ( " ABCDEFGHIJKLMNOPQRSTUVWXYZ " ) , new Integer ( 0 ) ) ; for ( char c : pm . keySet ( ) ) { for ( int i = 0 ; i < x . length ( ) ; i ++ ) { char xc = x . charAt ( i ) ; if ( c == xc ) pm . put ( c , i ) ; } } int V = ( 1 << x . length ( ) ) - 1 ; List < String > rec = new ArrayList < > ( ) ; for ( char yc : y . toCharArray ( ) ) { V = ( ( V + ( V & pm . get ( yc ) ) ) . intValue ( ) ) ; rec . add ( Integer . toBinaryString ( V ) ) ; } int lcsLen = Integer . toBinaryString ( V ) . toString ( ) . indexOf ( '0' ) ; if ( lcsLen > preLcsLen ) { String rx = x . substring ( 0 , x . length ( ) - 1 ) ; StringBuffer lcs = new StringBuffer ( ) ; int idx = 0 ; for ( String v = rec . get ( 0 ) , yc = new String ( ) ; i < y . length ( ) ; i ++ ) { idx = v . indexOf ( '0' , idx ) ; if ( yc == rx . charAt ( idx ) ) { lcs . append ( yc ) ; if ( lcs . length ( ) == lcsLen ) { return ( lcs . toString ( ) . substring ( 0 , lcsLen ) ) ; } idx ++ ; } } } else { return ( preLcs ) ; } final Scanner fileScanner = new Scanner ( System . in ) ; StringBuilder ansOut = new StringBuilder ( ) ; while ( fileScanner . hasNextLine ( ) ) { String s = fileScanner . nextLine ( ) ; if ( s . charAt ( 0 ) == ' # ' ) break ; int sLen = s . length ( ) ; int sep = sLen / 2 ; String ans , ansLen = lcs ( s . substring ( 0 , sep ) , s . substring ( sep ) , " " , 0 ) ; while ( sep > ansLen ) { ans = lcs ( s . substring ( 0 , sep ) , s . substring
public static int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { double denominator = Math . pow ( i , i ) ; double numerator = Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
public static void isPerfectSquare ( int x ) { int sr = ( int ) Math . sqrt ( x ) ; if ( ( sr * sr == x ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } if ( Class . isPrimitive ( " java . lang . String " ) ) { int n = 7 ; int k = 2 ; isPerfectSquare ( n + k ) ; } }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ N ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = Integer . parseInt ( array [ i ] ) * N + i ; } Arrays . sort ( array ) ; int cnt = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { int d = ( array [ i ] % array [ i ] ) % array [ i ] ; if ( d % 2 != i % 2 ) { cnt ++ ; } } return array ; }
public static String get ( @ NonNull ArrayList < Integer > l ) { Collections . sort ( l ) ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) { if ( l . contains ( l . get ( i + 1 ) ) && l . contains ( l . get ( i + 2 ) ) ) { return " YES " ; } } return " NO " ; if ( Class . isPrimitive ( String . class ) ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; String [ ] lst = System . getProperty ( " line . separator " ) . split ( " ▁ " ) ; List < Integer > list = new ArrayList < > ( ) ; for ( String s : lst ) { list . add ( Integer . parseInt ( s ) ) ; } System . out . println ( get ( list ) ) ; } return " " ; }
public static boolean isSankaku ( int v ) { double x = ( Math . sqrt ( 8 * v + 1 ) - 1 ) / 2 ; return x == ( int ) x ; }
public static boolean accumulate ( String s ) { int acc = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { acc += ( int ) s . charAt ( i ) - 48 ; } return acc ; }
public static String compute ( ) { final int [ ] issquare = new int [ ] { 1 } ; final StringBuilder sum ; for ( int a = 1 ; ; a ++ ) { if ( a * a >= limit ) { break ; } for ( int b = 1 ; b < a ; b ++ ) { if ( ( a + b ) % 2 != 0 ) { continue ; } int x = ( a * a + b * b ) / 2 ; int y = ( a * a - b * b ) / 2 ; if ( x + y + 1 >= limit ) { continue ; } int zlimit = Math . min ( y , limit - x - y ) ; for ( int c = Math . sqrt ( y ) + 1 ; c <= Math . sqrt ( c ) ; c ++ ) { int z = c * c - y ; if ( z >= zlimit ) { break ; } if ( issquare [ x + z ] && issquare [ x - z ] && issquare [ y - z ] ) { return x + y + z ; } } } } return null ; } int sumlimit = 10 ; do { issquare = new boolean [ sumlimit ] ; for ( int i = 0 ; i < Math . sqrt ( issquare . length - 1 ) + 1 ; i ++ ) { issquare [ i * i ] = true ; } sum = sum . toString ( ) ; } while ( issquare [ 0 ] ) ; if ( issquare [ 0 ] ) { return sum . toString ( ) ; } return sum . toString ( ) ; }
public static String isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; }
public static int gcd ( int a , int b ) { if ( b == 0 ) { return Math . abs ( a ) ; } else { return gcd ( b , a % b ) ; } int N = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int M = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; String S = System . getProperty ( " line . separator " ) ; String T = System . getProperty ( " line . separator " ) ; if ( S . charAt ( 0 ) != T . charAt ( 0 ) ) { System . out . println ( - 1 ) ; exit ( ) ; } if ( S . length ( ) == T . length ( ) ) { if ( S . equals ( T ) ) { System . out . println ( S . length ( ) ) ; } else { System . out . println ( - 1 ) ; } exit ( ) ; } int gcd1 = gcd ( S . length ( ) , T . length ( ) ) ; int lcm = S . length ( ) * T . length ( ) / gcd1 ; int [ ] SS = new int [ S . length ( ) ] ; int [ ] TT = new int [ TT . length ] ; int i = 0 ; int j = 0 ; while ( i < N ) { SS [ i ] = ( i * lcm / N + 1 ) ; i ++ ; } while ( j < M ) { TT [ j ] = ( j * lcm / M + 1 ) ; j ++ ; } int ind = 0 ; int indMax = j - 1 ; for ( ; i < SS . length ; i ++ ) { int v = SS [ i ] ; ind = Arrays . binarySearch ( TT , v , ind , j ) ; if ( ind == j ) { break ; } if ( TT [ ind ] == v ) { if ( S . charAt ( i ) == T . charAt ( ind ) ) { continue ; } else { System . out . println ( - 1 ) ; exit ( ) ; } } } System . out . println ( lcm ) ; return lcm ; }
public static int getRandom ( ) { String input = System . getProperty ( " user . name " ) ; int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; boolean [ ] [ ] black = new boolean [ n + 10 ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { black [ i ] [ 0 ] = false ; black [ i ] [ i ] = true ; } for ( int i = 1 ; i <= m ; i ++ ) { int x = Integer . parseInt ( input ) ; int y = Integer . parseInt ( input ) ; black [ x ] [ y ] = true ; for ( int lx = x - 2 ; lx <= x ; lx ++ ) { for ( int ly = y - 2 ; ly <= y ; ly ++ ) { int cnt = 0 ; for ( int dx = 0 ; dx < 3 ; dx ++ ) { for ( int dy = 0 ; dy < 3 ; dy ++ ) { cnt += black [ lx + dx ] [ ly + dy ] ; } } } if ( cnt == 9 ) { System . out . println ( i ) ; System . exit ( 0 ) ; } } } System . out . println ( - 1 ) ; return 0 ; }
public static int gridLength ( int n , String [ ] grid ) { String PYDEV = System . getProperty ( " PYDEV " ) ; if ( PYDEV . equals ( " true " ) ) { System . setIn ( new FileInputStream ( " sample - input . txt " ) ) ; } return L ; }
public static double fourthPowerSum ( double n ) { return ( ( 6 * n * n * n * n ) + ( 15 * n * n * n ) + ( 10 * n * n ) - n ) / 30 ; }
@ SuppressWarnings ( " static - method " ) public int maxLenSub ( int [ ] arr , int n ) { Map < Integer , Integer > um = new HashMap < > ( ) ; int maxLen = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int length = 0 ; if ( ( arr [ i ] - 1 ) != null && length < um . get ( arr [ i ] - 1 ) ) { length = um . get ( arr [ i ] - 1 ) ; } if ( um . containsKey ( arr [ i ] ) && length < um . get ( arr [ i ] ) ) { length = um . get ( arr [ i ] ) ; } if ( ( arr [ i ] + 1 ) != null && length < um . get ( arr [ i ] + 1 ) ) { length = um . get ( arr [ i ] + 1 ) ; } um . put ( arr [ i ] , length + 1 ) ; if ( maxLen < um . get ( arr [ i ] ) ) { maxLen = um . get ( arr [ i ] ) ; } } return maxLen ; }
public static void rearrange ( int n ) { int temp ; if ( ( n % 2 == 1 ) ) return ; int currIdx = ( int ) ( ( n - 1 ) / 2 ) ; while ( ( currIdx > 0 ) ) { count = currIdx ; int swapIdx = currIdx ; while ( ( count > 0 ) ) { temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx = swapIdx + 1 ; count = count - 1 ; } currIdx = currIdx - 1 ; } int n = arr . length ; rearrange ( n ) ; for ( int i = 0 ; i <= n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
public static int g ( int n , int [ ] [ ] E , int S , int G ) { final String r = System . getProperty ( " line . separator " ) ; final int [ ] F = new int [ - ~ n ] ; F [ S ] = 0 ; final int [ ] H = new int [ ] { ( 0 , S ) } ; while ( H . length > 0 ) { int c = H [ 0 ] ; final int u = H [ 1 ] ; if ( u == G ) return c ; for ( int f = 0 ; f < E [ u ] . length ; f ++ ) { final int v = E [ u ] [ f ] ; final int t = c + f ; if ( t < F [ v ] ) { F [ v ] = t ; H [ 0 ] = H [ ( t ) ] [ v ] ; } } } return - 1 ; }
public static void countCharacterType ( String str ) { int vowels = 0 ; int consonant = 0 ; int specialChar = 0 ; int digit = 0 ; for ( int i = 0 ; i != str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) ) { ch = Character . toLowerCase ( ch ) ; if ( ( ch == ' a ' || ch == ' e ' || ch == ' i ' || ch == ' o ' || ch == ' u ' ) ) { vowels ++ ; } else { consonant ++ ; } } else if ( ( ch >= '0' && ch <= '9' ) ) { digit ++ ; } else { specialChar ++ ; } } System . out . println ( " Vowels : " + vowels ) ; System . out . println ( " Consonant : " + consonant ) ; System . out . println ( " Digit : " + digit ) ; System . out . println ( " Special ▁ Character : " + specialChar ) ; str = " geeks ▁ for ▁ geeks121" ; countCharacterType ( str ) ; }
public static int increaseInVol ( int l , int b , int h ) { int percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ) ; percentInc -- ; percentInc *= 100 ; return percentInc ; }
public static int MaxTotalRectangleArea ( int [ ] a , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; int i = 0 ; while ( ( i < n - 1 ) ) { if ( ( i != 0 ) ) { i = i + 1 ; } if ( ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == false ) ) { flag = true ; len = a [ i + 1 ] ; i = i + 1 ; } else if ( ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == true ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i = i + 1 ; } } return sum ; }
public static final double getDistance ( double [ ] array , double [ ] dist ) { double distance = 0 ; double sum = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { sum += array [ i ] * array [ i ] ; } double distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { sum += array [ i ] * array [ i ] ; } double distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { distance += array [ i ] * array [ i ] ; } double distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { distance += array [ i ] * array [ i ] ; } double distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { distance += array [ i ] * array [ i ] ; } double distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { distance += array [ i ] * array [ i ] ; } double distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] * array [ i ] ; distance += array [ i ] ; distance += array [ i ] ; return distance
public static void lastFiveDigits ( long n ) { n = ( ( ( long ) ( n / 10000 ) ) * 10000 + ( ( ( long ) ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( ( long ) ( n / 10 ) % 10 ) * 10 + ( ( long ) ( n / 1000 ) % 10 ) ) ) ; long ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } System . out . println ( ans ) ; }
public static String compute ( ) { final int DIGITS = 100 ; final int MULTIPLIER = 100 * DIGITS ; int ans = 100 ; for ( int i = 0 ; i < 100 ; i ++ ) { if ( Math . sqrt ( i ) * i != i ) { ans = Math . pow ( i , 2 ) ; } } return String . valueOf ( ans ) ; if ( Thread . currentThread ( ) . getName ( ) . equals ( " _ _ main _ _ " ) ) { System . out . println ( compute ( ) ) ; } return null ; }
public static void evaluate ( int n ) { if ( ( n == 1 ) || ( n == 2 ) ) { System . out . println ( " No ▁ Pythagoras " + " ▁ Triplet ▁ exists " ) ; } else if ( ( n % 2 == 0 ) ) { int var = n * n / 4 ; System . out . print ( " Pythagoras ▁ Triplets " + " ▁ exist ▁ i . e . ▁ " ) ; System . out . println ( ( int ) n + " ▁ " + ( int ) var - 1 + " ▁ " + ( int ) var + 1 ) ; } else if ( ( n % 2 != 0 ) ) { int var = n * n + 1 ; System . out . print ( " Pythagoras ▁ Triplets ▁ " + " exist ▁ i . e . ▁ " ) ; System . out . println ( ( int ) n + " ▁ " + ( int ) var / 2 - 1 + " ▁ " + ( int ) var / 2 ) ; } } n = 22 ; evaluate ( n ) ; }
public static int d ( int a , int b ) { int abx [ ] = Integer . parseInt ( input ( ) ) ; return abx [ 0 ] ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) ) { return b ; } return gcd ( b % a , a ) ; }
static int countKdivPairs ( int [ ] A , int n , int K ) { int [ ] freq = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) { freq [ i ] = 0 ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int rem = A [ i ] % K ; if ( ( rem != 0 ) ) { ans += freq [ K - rem ] ; } else { ans += freq [ 0 ] ; } freq [ rem ] ++ ; } return ans ; }
public static double getDistance ( double a , double b ) { return Math . sqrt ( a * a + b * b ) ; }
public static int [ ] input ( ) { return Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int [ ] list = new int [ n ] ; System . arraycopy ( System . getProperty ( " line . separator " ) , 0 , list , 0 , list . length ) ; if ( list [ 0 ] != list [ list . length - 1 ] ) System . out . println ( n - 1 ) ; else { int i = 1 ; while ( i < n && list [ i ] == list [ 0 ] ) i ++ ; int j = n - 2 ; while ( j >= 0 && list [ j ] == list [ 0 ] ) j -- ; System . out . println ( Math . max ( n - i - 1 , j ) ) ; } return list ; }
static int countSubarrays ( int [ ] arr , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hashPositive = new int [ n + 1 ] ; int [ ] hashNegative = new int [ n + 1 ] ; hashPositive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) { difference = difference + 1 ; } else { difference = difference - 1 ; } if ( ( difference < 0 ) ) { ans += hashNegative [ -- difference ] ; hashNegative [ -- difference ] = hashNegative [ - difference ] + 1 ; } else { ans += hashPositive [ difference ] ; hashPositive [ difference ] = hashPositive [ difference ] + 1 ; } } return ans ; arr = Arrays . asList ( 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ) ; n = arr . length ; System . out . println ( " Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays ▁ are ▁ " + countSubarrays ( arr , n ) ) ; return ans ; }
public static void printChar ( String string , int n ) { int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i <= n ; i ++ ) { freq [ ( int ) string . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i <= n ; i ++ ) { if ( ( freq [ ( int ) string . charAt ( i ) - ' a ' ] % 2 ) == 0 ) { System . out . print ( string . charAt ( i ) ) ; } } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { string = " geeksforgeeks " ; n = string . length ( ) ; printChar ( string , n ) ; } }
public static void printChar ( String str_ , int n ) { final int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ ( int ) ( ( int ) str_ . charAt ( i ) - ( int ) ' a ' ) ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( freq [ ( int ) ( int ) ( str_ . charAt ( i ) - ( int ) ' a ' ) ] % 2 ) == 1 ) { System . out . print ( ( int ) str_ . charAt ( i ) + " " ) ; } } if ( String . valueOf ( ) . equals ( " " ) ) { str_ = " geeksforgeeks " ; n = str_ . length ( ) ; printChar ( str_ , n ) ; } }
static int countGreater ( int [ ] arr , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( ( l <= r ) ) { int m = ( int ) ( l + ( r - l ) / 2 ) ; if ( ( arr [ m ] > k ) ) { leftGreater = m ; r = m - 1 ; } else { l = m + 1 ; } } return ( n - leftGreater ) ; }
public static int getDistance ( String [ ] [ ] ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int m = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; if ( m == 1 ) { System . out . println ( 2 * n % 1000000 ) ; } else { int [ ] [ ] [ ] dp = new int [ 3 ] [ n + 1 ] [ ] ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int y = 0 ; y < n ; y ++ ) { for ( int x = 0 ; x < 3 ; x ++ ) { for ( int slideLimit = 0 ; slideLimit < y + 1 ; slideLimit ++ ) { if ( x == 0 ) { dp [ y + 1 ] [ 0 ] [ slideLimit ] += dp [ y ] [ 0 ] [ slideLimit ] ; dp [ y + 1 ] [ 1 ] [ y + 1 ] += dp [ y ] [ 0 ] [ slideLimit ] ; dp [ y + 1 ] [ 2 ] [ y + 1 ] += dp [ y ] [ 0 ] [ slideLimit ] * ( y - slideLimit + 1 ) ; } if ( x == 1 ) { dp [ y + 1 ] [ 0 ] [ y + 1 ] += dp [ y ] [ 1 ] [ slideLimit ] ; dp [ y + 1 ] [ 1 ] [ slideLimit ] += dp [ y ] [ 1 ] [ slideLimit ] ; } if ( x == 2 ) { dp [ y + 1 ] [ 0 ] [ y + 1 ] += dp [ y ] [ 2 ] [ slideLimit ] * ( y - slideLimit + 1 ) ; dp [ y + 1 ] [ 1 ] [ y + 1 ] += dp [ y ] [ 2 ] [ slideLimit ] ; dp [ y + 1 ] [ 2 ] [ slideLimit ] += dp [ y ] [ 2 ] [ slideLimit ] ; } } } } } System . out . println ( ( Math . sum ( dp [ n ] . length , 2 ) + Math . sum ( dp [ n ] [ 0 ] [ slideLimit ] * ( n - slideLimit ) ) ) % 1000000 ) ; return m ; }
@ SuppressWarnings ( " static - method " ) public void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( ( val < 0 ) ) { System . out . println ( " NO " ) ; return ; } double a = ( N + Math . sqrt ( val ) ) / 2.0 ; double b = ( N - Math . sqrt ( val ) ) / 2.0 ; System . out . println ( " a ▁ = " + String . format ( " % d " , a ) ) ; System . out . println ( " b ▁ = " + String . format ( " % d " , b ) ) ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPro
public static String getCountry ( String country ) { if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else { return " " " " ; } else { return " " " ; }
public static void solve ( String A , String B , String C ) { A = A . substring ( 0 , A . length ( ) - 1 ) ; B = B . substring ( 0 , B . length ( ) - 1 ) ; C = C . substring ( 0 , C . length ( ) - 1 ) ; int [ ] before = { 1 , 0 , 0 } ; int N = A . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] dp = new int [ 3 ] ; int s = 0 ; if ( i == N - 1 ) { s ++ ; } for ( int j = 0 ; j < 3 ; j ++ ) { for ( int a = s ; a < 10 ; a ++ ) { if ( A . charAt ( i ) != ' ? ' && Integer . parseInt ( A . charAt ( i ) ) != a ) continue ; for ( int b = s ; b < 10 ; b ++ ) { if ( B . charAt ( i ) != ' ? ' && Integer . parseInt ( B . charAt ( i ) ) != b ) continue ; for ( int c = s ; c < 10 ; c ++ ) { if ( C . charAt ( i ) != ' ? ' && Integer . parseInt ( C . charAt ( i ) ) != c ) continue ; if ( ( j + a + b ) % 10 != c ) continue ; dp [ ( j + a + b ) / 10 ] += before [ j ] ; dp [ ( j + a + b ) / 10 ] %= MOD ; } } } } before = dp ; } int ans = before [ 0 ] ; System . out . println ( ans ) ; }
public static int getRandom ( ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int test = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int move = 0 ; while ( test != 1 ) { if ( test % 6 == 0 ) { test = test / 6 ; move ++ ; } else if ( test % 3 == 0 ) { test = test * 2 ; move ++ ; } else { System . out . println ( - 1 ) ; break ; } } else { System . out . println ( move ) ; } } return n ; }
public static int minIncrementForUnique ( int [ ] A ) { final int [ ] count = A . toArray ( ) ; final Stack < Integer > taken = new Stack < > ( ) ; int ans = 0 ; for ( int x = 0 ; x < 100000 ; x ++ ) { if ( count [ x ] >= 2 ) { taken . push ( x ) ; taken . pop ( ) ; } else if ( taken . empty ( ) && count [ x ] == 0 ) { ans += x - taken . pop ( ) ; } } return ans ; }
public static int getUnsignedInt ( String value ) { try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException e ) { return 0 ; } }
public static int modulo13 ( String s , int n ) { final int MOD = ( ( int ) ( 1e9 + 7 ) ) ; int [ ] [ ] dp = new int [ n + 1 ] [ 13 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int nxt = ( int ) s . charAt ( i ) - '0' ; if ( ( s . charAt ( i ) == ' ? ' ) ) { nxt = j ; } for ( int k = 0 ; k < 13 ; k ++ ) { int rem = ( 10 * k + nxt ) % 13 ; dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; dp [ i + 1 ] [ rem ] %= MOD ; } if ( ( s . charAt ( i ) != ' ? ' ) ) { break ; } } } return ( int ) dp [ n ] [ 5 ] ; } if ( String . valueOf ( s ) . equals ( " " ) ) { s = " ? 44" ; n = s . length ( ) ; System . out . println ( modulo13 ( s , n ) ) ; } return ( int ) dp [ n ] [ 5 ] ; }
public static int countNums ( int a , int b , int c , int d ) { int x = b / c - ( a - 1 ) / c ; int y = b / d - ( a - 1 ) / d ; int k = ( c * d ) / gcd ( c , d ) ; int z = b / k - ( a - 1 ) / k ; return ( b - a + 1 - x - y + z ) ; }
public static void printSubstrings ( int n ) { int s = ( int ) Math . log10 ( n ) ; int d = ( Math . pow ( 10 , s ) ) ; int k = d ; while ( ( n > 0 ) ) { while ( ( d > 0 ) ) { System . out . println ( ( int ) ( n / d ) ) ; d = ( int ) ( d / 10 ) ; } n = ( int ) ( n % k ) ; k = ( int ) ( k / 10 ) ; d = k ; } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { n = 123 ; printSubstrings ( n ) ; } }
public static char NthCharacter ( int n ) { String s = " " ; int c = 1 ; while ( ( c = ( int ) ( System . currentTimeMillis ( ) / 1000 ) ) != 0 ) { if ( ( c < 10 ) ) { s += ( char ) ( 48 + c ) ; } else { String s1 = " " ; int dup = c ; while ( ( dup > 0 ) ) { s1 += ( char ) ( ( dup % 10 ) + 48 ) ; dup /= 10 ; } s1 = s1 . charAt ( 0 ) ; s += s1 ; } c ++ ; if ( ( s . length ( ) >= n ) ) { return s . charAt ( n - 1 ) ; } } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { n = 11 ; System . out . println ( NthCharacter ( n ) ) ; } return s . charAt ( n - 1 ) ; }
public static int days ( int y , int m , int d ) { int cnt = 0 ; for ( int i = 1 ; i < y ; i ++ ) { if ( i % 3 == 0 ) cnt += 200 ; else cnt += 195 ; } for ( int i = 1 ; i < m ; i ++ ) { if ( y % 3 == 0 ) cnt += 20 ; else { if ( i % 2 == 0 ) cnt += 19 ; else cnt += 20 ; } } cnt += d - 1 ; return cnt ; } int n = Integer . parseInt ( input ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { y = Integer . parseInt ( input ( ) ) ; m = Integer . parseInt ( input ( ) ) ; d = Integer . parseInt ( input ( ) ) ; System . out . println ( days ( 1000 , 1 , 1 ) - days ( y , m , d ) ) ; }
public static boolean checkPrime ( int n ) { if ( ( n <= 1 ) ) { return false ; } if ( ( n <= 3 ) ) { return true ; } if ( ( n % 2 == 0 ) || ( n % 3 == 0 ) ) { return false ; } for ( int i = 5 ; i <= n ; i += 6 ) { if ( ( n % i == 0 ) || ( n % ( i + 2 ) == 0 ) ) { return false ; } } return true ; }
@ Function public static int getGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatestGreatest
public static int catalan ( int n ) { if ( ( n == 0 ) || ( n == 1 ) ) { return 1 ; } int [ ] catalan = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { catalan [ i ] = 0 ; } catalan [ 0 ] = 1 ; catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { catalan [ i ] = catalan [ i ] + catalan [ j ] * catalan [ i - j - 1 ] ; } } return catalan [ n ] ; }
public static String compute ( ) { final double TARGET = Math . toRadians ( 15499 ) ; final double totient = 1 ; double denominator = 1 ; int p = 2 ; do { totient *= p - 1 ; denominator *= p ; do { p ++ ; } while ( Math . isPrime ( p ) ) ; } while ( Math . toDegrees ( totient ) < TARGET ) ; for ( int i = 1 ; i < p ; i ++ ) { final double numer = i * totient ; final double denom = i * denominator ; if ( Math . toDegrees ( numer ) < denom - 1 ) { return String . valueOf ( denom ) ; } } return String . valueOf ( ) ; }
public static int getDistance ( int [ ] array , int [ ] values ) { int [ ] dist = new int [ array . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { int [ ] a = array [ i ] ; for ( int j = 0 ; j < values . length ; j ++ ) { if ( j == values [ j ] ) { dist [ j ] = i ; } } } return dist [ 0 ] ; }
public static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n == 2 ) return true ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= ( int ) Math . sqrt ( n ) ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; }
static double countDyckPaths ( int n ) { double res = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
public static void addNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumberToNumber
@ NonNull public static String solve ( String string ) { int n = Integer . parseInt ( string ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < a . length ; i ++ ) a [ i ] = Math . pow ( a [ i ] , 2 ) ; return String . valueOf ( Arrays . toString ( a ) ) ; }
public static int [ ] getNegativeInstances ( ) { int [ ] a = new int [ 13 ] ; for ( int i = 0 ; i <= 14 ; i ++ ) { a [ i ] = Integer . parseInt ( input ( ) ) ; } int ans = 0 ; for ( int i = 0 ; i <= 14 ; i ++ ) { int [ ] x = new int [ 14 ] ; int n = a [ i ] / 14 ; int r = a [ i ] % 14 ; x [ i ] = 0 ; for ( int j = 0 ; j <= 14 ; j ++ ) { x [ j ] += n ; } if ( r >= 13 - i ) { for ( int j = i + 1 ; j <= 14 ; j ++ ) { x [ j ] += 1 ; } for ( int j = 0 ; j <= r - 13 + i ; j ++ ) { x [ j ] += 1 ; } } else { for ( int j = i + 1 ; j <= i + 1 + r ; j ++ ) { x [ j ] += 1 ; } } int summ = 0 ; for ( int j : x ) { if ( j % 2 == 0 ) { summ += j ; } } ans = Math . max ( ans , summ ) ; } System . out . println ( ans ) ; return a ; }
public static double pentdiagonal ( double a ) { if ( ( a < 0 ) ) { return - 1 ; } double d = 1.22 * a ; return d ; }
public static int hexDiagonal ( int a ) { if ( ( a < 0 ) ) { return - 1 ; } int d = 1.73 * a ; return d ; }
public static void translate ( String st ) { int l = st . length ( ) ; if ( ( l < 2 ) ) return ; int i = 0 ; int j = 0 ; while ( ( j < l - 1 ) ) { if ( ( st . charAt ( j ) == ' A ' ) && ( st . charAt ( j + 1 ) == ' B ' ) ) { j += 2 ; st . setChar ( ' C ' ) ; i ++ ; continue ; } st . setChar ( st . charAt ( j ) ) ; i ++ ; j ++ ; } if ( ( j == l - 1 ) ) { st . setChar ( st . charAt ( j ) ) ; i ++ ; } st . setChar ( ' ▁ ' ) ; st . setChar ( l - 1 ) ; } StringTokenizer st = new StringTokenizer ( " helloABworldABGfG " ) ; translate ( st ) ; System . out . println ( " The ▁ modified ▁ string ▁ is ▁ : " ) ; System . out . println ( st . toString ( ) ) ; }
public static void translate ( String [ ] st ) { for ( int i = 1 ; i < st . length ; i ++ ) { if ( ( st [ i - 1 ] . equals ( " A " ) ) && ( st [ i ] . equals ( " B " ) ) ) { st [ i - 1 ] = ' C ' ; for ( int j = i ; j < st . length - 1 ; j ++ ) { st [ j ] = st [ j + 1 ] ; } st [ st . length - 1 ] = ' ▁ ' ; } } return ; StringBuilder sb = new StringBuilder ( " helloABworldABGfG " ) ; translate ( sb . toString ( ) ) ; System . out . println ( " The ▁ modified ▁ string ▁ is ▁ : " ) ; System . out . println ( sb . toString ( ) ) ; }
public static String compute ( ) { final int TARGET = 2000 ; int count = 2 ; for ( int ring = 0 ; ring < 2 ; ring ++ ) { if ( Arrays . equals ( new int [ ] { ring * 6 - 1 , ring * 6 + 1 , ring * 12 + 5 } , new int [ ] { ring * 6 , ring * 12 + 5 } ) ) { count ++ ; if ( count == TARGET ) { return String . valueOf ( ring * ( ring - 1 ) * 3 + 2 ) ; } } if ( Arrays . equals ( new int [ ] { ring * 6 - 1 , ring * 6 + 5 , ring * 12 - 7 } , new int [ ] { ring * 6 , ring * 6 + 5 , ring * 12 - 7 } ) ) { count ++ ; if ( count == TARGET ) { return String . valueOf ( ring * ( ring + 1 ) * 3 + 1 ) ; } } } if ( String . format ( " % s " , " % s " , " % s " , " % s " , " % s " , " % s " , " % s " , " % s " , " % s " % s " , " % s " % s " , " % s " % s " , " % s " % s " % s " , " % s " % s " % s " , " % s " % s " % s " , " % s " % s " % s " , " % s " % s " % s " % " % s " % s " , " % s " % s " % s " % " % s " % s " ) ) { count ++ ; if ( count == TARGET ) { return String . valueOf ( ring * ( ring + 1 ) * 3 + 1 ) ; } } return String . format ( " % s " , " % s " , " % s " % " % s " , " % s " % " % s " , " % s " % " % s " % " % s " , " % s " % s " % " % s " % s " , " % s " % s " % s " , " % s " % s " % " % s " % s " , " % s " % s " % s " % s " , " % s " % s " % s " ) ; return String . format ( " % s " , "
public static int getDistance ( int [ ] array ) { int distance = array . length ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == 0 ) { distance = i ; } else if ( array [ i ] == 1 ) { distance = i ; } else if ( array [ i ] == 2 ) { distance = i ; } else if ( array [ i ] == 3 ) { distance = i ; } else if ( array [ i ] == 4 ) { distance = i ; } else if ( array [ i ] == 5 ) { distance = i ; } else if ( array [ i ] == 6 ) { distance = i ; } else if ( array [ i ] == 7 ) { distance = i ; } else if ( array [ i ] == 8 ) { distance = i ; } else if ( array [ i ] == 9 ) { distance = i ; } else if ( array [ i ] == 10 ) { distance = i ; } else if ( array [ i ] == 11 ) { distance = i ; } else if ( array [ i ] == 12 ) { distance = i ; } return distance ; }
public static void Digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( ( n = n ) != 0 ) { int r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = n / 10 ; } System . out . println ( largest + " ▁ " + smallest ) ; }
public static void solve ( int d1 , int d2 , int d3 ) { int maxx = Math . max ( d1 , Math . max ( d2 , d3 ) ) ; int sum = ( d1 + d2 + d3 ) ; if ( ( 2 * maxx > sum || sum % 2 == 1 ) ) { System . out . println ( " - 1" ) ; return ; } int x1 = 0 ; int y1 = 0 ; int x2 = d1 ; int y2 = 0 ; int x3 = ( d1 + d2 - d3 ) / 2 ; int y3 = ( d2 + d3 - d1 ) / 2 ; System . out . println ( " ( " + x1 + " , " + y1 + " ) , ▁ ( " + x2 + " , " + y2 + " ) ▁ and ▁ ( " + x3 + " , " + y3 + " ) " ) ; } d1 = 3 ; d2 = 4 ; d3 = 5 ; solve ( d1 , d2 , d3 ) ; }
public static boolean distributingBalls ( int k , int n , String string ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ ( int ) string . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( ( a [ i ] > k ) ) { return false ; } } return true ; }
public static void printString ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' T ' ) { i ++ ; } else { i -- ; } if ( i > s . charAt ( i ) || i < s . charAt ( i ) ) { break ; } } System . out . println ( i == s . length ( ) ) ; }
public static String getCountry ( String country ) { if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " " " " ; } else if ( country == null ) { return " "
public static int first ( int [ ] arr , int low , int high ) { final int [ ] [ ] arr = new int [ ] [ ] { { 0 , 0 , 0 , 1 } , { 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 2 , 2 , 2 } , { 4 , 2 , 2 } , { 5 , 2 , 2 } , { 6 , 2 , 2 } , { 8 , 2 } , { 9 , 2 } , { 10 , 2 } , { 11 , 2 } , { 11 , 2 } , { 12 , 2 } , { 11 , 2 } , { 12 , 2 } , { 13 , 2 } , { 14 , 2 } , { 15 , 2 } , { 16 , 2 } , { 17 , 2 } , { 18 , 2 } , { 19 , 2 } , { 20 , 2 } , { 21 , 2 } , { 22 , 2 } , { 23 , 2 } , { 23 , 2 } , { 23 , 2 } , { 23 , 2 } , { 24 , 2 } , { 25 , 2 } , { 26 , 2 } , { 27 , 2 } , { 26 , 2 } , { 27 , 2 } , { 26 , 2 } , { 27 , 2 } , { 26 , 2 } , { 26 , 2 } , { 27 , 2 } , { 26 , 2 } , { 27 , 2 } , { 26 , 2 } , { 27 , 2 } , { 26 , 2 } , { 27 , 2 } , { 26 , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , 2 } , { 27 , 2 } , { 27 , 2 } , { 27 , 2 } , 2 } , { 27 , 2 } , { 27 , 2 } , 2 } , { 27 , 2 } , 2 } , { 27 , 2 } , { 27 , 2 } , 2 } , { 27 , 2 } } }
public static int bitAtGivenPosSetOrUnset ( int n , int k ) { int newNum = n >>> ( k - 1 ) ; return ( newNum & 1 ) ; }
public static String getLetter ( String s ) { int i , j , m , d ; if ( s . length ( ) == 0 ) { m = 0 ; j = s . length ( ) ; m = s . length ( ) ; d = s . length ( ) ; } else { m = s . length ( ) ; d = s . length ( ) ; } for ( i = 0 ; i < m ; i ++ ) { m = s . charAt ( i ) ; if ( m == ' A ' ) { m = s . charAt ( j ) ; } if ( m == ' G ' ) { m = s . charAt ( j ) ; } if ( m == ' C ' ) { m = s . charAt ( m ) ; } if ( t == ' T ' ) { m = s . charAt ( j ) ; } } return m ; }
public static double [ ] [ ] mv = new double [ ] [ ] { { - 1 , 0 } , { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } } ; while ( true ) { int n = Integer . parseInt ( input ) ; if ( n == 0 ) break ; char t1 = input [ 0 ] ; char t2 = input [ 0 ] ; char t3 = input [ 0 ] ; int s = ( int ) t1 - ' A ' ; int t = ( int ) t2 - ' A ' ; int b = ( int ) t3 - ' A ' ; double [ ] [ ] f = new double [ 3 ] [ 17 ] ; for ( int a = 0 ; a < 3 ; a ++ ) for ( int c = 0 ; c < 3 ; c ++ ) for ( int r = 0 ; r < 17 ; r ++ ) f [ 0 ] [ r ] [ s / 3 ] [ s % 3 ] = 1 ; for ( int j = 1 ; j <= n ; j ++ ) { for ( int r = 0 ; r < 3 ; r ++ ) for ( int c = 0 ; c < 3 ; c ++ ) for ( int i = 0 ; i < 4 ; i ++ ) { int r2 = r + mv [ i ] [ 0 ] , c2 = c + mv [ i ] [ 1 ] ; if ( r2 < 0 || r2 >= 3 || c2 < 0 || c2 >= 3 || 3 * r2 + c2 == b ) r2 = r , c2 = c ; f [ j ] [ r2 ] [ c2 ] += f [ j - 1 ] [ r ] [ c ] / 4 ; } } } System . out . println ( f [ n ] [ t / 3 ] [ t % 3 ] ) ; return f [ n ] [ t / 3 ] [ t % 3 ] ; }
public static int getDistance ( int [ ] array ) { int distance = array . length ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == 0 ) { distance = i ; } } return distance ; }
public static int min ( int L , int K ) { L = Math . min ( L , K ) ; return L ; }
public static boolean arePermutations ( int [ ] a , int [ ] b , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }
public static void findAndPrintUncommonChars ( String str1 , String str2 ) { int [ ] present = new int [ MAX_CHAR ] ; for ( int i = 0 ; i <= MAX_CHAR ; i ++ ) { present [ i ] = 0 ; } int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; i <= l1 ; i ++ ) { present [ ( int ) str1 . charAt ( i ) - ( int ) ' a ' ] = 1 ; } for ( int i = 0 ; i <= l2 ; i ++ ) { if ( ( present [ ( int ) str2 . charAt ( i ) - ( int ) ' a ' ] == 1 ) || ( present [ ( int ) str2 . charAt ( i ) - ( int ) ' a ' ] == - 1 ) ) { present [ ( int ) str2 . charAt ( i ) - ( int ) ' a ' ] = - 1 ; } else { present [ ( int ) str2 . charAt ( i ) - ( int ) ' a ' ] = 2 ; } } for ( int i = 0 ; i <= MAX_CHAR ; i ++ ) { if ( ( present [ i ] == 1 ) || ( present [ i ] == 2 ) ) { System . out . print ( ( char ) ( i + ( int ) ' a ' ) + " ▁ " ) ; } } if ( String . valueOf ( str1 ) . compareTo ( String . valueOf ( str2 ) ) == 0 ) { str1 = " characters " ; str2 = " alphabets " ; findAndPrintUncommonChars ( str1 , str2 ) ; } }
public static boolean isInside ( int circleX , int circleY , int rad , int x , int y ) { if ( ( ( x - circleX ) * ( x - circleX ) + ( y - circleY ) * ( y - circleY ) <= rad * rad ) ) { return true ; } else { return false ; } } x = 1 ; y = 1 ; circleX = 0 ; circleY = 1 ; rad = 2 ; if ( ( isInside ( circleX , circleY , rad , x , y ) ) ) { System . out . println ( " Inside " ) ; } else { System . out . println ( " Outside " ) ; } return false ; }
public static int minSum ( int [ ] arr , int n , int x ) { int Sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i <= n ; i ++ ) { Sum += arr [ i ] ; if ( ( arr [ i ] % x ) == 0 && largestDivisible < arr [ i ] ) { largestDivisible = arr [ i ] ; } if ( arr [ i ] < minimum ) { minimum = arr [ i ] ; } } if ( largestDivisible == - 1 ) { return Sum ; } int sumAfterOperation = ( Sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ) ; return Math . min ( Sum , sumAfterOperation ) ; }
public static int nthTerm ( int n ) { int nth = 0 ; if ( ( n % 2 == 0 ) ) { nth = 2 * ( ( n * n ) - n ) ; } else { nth = ( 2 * n * n ) - n ; } return nth ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( args [ 0 ] ) ; Node tail = new Node ( null ) ; Node node = tail ; for ( ; ; ) { String command = args [ 1 ] ; if ( command . startsWith ( "0" ) ) { Node nn = new Node ( Integer . parseInt ( command . substring ( 2 ) ) ) ; nn . prev = node . prev ; nn . next = node ; if ( node . prev != null ) { node . prev . next = nn ; } node . prev = nn ; node = node . prev ; } else if ( command . startsWith ( "1" ) ) { int i = Integer . parseInt ( command . substring ( 2 ) ) ; if ( i > 0 ) { for ( ; ; ; ) { node = node . next ; } } else { for ( ; ; ; ) { for ( ; ; ) { if ( - i ) { node = node . prev ; } } } } } else if ( command . startsWith ( "2" ) ) { Node p = node . prev ; n = node . next ; node . prev = null ; node . next = null ; node = n ; if ( p == null ) { n . prev = null ; } else { n . prev = p ; p . next = n ; } } else { throw new IllegalArgumentException ( " invalid ▁ command " ) ; } } Stack < String > st = new Stack < String > ( ) ; node = tail . prev ; while ( node != null ) { st . push ( node . value ) ; node = node . prev ; } while ( st . size ( ) > 0 ) { System . out . println ( st . pop ( ) ) ; } }
public static String getRandom ( String s ) { int n = Integer . parseInt ( s ) ; int k = Integer . parseInt ( s ) ; String result = " " ; int common = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { String a = s . substring ( n - 1 - i ) ; String b = s . substring ( 0 , i + 1 ) ; if ( ( a . equals ( b ) ) ) { common = i + 1 ; continue ; } } int ans = ( n ) + ( k - 1 ) * ( n - common ) ; String finalResult = s ; for ( int i = 0 ; i < k - 1 ; i ++ ) { finalResult += ( result . substring ( common ) ) ; } return finalResult ; }
public static int [ ] getBinaryTree ( int [ ] preM , int preIndex , int l , int h , int size ) { int preIndex = 0 ; int preMIndex = 0 ; int root , x ; preMIndex = preIndex ; root = new int [ preM . length ] ; x = preM [ preIndex ] ; x = preMIndex ; x = preM [ preIndex ] ; x = preMIndex ; x = preM [ preIndex ] ; x = preMIndex + x ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; x = preM [ preIndex ] ; return x
public static String findSubString ( String string , String pat ) { int len1 = string . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } int [ ] hashPat = new int [ noOfChars ] ; int [ ] hashStr = new int [ noOfChars ] ; for ( int i = 0 ; i <= len2 ; i ++ ) { hashPat [ ( int ) pat . charAt ( i ) ] ++ ; } int start = 0 , startIndex = - 1 , minLen = Double . MAX_VALUE ; int count = 0 ; for ( int j = 0 ; j <= len1 ; j ++ ) { hashStr [ ( int ) string . charAt ( j ) ] ++ ; if ( ( hashPat [ ( int ) string . charAt ( j ) ] != 0 ) && ( hashStr [ ( int ) string . charAt ( j ) ] <= hashPat [ ( int ) string . charAt ( j ) ] ) ) count ++ ; } if ( count == len2 ) { while ( ( hashStr [ ( int ) string . charAt ( start ) ] > hashPat [ ( int ) string . charAt ( start ) ] || hashPat [ ( int ) string . charAt ( start ) ] == 0 ) ) { if ( ( hashStr [ ( int ) string . charAt ( start ) ] > hashPat [ ( int ) string . charAt ( start ) ] ) ) { hashStr [ ( int ) string . charAt ( start ) ] -- ; } start ++ ; } int lenWindow = j - start + 1 ; if ( minLen > lenWindow ) { minLen = lenWindow ; startIndex = start ; } } if ( startIndex == - 1 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } return string . substring ( startIndex , startIndex + minLen ) ; if ( className . equals ( " java . util . regex . Matcher " ) ) { string = " this ▁ is ▁ a ▁ test ▁ string " ; pat = " tist " ; System . out . println ( " Smallest ▁ window ▁ is ▁ : ▁ " ) ; System . out . println ( findSubString ( string , pat ) ) ; return " " ; }
public static double tri ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { return Math . abs ( ( x2 - x1 ) * ( y3 - y1 ) - ( y2 - y1 ) * ( x3 - x1 ) ) / 2 ; double abc , abp , acp , bcp ; do { x1 = Double . parseDouble ( input ( ) ) ; y1 = Double . parseDouble ( input ( ) ) ; x2 = Double . parseDouble ( input ( ) ) ; y2 = Double . parseDouble ( input ( ) ) ; x3 = Double . parseDouble ( input ( ) ) ; y3 = Double . parseDouble ( input ( ) ) ; x = Double . parseDouble ( input ( ) ) ; y = Double . parseDouble ( input ( ) ) ; } while ( true ) ; return abc ; }
public static int [ ] getNegativeInstances ( ) { int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int m = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int [ ] array = new int [ n + m ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; } if ( n > m ) { System . out . println ( " YES " ) ; } else if ( n < m ) { System . out . println ( " NO " ) ; } else if ( n == m ) { if ( Arrays . stream ( array ) . size ( ) % 2 != 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { System . out . println ( " NO " ) ; } return array ; }
public static int [ ] addPrimes ( ) { int n = MAX ; boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } for ( int p = 2 ; p <= n ; p ++ ) { if ( p * p > n ) break ; if ( ( prime [ p ] ) == true ) { for ( int i = 2 * p ; i <= n ; i += p ) prime [ i ] = false ; } } int [ ] ans = new int [ n + 1 ] ; for ( int p = 2 ; p <= n ; p ++ ) { if ( ( prime [ p ] ) != true ) ans [ p ] = p ; } return ans ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 4 ] ; int [ ] result = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { result [ i ] = array [ i ] ; } return result ; }
public static int result ( int n , int [ ] a ) { int validMin = 15 ; if ( a [ 0 ] > validMin ) { return validMin ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= validMin ) { validMin = 15 + a [ i ] ; } } return validMin >= 90 ? 90 : validMin ; }
public static int memo ( int index , int evenSum , int oddSum , int tight ) { if ( index == v . length ) { if ( evenSum > oddSum ) return 1 ; else return 0 ; } if ( dp [ index ] [ evenSum ] [ oddSum ] [ tight ] != - 1 ) return dp [ index ] [ evenSum ] [ oddSum ] [ tight ] ; int limit = tight != 0 ? v [ index ] : 9 ; int ans = 0 ; for ( int d = 0 ; d < limit + 1 ; d ++ ) { int currTight = 0 ; if ( d == v [ index ] ) { currTight = tight ; } if ( d % 2 != 0 ) { ans += memo ( index + 1 , evenSum , oddSum + d , currTight ) ; } else { ans += memo ( index + 1 , evenSum + d , oddSum , currTight ) ; } } dp [ index ] [ evenSum ] [ oddSum ] [ tight ] = ans ; return ans ; }
public static int [ ] [ ] getNegativeInstances ( ) { int [ ] [ ] array = new int [ 3 ] [ 3 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = Integer . parseInt ( array [ i ] [ 0 ] ) ; } int total = 0 ; for ( int i = 0 ; i < array [ 0 ] . length ; i ++ ) { for ( int j = 0 ; j < array [ i ] [ j ] ; j ++ ) { total += array [ i ] [ j ] ; } } total = total / 3 ; boolean flag = true ; for ( int i = 0 ; i < array [ 0 ] . length ; i ++ ) { int a = array [ 0 ] [ i % 3 ] + array [ 1 ] [ ( i + 1 ) % 3 ] + array [ 2 ] [ ( i + 2 ) % 3 ] ; if ( a != total ) { flag = false ; } } int a = array [ 0 ] [ 0 ] + array [ 1 ] [ 2 ] + array [ 2 ] [ 1 ] ; if ( a != total ) { flag = false ; } a = array [ 1 ] [ 1 ] + array [ 0 ] [ 2 ] + array [ 2 ] [ 0 ] ; if ( a != total ) { flag = false ; } a = array [ 2 ] [ 2 ] + array [ 1 ] [ 0 ] + array [ 0 ] [ 1 ] ; if ( a != total ) { flag = false ; } if ( flag ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return array ; }
public static void solve ( ) { for ( int t = 0 ; t < Integer . parseInt ( System . console ( ) . readLine ( ) ) ; t ++ ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int [ ] diff = new int [ n ] ; for ( String s : System . console ( ) . readLine ( ) . split ( " ▁ " ) ) { diff [ t ] = Integer . parseInt ( s ) ; } int [ ] arr = new int [ n ] ; arr [ 0 ] = diff [ 0 ] ; boolean flag = false ; for ( int i = 1 ; i < diff . length ; i ++ ) { int x = arr [ i - 1 ] + diff [ i ] ; int y = arr [ i - 1 ] - diff [ i ] ; if ( y >= 0 && x != y ) { flag = true ; break ; } else { arr [ i ] = x ; } } if ( flag ) { System . out . println ( - 1 ) ; } else { for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; } } if ( System . console ( ) . readLine ( ) . equals ( " solve " ) ) { solve ( ) ; } }
public static String compute ( ) { return "0" ; }
public static int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] == x ) ) { return i ; } } return - 1 ; arr = new int [ ] { 2 , 3 , 4 , 10 , 40 } ; x = 10 ; n = arr . length ; int result = search ( arr , n , x ) ; if ( ( result == - 1 ) ) { System . out . println ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) ; } else { System . out . println ( " Element ▁ is ▁ present ▁ at ▁ index " + result ) ; } return result ; }
public static int getDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOfDegreeOf
public static int toggleBitsFromLToR ( int n , int l , int r ) { int num = ( ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ) ; return ( n ^ num ) ; }
public static int MinStep ( int [ ] a , int n ) { int positive = 0 ; int negative = 0 ; int zero = 0 ; int step = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == 0 ) ) { zero ++ ; } else if ( ( a [ i ] < 0 ) ) { negative ++ ; step = step + ( - 1 - a [ i ] ) ; } else { positive ++ ; step = step + ( a [ i ] - 1 ) ; } } if ( ( negative % 2 ) == 0 ) { step = step + zero ; } else { if ( ( zero > 0 ) ) { step = step + zero ; } else { step = step + 2 ; } } return step ; } if ( Class . isPrimitive ( String . class ) ) { a = Arrays . asList ( 0 , - 2 , - 1 , - 3 , 4 ) ; n = a . length ; System . out . println ( MinStep ( a , n ) ) ; } return 0 ; }
public static String toStr ( String s ) { String [ ] parts = s . split ( " ▁ " ) ; if ( parts . length == 1 ) { return parts [ 0 ] ; } else if ( parts . length == 2 ) { return parts [ 1 ] ; } else if ( parts . length == 3 ) { return parts [ 2 ] ; } else if ( parts . length == 4 ) { return parts [ 3 ] ; } else if ( parts . length == 5 ) { return parts [ 4 ] ; } else if ( parts . length == 6 ) { return parts [ 4 ] ; } else if ( parts . length == 7 ) { return parts [ 4 ] ; } else if ( parts . length == 8 ) { return parts [ 8 ] ; } else if ( parts . length == 9 ) { return parts [ 9 ] ; } else if ( parts . length == 10 ) { return parts [ 10 ] ; } else if ( parts . length == 11 ) { return parts [ 11 ] ; } else if ( parts . length == 12 ) { return parts [ 12 ] ; } else if ( parts . length == 13 ) { return parts [ 13 ] ; } else if ( parts . length == 14 ) { return parts [ 14 ] ; } else if ( parts . length == 15 ) { return parts [ 15 ] ; } else if ( parts . length == 16 ) { return parts [ 16 ] ; } else if ( parts . length == 17 ) { return parts [ 17 ] ; } else if ( parts . length == 18 ) { return parts [ 18 ] ; } else if ( parts . length == 19 ) { return parts [ 19 ] ; } else if ( parts . length == 19 ) { return parts [ 19 ] ; } else if ( parts . length == 20 ) { return parts [ 20 ] ; } else if ( parts . length == 19 ) { return parts [ 19 ] ; } else if ( parts . length == 20 ) { return parts [ 20 ] ; } else if ( parts . length == 21 ) { return parts [ 21 ] ; } else if ( parts . length == 22 ) { return parts [ 22 ] ; } else if ( parts . length == 23 ) { return parts [ 23 ] ; } else if ( parts . length == 19 ) { return parts [ 23 ] ; } else if ( parts . length == 23 ) { return parts [ 23 ] ; return parts [ 23 ] ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int n = Integer . parseInt ( args [ i ] ) ; int [ ] v = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) v [ j ] = Integer . parseInt ( args [ i ] ) ; Arrays . sort ( v ) ; System . out . println ( v [ n - 1 ] + v [ n - 2 ] ) ; } }
public static void noOfSquares ( int x1 , int y1 , int x2 , int y2 ) { int dx = Math . abs ( x2 - x1 ) ; int dy = Math . abs ( y2 - y1 ) ; int ans = dx + dy - Math . gcd ( dx , dy ) ; System . out . println ( ans ) ; if ( Class . isPrimitive ( ) ) { x1 = 1 ; y1 = 1 ; x2 = 4 ; y2 = 3 ; noOfSquares ( x1 , y1 , x2 , y2 ) ; } }
public static String getMaximum ( String s , int [ ] a ) { StringBuilder sb = new StringBuilder ( s ) ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( int ) s . charAt ( i ) - '0' ) < a [ ( int ) s . charAt ( i ) - '0' ] ) { int j = i ; while ( ( j < n ) && ( ( int ) s . charAt ( j ) - '0' <= a [ ( int ) s . charAt ( j ) - '0' ] ) ) { sb . setCharAt ( j , ( char ) ( '0' + a [ ( int ) s . charAt ( j ) - '0' ] ) ) ; j ++ ; } return sb . toString ( ) ; } } return s ; }
public static boolean isOctal ( int n ) { while ( ( n = ( n ) ) != 0 ) { if ( ( ( n % 10 ) >= 8 ) ) { return false ; } else { n = ( int ) ( n / 10 ) ; } } if ( isPalindrome ( n ) ) { int divide = ( isOctal ( n ) == false ) ? 8 : 10 ; int [ ] octal = new int [ 2 ] ; while ( ( n != 0 ) ) { octal [ 0 ] = n % divide ; n = ( int ) ( n / divide ) ; } int j = octal . length - 1 ; int k = 0 ; while ( ( k <= j ) ) { if ( ( octal [ j ] != octal [ k ] ) ) { return false ; } j -- ; k ++ ; } return true ; } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { int n = 97 ; if ( ( isPalindrome ( n ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } return false ; }
public static int getNum ( String input ) { int num = Integer . parseInt ( input ) ; List < Integer > listIs = new ArrayList < > ( ) ; for ( int i = 0 ; i < num ; i ++ ) { listIs . add ( Integer . parseInt ( input ) ) ; } List < Integer > listIs1 = listIs . subList ( 0 , listIs . size ( ) / 2 ) ; List < Integer > listIs2 = listIs . subList ( listIs . size ( ) / 2 , listIs . size ( ) ) ; int sum1 = Collections . sum ( listIs1 ) ; int sum2 = Collections . sum ( listIs2 ) ; boolean condition = false ; for ( int i = 0 ; i < listIs . size ( ) ; i ++ ) { if ( listIs . get ( i ) == 4 || listIs . get ( i ) == 7 ) { condition = true ; continue ; } else { condition = false ; break ; } } if ( condition == true ) { if ( sum1 == sum2 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { System . out . println ( " NO " ) ; } return 0 ; }
public static int binarySearch ( int [ ] arr , int low , int high ) { if ( ( high < low ) ) { return - 1 ; } int mid = ( int ) ( ( low + high ) / 2 ) ; int midValue = arr [ mid ] ; if ( ( mid == arr [ mid ] ) ) { return mid ; } int leftindex = Math . min ( mid - 1 , midValue ) ; int left = binarySearch ( arr , low , leftindex ) ; if ( ( left >= 0 ) ) { return left ; } int rightindex = Math . max ( mid + 1 , midValue ) ; int right = binarySearch ( arr , rightindex , high ) ; return right ; }
public static int getDigitProduct ( int x ) { if ( ( x < 10 ) ) { return x ; } if ( ( prodDig [ x ] != 0 ) ) { return prodDig [ x ] ; } int prod = ( ( int ) ( x % 10 ) * getDigitProduct ( ( int ) ( x / 10 ) ) ) ; prodDig [ x ] = prod ; return prod ; }
public static int getDistance ( int [ ] array ) { int [ ] dist = array . clone ( ) ; for ( int i = 0 ; i < dist . length ; i ++ ) { if ( i < array . length ) { dist [ i ] = i ; } } return dist [ 0 ] ; }
public static double diff ( double n , double mid ) { if ( ( n > ( mid * mid * mid ) ) ) { return ( n - ( mid * mid * mid ) ) ; } else { return ( ( mid * mid * mid ) - n ) ; } }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } return array ; }
public static int inv ( int a , int m ) { int m0 = m ; int x0 = 0 ; int x1 = 1 ; if ( ( m == 1 ) ) { return 0 ; } while ( ( a > 1 ) ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( ( x1 < 0 ) ) { x1 = x1 + m0 ; } return x1 ; }
static int findMaxOR ( int [ ] arr , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int maxOR = arr [ 0 ] ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( ( maxOR = maxOR ; arr [ i ] ) > maxOR ) { maxOR = maxOR ; arr [ i ] = arr [ i ] ; count ++ ; } } return count ; }
public static int seriessum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * ( i + 1 ) / 2 ; } return sum ; }
public static int aliquotSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( n % i ) == 0 ) { sm = sm + i ; } } return sm ; }
public static int pentagonPyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
public static int fifthPowerSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sm = sm + ( i * i * i * i ) ; } return sm ; }
public static int squaresum ( int n ) { int sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sm = sm + ( i * i ) ; } return sm ; }
public static int seriessum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * ( i + 1 ) / 2 ; } return sum ; }
public static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; } return sum ; }
static int findSum ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ = ( summ + ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ) ; } return summ ; }
public static int fourthPowerSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum = sum + ( i * i * i ) ; } return sum ; }
public static int squareSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sum += ( 2 * i ) * ( 2 * i ) ; } return sum ; }
public static double AvgofSquareN ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += ( i * i ) ; } return sum / n ; }
static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += i * ( n - i ) ; } return 2 * sum ; }
public static int solve ( int n , int base ) { int sum = 0 ; while ( ( n > 0 ) ) { int remainder = n % base ; sum = sum + remainder ; n = ( int ) ( n / base ) ; } return sum ; }
public static int [ ] eratos ( int n ) { boolean [ ] isPrime = new boolean [ 110001 ] ; ArrayList < Integer > primes = new ArrayList < > ( ) ; int [ ] eratos = new int [ 110000 ] ; for ( int i = 2 ; i < Integer . MAX_VALUE ; i ++ ) { if ( isPrime [ i ] ) { int j = 2 * i ; while ( j <= n ) { isPrime [ j ] = false ; j = j + i ; } } } for ( int i = 2 ; i < 110000 ; i ++ ) { if ( isPrime [ i ] ) { primes . add ( i ) ; } } eratos [ 110000 ] = true ; while ( true ) { try { int p = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; if ( p == 0 ) { break ; } int ans = 0 ; for ( int i = 0 ; i <= p ; i ++ ) { ans += primes . get ( i ) ; } System . out . println ( ans ) ; } catch ( Exception e ) { break ; } } return primes . toArray ( new Integer [ primes . size ( ) ] ) ; }
public static String toStr ( String s ) { return s . substring ( s . indexOf ( '1' ) + 1 ) ; }
public static int optimalSearchTree ( int [ ] keys , int [ ] freq , int n ) { int [ ] [ ] cost = new int [ n ] [ n ] ; for ( int x = 0 ; x < n ; x ++ ) { for ( int y = 0 ; y < n ; y ++ ) { cost [ x ] [ y ] = 0 ; } } for ( int L = 2 ; L <= n ; L ++ ) { for ( int i = 0 ; i < n - L + 2 ; i ++ ) { int j = i + L - 1 ; if ( i >= n || j >= n ) break ; cost [ i ] [ j ] = INT_MAX ; for ( int r = i ; r <= j ; r ++ ) { int c = 0 ; if ( ( r > i ) ) c += cost [ i ] [ r - 1 ] ; if ( ( r < j ) ) c += cost [ r + 1 ] [ j ] ; c += sum ( freq , i , j ) ; if ( ( c < cost [ i ] [ j ] ) ) cost [ i ] [ j ] = c ; } } } return cost [ 0 ] [ n - 1 ] ; }
public static int get ( int x , int y , int z ) { if ( ( x > z ) ) { return - 1 ; } int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; }
public static int [ ] getNegativeInstances ( ) { int [ ] a = new int [ 2 ] ; a [ 0 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 1 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 2 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 3 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 4 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 5 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 6 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 7 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 8 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 9 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 10 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 11 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 12 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 13 ] = Integer . parseInt ( System
public static int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ k + 1 ] [ n + 1 ] ; for ( int x = 0 ; x < k ; x ++ ) { for ( int y = 0 ; y < n ; y ++ ) { for ( int i = 0 ; i < Math . min ( i , k ) ; i ++ ) { if ( ( j == 0 ) || ( j == i ) ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } } } return C [ n ] [ k ] ; }
static boolean isVowel ( char ch ) { if ( ch == ' a ' || ch == ' e ' || ch == ' i ' || ch == ' o ' || ch == ' u ' ) { return true ; } else { return false ; } }
public static void main ( String [ ] args ) { do { int N = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; if ( N == 0 ) { exit ( ) ; } final int W = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; final int H = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int [ ] [ ] persimmon = new int [ 100 ] [ 100 ] ; for ( int j = 0 ; j < N ; j ++ ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( j == N ) { persimmon [ j ] [ j ] = 1 ; } } } } } } } int [ ] [ ] cumsum = new int [ 100 ] [ 100 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( j == N ) { break ; } } } } } } for ( int j = 0 ; j < N ; j ++ ) { for ( int i = 0 ; j < N ; j ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( j == N ) { break ; } } } } } final int S = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; final int T = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int maxPersistmmon = 0 ; for ( int x = S ; x <= W ; x ++ ) { for ( int y = T ; y <= H ; y ++ ) { maxPersistmmon = Math . max ( maxPersistmmon , cumsum [ x
public static int isSubstring ( String s1 , String s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i < N - M + 1 ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( ( s2 . charAt ( i + j ) != s1 . charAt ( j ) ) ) break ; } if ( j + 1 == M ) return i ; } return - 1 ; if ( Class . forName ( " java . lang . String " ) . equals ( s1 ) ) { s1 = " for " ; s2 = " geeksforgeeks " ; int res = isSubstring ( s1 , s2 ) ; if ( res == - 1 ) System . out . println ( " Not ▁ present " ) ; else System . out . println ( " Present ▁ at ▁ index ▁ " + res ) ; } return - 1 ; }
public static double angleOncirCumference ( double z ) { return ( z / 2 ) ; }
public static void countSubarraysof1and0 ( int [ ] a , int n ) { int count1 = 0 ; int count0 = 0 ; int number1 = 0 ; int number0 = 0 ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( a [ i ] == 1 ) ) { count1 ++ ; } else { number1 += ( ( count1 ) * ( count1 + 1 ) / 2 ) ; count1 = 0 ; } } for ( int i = 0 ; i < n ; i += 1 ) { if ( ( a [ i ] == 0 ) ) { count0 ++ ; } else { number0 += ( count0 ) * ( count0 + 1 ) / 2 ; count0 = 0 ; } } if ( ( count1 ) != 0 ) { number1 += ( count1 ) * ( count1 + 1 ) / 2 ; } if ( ( count0 ) != 0 ) { number0 += ( count0 ) * ( count0 + 1 ) / 2 ; } System . out . println ( " Count ▁ of ▁ subarrays ▁ of ▁ 0 ▁ only : " + Integer . valueOf ( number0 ) ) ; System . out . println ( " Count ▁ of ▁ subarrays ▁ of ▁ 1 ▁ only : " + Integer . valueOf ( number1 ) ) ; } if ( Integer . valueOf ( number0 ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) . intValue ( ) ; }
public static void printNumbers ( int N ) { int flag = 1 ; int x = N ; if ( ( N > 0 ) ) { while ( ( x > 0 ) && ( flag == 1 ) ) { int digit = x % 10 ; if ( ( digit != 1 ) && ( digit != 3 ) ) { flag = 0 ; } x = x / 10 ; } if ( ( flag == 1 ) ) { System . out . print ( N + " ▁ " ) ; } printNumbers ( N - 1 ) ; } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { N = 20 ; printNumbers ( N ) ; } }
static void printPermutation ( int n , int k ) { int mx = n ; for ( int i = 1 ; i <= k ; i ++ ) { System . out . print ( mx ) ; mx -- ; } for ( int i = 1 ; i <= mx ; i ++ ) { System . out . print ( i ) ; } if ( Class . forName ( " java . util . regex . Matcher " ) . matches ( ) ) { int N = 5 , K = 3 ; if ( K >= N - 1 ) { System . out . println ( " Not ▁ Possible " ) ; } else { printPermutation ( N , K ) ; } } }
public static int getRandom ( ) { int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; List < Integer > l = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) l . add ( Integer . parseInt ( System . getProperty ( " user . name " ) ) ) ; int a = l . get ( 0 ) ; l . sort ( Collections . reverseOrder ( ) ) ; return l . size ( ) ; }
public static boolean isMember ( String [ ] List , String key ) { for ( int i = 0 ; ( List != null ) && ( i < List . length ) ; i ++ ) { if ( key . equals ( List [ i ] ) ) { return true ; } } return false ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositional
static void findElements ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { count = count + 1 ; } } if ( count >= 2 ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } arr = new int [ ] { 2 , - 6 , 3 , 5 , 1 } ; n = arr . length ; findElements ( arr , n ) ; }
public static int maxPathSum ( int [ ] [ ] tri , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < i + 1 ; j ++ ) { if ( ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) ) { tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; } else { tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } } return tri [ 0 ] [ 0 ] ; } int [ ] [ ] tri = new int [ ] [ ] { { 1 , 0 , 0 } , { 4 , 8 , 0 } , { 1 , 5 , 3 } } ; System . out . println ( maxPathSum ( tri , 2 , 2 ) ) ; return tri [ 0 ] [ 0 ] ; }
public static boolean isHeap ( int [ ] arr , int n ) { for ( int i = 0 ; i < ( int ) ( ( n - 2 ) / 2 ) + 1 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) { return false ; } if ( ( 2 * i + 2 < n ) && arr [ 2 * i + 2 ] > arr [ i ] ) { return false ; } } return true ; }
public static boolean isHeap ( int [ ] arr , int i , int n ) { if ( i > ( int ) ( ( n - 2 ) / 2 ) ) return true ; if ( ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) ) return true ; return false ; }
public static double dist ( double [ ] A , double [ ] B ) { double [ ] P = new double [ 3 ] ; for ( int i = 0 ; i < P . length ; i ++ ) { P [ i ] = ( V [ 0 ] ) ; V = V [ 2 ] ; } double [ ] A = P [ 0 ] , B = P [ 1 ] , C = P [ 2 ] ; for ( int i = 1 ; i < P . length ; i ++ ) { double x = P [ i ] ; double y = P [ i ] ; double x0 = P [ 0 ] ; double y0 = P [ i ] ; P [ i ] = x - x0 ; y = y - y0 ; } double a = P [ 1 ] ; double b = P [ 2 ] ; double c = P [ 3 ] ; double d = P [ 4 ] ; if ( a * d - b * c == 0 ) { System . out . println ( " NO " ) ; System . exit ( 0 ) ; } return Math . sqrt ( dist ( A , B ) ) ; }
public static int findMinDel ( int [ ] arr , int n ) { int minNum = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { minNum = Math . min ( arr [ i ] , minNum ) ; } int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] == minNum ) ) { cnt ++ ; } } return n - cnt ; }
public static int count ( int x , int y ) { int ans = 0 ; Map < Integer , Integer > m = new HashMap < > ( ) ; while ( x % y != 0 ) { x %= y ; ans ++ ; if ( m . containsKey ( x ) ) { return - 1 ; } m . put ( x , 1 ) ; x *= 10 ; } return ans ; }
public static boolean isPossibleToMakeDivisible ( int [ ] arr , int n ) { int remainder = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { remainder = ( remainder + arr [ i ] ) % 3 ; } return ( remainder == 0 ) ; arr = new int [ ] { 40 , 50 , 90 } ; n = 3 ; if ( ( isPossibleToMakeDivisible ( arr , n ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
public static int [ ] getNegativeInstances ( ) { if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } if ( ! isNumeric ( ) ) { return null ; } return null ; }
static void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { int j = 1 ; for ( j = j * j ; j <= i ; j ++ ) { if ( ( j * j ) == i ) { System . out . print ( j * j + " ▁ " ) ; break ; } } } a = 1 ; b = 100 ; System . out . println ( " Perfect ▁ cubes ▁ in ▁ given ▁ range : ▁ " ) ; printCubes ( a , b ) ; }
static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; n = 6 ; d = 4 ; return print ( n , " moduo " , d , " is " , getModulo ( n , d ) ) ; }
public static int getDistance ( String [ ] arr ) { int N = Integer . parseInt ( arr [ 0 ] ) ; int d = Integer . parseInt ( arr [ 1 ] ) ; int [ ] nums = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { nums [ i ] = Integer . parseInt ( arr [ i ] ) ; } Arrays . sort ( nums ) ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= i ; j -- ) { if ( Math . abs ( nums [ i ] - nums [ j ] ) <= d ) { ans = Math . max ( ans , j - i + 1 ) ; break ; } } } System . out . println ( N - ans ) ; return ans ; }
public static int solve ( String s ) { int a = s . charAt ( s . length ( ) - 1 ) - ' a ' ; int n = Integer . parseInt ( s . substring ( 0 , s . length ( ) - 1 ) ) ; int [ ] od = { 4 , 5 , 6 , 3 , 2 , 1 } ; int [ ] ad = { 0 , 7 , 0 , 7 } ; int c = 16 ; int ktmp = ( n - 1 ) / 4 ; int ttmp = ( n - 1 ) % 4 ; int ans = ktmp * 16 + ad [ ttmp ] + od [ a ] ; return ans ; }
public static boolean isPerfectCube ( double x ) { int cr = ( int ) ( x * ( 1 / 3 ) ) ; return ( cr * cr * cr == x ) ; }
public static final int getRandom ( ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; String s = System . console ( ) . readLine ( ) ; String t = System . console ( ) . readLine ( ) ; String test = s + t ; if ( ( s . equals ( t ) ) ) { System . out . println ( s . length ( ) ) ; System . exit ( 0 ) ; } for ( int i = 1 ; i <= n ; i ++ ) { test = s . substring ( 0 , s . length ( ) - i ) + t ; if ( ( test . substring ( 0 , n ) . equals ( s ) ) && ( test . substring ( test . length ( ) - n , t . length ( ) ) . equals ( t ) ) ) { System . out . println ( test . length ( ) ) ; System . exit ( 0 ) ; } } return s . length ( ) + t . length ( ) ; }
@ java . lang . SuppressWarnings ( " unchecked " ) public static void DFS ( int v ) { final HashMap < Integer , Integer > graph = new HashMap < > ( ) ; final int [ ] array = new int [ graph . size ( ) ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = graph . get ( array [ i ] ) ; } for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == false ) { array [ i ] = true ; } } for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == false ) { array [ i ] = true ; } } for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == false ) { array [ i ] = true ; } } System . out . println ( " Following ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) ; System . out . println ( " DFS ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) ; System . out . println ( " DFS ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) ; System . out . println ( " DFS ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) ; System . out . println ( " DFS ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) ; }
public static void countDigits ( int val , int [ ] arr ) { while ( ( val > 0 ) ) { int digit = val % 10 ; arr [ ( int ) digit ] ++ ; val = val / 10 ; } return ; }
public static String getRandom ( String s ) { if ( s == null ) return null ; int n = s . length ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Integer . parseInt ( s . substring ( i , i + 1 ) ) ; String ans = " NO " ; Arrays . sort ( a , Collections . reverseOrder ( ) ) ; while ( a . length > 0 && ! a [ a . length - 1 ] ^ 1 ) a . length -- ; Collections . reverse ( a ) ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) if ( 2 * a [ i ] > a [ i + 1 ] && a [ i ] ^ a [ i + 1 ] ) { ans = " YES " ; break ; } return ans ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int N = Integer . parseInt ( args [ i ] ) ; System . out . println ( Math . max ( 0 , N - 2 ) ) ; } }
public static String a ( ) { String s = " " ; return s . substring ( s . indexOf ( " . " ) + 1 , s . length ( ) ) ; }
public static int linearCheck ( int [ ] ar , int [ ] arr ) { for ( int i = 0 ; i < m ; i ++ ) { boolean matched = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ar [ i ] [ j ] != arr [ j ] ) ) { matched = false ; break ; } } if ( ( matched ) ) { return i + 1 ; } } return - 1 ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositional
public static double getDistance ( double [ ] values ) { double distance = 0 ; double [ ] temp = new double [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { temp [ i ] = values [ i ] ; } double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; double distance = 0 ; distance = 0 ; distance = distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; distance = distance * distance ; return distance ; }
public static int nthTerm ( int n ) { return 2 * Math . pow ( n , 2 ) + 4 * n - 2 ; int N = 4 ; return nthTerm ( N ) ; }
public static int nthTerm ( int n ) { return 7 * Math . pow ( n , 2 ) - 7 * n + 7 ; int N = 4 ; return nthTerm ( N ) ; }
public static double nthTerm ( double n ) { return 5 * Math . pow ( n , 2 ) - 5 * n ; int N = 4 ; return Math . sqrt ( nthTerm ( N ) ) ; }
public static double nthTerm ( double n ) { return Math . pow ( n , 2 ) + 2 * n + 2 ; }
public static double nthTerm ( double n ) { return 2 * Math . pow ( n , 3 ) + Math . pow ( n , 2 ) ; if ( Double . class . equals ( Double . class ) ) { int N = 3 ; System . out . println ( nthTerm ( N ) ) ; } return 0 ; }
public static int nthTerm ( int n ) { return 2 * Math . pow ( n , 2 ) - n - 1 ; }
public static double nthTerm ( double n ) { return Math . pow ( n , 2 ) - 2 * n + 2 ; }
public static int nthTerm ( int n ) { return 3 * Math . pow ( n , 2 ) + n - 2 ; int N = 4 ; return nthTerm ( N ) ; }
public static int x ( String input , int y ) { int c = Integer . parseInt ( input ) ; int x = Math . abs ( x ) , y = Math . abs ( y ) ; if ( x > 0 && y > 0 ) { System . out . println ( 0 + c + c + 0 ) ; } if ( x < 0 && y > 0 ) { System . out . println ( - c + 0 + 0 + c ) ; } if ( x > 0 && y < 0 ) { System . out . println ( 0 + - c + c + 0 ) ; } if ( x < 0 && y < 0 ) { System . out . println ( - c + 0 + 0 + - c ) ; } return x ; }
public static String getDelimiter ( String delimiter ) { if ( delimiter == null ) { return null ; } else if ( delimiter . length ( ) > 0 ) { return delimiter ; } else if ( delimiter . length ( ) > 0 ) { return delimiter ; } else if ( delimiter . length ( ) > 0 ) { return delimiter ; } else if ( delimiter . length ( ) > 0 ) { return delimiter ; } else { return delimiter ; } else { return delimiter ; } }
public static int [ ] getSolution ( ) { int [ ] memo = new int [ 2 ] ; memo [ 0 ] = 0 ; memo [ 1 ] = 1 ; int [ ] fib = new int [ 2 ] ; for ( int i = 0 ; i <= N ; i ++ ) { if ( i < memo . length ) { return memo [ i ] ; } for ( int j = i ; j <= N ; j ++ ) { memo [ j ] = memo [ j - 1 ] + memo [ j - 2 ] ; } } return memo ; }
public static final String getRandom ( ) { int t = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; Thread GO_LIFE = new Thread ( ) { public void run ( ) { char [ ] a = new char [ a . length ] ; int [ ] b = new int [ b . length ] ; System . arraycopy ( a , 0 , b , 0 , b . length ) ; Arrays . sort ( b ) ; int n = a . length ; int ok = 0 ; for ( int i = 0 ; i < b . length ; i ++ ) { if ( b [ i ] == 0 ) { ok = 1 ; } } if ( b . length != b . length || ok == 1 ) { for ( int i = 0 ; i < a . length ; i ++ ) { System . out . print ( a [ i ] ) ; } System . out . println ( ) ; return ; } Arrays . sort ( b ) ; int [ ] q1 = new int [ n ] ; int [ ] q2 = new int [ n ] ; List < Integer > q = new ArrayList < > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] == ' c ' ) { q . add ( i ) ; } if ( a [ i ] == ' b ' ) { q1 . add ( 0 , i ) ; } } int i = 0 , j = 0 ; while ( j < q1 . length && i < q . size ( ) ) { a [ q . get ( i ) ] = a [ q1 . get ( j ) ] ; i ++ ; j ++ ; } for ( int i : a ) { System . out . print ( i ) ; } System . out . println ( ) ; } } ; while ( t > 0 ) { GO_LIFE . start ( ) ; t -- ; } return null ; }
public static double cosXSertiesSum ( double x , int n ) { x = x * ( Math . PI / 180.0 ) ; double res = 1 ; double sign = 1 ; double fact = 1 ; double pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
static int findNumber ( int N , int S ) { int i = ( ( ( N ) * ( N + 1 ) ) / 4 ) - ( ( S + 1 ) / 2 ) ; return i ; }
public static boolean multipleOfThree ( int K , int dig0 , int dig1 ) { int sum = 0 ; int temp = ( dig0 + dig1 ) % 10 ; sum = dig0 + dig1 ; if ( ( K == 2 ) ) { if ( ( sum % 3 ) == 0 ) { return true ; } else { return false ; } } sum += temp ; int numberofGroups = ( K - 3 ) / 4 ; int remNumberofDigits = ( K - 3 ) % 4 ; sum += ( numberofGroups * 20 ) ; for ( int i = 0 ; i < remNumberofDigits ; i ++ ) { temp = ( 2 * temp ) % 10 ; sum += temp ; } if ( ( sum % 3 ) == 0 ) { return true ; } else { return false ; } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { K = 5 ; dig0 = 3 ; dig1 = 4 ; if ( ( multipleOfThree ( K , dig0 , dig1 ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } else { return false ; } }
public static int sum ( int [ ] a ) { int [ ] b = new int [ a . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = a [ i ] ; } return b [ a . length ] ; }
static int countOcc ( String s ) { int cnt = 0 ; for ( int i = 0 ; i <= s . length ( ) - 3 ; i ++ ) { int c = 0 , l = 0 , a = 0 , p = 0 ; for ( int j = i ; j <= i + 4 ; j ++ ) { switch ( s . charAt ( j ) ) { case ' c ' : c ++ ; break ; case ' l ' : l ++ ; break ; case ' a ' : a ++ ; break ; case ' p ' : p ++ ; break ; } } if ( c == 1 && l == 1 && a == 1 && p == 1 ) { cnt ++ ; break ; } } return cnt ; }
public static int countSteps ( int x , int y ) { if ( ( x % y ) == 0 ) { return Math . floor ( x / y ) ; } return Math . floor ( ( x / y ) + countSteps ( y , x % y ) ) ; }
public static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
public static double areaInscribed ( double P , double B , double H ) { return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) ; double P = 3 ; double B = 4 ; double H = 5 ; return Math . toDegrees ( Math . toDegrees ( P ) ) ; }
public static void printLine ( String line ) { int n = Integer . parseInt ( line ) ; if ( n == 0 ) { break ; } Map < String , String > map = new HashMap < > ( ) ; for ( ; ; ) { String k = line . substring ( 0 , n ) ; String v = line . substring ( n , n ) ; map . put ( k , v ) ; } for ( ; ; ) { String e = line . substring ( 0 , n ) ; System . out . print ( map . containsKey ( e ) ? map . get ( e ) : e ) ; } System . out . println ( ) ; }
@ VisibleForTesting static int getIndexOf ( int [ ] v , int n ) { Arrays . sort ( v ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = n - 1 - getIndexOf ( v , v [ i ] - 1 ) ; if ( ( tmp == v [ i ] ) ) { cnt ++ ; } } return cnt ; }
public static int trailingZeros ( int N ) { int countOfTwo = 0 ; int countOfFive = 0 ; for ( int i = 1 ; i <= N ; i += 1 ) { int val = i ; while ( ( val % 2 == 0 && val > 0 ) ) { val /= 2 ; countOfTwo += i ; } while ( ( val % 5 == 0 && val > 0 ) ) { val /= 5 ; countOfFive += i ; } } int ans = Math . min ( countOfTwo , countOfFive ) ; return ans ; }
public static boolean removeZero ( int n ) { int res = 0 ; int d = 1 ; while ( ( n > 0 ) ) { if ( ( n % 10 != 0 ) ) { res += ( n % 10 ) * d ; d *= 10 ; } n /= 10 ; } return res ; }
public static int sum ( int [ ] array ) { int m = 1000000007 ; Scanner fI = new Scanner ( System . in ) ; int N = Integer . parseInt ( fI . nextLine ( ) ) ; String [ ] nType = new String [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { String t = fI . nextLine ( ) ; nType [ i ] = t ; } int [ ] [ ] adj = new int [ N ] [ ] ; for ( int i = 0 ; i < N ; i ++ ) { adj [ i ] = new int [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { adj [ i ] [ j ] = adj [ i ] [ j ] ; } } for ( int i = 0 ; i < N - 1 ; i ++ ) { int s = Integer . parseInt ( fI . nextLine ( ) ) ; int t = Integer . parseInt ( fI . nextLine ( ) ) ; s -- ; t -- ; adj [ s ] [ t ] = adj [ i ] [ t ] ; } return p ; }
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static int getDistance ( int [ ] array ) { int distance = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { distance += array [ i ] ; } int a = array [ 0 ] ; int b = array [ 1 ] ; System . out . print ( Math . min ( array . length , distance ) ) ; if ( Math . abs ( a - b ) >= 2 ) { System . out . println ( Math . abs ( a - b ) / 2 ) ; } else { System . out . println ( 0 ) ; } return a + b ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = array [ i ] ; } return array ; }
public static int countSetBits ( int n ) { int count = 0 ; while ( ( n = n ) != 0 ) { count += n & 1 ; n >>>= 1 ; } return count ; }
static int countSubSeq ( int i , int Sum , int cnt , int [ ] a , int n ) { if ( ( i == n ) ) { if ( ( Sum == 0 ) && ( cnt > 0 ) ) { return 1 ; } else { return 0 ; } } int ans = 0 ; ans += countSubSeq ( i + 1 , Sum , cnt , a , n ) ; ans += countSubSeq ( i + 1 , Sum + a [ i ] , cnt + 1 , a , n ) ; return ans ; }
public static String getRandom ( String input ) { int n = input . length ( ) ; String [ ] in = new String [ n ] ; int index ; if ( n % 2 == 0 ) { index = ( int ) ( n / 2 ) - 1 ; } else { index = ( int ) ( n / 2 ) ; } return in [ index ] ; }
public static int getDistance ( int [ ] array , int start , int end ) { if ( array == null ) { return - 1 ; } if ( start == 0 ) { return - 1 ; } if ( end == 1 ) { return - 1 ; } if ( start == 0 ) { return - 1 ; } if ( end == 1 ) { return - 1 ; } if ( start == 1 ) { return - 1 ; } if ( end == 2 ) { return - 1 ; } if ( start == 3 ) { return - 1 ; } if ( end == 4 ) { return - 1 ; } if ( start == 5 ) { return - 1 ; } if ( start == 6 ) { return - 1 ; } if ( start == 7 ) { return - 1 ; } return - 1 ; }
public static int pivotedBinarySearch ( int [ ] arr , int n , int key ) { int pivot = findPivot ( arr , 0 , n - 1 ) ; if ( pivot == - 1 ) { return binarySearch ( arr , 0 , n - 1 , key ) ; } if ( arr [ pivot ] == key ) { return pivot ; } if ( arr [ 0 ] <= key ) { return binarySearch ( arr , 0 , pivot - 1 , key ) ; } return binarySearch ( arr , pivot + 1 , n - 1 , key ) ; }
public static int [ ] [ ] getG ( ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) + 1 ; int d = 1000000007 ; int [ ] [ ] g = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { g [ i ] [ 0 ] = g [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) { g [ i ] [ j ] = ( g [ i ] [ j - 1 ] + g [ i - 1 ] [ j - 1 ] ) % d ; } } return g ; }
public static String getRandom ( String input ) { StringBuilder answer = new StringBuilder ( ) ; int n = Integer . parseInt ( input ) ; List < Integer > a = Collections . list ( Integer . parseInt ( input ) ) ; List < Integer > b = new ArrayList < > ( a ) ; Collections . sort ( b ) ; Map < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { int x = a . get ( i ) ; if ( visited . get ( i ) != null ) continue ; List < Integer > seq = new ArrayList < > ( ) ; seq . add ( i ) ; visited . set ( i , 1 ) ; int hold = a . get ( i ) ; while ( hold != b . get ( seq . size ( ) - 1 ) ) { int z = map . get ( b . get ( seq . size ( ) - 1 ) ) ; visited . set ( z , 1 ) ; seq . add ( z ) ; } answer . append ( " ▁ " ) ; } return answer . toString ( ) ; }
public static int [ ] [ ] makeGuruguru ( int d ) { int [ ] [ ] list = new int [ d + 4 ] [ ] ; for ( ; ; ) { list [ 0 ] [ 0 ] = " # " ; list [ 1 ] [ 0 ] = " ▁ " ; list [ 2 ] [ 1 ] = " # " ; } list [ 3 ] [ 0 ] = " # " ; list [ 4 ] [ 1 ] = " # " ; int x = 2 , y = d + 1 ; list [ y ] [ x ] = " # " ; int direct = 0 ; int vx , vy = vector [ 0 ] ; int cnt = 1 ; do { while ( list [ y + vy * 2 ] [ x + vx * 2 ] == " ▁ " ) { list [ y + vy ] [ x + vx ] = " # " ; y += vy ; x += vx ; cnt ++ ; } } while ( cnt <= 1 ) ; if ( cnt == 1 ) break ; direct = ( direct + 1 ) % 4 ; vx = vector [ direct ] ; vy = vector [ direct ] ; cnt = 0 ; } for ( y = 2 ; y <= d ; y ++ ) System . out . println ( Arrays . toString ( list [ y ] ) . substring ( 2 , list [ y ] . length - 2 ) ) ; int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; makeGuruguru ( Integer . parseInt ( System . getProperty ( " line . separator " ) ) ) ; for ( ; ; ) { System . out . println ( ) ; makeGuruguru ( Integer . parseInt ( System . getProperty ( " line . separator " ) ) ) ; }
public static String compute ( ) { final int [ ] [ ] SQUARES = new int [ 1 ] [ ] ; for ( int i = 1 << 10 ; i < SQUARES . length ; i ++ ) { for ( int j = i ; j < SQUARES [ i ] . length ; j ++ ) { if ( SQUARES [ i ] [ j ] == 6 && isArrangementValid ( i , j ) ) { return String . valueOf ( ans [ j ] [ i ] ) ; } } } return String . valueOf ( 0 ) ; }
public static int [ ] [ ] getNegativeInstances ( ) { int [ ] [ ] a = new int [ n ] [ n ] ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < a [ i ] . length ; j ++ ) { a [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < a . length ; i ++ ) { int [ ] info = new int [ a [ i ] . length ] ; for ( int j = 0 ; j < a [ i ] [ j ] . length ; j ++ ) { info [ j ] = Integer . parseInt ( a [ i ] [ j ] ) ; } for ( int j = 2 ; j < a [ i ] . length ; j ++ ) { a [ i ] [ j - 1 ] [ j ] = 1 ; } } for ( int v : a ) { System . out . println ( ( ( int ) v ) ) ; } return a ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { array [ i ] = i ; } a = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { array [ i ] = i ; } a [ m ] = array ; } int count = 0 ; for ( int j = 0 ; j < m - 1 ; j ++ ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { Set < String > set = new HashSet < > ( ) ; set . add ( array [ i ] [ j ] ) ; set . add ( array [ i + 1 ] [ j ] ) ; set . add ( array [ i ] [ j + 1 ] ) ; set . add ( array [ i + 1 ] [ j + 1 ] ) ; if ( set . contains ( " a " ) ) { count ++ ; } } } return array ; }
public static String getLowestDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayOfDayDayOfDayOfDayOfDayDayOfDayOfDayOfDayOfDayDayOfDayOfDayDayOfDayOfDayDayOfDayOfDayDayOfDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayDayOfDayDayOfDayDayOfDayDayOfDayDayDayOfDayDayOfDayDayDayOfDayDayOfDayDayOfDayDayOfDayDayDayOfDayDayOfDayDayOfDayDayDayOfDayDayOfDayDayOfDayDayDayOfDayDayDayOfDayDayOfDayDayOfDayDayDayOfDayDayOfDayDayDayOfDayDayOfDayDayOfDayDayOfDayDayDayOfDayDayOfDayDayOfDayDayDayOfDayDayDayOfDayDayOfDayDayOfDayDayOfDayDayDayOfDayDayDayOfDayDayOfDayDayOfDayDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayDayDayOfDayDayOfDayDayOfDayDayOfDayDayOfDayOfDayDayOf
public static int getCost ( int [ ] array ) { int [ ] cost = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { cost [ i ] = array [ i ] ; } return cost [ array . length ] ; }
public static int countMountains ( int [ ] a , int n ) { double [ ] [ ] A = new double [ n + 2 ] [ n + 2 ] ; for ( int i = 0 ; i < n + 2 ; i ++ ) { A [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j < n + 2 ; j ++ ) { if ( ( ( i == 0 ) || ( j == 0 ) || ( i == n + 1 ) || ( j == n + 1 ) ) { A [ i ] [ j ] = Double . NEGATIVE_INFINITY ; } else { A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] ; } } } for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) ) { count = count + 1 ; } } } return count ; }
public static int [ ] getDivisors ( ) { int N = 100005 ; int [ ] d = new int [ N ] ; int [ ] pre = new int [ N ] ; int ans ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j <= ( int ) Math . sqrt ( i ) ; j ++ ) { if ( ( i % j ) == 0 ) { if ( ( j * j ) == i ) { d [ i ] ++ ; } else { d [ i ] += 2 ; } } } ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( ( d [ i ] == d [ i - 1 ] ) ) { ans ++ ; } pre [ i ] = ans ; } } if ( Class . isPrimitive ( ) ) { Class . forName ( " java . util . Arrays $ ArrayList " ) ; int n = 15 ; System . out . println ( pre [ n ] ) ; } return pre ; }
public static void defragment ( String input ) { int [ ] a ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { a = new int [ n ] ; for ( int j = 0 ; j < m ; j ++ ) { a [ i ] = i ; } } int [ ] a = new int [ m ] ; int num = 1 ; { int x ; x = Integer . parseInt ( input . substring ( 1 , m ) ) ; for ( int i = 0 ; i < m - x + 1 ; i ++ ) { if ( a [ i ] == new int [ ] { x } ) { a [ i ] = new int [ ] { num } ; System . out . println ( num ) ; num ++ ; return ; } } System . out . println ( " NULL " ) ; } { int x ; x = Integer . parseInt ( input . substring ( 1 , m ) ) ; if ( a [ i ] == 0 || x < 1 ) { System . out . println ( " ILLEGAL _ ERASE _ ARGUMENT " ) ; } for ( int i = 0 , j = 0 ; j < a . length ; i ++ ) { if ( j == x ) { a [ i ] = 0 ; } } } } { int x ; a = Arrays . copyOf ( a , a . length ) ; a [ a . length ] = 0 ; a [ a . length ] = 0 ; } }
public static double areaOfRegularPolygon ( int n , int len ) { double P = ( len * n ) ; double A = len / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; double area = ( P * A ) / 2 ; return area ; }
public static String lastNonRepeating ( String string , int n ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ ( int ) string . charAt ( i ) ] ++ ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = string . charAt ( i ) ; if ( ( freq [ ( int ) ch ] == 1 ) ) { return ( " " + ch ) ; } } return " - 1" ; }
public static int [ ] [ ] a ( int n ) { int [ ] [ ] a = new int [ n ] [ ] ; int minx = 1000000000 ; int maxy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = Integer . parseInt ( input [ i ] [ 0 ] ) ; int y = Integer . parseInt ( input [ i ] [ 1 ] ) ; minx = Math . min ( minx , x ) ; maxy = Math . max ( maxy , y ) ; a [ i ] [ 0 ] = x ; a [ i ] [ 1 ] = y ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] [ 0 ] == minx && a [ i ] [ 1 ] == maxy ) { System . out . println ( i + 1 ) ; break ; } } return a ; }
public static double y ( double x ) { return ( 1 / ( 1 + x ) ) ; }
public static int findLen ( int [ ] arr , int i , int curr , int n , int m ) { int [ ] [ ] dp = new int [ maxN ] [ maxM ] ; int [ ] [ ] v = new int [ maxN ] [ maxM ] ; int ans ; int ans ; if ( ( i == n ) ) { if ( ( curr == m ) ) { return 0 ; } else { return - 1 ; } } if ( ( v [ i ] [ curr ] ) ) { return dp [ i ] [ curr ] ; } v [ i ] [ curr ] = 1 ; ans = v [ i ] [ curr ] ; v [ i ] [ curr ] = l ; if ( ( r != - 1 ) ) { dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; } return dp [ i ] [ curr ] ; }
public static int findLen ( int [ ] arr , int i , int curr , int n , int m ) { int [ ] [ ] dp = new int [ maxN ] [ maxM ] ; int [ ] [ ] v = new int [ maxN ] [ maxM ] ; int ans ; int ans ; if ( ( i == n ) ) { if ( ( curr == m ) ) { return 0 ; } else { return - 1 ; } } if ( ( v [ i ] [ curr ] ) ) { return dp [ i ] [ curr ] ; } v [ i ] [ curr ] = 1 ; ans = v [ i ] [ curr ] ; v [ i ] [ curr ] = l ; if ( ( r != - 1 ) ) { dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; } return dp [ i ] [ curr ] ; }
public static int dfsMax ( int cur , int pre ) { int max = 0 ; int [ ] [ ] R = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) { R [ i ] [ 0 ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { R [ i ] [ 0 ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { if ( R [ i ] [ 0 ] > 0 && i != pre ) { max = Math . max ( max , dfsMax ( i , cur ) + R [ i ] [ i ] ) ; } } int total = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = Integer . parseInt ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( " " ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) { int b = Integer . parseInt ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( String . valueOf ( " " ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ; } } if ( max != 0 ) { total = max ; } return max ; }
public static int aaa ( String n ) { if ( Integer . parseInt ( n ) > N ) { return 0 ; } int ans = new HashSet < > ( ) . contains ( Integer . toString ( Integer . parseInt ( n ) ) ) ? 1 : 0 ; for ( String i : "753" ) { ans += aaa ( n + i ) ; } return ans ; }
public static int minDiff ( int [ ] arr , int n , int k ) { int result = + 2147483647 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { result = ( int ) Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; } return result ; }
public static int [ ] loadStrings ( ) { System . setSecurityManager ( new SecurityManager ( ) ) ; int [ ] [ ] loadStrings = new int [ ] [ ] ; int [ ] [ ] balls = new int [ ] [ ] ; int i = 0 ; for ( ; ; ) { i = loadStrings [ i ] [ 0 ] ; loadStrings [ i ] [ 0 ] = i ; if ( loadStrings [ i ] [ 1 ] == null ) { loadStrings [ i ] [ 1 ] = loadStrings [ i ] [ 1 ] ; } else if ( loadStrings [ i ] [ 2 ] == null ) { loadStrings [ i ] [ 2 ] = loadStrings [ i ] [ 2 ] [ 2 ] ; } else if ( loadStrings [ i ] [ 3 ] == null ) { loadStrings [ i ] [ 3 ] [ 2 ] = loadStrings [ i ] [ 3 ] [ 3 ] [ 2 ] ; } else if ( loadStrings [ i ] [ 4 ] == null ) { loadStrings [ i ] [ 4 ] [ 2 ] = loadStrings [ i ] [ 4 ] [ 2 ] ; } else if ( loadStrings [ i ] [ 5 ] == null ) { loadStrings [ i ] [ 6 ] [ 2 ] = loadStrings [ i ] [ 4 ] [ 2 ] ; } else if ( loadStrings [ i ] [ 6 ] == null ) { loadStrings [ i ] [ 7 ] [ 2 ] = loadStrings [ i ] [ 6 ] [ 2 ] ; } else if ( loadStrings [ i ] [ 7 ] == null ) { loadStrings [ i ] [ 8 ] [ 2 ] = loadStrings [ i ] [ 7 ] [ 2 ] ; } else if ( loadStrings [ i ] [ 8 ] == null ) { loadStrings [ i ] [ 8 ] [ 2 ] = loadStrings [ i ] [ 8 ] [ 2 ] ; } else if ( loadStrings [ i ] [ 9 ] == null ) { loadStrings [ i ] [ 8 ] [ 2 ] = loadStrings [ i ] [ 9 ] [ 2 ] ; } else if ( loadStrings [ i ] [ 10 ] == null ) { loadStrings [ i ] [ 11 ] [ 2 ] = loadStrings [ i ] [ 11 ] [ 2 ] ; } else if ( loadStrings [ i ] [ 12 ] == null ) { loadStrings [ i ] [ 13 ] [ 2 ] = loadStrings [ i ] [
public static int solve ( int x ) { int y = 0 ; int j = 1 ; while ( y < x ) { y += j ; if ( y == x ) { return ( j ) ; } j ++ ; } if ( y - x == 1 ) { return ( j ) ; } else { return ( j - 1 ) ; } for ( int i = 0 ; i < t ; i ++ ) { y = y ; System . out . println ( solve ( i ) ) ; } return 0 ; }
public static int Mean ( int [ ] arr , int n ) { int sm = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sm = sm + arr [ i ] ; } return sm / n ; }
public static String compute ( ) { final int LIMIT = 10 * 9 ; final int [ ] primes = EulerUtil . listPrimes ( 100 ) ; return String . valueOf ( new int [ ] { primes . length , primes . length , primes [ 0 ] } ) ; }
public static int maximumXOR ( int n , int l , int r ) { int x = 0 ; for ( int i = ( int ) Math . log2 ( r ) ; i >= 0 ; i -- ) { if ( ( n & ( 1 << i ) ) != 0 ) { if ( ( x > r ) || ( x + ( 1 << i ) - 1 < l ) ) { x ^= ( 1 << i ) ; } } else { if ( ( x ^ ( 1 << i ) ) <= r ) { x ^= ( 1 << i ) ; } } } return n ^ x ; }
public static int maxPrimefactorNum ( int N ) { boolean [ ] arr = new boolean [ N + 5 ] ; int i = 3 ; while ( ( i * i <= N ) ) { if ( ( arr [ i ] ) ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = false ; } } i += 2 ; } int [ ] prime = new int [ N + 1 ] ; prime [ 0 ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( ( arr [ i ] ) ) { prime [ i ] = i ; } } i = 0 ; int ans = 1 ; while ( ( ans * prime [ i ] <= N ) && ( i < prime . length ) ) { ans *= prime [ i ] ; i ++ ; } return ans ; }
public static int CountTrailingZeros ( int n ) { String bit = Integer . toBinaryString ( n ) ; bit = bit . substring ( 0 , bit . length ( ) - 1 ) ; int zero = 0 ; for ( int i = 0 ; i < bit . length ( ) ; i ++ ) { if ( ( bit . charAt ( i ) == '0' ) ) { zero ++ ; } else { break ; } } return zero ; }
public static int min ( int a , int b , int c ) { int case1 = a + b + c ; int case2 = a + a + b + b ; int case3 = a + c + c + a ; int case4 = b + c + c + b ; return Math . min ( case1 , case2 , case3 , case4 ) ; }
public static void solve ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] p = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) p [ i ] = Integer . parseInt ( input ) ; int result = 0 ; int c = 0 ; while ( c < n - 1 ) { if ( p [ c ] > p [ c + 1 ] ) { result += 1 ; c ++ ; } c ++ ; } System . out . println ( result ) ; }
public static int distinctSubstring ( String P , String Q , int K , int N ) { Set < String > S = new HashSet < > ( ) ; for ( int i = 0 ; i <= N ; i ++ ) { int sum = 0 ; StringBuffer s = new StringBuffer ( ) ; for ( int j = i ; j < N ; j ++ ) { int pos = ( int ) P . charAt ( j ) - 97 ; sum = sum + ( int ) Q . charAt ( pos ) - 48 ; s . append ( P . charAt ( j ) ) ; if ( ( sum <= K ) ) { S . add ( s . toString ( ) ) ; } else { break ; } } } return S . size ( ) ; }
public static String makeEven ( String [ ] arr , int n ) { int firstEI = - 1 ; int lastEI = - 1 ; int lastNI = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( Integer . parseInt ( arr [ i ] ) % 2 == 0 ) && ( Integer . parseInt ( arr [ i ] ) < Integer . parseInt ( arr [ lastNI ] ) ) ) { firstEI = i ; break ; } if ( Integer . parseInt ( arr [ i ] ) % 2 == 0 ) { lastEI = i ; } } if ( firstEI != - 1 ) { ( arr [ firstEI ] = arr [ lastNI ] ) . trim ( ) ; return arr [ firstEI ] ; } if ( firstEI == - 1 && lastEI != - 1 ) { ( arr [ lastEI ] = arr [ lastNI ] ) . trim ( ) ; return arr [ lastEI ] ; } return arr [ lastNI ] ; }
static void findDivisors ( int n ) { int div [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < div . length ; i ++ ) { div [ i ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j * i <= n ) { div [ i * j ] ++ ; } } } for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( div [ i ] + " ▁ " ) ; } } if ( Class . forName ( " java . util . concurrent . ThreadPoolExecutor " ) . equals ( " java . util . concurrent . ThreadPoolExecutor " ) ) { n = 10 ; findDivisors ( n ) ; } }
public static int getCountry ( String country ) { if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else if ( country == null ) { return 0 ; } else { return 0 ; } }
public static void printDistinct ( String Str ) { int n = Str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < count . length ; i ++ ) { index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Str . charAt ( i ) ; count [ x ] ++ ; if ( ( count [ x ] == 1 ) && ( x != ' ▁ ' ) ) { index [ x ] = i ; } if ( ( count [ x ] == 2 ) ) { index [ x ] = n ; } } Arrays . sort ( index ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( index [ i ] == n ) break ; System . out . print ( Str . charAt ( index [ i ] ) ) ; } String str = " GeeksforGeeks " ; printDistinct ( str ) ; }
public static int calculate ( int x , int k , int m ) { double result = x ; k = k - 1 ; while ( ( k ) != 0 ) { result = Math . pow ( result , x ) ; if ( ( result > m ) ) { result = result % m ; } k = k - 1 ; } return ( int ) result ; }
public static void converthenumber ( int n ) { String s = String . valueOf ( n ) ; String res = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s . charAt ( i ) == '1' ) || ( s . charAt ( i ) == '3' ) || ( s . charAt ( i ) == '5' ) || ( s . charAt ( i ) == '7' ) || ( s . charAt ( i ) == '9' ) ) { res += s . charAt ( i ) ; } if ( ( res . length ( ) == 2 ) ) { break ; } } if ( ( res . length ( ) == 2 ) ) { System . out . println ( res ) ; } else { System . out . println ( " - 1" ) ; } } if ( String . valueOf ( n ) . equals ( " - 1" ) ) { n = 18720 ; converthenumber ( n ) ; } else { System . out . println ( " - 1" ) ; } }
public static void solve ( ) { int n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; String s = System . console ( ) . readLine ( ) ; for ( int a = 0 ; a < 26 ; a ++ ) { char c = ( char ) ( a + ' a ' ) ; if ( ! s . contains ( c ) ) { System . out . println ( c ) ; return ; } } for ( int a = 0 ; a < 26 ; a ++ ) { char c1 = ( char ) ( a + ' a ' ) ; for ( int b = 0 ; b < 26 ; b ++ ) { char c2 = ( char ) ( b + ' a ' ) ; char c = c1 + c2 ; if ( ! s . contains ( c ) ) { System . out . println ( c ) ; return ; } } } for ( int a = 0 ; a < 26 ; a ++ ) { char c1 = ( char ) ( a + ' a ' ) ; for ( int b = 0 ; b < 26 ; b ++ ) { char c2 = ( char ) ( b + ' a ' ) ; char c4 = c1 + c2 ; for ( int d = 0 ; d < 26 ; d ++ ) { char c3 = ( char ) ( d + ' a ' ) ; char c = c4 + c3 ; if ( ! s . contains ( c ) ) { System . out . println ( c ) ; return ; } } } } int t = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; while ( t != 0 ) { t -- ; solve ( ) ; } }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int n = Integer . parseInt ( args [ i ] ) ; List < Integer > l = new ArrayList < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) l . add ( Integer . parseInt ( args [ j ] ) ) ; a . add ( l . get ( j ) ) ; } List < Integer > l1 = new ArrayList < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) l1 . add ( Math . max ( i , a . size ( ) ) ) ; System . out . println ( l1 ) ; }
public static int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; }
public static int getCountry ( String s ) { int h = Integer . parseInt ( s . substring ( 0 , s . indexOf ( ' # ' ) ) ) ; int w = Integer . parseInt ( s . substring ( 0 , s . indexOf ( ' # ' ) ) ) ; int ans = 0 ; int [ ] ci = new int [ w ] ; for ( int i = 0 ; i < w ; i ++ ) { ci [ i ] = 0 ; } for ( int i = h - 1 ; i >= 0 ; i -- ) { int co = 0 ; for ( int j = w - 1 ; j >= 0 ; j -- ) { if ( s . charAt ( i ) == ' J ' ) { ans += co * ci [ j ] ; } else if ( s . charAt ( i ) == ' O ' ) { co ++ ; } else if ( s . charAt ( i ) == ' I ' ) { ci [ j ] ++ ; } } } return ans ; }
public static int countDivisors ( int n , int k ) { int count = 0 ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( n ) ; i ++ ) { if ( ( n % i ) == 0 ) { if ( ( i % k ) == 0 ) count ++ ; if ( ( ( n / i ) % k ) == 0 ) count ++ ; } } if ( ( ( i * i ) == n ) && ( i % k ) == 0 ) count -- ; return count ; }
static int countDivisors ( int n , int k ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( n % i == 0 ) && ( i % k == 0 ) ) { count ++ ; } } return count ; }
public static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( ( y > 0 ) ) { if ( ( y > 0 ) && ( 1 ) ) { res = ( res * x ) % p ; } y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
public static int getDistance ( String [ ] arr ) { int [ ] dist = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . length ( ) > 0 ) { dist [ i ] = arr [ i ] . length ( ) ; } } return dist [ arr . length - 1 ] ; }
public static int findMaxDiff ( int [ ] a , int n ) { if ( ( n < 2 ) ) { System . out . println ( " Invalid ▁ " ) ; return 0 ; } int minVal = Integer . MAX_VALUE ; int maxVal = - Integer . MAX_VALUE - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( a [ i ] - i ) > maxVal ) ) { maxVal = a [ i ] - i ; } if ( ( ( a [ i ] - i ) < minVal ) ) { minVal = a [ i ] - i ; } } return ( maxVal - minVal ) ; } if ( Class . isPrimitive ( ) ) { int [ ] arr = { 9 , 15 , 4 , 12 , 13 } ; n = arr . length ; System . out . println ( findMaxDiff ( arr , n ) ) ; } return 0 ; }
public static int [ ] [ ] getNegativeInstances ( ) { int [ ] [ ] v = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < v . length ; i ++ ) { v [ i ] [ i ] = v [ i ] [ i ] ; } return v ; }
public static int numberOfPaths ( int m , int n ) { int [ ] [ ] count = new int [ m ] [ n ] ; for ( int x = 0 ; x < m ; x ++ ) { for ( int y = 0 ; y < n ; y ++ ) { count [ x ] [ y ] = 0 ; } } for ( int i = 0 ; i < m ; i ++ ) { count [ i ] [ 0 ] = 1 ; } for ( int j = 0 ; j < n ; j ++ ) { count [ 0 ] [ j ] = 1 ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } } return count [ m - 1 ] [ n - 1 ] ; m = 3 ; n = 3 ; System . out . println ( numberOfPaths ( m , n ) ) ; return count [ m ] [ n ] ; }
public static int getDistance ( String [ ] arr ) { int m = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int n = arr [ i ] . length ( ) ; int [ ] a = arr [ i ] . split ( " ▁ " ) ; int s = Arrays . stream ( a ) . mapToInt ( Integer :: parseInt ) . sum ( ) ; if ( ( s % n ) == 0 ) { if ( ( a . length / n ) == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { System . out . println ( " NO " ) ; } } return m ; }
public static boolean isKthBitSet ( int n , int k ) { if ( ( ( n >>> ( k - 1 ) ) & 1 ) != 0 ) return true ; return false ; }
public static int factorial ( int n ) { if ( ( n <= 1 ) ) { return 1 ; } return n * factorial ( n - 1 ) ; }
public static String commonPrefixUtil ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; String result = " " ; int j = 0 ; int i = 0 ; while ( ( i <= n1 - 1 ) && ( j <= n2 - 1 ) ) { if ( ( str1 . charAt ( i ) != str2 . charAt ( j ) ) ) break ; result += ( str1 . charAt ( i ) ) ; i ++ ; j ++ ; } return ( result ) ; }
public static int median ( ) { final int [ ] A = new int [ A . length ] ; Arrays . fill ( A , 0 ) ; Arrays . fill ( A , 0 ) ; final int mod = 10 * 9 + 7 ; return Arrays . stream ( A ) . map ( i -> Integer . parseInt ( i ) ) . filter ( i -> i >= 0 ) . map ( i -> Integer . parseInt ( i ) ) . collect ( Collectors . toList ( ) ) . orElse ( 0 ) ; }
public static int [ ] getNegativeInstances ( ) { int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int a = Integer . parseInt ( System . getProperty ( " " ) ) ; A [ i ] = a ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int nex ; if ( i == 0 ) { now = 0 ; nex = A [ 0 ] ; count ++ ; } else { nex = A [ nex - 1 ] ; count ++ ; } if ( nex == 2 ) { System . out . println ( count ) ; exit ( ) ; } } return A ; }
public static String compute ( ) { int a = 0 ; int b = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { a = b ; b = a + b ; } return String . valueOf ( a ) ; }
static void findFrequencyUtil ( int arr [ ] , int low , int high , int [ ] freq ) { if ( ( arr [ low ] == arr [ high ] ) ) { freq [ arr [ low ] ] += high - low + 1 ; } else { int mid = ( int ) ( ( low + high ) / 2 ) ; findFrequencyUtil ( arr , low , mid , freq ) ; findFrequencyUtil ( arr , mid + 1 , high , freq ) ; } }
public static String compute ( ) { final List < Integer > totients = EulerUtil . listTotients ( 10 * 7 - 1 ) ; int minnumer = 1 ; int mindenom = 0 ; final Iterator < Integer > iterator = totients . subList ( 2 , 2 ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { final Integer i = iterator . next ( ) ; final int tot = totients . get ( i ) ; if ( i * mindenom < minnumer * tot && new String ( i ) . equals ( new String ( tot ) ) ) { minnumer = i ; mindenom = totients . get ( i ) ; } } return String . valueOf ( minnumer ) ; }
public static void intersection ( int [ ] a , int [ ] b , int n , int m ) { int i = 0 ; int j = 0 ; while ( ( i < n ) && ( j < m ) ) { if ( ( a [ i ] > b [ j ] ) ) { j ++ ; } else { if ( ( b [ j ] > a [ i ] ) ) { i ++ ; } else { System . out . print ( a [ i ] + " ▁ " ) ; i ++ ; j ++ ; } } } if ( Class . isPrimitive ( String . class ) ) { a = Arrays . asList ( 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 ) ; b = Arrays . asList ( 3 , 3 , 5 ) ; n = a . length ; m = b . length ; intersection ( a , b , n , m ) ; } }
public static int findMin ( int [ ] a , int n ) { double _sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { _sum += Math . log ( a [ i ] ) ; } double x = Math . exp ( _sum / n ) ; return ( int ) ( x + 1 ) ; }
public static int lcmOfArray ( int [ ] arr , int n ) { if ( ( n < 1 ) ) { return 0 ; } int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i += 1 ) { lcm = ( int ) ( ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ) ; } return lcm ; }
public static int subarrayCount ( int [ ] arr , int n ) { int result = 0 ; int fast = 0 , slow = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == 1 ) { fast ++ ; } else { int length = fast - slow + 1 ; result += length * ( length - 1 ) / 2 ; fast = i ; slow = i ; } } if ( ( fast != slow ) ) { int length = fast - slow + 1 ; result += length * ( length - 1 ) / 2 ; } return result ; }
public static void solve ( int n ) { int f = 0 ; int s = 0 ; boolean fs = true ; if ( ( n & 1 ) != 0 ) { n -- ; fs = false ; } while ( n > 0 ) { if ( n == 4 ) { f += 3 ; s ++ ; n = 0 ; } else if ( ( n / 2 ) & 1 ) { f += n / 2 ; s ++ ; n = ( n / 2 ) - 1 ; } else { f += 1 ; s ++ ; n -= 2 ; } } ans . add ( new int [ ] { s + 1 , f } [ fs ] ) ; } int [ ] coins = new int [ ] { } ; for ( ; ; ; ) { coins [ 0 ] = Integer . parseInt ( input ( ) ) ; } for ( int i : coins ) { if ( i == 1 ) { ans . add ( 1 ) ; } else { solve ( i ) ; } } System . out . println ( Arrays . toString ( ans ) ) ; }
public static int min ( int [ ] a ) { int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; return a [ n ] ; }
@ NonNull public static String findSubString ( String strr ) { final int MAX_CHARS = 256 ; int startIndex = 0 ; if ( Character . isLetterOrDigit ( strr . charAt ( 0 ) ) ) { return strr ; } int distCount = new HashSet ( ) . size ( ) ; for ( char x : strr . toCharArray ( ) ) { if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } if ( x == ' _ ' ) { continue ; } return x ; } return null ; }
public static int concentration ( int water , int suger ) { return 100 * suger / ( water + suger ) ; int WATER_A = Integer . parseInt ( System . getProperty ( " user . name " ) ) , WATER_B = Integer . parseInt ( System . getProperty ( " user . name " ) ) , SUGER_C = Integer . parseInt ( System . getProperty ( " user . name " ) ) , SUGER_D = Integer . parseInt ( System . getProperty ( " user . name " ) ) , MELT_PER_100 = Integer . parseInt ( System . getProperty ( " user . name " ) ) , LIMIT = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; WATER_A *= 100 ; WATER_B *= 100 ; int MELT_PERCENT_LIMIT = concentration ( 100 , MELT_PER_100 ) ; int wa = 0 ; int wb = 0 ; int sc = 0 ; int sd = 0 ; HashSet < Integer > waterSet = new HashSet < > ( ) ; while ( wa * WATER_A <= LIMIT ) { while ( wb * WATER_B <= LIMIT ) { water = wa * WATER_A + wb * WATER_B ; if ( water <= LIMIT ) { waterSet . add ( water ) ; } wb ++ ; } wb = 0 ; wa ++ ; } HashSet < Integer > sugerSet = new HashSet < > ( ) ; while ( sc * SUGER_C <= LIMIT ) { while ( sd * SUGER_D <= LIMIT ) { suger = sc * SUGER_C + sd * SUGER_D ; if ( suger <= LIMIT ) { sugerSet . add ( suger ) ; } sd ++ ; } sd = 0 ; sc ++ ; } int ansSugerWater = 0 ; int ansSuger = 0 ; int maxConcentration = 0 ; for ( Integer water : waterSet ) { for ( Integer suger : sugerSet ) { if ( ! ( 0 < water + suger <= LIMIT ) ) { continue ; } int sugerPrecent = concentration ( water , suger ) ; if ( maxConcentration <= sugerPrecent && suger <= MELT_PERCENT_LIMIT ) { maxConcentration = sugerPrecent ; ansSugerWater = water + suger ; ansSuger = suger ; } } return ansSugerWater + ansSu
public static int [ ] [ ] getLines ( String line ) { final int [ ] [ ] lines = new int [ line . length ( ) ] [ ] ; for ( int i = 0 ; i < lines . length ; i ++ ) lines [ i ] = Integer . parseInt ( line . substring ( i , i + 1 ) ) ; for ( int j = 0 ; j < lines [ i ] . length ; j ++ ) lines [ i ] [ j ] += Math . max ( lines [ i - 1 ] [ Math . max ( j - 1 , 0 ) ] , Math . min ( j + 1 , lines [ i - 1 ] . length ) ) ; for ( int i = lines . length / 2 + 1 ; i < lines . length ; i ++ ) { for ( int j = 0 ; j < lines [ i ] . length ; j ++ ) lines [ i ] [ j ] += Math . max ( lines [ i - 1 ] [ j ] , j + 2 ) ; } return lines [ lines . length - 1 ] [ 0 ] ; }
static void countPairs ( int [ ] arr , int n ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 ) == 0 ) { even ++ ; } else { odd ++ ; } } int oddPairs = odd * ( n - 1 ) ; int evenPairs = even * ( n - 1 ) ; System . out . println ( oddPairs ) ; System . out . println ( evenPairs ) ; }
public static int getDistance ( String [ ] arr ) { int m , k ; for ( int i = 0 ; i < arr . length ; i ++ ) { m = arr [ i ] . length ( ) ; k = arr [ i ] . length ( ) ; } for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . length ( ) > 0 ) { arr [ i ] = arr [ i ] . substring ( 0 , i ) ; } } return arr . length ; }
public static int getDayNumber ( String number ) { int [ ] numbers = number . split ( " ▁ " ) ; int columns = numbers [ 0 ] ; int rows = numbers [ 1 ] ; int counter = - 1 ; Map < String , Integer > map = new HashMap < > ( ) ; int stop = 0 ; for ( int i = 0 ; i <= columns ; i ++ ) { String x = String . valueOf ( i ) ; String g = " not " ; char s = ' not ' ; int count = 0 ; for ( int j = 0 ; j <= rows ; j ++ ) { if ( x . charAt ( j ) == ' S ' ) { if ( g . equals ( " found " ) ) { counter = count + 1 ; if ( ! map . containsKey ( f . format ( " % d " , counter ) ) ) { map . put ( f . format ( " % d " , counter ) , 1 ) ; } } else { stop = 1 ; } break ; } else if ( x . charAt ( j ) == ' G ' ) { g = ' found ' ; count = 0 ; } else { count ++ ; } } } return count ; }
public static boolean search ( int arr [ ] , int n , int x ) { int front = 0 ; int back = n - 1 ; while ( ( front <= back ) ) { if ( ( arr [ front ] == x ) || ( arr [ back ] == x ) ) { return true ; } front ++ ; back -- ; } return false ; arr = new int [ ] { 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 } ; x = 130 ; n = arr . length ; if ( ( search ( arr , n , x ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
public static void countFreq ( int [ ] arr , int n ) { HashMap < Integer , Integer > mp = new HashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , 0 ) ; } mp . get ( arr [ i ] ) . intValue ( ) ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( mp . get ( arr [ i ] ) != - 1 ) ) { System . out . println ( arr [ i ] + " ▁ " + mp . get ( arr [ i ] ) ) ; } mp . put ( arr [ i ] , - 1 ) ; } arr = new int [ ] { 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 } ; n = arr . length ; countFreq ( arr , n ) ; }
public static int MinCostTree ( int [ ] arr , int n ) { int ans = 0 ; Stack < Integer > st = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ( st . peek ( ) <= arr [ i ] ) ) { int x = st . peek ( ) ; st . pop ( ) ; ans += x * Math . min ( st . peek ( ) , arr [ i ] ) ; } st . push ( arr [ i ] ) ; } for ( int i = 2 ; i < st . size ( ) ; i ++ ) { ans += st . peek ( ) * st . peek ( ) ; } return ans ; }
public static int [ ] getDicList ( String str ) { int [ ] result = new int [ str . length ( ) ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { result [ i ] = i ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { result [ i ] = i ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { result [ str . charAt ( i ) ] = i ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { result [ str . charAt ( i ) ] = i ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { result [ str . charAt ( i ) ] = i ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { result [ str . charAt ( i ) ] = i ; } return result ; }
static void findEquation ( int a , int b ) { int summ = ( a + b ) ; int product = ( a * b ) ; System . out . println ( " x ^ 2 ▁ - ▁ ( " + summ + " x ) ▁ + ▁ ( " + product + " ) ▁ = ▁ 0" ) ; }
public static void circleEquation ( int x1 , int y1 , int r ) { int a = - 2 * x1 ; int b = - 2 * y1 ; int c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; System . out . print ( " x ^ 2 ▁ + ▁ ( " + a + " x ) ▁ + ▁ " ) ; System . out . print ( " y ^ 2 ▁ + ▁ ( " + b + " y ) ▁ = ▁ " ) ; System . out . println ( c + " . " ) ; }
public static void uniqueCombination ( int l , int sum , int K , ArrayList < Integer > local , ArrayList < Integer > A ) { if ( ( sum == K ) ) { System . out . print ( " { " ) ; for ( int i = 0 ; i < local . size ( ) ; i ++ ) { if ( ( i != 0 ) ) System . out . print ( " ▁ " ) ; System . out . print ( local . get ( i ) ) ; if ( ( i != local . size ( ) - 1 ) ) System . out . print ( " , ▁ " ) ; } } System . out . println ( " } " ) ; return ; } for ( int i = l ; i < A . size ( ) ; i += 1 ) { if ( ( sum + A . get ( i ) ) > K ) continue ; if ( ( i == 1 ) && ( A . get ( i ) == A . get ( i - 1 ) ) && ( i > l ) ) continue ; local . add ( A . get ( i ) ) ; uniqueCombination ( i + 1 , sum + A . get ( i ) , K , local , A ) ; local . remove ( local . size ( ) - 1 ) ; } public static void Combination ( ArrayList < Integer > A , int K ) { Collections . sort ( A , Collections . reverseOrder ( false ) ) ; local . clear ( ) ; uniqueCombination ( 0 , 0 , K , local , A ) ; } if ( Class . forName ( " java . util . Arrays $ ArrayList " ) . equals ( A . get ( 0 ) , K ) ) { A = new ArrayList ( 10 ) ; A . add ( 1 ) ; A . add ( 2 ) ; A . add ( 7 ) ; A . add ( 6 ) ; A . add ( 1 ) ; A . add ( 5 ) ; K = 8 ; Combination ( A , K ) ; }
public static int binarySearch ( String input ) { int n = Integer . parseInt ( input ) ; ArrayList < Integer > prices = new ArrayList < > ( ) ; for ( String s : input . split ( " ▁ " ) ) { prices . add ( Integer . parseInt ( s ) ) ; } for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { System . out . println ( prices . get ( i ) ) ; } return prices . size ( ) ; }
public static String f ( String input ) { String a ; for ( int i = 1 ; i < 26 ; i += 2 ) { for ( int j = 0 ; j < 26 ; j ++ ) { a = a . contains ( z . indexOf ( c ) ) ? z . substring ( ( z . indexOf ( c ) * i + j ) % 26 , j ) : c ; } if ( a . contains ( " that " ) || a . contains ( " this " ) ) return a ; } return null ; }
static boolean findNature ( int a , int b , int n ) { if ( ( n == 0 ) ) { return ( a & 1 ) != 0 ; } if ( ( n == 1 ) ) { return ( b & 1 ) != 0 ; } if ( ( ( a & 1 ) == 0 ) ) { if ( ( ( b & 1 ) == 0 ) ) { return false ; } else { return ( n % 3 != 0 ) ? true : false ; } } else { if ( ( ( b & 1 ) == 0 ) ) { return ( ( n - 1 ) % 3 != 0 ) ? true : false ; } else { return ( ( n + 1 ) % 3 != 0 ) ? true : false ; } } a = 2 ; b = 4 ; n = 3 ; if ( ( findNature ( a , b , n ) == true ) ) { System . out . print ( " Odd " ) ; } else { System . out . print ( " Even " ) ; } return false ; }
public static void solve ( String [ ] args ) { int d , e ; d = Integer . parseInt ( args [ 0 ] ) ; e = Integer . parseInt ( args [ 1 ] ) ; if ( d == 0 ) { break ; } ArrayList < Point > data = new ArrayList < > ( ) ; for ( int i = 0 ; i <= 101 ; i ++ ) { for ( int j = 0 ; j <= 101 ; j ++ ) { data . add ( new Point ( Math . abs ( ( ( i * i + j * j ) * 0.5 ) - e ) , i , j ) ) ; } } for ( Point p : data ) { if ( p . y + p . z == d ) { System . out . println ( p . x ) ; break ; } } }
public static int maxSum ( int [ ] a , int n ) { int [ ] dp = new int [ n ] ; if ( ( n == 1 ) ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; } else if ( ( n == 2 ) ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; dp [ 1 ] = Math . max ( a [ 1 ] , dp [ 0 ] ) ; } else if ( ( n >= 3 ) ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; dp [ 1 ] = Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ; dp [ 2 ] = Math . max ( a [ 2 ] , Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ) ; int i = 3 ; while ( ( i < n ) ) { dp [ i ] = Math . max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ; i ++ ; } } return dp [ n - 1 ] ; }
public static String getLetter ( String s ) { String [ ] arr = s . split ( " ▁ " ) ; int start = 0 , letter = 0 ; while ( true ) { if ( ( arr [ start ] . charAt ( 0 ) != ' ▁ ' ) && ( arr [ start ] . charAt ( 0 ) != ' ? ' ) ) { letter = arr [ start ] ; break ; } start -- ; } if ( arr [ 0 ] . equalsIgnoreCase ( " a " ) || arr [ 0 ] . equalsIgnoreCase ( " e " ) || arr [ 0 ] . equalsIgnoreCase ( " i " ) || arr [ 0 ] . equalsIgnoreCase ( " o " ) || arr [ 0 ] . equalsIgnoreCase ( " u " ) || arr [ 0 ] . equalsIgnoreCase ( " y " ) ) { return arr [ start ] ; } else { return arr [ start ] ; } }
public static int minimumX ( int n , int k ) { int mini = Integer . MAX_VALUE ; int i = 1 ; while ( i * i <= n ) { if ( ( n % i ) == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( ( res == n ) ) { mini = Math . min ( num1 , mini ) ; } int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( ( res == n ) ) { mini = Math . min ( num2 , mini ) ; } } i ++ ; } return mini ; }
public static int findLongest ( int node ) { boolean [ ] visited ; visited [ node ] = true ; if ( ! graph . containsKey ( node ) ) { return 1 ; } int maxChild = 0 ; for ( int i = 0 ; i < graph . get ( node ) . size ( ) ; i ++ ) { if ( visited [ i ] ) { continue ; } maxChild = Math . max ( maxChild , findLongest ( i ) ) ; } return maxChild + 1 ; }
public static double SellingPrice ( double CP , double PP ) { double Pdecimal = 1 + ( PP / 100 ) ; double res = Pdecimal * CP ; return res ; }
public static int getProposis ( int [ ] pcs ) { int [ ] pcs = new int [ pcs . length ] ; for ( int i = 0 ; i < pcs . length ; i ++ ) { pcs [ i ] = pcs [ i ] ; } return pcs [ pcs . length - 1 ] ; }
public static int f ( int b , int n ) { if ( b > n ) { return n ; } return f ( b , n / b ) + ( n % b ) ; }
public static int getDistance ( int [ ] array ) { int distance = array . length ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == 0 ) { distance = i ; } } return distance ; }
public static void check ( int n , int m ) { if ( ( m % n ) == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } n = 5 ; m = 10 ; check ( n , m ) ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int x = Integer . parseInt ( args [ i ] ) ; String [ ] a = args [ i ] . split ( " ▁ " ) ; int p = 0 ; for ( int j = 0 ; j < x - 2 ; j ++ ) { if ( a [ j ] . contains ( a [ j + 2 ] ) ) { p = 1 ; break ; } } System . out . println ( p != 0 ? " YES " : " NO " ) ; } }
public static int getMonth ( int year , int month ) { int monthMonth = year + month ; int monthMonth = month + 1 ; int monthMonth = month + 1 ; return monthMonth ; }
public static int getDistance ( int [ ] array , int [ ] values ) { if ( array == null ) { return 0 ; } if ( array . length == 0 ) { return 0 ; } if ( array . length == 1 ) { return array [ 0 ] ; } if ( array . length == 2 ) { return array [ 0 ] ; } if ( array . length == 3 ) { return array [ 1 ] ; } if ( array . length == 4 ) { return array [ 2 ] ; } if ( array . length == 5 ) { return array [ 3 ] ; } if ( array . length == 6 ) { return array [ 4 ] ; } if ( array . length == 7 ) { return array [ 5 ] ; } if ( array . length == 8 ) { return array [ 4 ] ; } if ( array . length == 9 ) { return array [ 4 ] ; } return array [ 0 ] ; }
static int findNthOccur ( String string , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( ( string . charAt ( i ) == ch ) ) { occur ++ ; } if ( ( occur == N ) ) { return i ; } } return - 1 ; }
public static int mostFrequent ( String List ) { int occurentCount = Collections . frequency ( List , " A " ) ; return occurentCount / 2 ; }
public static String compute ( ) { final int LIMIT = 10 * 15 ; final int MODULUS = 10 * 9 ; final int splitcount = EulerMath . sqrt ( LIMIT ) ; final int splitat = LIMIT / ( splitcount + 1 ) ; { final int ans = ( int ) ( ( s * ( e + 1 ) * ( e * 2 + 1 ) - s * ( s + 1 ) * ( s * 2 + 1 ) ) / 6 ; ans += ( int ) ( ( i * i * ( LIMIT / i ) ) ) ; ans += ( int ) ( ( sum_squares ( LIMIT / ( i + 1 ) , LIMIT / i ) * i ) ) ; ans += ( int ) ( ( sum_squares ( LIMIT / ( i + 1 ) , LIMIT / i ) * i ) ) ; ans += ( int ) ( ans % MODULUS ) ; } if ( Class . isPrimitive ( ) ) { System . out . println ( compute ( ) ) ; } return String . valueOf ( ans ) ; }
public static void solve ( String input ) { int n , k , z ; n = Integer . parseInt ( input ) ; k = Integer . parseInt ( input ) ; z = Integer . parseInt ( input ) ; a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Integer . parseInt ( input ) ; int ans = 0 ; int s = 0 ; int mx = 0 ; for ( int i = 0 ; i < k + 1 ; i ++ ) { if ( i < n - 1 ) mx = Math . max ( mx , a [ i ] + a [ i + 1 ] ) ; s += a [ i ] ; if ( i % 2 == k % 2 ) { int tmp = ( k - i ) / 2 ; if ( tmp <= z ) ans = Math . max ( ans , s + mx * tmp ) ; } } System . out . println ( ans ) ; }
public static int getDistance ( int [ ] arr ) { int distance = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == arr [ i ] ) { distance += i ; } } return distance ; }
public static int [ ] makeSets ( int [ ] start , int [ ] end ) { List < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { list . add ( Integer . parseInt ( input [ i ] ) ) ; } int [ ] aStart = list . toArray ( new int [ list . size ( ) ] ) ; int [ ] aEnd = list . toArray ( new int [ list . size ( ) ] ) ; int [ ] hStart = list . toArray ( new int [ list . size ( ) ] ) ; int [ ] hEnd = list . toArray ( new int [ list . size ( ) ] ) ; int [ ] bStart = list . toArray ( new int [ list . size ( ) ] ) ; int [ ] bEnd = list . toArray ( new int [ list . size ( ) ] ) ; for ( int i = 0 ; i < bStart . length ; i ++ ) { if ( bStart [ i ] == bEnd [ i ] ) { bStart [ i ] = bEnd [ i ] ; } } return list . toArray ( new int [ list . size ( ) ] ) ; }
public static int [ ] getTwoInt ( ) { int [ ] twoInt = new int [ 2 ] ; for ( int i = 0 ; i < twoInt . length ; i ++ ) { twoInt [ i ] = Integer . parseInt ( twoInt [ i ] ) ; } return twoInt ; }
public static int countTwoIdx ( int [ ] A , int q ) { int ans = 0 ; int left = 0 ; int csum = 0 ; for ( int right = 0 ; right < N ; right ++ ) { csum += A [ right ] ; while ( csum > q ) { csum -= A [ left ] ; left ++ ; } ans += right - left + 1 ; } return ans ; int N = Integer . parseInt ( System . getProperty ( " line . separator " ) ) , M = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int [ ] A = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int [ ] X = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; for ( int q : X ) { System . out . println ( countTwoIdx ( A , q ) ) ; } return ans ; }
public static int a ( String input ) { int b , c ; for ( int i = 0 ; i < a ; i ++ ) { b = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; c = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; } int d = Math . abs ( b - c ) ; if ( d % 10 != 0 ) { System . out . println ( d / 10 + 1 ) ; } else { System . out . println ( d / 10 ) ; } return d ; }
public static int [ ] getFibonacci ( int [ ] [ ] array ) { int [ ] [ ] query = { { 1 , 11 } , { 5 , 15 } , { 2 , 24 } } ; int [ ] prefix = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { int sum = 0 ; while ( ( i = array [ i ] [ 0 ] ) != 0 ) { sum = sum + i % 10 ; i = array [ i ] [ 1 ] ; } } for ( int i = 0 ; i < array . length ; i ++ ) { if ( i < array . length ) { prefix [ i ] [ 0 ] = i ; } } for ( int i = 0 ; i < array . length ; i ++ ) { if ( i < array [ i ] [ 0 ] == array [ i ] [ 0 ] ) { prefix [ i ] [ 0 ] = i ; } } for ( int i = 0 ; i < array . length ; i ++ ) { if ( i < array [ i ] [ 0 ] == array [ i ] [ 0 ] ) { prefix [ i ] [ 0 ] = i ; } } for ( int i = 0 ; i < array . length ; i ++ ) { prefix [ i ] [ 0 ] = i ; } for ( int i = 0 ; i < array . length ; i ++ ) { prefix [ i ] [ 0 ] = i ; } for ( int i = 0 ; i < array . length ; i ++ ) { prefix [ i ] [ 0 ] = i ; } for ( int i = 0 ; i < array . length ; i ++ ) { prefix [ i ] [ 0 ] = i ; } for ( int i = 0 ; i < array . length ; i ++ ) { prefix [ i ] [ 0 ] = i ; } for ( int i = 0 ; i < array . length ; i ++ ) { prefix [ i ] [ 0 ] = i ; } for ( int i = 0 ; i < array . length ; i ++ ) { prefix [ i ] [ 0 ] = i ; } for ( int i = 0 ; i < array . length ; i ++ ) { prefix [ i ] [ 1 ] = i ; } return prefix ; }
public static void solve ( String input ) { for ( int i = 0 ; i < input . length ( ) ; i ++ ) { int x1 = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int y1 = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int x2 = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int y2 = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int x3 = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int y3 = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int alpha = 0 ; if ( y1 == y2 && y3 < y1 ) alpha += Math . abs ( x1 - x2 ) ; if ( y2 == y3 && y1 < y2 ) alpha += Math . abs ( x2 - x3 ) ; if ( y3 == y1 && y2 < y3 ) alpha += Math . abs ( x3 - x1 ) ; System . out . println ( alpha ) ; } }
public static boolean isPalindrome ( String s ) { int l = s . length ( ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) { if ( ( s . charAt ( i ) != s . charAt ( l - 1 - i ) ) ) { return false ; } } return true ; }
public static String getStrFromString ( String str ) { String [ ] soots = { " S " , " H " , " C " , " D " } ; ArrayList < String > sootlist = new ArrayList ( ) ; ArrayList < Integer > numlist = new ArrayList ( ) ; for ( int i = 0 ; i < soots . length ; i ++ ) { String soot = Integer . parseInt ( str . substring ( 0 , i ) ) ; String num = Integer . parseInt ( str . substring ( i , i + 1 ) ) ; sootlist . add ( soot ) ; numlist . add ( Integer . parseInt ( num ) ) ; } ArrayList < String > ansootlist = new ArrayList ( ) ; ArrayList < Integer > ansnumlist = new ArrayList ( ) ; for ( String soot : soots ) { for ( int num = 1 ; num < 14 ; num ++ ) { int flag = 0 ; for ( String s = sootlist . get ( s ) ; s != null && num = numlist . get ( s ) ; n = numlist . get ( n ) ; if ( soot . equals ( s ) && num == n ) { flag = 1 ; break ; } } if ( flag == 1 ) { continue ; } else { ansootlist . add ( soot ) ; ansnumlist . add ( num ) ; } } for ( int i = 0 ; i < ansootlist . size ( ) ; i ++ ) { String soot = ansootlist . get ( i ) ; String num = ansnumlist . get ( i ) ; System . out . println ( soot + " ▁ " + num ) ; } return sootlist . get ( 0 ) ; }
public static int sumEvenAndEvenIndex ( int [ ] arr , int n ) { int i = 0 ; int sum = 0 ; for ( i = 0 ; i < n ; i += 2 ) { if ( ( arr [ i ] % 2 ) == 0 ) { sum += arr [ i ] ; } } return sum ; }
public static String getRandom ( String input ) { for ( int i = 0 ; i < input . length ( ) ; i ++ ) { String ans = " YES " ; for ( int k = 0 ; k < input . length ( ) ; k ++ ) { String g = input . substring ( k , k + 1 ) ; if ( Collections . frequency ( g , " A " ) == 1 ) { ans = " NO " ; break ; } } System . out . println ( ans ) ; } return null ; }
static void printDuplicates ( int [ ] arr , int n ) { int fl = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ arr [ i ] % n ] >= n ) ) { if ( ( arr [ arr [ i ] % n ] < 2 * n ) ) { System . out . print ( arr [ i ] % n + " ▁ " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ( fl == 0 ) ) { System . out . println ( " - 1" ) ; } arr = new int [ ] { 1 , 6 , 3 , 1 , 3 , 6 , 6 } ; int arrSize = arr . length ; printDuplicates ( arr , arrSize ) ; }
public static double sum ( double [ ] a ) { return a [ 0 ] * a [ 0 ] ; }
public static int Sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; if ( Class . isPrimitive ( " java . util . function . call " ) ) { n = 2 ; System . out . println ( Sum ( n ) ) ; } return 0 ; }
public static int maxHandshake ( int n ) { return ( int ) ( ( n * ( n - 1 ) ) / 2 ) ; n = 10 ; return maxHandshake ( n ) ; }
public static int grayCode ( int n ) { return n ^ ( n >>> 1 ) ; n = 10 ; return ( int ) n ; }
public static int MaxSum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
public static int possibleWays ( int n ) { if ( ( n % 2 == 1 ) ) { return 0 ; } else if ( ( n % 4 == 0 ) ) { return n / 4 - 1 ; } else { return n / 4 ; } int n = 20 ; return System . out . println ( possibleWays ( n ) ) ; }
public static int CountSetBits ( int n ) { if ( ( n == 0 ) ) { return 0 ; } if ( ( ( n & 1 ) == 1 ) ) { return 1 + CountSetBits ( n >> 1 ) ; } else { return CountSetBits ( n >> 1 ) ; } if ( Class . class . equals ( String . class ) ) { n = 21 ; System . out . println ( CountSetBits ( n ) ) ; } return 0 ; }
public static int summ ( int m , int n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; }
public static int SUM ( int n , int m ) { if ( ( m == 1 ) ) { return ( n * ( n + 1 ) / 2 ) ; } int sum = SUM ( n , m - 1 ) ; return ( int ) ( sum * ( sum + 1 ) / 2 ) ; }
public static int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; }
static int findSum ( int n ) { return ( ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ) ; }
public static int cntWays ( int n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } n = 18 ; return System . out . println ( cntWays ( n ) ) ; }
public static void findCompositeNos ( int n ) { System . out . println ( 9 * n + " ▁ " + 8 * n ) ; }
static int findThirdDigit ( int n ) { if ( n < 3 ) { return 0 ; } return n > 0 && 1 != 0 ? 1 : 6 ; }
public static int countMaxIntersect ( int n ) { return ( int ) ( n * ( n - 1 ) / 2 ) ; if ( Class . class . equals ( String . class ) ) { n = 8 ; System . out . println ( countMaxIntersect ( n ) ) ; } return 0 ; }
public static int sum ( int n ) { if ( ( n == 1 ) ) { return 2 ; } else { return ( n * ( n + 1 ) + sum ( n - 1 ) ) ; } }
public static int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { n = 48 ; System . out . println ( highestPowerOf2 ( n ) ) ; } return 0 ; }
public static int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; }
public static String getCountry ( String country ) { String country = country . toLowerCase ( ) ; return country . substring ( country . lastIndexOf ( ' . ' ) + 1 ) ; }
public static int min ( int [ ] array ) { int a = 0 ; int smallest ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] > array [ i ] ) { smallest = array [ i ] ; } } smallest = Math . min ( array [ 0 ] , smallest ) ; Arrays . sort ( array ) ; int i = 1 ; boolean tOrF = true ; while ( i < n ) { if ( array [ i ] / smallest != ( int ) array [ i ] / smallest ) { tOrF = false ; } i ++ ; } if ( tOrF == true ) { System . out . println ( smallest ) ; } else { System . out . println ( - 1 ) ; } return i ; }
public static String getCountry ( String country ) { return country . toLowerCase ( ) . replace ( " country " , " " ) ; }
public static String skipSpaces ( ) { char c = ' ▁ ' ; while ( Character . isWhitespace ( c ) ) { c = Character . toChars ( c ) ; } return c ; }
public static int smallest ( int x , int y , int z ) { int c = 0 ; while ( ( x && y && z ) != 0 ) { x = x - 1 ; y = y - 1 ; z = z - 1 ; c = c + 1 ; } return c ; }
public static int sum ( int a , int b , int c , int d , int e , int f ) { int sum = Integer . parseInt ( input ( ) ) ; return sum ; }
public static double getDistance ( double [ ] array , double distance ) { double distance = array [ 0 ] ; double distance = array [ 1 ] ; double distance = array [ 2 ] ; distance = array [ 3 ] ; distance = array [ 4 ] ; distance = array [ 5 ] ; distance = array [ 6 ] ; distance = array [ 7 ] ; return distance ; }
public static int countCubes ( int a , int b ) { return ( Math . floor ( b * ( 1.0d / 3. ) ) - Math . ceil ( a * ( 1.0d / 3. ) ) + 1 ) ; }
public static int search ( int [ ] itemArr , int d ) { final int INF = 10 * 20 ; final int [ ] [ ] que = new int [ ] [ ] ; Arrays . fill ( que , new int [ ] { 0 , 0 , 0 } ) ; while ( que . length > 0 ) { int score = que [ 0 ] [ 0 ] ; int a = que [ 0 ] [ 0 ] ; int e = que [ 0 ] [ 0 ] ; for ( int da = 0 ; da < itemArr [ e ] . length ; da ++ ) { int de = itemArr [ e ] [ da ] [ 0 ] ; int na = a + da ; if ( na >= d ) { System . out . println ( score + 1 ) ; return true ; } int ne = e + de ; if ( ne > 100 ) { ne = 100 ; } if ( ! visited [ ( na , ne ) ] [ 0 ] ) { visited [ ( na , ne ) ] [ 0 ] = true ; Arrays . fill ( que [ 0 ] [ da ] [ ne ] , new int [ ] { score + 1 , na , ne } ) ; } } } System . out . println ( " NA " ) ; return false ; }
public static String compute ( ) { final int triangle = 0 ; for ( int i = 1 ; i < 1000 ; i ++ ) { triangle += i ; if ( numDivisors ( triangle ) > 500 ) { return String . valueOf ( triangle ) ; } } final int numDivisors = ( int ) n ; final int end = Math . sqrt ( n ) ; int result = Math . pow ( 2 , end ) ; for ( int i = 1 ; i <= end ; i ++ ) { if ( n % i == 0 ) { result -= 1 ; } } if ( j == n ) { result -= 1 ; } return result ; }
static int findDelta ( int a , int b , int c , int d ) { return ( int ) ( ( b * c - a * d ) / ( d - c ) ) ; }
public static void SieveOfEratosthenes ( int n , boolean [ ] isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) { isPrime [ i ] = true ; } int p = 2 ; while ( ( p * p <= n ) ) { if ( ( isPrime [ p ] == true ) ) { int i = p * p ; while ( ( i <= n ) ) { isPrime [ i ] = false ; i += p ; } } p ++ ; } }
static int replaceDigit ( int x , int d1 , int d2 ) { int result = 0 ; int multiply = 1 ; while ( ( x % 10 ) > 0 ) { int remainder = x % 10 ; if ( ( remainder == d1 ) ) { result = ( result + d2 * multiply ) ; } else { result = ( result + remainder * multiply ) ; } multiply *= 10 ; x = ( int ) ( x / 10 ) ; } return result ; }
public static int printPattern ( int i , int j , int n ) { if ( ( j >= n ) ) { return 0 ; } if ( ( i >= n ) ) { return 1 ; } if ( ( j == i ) || ( j == n - 1 - i ) ) { if ( ( i == n - 1 - j ) ) { System . out . print ( " / " ) ; } else { System . out . print ( " \ \ " ) ; } } else { System . out . print ( " * " ) ; } if ( ( printPattern ( i , j + 1 , n ) ) == 1 ) { return 1 ; } System . out . println ( ) ; return printPattern ( i + 1 , 0 , n ) ; } if ( Class . forName ( " java . util . regex . Pattern " ) . equals ( " java . util . regex . Pattern " ) ) { int N = 9 ; printPattern ( 0 , 0 , N ) ; } return 0 ; }
public static int getPairsCount ( int [ ] arr , int n , int sum ) { final int [ ] m = new int [ 1000 ] ; for ( int i = 0 ; i <= n ; i ++ ) { m [ arr [ i ] ] = 0 ; m [ arr [ i ] ] ++ ; } int twiceCount = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { twiceCount += m [ sum - arr [ i ] ] ; if ( ( sum - arr [ i ] ) == arr [ i ] ) { twiceCount -- ; } } return ( int ) ( twiceCount / 2 ) ; }
public static int countSubArray ( int [ ] arr , int n ) { int subarraySum = 0 , remainingSum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarraySum = 0 ; remainingSum = 0 ; for ( int k = i ; k <= j ; k ++ ) subarraySum += arr [ k ] ; for ( int l = 0 ; l < i ; l ++ ) remainingSum += arr [ l ] ; for ( int l = j + 1 ; l < n ; l ++ ) remainingSum += arr [ l ] ; if ( ( subarraySum > remainingSum ) ) count ++ ; } } return count ; }
public static void solve ( String input ) { int n , x , a , b ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { n = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; x = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; a = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; b = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; int p = Math . abs ( a - b ) ; int q = p + x ; if ( q >= n - 1 ) { System . out . println ( n - 1 ) ; } else { System . out . println ( q ) ; } } }
public static int sum ( int [ ] array ) { int n = array . length ; int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = array [ i ] ; } Arrays . sort ( s ) ; int t = Arrays . stream ( s ) . sum ( ) ; if ( t % 10 != 0 ) { System . out . println ( t ) ; System . exit ( 0 ) ; } for ( int i = 0 ; i < n ; i ++ ) { t = Arrays . stream ( s , 0 , i ) . sum ( ) + Arrays . stream ( s , i + 1 ) . sum ( ) ; if ( t % 10 != 0 ) { System . out . println ( t ) ; System . exit ( 0 ) ; } } return t ; }
@ NonNull public static String getRandom ( ) { final String [ ] arr = new String [ ] { " A " , " B " , " C " , " D " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E " , " E "
public static int findRepeatingNumber ( int [ ] arr , int n ) { double sq = Math . sqrt ( n ) ; int range__ = ( int ) ( ( n / sq ) + 1 ) ; int [ ] count = new int [ range__ ] ; for ( int i = 0 ; i < n ; i += 1 ) count [ ( int ) ( ( arr [ i ] - 1 ) / sq ) ] ++ ; int selectedBlock = range__ - 1 ; for ( int i = 0 ; i < range__ - 1 ; i += 1 ) { if ( ( count [ i ] > sq ) ) { selectedBlock = i ; break ; } } HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( ( selectedBlock * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selectedBlock + 1 ) * sq ) ) ) { m . put ( arr [ i ] , 1 ) ; if ( ( m . get ( arr [ i ] ) ) > 1 ) return arr [ i ] ; } } return - 1 ; }
public static int maxPrimeFactors ( long n ) { long maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n >>= 1 ; } for ( long i = 3 ; i <= ( long ) Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) { maxPrime = n ; } return ( int ) maxPrime ; }
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static int getProfession ( int [ ] profession ) { int profession = profession . length ; int profession = profession [ profession . length ] ; return profession . length ; }
public static void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= ( int ) ( n / 3 ) ; i ++ ) { for ( int j = i + 1 ; j <= ( int ) ( n / 2 ) ; j ++ ) { int k = n - i - j ; if ( ( i * i + j * j == k * k ) ) { System . out . println ( i + " , ▁ " + j + " , ▁ " + k + " , ▁ " ) ; return ; } } } System . out . println ( " No ▁ Triplet " ) ; n = 12 ; pythagoreanTriplet ( n ) ; }
public static int countDigits ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) { return 1 ; } return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }
public static int indexOfFirstOne ( int [ ] arr , int low , int high ) { while ( ( low <= high ) ) { int mid = ( low + high ) / 2 ; if ( ( arr [ mid ] == 1 ) && ( mid == 0 || arr [ mid - 1 ] == 0 ) ) break ; else if ( ( arr [ mid ] == 1 ) ) high = mid - 1 ; else low = mid + 1 ; } return mid ; }
public static int gcd ( int n ) { final int gcd = Math . max ( 0 , Math . min ( 0 , Math . max ( 0 , n ) ) ) ; final int gcd = Math . max ( 0 , Math . min ( 0 , n ) ) ; final int gcd = gcd ; final int gcd = gcd ; if ( gcd == 0 ) { gcd = gcd ; } else { gcd = gcd ; } if ( gcd == 1 ) { gcd = gcd ; } return gcd ; }
public static void printString ( String input ) { double n = Double . parseDouble ( input ) ; if ( n < 0 ) break ; if ( Double . doubleToLongBits ( n * 16 ) - n * 16 == 0 ) System . out . println ( " NA " ) ; continue ; else { String s = Integer . toBinaryString ( ( int ) ( n * 16 ) ) ; System . out . println ( s . substring ( 0 , s . length ( ) - 4 ) + " . " + s . substring ( s . length ( ) - 4 ) ) ; } }
public static int digSum ( int n ) { int sum = 0 ; int rem = 0 ; while ( ( n = Math . max ( n , 0 ) ) != 0 ) { rem = n % 10 ; sum = sum + rem ; n = ( int ) ( n / 10 ) ; } return sum ; }
public static void main ( String [ ] args ) { int N = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int [ ] P = new int [ N ] ; for ( int i = 0 ; i < P . length ; i ++ ) { P [ i ] = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; } editorial ( N , P ) ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int a = Integer . parseInt ( args [ i ] ) ; int b = Integer . parseInt ( args [ i ] ) ; System . out . println ( a - b ) ; } }
static void performQueries ( int [ ] A , int [ ] q ) { int n = A . length ; int [ ] pref_xor = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) pref_xor [ i ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] ; for ( int i = 0 ; i < q . length ; i ++ ) { int L = q [ i ] [ 0 ] ; int R = q [ i ] [ 1 ] ; if ( ( L > R ) ) L = R ; R = L ; if ( ( L != R ) && pref_xor [ R ] == pref_xor [ L - 1 ] ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } int [ ] Arr = { 1 , 1 , 2 , 2 , 1 } ; q = new int [ ] { { 1 , 5 } , { 1 , 4 } , { 3 , 4 } } ; performQueries ( Arr , q ) ; }
public static final int [ ] getIntegerArray ( String [ ] array ) { int [ ] I = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { I [ i ] = Integer . parseInt ( array [ i ] ) ; } return I ; }
public static int getCountry ( String country ) { int country = country . indexOf ( ' _ ' ) ; if ( country . indexOf ( ' _ ' ) != - 1 ) { country = country . substring ( country . indexOf ( ' _ ' ) + 1 , country . length ( ) ) ; } else { country = country . substring ( 0 , country . length ( ) ) ; } return country . indexOf ( ' _ ' ) ; }
public static String getTitleString ( String text ) { if ( text == null ) { return null ; } if ( text . length ( ) == 0 ) { return " " ; } if ( text . length ( ) == 1 ) { return text . substring ( 0 , text . length ( ) ) ; } if ( text . length ( ) == 2 ) { return text . substring ( text . length ( ) - 2 , text . length ( ) ) ; } if ( text . length ( ) == 3 ) { return text . substring ( text . length ( ) - 3 , text . length ( ) ) ; } if ( text . length ( ) == 4 ) { return text . substring ( text . length ( ) - 4 , text . length ( ) ) ; } if ( text . length ( ) == 5 ) { return text . substring ( text . length ( ) - 5 , text . length ( ) ) ; } if ( text . length ( ) == 6 ) { return text . substring ( text . length ( ) - 6 , text . length ( ) - 7 ) ; } if ( text . length ( ) == 7 ) { return text . substring ( text . length ( ) - 7 , text . length ( ) ) ; } return text ; }
static int findPerm ( int n , int [ ] differences ) { int [ ] ans = new int [ n ] ; ans [ 0 ] = 0 ; int x = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = differences [ i ] ; x = x + diff ; ans [ i ] = x ; } int [ ] anss = ans ; Arrays . sort ( ans ) ; int flag = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { int res = ans [ i ] - ans [ i - 1 ] ; if ( ( res != 1 ) ) { flag = 0 ; } } if ( ( flag == 0 ) ) { System . out . println ( " - 1" ) ; return 0 ; } else { Map < Integer , Integer > mpp = new HashMap < > ( ) ; int j = 1 ; List < Integer > valueAtIndex = new ArrayList < > ( ) ; for ( int x : ans ) { mpp . put ( x , j ) ; j ++ ; } for ( int x : anss ) { valueAtIndex . add ( mpp . get ( x ) ) ; } for ( Integer x : valueAtIndex ) { System . out . print ( x + " ▁ " ) ; } System . out . println ( ) ; } differences = new int [ n ] ; differences [ 0 ] = 2 ; differences [ 1 ] = - 3 ; differences [ 2 ] = 2 ; n = differences . length + 1 ; findPerm ( n , differences ) ; }
public static int countPrimeFactors ( int n ) { int count = 0 ; while ( ( n % 2 ) == 0 ) { n = n / 2 ; count ++ ; } int i = 3 ; while ( ( i <= Math . sqrt ( n ) ) ) { while ( ( n % i ) == 0 ) { n = n / i ; count ++ ; } i = i + 2 ; } if ( ( n > 2 ) ) { count ++ ; } return ( count ) ; }
public static int solve ( int N , int K ) { int [ ] combo = new int [ N + 1 ] ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; }
public static String getDigitsFromString ( String str ) { if ( str . equals ( " " ) ) { return null ; } if ( str . length ( ) == 0 ) { return null ; } if ( str . length ( ) == 1 ) { return str . substring ( 1 ) ; } if ( str . length ( ) == 2 ) { return str . substring ( 0 , 2 ) ; } if ( str . length ( ) == 3 ) { return str . substring ( 3 , 4 ) ; } if ( str . length ( ) == 4 ) { return str . substring ( 4 , 5 ) ; } if ( str . length ( ) == 5 ) { return str . substring ( 5 , 6 ) ; } if ( str . length ( ) == 6 ) { return str . substring ( 6 , 7 ) ; } if ( str . length ( ) == 7 ) { return str . substring ( 7 , 8 ) ; } if ( str . length ( ) == 8 ) { return str . substring ( 8 , 9 ) ; } if ( str . length ( ) == 9 ) { return str . substring ( 9 , 10 ) ; } if ( str . length ( ) == 10 ) { return str . substring ( 11 , 12 ) ; } if ( str . length ( ) == 11 ) { return str . substring ( 12 , 13 ) ; } if ( str . length ( ) == 12 ) { return str . substring ( 13 , 14 ) ; } if ( str . length ( ) == 15 ) { return str . substring ( 14 , 15 ) ; } return str . substring ( 15 , 16 ) ; }
public static double normal ( double m , double n ) { double N = ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; }
public static double getDistance ( double [ ] values ) { double distance = 0 ; for ( double value : values ) { distance += value * value ; } return distance ; }
static int countBits ( int n ) { int count = 0 ; while ( ( n ) != 0 ) { count ++ ; n >>>= 1 ; } return count ; }
public static int getWeight ( int weight ) { int weight = weight / 2 ; int weight = weight / 2 ; weight = weight / 2 ; return weight ; }
public static int binarySearch ( int [ ] tlst ) { int n = Integer . parseInt ( input ( ) ) ; List < Integer > tlst = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) tlst . add ( Integer . parseInt ( input ( ) ) ) ; int maxT = tlst . get ( tlst . size ( ) - 1 ) ; List < Integer > divisors = new ArrayList < > ( ) ; for ( int i = 1 ; i <= maxT ; i ++ ) if ( maxT % i == 0 ) { divisors . add ( i ) ; } int ans = 0 ; for ( int t : tlst ) { int ind = bl ( divisors , t ) ; ans += divisors . get ( ind ) - t ; } return ans ; }
public static int LongestSubarray ( int [ ] arr , int n , int k ) { int [ ] arr2 = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] % k ; } int maxLength = 0 ; int i = 0 ; while ( i < n ) { int currentLength = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr2 [ j ] == arr2 [ i ] ) ) { currentLength ++ ; } else { break ; } } maxLength = Math . max ( maxLength , currentLength ) ; i = j ; i ++ ; } return maxLength ; }
public static int getMonth ( String year ) { int month = year . indexOf ( ' . ' ) ; return month ; }
public static boolean isHeterogram ( String s , int n ) { int [ ] hash = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != ' ▁ ' ) { if ( hash [ ( int ) s . charAt ( i ) - ' a ' ] == 0 ) { hash [ ( int ) s . charAt ( i ) - ' a ' ] = 1 ; } else { return false ; } } } return true ; s = " the ▁ big ▁ dwarf ▁ only ▁ jumps " ; n = s . length ( ) ; return ( isHeterogram ( s , n ) ? " YES " : " NO " ) ; }
public static String compute ( ) { final ArrayList < String > arr = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { arr . add ( " " ) ; } final ArrayList < String > temp = new ArrayList < > ( ) ; temp . addAll ( arr ) ; temp . addAll ( 999999 ) ; return temp . toString ( ) ; }
public static boolean FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( ( x > x1 && x < x2 && y > y1 && y < y2 ) ) { return true ; } else { return false ; } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { x1 = 0 ; y1 = 0 ; x2 = 10 ; y2 = 8 ; x = 1 ; y = 5 ; if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } else { return false ; } }
public static int countPoints ( int n , int [ ] points ) { final int MX = 2001 ; final int OFF = 1000 ; int [ ] x = new int [ ] { 0 , 1 } ; int [ ] y = new int [ ] { 0 , 1 } ; int [ ] x = new int [ ] { 0 , 1 } ; int [ ] y = new int [ ] { 0 , 1 } ; int [ ] x = new int [ ] { 0 , 1 } ; int [ ] y = new int [ ] { 0 , 1 } ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = x [ i ] ; y [ i ] = y [ i ] ; x [ i ] = x [ i ] ; y [ i ] = y [ i ] ; x [ i ] = Math . min ( x [ y ] , x [ i ] ) ; y [ i ] = Math . max ( x [ y ] , x [ i ] ) ; x [ i ] = y [ i ] ; x [ i ] = x [ i ] ; y [ i ] = y [ i ] ; x [ i ] = Math . min ( x [ y ] , y [ i ] ) ; y [ i ] = Math . max ( y [ x ] , y [ i ] ) ; x [ i ] = y [ i ] ; x [ i ] = x [ i ] ; y [ i ] = y [ i ] ; if ( ( x [ i ] > minx [ y ] && x [ i ] < maxx [ y ] ) ) { if ( ( y [ i ] > miny [ x ] && y [ i ] < maxy [ x ] ) ) { count [ i ] = 1 ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = x [ i ] ; y [ i ] = y [ i ] ; if ( ( x [ i ] > minx [ y ] && x [ i ] < maxx [ y ] ) ) { if ( ( y [ i ] > miny [ x ] && y [ i ] < maxy [ x ] ) ) { count ++ ; } } return count ; } if ( Thread . currentThread ( ) . getName ( ) . equals ( " java . util . Date " ) ) { points = new int [ ] { System . currentTimeMillis ( ) , points }
public static int getDistance ( int [ ] values ) { int distance = 0 ; for ( int i = 0 ; i < values . length ; i ++ ) distance += values [ i ] * values [ i ] ; return distance ; }
public static int countSticks ( String string , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ ( int ) string . charAt ( i ) - '0' ] ) ; } return cnt ; }
public static int getRandom ( String input ) { int T = Integer . parseInt ( input ) ; for ( int t = 0 ; t <= T ; t ++ ) { int n = Integer . parseInt ( input ) ; int [ ] a = Integer . parseInt ( input ) ; int ctr = 0 ; int maxi = Math . max ( a . length , maxi ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] && a [ i - 1 ] > a [ i - 2 ] ) { ctr ++ ; if ( i != n - 1 ) a [ i ] = Math . max ( a [ i - 1 ] , a [ i + 1 ] ) ; else a [ i ] = a [ i - 1 ] ; } } } System . out . println ( ctr ) ; for ( int item : a ) { System . out . print ( item + " ▁ " ) ; } System . out . println ( ) ; return T ; }
public static void command ( int brr , int a , int b ) { arr [ a ] ^= 1 ; arr [ b + 1 ] ^= 1 ; }
public static int mostFrequent ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int maxCount = 1 ; int res = arr [ 0 ] ; int currCount = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] == arr [ i - 1 ] ) ) { currCount ++ ; } else { if ( ( currCount > maxCount ) ) { maxCount = currCount ; res = arr [ i - 1 ] ; } currCount = 1 ; } } if ( ( currCount > maxCount ) ) { maxCount = currCount ; res = arr [ n - 1 ] ; } return res ; } arr = Arrays . asList ( 1 , 5 , 2 , 1 , 3 , 2 , 1 ) ; n = arr . length ; System . out . println ( mostFrequent ( arr , n ) ) ; }
public static int maxLength ( String str , int len ) { int res = 0 ; int [ ] lastPos = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { lastPos [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int C = str . charAt ( i ) - ' a ' ; if ( ( lastPos [ C ] != - 1 ) ) { res = Math . max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) ; } lastPos [ C ] = i ; } return res ; }
public static int ksmallest ( int [ ] arr , int n , int k ) { int [ ] b = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; j < MAX ; j ++ ) { if ( ( b [ j ] != 1 ) ) { k -- ; } if ( ( k != 1 ) ) { return j ; } } k = 1 ; arr = new int [ n ] ; arr [ n ] = 1 ; n = arr . length ; System . out . println ( ksmallest ( arr , n , k ) ) ; return 0 ; }
public static boolean isDivisible ( int n ) { while ( n / 100 != 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
public static boolean isDivisible ( int n ) { while ( n / 100 != 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { n = 59173 ; if ( ( isDivisible ( n ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } return false ; }
public static boolean isDivisible ( int n ) { while ( n / 100 != 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { n = 1922 ; if ( ( isDivisible ( n ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } return false ; }
public static boolean isDivisible ( int n ) { while ( n / 100 != 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
public static int OddSum ( int n ) { int total = ( n + 1 ) / 2 ; int odd = total * total ; return odd ; }
public static boolean isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( ( lowCost <= ans && ans <= upCost ) ) { return true ; } } return false ; }
public static boolean Log2 ( int x ) { if ( x == 0 ) { return false ; } return ( Math . log10 ( x ) / Math . log10 ( 2 ) ) ; }
public static String compute ( ) { final int LIMIT = 50000000 ; final List < Integer > primes = EulerUtil . listPrimes ( EulerUtil . sqrt ( LIMIT ) ) ; final Set < Integer > sums = new HashSet < > ( 0 ) ; for ( int i = 2 ; i < 5 ; i ++ ) { final Set < Integer > newsums = new HashSet < > ( ) ; for ( final Integer p : primes ) { final int q = p * i ; if ( q > LIMIT ) break ; for ( final Integer x : sums ) if ( x + q <= LIMIT ) newsums . add ( x + q ) ; } sums = newsums ; } return String . valueOf ( sums . size ( ) ) ; }
public static int longLenSub ( int [ ] arr , int n ) { HashMap < Integer , Integer > um = new HashMap < > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len1 = 0 ; if ( ( um . containsKey ( arr [ i ] - 1 ) ) && ( len1 < um . get ( arr [ i ] - 1 ) ) ) { len1 = um . get ( arr [ i ] - 1 ) ; } if ( ( um . containsKey ( arr [ i ] + 1 ) ) && ( len1 < um . get ( arr [ i ] + 1 ) ) ) { len1 = um . get ( arr [ i ] + 1 ) ; } um . put ( arr [ i ] , len1 + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) { longLen = um . get ( arr [ i ] ) ; } } return longLen ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int a = Integer . parseInt ( args [ i ] ) ; int b = Integer . parseInt ( args [ i ] ) ; System . out . println ( a + b ) ; } }
static int calculateSum ( int n ) { int sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
static int calculateSum ( int n ) { int sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
public static int maxDiff ( int [ ] arr , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int currSum = diff ; int maxSum = currSum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( ( currSum > 0 ) ) { currSum += diff ; } else { currSum = diff ; } if ( ( currSum > maxSum ) ) { maxSum = currSum ; } } return maxSum ; }
public static int f3 ( int n ) { int a = 0 ; int b = 0 ; int c = 0 ; for ( ; n > 0 ; n -- ) { a = ( a + b + c + 1 ) % 100000007 ; b = a ; c = b ; } return a ; int f5 ( n ) { a = b = c = d = e = 0 ; for ( ; n > 0 ; n -- ) { a = ( a + b + c + d + e + 1 ) % 100000007 ; b = a ; c = b ; d = c ; e = d ; } return a ; } while ( true ) { String s = System . getProperty ( " line . separator " ) ; if ( s . equals ( " # " ) ) break ; int ans = 1 ; String num = " _ " ; int cnt = 1 ; for ( ; n != null ; n = s + " _ " ; n = s . length ( ) ) { if ( n . equals ( num ) ) cnt ++ ; else { if ( "80" . equals ( num ) ) ans = ans * f3 ( cnt ) % 100000007 ; else ans = ans * f5 ( cnt ) % 100000007 ; num = n ; cnt = 1 ; } } } System . out . println ( ans ) ; }
static int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int Max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( ( val == Max ) ) { count ++ ; } } } return count ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = 0 ; } for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == 0 ) { array [ i ] = 0 ; } else { array [ i ] = array [ i - 1 ] ; } if ( array [ i ] == array [ i + 1 ] ) { array [ i ] ++ ; } } for ( int m = 0 ; m < array . length ; m ++ ) { int y = Integer . parseInt ( array [ m ] ) ; int z = Integer . parseInt ( array [ m ] ) ; if ( y == 1 ) { System . out . println ( array [ z - 2 ] ) ; } else { System . out . println ( array [ z - 2 ] - array [ y - 2 ] ) ; } } return array ; }
public static void solve ( ) { Scanner f_i = new Scanner ( System . in ) ; int n = f_i . nextInt ( ) ; int ans ; int ans ; int [ ] cups = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int i = f_i . nextInt ( ) ; if ( i == 0 ) { return ; } char tray = cups [ n - i ] ; if ( tray == ' A ' ) { return f . nextInt ( ) ; } else if ( tray == ' B ' ) { return 2 * 3 * ( i - 1 ) - 1 - f . nextInt ( ) ; } else { return f . nextInt ( ) + 2 * 3 * f . nextInt ( ) ; } } while ( true ) { n = f_i . nextInt ( ) ; m = f_i . nextInt ( ) ; if ( n == 0 ) { break ; } cups = new int [ n ] ; for ( char tray : " ABC " . toCharArray ( ) ) { Iterator < char > itr = f_i . nextInt ( ) ; ( ( char ) itr . next ( ) ) { cups [ i - 1 ] = tray ; } } ans = Math . min ( num , 3 * n - 1 - num ) ; if ( ans <= m ) { System . out . println ( ans ) ; } else { System . out . println ( - 1 ) ; } } }
public static void print ( int [ ] g1 , int a , int [ ] g2 , int b ) { for ( int i = 0 ; i < a ; i ++ ) { System . out . print ( g1 [ i ] + " ▁ " ) ; } System . out . print ( " and ▁ " ) ; for ( int i = 0 ; i < b ; i ++ ) { System . out . print ( g2 [ i ] + " ▁ " ) ; } System . out . print ( " \n " ) ; }
public static void cutRibbon ( ) { int [ ] arr = new int [ 4 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = Integer . parseInt ( String . valueOf ( i ) ) ; } int length = arr [ 0 ] ; Arrays . sort ( arr , 1 , 4 , false ) ; if ( ( length % arr [ 0 ] ) == 0 ) { System . out . println ( ( int ) ( length / arr [ 0 ] ) ) ; return ; } int ans = 0 ; if ( ( arr [ 0 ] ) == arr [ 1 ] ) { int k = 0 ; for ( int i = ( int ) ( length / arr [ 2 ] ) + 1 ; ; i ++ ) { int check = length - i * arr [ 2 ] ; if ( ( check >= 0 ) && ( check % arr [ 0 ] ) == 0 ) { k = ( int ) ( check / arr [ 0 ] ) ; ans = Math . max ( ans , k + i ) ; } } } else { int k = 0 ; for ( int i = ( int ) ( length / arr [ 2 ] ) + 1 ; i ++ ) { for ( int j = ( int ) ( length / arr [ 1 ] ) + 1 ; j ++ ) { int check = length - i * arr [ 2 ] - j * arr [ 1 ] ; if ( ( check >= 0 ) && ( check % arr [ 0 ] ) == 0 ) { k = ( int ) ( check / arr [ 0 ] ) ; ans = Math . max ( ans , k + i + j ) ; } } } } System . out . println ( ans ) ; return ; }
public static int maxSubseq ( int [ ] vec , int n ) { int suffix = 0 ; int i = n - 1 ; while ( ( i >= 0 ) && ( ( vec [ i ] ) == 1 ) ) { suffix ++ ; vec [ i ] = suffix ; } i -- ; int res = 0 ; int zero = 0 ; for ( i = 0 ; i < n ; i += 1 ) { if ( ( vec [ i ] ) == 0 ) { zero ++ ; } if ( ( vec [ i ] ) > 0 ) { res = Math . max ( res , zero + vec [ i ] ) ; } } return Math . max ( res , zero ) ; }
public static int countPaths ( int [ ] [ ] maze ) { int R = 4 ; int C = 4 ; int [ ] [ ] ; if ( ( maze [ 0 ] [ 0 ] == - 1 ) ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( ( maze [ i ] [ 0 ] == 0 ) ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i += 1 ) { if ( ( maze [ 0 ] [ i ] == 0 ) ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i += 1 ) { for ( int j = 1 ; j < C ; j += 1 ) { if ( ( maze [ i ] [ j ] == - 1 ) ) continue ; if ( ( maze [ i - 1 ] [ j ] > 0 ) ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( ( maze [ i ] [ j - 1 ] > 0 ) ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } if ( ( maze [ R - 1 ] [ C - 1 ] > 0 ) ) return maze [ R - 1 ] [ C - 1 ] ; else return 0 ; } if ( Class . forName ( " java . util . regex . regex " ) . equals ( " java . util . regex . regex . regex " ) ) { maze = new int [ ] [ ] { 0 , 0 , 0 , 0 } ; } else if ( ( maze [ R - 1 ] [ C - 1 ] > 0 ) && ( maze [ R - 1 ] [ C - 1 ] != 0 ) ) return maze [ R - 1 ] [ C - 1 ] ; else return 0 ; }
public static boolean isPrime ( int N ) { boolean isPrime = true ; int arr [ ] = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( ( N < 2 ) ) { isPrime = false ; } if ( ( N % 2 == 0 ) || ( N % 3 == 0 ) || ( N % 5 == 0 ) ) { isPrime = false ; } for ( int i = 0 ; ( i = ( int ) Math . sqrt ( N ) ; i < 30 ; i ++ ) { for ( int c : arr ) { if ( ( c > ( int ) Math . sqrt ( N ) ) ) { break ; } else { if ( ( N % ( c + i ) ) == 0 ) { isPrime = false ; break ; } } if ( ( ! isPrime ) ) { break ; } } } if ( ( isPrime ) ) { System . out . println ( " Prime ▁ Number " ) ; } else { System . out . println ( " Not ▁ a ▁ Prime ▁ Number " ) ; } if ( Class . isPrime ( ) ) { N = 121 ; isPrime ( N ) ; } return true ; }
public static int getMonth ( int year , int month ) { return ( year + month ) * ( month - 1 ) ; }
public static int max ( int x , int y ) { if ( ( x > y ) ) { return x ; } return y ; }
static int findLength ( String st , int n ) { int [ ] total = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { total [ i ] = ( total [ i - 1 ] + Integer . parseInt ( st . substring ( i - 1 , i + 1 ) ) - Integer . parseInt ( "0" ) ) ; } int ans = 0 ; int l = 2 ; while ( ( l <= n ) ) { for ( int i = 0 ; i <= n - l ; i ++ ) { int j = i + l - 1 ; if ( ( total [ i + Integer . parseInt ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + Integer . parseInt ( l / 2 ) ] ) ) { ans = Math . max ( ans , l ) ; } } l = l + 2 ; } return ans ; }
public static void prints ( String [ ] a , int n , int ind ) { int i = ind ; while ( i < n + ind ) { System . out . print ( a [ ( i % n ) ] + " ▁ " ) ; i = i + 1 ; } a = a [ 0 ] ; a [ 0 ] = a [ 1 ] ; a [ 1 ] = a [ 2 ] ; a [ 2 ] = a [ 3 ] ; }
public static void prints ( String [ ] a , int n , int ind ) { String [ ] b = new String [ 2 * n ] ; int i = 0 ; while ( i < n ) { b [ i ] = b [ n + i ] = a [ i ] ; i = i + 1 ; } i = ind ; while ( i < n + ind ) { System . out . print ( b [ i ] + " ▁ " ) ; i = i + 1 ; } a = new String [ ] { " A " , " B " , " C " , " D " , " E " , " F " } ; n = a . length ; prints ( a , n , 3 ) ; }
public static int solve ( ) { final String input = System . getProperty ( " line . separator " ) ; return Integer . parseInt ( input ) ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 2 ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = i ; } return array ; }
public static int min ( int v1 , int v2 ) { int t = Integer . parseInt ( input ( ) ) ; int d = Integer . parseInt ( input ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < t ; i ++ ) { sum += Math . min ( v1 + d * i , v2 + d * ( t - i - 1 ) ) ; } return sum ; }
public static int getDistance ( int [ ] array , int [ ] values ) { int [ ] dist = new int [ array . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( values [ i ] < values [ i ] ) dist [ i ] = values [ i ] ; } return dist [ 0 ] ; }
public static final double [ ] getDoubleArray ( double [ ] array ) { double [ ] a = new double [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { a [ i ] = array [ i ] ; } return a ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForProposi
public static void bin ( int n ) { if ( ( n > 1 ) ) { bin ( n >> 1 ) ; } System . out . print ( n & 1 ) ; }
public static String compute ( ) { long ans = Long . parseLong ( " " ) ; for ( long x = 0 ; x < 1000 ; x ++ ) { if ( ( x % 3 == 0 || x % 5 == 0 ) ) { ans = Long . parseLong ( " " ) ; } } return String . valueOf ( ans ) ; }
public static void input ( ) { Scanner S = new Scanner ( System . in ) ; int A = S . nextInt ( ) ; System . out . println ( "1 ▁ ' " . concat ( A ) . concat ( "0 ▁ ' " . concat ( A ) . concat ( " z " ) ) ) ; }
public static int a ( ) { int b = Integer . parseInt ( input ( ) ) ; return ( b * 2 - a ) ; }
public static int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
public static int productDiagonals ( int [ ] [ ] arr , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * arr [ i ] [ i ] ; product = product * arr [ i ] [ n - i - 1 ] ; } if ( ( n % 2 ) == 1 ) { product = product / arr [ n / 2 ] [ n / 2 ] ; } return product ; }
public static void printString ( String input ) { int n = Integer . parseInt ( input ) ; if ( n == 0 ) { break ; } HashMap < Integer , Integer > dic = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int c = Integer . parseInt ( input ) ; dic . put ( c , ++ i ) ; } for ( int v : dic . values ( ) ) { System . out . println ( v != 0 ? " * " + v : " - " ) ; } }
public static char getSecondMostFreq ( String str ) { final int NO_OF_CHARS = 256 ; int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ ( int ) str . charAt ( i ) ] ++ ; } int first = 0 , second = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( ( count [ i ] > count [ second ] ) && ( count [ i ] != count [ first ] ) ) { second = i ; } } return ( char ) second ; }
public static int [ ] a ( int [ ] a ) { for ( int i = 0 ; i < 2001 ; i ++ ) a [ i ] = a [ 4000 - i ] = ( i + 3 ) * ( i + 2 ) * ( i + 1 ) / 6 - 4 * a [ i - 1001 ] * ( i > 999 ) ; while ( true ) { try { System . out . println ( a [ Integer . parseInt ( input ) ] ) ; } catch ( Exception e ) { break ; } } return a ; }
public static int [ ] mySort ( int [ ] arr , int n ) { int [ ] arr1 = Arrays . copyOf ( arr , n / 2 ) ; int [ ] arr2 = Arrays . copyOf ( arr , n / 2 ) ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 , Collections . reverseOrder ( ) ) ; return arr1 . clone ( ) ; }
public static int minflip ( int [ ] arr1 , int [ ] arr2 , int [ ] arr3 , int p , int q , int n ) { int flip = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr1 [ i ] ^ arr2 [ i ] != arr3 [ i ] ) ) { flip ++ ; } } return ( flip <= p + q ) ? flip : - 1 ; }
public static double sum ( int n ) { int i = 1 ; double s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) { s = s + 1 / i ; } return s ; }
public static void bitonicGenerator ( int [ ] arr , int n ) { ArrayList < Integer > evenArr = new ArrayList < > ( ) ; ArrayList < Integer > oddArr = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( i % 2 ) == 0 ) ) { evenArr . add ( arr [ i ] ) ; } else { oddArr . add ( arr [ i ] ) ; } } evenArr . clear ( ) ; evenArr . add ( arr [ 0 ] ) ; oddArr . add ( arr [ 1 ] ) ; oddArr . add ( arr [ 2 ] ) ; oddArr . clear ( ) ; oddArr . add ( arr [ 3 ] ) ; oddArr . add ( arr [ 4 ] ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ] = evenArr . get ( j ) ; i ++ ; } for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) { arr [ i ] = oddArr . get ( j ) ; i ++ ; } arr = new int [ ] { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; n = arr . length ; bitonicGenerator ( arr , n ) ; for ( int i : arr ) { System . out . print ( i + " ▁ " ) ; } }
static int countPairs ( int [ ] arr , int n ) { int count = 0 ; int right = 0 ; int left = 0 ; boolean [ ] visited = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { visited [ i ] = false ; } while ( ( right < n ) ) { while ( ( right < n ) && visited [ arr [ right ] ] == false ) { count += ( right - left ) ; visited [ arr [ right ] ] = true ; right ++ ; } while ( ( left < right ) && ( right != n ) && visited [ arr [ right ] ] == true ) { visited [ arr [ left ] ] = false ; left ++ ; } } return count ; }
public static String preorder ( String val ) { String sObj ; if ( val == null ) { sObj = " " ; } else if ( val . length ( ) < 3 ) { sObj = " " ; } else if ( val . length ( ) < 4 ) { sObj = " " ; } else if ( val . length ( ) < 5 ) { sObj = " " ; } else if ( val . length ( ) < 6 ) { sObj = " " ; } else if ( val . length ( ) < 7 ) { sObj = " " ; } else if ( val . length ( ) < 8 ) { sObj = " " ; } else if ( val . length ( ) < 9 ) { sObj = " " ; } else if ( val . length ( ) < 10 ) { sObj = " " ; } else if ( val . length ( ) < 11 ) { sObj = " " ; } else if ( val . length ( ) < 12 ) { sObj = " " ; } else if ( val . length ( ) < 13 ) { sObj = " " ; } else if ( val . length ( ) < 14 ) { sObj = " " ; } else if ( val . length ( ) < 15 ) { sObj = " " ; } else if ( val . length ( ) < 17 ) { sObj = " " ; } else if ( val . length ( ) < 18 ) { sObj = " " ; } else if ( val . length ( ) < 19 ) { sObj = " " ; } else if ( val . length ( ) < 19 ) { sObj = " " ; } else if ( val . length ( ) < 17 ) { sObj = " " ; } else if ( val . length ( ) < 18 ) { sObj = " " ; } else if ( val . length ( ) < 19 ) { sObj = " " ; } else if ( val . length ( ) < 19 ) { sObj = " " ; } else if ( val . length ( ) < 20 ) { sObj = " " ; } else if ( val . length ( ) < 21 ) { sObj = " " ; } else if ( val . length ( ) < 21 ) { sObj = " " ; } else if ( val . length ( ) < 21 ) { sObj = " " ; } else if ( val . length (
public static int solve ( int idx , int diff , int N , int M , int K ) { int N = 1001 ; int MOD = 998244353 ; int [ ] [ ] dp = new int [ M ] [ M ] ; for ( int i = 0 ; i < M ; i ++ ) { if ( ( idx > N ) ) { if ( ( diff == K ) ) { return 1 ; } return 0 ; } if ( ( dp [ idx ] [ diff ] != - 1 ) ) { return dp [ idx ] [ diff ] ; } int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; dp [ idx ] [ diff ] = ans % MOD ; } return dp [ idx ] [ diff ] ; }
public static String compute ( ) { final int NUM_SPHERES = 21 ; final int [ ] sphereradii = new int [ NUM_SPHERES ] ; for ( int i = 0 ; i < NUM_SPHERES ; i ++ ) { sphereradii [ i ] = ( i + 30 ) * 1000 ; } final double [ ] [ ] minlength = new double [ NUM_SPHERES ] [ ] ; for ( int i = 0 ; i < NUM_SPHERES ; i ++ ) { minlength [ i ] [ i ] = new double [ 2 * NUM_SPHERES ] ; } for ( int i = 0 ; i < NUM_SPHERES ; i ++ ) { if ( ( setofspheres & ( 1 << currentsphereindex ) ) == 0 ) { throw new IllegalArgumentException ( ) ; } if ( minlength [ i ] [ i ] == 0 ) { double result ; if ( ( setofspheres ) == 1 ) { result = sphereradii [ currentsphereindex ] ; } else { result = Double . MAX_VALUE ; int newsetofspheres = setofspheres ^ ( 1 << currentsphereindex ) ; for ( int i = 0 ; i < NUM_SPHERES ; i ++ ) { if ( ( newsetofspheres & ( 1 << i ) ) == 0 ) { continue ; } double temp = Math . sqrt ( ( sphereradii [ i ] + sphereradii [ currentsphereindex ] - 50000 ) * 200000 ) ; temp += findMinimumLength ( i , newsetofspheres ) ; result = Math . min ( temp , result ) ; } } minlength [ i ] [ i ] = result ; } } final double ans = Math . min ( ( findMinimumLength ( i , ( 1 << NUM_SPHERES ) - 1 ) + sphereradii [ i ] ) , Math . round ( ans ) ) ; return String . valueOf ( ( int ) Math . round ( ans ) ) ; }
public static String getCountry ( String country ) { String country = country . toLowerCase ( ) ; if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 , country . length ( ) ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 , country . length ( ) ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 , country . length ( ) ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 , country . length ( ) ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 , country . length ( ) ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 , country . length ( ) ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring ( country . indexOf ( " _ " ) + 1 , country . length ( ) ) ; } else if ( country . contains ( " _ " ) ) { country = country . substring
static int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { if ( ( N % 2 == 0 ) ) { return 0 ; } int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) { res ^= arr [ i ] ; } return res ; }
static int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( ( freq % 2 == 1 ) ) { res = res ^ arr [ i ] ; } } return res ; }
public static String getRandom ( String s ) { if ( s == null ) { return null ; } else if ( s . length ( ) == 0 ) { return " " ; } else if ( s . length ( ) == 1 ) { return " " ; } else if ( s . length ( ) == 2 ) { return " " ; } else if ( s . length ( ) == 3 ) { return " " ; } else if ( s . length ( ) == 4 ) { return " " ; } else if ( s . length ( ) == 5 ) { return " " ; } else if ( s . length ( ) == 6 ) { return " " ; } else if ( s . length ( ) == 7 ) { return " " ; } else if ( s . length ( ) == 8 ) { return " " ; } else if ( s . length ( ) == 9 ) { return " " ; } else if ( s . length ( ) ==
public static void main ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { int n = Integer . parseInt ( args [ i ] ) ; List < Integer > l = new ArrayList < > ( ) ; l . add ( Integer . parseInt ( args [ i ] ) ) ; l . add ( l . get ( n ) ) ; l . add ( l . get ( n - 1 ) ) ; } System . out . println ( l . get ( 0 ) . compareTo ( l . get ( 1 ) ) ) ; }
public static int getFrequency ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] t = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { t [ i ] = Integer . parseInt ( input ) ; } int ans = 0 ; Map < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( - t [ i ] ) ) { ans += freq . get ( - t [ i ] ) ; } if ( freq . containsKey ( t [ i ] ) ) { freq . put ( t [ i ] , 1 ) ; } else { freq . put ( t [ i ] , 1 ) ; } } return ans ; }
public static String getLetter ( String s ) { int index ; if ( s . length ( ) > 0 ) { s = s . indexOf ( ' _ ' ) ; if ( index == - 1 ) { s = s . substring ( 0 , index ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } else if ( index == - 1 ) { s = s . substring ( index + 1 ) ; } return s ; }
public static int lcm ( int a , int b ) { int [ ] S = new int [ ] { a * b , a * b } ; int combinationCount = 0 ; int permutationsCount = 0 ; int bigPrime = 1000000007 ; int N = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; String [ ] S = System . getProperty ( " line . separator " ) . split ( " ▁ " ) ; int [ ] Wn = new int [ N ] ; int [ ] En = new int [ N ] ; int Wc = 0 ; int Ec = 0 ; for ( int i = 0 ; i < S . length ; i ++ ) { String s = S [ i ] ; if ( s . equals ( " W " ) ) { Wc ++ ; } else { Ec ++ ; } Wn [ i ] = Wc ; En [ i ] = Ec ; } int ans = 10 * 10 ; Wn = new int [ N ] ; En = new int [ N ] ; En [ 0 ] = En [ N ] ; for ( int i = 1 , w = 0 , e = 0 ; w < N ; w ++ , e = 0 ; e ++ ) { ans = Math . min ( Wn [ i ] + En [ N ] - En [ i + 1 ] , ans ) ; } System . out . println ( ans ) ; return 0 ; }
public static int getRandom ( ) { int n = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; int [ ] chips = new int [ n ] ; for ( int i = 0 ; i < chips . length ; i ++ ) { chips [ i ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; } return chips [ 0 ] ; }
public static int getQuadrupletCount ( int [ ] array ) { int N = 10100000 ; boolean [ ] temp = new boolean [ N + 1 ] ; temp [ 0 ] = temp [ 1 ] = false ; for ( int i = 2 ; i < array . length ; i ++ ) { if ( temp [ i ] ) { temp [ i + i ] = new boolean [ array . length ] ; for ( int j = 0 ; j < array . length ; j ++ ) { temp [ i + j ] [ j ] = false ; } } } boolean [ ] quadruplet = new boolean [ ] { true , false , true , false , false , false , true , false , true } ; while ( true ) { try { int n = Integer . parseInt ( input ( ) ) ; for ( int i = n ; i > 9 ; i -- ) { if ( temp [ i ] && temp [ i - 8 ] == quadruplet [ i ] ) { System . out . println ( i ) ; break ; } } } catch ( Exception e ) { } } return 0 ; }
public static int [ ] getNegativeInstances ( ) { int [ ] a = new int [ 2 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = Integer . parseInt ( a [ i ] ) ; } List < Integer > r = new ArrayList < > ( ) ; int s = 0 ; int l = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] != 1 ) { s = s + a [ i ] ; int t = i + 1 - l ; int p = s - 1 * t ; if ( p % 2 == 0 ) { r . add ( 2 ) ; } else { r . add ( 1 ) ; } } else { l = l + 1 ; if ( r . size ( ) == 0 ) { r . add ( 2 ) ; } else { int q = r . get ( r . size ( ) - 1 ) ; r . add ( q ) ; } } } for ( int i = 0 ; i < r . size ( ) ; i ++ ) { System . out . println ( r . get ( i ) ) ; } return r . toArray ( new Integer [ r . size ( ) ] ) ; }
public static boolean powerOfTwo ( int n ) { return ( ! ( n & n - 1 ) ) ; }
public static int minimumCostOfBreaking ( int [ ] X , int [ ] Y , int m , int n ) { int res = 0 ; Arrays . sort ( X , Collections . reverseOrder ( ) ) ; Arrays . sort ( Y , Collections . reverseOrder ( ) ) ; int hzntl = 1 ; int vert = 1 ; int i = 0 ; int j = 0 ; while ( ( i < m ) && ( j < n ) ) { if ( ( X [ i ] > Y [ j ] ) ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( ( i < m ) ) { total += X [ i ] ; i ++ ; } res += total * vert ; total = 0 ; while ( ( j < n ) ) { total += Y [ j ] ; j ++ ; } res += total * hzntl ; return res ; } m = 6 ; n = 4 ; X = new int [ ] { 2 , 1 , 3 , 1 , 4 } ; Y = new int [ ] { 4 , 1 , 2 } ; System . out . println ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) ) { return b ; } return gcd ( b % a , a ) ; }
public static int [ ] [ ] multiply ( int [ ] [ ] a , int [ ] [ ] b ) { int [ ] [ ] mul = new int [ 3 ] [ 3 ] ; for ( int x = 0 ; x < 3 ; x ++ ) mul [ x ] [ x ] [ y ] [ x ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ x ] [ y ] [ y ] [ y ] [ x ] [ y ] [ y ] [ y ] [ x ] [ y ] [ y ] [ y ] [ x ] [ y ] [ y ] [ y ] [ y ] [ x ] [ y ] [ y ] [ y ] [ y ] [ x ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ x ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y ] [ y
public static int MinimumValue ( int x , int y ) { if ( ( x > y ) ) { x = y ; y = x ; } int a = 1 ; int b = x - 1 ; int c = y - b ; return a + b + c ; }
public static boolean checkPossibility ( int [ ] nums ) { if ( Class . forName ( " java . util . regex . regex . regex " ) . equals ( " . * " ) ) { int sObj = 0 ; int [ ] nums = { 4 , 2 , 3 } ; for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( ( nums [ i ] > nums [ i + 1 ] ) ) { brokenNum ++ ; if ( brokenNum >= 2 ) return false ; if ( ( i - 1 < 0 ) || ( nums [ i - 1 ] <= nums [ i + 1 ] ) ) nums [ i ] = nums [ i + 1 ] ; else nums [ i + 1 ] = nums [ i ] ; } } } return true ; }
public static boolean check ( int mid , int [ ] array , int n , int K ) { int count = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( array [ i ] > mid ) ) { return false ; } sum += array [ i ] ; if ( ( sum > mid ) ) { count ++ ; sum = array [ i ] ; } } count ++ ; if ( ( count <= K ) ) { return true ; } return false ; }
public static int [ ] [ ] getComponents ( int [ ] components ) { int m = 0 ; int n = components . length ; if ( m == 0 ) { break ; } int [ ] objs = new int [ n ] ; for ( int i = 0 ; i < objs . length ; i ++ ) { objs [ i ] = Integer . parseInt ( components [ i ] , 2 ) ; } int [ ] [ ] dp = new int [ 1 << m ] [ ] ; for ( int i = 0 ; i < dp . length ; i ++ ) { dp [ i ] [ 0 ] = 0 ; } for ( int i = 0 ; i < bits . length ; i ++ ) { bits [ i ] [ 0 ] = 1 << i ; } for ( int mask = 0 ; mask < 1 << m ; mask ++ ) { Set < Integer > s = new HashSet < > ( ) ; for ( int obj : objs ) { if ( obj != null ) { s . add ( obj ) ; } } for ( int b : s . iterator ( ) ) { if ( ! b & mask ) { dp [ mask ] [ masked ] = Math . min ( Math . max ( dp [ mask ] [ b ] [ masked ] , dp [ mask ] [ b ] [ masked ] ) + 1 ) ; } } } System . out . println ( dp [ 0 ] [ 0 ] ) ; return dp ; }
public static int test ( String input ) { int test = Integer . parseInt ( input ) ; for ( int i = 0 ; i < test ; i ++ ) { String a = input . split ( " ▁ " ) [ 0 ] ; String b = input . split ( " ▁ " ) [ 1 ] ; a = Integer . parseInt ( a ) ; b = Integer . parseInt ( b ) ; int c = ( Math . min ( a , b ) * Math . min ( a , b ) ) * Math . min ( a , b ) ; int d = ( Math . max ( a , b ) * Math . max ( a , b ) ) ; System . out . println ( Math . max ( c , d ) ) ; } return test ; }
public static String getValidString ( String str ) { if ( str == null ) { return null ; } else if ( str . length ( ) == 0 ) { return " " ; } else if ( str . length ( ) == 1 ) { return " " ; } else if ( str . length ( ) == 2 ) { return " " ; } else if ( str . length ( ) == 3 ) { return " " ; } else if ( str . length ( ) == 4 ) { return " " ; } else if ( str . length ( ) == 5 ) { return " " ; } else if ( str . length ( ) == 6 ) { return " " ; } else if ( str . length ( ) == 7 ) { return " " ; } else if ( str . length ( ) == 8 ) { return " " ; } else if ( str . length ( ) == 9 ) { return " " ; } else if ( str . length ( ) == 10 ) { return " " ; } else if ( str . length ( ) == 11 ) { return " " ; } else if ( str . length ( ) == 12 ) { return " " ; } else if ( str . length ( ) == 13 ) { return " " ; } else if ( str . length ( ) == 14 ) { return " " ; } else if ( str . length ( ) == 15 ) { return " " ; } else if ( str . length ( ) == 16 ) { return " " ; } else if ( str . length ( ) == 17 ) { return " " ; } else if ( str . length ( ) == 18 ) { return " " ; } else if ( str . length ( ) == 19 ) { return " " ; } else if ( str . length ( ) == 19 ) { return " " ; } else if ( str . length ( ) == 20 ) { return " " ; } else if ( str . length ( ) == 19 ) { return " " " ; } else if ( str . length ( ) == 20 ) { return " " " ; } else if ( str . length ( ) == 21 ) { return " " " ; } else if ( str . length ( ) == 23 ) { return " " " ; return " " " ; }
public static String evenOrOdd ( String N ) { int l = N . length ( ) ; if ( ( N . charAt ( l - 1 ) == '0' || N . charAt ( l - 1 ) == '2' || N . charAt ( l - 1 ) == '4' || N . charAt ( l - 1 ) == '6' ) ) { return ( " Even " ) ; } else { return ( " Odd " ) ; } return N ; }
public static String [ ] getStrings ( String [ ] strings ) { String [ ] a = new String [ strings . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = Integer . parseInt ( strings [ i ] ) ; } ArrayList < String > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { list . add ( new String [ ] { } ) ; } for ( int i = 0 ; i < a . length ; i ++ ) { int [ ] cmd = new int [ ] { Integer . parseInt ( strings [ i ] ) } ; switch ( cmd [ 0 ] ) { case 0 : list . get ( cmd [ 1 ] ) . add ( cmd [ 2 ] ) ; break ; case 1 : String [ ] maped = list . get ( cmd [ 1 ] ) ; String output = new String ( maped ) ; System . out . println ( output ) ; break ; case 2 : list . get ( cmd [ 1 ] ) . clear ( ) ; } } return list . toArray ( new String [ list . size ( ) ] ) ; }
public static int getPrimeNumber ( String s ) { int [ ] nums = s . split ( " ▁ " ) ; int even = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( Integer . parseInt ( nums [ i ] ) % 2 == 0 ) even ++ ; } if ( even == 1 ) { for ( int i = 0 ; i < nums . length ; i ++ ) { if ( Integer . parseInt ( nums [ i ] ) % 2 == 0 ) System . out . println ( nums [ num . length - i ] + 1 ) ; } } else { for ( int i = 0 ; i < nums . length ; i ++ ) { if ( Integer . parseInt ( nums [ i ] ) % 2 == 1 ) System . out . println ( nums [ num . length - i ] + 1 ) ; } } return nums [ even ] ; }
public static int solve ( String X , String Y , int N , int K ) { int [ ] count = new int [ N + 1 ] ; int sol = 0 ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) count [ i ] = ( count [ i - 1 ] + Math . abs ( ( int ) X . charAt ( i - 1 ) - ( int ) Y . charAt ( i - 1 ) ) ) ; int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { while ( ( ( count [ i ] - count [ j ] ) ) > K ) j ++ ; sol = Math . max ( sol , i - j ) ; } return sol ; }
public static int sum ( int [ ] array ) { int sum = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { sum += array [ i ] ; } return sum ; }
public static boolean isPrime ( int n , int i ) { if ( ( n <= 2 ) ) { return ( n == 2 ) ? true : false ; } if ( ( n % i ) == 0 ) { return false ; } if ( ( i * i ) > n ) { return true ; } return isPrime ( n , i + 1 ) ; } int n = 15 ; if ( ( n ) != 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
public static boolean isPrime ( int n ) { int i = 2 ; while ( ( i * i <= n ) ) { if ( ( n % i ) == 0 ) { return false ; } i ++ ; } return true ; }
public static int isPrime ( int x ) { for ( int i = 2 ; i <= ( int ) Math . sqrt ( x ) ; i ++ ) { if ( ( x % i ) == 0 ) { return 0 ; } } return 1 ; }
public static int snoob ( int x ) { int next = 0 ; if ( ( x != 0 ) ) { int rightOne = x & - ( x ) ; int nextHigherOneBit = x + ( int ) rightOne ; int rightOnesPattern = x ^ ( int ) nextHigherOneBit ; rightOnesPattern = ( ( int ) rightOnesPattern / ( int ) rightOne ) ; rightOnesPattern = ( ( int ) rightOnesPattern ) >> 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
public static int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = n + 1 ; ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j * j > i ) break ; if ( ( i % j ) == 0 ) { if ( ( i / j ) == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
public static int getMinLength ( int [ ] arr , int n ) { int count = 0 ; int result = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] == 1 ) ) { count ++ ; } else { if ( ( count != 0 ) ) { result = Math . min ( result , count ) ; } count = 0 ; } } return result ; }
public static int getLevenstein ( String inpt ) { String revInput = inpt . substring ( 0 , inpt . length ( ) - 1 ) ; int n = inpt . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( inpt . charAt ( i - 1 ) == revInput . charAt ( j - 1 ) ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } int res = INT_MAX ; int i = 0 , j = 0 ; while ( i >= 0 ) { res = Math . min ( res , dp [ i ] [ j ] ) ; if ( i < n ) { res = Math . min ( res , dp [ i + 1 ] [ j ] ) ; } if ( i > 0 ) { res = Math . min ( res , dp [ i - 1 ] [ j ] ) ; } i -- ; j ++ ; } return res ; }
public static String compute ( ) { final int LIMIT = 12000 ; final int [ ] minsumproduct = new int [ LIMIT + 1 ] ; Arrays . fill ( minsumproduct , null ) ; for ( int i = 0 ; i < maxfactor ; i ++ ) { if ( remain == 1 ) { if ( sum > n ) { throw new AssertionError ( ) ; } terms += n - sum ; if ( terms <= LIMIT && ( minsumproduct [ terms ] == null || n < minsumproduct [ terms ] ) ) { minsumproduct [ terms ] = n ; } } else { for ( int j = 2 ; j <= maxfactor ; j ++ ) { if ( remain % j == 0 ) { int factor = j ; factorize ( i , remain / factor , Math . min ( factor , maxfactor ) , sum + factor , terms + 1 ) ; } } } } for ( int i = 2 ; i <= LIMIT * 2 ; i ++ ) { factorize ( i , i , i , 0 , 0 ) ; } int ans = Arrays . stream ( minsumproduct ) . reduce ( 0 , ( x , y ) -> x + y ) ; return String . valueOf ( ans ) ; }
public static int [ ] getNegativeInstances ( ) { int [ ] a = new int [ N + 1 ] , factInv = new int [ N + 1 ] , inv = new int [ N + 1 ] ; Arrays . fill ( a , 0 ) ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact [ i ] = fact [ i - 1 ] * i % MOD ; } factInv [ N ] = Math . pow ( fact [ N ] , MOD - 2 , MOD ) ; for ( int i = N - 1 ; i > 0 ; i -- ) { factInv [ i ] = factInv [ i + 1 ] * ( i + 1 ) % MOD ; } for ( int i = 1 ; i <= N ; i ++ ) { inv [ i ] = factInv [ i ] * fact [ i - 1 ] % MOD ; } int [ ] b = new int [ N + 1 ] , s = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { s [ i ] = ( s [ i - 1 ] + inv [ i ] ) % MOD ; } for ( int i = 0 ; i < N ; i ++ ) { b [ i ] = ( s [ i + 1 ] + s [ N - i ] - 1 ) % MOD ; } int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ans = ( ans + a [ i ] * b [ i ] ) % MOD ; } ans = ans * fact [ N ] % MOD ; System . out . println ( ans ) ; if ( Thread . currentThread ( ) . isInterrupted ( ) ) { Thread . currentThread ( ) . getStackTrace ( ) ; } return b ; }
public static final void reverseQueue ( final int [ ] q ) { final int [ ] items = new int [ q . length ] ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; Arrays . fill ( items , ( int ) - 1 ) ; }
public static int findDiff ( int [ ] arr , int n ) { int [ ] prime = new int [ MAX + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 1 ] = false ; int p = 2 ; int c = 0 ; while ( ( p * p <= MAX ) ) { c ++ ; if ( ( prime [ p ] == true ) ) { for ( int i = p * 2 ; i <= MAX && i < p ; i += p ) { prime [ i ] = false ; } } p ++ ; } return ( max == - 1 ) ? - 1 : ( max - min ) ; }
public static int indexOf ( int x , int [ ] parArr ) { if ( parArr [ x ] == x ) { return x ; } int root = indexOf ( parArr [ x ] , parArr ) ; parArr [ x ] = root ; return root ; }
public static int [ ] getNegativeInstances ( ) { int [ ] array = new int [ 371 ] ; int p , q ; int count = 0 ; for ( int i = 1 ; i <= 371 ; i ++ ) { array [ i ] = i ; } if ( count == 1 ) { array [ 0 ] = i ; } if ( count == 2 ) { array = new int [ 2 ] ; while ( q != 0 ) { int x = q % 10 ; q /= 10 ; array [ i ] = x ; } array = array . clone ( ) ; } if ( count == 3 ) { array = new int [ 2 ] ; while ( q != 0 ) { int x = q % 10 ; q /= 10 ; array [ i ] = x ; } array = array . clone ( ) ; } return array ; }
public static int distinctSubstring ( String P , int N ) { Map < String , Integer > S = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { boolean [ ] freq = new boolean [ 26 ] ; String s = " " ; for ( int j = i ; j < N ; j ++ ) { int pos = ( int ) P . charAt ( j ) - ( int ) ' a ' ; if ( ( freq [ pos ] == true ) ) break ; freq [ pos ] = true ; s += P . charAt ( j ) ; S . put ( s , 1 ) ; } } return S . size ( ) ; }
public static int getLargestNumber ( int n , int k ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = a [ i ] ; } return a [ n ] ; }
public static int minimumAdjacentDifference ( int [ ] a , int n , int k ) { final int INT_MAX = Integer . MAX_VALUE ; final int INT_MIN = - ( Integer . MIN_VALUE - 1 ) ; int minDiff = INT_MAX ; for ( int i = 0 ; i < 1 << n ; i ++ ) { int cnt = Integer . toBinaryString ( i ) . indexOf ( '1' ) ; if ( ( cnt == n - k ) ) { int [ ] temp = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i & ( 1 << j ) ) != 0 ) ) { temp [ j ] = a [ j ] ; } } maxDiff = INT_MIN ; for ( int j = 0 ; j < temp . length - 1 ; j ++ ) { maxDiff = Math . max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ; } minDiff = Math . min ( minDiff , maxDiff ) ; } } return minDiff ; }
public static void difference ( int [ ] arr , int n ) { int largest = arr [ 0 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( ( largest < arr [ i ] ) ) { largest = arr [ i ] ; } } for ( i = 0 ; i < n ; i ++ ) { arr [ i ] = largest - arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } if ( Class . forName ( " java . util . Arrays $ ArrayList " ) . equals ( " java . util . Arrays $ ArrayList " ) ) { arr = new int [ ] { 10 , 5 , 9 , 3 , 2 } ; n = arr . length ; difference ( arr , n ) ; }
public static int countKdivPairs ( int [ ] A , int n , int K ) { int [ ] freq = new int [ K ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ A [ i ] % K ] ++ ; } double sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ; int i = 1 ; while ( ( i <= K / 2 ) && ( i != ( K - i ) ) ) { sum += freq [ i ] * freq [ K - i ] ; i ++ ; } if ( ( K % 2 == 0 ) ) { sum += ( freq [ K / 2 ] * ( freq [ K / 2 ] - 1 ) / 2 ) ; } return ( int ) sum ; }
public static String f ( String a ) { for ( char x = ' b ' ; x <= ' w ' ; x ++ ) { if ( a . substring ( 0 , 4 ) . indexOf ( x ) == 3 || a . substring ( 2 , 7 ) . indexOf ( x ) == 3 ) return x ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( a . substring ( i * 3 , i * 3 + 3 ) . indexOf ( x ) == 3 || a . substring ( i , 3 ) . indexOf ( x ) == 3 ) return x ; } } return " NA " ; }
public static int maxOnesIndex ( int [ ] arr , int n ) { int maxCount = 0 ; int maxIndex = 0 ; int prevZero = - 1 ; int prevPrevZero = - 1 ; for ( int curr = 0 ; curr < n ; curr ++ ) { if ( ( arr [ curr ] == 0 ) ) { if ( ( ( curr - prevPrevZero ) > maxCount ) ) { maxCount = curr - prevPrevZero ; maxIndex = prevZero ; } prevPrevZero = prevZero ; prevZero = curr ; } } if ( ( n - prevPrevZero ) > maxCount ) { maxIndex = prevZero ; } return maxIndex ; }
public static int minimumX ( int n , int k ) { int ans = 10 * 18 ; for ( int i = k - 1 ; i > 0 ; i -- ) { if ( n % i == 0 ) { ans = Math . min ( ans , i + ( n / i ) * k ) ; } } return ans ; }
public static int moduloMultiplication ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; while ( ( b ) != 0 ) { if ( ( b & 1 ) != 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; }
public static int searchNode ( int i , int [ ] [ ] u , int [ ] [ ] path ) { int r = 1 ; u [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( path [ i ] [ j ] && ( u [ j ] [ j ] == 0 ) ) { r += searchNode ( j , u , path ) ; } } return r ; while ( ( i = 0 ) != 0 ) { int n = Integer . parseInt ( input ( ) ) ; if ( n == 0 ) break ; List < String > strs = new LinkedList < String > ( ) ; for ( int j = 0 ; j < n ; j ++ ) strs . add ( new String ( new String ( new char [ ] { i , j } ) ) ) ; } int [ ] ss = new int [ 26 ] , ee = new int [ 26 ] ; path = new int [ 27 ] ; u = new int [ 26 ] ; for ( int j = 0 ; j < 27 ; j ++ ) { String s = strs . get ( j ) ; String e = strs . get ( j ) ; ss [ ( int ) s . charAt ( 0 ) - ' a ' ] ++ ; ee [ ( int ) e . charAt ( 0 ) - ' a ' ] ++ ; path [ ( int ) s . charAt ( 0 ) - ' a ' ] [ ( int ) e . charAt ( 0 ) - ' a ' ] ++ ; } if ( Arrays . stream ( ss ) . parallel ( ) . filter ( s1 -> s1 . equals ( e1 ) ) . count ( ) ) { System . out . println ( " NG " ) ; continue ; } System . out . println ( Arrays . stream ( ss ) . filter ( s -> s . length ( ) == searchNode ( ( int ) s . charAt ( 0 ) - ' a ' , u , path ) . count ( ) ) . count ( ) ) ; return r ; }
public static int [ ] getNegativeInstances ( ) { int [ ] a = new int [ 2 ] ; a [ 0 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 1 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 2 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 3 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 4 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 5 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 6 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 7 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 8 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 9 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 10 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 11 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 12 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 13 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 14 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; a [ 15 ] = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; return a ; }
public static boolean checkPalindrome ( String string ) { int length = string . length ( ) ; length -- ; for ( int i = 0 ; i < length ; i ++ ) { if ( string . charAt ( i ) != string . charAt ( length ) ) { return false ; } length -- ; } return true ; }
public static int dp ( int n , int k ) { if ( tbl [ n ] [ k ] != null ) return tbl [ n ] [ k ] ; int ans ; if ( ( k << 1 ) > n ) { k = n - k ; } if ( k == 0 ) ans = 1 ; else if ( k == 1 ) ans = n ; else { ans = dp ( n - 1 , k ) + dp ( n - 1 , k - 1 ) ; tbl [ n ] [ k ] = ans % MOD ; return tbl [ n ] [ k ] ; } tbl = new int [ 1001 ] [ 1001 ] ; for ( int j = 0 ; j < 1001 ; j ++ ) { tbl [ j ] [ j ] = 0 ; } int k = 0 ; int r = Integer . parseInt ( String . valueOf ( System . in ) ) , c = Integer . parseInt ( String . valueOf ( System . in ) ) , a1 = Integer . parseInt ( String . valueOf ( System . in ) ) , a2 = Integer . parseInt ( String . valueOf ( System . in ) ) , b1 = Integer . parseInt ( String . valueOf ( System . in ) ) , b2 = Integer . parseInt ( String . valueOf ( System . in ) ) ; int dr = Math . abs ( a1 - b1 ) ; if ( dr > r - dr ) dr = r - dr ; if ( ( dr << 1 ) == r ) k ++ ; int dc = Math . abs ( a2 - b2 ) ; if ( dc > c - dc ) dc = c - dc ; if ( ( dc << 1 ) == c ) k ++ ; System . out . println ( ( dp ( dr + dc , Math . min ( dr , dc ) ) << k ) % MOD ) ; return k ; }
@ SafeVarargs public static void findSubsequence ( int [ ] arr , int n , int k ) { Map < Integer , Integer > M = new HashMap < > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { M . put ( arr [ i ] , 1 ) ; } int [ ] numCount = new int [ k + 1 ] ; for ( int p : M . keySet ( ) ) { if ( p <= k ) { int i = 1 ; while ( p * i <= k ) { numCount [ p * i ] += M . get ( p ) ; i ++ ; } } else { break ; } } int lcm = 0 , length = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { if ( numCount [ i ] > length ) { length = numCount [ i ] ; lcm = i ; } } if ( lcm == 0 ) { System . out . println ( - 1 ) ; } else { System . out . println ( " LCM ▁ = ▁ " + lcm + " , ▁ Length ▁ = ▁ " + length ) ; System . out . print ( " Indexes ▁ = ▁ " ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( lcm % arr [ i ] == 0 ) { System . out . print ( i + " ▁ " ) ; } } } if ( String . valueOf ( arr [ n ] ) . toUpperCase ( ) . equals ( " " ) ) { k = 14 ; arr = Arrays . asList ( 2 , 3 , 4 , 5 ) ; n = arr . length ; findSubsequence ( arr , n , k ) ; } }
public static int countPairs ( int [ ] a , int [ ] b , int n , int m ) { int odd1 = 0 ; int even1 = 0 ; int odd2 = 0 ; int even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] % 2 ) == 1 ) { odd1 ++ ; } else { even1 ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( ( b [ i ] % 2 ) == 1 ) { odd2 ++ ; } else { even2 ++ ; } } int pairs = Math . min ( odd1 , odd2 ) + Math . min ( even1 , even2 ) ; return pairs ; }
public static int countPairs ( int [ ] a , int [ ] b , int n , int m ) { int odd1 = 0 ; int even1 = 0 ; int odd2 = 0 ; int even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] % 2 ) != 0 ) { odd1 ++ ; } else { even1 ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( ( b [ i ] % 2 ) != 0 ) { odd2 ++ ; } else { even2 ++ ; } } int pairs = ( Math . min ( odd1 , even2 ) + Math . min ( odd2 , even1 ) ) ; return pairs ; }
public static int maxDiff ( int [ ] arr , int arrSize ) { int maxDiff = arr [ 1 ] - arr [ 0 ] ; int minElement = arr [ 0 ] ; for ( int i = 1 ; i < arrSize ; i ++ ) { if ( ( arr [ i ] - minElement ) > maxDiff ) { maxDiff = arr [ i ] - minElement ; } if ( ( arr [ i ] < minElement ) ) { minElement = arr [ i ] ; } } return maxDiff ; arr = Arrays . asList ( 1 , 2 , 6 , 80 , 100 ) ; int size = arr . length ; System . out . println ( " Maximum ▁ difference ▁ is " + maxDiff ( arr , size ) ) ; return size ; }
public static int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = Math . min ( i , k ) + 1 ; j <= Math . min ( i , k ) ; j ++ ) { if ( ( j == 0 ) || ( j == i ) ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } } return C [ n ] [ k ] ; }
public static int minimumAddition ( String str1 , int Len ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < Len ; i ++ ) { freq [ ( int ) str1 . charAt ( i ) - ( int ) ' a ' ] ++ ; } int maxFreq = Collections . max ( freq ) ; int minAddition = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( ( freq [ i ] > 0 ) ) { minAddition += Math . abs ( maxFreq - freq [ i ] ) ; } } return minAddition ; str1 = " geeksforgeeks " ; Len = str1 . length ( ) ; System . out . println ( minimumAddition ( str1 , Len ) ) ; return 0 ; }
public static int getDistance ( int [ ] a , int [ ] b ) { int distance = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { distance += a [ i ] * b [ i ] ; } return distance ; }
public static int [ ] solve ( int n , int k ) { int n = 32 ; int k = 5 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( i > 0 ) { n = i ; k = i ; } else if ( i < MAX ) { k = i ; } else if ( i < MAX ) { k = i ; } else if ( i < MAX ) { k = i ; } else if ( i < MAX ) { k = i ; } else if ( i < MAX ) { k = i ; } else { k = i ; } else if ( i < MAX ) { k = i ; } else { k = i ; } else if ( k == 0 ) { k = i ; } else { k = i ; } else { k = i ; } } else { k = i ; } if ( k == 1 ) { k = i ; } else if ( k == 2 ) { k = i ; } else if ( k == 3 ) { k = i ; } else if ( k == 4 ) { k = i ; } else if ( k == 5 ) { k = i ; } else if ( k == 6 ) { k = i ; } else if ( k == 7 ) { k = i ; } else if ( k == 8 ) { k = i ; } else if ( k == 9 ) { k = i ; } else if ( k == 10 ) { k = i ; } else if ( k == 11 ) { k = i ; } else if ( k == 12 ) { k = i ; } else if ( k == 13 ) { k = i ; } else if ( k == 14 ) { k = i ; } else if ( k == 15 ) { k = i ; } else if ( k == 15 ) { k = i ; } else if ( k == 16 ) { k = i ; } else if ( k == 17 ) { k = i ; } else if ( k == 18 ) { k = i ; } else if ( k == 19 ) { k = i ; } else if ( k == 19 ) { k = i ; } else if ( k == 20 ) { k = i ; } else if ( k == 21 ) { k = i ; } else if ( k == 23 ) { k = i ; } else if ( k == 23 ) { k = i ; } return k ; }
public static String compute ( ) { final String [ ] ans = Collections . max ( ( new String [ ] { " a " , " b " } ) , new String [ ] { " a " , " b " } ) ; Arrays . sort ( ans ) ; return String . valueOf ( ans [ 0 ] * ans [ 1 ] ) ; }
public static void pratyush ( ) { for ( int i = 0 ; i < Integer . parseInt ( System . getProperty ( " pratyush " ) ) ; i ++ ) { int n = Integer . parseInt ( System . getProperty ( " pratyush " ) ) ; int r = Integer . parseInt ( System . getProperty ( " pratyush " ) ) ; int a = Math . min ( r , n - 1 ) ; int ans = ( int ) ( ( a * ( a + 1 ) ) / 2 ) ; if ( a != r ) { ans ++ ; } System . out . println ( ans ) ; } }
public static int findSubset ( int [ ] a , int n ) { final int MAX = 100001 ; final int [ ] isPrime = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { isPrime [ i ] = 0 ; } int [ ] A = new int [ n ] ; for ( int i = 0 ; i < A . length ; i ++ ) { A [ i ] = i ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( isPrime [ i ] == 0 ) ) { for ( int j = 2 * j ; j < MAX ; j += p ) { isPrime [ j ] = 1 ; } } } return A [ n ] ; }
public static int [ ] getPoints ( int [ ] points ) { int [ ] speed = new int [ points . length ] ; for ( int i = 0 ; i < points . length ; i ++ ) { speed [ i ] = Integer . parseInt ( points [ i ] ) ; } Arrays . sort ( speed ) ; for ( int i = 0 ; i < points . length ; i ++ ) { point [ i ] = 0 ; } int [ ] bottle = new int [ r ] ; for ( int i = 0 ; i < points . length ; i ++ ) { for ( int j = 0 ; j < points [ i ] ; j ++ ) { bottle [ i ] = points [ i ] ; } } for ( int i = 0 ; i < points . length ; j ++ ) { int [ ] nums = new int [ r ] ; for ( int j = 0 ; j < points . length ; j ++ ) { if ( bottle [ i ] < nums [ j ] ) { bottle [ i ] = nums [ j ] ; } bottle [ i ] += nums [ j ] ; } } return bottle ; }
public static int getRandom ( ) { int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( System . getProperty ( " line . separator " ) . replace ( " Hoshino " , " Hoshina " ) ) ; } return n ; }
static int countRotations ( int [ ] arr , int low , int high ) { if ( ( high < low ) ) { return 0 ; } if ( ( high == low ) ) { return low ; } int mid = low + ( high - low ) / 2 ; int i = ( int ) mid ; if ( ( mid < high ) && ( arr [ mid + 1 ] < arr [ mid ] ) ) { return ( mid + 1 ) ; } if ( ( mid > low ) && ( arr [ mid ] < arr [ mid - 1 ] ) ) { return mid ; } if ( ( arr [ high ] > arr [ mid ] ) ) { return countRotations ( arr , low , mid - 1 ) ; } return countRotations ( arr , mid + 1 , high ) ; }
public static int getLargestIndex ( int [ ] array ) { int i = 0 ; for ( int j = 0 ; j < array . length ; j ++ ) { if ( array [ j ] == array [ j ] ) { i ++ ; } } return i ; }
public static boolean modularSum ( int [ ] arr , int n , int m ) { if ( ( n > m ) ) return true ; boolean [ ] DP = new boolean [ m ] ; for ( int i = 0 ; i < m ; i ++ ) DP [ i ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( DP [ 0 ] ) ) return true ; boolean [ ] temp = new boolean [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( DP [ j ] ) == true ) { if ( ( DP [ ( j + arr [ i ] ) % m ] ) == false ) { temp [ ( j + arr [ i ] ) % m ] = true ; } } } for ( int j = 0 ; j < m ; j ++ ) { if ( ( temp [ j ] ) ) DP [ j ] = true ; } DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; } arr = new int [ ] { 1 , 7 } ; n = arr . length ; m = 5 ; return ( ( modularSum ( arr , n , m ) ) ) ? true : false ; }
public static int getDistance ( String value , int min , int max ) { if ( value == null ) { return min ; } if ( value == null ) { return max ; } if ( value == null ) { return min ; } if ( value == null ) { return max ; } if ( value == null ) { return min ; } if ( value == null ) { return max ; } if ( value == null ) { return max ; } return min ; }
public static int [ ] getNegativeInstances ( ) { int [ ] [ ] A = new int [ ] [ ] ; for ( int i = 0 ; i < A . length ; i ++ ) { A [ i ] = Integer . parseInt ( String . valueOf ( A [ i ] [ i ] ) ) ; } int INF = ( 1 << 42 ) - 1 ; int [ ] [ ] cum = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j ++ ) { cum [ i ] [ j ] = Math . min ( cum [ i ] [ j - 1 ] , A [ j ] ) ; } } int ans = INF ; for ( int k = 0 ; k < N ; k ++ ) { int score = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( j - k >= 0 ) { score += cum [ j - k ] [ j ] ; } else { score += Math . min ( cum [ 0 ] [ j ] , cum [ ( j - k ) % N ] [ N - 1 ] ) ; } } ans = Math . min ( ans , k * x + score ) ; } return ans ; }
public static int getPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalForPropositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalForPropositionalpositionalpositionalpositionalForPropositionalpositionalpositionalpositionalpositionalpositionalpositionalpositionalFor
public static int [ ] getNum ( String input , int k ) { int [ ] arr = new int [ input . length ( ) ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; } HashSet < Integer > different = new HashSet < > ( ) ; int temp = 0 ; Arrays . sort ( arr ) ; for ( int x : arr ) { if ( ( x % k != 0 ) || ! different . contains ( x / k ) ) { different . add ( x ) ; } temp = Math . max ( different . size ( ) , temp ) ; } return different . toArray ( ) ; }
public static int sum ( int k , int n ) { int sum = ( Math . pow ( k , n + 1 ) - Math . pow ( k - 1 , n + 1 ) ) ; return sum ; }
public static int solve ( int i , boolean tight , int sumSoFar , int Sum , String number , int length ) { if ( i == length ) { if ( sumSoFar == Sum ) return 1 ; else return 0 ; } int ans = dp [ i ] [ tight ] [ sumSoFar ] ; if ( ans != - 1 ) return ans ; ans = 0 ; for ( int currdigit = 0 ; ; currdigit ++ ) { String currdigitstr = String . valueOf ( currdigit ) ; if ( tight == 0 && currdigitstr . compareTo ( number . charAt ( i ) ) > 0 ) break ; boolean ntight = tight || currdigitstr . compareTo ( number . charAt ( i ) ) < 0 ; boolean nsumSoFar = sumSoFar + currdigit ; ans += solve ( i + 1 , ntight , nsumSoFar , Sum , number , length ) ; } return ans ; }
public static int total ( int numCases ) { int numCases = Integer . parseInt ( System . getProperty ( " line . number " ) ) ; for ( int i = 0 ; i < numCases ; i ++ ) { String line = System . getProperty ( " line . number " ) ; if ( Integer . parseInt ( line ) >= 2 ) { total ++ ; } } return total ; }
public static int evenOddLevelDifference ( int root ) { if ( ( root == 0 ) ) { return 0 ; } ArrayList < Integer > q = new ArrayList < > ( ) ; q . add ( root ) ; int level = 0 ; int evenSum = 0 ; int oddSum = 0 ; while ( ( q . size ( ) ) > 0 ) { int size = q . size ( ) ; level ++ ; while ( ( size > 0 ) ) { int temp = q . get ( 0 ) ; q . remove ( 0 ) ; if ( ( level % 2 == 0 ) ) { evenSum += temp . data ; } else { oddSum += temp . data ; } if ( ( temp . left ) != null ) { q . add ( temp . left ) ; } if ( ( temp . right ) != null ) { q . add ( temp . right ) ; } size -- ; } } return ( oddSum - evenSum ) ; } if ( String . valueOf ( root ) . equals ( " " ) ) { root = new Integer ( 5 ) ; root . left = new Integer ( 2 ) ; root . right = new Integer ( 6 ) ; root . left . left = new Integer ( 1 ) ; root . left . right = new Integer ( 4 ) ; root . left . right . left = new Integer ( 3 ) ; root . right . right = new Integer ( 8 ) ; root . right . right = new Integer ( 9 ) ; root . right . left = new Integer ( 7 ) ; int result = evenOddLevelDifference ( root ) ; System . out . println ( " Difference ▁ between ▁ sums ▁ is " + result ) ; return result ; }
static int countSubarrays ( int [ ] a , int n , int x ) { int count = 0 ; int number = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] > x ) ) { count ++ ; } else { number += ( count ) * ( count + 1 ) / 2 ; count = 0 ; } } if ( ( count ) != 0 ) { number += ( count ) * ( count + 1 ) / 2 ; } return ( int ) number ; }
public static int minCost ( int [ ] arr , int n ) { int countEven = 0 ; int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 ) == 0 ) { countEven ++ ; } else { countOdd ++ ; } } return Math . min ( countEven , countOdd ) ; }
static void printLastOccurrence ( int [ ] a , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < 7 ; i ++ ) { mp . put ( i , 0 ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( mp . get ( a [ i ] ) ) == i ) { System . out . print ( a [ i ] + " ▁ " ) ; } } if ( Class . isPrimitive ( String . class ) ) { a = new int [ ] { 1 , 5 , 5 , 1 , 6 , 1 } ; n = a . length ; printLastOccurrence ( a , n ) ; } }
public static void doSearch ( String input ) { int n = Integer . parseInt ( input ) ; if ( n == 0 ) { break ; } List < Integer > s = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( Integer . parseInt ( input ) ) ; } if ( Math . max ( s . size ( ) , 2 ) < 2 ) { System . out . println ( " NA " ) ; } else { int t = s . stream ( ) . filter ( i -> i >= 0 ) . count ( ) ; System . out . println ( n - t + 1 ) ; } }
static int countPaths ( int m , int n ) { if ( m == 1 || n == 1 ) { return 1 ; } return ( countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ) ; }
public static double sumOfAP ( double a , double d , int n ) { double sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
public static int countPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] ) { count ++ ; } } } return count ; }
public static int coordinateCompression ( int [ ] arr , int n ) { Map < Integer , Integer > s = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . put ( arr [ i ] , 1 ) ; } int index = 0 ; Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( Iterator < Integer > itr = s . values ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { index += 1 ; mp . put ( itr . next ( ) , index ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = mp . get ( arr [ i ] ) ; } return ans ; }
public static int getDistance ( int [ ] arr ) { int [ ] [ ] a = new int [ arr . length ] [ arr [ 0 ] . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { a [ i ] [ i ] = arr [ i ] [ 0 ] ; } for ( int j = 0 ; j < arr . length ; j ++ ) { a [ i ] [ j ] = arr [ i ] [ j ] ; } boolean ans = false ; for ( int j = 0 ; j < 5 ; j ++ ) { for ( int k = 0 ; k < 5 ; k ++ ) { if ( k != j ) { int cnt1 = 0 ; int cnt2 = 0 ; int cntno = 0 ; for ( int z = 0 ; z < arr . length ; z ++ ) { if ( a [ z ] [ j ] == 1 ) { cnt1 ++ ; } if ( a [ z ] [ k ] == 1 ) { cnt2 ++ ; } if ( a [ z ] [ j ] == 0 && a [ z ] [ k ] == 0 ) { cntno ++ ; } } if ( cnt1 >= arr [ n ] . length / 2 && cnt2 >= arr [ n ] . length / 2 && cntno == 0 ) { ans = true ; } } } } if ( ans ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } return ans ? 0 : 1 ; }
public static String compute ( ) { final int BASE = 10 ; final int DIGITS = 20 ; final int CONSECUTIVE = 3 ; final int MAX_SUM = 9 ; int innerlen = BASE * CONSECUTIVE ; int [ ] [ ] ways = new int [ innerlen ] [ ] ; ways [ 0 ] [ 0 ] = 1 ; ways [ 0 ] [ 1 ] = 0 ; for ( int digits = 1 ; digits <= DIGITS ; digits ++ ) { int [ ] newrow = new int [ innerlen ] [ ] ; for ( int prefix = 0 ; prefix < innerlen ; prefix ++ ) { int sum = 0 ; if ( DigitSum ( prefix ) <= MAX_SUM ) { for ( int nextdigit = 0 ; nextdigit < BASE ; nextdigit ++ ) { sum += ways [ digits - 1 ] [ prefix % ( BASE * ( CONSECUTIVE - 1 ) ) * BASE + nextdigit ] ; } } newrow [ prefix ] [ prefix ] = sum ; } ways [ digits ] [ 0 ] = newrow ; } int ans = ways [ ways . length - 1 ] [ 0 ] - ways [ ways . length - 2 ] [ 0 ] ; return String . valueOf ( ans ) ; }
public static String getStrFromString ( String str ) { if ( str == null ) { return null ; } if ( str . length ( ) == 0 ) { return " " ; } if ( str . length ( ) == 1 ) { return " " ; } if ( str . length ( ) == 2 ) { return " " ; } if ( str . length ( ) == 3 ) { return " " ; } if ( str . length ( ) == 4 ) { return " " ; } if ( str . length ( ) == 5 ) { return " " ; } if ( str . length ( ) == 6 ) { return " " ; } if ( str . length ( ) == 7 ) { return " " ; } if ( str . length ( ) == 8 ) { return " " ; } if ( str . length ( ) == 9 ) { return " " ; } if ( str . length ( ) == 10 ) { return " " ; } if ( str . length ( ) == 11 ) { return " " ; } if ( str . length ( ) == 12 ) { return " " ; } if ( str . length ( ) == 13 ) { return " " ; } if ( str . length ( ) == 14 ) { return " " ; } if ( str . length ( ) == 15 ) { return " " ; } if ( str . length ( ) == 16 ) { return " " ; } if ( str . length ( ) == 17 ) { return " " ; } if ( str . length ( ) == 18 ) { return " " ; } if ( str . length ( ) == 19 ) { return " " ; } if ( str . length ( ) == 19 ) { return " " ; } if ( str . length ( ) == 19 ) { return " " ; } if ( str . length ( ) == 20 ) { return " " ; } if ( str . length ( ) == 21 ) { return " " ; } if ( str . length ( ) == 22 ) { return " " ; } if ( str . length ( ) == 23 ) { return " " ; } return str . substring ( 0 , 3 ) ; if ( str . length ( ) == 23 ) { return " " " ; } return str . substring ( 0 , 3 ) ; }
public static boolean isToeplitzMatrix ( int [ ] [ ] matrix ) { if ( matrix . length == 0 ) { return true ; } if ( matrix [ 0 ] . length == 1 ) { int [ ] [ ] matrix = matrix [ 0 ] ; for ( int i = 0 ; i < matrix . length ; i ++ ) { for ( int j = 0 ; j < matrix [ i ] . length ; j ++ ) { if ( matrix [ i ] [ j ] != matrix [ i ] [ j ] ) { return false ; } } } return true ; } if ( matrix . length == 1 ) { int [ ] [ ] matrix = matrix [ 0 ] ; for ( int j = 0 ; j < matrix . length ; j ++ ) { if ( matrix [ i ] [ j ] != matrix [ j ] [ j ] ) { return false ; } } return true ; } return false ; }
public static String compute ( ) { final int LIMIT = 10 * 9 ; int ans = 0 ; for ( int s = 1 ; ; s ++ ) { if ( s * s > ( LIMIT + 1 ) / 3 ) break ; for ( int t = s - 2 ; t > 0 ; t -- ) { if ( Math . gcd ( s , t ) == 1 ) { int a = s * t ; int b = ( s * s - t * t ) / 2 ; int c = ( s * s + t * t ) / 2 ; if ( a * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) ans += p ; } } if ( a * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) ans += p ; } if ( b * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) ans += p ; } } if ( b * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) ans += p ; } } return String . valueOf ( ans ) ; }
public static void solve ( String [ ] args ) { int n , t , L , b ; for ( String s : args ) { if ( ( n = Integer . parseInt ( s ) ) == ( t = Integer . parseInt ( s ) ) ) { break ; } else { L = Integer . parseInt ( s ) ; b = Integer . parseInt ( s ) ; } } if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = Integer . parseInt ( l ) ) == ( b = 0 ) ) { break ; } else if ( ( L = 0 ) == 0 ) { break ; } else if ( ( L = 0 ) == 0 ) { break ; } else if ( ( L = 0 ) ) { break ; } else { break ; } else
public static String getOneString ( String input ) { if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; } else if ( input . contains ( " - " ) ) { return " - " ; }
public static int minInsertions ( int [ ] H , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; if ( ( diff <= K ) ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; } return inser ; }
static int countWords ( String str , int l ) { int count = 1 ; if ( ( l == 1 ) ) { return count ; } if ( ( str . charAt ( 0 ) == str . charAt ( 1 ) ) ) { count *= 1 ; } else { count *= 2 ; } for ( int j = 1 ; j < l - 1 ; j ++ ) { if ( ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) ) { count *= 1 ; } else if ( ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) ) { count *= 2 ; } else { count *= 3 ; } } if ( ( str . charAt ( l - 1 ) == str . charAt ( l - 2 ) ) ) { count *= 1 ; } else { count *= 2 ; } return count ; }
public static int getLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowestLowest
public static int [ ] getPerfectSquares ( int n ) { int [ ] perfectSquares = new int [ n ] ; int current = 1 ; int i = 1 ; while ( ( current <= n ) ) { perfectSquares [ 0 ] = current ; i ++ ; current = ( int ) Math . pow ( i , 2 ) ; } return perfectSquares ; }
static double findHypotenuse ( double side1 , double side2 ) { double h = ( ( ( side1 * side1 ) + ( side2 * side2 ) ) * ( 1 / 2 ) ) ; return h ; }
static void printTwoOdd ( int [ ] arr , int size ) { int xor2 = arr [ 0 ] ; int setBitNo = 0 ; int n = size - 2 ; int x = 0 , y = 0 ; for ( int i = 1 ; i < size ; i ++ ) { xor2 = xor2 ^ arr [ i ] ; } setBitNo = xor2 & ~ ( xor2 - 1 ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & setBitNo ) != 0 ) { x = x ^ arr [ i ] ; } else { y = y ^ arr [ i ] ; } } System . out . println ( " The ▁ two ▁ ODD ▁ elements ▁ are " + x + " & " + y ) ; arr = new int [ ] { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arrSize = arr . length ; printTwoOdd ( arr , arrSize ) ; }
public static double solve ( int n , String [ ] nums ) { int maxIndex = nums . indexOf ( Math . max ( nums . length , 0 ) ) ; int minIndex = nums . indexOf ( Math . min ( nums . length , 0 ) ) ; double ans = Double . parseDouble ( " INF " ) ; ans = Math . min ( ans , Math . max ( maxIndex , minIndex ) + 1 ) ; ans = Math . min ( ans , n - Math . min ( maxIndex , minIndex ) ) ; ans = Math . min ( ans , maxIndex + 1 + n - minIndex ) ; ans = Math . min ( ans , minIndex + 1 + n - maxIndex ) ; return ans ; int t = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; for ( int T = 0 ; T < t ; T ++ ) { n = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; nums = Arrays . stream ( nums ) . map ( Integer :: parseInt ) . collect ( Collectors . joining ( " ▁ " ) ) ; } System . out . println ( solve ( n , nums ) ) ; return 0 ; }
public static final String getDelimiter ( String s ) { int [ ] delimiters = s . split ( " [ , ] " ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < delimiters . length ; i ++ ) { sb . append ( delimiters [ i ] ) ; } return sb . toString ( ) ; }
public static String getSpisok ( String [ ] spisok ) { int kolvomest = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int k = 0 ; String [ ] spisok = new String [ spisok . length ] ; for ( int stroka = 0 ; stroka < kolvomest ; stroka ++ ) { String ryad = System . console ( ) . readLine ( ) ; if ( ryad . contains ( " OO " ) && k == 0 ) { k = 1 ; ryad = ryad . replace ( " OO " , " + + " , 1 ) ; } spisok [ stroka ] = ryad ; } if ( k == 1 ) { System . out . println ( " YES " ) ; for ( int stroka = 0 ; stroka < kolvomest ; stroka ++ ) { System . out . println ( spisok [ stroka ] ) ; } } else { System . out . println ( " NO " ) ; } return spisok [ 0 ] ; }
public static int deleteK ( int headRef , int x ) { int head = headRef ; int temp = new Integer ( x ) ; if ( ( head == 0 ) ) { return 0 ; } temp = head ; System . out . print ( temp . data + " - > " ) ; temp = temp . intValue ( ) ; while ( ( temp = temp ) != head ) { System . out . print ( temp . data + " - > " ) ; temp = temp . intValue ( ) ; } System . out . println ( head . data ) ; }
public static double steps ( int cur , int x , int n ) { if ( x == 0 ) { return Double . MAX_VALUE ; } else if ( x > 0 ) { return Math . abs ( ( n - cur ) / x ) ; } else { return Math . abs ( ( int ) ( ( cur - 1 ) / x ) ) ; } }
public static int getProfession ( int [ ] pds ) { int [ ] profession = new int [ pds . length ] ; for ( int i = 0 ; i < pds . length ; i ++ ) { profession [ i ] = pds [ i ] ; } return profession [ pds . length - 1 ] ; }
public static int cntSubArr ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int currGcd = 0 ; for ( int j = i ; j < n ; j ++ ) { currGcd = Math . gcd ( currGcd , arr [ j ] ) ; ans += ( currGcd == 1 ) ; } } return ans ; }
public static boolean isVowel ( char c ) { if ( ( c == ' a ' ) || ( c == ' e ' ) || ( c == ' i ' ) || ( c == ' o ' ) || ( c == ' u ' ) ) { return true ; } return false ; }
public static int minStepToDeleteString ( String str ) { int N = str . length ( ) ; int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < N ; y ++ ) { dp [ x ] [ y ] = 0 ; } } for ( int l = 1 ; l <= N ; l ++ ) { int i = 0 ; int j = l - 1 ; while ( j < N ) { if ( ( l == 1 ) ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( ( str . charAt ( i ) == str . charAt ( i + 1 ) ) ) { dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; } for ( int K = i + 2 ; K <= j ; K ++ ) { if ( ( str . charAt ( i ) == str . charAt ( K ) ) ) { dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } } i ++ ; j ++ ; } return dp [ 0 ] [ N - 1 ] ; }
public static void sieve ( ) { int limit = 1000000 ; int [ ] position = new int [ limit + 1 ] ; int i ; int n ; position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; pos = 0 ; for ( i = 2 ; i <= limit ; i ++ ) { if ( ( position [ i ] == 0 ) ) { pos ++ ; position [ i ] = pos ; for ( j = i * 2 ; j <= limit ; j += i ) { position [ j ] = - 1 ; } } } if ( Class . forName ( " java . lang . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation . annotation
public static int getNumMonotone ( int ln ) { int [ ] [ ] DP = new int [ DP_s ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; i ++ ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 0 ; i < ln ; i ++ ) DP [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < ln ; i ++ ) { for ( int j = 1 ; j < DP_s ; j ++ ) DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; } return DP [ ln - 1 ] [ DP_s - 1 ] ; }
public static int getNumMonotone ( int ln ) { int [ ] [ ] DP = new int [ DP_s ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; i ++ ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 0 ; i < ln ; i ++ ) DP [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < ln ; i ++ ) { for ( int j = 1 ; j < DP_s ; j ++ ) DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; } return DP [ ln - 1 ] [ DP_s - 1 ] ; }
public static int maxCost ( int [ ] a , int n , int l , int r ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mx = Math . max ( mx , a [ i ] ) ; } int [ ] count = new int [ mx + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ a [ i ] ] ++ ; } int [ ] res = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { int k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
public static boolean test ( ) { int nrow = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int ncol = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int [ ] [ ] arr = new int [ nrow ] [ ncol ] ; long val = 1000000000L ; int lr = 0 , lc = 0 ; for ( int rowId = 0 ; rowId < nrow ; rowId ++ ) { String [ ] temp = System . getProperty ( " line . separator " ) . split ( " ▁ " ) ; arr [ rowId ] [ col ] = new int [ col ] ; for ( int colId = 0 ; colId < ncol ; colId ++ ) { if ( temp [ colId ] . equals ( " R " ) ) { int temp2 = rowId + colId ; arr [ rowId ] [ col ] = temp2 ; if ( temp2 < val ) { val = temp2 ; lr = rowId ; lc = colId ; } } } else { arr [ rowId ] [ col ] = 0 ; } } for ( int i = 0 ; i < lr ; i ++ ) { int [ ] temp = arr [ i ] ; if ( Math . max ( temp [ col ] , 0 ) > 0 ) { return false ; } } for ( int i = 0 ; i < nrow ; i ++ ) { for ( int j = 0 ; j < lc ; j ++ ) { if ( arr [ i ] [ j ] > 0 ) { return false ; } } } return true ; }
public static double findArea ( double r ) { double PI = 3.142 ; return PI * ( r * r ) ; }
public static int [ ] getHowToPa ( int [ ] pa ) { int [ ] pa = new int [ pa . length ] ; for ( int i = 0 ; i < pa . length ; i ++ ) { pa [ i ] = pa [ i ] ; pa [ i ] = pa [ i ] ; } pa [ pa . length ] = pa [ pa . length ] ; for ( int i = pa . length ; i < pa . length ; i ++ ) { pa [ pa . length - i ] = pa [ pa . length - i ] ; pa [ pa . length - i ] = pa [ pa . length - i ] ; pa [ pa . length - i ] = pa [ pa . length - i ] ; pa [ pa . length - i ] = pa [ pa . length - i ] ; } pa [ pa . length - i ] = pa [ pa . length - i ] ; pa [ pa . length - i ] = pa [ pa . length - i ] ; pa [ pa . length - i ] = pa [ pa . length - i ] ; pa [ pa . length - i ] = pa [ pa . length - i ] ; } return pa ; }
public static int nthTerm ( int N ) { return ( Math . abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) ) ; if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { N = 6 ; System . out . println ( nthTerm ( N ) ) ; } return 0 ; }
public static int getHeight ( int X ) { return ( 2 * X ) ; if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { X = 35 ; System . out . println ( getHeight ( X ) ) ; } return 0 ; }
public static int countwalks ( int [ ] [ ] graph , int u , int v , int k ) { if ( ( k == 0 ) && ( u == v ) ) return 1 ; if ( ( k == 1 ) && ( graph [ u ] [ v ] ) ) return 1 ; if ( ( k <= 0 ) ) return 0 ; int count = 0 ; for ( int i = 0 ; i <= V ; i ++ ) { if ( ( graph [ u ] [ i ] == 1 ) ) count += countwalks ( graph , i , v , k - 1 ) ; } return count ; }
public static int findDigits ( int n , int b ) { if ( ( n < 0 ) ) { return 0 ; } final double M_PI = 3.141592 ; final double M_E = 2.7182 ; if ( ( n <= 1 ) ) { return 1 ; } double x = ( ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( Math . log10 ( b ) ) ; return Math . floor ( x ) + 1 ; }
public static int bit ( ) { int N ; int [ ] bit = new int [ N + 1 ] ; int x ; int ret ; int [ ] ret ; for ( int i = 0 ; i < N ; i ++ ) { x = i ; while ( x <= N ) { bit [ x ] += w ; x += x & - x ; } } for ( int i = 0 ; i < N ; i ++ ) { ret = 0 ; x = i ; while ( x > 0 ) { ret += bit [ x ] ; x -= x & - x ; } } return ret ; for ( int i = 0 ; i < N ; i ++ ) { ret = 0 ; x = i ; while ( x > 0 ) { ret += bit [ x ] ; x -= x & - x ; } } return ret ; }
public static int mod ( int mod ) { int n = Integer . parseInt ( input ( ) ) ; int nthBit = ( n >> d ) & 1 ; int [ ] [ ] dp = new int [ 61 ] [ ] ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = 1 ; for ( int d = 59 ; d >= 0 ; d -- ) { for ( int s = 0 ; s < 3 ; s ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { int s2 = Math . min ( 2 , 2 * s + nthBit - k ) ; if ( s2 >= 0 ) dp [ d ] [ s2 ] += dp [ d + 1 ] [ s ] ; } } } int ans = dp [ 0 ] [ 0 ] % mod ; System . out . println ( ans ) ; return ans ; }
@ Function public static int solve ( int p , int q , int a , int n ) { { int num = p ; int dem = q ; int d = a ; int m = n ; int s = p ; if ( num == 0 ) { return 1 ; } if ( d == 0 ) { return 0 ; } if ( num * a / m < dem ) { return 0 ; } return Math . pow ( ( int ) ( Math . pow ( num * i - dem , dem * i ) + d - 1 ) , m * i , i ) ; }
public static String binaryConversion ( String s , int m ) { while ( ( m = m ) != 0 ) { int temp = m % 2 ; s += temp ; m = m / 2 ; } return s . substring ( 0 , s . length ( ) - 1 ) ; }
static int countSubSets ( int [ ] arr , int n ) { HashSet < Integer > us = new HashSet < > ( ) ; int evenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { us . add ( arr [ i ] ) ; } } evenCount = us . size ( ) ; return Math . pow ( 2 , evenCount ) - 1 ; }
public static int fib ( int n ) { int [ ] f = new int [ MAX ] ; int k ; if ( ( n == 0 ) ) { return 0 ; } if ( ( n == 1 ) || ( n == 2 ) ) { f [ n ] = 1 ; return f [ n ] ; } if ( ( f [ n ] ) ) { return f [ n ] ; } k = ( n & 1 ) != 0 ? ( n + 1 ) / 2 : n / 2 ; if ( ( n & 1 ) != 0 ) { f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; } else { f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; } return f [ n ] ; }
static int findNumbers ( int n , int w ) { int x = 0 ; int sum = 0 ; if ( ( w >= 0 && w <= 8 ) ) { x = 9 - w ; } else if ( ( w >= - 9 && w <= - 1 ) ) { x = 10 + w ; } sum = Math . pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; }
static int findKthChar ( String s , int k ) { int len1 = s . length ( ) ; int i = 0 ; int totalLen = 0 ; while ( ( i < len1 ) ) { if ( ( Character . isLetter ( s . charAt ( i ) ) ) ) { totalLen ++ ; if ( ( totalLen == k ) ) { return s . charAt ( i ) ; } i ++ ; } else { int n = 0 ; while ( ( i < len1 ) && ( Character . isLetter ( s . charAt ( i ) ) == false ) ) { n = n * 10 + ( ( int ) s . charAt ( i ) - '0' ) ; i ++ ; } int nextTotalLen = totalLen * n ; if ( ( k <= nextTotalLen ) ) { int pos = k % totalLen ; if ( ( pos == 0 ) ) { pos = totalLen ; } return findKthChar ( s , pos ) ; } else { totalLen = nextTotalLen ; } } } return - 1 ; }
public static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return ( int ) ( n * ( n + 1 ) / 2 ) ; }
