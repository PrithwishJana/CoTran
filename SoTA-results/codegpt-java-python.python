import sys NEW_LINE for e in sys . stdin : NEW_LINE INDENT e = e . replace ( ' \n ' , ' ' ) NEW_LINE DEDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( len ( set ( input ( ) for _ in range ( int ( input ( ) ) ) ) & set ( input ( ) ) ) ) NEW_LINE DEDENT
MAX
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) NEW_LINE a = ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 NEW_LINE b = ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 NEW_LINE c = ( y1 - y2 ) ** 2 + ( x1 - x2 ) ** 2 NEW_LINE d = ( a * a ) / ( b * b ) NEW_LINE print ( c , d ) NEW_LINE DEDENT
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 ] * 9 NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_sum = 0 NEW_LINE continuous_zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( number [ i ] - '0' ) == 0 : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += ( number [ i ] - '0' ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE DEDENT return result NEW_LINE DEDENT print ( count9s ( "01809" ) ) NEW_LINE print ( count9s ( "1809" ) ) NEW_LINE print ( count9s ( "4189" ) ) NEW_LINE
def fastPow ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = fastPow ( N , K // 2 ) NEW_LINE if ( K % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return N * temp * temp NEW_LINE DEDENT DEDENT def countWays ( N , K ) : NEW_LINE INDENT return K * fastPow ( K - 1 , N - 1 ) NEW_LINE DEDENT N = 3 NEW_LINE K = 3 NEW_LINE print ( countWays ( N , K ) ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == - 1 : break NEW_LINE a = [ 1 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] ^ a [ j ] : print ( " ▁ " . join ( map ( str , a [ i ] ^ a [ j ] ) ) ) ; break NEW_LINE DEDENT else : print ( " ▁ " . join ( map ( str , a [ i ] ^ a [ j ] ) ) ) NEW_LINE DEDENT DEDENT
MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE
MAX = 1000000 NEW_LINE arr = [ ] NEW_LINE prime = [ True ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if ( not prime [ n ] ) : NEW_LINE INDENT return False NEW_LINE
def mul_table ( N , i ) : NEW_LINE INDENT if ( i > 10 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT print ( N , i , " ▁ * ▁ " , N * i ) ; NEW_LINE mul_table ( N , i + 1 ) ; NEW_LINE DEDENT N = 8 ; NEW_LINE mul_table ( N , 1 ) ; NEW_LINE
import math NEW_LINE def closestNumber ( n , m ) : NEW_LINE INDENT q = n // m NEW_LINE n1 = m * q NEW_LINE n2 = ( n * m ) > 0 NEW_LINE m1 = ( m * ( q + 1 ) ) NEW_LINE n2 = ( m * ( q - 1 ) ) NEW_LINE if abs ( n - n1 ) < abs ( n - n2 ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 13 NEW_LINE m = 4 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = - 15 NEW_LINE m = 6 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 0 NEW_LINE m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = - 7 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE DEDENT
def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) / 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE DEDENT
def compute_lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 ] * n NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ len ] ) : NEW_LINE INDENT len += 1 NEW_LINE lps [ i ] = len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len != 0 ) : NEW_LINE INDENT len = lps [ len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE
def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = float ( ' inf ' ) NEW_LINE maxEle = float ( ' inf ' ) NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < minEle ) : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = True NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag1 = False NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = True NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag2 = False
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE l2 = l [ n - 1 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if l2 > l [ i ] : NEW_LINE INDENT l2 -= l [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT l2 = l [ i + 1 ] NEW_LINE DEDENT DEDENT print ( l2 ) NEW_LINE
def checkIfPowerIsolated ( num ) : NEW_LINE INDENT input = num ; NEW_LINE count = 0 ; NEW_LINE factor = [ 0 ] * ( num + 1 ) ; NEW_LINE if ( num % 2 == 0 ) : NEW_LINE INDENT while ( num % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= 2 ; NEW_LINE DEDENT factor [ 2 ] = count ; NEW_LINE DEDENT for i in range ( 3 , int ( num + 1 ) , 2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( num % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= i ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT factor [ i ] = count ; NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT factor [ num ] = 1 ; NEW_LINE DEDENT product = 1 ; NEW_LINE for i in range ( num + 1 ) : NEW_LINE INDENT if ( factor [ i
s = input ( ) NEW_LINE ans = " AZ " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == " A " and s [ i + 1 ] == " Z " ) : NEW_LINE INDENT ans = " AZ " NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE d = { } NEW_LINE for i in a : NEW_LINE INDENT if i not in d : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT DEDENT print ( max ( d . values ( ) ) ) NEW_LINE DEDENT
def
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE if s <= l [ 0 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if k > n // 2 : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT print ( s [ i : i + 2 ] , end = " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT
def printDistSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = 1 NEW_LINE for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT for j in range ( 0 , sum + 1 ) : NEW_LINE INDENT if
def Subtract ( a , b ) : NEW_LINE INDENT c = a + ( ~ b + 1 ) ; NEW_LINE return c ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 3 ; NEW_LINE print ( Subtract ( a , b ) ) ; NEW_LINE a = 9 ; NEW_LINE b = 7 ; NEW_LINE print ( Subtract ( a , b ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE if n % 4 == 1 or n % 4 == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n // 2 - 1 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE if l [ n - 1 ] == l [ n - 2 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def nextZero ( i , occurrences ) : NEW_LINE INDENT while ( i < len ( occurrences ) ) : NEW_LINE INDENT if ( occurrences [ i ] == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def getModifiedString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n > 26 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT ch = str . toCharArray ( ) NEW_LINE i , occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ch [ i ] - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = nextZero ( 0 , occurrences ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( occurrences [ ch [ i ] - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT occurrences [ ch [ i ] - ord ( ' a ' ) ] -= 1 NEW_LINE ch [ i ] =
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT h , r = map ( int , input ( ) . split ( ) ) NEW
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE while n > 0 : NEW_LINE INDENT ans = ans * n % 2 NEW_LINE n = n // 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE if n % 2 == 1 : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in b : NEW_LINE INDENT for j in b : NEW_LINE INDENT if i <= j : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT b . append ( int ( input ( ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % m == 0 : NEW_LINE INDENT ans += ( ( a [ i ] - m ) + ( b [ i ] - m ) ) % m NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( ( a [ i ] - m ) + ( b [ i ] - m ) ) % m NEW_LINE DEDENT DEDENT print ( ans % m ) NEW_LINE
def printMax ( arr , n , k ) : NEW_LINE INDENT Qi = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT while len ( Qi ) and arr [ i ] >= arr [ Qi [ - 1 ] ] : NEW_LINE INDENT Qi . pop ( ) NEW_LINE Qi . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ Qi [ i ] ] , end = " ▁ " ) NEW_LINE while len ( Qi ) and Qi [ i ] <= i - k : NEW_LINE INDENT Qi . pop ( ) NEW_LINE Qi . append ( arr [ i ] ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT print ( arr [ Qi [ - 1 ] ] ) NEW_LINE DEDENT arr = [ 12 , 1 , 78 , 90 , 57 , 89 , 56 ] NEW_
def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b ) : NEW_LINE INDENT if ( ( b & 1 ) != 0 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( russianPeasant ( 18 , 1 ) ) NEW_LINE print ( russianPeasant ( 20 , 12 ) ) NEW_LINE
def isValid ( str , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if ( str [ i ] == str [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "0110" NEW_LINE length = len ( str ) NEW_LINE if isValid ( str , length ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE lehmann ( n , t ) = int ( input ( ) ) NEW_LINE e = int ( input ( ) ) NEW_LINE if ( lehmann ( n , t ) == 1 or ( lehmann ( n , t ) == n - 1 ) ) : NEW_LINE INDENT a = rand . next ( n - 3 ) + 2 NEW_LINE e = int ( n - 1 ) / 2 NEW_LINE while ( t > 0 ) : NEW_LINE INDENT result = ( ( a * ( result ) ) % n ) NEW_LINE if ( result % n == 1 or ( result % n ) == ( n - 1 ) ) : NEW_LINE INDENT a = rand . next ( n - 3 ) + 2 NEW_LINE t -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( " ▁ 2 ▁ is ▁ Prime . " ) NEW_LINE D
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE k = ( a + b ) // ( a - 1 ) NEW_LINE print ( k * ( k + 1 ) ) NEW_LINE DEDENT
k = int ( input ( ) ) NEW_LINE print ( ' { } ▁ { } ' . format ( k * ( 10 ** ( k - 1 ) ) ) ) NEW_LINE
N = 3 NEW_LINE MaxTraceSub ( mat ) : NEW_LINE INDENT max_trace = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT r = i , s = j , 0 NEW_LINE while r < N and s < N : NEW_LINE INDENT trace += mat [ r ] [ s ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE DEDENT DEDENT DEDENT return max_trace NEW_LINE DEDENT mat = [ [ 10 , 2 , 5 ] , [ 6 , 10 , 4 ] , [ 2 , 7 , - 10 ] ] NEW_LINE print ( MaxTraceSub ( mat ) ) NEW_LINE
import sys NEW_LINE for e in sys . stdin : NEW_LINE INDENT a , b , c , d = map ( float , e . split ( ) ) NEW_LINE xa , ya , xb , yb , xc , yc , xd , yd = a * b - c * d , a * c - b * d NEW_LINE if ya < xb : NEW_LINE INDENT ya = xb NEW_LINE DEDENT if ya > yb : NEW_LINE INDENT yb = xc NEW_LINE DEDENT if xd < yd : NEW_LINE INDENT xd = yd NEW_LINE DEDENT if xc < yc : NEW_LINE INDENT xc = xd NEW_LINE DEDENT if yc < yd : NEW_LINE INDENT yc = yd NEW_LINE DEDENT print ( ' YES ' ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] % j != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( ( divCount % 2 ) != 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( l [ i ] / s ) > m : NEW_LINE INDENT s = l [ i ] NEW_LINE DEDENT DEDENT print ( s + 1 ) NEW_LINE
def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def replacedArray ( N , arr ) : NEW_LINE INDENT pos_sum , neg_sum , i , j , diff = 0 , 0 , 0 , 0 , 0 NEW_LINE pos_sum = 0 ; NEW_LINE neg_sum = 0 ; NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT diff = abs ( pos_sum ) - abs ( neg_sum ) ; NEW_LINE if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ i ] ; NEW_LINE DEDENT arr [ i ] = abs ( diff ) ; NEW_LINE DEDENT DEDENT N = 5 ; NEW_LINE arr = [
def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def replacedArray ( N , arr ) : NEW_LINE INDENT pos_sum , neg_sum , i , j , diff = 0 , 0 , 0 , 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT pos_sum = 0 ; NEW_LINE neg_sum = 0 ; NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ j ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ j ] ; NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ j ] ; NEW_LINE DEDENT DEDENT diff = abs ( pos_sum ) - abs ( neg_sum ) ; NEW_LINE arr [ i
def countDivisbleby4 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT h = ( s [ i ] - '0' ) * 10 + ( s [ i + 1 ] - '0' ) NEW_LINE if ( h % 4 == 0 ) : NEW_LINE INDENT count = count + i + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = "124" NEW_LINE print ( countDivisbleby4 ( s ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 0 ] > a [ 1 ] and a [ 2 ] > a [ 3 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = bin ( ord ( '1' ) ) [ 2 : ] NEW_LINE y = len ( x ) NEW_LINE if x [ 0 ] == '0' : NEW_LINE INDENT ans = i - y NEW_LINE DEDENT else : NEW_LINE INDENT ans = i - y NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , t = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p = 0 NEW_LINE for i in a : NEW_LINE INDENT if i == t : NEW_LINE INDENT p = 1 NEW_LINE DEDENT DEDENT print ( ' yes ' if p < 0 else ' no ' ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ' Case ▁ # { } : ▁ { } ' .
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a , b , c = [ 0 ] * n , 0 , 0 NEW_LINE for i in range ( n ) : a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) NEW_
def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arraySortedOrNot ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += abs ( l [ i ] - l [ i - 1 ] ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def printKDistinct ( arr , n , k ) : NEW_LINE INDENT h = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( h [ arr [ i ] ] ) : NEW_LINE INDENT h [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT h [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if ( len ( h ) < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( h [ arr [ i ] ] == 1 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE print ( printKDistinct ( ar , n , 2 ) ) NEW_LINE
def fib ( f ) : NEW_LINE INDENT f [ 0 ] = 0 ; f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , 59 + 1 ) : NEW_LINE INDENT f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 ; NEW_LINE DEDENT DEDENT def findLastDigit ( n ) : NEW_LINE INDENT f [ 0 ] = 0 ; f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , 59 + 1 ) : NEW_LINE INDENT f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 ; NEW_LINE DEDENT return f [ index ] ; NEW_LINE DEDENT n = 1 ; NEW_LINE print ( fib ( n ) ) ; NEW_LINE n = 61 ; NEW_LINE print ( fib ( n ) ) ; NEW_LINE n = 7 ; NEW_LINE print ( fib ( n ) ) ; NEW_LINE n = 67 ; NEW_LINE print ( fib ( n ) ) ; NEW_LINE
a = input ( ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE if a == 7 and b == 5 and c == 7 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif a == 7 and b == 5 and c == 7 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif a == 7 and b == 6 and c == 6 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif a == 7 and b == 6 and c == 7 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif a == 7 and b == 6 and c == 6 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif a == 7 and b == 6 and c == 7 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif a == 7 and b == 6 and c == 6 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif a == 7 and b == 6 and c
n , z , w = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( abs ( a [ 0 ] - a [ 0 ] ) ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( abs ( a [ 0 ] - a [ 1 ] ) ) NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT print ( max ( a ) - min ( a ) ) NEW_LINE DEDENT elif n == 4 : NEW_LINE INDENT print ( abs ( a [ 0 ] - a [ 1 ] ) ) NEW_LINE DEDENT elif n == 5 : NEW_LINE INDENT print ( abs ( a [ n - 2 ] - a [ 0 ] ) ) NEW_LINE DEDENT elif n == 6 : NEW_LINE INDENT print ( max ( a ) - min ( a ) ) NEW_LINE DEDENT elif n == 7 : NEW_LINE INDENT print ( abs ( a [ n - 1 ] - a [ 1 ] ) ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( abs ( a [ n - 2 ] - a [ 0 ] ) ) NEW_LINE DEDENT elif n == 9 : NEW_LINE INDENT print (
def countEleLessThanOrEqual ( arr1 , arr2 , m , n ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr2 [ j ] <= arr1 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT return m NEW_LINE DEDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] NEW_LINE countEleLessThanOrEqual ( arr1 , arr2 , arr1 . length , arr2 . length ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT else
n = int ( input ( ) ) NEW_LINE s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE while n != 0 : NEW_LINE INDENT k = 0 NEW_LINE if s1 [ 0 ] == s2 [ 0 ] : NEW_LINE INDENT k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 0 NEW_LINE DEDENT s1 [ 1 ] = s2 [ 1 ] NEW_LINE n -= 1 NEW_LINE DEDENT print ( k , end = ' ▁ ' ) NEW_LINE print ( ' ▁ ' . join ( s1 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE print ( a [ n // 2 - 1 ] ) NEW_LINE
k , p = map ( int , input ( ) . split ( ) ) NEW_LINE print ( sum ( ( 10 ** p ) - ( 10 ** ( p - 1 ) // 10 ) * ( 10 ** p - 1 ) for p in range ( 1 , k + 1 ) ) % 10 ** 9 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT ans += ( a [ i ] - a [ i + 1 ] ) * ( i + 1 ) NEW_LINE DEDENT elif a [ i ] < a [ i + 1 ] : NEW_LINE INDENT ans += ( a [ i ] - a [ i + 1 ] ) * ( i + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def lps ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE i , j , cl = 0 , 0 , 0 NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if seq [ i ] == seq [ j ] and seq [ i ] [ j ] == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif seq [ i ] == seq [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2
def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , end = " ▁ " ) ; NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( " ▁ + ▁ " , x ) ; NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( 0 , last ) : NEW_LINE INDENT if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) : NEW_LINE INDENT print ( N , end = " ▁ " ) ; NEW_LINE printConsecutive ( last , first + 1 ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT print ( " - 1" ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 ; NEW_LINE findConsecutive ( n ) ; NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
from math import gcd NEW_LINE def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = gcd ( x , y ) ; NEW_LINE ans = ( x * y ) / ( s * s ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 385 ; n = 60 ; NEW_LINE print ( NumberOfSquares ( m , n ) ) ; NEW_LINE DEDENT
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = ord ( s [ i ] ) NEW_LINE DEDENT c . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != ord ( s [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabbbcc " NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printKMax ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE for j in range ( 1 , k ) : NEW_LINE INDENT if ( arr [ i + j ] > max ) : NEW_LINE INDENT max = arr [ i + j ] NEW_LINE DEDENT DEDENT print ( max , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE k = 3 NEW_LINE printKMax ( arr , len ( arr ) , k ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT b
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 1 if n + m > 1 else m - 1 ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) :
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) ) NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT b . append ( input ( ) ) NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s = ' ' NEW_LINE for j in range ( len ( b ) ) : NEW_LINE INDENT s += b [ j ] [ i ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def pre_process ( substrings , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dup = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT dup += s [ j ] NEW_LINE substrings [ count ] = dup NEW_LINE DEDENT DEDENT size = len ( substrings ) NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if substrings [ i ] . compareTo ( substrings [ j ] ) > 0 : NEW_LINE INDENT temp = substrings [ i ] NEW_LINE substrings [ i ] = substrings [ j ] NEW_LINE substrings [ j ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT s = " geek " NEW_LINE substrings = [ [ 1 , 5 , 10 ] , [ 1
while True : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if w == 0 and h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( w , h ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == " x " : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ans == 3 : NEW_LINE INDENT print ( n - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT
while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == '0' : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' A ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count == 0 : NEW_LINE INDENT print ( '0 ▁ 0' ) NEW_LINE DEDENT elif count == 1 : NEW_LINE INDENT print ( '1 ▁ 0' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT DEDENT
def fact ( N ) : NEW_LINE INDENT i , product = 1 , 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT return product NEW_LINE DEDENT N = 4 NEW_LINE print ( fact ( N ) ) NEW_LINE
def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( 9 * ( k * 9 + 1 ) ) - ( 9 * ( k * 9 + 2 ) ) ) NEW_LINE DEDENT
def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left , right , above = x * b , y * b NEW_LINE above = l * y NEW_LINE below = l * y NEW_LINE print ( max ( left , right ) , max ( above , above ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 8 NEW_LINE B = 8 NEW_LINE X = 0 NEW_LINE Y = 0 NEW_LINE maximumArea ( L , B , X , Y ) NEW_LINE DEDENT
NO_OF_CHARS = 256 NEW_LINE def max_distinct_char ( str , n ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT max_distinct = max ( max_distinct , count ) NEW_LINE minl = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if s . count ( " R " ) == 1 and s . count ( " G " ) == 1 and s . count ( " B " ) == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findNumberOfEvenCells ( n , q , size ) : NEW_LINE INDENT row = [ 0 ] * n ; NEW_LINE col = [ 0 ] * n ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT x = q [ i ] [ 0 ] ; NEW_LINE y = q [ i ] [ 1 ] ; NEW_LINE row [ x - 1 ] += 1 ; NEW_LINE col [ y - 1 ] += 1 ; NEW_LINE DEDENT r1 = 0 ; NEW_LINE r2 = 0 ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( row [ i ] % 2 == 0 ) : NEW_LINE INDENT r1 += 1 ; NEW_LINE DEDENT if ( row [ i ] % 2 == 1 ) : NEW_LINE INDENT r2 += 1 ; NEW_LINE DEDENT if ( col [ i ] % 2 == 1
def checkType ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] <= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing " ) NEW_LINE DEDENT elif ( arr [ 0 ] >= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Decreasing " ) NEW_LINE DEDENT elif ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Decreasing " ) NEW_LINE DEDENT elif ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Decreasing " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Increasing ▁ then ▁ decreasing " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE checkType ( arr , n ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( min ( max ( s ) , n - 1 ) ) NEW
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a * d - b * c , ( b * c - a * d ) // a ) NEW_LINE
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ 0 ] * ( x + 1 ) ; NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; NEW_LINE DEDENT return dp [ x ] ; NEW_LINE DEDENT x = 3 ; NEW_LINE print ( numberOfWays ( x ) ) ; NEW_LINE
def rearrange ( arr , n ) : NEW_LINE INDENT j = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( arr ) NEW_LINE
def centered_square_num ( n ) : NEW_LINE INDENT return ( n * n + ( ( n - 1 ) * ( n - 1 ) ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( n , " th ▁ Centered " , " square ▁ number : ▁ " , centered_square_num ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n % 2 != k % 2 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
def maxSubArraySum ( arr , size ) : NEW_LINE INDENT max_so_far = arr [ 0 ] NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( arr [ i ] , curr_max + arr [ i ] ) NEW_LINE max_so_far = max ( max
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if l [ i ] * l [ j ] == l [ j ] * l [ i ] : NEW_LINE INDENT ans = max ( ans , j - i + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def find ( dividend , divisor , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return [ 0 , dividend ] NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE n = dividend - divisor * mid NEW_LINE if ( n > divisor ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT elif ( n < 0 ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n == divisor ) : NEW_LINE INDENT mid += 1 NEW_LINE n = 0 NEW_LINE DEDENT return [ mid , n ] NEW_LINE DEDENT return find ( dividend , divisor , start , end ) NEW_LINE DEDENT def divide ( dividend , divisor ) : NEW_LINE INDENT return find ( dividend , divisor , 1 , dividend ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT dividend = 10 NEW_LINE divisor = 3 NEW_LINE ans = divide ( dividend , divisor ) NEW_LINE print ( ans [ 0 ] , " , ▁ " , ans [ 1 ] , " , " , ans [ 2 ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE l2 = l [ n - 1 ] - l [ 0 ] NEW_LINE if n == 1 : NEW_LINE INDENT print ( l2 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( l2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( l2 ) , max ( l ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = [ i + 1 for i in a ] NEW_LINE print ( n - a [ - 1 ] . count ( 1 ) ) NEW_LINE
from_werOfHanoi ( n , from_rod , to_rod , aux_rod1 , aux_rod2 ) ; NEW_LINE print ( ' Move ▁ disk ' , n , ' from ' , ' to ' , ' rod ' , ' to ' , ' rod ' , aux_rod2 ) ; NEW_LINE print ( ' Move �
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) . rstrip ( ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( s [ 0 ] + s [ 1 ] ) NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT print ( s [ 0 ] + s [ 1 ] + s [ 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( 100 * pow ( 2 , n - 1 , 10 ) ) + s [ 0 ] * pow ( 2 , n - 1 , 10 ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE dic = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) . strip ( ) NEW_LINE if s in dic : NEW_LINE INDENT dic [ s ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dic [ s ] = 1 NEW_LINE DEDENT DEDENT dic = sorted ( dic . items ( ) , key = lambda x : ( - x [ 1 ] , x [ 0 ] ) ) NEW_LINE n = dic [ 0 ] [ 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dic [ i ] [ 1 ] == 0 : NEW_LINE INDENT print ( dic [ i ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( dic [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] <= prev ) : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum = sum + prev NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE prev = arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 2 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minSum ( arr , n ) ) NEW_LINE
def findN ( k ) : NEW_LINE INDENT ans = 3 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT
def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << ( int ) ( max_ele
d , g , b = map ( int , input ( ) . split ( ) ) NEW_LINE p , c = 0 , 1001 NEW_LINE for i in range ( d ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE p += x * 1001 NEW_LINE c += y * 1001 NEW_LINE DEDENT if ( ( 1001 - p ) >= 0 ) : NEW_LINE INDENT print ( min ( p ) + c ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DED
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE print ( l [ n - 1 ] ) NEW_LINE
def minAbsDiff ( n ) : NEW_LINE INDENT left = pow ( 2 , ( int ) ( pow ( 2 , ( int ) ( pow ( 2 ** ( n ) ) ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE
LCIS ( arr1 , n , arr2 , m ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT current = 0 ; NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 ; NEW_LINE DEDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT current = table [ j ] ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT result = 0 ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] > result ) : NEW_
def countSetBits ( n ) : NEW_LINE INDENT bitCount = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bitCount += countSetBitsUtil ( i ) ; NEW_LINE DEDENT return bitCount ; NEW_LINE DEDENT def countSetBitsUtil ( x ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return ( x % 2 == 0 ) + countSetBitsUtil ( x // 2 ) ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( " Total ▁ set ▁ bit ▁ count ▁ is " , end = " ▁ " ) ; NEW_LINE print ( countSetBits ( n ) ) ; NEW_LINE
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ low ] NEW_LINE i = low - 1 NEW_LINE j = high + 1 NEW_LINE while ( True ) : NEW_LINE INDENT i = i + 1 NEW_LINE while ( arr [ i ] < pivot ) : NEW_LINE INDENT j = j - 1 NEW_LINE DEDENT while ( arr [ j ] > pivot ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i >= j ) : NEW_LINE INDENT return j NEW_LINE DEDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE i = j NEW_LINE j = i + 1 NEW_LINE DEDENT DEDENT def quickSort ( arr , low , high ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ high ] NEW_LINE i = ( low - 1 ) NEW_LINE for j in range ( low , high + 1 ) : NEW_LINE INDENT if arr [ j ] <= pivot : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT arr [ i + 1 ] = arr [ i ] NEW_LINE arr [ i + 1 ] = arr [ i ] NEW_LINE DEDENT def quickSort ( arr , low , high ) : NEW_LINE INDENT if low < high : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE quickSort ( arr , pi + 1 , high ) NEW_LINE quickSort ( arr , pi + 1
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( - max_so_far ) ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE DEDENT DEDENT return max_so_far ; NEW_LINE DEDENT def minPossibleSum ( a , n , x ) : NEW_LINE INDENT mxSum = maxSubArraySum ( a , n ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT sum = sum - mxSum + mxSum / x ; NEW_LINE print
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( )
def printArray ( N , SUM , K ) : NEW_LINE INDENT minSum = ( N * ( N + 1 ) ) // 2 NEW_LINE maxSum = ( N * K ) - ( N * ( N - 1 ) ) // 2 NEW_LINE if ( minSum > SUM or maxSum < SUM ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT arr = [ 0 ] * N NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr [ i ] = i NEW_LINE DEDENT sum = minSum NEW_LINE for i in range ( N , 1 , - 1 ) : NEW_LINE INDENT x = sum + ( K - i ) NEW_LINE if ( x < SUM ) : NEW_LINE INDENT sum = sum + ( K - i ) NEW_LINE arr [ i ] = K NEW_LINE K -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( SUM - sum ) NEW_LINE sum = SUM NEW
def maxItems ( x , y , z ) : NEW_LINE INDENT type1 = x // COST NEW_LINE x %= COST NEW_LINE type2 = y // COST NEW_LINE y %= COST NEW_LINE type3 = z // COST NEW_LINE z %= COST NEW_LINE type4 = min ( x , min ( y , z ) ) NEW_LINE maxItems = type1 + type2 + type3 + type4 NEW_LINE return maxItems NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x , y , z = 4 , 5 , 6 NEW_LINE print ( maxItems ( x , y , z ) ) NEW_LINE DEDENT
def run_tasks ( A , Queue ) : NEW_LINE INDENT total_time = 0 NEW_LINE while True : NEW_LINE INDENT x = A . pop ( ) NEW_LINE y = B . pop ( ) NEW_LINE if x == y : NEW_LINE INDENT A . remove ( ) NEW_LINE B . remove ( ) NEW_LINE total_time += 1 NEW_LINE DEDENT elif x == y : NEW_LINE INDENT A . remove ( ) NEW_LINE A . add ( x ) NEW_LINE total_time += 2 NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 3 , 2 , 1 , 4 , 1 , 3 , 2 ] NEW_LINE A . append ( 3 ) NEW_LINE A . append ( 2 ) NEW_LINE A . append ( 1 ) NEW_LINE A . append ( 4 ) NEW_LINE Queue < Integer : NEW_LINE INDENT total_time = 0 NEW_LINE while True : NEW_LINE INDENT x = A . pop ( ) NEW_LINE y = B . pop ( ) NEW_LINE total_time += 2 NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT
def line ( x0 , y0 ) : NEW_LINE INDENT c = ( 2 * y0 * x0 ) ; NEW_LINE print ( str ( x0 ) + " x " + " ▁ + " x " , " ▁ " + str ( y0 ) ) ; NEW_LINE DEDENT x0 , y0 = 4 , 3 ; NEW_LINE line ( x0 , y0 ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] not in ans ) : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . real NEW_LINE DEDENT q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) NEW_LINE cross ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT print ( 1 if x1 < x2 else 0 ) NEW_LINE
def isAnyNotPalindrome ( s ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT unique . add ( s [ i ] ) NEW_LINE DEDENT if ( len ( unique ) > 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaaaab " NEW_LINE if ( isAnyNotPalindrome ( s ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT return arr [ n // 2 ] NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMajority ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , p , q = input ( ) . split ( ) NEW_LINE l . append ( ( s , 100 - int ( p ) , 2 )
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , n ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE
def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr = [ 0 for i in range ( 3 ) ] NEW_LINE arr [ 0 ] = a NEW_LINE arr [ 1 ] = b NEW_LINE arr [ 2 ] = c NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] NEW_LINE k = k - diff NEW_LINE if ( k < 0 or k % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a1 = 6 NEW_LINE b1 = 3 NEW_LINE c1 = 2 NEW_LINE k1 = 7 NEW_LINE if ( canBeEqual ( a1 , b1 , c1 , k1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def insert ( x , y ) : NEW_LINE INDENT adjacency [ x ] . append ( y ) NEW_LINE DEDENT def dfs ( node , leaf , vis ) : NEW_LINE INDENT leaf [ node ] = 0 NEW_LINE vis [ node ] = 1 NEW_LINE for i in range ( len ( leaf ) ) : NEW_LINE INDENT it = adjacency [ node ] [ i ] NEW_LINE if ( vis [ it ] == 0 ) : NEW_LINE INDENT dfs ( it , leaf , vis ) NEW_
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT ranks = [ 0 ] * 5 NEW_LINE n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT h = int ( input ( ) ) NEW_LINE if h == 1 : NEW_LINE INDENT ranks [ 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ranks [ 2 ] += 1 NEW_LINE DEDENT DEDENT for i , f in enumerate ( ranks ) : NEW_LINE INDENT print ( f ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE if s1 in s2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s2 ) NEW
def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ 0 for i in range ( o + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = abs ( l [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += abs ( l [ i ] - l [ i - 1 ] ) NEW_LINE DEDENT print ( s ) NEW_LINE
def isSpiltPossible ( n , a ) : NEW_LINE INDENT sum = 0 ; c1 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT DEDENT if ( sum % 2 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( c1 > 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 ; NEW_LINE a = [ 1 , 1 , 2 ] ; NEW_LINE if ( isSpiltPossible ( n , a ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp = [ [ 0 ] * ( 2 * n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 1 ] [ i ] = max ( dp [ 1 ] [ i ] , 0 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 * n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + a [ i - 1 ] ) NEW_LINE DEDENT DEDENT print ( dp [ n ] [ n - 1 ] ) NEW_LINE
def count_even_odd ( min , max , steps ) : NEW_LINE INDENT beven = True NEW_LINE ai = steps [ 0 ] [ 0 ] NEW_LINE b = steps [ 0 ] [ 1 ] NEW_LINE if ( ai & 1 ) : NEW_LINE INDENT ai = 0 NEW_LINE DEDENT if ( b & 1 ) : NEW_LINE INDENT b = 0 NEW_LINE DEDENT if ( beven ) : NEW_LINE INDENT even = max // 2
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n // k + 1 ) * k ) NEW_LINE
def printKPFNums ( A , B , K ) : NEW_LINE INDENT prime = [ True ] * ( B + 1 ) NEW_LINE p_factors = [ 0 ] * ( B + 1 ) NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if ( p_factors [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p , B + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( p_factors [ i ] == K ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT A = 14 NEW_LINE B = 18 NEW_LINE K = 2 NEW_LINE printKPFNums ( A , B , K ) NEW_LINE
def reverseWords ( str ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != ' ▁ ' ) : NEW_LINE INDENT st . append ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( st and len ( st ) == 0 ) : NEW_LINE INDENT print ( st . pop ( ) , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT while ( st ) : NEW_LINE INDENT print ( st [ : len ( st ) ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " Geeks ▁ for ▁ Geeks " NEW_LINE reverseWords ( str ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] == 1 and b [ i ] == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif p [ i ] == 0 and b [ i ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ans == n : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = [ 1 ] * ( n - 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT ans [ i ] = ans [ i - 1 ] * 2 + 1 NEW_LINE DEDENT print ( * ans ) NEW_LINE DEDENT
while True : NEW_LINE INDENT try : NEW_LINE INDENT s = input ( ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT t = input ( ) NEW_LINE v = [ ' - ' ] * 100 NEW_LINE for x in s : NEW_LINE INDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == k : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif k % n == 0 : NEW_LINE INDENT print ( k // n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( k + 1 ) // n + 1 ) NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE print ( pow ( 3 , n - 1 ) , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT n = ( n // 2 ) + 1 NEW_LINE print ( pow ( 2 , n - 1 ) , end = " " ) NEW_LINE DEDENT DEDENT N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE N = 11 NEW_LINE findNthTerm ( N ) NEW_LINE
def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] >= arr [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) // 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 7 , 1 , 1 ] NEW_LINE n = len NEW_LINE print ( countNonIncreasing ( arr , n ) ) NEW_LINE
def maximize ( A1 , A2 , n , x , y ) : NEW_LINE INDENT c = [ 0 ] * n NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = A2 [ i ] - A1 [ i ] NEW_LINE sum += A1 [ i ] NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( c [ i ] < c [ i + 1 ] ) : NEW_LINE INDENT temp = c [ i ] NEW_LINE c [ i ] = c [ i + 1 ] NEW_LINE c [ i + 1 ] = temp NEW_LINE DEDENT DEDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += c [ i ] NEW_LINE if ( i + 1 >= ( n - x ) ) : NEW_LINE INDENT maxi = max ( sum , maxi )
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE s = str ( x ) NEW_LINE ans = 0 NEW_LINE for i in s : NEW_LINE INDENT ans += 10 * ( i - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( max ( a ) - min ( a ) ) NEW_LINE
r1 , r2 , c1 , c2 , d1 = map ( int , input ( ) . split ( ) ) NEW_LINE if ( c1 + c2 ) % 2 != 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x , y , z = ( r1 + r2 ) // 2 , ( r1 - r2 ) // 2 , ( r1 - r2 ) // 2 NEW_LINE if ( c1 + c2 ) % 2 != 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , y , z ) NEW_LINE DEDENT DEDENT
while 1 : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n
def startsWith ( str , pre ) : NEW_LINE INDENT strLen = len ( str ) NEW_LINE preLen = len ( pre ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < strLen and j < preLen ) : NEW_LINE INDENT if ( str [ i ] != pre [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def endsWith ( str , suff ) : NEW_LINE INDENT if ( len ( str ) != len ( suff ) + len ( str ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( startsWith ( str , suff ) ) : NEW_LINE INDENT if ( endsWith ( str
def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , " ▁ " , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT n = 233 NEW_LINE printCombination ( n ) NEW_LINE
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n - i ) : NEW_LINE INDENT for k in range ( n - i ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE
def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % TEN NEW_LINE n //= TEN NEW_LINE DEDENT return sum NEW_LINE DEDENT def getNthTerm ( n ) : NEW_LINE INDENT sum = digitSum ( n ) NEW_LINE if ( sum % TEN == 0 ) : NEW_LINE INDENT return ( n * TEN ) NEW_LINE DEDENT extra = TEN - ( sum % TEN ) NEW_LINE return ( ( n * TEN ) + extra ) NEW_LINE DEDENT def firstNTerms ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( getNthTerm ( i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE firstNTerms ( n ) NEW_LINE
def power ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while ( a > 0 ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT maxProduct = - 1 NEW_LINE switch ( N % 3 ) : NEW_LINE INDENT case 0 : NEW_LINE INDENT maxProduct = power ( 3 , N // 3 ) NEW_LINE break NEW_LINE DEDENT case 1 : NEW_LINE INDENT maxProduct = 2 * power ( 3 , ( N // 3 ) - 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT return maxProduct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT maxProduct = breakInteger ( 10 ) NEW_LINE print ( maxProduct ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = [ 0 ] * ( n + 1 ) NEW_LINE x = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT ans [ i ] = x + ( x // i - 2 ) NEW_LINE x = ( x - ( x % i ) ) % i NEW_LINE DEDENT print ( sum ( ans ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT
import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import collections NEW_LINE import numpy as np NEW_LINE rl = sys . stdin . readline NEW_LINE n = int ( rl ( ) ) NEW_LINE s = rl ( ) NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == ' ? ' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE
MAX_CHAR = 26 NEW_LINE def firstNonRepeating ( string ) : NEW_LINE INDENT charCount = [ 0 ] * MAX_CHAR NEW_LINE q = deque ( ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE q . append ( ch ) NEW_LINE while len ( q ) > 0 : NEW_LINE INDENT if charCount [ q . popleft ( ) ] > 1 : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( q . popleft ( ) , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( q . popleft ( ) != - 1 ) : NEW_LINE INDENT print ( - 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " aabc " NEW_LINE firstNonRepeating ( string ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ [ ] , [ ] ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) NEW_LINE DEDENT a . sort ( key = lambda x : - x [ 1 ] ) NEW_LINE b = [ a [ 0 ] [ 1 ] , a [ 0 ] [ 0 ] ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT b [ a [ i ] [ 1 ] ] . append ( i ) NEW_LINE b [ a [ i ] [ 0 ] ] . append ( i ) NEW_LINE DEDENT print ( sum ( b ) )
def solve ( n , m , obstacles , range ) : NEW_LINE INDENT val = min ( n , m ) NEW_LINE range . sort ( ) NEW_LINE c = 1 NEW_LINE for i in range ( obstacles - 1 , - 1 , - 1 ) : NEW_LINE INDENT range [ i ] = 2 * range [ i ] NEW_LINE val -= range [ i ] NEW_LINE if ( val <= 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( val > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 4 NEW_LINE m = 5 NEW_LINE obstacles = 3 NEW_LINE range = [ 1.0 , 1.25 , 1.15 ] NEW_LINE print ( solve ( n , m , obstacles , range ) ) NEW_LINE
a = input ( ) NEW_LINE b = int ( a [ : 2 ] ) NEW_LINE if b == 0 : NEW_LINE INDENT print ( ' U ' ) NEW_LINE DEDENT elif b == 1 : NEW_LINE INDENT print ( ' M ' ) NEW_LINE DEDENT elif b == 2 : NEW_LINE INDENT print ( ' L ' ) NEW_LINE DEDENT elif b == 3 : NEW_LINE INDENT print ( ' U ' ) NEW_LINE DEDENT elif b == 4 : NEW_LINE INDENT print ( ' M ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' L ' ) NEW_LINE DEDENT
from collections import deque NEW_LINE def push ( x ) : NEW_LINE INDENT if ( not x ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return x - 3 NEW_LINE DEDENT DEDENT def pop ( ) : NEW_LINE INDENT return pop ( ) - 2 NEW_LINE DEDENT def push ( x ) : NEW_LINE INDENT return x - 1 NEW_LINE DEDENT def popleft ( ) : NEW_LINE INDENT return pop ( ) - 1 NEW_LINE DEDENT def popn ( ) : NEW_LINE INDENT return [ i for i in range ( len ( x ) ) if ( x [ i ] > x [ i - 1 ] ) ] NEW_LINE DEDENT def popover ( x ) : NEW_LINE INDENT return pop ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = [ - 2 , - 3 , - 3 ] NEW_LINE m . append ( 0 ) NEW_LINE m . append ( - 2 ) NEW_LINE m . pop ( ) NEW_LINE print ( popleft ( ) ) NEW_LINE print ( pop ( ) ) NEW_

def flipSign ( a ) : NEW_LINE INDENT neg = 0 NEW_LINE tmp = a < 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT neg += tmp NEW_LINE a += tmp NEW_LINE DEDENT return neg NEW_LINE DEDENT def areDifferentSign ( a , b ) : NEW_LINE INDENT return ( ( a < 0 and b > 0 ) or ( a > 0 and b < 0 ) ) NEW_LINE DEDENT def sub ( a
def factorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE while ( n / fact != n ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT num = 5 NEW_LINE print ( " Factorial ▁ of " , num , " is " , factorial ( num ) ) NEW_LINE
def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( ( number % x == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE print ( CntDivbyX ( arr , n , x ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( a [ i ] - 1 ) * ( a [ i ] - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def min_noOf_operation ( arr , n , k ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = ( noOfSubtraction + k ) // k NEW_LINE if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) // k NEW_LINE if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT res = res + noOfSubtraction NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = 4 NEW_LINE k = 5 NEW_LINE print ( min_noOf_operation ( arr , N , k ) ) NEW_LINE
def CountSubSet ( arr , n , X ) : NEW_LINE INDENT N = pow ( 2 , n ) NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) != 0 ) : NEW_LINE INDENT if ( arr [ j ] == X ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 ] NEW_LINE X = 5 NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubSet ( arr , n , X ) ) NEW_LINE
n = 5 NEW_LINE FindMaxProduct ( arr , n ) ; NEW_LINE def FindMaxProduct ( arr , n ) : NEW_LINE INDENT max = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if
MAX = 50002 NEW_LINE primes = [ ] NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if p * p > MAX : NEW_LINE INDENT break NEW_LINE DEDENT if ( isPrime [ p ] == 1 ) : NEW_LINE INDENT for i
def smallestIndexsum ( arr , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 and arr [ i ] % 2 == 1 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 6 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestIndexsum ( arr , n ) ) NEW_LINE
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE s3 = s1 + '0' * ( 2 * 60 * 60 + 1 ) NEW_LINE s4 = s1 + '0' * ( 2 * 60 * 60 + 1 ) NEW_LINE print ( ( s1 + s2 + s3 + s4 ) // ( 24 * 60 * 60 ) ) NEW_LINE
s = input ( ) NEW_LINE t = len ( s ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT if s [ i ] == ' Q ' : NEW_LINE INDENT print ( s . lower ( ) , end = ' ' ) NEW_LINE DEDENT elif s [ i ] == ' A ' : NEW_LINE INDENT print ( s . lower ( ) , end = ' ' ) NEW_LINE DEDENT elif s [ i ] == ' B ' : NEW_LINE INDENT print ( s . lower ( ) , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE print ( sum ( ( s // i ) * i + ( i + 1 ) for i in range ( n ) ) ) NEW_LINE
def multiply ( x ) : NEW_LINE INDENT carry = 0 ; NEW_LINE size = len ( v ) ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT carry = 0 ; NEW_LINE size = size * x ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT res = carry + v [ i ] * x ; NEW_LINE v [ i ] = res % 10 ; NEW_LINE carry = int ( res / 10 ) ; NEW_LINE DEDENT while ( carry != 0 ) : NEW_LINE INDENT v . add ( carry % 10 ) ; NEW_LINE carry = int ( carry / 10 ) ; NEW_LINE DEDENT DEDENT DEDENT def findSumOfDigits ( n ) : NEW_LINE INDENT v . append ( 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT multiply ( i ) ; NEW_LINE DEDENT sum = 0 ; NEW_LINE size = len ( v ) ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT sum += v [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 1000 ; NEW_LINE print ( findSumOfDigits ( n ) ) ; NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( s [ i ] ) NEW_LINE DEDENT l . sort ( ) NEW_LINE for i in l : NEW_LINE INDENT if i [ 1 ] == ' U ' : NEW_LINE INDENT s = s [ : i [ 0 ] + i [ 2 ] ] NEW_LINE DEDENT elif i [ 1 ] == ' D ' : NEW_LINE INDENT s = s [ : i [ 0 ] + i [ 2 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT s = s [ : i [ 0 ] + i [ 2 ] ] NEW_LINE DEDENT DEDENT print ( * s ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in l : NEW_LINE INDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp = [ - 1 ] * ( n + 1 ) NEW_LINE dp [ n ] = a [ n ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] < dp [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] = dp [ i + 1 ] - a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i + 1 ] NEW_LINE DEDENT DEDENT print ( dp [ n - 1 ] ) NEW_LINE
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 2 * pell ( n - 1 ) + pell ( n - 2 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( pell ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = i NEW_LINE DEDENT DEDENT a . sort ( ) NEW_LINE for i in a : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT
def printSmall ( arr , asize , n ) : NEW_LINE INDENT copy_arr = sorted ( arr ) NEW_LINE for i in range ( 0 , asize ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE asize = len ( arr ) NEW_LINE n = 5 NEW_LINE printSmall ( arr , asize , n ) NEW_LINE
def countNumbers ( n ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT count += pow ( 2 , k ) NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 11 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , a [ i ] * b [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def maximum ( graph , node ) : NEW_LINE INDENT ans = - math . inf ; NEW_LINE graph [ node ] = 0 ; NEW_LINE for i in range ( 60 ) : NEW_LINE INDENT if ( ( ( x >> i ) & 1 ) != 0 ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT def dfs ( node , parent ) : NEW_LINE INDENT a = math . inf ; NEW_LINE
MAX = 26 NEW_LINE def updateFreq ( str , freq ) : NEW_LINE INDENT l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT def maxCount ( str , patt ) : NEW_LINE INDENT strFreq = [ 0 ] * MAX NEW_LINE updateFreq ( str , strFreq ) NEW_LINE pattFreq = [ 0 ] * MAX NEW_LINE updateFreq ( patt , pattFreq ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if pattFreq [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT ans = min ( ans , freq [ i ] // pattFreq [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE patt = " geeks " NEW_LINE print ( maxCount ( str , patt ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] ) > ans : NEW_LINE INDENT ans = ( a [ i ] + b [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n , l , r , a = map ( int , input ( ) . split ( ) ) NEW_LINE W = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE W . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT l -= W [ i ] NEW_LINE DEDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT r -= W [ i + l - 1 ] NEW_LINE DEDENT ans = min ( l , r ) NEW_LINE print ( ans ) NEW_LINE
import math NEW_LINE def wastedWater ( V , M , N ) : NEW_LINE INDENT wasted_amt = math . floor ( V / ( M - N ) ) NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT V = 700 NEW_LINE M = 10 NEW_LINE N = 3 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE V = 1000 NEW_LINE M = 100 NEW_LINE N = 50 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE
def maxSubStr ( str , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT if ( count0 == count1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( count0 != count1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "0100110101" NEW_LINE n = len ( str ) NEW_LINE print ( maxSubStr ( str , n ) ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a , b , c ) NEW_LINE
def findS ( s ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for n in range ( 1 , s ) : NEW_LINE INDENT sum += n ; NEW_LINE if ( sum == s ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = 15 ; NEW_LINE n = findS ( s ) ; NEW_LINE if ( n == - 1 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) ; NEW_LINE DEDENT DEDENT
def maximumAbsolute ( arr , n ) : NEW_LINE INDENT mn = float ( ' inf ' ) NEW_LINE mx = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 and arr [ i ] == - 1 and arr [ i - 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i - 1 ] ) NEW_LINE mx = max ( mx , arr [ i + 1 ] ) NEW_LINE DEDENT if ( i < n - 1 and arr [ i ] == - 1 and arr [ i + 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i + 1 ] ) NEW_LINE mx = max
MOD = 1000000007 ; NEW_LINE def countStrings ( N ) : NEW_LINE INDENT i , j = 0 , 0 ; NEW_LINE dp = [ [ 0 for i in range ( 3 ) ] for i in range ( N + 1 ) ] ; NEW_LINE dp [ 1 ] [ 0 ] = 1 ; NEW_LINE dp [ 1 ] [ 1 ] = 1 ; NEW_LINE dp [ 1 ] [ 2 ] = 0 ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] % MOD ) ; NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp
def longest_subseq ( n , k , s ) : NEW_LINE INDENT dp = [ 0 ] * ( 26 ) NEW_LINE max_length = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE lower = max ( 0 , curr - k ) NEW_LINE upper = min ( 25 , curr + k ) NEW_LINE for j in range ( lower , upper + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , max_length [ j ] + 1 ) NEW_LINE DEDENT max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( dp ) ) : NEW_LINE INDENT ans = max ( i , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE n = len ( s ) NEW_LINE k = 3 NEW_
def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT len = 2 NEW_LINE mx = - ( int ) ( a [ 0 ] + a [ 0 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = 2 NEW_LINE DEDENT mx = max ( mx , len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE
def minimumSubarrays ( ar , n ) : NEW_LINE INDENT se = [ ] ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( se [ i ] not in se ) : NEW_LINE INDENT se . append ( ar [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 ; NEW_LINE se . clear ( ) ; NEW_LINE se . append ( ar [ i ] ) ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 , 4 , 4 , 4 ] ; NEW_LINE n = len ( ar ) ; NEW_LINE print ( minimumSubarrays ( ar , n ) ) ; NEW_LINE
def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE r = 0 NEW_LINE i = 0 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = ( s // 10 ) NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor__ = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor__ = xor__ ^ freq [ i ] NEW_LINE if ( xor__ == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = a [ 0 ] NEW_
MAXN = 1000005 NEW_LINE even = [ 0 ] * MAXN NEW_LINE odd = [ 0 ] * MAXN NEW_LINE def precompute ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd [ i ] = 1 NEW_LINE DEDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even [ i ] =
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( * range ( n , n * 3 + 5 , n * 5 ) ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE t = input ( ) NEW_LINE t = t . split ( ) NEW_LINE t = [ int ( i ) for i in t ] NEW_LINE c = int ( c ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a += 1 NEW_LINE b += 1 NEW_LINE c -= 1 NEW_LINE if i % 2 == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def times ( steps , n ) : NEW_LINE INDENT current_level = 0 ; NEW_LINE previous_level = 0 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT previous_level = current_level ; NEW_LINE current_level = current_level + steps [ i ] ; NEW_LINE if ( ( previous_level < 0 and current_level >= 0 ) or ( previous_level > 0 and current_level <= 0 ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT steps = [ 1 , - 1 , 0 , 0 , 1 , - 3 , 2 ] ; NEW_LINE n = len ( steps ) ; NEW_LINE print ( times ( steps , n ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE h1 , m1 = map ( int , input ( ) . split ( ) ) NEW_LINE a = max ( 0 , h1 - m1 ) NEW_LINE print ( max ( 0 , a - 360 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print (
def smallest ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = " " NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT ans += s [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT ans = s [ 0 : l - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abcda " NEW_LINE print ( smallest ( s ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = 10 ** 9 NEW_LINE found = False NEW_LINE sum = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif ( sum > k ) : NEW_LINE INDENT while ( sum > k ) : NEW_LINE INDENT sum = sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 ,
s = input ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE
def nthPalindrome ( n , k ) : NEW_LINE INDENT temp = ( k & 1 ) : ( k // 2 ) ; NEW_LINE palindrome = pow ( 10 , temp ) ; NEW_LINE palindrome += n - 1 ; NEW_LINE print ( palindrome ) ; NEW_LINE if ( ( k & 1 ) > 0 ) : NEW_LINE INDENT palindrome /= 10 ; NEW_LINE DEDENT while ( palindrome > 0 ) : NEW_LINE INDENT print ( palindrome % 10 , end = " ▁ " ) ; NEW_LINE palindrome = palindrome // 10 ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 ; k = 5 ; NEW_LINE print ( n + " th ▁ palindrome ▁ of " , k , " digit ▁ = " , end = " ▁ "
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , x = map ( int , input ( ) . split ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ i + 1 ] = w [ i ] + w [ i + 1 ] NEW_LINE DEDENT d [ 1 ] = x NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT d [ i ] = max ( d [ i ] , d [ i + 1 ] + x ) NEW_LINE DEDENT print ( min ( d ) ) NEW_LINE
MAX = 10000 NEW_LINE hashTable = [ 0 ] * MAX NEW_LINE def minOperations ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hashTable [ arr [ i ] ] ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT hashTable [ arr [ j ] ] = 0 NEW_LINE DEDENT DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE
p1 , p2 , p3 , p4 = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = p1 + p2 + p3 + p4 NEW_LINE d = p1 - p2 NEW_LINE e = p1 + p3 + p4 NEW_LINE if d < e : NEW_LINE INDENT print ( d ) NEW_LINE DEDENT elif e < a : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT numer = 1 NEW_LINE denom = 1 NEW_LINE for d in range ( 10 , 100 ) : NEW_LINE INDENT n = 10 NEW_LINE n % 10 NEW_LINE n = n // 10 NEW_LINE d0 = d % 10 NEW_LINE d1 = d // 10 NEW_LINE if n1 == d0 and n1 * d == n * d1 or n1 * d == n * d0 : NEW_LINE INDENT denom *= n NEW_LINE DEDENT DEDENT return str ( denom ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT def countOfOddsPascal ( n ) : NEW_LINE INDENT c = countSetBits ( n ) NEW_LINE return pow ( 2 , c ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddsPascal ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( a * x , b * y ) ) NEW_LINE DEDENT
def minSwaps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arrpos = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrpos . append ( [ arr [ i ] , i ] ) NEW_LINE DEDENT arrpos . sort ( key = lambda x : - x [ 1 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arrpos [ i ] [ 1 ] < arrpos [ i ] [ 2 ] :
N = 1000005 NEW_LINE prime = [ True ] * N ; NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( i * 2 , N , i ) : NEW_LINE INDENT prime [ j ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumTruncatablePrimes ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT num = i ; NEW_LINE flag = True ; NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( prime [ num ] ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT num //= 10 ; NEW_LINE DEDENT num = i ; NEW_LINE power = 10 ; NEW
def findWeights ( X ) : NEW_LINE INDENT sum = 0 ; NEW_LINE power = 0 ; NEW_LINE number = 3 ; NEW_LINE while ( sum < X ) : NEW_LINE INDENT sum = number - 1 ; NEW_LINE sum /= 2 ; NEW_LINE number *= 3 ; NEW_LINE DEDENT ans = 1 ; NEW_LINE for i in range ( 1 , power + 1 ) : NEW_LINE INDENT print ( ans , end = " ▁ " ) ; NEW_LINE ans = ans * 3 ; NEW_LINE DEDENT DEDENT X = 2 ; NEW_LINE findWeights ( X ) ; NEW_LINE
def addToArrayForm ( A , K ) : NEW_LINE INDENT v = [ ] NEW_LINE ans = [ ] NEW_LINE rem = 0 NEW_LINE i = 0 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT my = A [ i ] + K % 10 + rem NEW_LINE if ( my > 9 ) : NEW_LINE INDENT rem = 1 NEW_LINE v . append ( my % 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( my ) NEW_LINE rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT while ( K > 0 ) : NEW_LINE INDENT my = K % 10 + rem NEW_LINE v . append ( my ) NEW_LINE DED
def printPaths ( input , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( input , " " , 0 , i , R , C ) ; NEW_LINE print ( ) ; NEW_LINE DEDENT DEDENT def dfs ( input , R , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res , " ▁ " , end = " " ) ; NEW_LINE return ; NEW_LINE DEDENT res = res + input [ i ] [ j ] ; NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( input , res , i + 1 , k , R , C ) ; NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = [ [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] ] ; NEW_LINE R = len ( input ) ; NEW_LINE C = input [ 0 ] ; NEW_LINE printPaths ( input , R , C ) ; NEW_LINE DED
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == " R " : NEW_LINE INDENT ans += " L " NEW_LINE DEDENT else : NEW_LINE INDENT ans += " R " NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input
def precio ( n , m ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif n < m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif m < n < m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT d = m / n NEW_LINE for i in range ( 0 , d + 1 ) : NEW_LINE INDENT if precio ( i , d ) == d : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT DEDENT x = 22 NEW_LINE y = 7 NEW_LINE n = 15 NEW_LINE precio ( x , y ) NEW_LINE print ( ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( lcm , arr [ i ] ) NEW_LINE DEDENT return
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE D
import math NEW_LINE def hollowSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT if ( i == 1 or i == rows ) : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT if ( j == 1 or j == rows ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT DEDENT DEDENT rows = 5 NEW_LINE printPattern ( rows ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( ' abc ' ) NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT print ( ' abc ' ) NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif n % 2 == 1 : NEW_LINE INDENT print ( ' abc ' ) NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT print ( ' abc ' ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT for k in range ( j + 1 , n + 1 ) : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , dp [ j - k ] + a [ k ] [ 0 ] ) NEW_LINE DEDENT DEDENT print ( dp [ n ] ) NEW_LINE
a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE if x < a : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT
def findLargest ( arr , n ) : NEW_LINE INDENT gcd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( arr [ i ] , gcd ) ; NEW_LINE DEDENT return gcd ; NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT return b == 0 and a == 0 : __gcd ( b , a % b ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 6 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findLargest ( arr , n ) ) ; NEW_LINE DEDENT
def findWinner ( n ) : NEW_LINE INDENT if ( n - 1 ) % 6 == 0 : NEW_LINE INDENT print ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ Player ▁ wins ▁ the ▁ game " ) NEW_LINE DEDENT DEDENT n = 7 NEW_LINE findWinner ( n ) NEW_LINE
v = { } NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE v [ x ] . append ( y ) ; NEW_LINE v [ y ] = x NEW_LINE DEDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( * v . values ( ) , sep = " \n " ) NEW_LINE DEDENT
v = { } NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE v [ x ] . append ( y ) ; NEW_LINE v [ y ] = x NEW_LINE DEDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( * v . values ( ) , sep = " \n " ) NEW_LINE DEDENT
def getElements ( a , arr , n ) : NEW_LINE INDENT elements = [ 0 ] * n NEW_LINE elements [ 0 ] = a NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 13 , 2 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE a = 5 NEW_LINE getElements ( a , arr , n ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( " Case ▁
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT if ( a [ i ] ^ i ) not in a : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def printRepeating ( arr , size ) : NEW_LINE INDENT S = 0 NEW_LINE P = 1 NEW_LINE x , y = 1 , 1 NEW_LINE D = 1 NEW_LINE n = size - 2 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE DEDENT S = S - n * ( n + 1 ) // 2 NEW_LINE P = P // fact ( n ) NEW_LINE D = ( S - D ) * 2 NEW_LINE x = ( D + S ) // 2 NEW_LINE y = ( S - D ) * 2 NEW_LINE print ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : ▁ " ) NEW_LINE print ( x , " ▁ & ▁ " , y ) NEW_LINE print ( " ▁ & ▁
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT N = int ( readline ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT A = [ int ( readline ( ) ) for i in range ( N ) ] NEW_LINE B = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT c = int ( readline ( ) ) NEW_LINE B [ i ] = c NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT A [ j ] = B [ j ] + A [ j ] NEW_LINE DEDENT DEDENT write ( " \n " . join ( map ( str , A ) )
import math NEW_LINE n = int ( input ( ) ) NEW_LINE x = [ 0 ] * n NEW_LINE y = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT x [ i ] , y [ i ] = map ( float , input ( ) . split ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( math . pi * x [ i ] - math . pi
while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " # " : NEW_LINE INDENT break NEW_LINE DEDENT q = " q " NEW_LINE for i in s : NEW_LINE INDENT if i == q : NEW_LINE INDENT inp = True NEW_LINE break NEW_LINE DEDENT DEDENT if inp : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if s . count ( ' S ' ) > s . count ( ' F ' ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE s = a [ - 1 ] NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( s * a [ i ] > s * a [ i + 1 ] ) : NEW_LINE INDENT s = s * a [ i + 1 ] NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
def FindLCM ( a , b ) : NEW_LINE INDENT return ( a * b ) / new BigInteger ( a + b ) NEW_LINE DEDENT def rangeDivisor ( m , n , a , b ) : NEW_LINE INDENT lcm = FindLCM ( a , b ) NEW_LINE a_divisor = n // a - ( m - 1 ) // a NEW_LINE b_divisor = n // b - ( m - 1 ) // b NEW_LINE common_divisor = n // lcm - ( m - 1 ) // lcm NEW_LINE ans = a_divisor + b_divisor - common_divisor NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 3 NEW_LINE n = 11 NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) NEW_LINE m = 11 NEW_LINE n = 1000000 NEW_LINE a = 6 NEW_LINE b = 35 NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE if s [ 0 ] == ' . ' : NEW_LINE INDENT print ( ' ' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ' , end = ' ' ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' ? ' : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT DEDENT print ( ' ' , end = ' ' ) NEW_LINE DEDENT
def smallestKFreq ( a , n , k ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] = m . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 10 ** 9 NEW_LINE s = m . keys ( ) NEW_LINE for temp in s : NEW_LINE INDENT if m [ temp ] == k : NEW_LINE INDENT res = min ( res , temp ) NEW_LINE DEDENT DEDENT return res if res != 10 ** 9 else - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 1 , 3 , 1 ] NEW_LINE k = 2 NEW_LINE print ( smallestKFreq ( arr , len ( arr ) , k ) ) NEW_LINE
def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = 64 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' i ' or s [ i ] == ' o ' or s [ i ] == ' u ' ) : NEW_LINE INDENT if ( s [ i ] < c ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT s = " aabbbddeecc " NEW_LINE if areVowelsInOrder ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
for _ in range ( int ( input
def countOfLetters ( str ) : NEW_LINE INDENT letter = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ord ( str [ i ] ) >= ord ( ' A ' and ord ( str [ i ] ) <= ord ( ' Z ' ) ) or ( ord ( str [ i ] ) >= ' a ' and ord ( str [ i ] ) <= ord ( ' z ' ) ) ) : NEW_LINE INDENT letter += 1 NEW_LINE DEDENT DEDENT return letter NEW_LINE DEDENT def countOfNumbers ( str ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ord ( str [ i ] ) >= ord ( ' A ' and ord ( str [ i ] ) <= ord ( ' z ' ) ) ) : NEW_LINE INDENT number += 1 NEW_LINE DEDENT DEDENT return number NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeKs01324" NEW_LINE check ( str ) NEW_LINE DEDENT
while True : NEW_LINE INDENT try : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT A = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT A . append ( int ( input ( ) ) ) NEW_LINE DEDENT ans = A . count ( 0 ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT ranks = [ 0 ] * 510 NEW_LINE n , x = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 1 or x == 2 * n - 1 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT ranks [ 0 ] += 1 NEW_LINE ranks [ 1 ] += 1 NEW_LINE if x < 2 * n - 1 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE print ( ' Yes ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
MAX = 100001 NEW_LINE perfectDiv = [ 0 ] * MAX NEW_LINE def precomputeCounts ( ) : NEW_LINE INDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT perfectDiv [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT return perfectDiv [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT precomputeCounts ( ) NEW_LINE n = 16 NEW_LINE print ( " Total ▁ perfect ▁ divisors ▁ of " , n , " = ▁ " , countPerfectDivisors ( n ) ) NEW_LINE n = 12 NEW_LINE print ( " Total ▁ perfect ▁ divisors ▁ of " , n , " = ▁ " , countPerfectDivisors ( n ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum = 0 NEW_LINE for i in l : NEW_LINE INDENT sum += i NEW_LINE DEDENT print ( sum ) NEW_LINE
n , t , e = map ( int , input ( ) . split ( ) ) NEW_LINE x = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x [ i ] = ( t + e - x [ i ] ) / x [ i ] NEW_LINE DEDENT print ( x [ - 1 ] ) NEW_LINE
def cal_IST ( h , r ) : NEW_LINE INDENT IST = h * r * 1.0 NEW_LINE IST = int ( IST ) NEW_LINE print ( int_IST , end = " : " ) NEW_LINE print ( int_IST ) NEW_LINE DEDENT h = 20 NEW_LINE r = 150 NEW_LINE cal_IST ( h , r ) NEW_LINE
import math NEW_LINE def printRoots ( n ) : NEW_LINE INDENT theta = math . pi * 2 / n NEW_LINE for k in range ( n ) : NEW_LINE INDENT real = math . cos ( k * theta ) NEW_LINE img = sin ( k * theta ) NEW_LINE print ( str ( real ) , end = " ▁ " ) NEW_LINE if ( img >= 0 ) : NEW_LINE INDENT print ( " , ▁ i ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ - ▁ i ▁ " , end = " " ) NEW_LINE DEDENT print ( str ( real ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT printRoots ( 1 ) NEW_LINE printRoots ( 2 ) NEW_LINE printRoots ( 3 ) NEW_LINE DEDENT
def findCart ( arr1 , arr2 , n , n1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n1 ) : NEW_LINE INDENT print ( " { " , arr1 [ i ] , " , ▁ " , arr2 [ j ] , " } , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE findCart ( arr1 , arr2 , n1 , n2 ) NEW_LINE
def no_of_ways ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count_left = 0 NEW_LINE count_right = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [ 0 ] ) : NEW_LINE INDENT count_left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ n - 1 ] ) : NEW_LINE INDENT count_right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ n - 1 ] ) : NEW_LINE INDENT return ( ( count_left + 1 ) * ( count_right + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( count_left + count_right + 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( no_of_ways ( s ) ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ]
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def solve ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT if __name__ ==
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = True NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT def productOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( product ) NEW_LINE D
def findSequences ( diff , out , start , end ) : NEW_LINE INDENT if ( abs ( diff ) > ( end - start + 1 ) / 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT if ( diff == 0 ) : NEW_LINE INDENT print ( out [ 0 , 0 , 0 ) NEW_LINE DEDENT return NEW_LINE DEDENT out [ start ] = '1' NEW_LINE out [ end ] = '1' NEW_LINE findSequences ( diff , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = out [ end ] = '1' NEW_LINE findSequences ( diff , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = out [ end ] = '1' NEW_LINE DEDENT if __name__ == ' _ _ main _
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] == a [ ans ] : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = " ▁ - > ▁ " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( " NULL " ) NEW_LINE DEDENT def cntNodes ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + cntNodes ( node . next ) ) NEW_LINE DEDENT def updateList
def maxSubStrings ( s , k ) : NEW_LINE INDENT maxSubStr = 0 NEW_LINE n = len ( s ) NEW_LINE for c in range ( 26 ) : NEW_LINE INDENT ch = chr ( ord ( ' a ' ) + c ) NEW_LINE curr = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT if ( s [ i ] != ch ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE while ( i < n and s [ i ] == ch and cnt != k ) : NEW_LINE INDENT i += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i = i - 1 NEW_LINE if ( cnt == k ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT DEDENT maxSubStr = max ( maxSubStr , curr ) NEW_LINE DEDENT return maxSubStr NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaacaabbaa " NEW_LINE k = 2 NEW_LINE print ( maxSubStrings ( s , k ) ) NEW_LINE DEDENT
def ansQueries ( prefeven , prefodd , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prefeven [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT D
n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] < a [ i + 1 ] : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT elif a [ i ] > a [ i + 1 ] : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( a ) - max ( a ) - min ( a ) )
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT l . sort ( ) NEW_LINE for i in l [ q : ] : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal ; NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n )
def find_Centroid ( v ) : NEW_LINE INDENT ans = [ 0 ] * 2 NEW_LINE n = len ( v ) NEW_LINE x0 = v [ 0 ] [ 0 ] NEW_LINE y0 = v [ 0 ] [ 1 ] NEW_LINE x1 = v [ ( i + 1 ) % n ] [ 0 ] NEW_LINE y1 = v [ ( i + 1 ) % n ] [ 1 ] NEW_LINE A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE A = ( x0 * A ) - ( x1 * y1 ) NEW_LINE ans [ 0 ] += ( x0 + x1 ) * A NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A NEW_LINE DEDENT vp = [ [ 1 , 2 ] , [ 3 , - 4 ] ,
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT word = input ( ) NEW_LINE if word [ 0 ] == " e " : NEW_LINE INDENT word = word [ 1 : ] + " - " + word [ 2 : ] NEW_LINE DEDENT elif word [ 0 ] == " i " : NEW_LINE INDENT word = word [ 1 : ] + " o " + word [ 2 : ] NEW_LINE DEDENT elif word [ 0 ] == " o " : NEW_LINE INDENT word = word [ 1 : ] + " l " + word [ 2 : ] NEW_LINE DEDENT print ( word ) NEW_LINE DEDENT
def minOperations ( ar , k ) : NEW_LINE INDENT ar . sort ( ) NEW_LINE operationsNeeded = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT operationsNeeded += ar [ k - 1 ] - ar [ i ] NEW_LINE DEDENT ans = operationsNeeded NEW_LINE for i in range ( k , len ( ar ) ) : NEW_LINE INDENT ar [ i - 1 ] = operationsNeeded - ( ar [ i - 1 ] - ar [ i ] ) NEW_LINE operationsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) NEW_LINE ans = min ( ans , operationsNeeded ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 1 , 9 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minOperations ( arr , k ) ) NEW_LINE DEDENT
def charCheck ( input_char ) : NEW_LINE INDENT if ( ( input_char >= 65 and input_char <= 90 ) or ( input_char >= 97 and input_char <= 122 ) ) : NEW_LINE INDENT print ( " ▁ Alphabet ▁ " ) NEW_LINE DEDENT elif ( input_char >= 48 and input_char <= 57 ) : NEW_LINE INDENT print ( " ▁ Digit ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ Special ▁ Character ▁ " ) NEW_LINE DEDENT DEDENT input_char = ' $ ' NEW_LINE charCheck ( input_char ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] == 1 : NEW_LINE INDENT print ( l [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 300000 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i + j ) % 2 == 0 : NEW_LINE INDENT ans = min ( ans , a [ i ] + a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == 3000 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] < b [ j ] : NEW_LINE INDENT a [ i ] = b [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( * a ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) )
def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ctX = 0 NEW_LINE ctY = 0 NEW_LINE for j in range ( i , n - 1 ) : NEW_LINE INDENT if ( arr [ j ] == x ) : NEW_LINE INDENT ctX += 1 NEW_LINE DEDENT elif ( arr [ j ] == y ) : NEW_LINE INDENT ctY += 1 NEW_LINE DEDENT if ( ctX == ctY ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE if len ( s ) >= 3 : NEW_LINE INDENT print ( s . count ( '1' ) + s . count ( '0' ) - s . count ( '1' ) ) NEW_LINE DEDENT elif len ( s ) == 2 : NEW_LINE INDENT print ( s . count ( '0' ) + s . count ( '1' ) - s . count ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( " Agasa " if max ( a ) % 2 == 0
def print_digits ( a ) : NEW_LINE INDENT print ( " ▁ " . join ( str ( a ) ) ) NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT print_digits ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT
import math NEW_LINE def compute ( ) : NEW_LINE INDENT arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE ans = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if ( target % arr [ i ] ) : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] ) : NEW_LINE INDENT toFind = target // ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if ( arr [ k ] == toFind ) : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( " Total ▁ number ▁ of ▁ triplets ▁ found : ▁ " , totalCount ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW
n = int (
def finalNum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = result + __gcd ( result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT return b == 0 and a == 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 9 , 6 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( finalNum ( arr , n ) ) NEW_LINE DEDENT
N = 1000 NEW_LINE lastElement ( a , n ) ; NEW_LINE steps = 1 ; NEW_LINE v = [ [ ] for i in range ( N ) ] ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT v [ i ] = [ ] ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( steps % 2 == 1 ) : NEW_LINE INDENT v [ steps ] . append ( a [ i ] | a [ i +
def number_cake ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 ) // 6 NEW_LINE DEDENT n = 2 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_cake ( n ) ) NEW_LINE
s = input ( ) NEW_LINE t = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' g ' : NEW_LINE INDENT t += 1 NEW_LINE DEDENT else : NEW_LINE INDENT t += 1 NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE
def pattern ( N ) : NEW_LINE INDENT i , j , k = 0 , 0 , 0 NEW_LINE for i in range ( rows , 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( " * " , end = " ▁ " ) NEW_LINE DEDENT if ( i != rows ) : NEW_LINE INDENT for k in range ( 1 , space + 1 ) : NEW_LINE INDENT print ( " * " , end = " ▁ " ) NEW_LINE DEDENT space = space + 2 NEW_LINE DEDENT for j in range ( i , 1 , - 1 ) : NEW_LINE INDENT if ( j != rows ) : NEW_LINE INDENT print ( " * " , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT N = 6 NEW_LINE pattern ( N ) NEW_LINE
def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) // 2 NEW_LINE high = ( n + 1 - k ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 9 , 5 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n = 9 NEW_LINE k = 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE
class TreeNode : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . val = rootData NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def pathSum ( self , root , s ) : NEW_LINE INDENT result = 0 NEW_LINE
def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE
import sys NEW_LINE def printe ( * st ) : NEW_LINE INDENT return True NEW_LINE sys . stderr . write ( " , " . join ( [ str ( x ) for x in st ] ) + " \n " ) NEW_LINE DEDENT def generator ( N , l ) : NEW_LINE INDENT a = 0 NEW_LINE i = 0 NEW_LINE while a < N : NEW_LINE INDENT yield l [ i ] NEW_LINE i += 1 NEW_LINE if i == len ( l ) : NEW_LINE INDENT i = 0 NEW_LINE DEDENT a += 1 NEW_LINE DEDENT DEDENT def simulate ( ) : NEW_LINE INDENT [ n , l , c ] = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE N = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT l . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) NEW_LINE DEDENT l = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT l . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) NEW_LINE DEDENT printe ( * l ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT i = 1 NEW_LINE xyz = n * n + 1 NEW_LINE while i <= xyz : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 2 NEW_LINE DEDENT DEDENT print (xyz - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) NEW_LINE DEDENT DEDENT return maxVal NEW_LINE DEDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxOR ( arr , n ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def numJewelsInStones ( self , J , S ) : NEW_LINE INDENT result = 0 NEW_LINE j = 0 NEW_LINE for j in range ( 0 , len ( S ) ) : NEW_LINE INDENT j = j + 1 NEW_LINE if ( j in S ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE J = " aA " NEW_LINE S = " aAAbbbb " NEW_LINE out = sObj . numJewelsInStones ( J , S ) NEW_LINE print ( out ) NEW_LINE DEDENT
MAX = 100 NEW_LINE n = 3 NEW_LINE store = [ 0 ] * MAX NEW_LINE graph = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 1 ] , [ 4 , 2 ] ] NEW_LINE size = len ( store ) NEW_LINE print ( maxCliques ( 0 , size ) ) NEW_LINE
def setBitNumber ( n ) : NEW_LINE INDENT k = int ( ( n ) / int ( math . log ( n ) ) ) NEW_LINE return ( pow ( 2 , k ) ) NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE
n , m , s , f = map ( int , input ( ) . split ( )
def subsetPairNotDivisibleByK ( arr , N , K ) : NEW_LINE INDENT f = [ 0 ] * K NEW_LINE for i in range ( N ) : NEW_LINE INDENT f [ arr [ i ] % K ] += 1 NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT f [ K // 2 ] = min ( f [ K // 2 ] , 1 ) NEW_LINE DEDENT res = min ( f [ 0 ] , 1 ) NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT res += max ( f [ i ] , f [ K - i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 3 , 7 , 2 , 9 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( subsetPairNotDivisibleByK ( arr , N , K ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE total = r * l NEW_LINE r -= 1 NEW_LINE ans = total // 10 NEW_LINE if r < l : NEW_LINE INDENT ans = total % 10 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " :
def printRoots ( a , b , c ) : NEW_LINE INDENT print ( 1 , " , ▁ " , c / ( a * 1.0 ) ) ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 3 ; NEW_LINE c = - 5 ; NEW_LINE printRoots ( a , b , c ) ; NEW_LINE
dp = [ [ 0 for i in range ( 2 ) ] for j in range ( 2 ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 0 ] [ 0
N = 4 NEW_LINE MaxDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0
def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr < maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def findFibonacciPair ( n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE createHash ( hash , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash . count ( i ) == 1 and hash . count ( n - i ) == 1 ) : NEW_LINE INDENT print ( i , " , ▁ " , ( n - i ) , end = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " - 1 \n " , end = " " ) NEW_LINE DEDENT N = 90 NEW_LINE findFibonacciPair ( N ) NEW_LINE
def countgroup ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT if ( xs == 0 ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countgroup ( a , n ) ) NEW_LINE
def maxLength ( s , n ) : NEW_LINE INDENT ans = - 10 ** 9 NEW_LINE A = [ ] NEW_LINE L = [ ] NEW_LINE R = [ ] NEW_LINE freq = [ 0 ] * n NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n
from math import sqrt NEW_LINE def nCr ( n , m ) : NEW_LINE INDENT a = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = a
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE DEDENT DEDENT if len ( ans ) == 0 : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT elif len ( ans ) == 1 : NEW_LINE INDENT print ( ans [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans [ 0 ] * ans [ 1 : ] ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a * b - a - b + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def isPrime ( k ) : NEW_LINE INDENT if ( k <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , k ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT if ( num % k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findCount ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE if ( isPrime ( k ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( a ,
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( [ " - 1" , " a " ] [ n
from math import sqrt NEW_LINE def precompute ( ) : NEW_LINE INDENT dp = [ 0 ] * ( maxn ) NEW_LINE arr = [ 4 , 6 , 9 ] NEW_LINE for i in range ( maxn ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , maxn ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT j = arr [ k ] NEW_LINE if ( i >= j and dp [ i - j ] != - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp NEW_LINE DEDENT def Maximum_Summands ( dp , n ) : NEW_LINE INDENT if ( n < maxn ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT t = ( n - maxn ) // 4 + 1 NEW_LINE return t + dp [ n -
def countSquares ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 NEW_LINE DEDENT n = 3 NEW_LINE print ( " Count ▁ of ▁ squares ▁ is " , countSquares ( n ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( a [ i ] - 1 ) % m NEW_LINE DEDENT print ( ans ) NEW_LINE
def FindSubarray ( arr , n , k ) : NEW_LINE INDENT count_one = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_one [ i ] = bin ( arr [ i ] ) ; NEW_LINE DEDENT sum = count_one [ 0 ] ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT if ( count_one [ 0 ] >= k ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT ans = 10 ** 9 ; NEW_LINE i = 1 ; NEW
def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) NEW_LINE print ( " Loss ▁ = " , str ( loss ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SP = 2400 NEW_LINE P = 30 NEW_LINE Loss ( SP , P ) NEW_LINE DEDENT
n , m , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE joy = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp2 = ( a [ i ] + 1 ) // x NEW_LINE if ( b [ i ] != temp2 ) : NEW_LINE INDENT temp1 = b [ i ] // x NEW_LINE joy += ( temp1 * temp2 ) NEW_LINE DEDENT DEDENT print ( joy ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE l . append ( x ) NEW_LINE DEDENT l . sort ( ) NEW_LINE if l [ n - 1 ] < l [ n - 2 ] : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( l ) * 2 ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 7 NEW_LINE ans = sum ( i for i in range ( 1 , LIMIT ) if is_89 ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_89 ( x ) : NEW_LINE INDENT while True : NEW_LINE INDENT if is_89 ( x ) : NEW_LINE INDENT return False NEW_LINE DEDENT x = nextNumber ( x ) NEW_LINE DEDENT return True NEW_LINE DEDENT def nextNumber ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += x % 10 NEW_LINE x = int ( x ) NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def countStrings ( str , n ) : NEW_LINE INDENT distinct_char = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char . add ( str [ i ] ) NEW_LINE DEDENT return fact ( distinct_char . size ( ) ) NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE print ( countStrings ( str , n ) ) NEW_LINE
M = 4 NEW_LINE N = 5 NEW_LINE def printCommonElements ( mat ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT mp [ mat [ j ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mp [ mat [ i ] [ j ] ] == i ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if ( i == M - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT mat = [ [ 1 , 2 , 1 , 4 , 8 ] , [ 3 , 7 , 8 , 5 , 1 ] , [ 8 , 7 , 7 , 3 , 1 ] , [ 8 , 7 , 7 , 3 , 1 ] , [ 8 , 7 , 7 , 3 , 1 ] ] NEW_LINE
n = int ( input ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a * ( a + b ) <= b
n , t = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT ans = - 1e18 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if s [ j ] [ 0 ] == s [ j ] [ 1 ] : NEW_LINE INDENT ans = j + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + a ; NEW_LINE a = a + d ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 20 ; NEW_LINE a = 2.5 ; NEW_LINE print ( sumOfAP ( a , d , n ) ) ; NEW_LINE DEDENT
def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = + 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= large ) : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( " No ▁ such ▁ triplet ▁ found " ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( arr [ j ] < small ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small , " ▁ " , large , " ▁ " , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE
def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime [ 0 ] = prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT print ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : " ) ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT n = 96 ; NEW_LINE numbersWith3Divisors ( n ) ; NEW_LINE
def findPairCount ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE rem = [ 0 ] * K NEW_LINE rem [ 0 ] = N // K NEW_LINE rem [ 0 ] = N // K NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem [ i ] = ( N - i ) // K + 1 NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT count += ( rem [ K // 2 ] * ( rem [ K // 2 ] - 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE while n != 0 : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE k = 1 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] - k > a [ i - 1 ] - a [ i ] : NEW_LINE INDENT k = a [ i ] - k NEW_LINE DEDENT DEDENT print ( k ) NEW_LINE n -= 1 NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if sum ( a ) % 2 == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n < 6 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while ( t < n ) : NEW_LINE INDENT fn = ( fn * pow ( fib ( n ) , 2 , 3 , 5 ) ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT n = 9 NEW_LINE print ( n , " th ▁ Fibonacci ▁ Number ▁ = " , fib ( n ) ) NEW_LINE
def kthSmallest ( n , k ) : NEW_LINE INDENT return ( 2 * k ) ; NEW_LINE DEDENT n = 8 ; NEW_LINE k = 4 ; NEW_LINE print ( kthSmallest ( n , k ) ) ; NEW_LINE
n = 5 NEW_LINE def printSumTricky ( mat , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return NEW_LINE DEDENT stripSum = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += mat [ i ] [ j ]
a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT if a == b : NEW_LINE INDENT print ( " No ▁ solution " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT if a == b : NEW_LINE INDENT print ( " No ▁ solution " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a + b ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a == b : NEW_LINE INDENT print ( " No ▁ solution " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a + b ) NEW_LINE DEDENT DEDENT DEDENT
def ncr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE ans /= i NEW_LINE DEDENT return ans NEW_LINE DEDENT def totalWays ( X , Y , M , W ) : NEW_LINE INDENT return ( ncr ( M , X ) * ncr ( W , Y ) ) NEW_LINE DEDENT X = 4 NEW_LINE Y = 3 NEW_LINE M = 6 NEW_LINE print ( totalWays ( X , Y , M , W ) ) NEW_LINE
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n != 0 and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT def removeElement ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = nextPowerOf2 ( n ) NEW_LINE if ( n == a or n == a - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == a - 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeElement ( n ) ) NEW_LINE
n , p = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 1 << 29 NEW_LINE for i in range ( n - p + 1 ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT ans = ans * ( a [ i : i + p ] ) + a [ i + p - 1 : ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE
def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sum += x % 10 ; NEW_LINE x = x // 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 and sumOfDigits ( i ) % 3 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT l = 1000 ; NEW_LINE r = 6000 ; NEW_LINE print ( countNumbers ( l , r ) ) ; NEW_LINE
def findGreater ( a , b ) : NEW_LINE INDENT x = ( a * ( b ) ) NEW_LINE y = b * ( a ) NEW_LINE if ( y > x ) : NEW_LINE INDENT print ( " a ^ b ▁ is ▁ greater " ) NEW_LINE DEDENT elif ( y < x ) : NEW_LINE INDENT print ( " b ^ a ▁ is ▁ equal " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " both ▁ are ▁ equal " ) NEW_LINE DEDENT DEDENT a , b = 3 , 5 , 2 NEW_LINE c = 2 NEW_LINE d = 4 NEW_LINE findGreater ( a , b ) NEW_LINE findGreater ( c , d ) NEW_LINE
def findAnswer ( str1 , str2 , n ) : NEW_LINE INDENT l = 0 ; r = 0 ; NEW_LINE ans = 2 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT l = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT r = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( r < l ) : NEW_LINE INDENT return 26 * ( n + 1 ) ; NEW_LINE DEDENT elif ( l == r ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( l +
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , x , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = set ( a ) NEW_LINE if x in s : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m ) NEW_LINE DEDENT DEDENT
def bitsAreInAltPatToQueueGivenRatOverlap ( n , l , r ) : NEW_LINE INDENT num = n >> ( l - 1 ) NEW_LINE prev = num & 1 NEW_LINE num = num & 1 NEW_LINE for i in range ( 1 , ( r - l ) + 1 ) : NEW_LINE INDENT curr = num & 1 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE num = num >> 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if ( bitsAreInAltPatToQueueGivenRatOverlap ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = " " NEW_LINE for i in range ( k ) : NEW_LINE INDENT ans += "1" NEW_LINE DEDENT ans += "0" * ( n - ( a [ i ] - 1 ) // 2 ) NEW_LINE print ( ans ) NEW_LINE
def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( a ) - ( k - ( a [ i ] + a [ i + 1 ] ) // 2 ) ) NEW_LINE
MAX = 1000000 NEW_LINE def maximumOccurredElement ( L , R , n ) : NEW_LINE INDENT arr = [ 0 ] * MAX NEW_LINE maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ L [ i ] ] += 1 NEW_LINE arr [ R [ i ] + 1 ] -= 1 NEW_LINE if ( R [ i ] > maxi ) : NEW_LINE INDENT maxi = R [ i ] NEW_LINE DEDENT DEDENT msum = arr [ 0 ] NEW_LINE ind = 0 NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE if ( msum < arr [ i ] ) : NEW_LINE INDENT msum = arr [ i ] NEW_LINE ind = i NEW_LINE DEDENT DEDENT return ind NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = [ 1 , 4 , 9 , 13 , 21 ] NEW_LINE R = [ 15 , 8 , 12 , 20 , 30 ] NEW_LINE n = len ( L ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if l [ i ] != l [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , n - 1 ) NEW_LINE DEDENT DEDENT elif m == 1 : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT print ( 1 , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , n - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n > m : NEW_LINE INDENT print ( m + n , m - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , m ) NEW_LINE DEDENT DEDENT
def func ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x * x ) ) NEW_LINE DEDENT def calculate ( lower_limit , upper_limit , interval_limit ) : NEW_LINE INDENT value = interval_limit - lower_limit NEW_LINE interval_size = ( upper_limit - lower_limit ) / interval_limit NEW_LINE sum = ( func ( lower_limit ) + func ( upper_limit ) ) NEW_LINE for i in range ( 1 , interval_limit ) : NEW_LINE INDENT if ( i % 3 == 0 ) : NEW_LINE INDENT sum = sum + 2 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + 3 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT DEDENT return ( 3 * interval_size / 8 ) * sum NEW_LINE DEDENT interval_limit = 10 NEW_LINE lower_limit = 1 NEW_LINE upper_limit = 10 NEW_LINE integral_res = calculate ( lower_limit , upper_limit , interval_limit ) NEW_LINE print ( " % . 4f " , integral_res
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE if n > k : NEW_LINE INDENT ans += ( x * k ) NEW_LINE ans += ( y * k ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += x * n NEW_LINE DEDENT print ( ans ) NEW_LINE
import math NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT x , h = map ( float , input ( ) . split ( ) ) NEW_LINE temp = ( h * h + ( x / 2 ) * ( x / 2 ) ) ** 0.5 NEW_LINE print ( temp ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
k = int ( input ( ) ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT n = input ( ) NEW_LINE if n == '0' and n == '9' : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n == '1' and n == '9' : NEW_LINE INDENT print ( ( 10 * ( i + 1 ) ) + ( int ( n ) - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( int ( n ) - 1 ) ) NEW_LINE DEDENT DEDENT
MAX = 1000000 NEW_LINE prime = [ True ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def printPrime Quad ( n ) : NEW_LINE INDENT for i in range ( n - 7 , - 1 , - 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] ) : NEW_LINE INDENT print ( i , i , i + 2 , 6 ) NEW_LINE DEDENT DEDENT DEDENT n = 20 NEW_LINE sieve ( ) NEW_LINE printPrime Quad ( n ) NEW_LINE
MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_
def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE
s = input ( ) NEW_LINE t = input ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT l . append ( t [ i ] ) NEW_LINE DEDENT l . sort ( ) NEW_LINE for i in l : NEW_LINE INDENT if s [ i ] in l : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
MAX = 1000 NEW_LINE sequence = [ 0 ] * MAX NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT vanEckSequence ( ) NEW_LINE n = 6 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE DEDENT
MAX = 100000 ; NEW_LINE sequence = [ 0 ] * MAX ; NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 ; NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT count = 1 ; NEW_LINE i = n - 1 ; NEW_LINE while ( sequence [ i + 1 ] != 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE i = i - sequence [ i + 1 ] ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT vanEckSequence ( ) ; NEW_LINE n = 5 ; NEW_LINE print ( getCount ( n ) ) ; NEW_LINE n = 11 ; NEW_LINE print ( getCount ( n ) ) ; NEW_LINE DEDENT
MAX = 100000 ; NEW_LINE sequence = [ 0 ] * MAX ; NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 ; NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT nthTerm = sequence [ n - 1 ] ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sequence [ i ] == nthTerm ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT vanEckSequence ( ) ; NEW_LINE n = 5 ; NEW_LINE print ( getCount ( n ) ) ; NEW_LINE n = 11 ; NEW_LINE print ( getCount ( n ) )
from math import gcd NEW_LINE def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) / gcd ( a , b ) ; NEW_LINE l = 1 ; r = min ( a , b ) * n ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 ; NEW_LINE val = mid // a + mid // b - mid // lcm ; NEW_LINE if ( val == n ) : NEW_LINE INDENT return max ( mid // a , ( mid // b ) * b ) ; NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 5 ; NEW_LINE b = 3 ; NEW_LINE n = 5 ; NEW_LINE print ( nthElement ( a , b , n ) ) ; NEW_LINE DEDENT
y = int ( input ( ) ) NEW_LINE billCompleted = False NEW_LINE bills = [ 1 , 5 , 7 , 11 , 13 ] NEW_LINE i = 4 NEW_LINE billCount = 0 NEW_LINE while not billCompleted : NEW_LINE INDENT temp = bills [ i ] NEW_LINE billCount += temp NEW_LINE i -= 1 NEW_LINE if i == 4 : NEW_LINE INDENT if billCount % 7 == 0 : NEW_LINE INDENT billCompleted = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( billCount ) NEW_LINE
import sys NEW_LINE def solve ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' H ' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == ' OK ' : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( s ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
from math import gcd NEW_LINE def findValue ( x , y , z ) : NEW_LINE INDENT __gcd ( y , z ) NEW_LINE return __gcd ( x , y - z ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 30 NEW_LINE y = 40 NEW_LINE z = 400 NEW_LINE print ( findValue ( x , y , z ) ) NEW_LINE DEDENT
a , b , c , d = map ( float , input ( ) . split ( ) ) NEW_LINE k = ( - a * x1 - b * y1 - c * z1 ) / ( a * a + b * b + c * c ) NEW_LINE x2 = a * k + b * k + c * k + d NEW_LINE y2 = a * k + b * k + c * k + d NEW_LINE print ( ' x2 ▁ = ▁ { } ' . format ( x2 ) , ' y2 ▁ = ▁ { } ' . format ( y2 ) , ' z2 ▁ = ▁ { } ' . format ( z2 ) , ' % .1f ' ) NEW_LINE
a = input ( ) NEW_LINE b = input ( ) NEW_LINE if a [ 0 ] == b [ 0 ] and b [ 1 ] == b [ 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small , large = min ( ar ) , max ( ar ) NEW_LINE dp = [ 0 for i in range ( small + 1 ) ] NEW_LINE for j in range ( large + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [
PI = 3.14159265 NEW_LINE def area_leaf ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 - 1 ) ) NEW_LINE DEDENT a = 7 NEW_LINE print ( area_leaf ( a ) ) NEW_LINE
def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n // 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) // 2 ) ) + 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if ( n == 2 or m == 2 or n % m == 0 ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 3 ; n = 9 ; NEW_LINE check ( n , m ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT m , n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( negProdSubArr ( arr , n ) ) NEW_LINE
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT def posProdSubArr ( arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) // 2 NEW_LINE cntNeg = negProdSubArr ( arr , n ) NEW_LINE return ( total - cntNeg ) NEW_LINE DEDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( posProdSubArr ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n - ( k - 1 ) + ( n - k + 1 ) // k ) ) NEW_LINE DEDENT
import math NEW_LINE x , y , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = math . gcd ( x , y ) NEW_LINE x = x % a NEW_LINE y = y % b NEW_LINE if x < y : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT print ( int ( math . gcd ( x , y ) ) + 1 ) NEW_LINE
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 ] * n NEW_LINE LIS [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT LIS [ j ] = 0 NEW_LINE DEDENT return n - LIS NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE DEDENT
def print_max ( a , n , k ) : NEW_LINE INDENT max_upto = [ 0 ] * n ; NEW_LINE s = [ ] ; NEW_LINE s . append ( 0 ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) > 0 and a [ s [ - 1 ] ] < a [ i ] ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = i - 1 ; NEW_LINE s . pop ( ) ; NEW_LINE DEDENT s . append ( i ) ; NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = n - 1 ; NEW_LINE s . pop ( ) ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT while ( j < i
import math NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( digit_sum ( ( x ) + 1 for x in range ( 1 , 1001 ) ) for x in range ( 1 , 1001 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countWindowDistinct ( arr , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( win [ arr [ i ] ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT DEDENT return dist_count NEW_LINE DEDENT def countDistinct ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT print ( countWindowDistinct ( arr , i , arr [ i + k ] ) ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 , 3 ] , k = 4 NEW_LINE countDistinct ( arr , n , k ) NEW_LINE
def evenNumSubstring ( str ) : NEW_LINE INDENT len = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "1234" NEW_LINE print ( evenNumSubstring ( str ) ) NEW_LINE DEDENT
def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if index == n : NEW_LINE INDENT if cnt == k : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if dp [ index ] [ cnt ] != - 1 : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE return dp [ index ] [ cnt ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE k = 2 NEW_LINE dp = [ [ - 1 ] * ( max ( 4 , 0 , dp , n , m , k ) ] for i in range ( n + 1 ) ] NEW_LINE print ( countWays ( 1 , 0
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + ( n / i ) NEW_LINE DEDENT DEDENT DEDENT return sum - n NEW_LINE DEDENT def printAliquot ( n ) : NEW_LINE INDENT print ( " " , n ) NEW_LINE s = set ( ) NEW_LINE s . add ( n ) NEW_LINE next = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = getSum ( n ) NEW_LINE if ( s . count ( n ) and n != s . last ( ) ) : NEW_LINE INDENT print ( " \n " , end = " " ) NEW_LINE break NEW_LINE DEDENT print ( n , end = " ▁ " ) NEW_LINE s . add ( n ) NEW_LINE DEDENT
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE
def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT arr [ i ] , arr [ n + ~ i + 1 ] = arr [ n + ~ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT def swap ( arr , i , j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , temp NEW_LINE return arr NEW_LINE DEDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE a = 1 NEW_LINE cnt = 0 NEW_LINE flag = True NEW_LINE sum += a NEW_LINE while ( cnt < N ) : NEW_LINE INDENT nextElement = a * 2 NEW_LINE if ( flag == True ) : NEW_LINE INDENT nextElement = a * 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * 3 / 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT a = nextElement NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT N = 8 NEW_LINE printSeriesSum ( N ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if gcd ( a , b ) == 1 : NEW_LINE INDENT print ( 1 , b ) NEW_LINE DEDENT elif gcd ( b , a ) == 0 : NEW_LINE INDENT print ( 1 , a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , b ) NEW_LINE DEDENT DEDENT
sz = 1e5 NEW_LINE isPrime = [ 1e5 ] NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , sz + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz + 1 , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def minDifference ( L , R ) : NEW_LINE INDENT fst = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW
def getMaxLength ( arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE preCnt = 0 NEW_LINE while ( start < n and arr [ start ] == 1 ) : NEW_LINE INDENT preCnt += 1 NEW_LINE start += 1 NEW_LINE DEDENT end = n - 1 NEW_LINE suffCnt = 0 NEW_LINE while ( end >= 0 and arr [ end ] == 1 ) : NEW_LINE INDENT suffCnt += 1 NEW_LINE end -= 1 NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT return n NEW_LINE DEDENT midCnt = 0 NEW_LINE result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT midCnt += 1 NEW_LINE result = max ( result , midCnt ) NEW_LINE DEDENT else : NEW_LINE INDENT midCnt = 0 NEW_LINE DEDENT DEDENT return max ( result , preCnt + suffCnt ) NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len (
d , n = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print (
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( s [ 0 ] , s [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT i = 2 NEW_LINE flag = True NEW_LINE while i <= n : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT i += 2 NEW_LINE flag = False NEW_LINE DEDENT else : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT i += 1 NEW_LINE flag = True NEW_LINE DEDENT DEDENT DEDENT if flag : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( i + 1 , i + 2 ) NEW_LINE DEDENT DEDENT
def sqroot ( s ) : NEW_LINE INDENT pSq = 0 ; NEW_LINE N = 0 ; NEW_LINE for i in range ( ( s ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i ; NEW_LINE N = j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT d = s - pSq ; NEW_LINE P = d / ( 2.0 * N ) ; NEW_LINE A = N + P ; NEW_LINE sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; NEW_LINE return sqrt_of_s ; NEW_LINE DEDENT num = 9.2345f ; NEW_LINE sqroot_of_num = sqroot ( num ) ; NEW_LINE print ( " Square ▁ root ▁ of ▁ " , num , " ▁ = ▁ " , int ( sqroot_of_num * 100000.0
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT ranks = [ 0 ] * 510 NEW_LINE n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT h = int ( input ( ) ) NEW_LINE if h > 1 : NEW_LINE INDENT if h <= 510 : NEW_LINE INDENT ranks [ ( h - 1 ) // 2 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ranks [ ( h - 1 ) // 2 ] += 1 NEW_LINE DEDENT DEDENT elif h > 1 : NEW_LINE INDENT if h <= 510 : NEW_LINE INDENT ranks [ ( h - 1 ) // 2 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ranks [ ( h - 1 ) // 2 ] += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ranks [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ]
while 1 : NEW_LINE INDENT r , n = map ( int , input ( ) . split ( ) ) NEW_LINE if r == 0 : break NEW_LINE prv = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT prv = map ( int , input ( ) . split ( ) ) NEW_LINE prv = max (
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE print ( 2 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] + a [ i + 1 ] ) <= n - i : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT try : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT if num == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT A = [ ] NEW_LINE for i in range ( num ) : NEW_LINE INDENT A . append ( int ( input ( ) ) ) NEW_LINE DEDENT B = [ ] NEW_LINE for i in range ( num ) : NEW_LINE INDENT B . append ( int ( input ( ) ) ) NEW_LINE DEDENT C = [ ] NEW_LINE for i in range ( num ) : NEW_LINE INDENT C . append ( int ( input ( ) ) ) NEW_LINE DEDENT if B [ 0 ] == B [ 1 ] == B [ 2 ] == B [ 3 ] == B [ 4 ] == B [ 5 ] == B [ 6 ] == B [ 7 ] == B [ 8 ] == '9' : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT elif B [ 0 ] == B [ 1 ] == B [ 2 ] == B [ 3 ] == B [ 4 ] == B [ 6 ] == B [ 8 ] == '9' : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT elif B [ 0 ] == B [ 2 ] == B [ 3 ] == B [ 4 ]
def maxAlternateSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ 0 ] * n NEW_LINE inc = [ 0 ] * n NEW_LINE dec [ 0 ] = inc [ 0 ] = arr [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ j ] < arr [ i ] and flag == 1 ) : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec
def generateArr ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] & arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev & arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev & arr [ n - 1 ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT prev = arr [ 0 ] ; NEW_LINE arr [ 0 ] = arr [ 0 ] + arr [ 1 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] ; NEW_LINE arr [ i ] = prev + arr [ i + 1 ] ; NEW_LINE prev = curr ; NEW_LINE DEDENT arr [ n - 1 ] = prev + arr [ n - 1 ] ; NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE ReplaceElements ( arr , n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT
def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if ( i * k > j * j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT A = 3 NEW_LINE B = 2 NEW_LINE C = 2 NEW_LINE print ( countTriplets ( A , B , C ) ) NEW_LINE
MAX = 100000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def smallestPrime ( d ) : NEW_LINE INDENT l = pow ( 10 , d - 1 )
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE mapp = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT mapp . append ( int ( input ( ) ) ) NEW_LINE DEDENT mas = 0 NEW_LINE ans = 0 NEW_LINE for dice in range ( m ) : NEW_LINE INDENT mas += int ( input ( ) ) NEW_LINE ans += dice * ( mas - 1 ) NEW_LINE DEDENT print ( ans
n , k , x = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE if s == x : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if l [ i ] > l [ i + k - 1 ] : NEW_LINE INDENT l [ i ] , l [ i + k - 1 ] = l [ i + k - 1 ] , l [ i ] NEW_LINE DEDENT DEDENT print ( sum ( l ) ) NEW_LINE DEDENT
n , m , a , d = map ( int , input ( ) . split ( ) ) NEW_LINE a -= 1 ; NEW_LINE b = ( a - 1 ) // ( n + 1 ) ; NEW_LINE c = ( a - 1 ) // ( n + 1 ) ; NEW_LINE print ( max ( 0 , max ( b - d , n - c ) - ( a - 1 ) * b ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += ( ( l [ i ] * 2 ) + 1 ) NEW_LINE DEDENT print ( s ) NEW_LINE
s = input ( ) NEW_LINE if s . count ( ' First ' ) % 2 == 0 and s . count ( ' Second ' ) % 2 == 0 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT elif s . count ( ' Second ' ) % 2 == 0 and s . count ( ' First ' ) % 2 == 0 : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT elif s . count ( ' First ' ) % 2 == 1 and s . count ( ' Second ' ) % 2 == 1 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT
def reverse ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT def getSum ( n ) : NEW_LINE INDENT n = reverse ( n ) NEW_LINE sumOdd = 0 NEW_LINE sumEven = 0 NEW_LINE c = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( c % 2 == 0 ) : NEW_LINE INDENT sumEven += n % 10 NEW_LINE DEDENT else : NEW_LINE INDENT sumOdd += n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE c += 1 NEW_LINE DEDENT print ( " Sum ▁ odd ▁ = " , sumOdd ) NEW_LINE print ( " Sum ▁ even ▁ = " , sumEven ) NEW_LINE DEDENT n = 457892 NEW_LINE getSum ( n ) NEW_LINE
def disp ( row_no , block ) : NEW_LINE INDENT print ( row_no * block ) NEW_LINE DEDENT def row_no ( ht , h ) : NEW_LINE INDENT return ht // h NEW_LINE DEDENT def calculate ( l , w , h , a , ht ) : NEW_LINE INDENT no_block = ( 4 * a ) // l NEW_LINE row_no = row ( ht , w ) NEW_LINE disp ( row_no , no_block ) NEW_LINE DEDENT l = 50 NEW_LINE w = 20 NEW_LINE h = 35 NEW_LINE calculate ( l , w , h , a , ht ) NEW_LINE
def bin ( s ) : NEW_LINE INDENT binary = "000" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT binary += bin [ ord ( s [ i ] ) - ord ( '0' ) ] NEW_LINE DEDENT binary = binary [ : : - 1 ] NEW_LINE count = 1 NEW_LINE prev = - 1 NEW_LINE j = 0 NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( binary [ i ] == '1' ) : NEW_LINE INDENT count = max ( count , j - prev ) NEW_LINE prev = j NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT octal = "13" NEW_LINE print ( maxFreq ( octal ) ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) ; NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT cv = [ 0 ] * n ; NEW_LINE cc = [ 0 ] * n ; NEW_LINE if ( isVowel ( s [ 0 ] ) ) : NEW_LINE INDENT cv [ 0 ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cv [ 0 ] = 1 ; NEW_LINE DEDENT cc [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n
def harmonicMean ( arr , freq , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE frequency_sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + freq [ i ] / arr [ i ] ; NEW_LINE frequency_sum = frequency_sum + freq [ i ] ; NEW_LINE DEDENT return ( frequency_sum / sum ) ; NEW_LINE DEDENT num = [ 13 , 14 , 15 , 16 , 17 ] ; NEW_LINE freq = [ 2 , 5 , 13 , 7 , 3 ] ; NEW_LINE n = len ( num ) ; NEW_LINE print ( " % . 4f " , harmonicMean ( num , freq , n ) ) ; NEW_LINE
def polyarea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a * a * n ) / ( 4 * Math . tan ( ( 180 / n ) * PI / 180 ) ) NEW_LINE return A NEW_LINE DEDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( " % .3f " , polyarea ( n , a ) ) NEW_LINE
import math NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) ; NEW_LINE DEDENT return __gcd ( a , b - a ) ; NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a // math . gcd ( a , b ) * b ) ; NEW_LINE DEDENT def getMin ( c ) : NEW_LINE INDENT ans = - 1 if ( c == 0 ) else max ( a , b ) ; NEW_LINE for i in range ( 1 , math . ceil ( math . sqrt ( c ) ) + 1 ) : NEW_LINE INDENT if ( c % i == 0 and lcm ( i , c // i ) == c ) : NEW_LINE INDENT ans = min ( ans , max ( i , c // i ) ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_
import sys NEW_LINE def solve ( m , n , prices ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( m , n + 1 ) : NEW_LINE INDENT t = prices [ i : i + m ] NEW_LINE if len ( t ) == m : NEW_LINE INDENT t [ - 1 ] = 0 NEW_LINE DEDENT ans = max ( ans , t [ - 1 ] + t [ : - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE prices = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = solve ( m , n , prices ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( a == b ) :
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE print ( a [ - 1 ] , 1 , a [ - 2 ] ) NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT fibo = 2.078087F * float ( n ) + 1.672276F NEW_LINE return round ( fibo ) NEW_LINE DEDENT n = 21 NEW_LINE print ( findIndex ( n ) ) NEW_LINE

def minSwaps ( s1 , s2 ) : NEW_LINE INDENT c0 = 0 NEW_LINE c1 = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == '0' and s2 [ i ] == '1' ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT elif ( s1 [ i ] == '1' and s2 [ i ] == '0' ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT ans = c0 / 2 + c1 / 2 NEW_LINE if ( c0 % 2 == 0 and c1 % 2 == 0 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT elif ( c0 + c1 ) % 2 == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = "0011" NEW_LINE s2 = "1111" NEW_LINE ans = minSwaps ( s1 , s2 ) NEW_LINE print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans +=
s = input ( ) NEW_LINE n = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] <= '9' and s [ i ] >= '0' : NEW_LINE INDENT ans += int ( s [ i ] ) * ( n - i - 1 ) NEW_LINE DEDENT DEDENT if ans == 0 : NEW_LINE INDENT print ( ' no ' ) NEW_LINE DEDENT elif ans < int ( s ) : NEW_LINE INDENT print ( ' left ' ) NEW_LINE DEDENT elif ans == int ( s ) : NEW_LINE INDENT print ( ' right ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' left ' ) NEW_LINE DEDENT
def normalSieve ( n ) : NEW_LINE INDENT prime = [ True ] * ( n // 2 ) ; NEW_LINE for i in range ( 3 , n // 2 , 2 ) : NEW_LINE INDENT if ( prime [ i // 2 ] == False ) : NEW_LINE INDENT for j in range ( i * i , n , i * 2 ) : NEW_LINE INDENT prime [ j // 2 ] = False ; NEW_LINE DEDENT DEDENT DEDENT print ( "2 ▁ " , end = " " ) ; NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT if ( prime [ i // 2 ] == False ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT n = 100 ; NEW_LINE normalSieve ( n ) ; NEW_LINE
s = input ( ) NEW_LINE a = s . count ( ' a ' ) NEW_LINE b = s . count ( ' b ' ) NEW_LINE c = s . count ( ' c ' ) NEW_LINE print ( min ( a , b , c ) ) NEW_LINE
def frequencyOfSmallest ( n , arr ) : NEW_LINE INDENT mn = arr [ 0 ] NEW_LINE freq = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < mn ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE freq = 1 NEW_LINE DEDENT elif ( arr [ i ] == mn ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 3 , 2 , 3 , 4 , 4 ] NEW_LINE print ( frequencyOfSmallest ( N , arr ) ) NEW_LINE DEDENT
def isSubArray ( A , B , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE if ( j == m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i = i - j + 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT A = [ 2 , 3 , 0 , 5 , 1 , 1 , 2 ] NEW_LINE n = len ( A ) NEW_LINE B = [ 3 , 0 , 5 , 1 ] NEW_LINE m = len ( B ) NEW_LINE if ( isSubArray ( A , B , n , m ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans += abs ( l [ i + 1 ] - l [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] not in ans : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT N , K = map ( int , readline ( ) . split ( " , " ) ) NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res += ( i + 1 ) ** 2 NEW_LINE DEDENT write ( " % d \n " % res ) NEW_LINE DEDENT solve ( ) NEW_LINE
MAX = 100 NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , - 1 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT def sumOfproduct ( n ) : NEW_LINE INDENT return binomialCoeff ( 2 * n , n - 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( sumOfproduct ( n ) ) NEW_LINE
s = input ( ) NEW_LINE print ( " ▁ " . join ( s [ : : - 1 ] ) ) NEW_LINE
def pairCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( max_val + 1 ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count * ( count - 1 ) ) // 2 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n
def getPrime ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( max_val + 1 ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT maximum = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT arr = [ 2 , 10 , 15 , 7 , 6 , 8 , 13 ] NEW_LINE

def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE
def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a * b ) NEW_LINE
def nth_term ( a , b , n ) : NEW_LINE INDENT z = 0 NEW_LINE if ( n % 6 == 1 ) : NEW_LINE INDENT z = a NEW_LINE DEDENT elif ( n % 6 == 2 ) : NEW_LINE INDENT z = b NEW_LINE DEDENT elif ( n % 6 == 3 ) : NEW_LINE INDENT z = b - a NEW_LINE DEDENT elif ( n % 6 == 4 ) : NEW_LINE INDENT z = - a NEW_LINE DEDENT elif ( n % 6 == 0 ) : NEW_LINE INDENT z = - a NEW_LINE DEDENT return z NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 17 NEW_LINE n = 3 NEW_LINE print ( nth_term ( a , b , n ) ) NEW_LINE DEDENT
def findSubSequence ( s , num ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( num ) : NEW_LINE INDENT if ( ( num & 1 ) == 1 ) : NEW_LINE INDENT res += s [ i ] - '0' NEW_LINE DEDENT i += 1 NEW_LINE num = num >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def combinedSum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c_sum = 0 NEW_LINE range = ( 1 << n ) - 1 NEW_LINE for i in range ( range + 1 ) : NEW_LINE INDENT c_sum += findSubSequence ( s , i ) NEW_LINE DEDENT return c_sum NEW_LINE DEDENT s = "123" NEW_LINE print ( int ( combineSum ( s ) ) ) NEW_LINE
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 ; dp2 = 0 ; dp1 = 0 ; dp2 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) ; NEW_LINE dp2 = dp1 ; dp1 = dp0 ; NEW_LINE DEDENT return min ( dp1 , dp2 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( minimumCost ( a , n ) ) ; NEW_LINE DEDENT
def countMultiples ( n ) : NEW_LINE INDENT return n // 3 + n // 7 - n // 21 NEW_LINE DEDENT print ( " Count ▁ = " , countMultiples ( 25 ) ) NEW_LINE
defSubstring ( str1 , k ) : NEW_LINE INDENT freq = [ 0 ] * len ( str1 ) NEW_LINE ch = str1 [ : : - 1 ] NEW_LINE start = 0 NEW_LINE maxLen = 0 NEW_LINE ch = str1 [ : : - 1 ] NEW_LINE n = len ( ch ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ch = ch + ch NEW_LINE freq [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( freq [ ord ( ch ) - ord ( ' a ' ) ] > k ) : NEW_LINE INDENT if ( maxLen < ( i - start ) ) : NEW_LINE INDENT maxLen = i - start NEW_LINE DEDENT while ( freq [ ch ] > k ) : NEW_LINE INDENT freq [ ord ( ch ) - ord ( ' a ' ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT if ( maxLen < ( n - start ) ) : NEW_LINE INDENT maxLen = n - start NEW_LINE DEDENT return maxLen NEW_LINE DEDENT str1 = " bab
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE s . append ( [ x , y ] ) NEW_LINE DEDENT ans = " A " if abs ( s [ 0 ] [ 1 ] - s [ 1 ] [ 0 ] ) + abs ( s [ 0 ] [ 2 ] - s [ 1 ] [ 1 ] ) + abs ( s [ 1 ] [ 3 ] - s [ 0 ] [ 2 ] ) NEW_LINE if abs ( s [ 1 ] [ 1 ] - s [ 1 ] [ 0 ] ) + abs ( s [ 0 ] [ 2 ] - s [ 1 ] [ 1 ] ) > 0 else ans NEW_LINE if abs ( s [ 1 ] [ 1 ] - s [ 1 ] [ 0 ] ) + abs ( s [ 0 ] [ 2 ] - s [ 1 ] [ 1 ] ) + abs ( s [ 0 ] [ 3 ] - s [ 1 ] [ 1 ] ) NEW_LINE print ( ans ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def Hex_map ( self , num ) : NEW_LINE INDENT res = " " NEW_LINE while ( num != 0 and num & 15 ) : NEW_LINE INDENT res = res + chr ( num & 15 ) + res NEW_LINE num = num >> 4 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 26 NEW_LINE out = sObj . Hex_map ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k % 2 == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 and k != 1 : NEW_LINE INDENT print ( " L " ) NEW_LINE k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " S " ) NEW_LINE k += 1 NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT
def longestString ( string1 , string2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( string1 ) ) : NEW_LINE INDENT count1 [ ord ( string1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( string2 ) ) : NEW_LINE INDENT count2 [ ord ( string2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result += chr ( ord ( ' a ' + i ) ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string1 = " geeks " NEW_LINE string2 = " cake " NEW_LINE longestString ( string1 , string2 ) NEW_LINE DEDENT
def msb ( x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( ( x >> ( ret + 1 ) ) != 0 ) : NEW_LINE INDENT ret += 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def xorRange ( l , r ) : NEW_LINE INDENT max_bit = msb ( r ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , max_bit + 1 ) : NEW_LINE INDENT if ( ( l // mul ) * mul == ( r // mul ) * mul ) : NEW_LINE INDENT if ( ( l & ( 1 << i ) ) != 0 ) and ( r - l + 1 ) % 2 == 1 : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2
def q1 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q2 ( s , i ) : NEW_LINE INDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE p [ i + a ] = p [ i + b ] = a NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT b , c = map ( int , input ( ) . split ( ) ) NEW_LINE p [ i + b ] = c NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( p [ i ] ) NEW_LINE DEDENT DEDENT
def findTime ( T , K ) : NEW_LINE INDENT minutes = ( ( T [ 0 ] - '0' ) * 10 + T [ 1 ] - '0' ) * 60 + ( ( T [ 3 ] - '0' ) * 10 + T [ 4 ] - '0' ) ; NEW_LINE minutes += K ; NEW_LINE hour = ( minutes // 60 ) % 24 ; NEW_LINE min = minutes % 60 ; NEW_LINE if ( hour < 10 ) : NEW_LINE INDENT print ( "0" + hour , end = " : " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( hour , end = " : " ) ; NEW_LINE DEDENT DEDENT T = "21:39" ; NEW_LINE K = 43 ; NEW_LINE findTime ( T , K ) ; NEW_LINE
def maxProductSum ( str , m ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxProd = - 10 ** 9 NEW_LINE maxSum = 0 NEW_LINE for i in range ( n - m ) : NEW_LINE INDENT product = 1 NEW_LINE sum = 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( str [ j ] ) NEW_LINE sum = sum + ( str [ j ] - '0' ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( " Maximum ▁ Product ▁ = " , maxProd ) NEW_LINE print ( " Maximum ▁ Sum ▁ = " , maxSum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " 3675356291 " NEW_LINE m = 5 NEW_LINE maxProductSum ( str , m ) NEW_LINE DEDENT
def minCost ( x , y , z ) : NEW_LINE INDENT if ( x < y ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return z NEW_LINE DEDENT DEDENT def minCost ( cost , m , n ) : NEW_LINE INDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT elif ( m == 0 and n == 0 ) : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) NEW_LINE DEDENT DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT j = i * 2 + 1 NEW_LINE ans = min ( ans , abs ( a [ j ] - a [ i * 2 ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE
def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( i % M == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT A = 6 NEW_LINE B = 15 NEW_LINE M = 3 NEW_LINE print ( sumDivisibles ( A , B , M ) ) NEW_LINE
def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = ( int ) ( n ) NEW_LINE a = [ 0 for i in range ( d + 2 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + ( int ) ( pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = int ( pow ( 10 , d ) ) NEW_LINE msd = n // p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( int ) ( a [ d ] ) * a [ d ] + p + countNumbersWith4 ( n % p ) NEW
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( k % ( 1000000000 + 7 ) ) NEW_LINE
import sys NEW_LINE def findPostOrderUtil ( pre , n , minval , maxval , preIndex ) : NEW_LINE INDENT if preIndex . data == n : NEW_LINE INDENT return NEW_LINE DEDENT if pre [ preIndex . data ] < minval or pre [ preIndex . data ] > maxval : NEW_LINE INDENT return NEW_LINE DEDENT val = pre [ preIndex . data ] NEW_LINE preIndex . data += 1 NEW_LINE findPostOrderUtil ( pre , n , minval , val , preIndex ) NEW_LINE findPostOrderUtil ( pre , n , val , maxval , preIndex ) NEW_LINE print ( val , end = " ▁ " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE n = len ( sys . argv ) NEW_LINE findPostOrder ( pre , n ) NEW_LINE DEDENT
def countWays ( n , arr , k ) : NEW_LINE INDENT if ( k <= 0 or k >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT if ( len ( s ) <= k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return len ( s ) - k NEW_LINE DEDENT arr = [ 100 , 200 , 400 , 50 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( countWays ( n , arr , k ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = input ( ) . split ( ' : ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if len ( l [ i ] ) == 2 and l [ i ] [ 0 ] == l [ i ] [ 1 ] : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT elif len (
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT return ( flag == 1 ) NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def countInterestingPrimes ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if ( isPerfectSquare ( i - j * j * j ) ) : NEW_LINE INDENT answer += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT N = 10 NEW_LINE print ( countInterestingPrimes ( N ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' a ' : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT elif s [ i ] == ' b ' : NEW_LINE INDENT b . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT for i in a : NEW_LINE INDENT if s [ i ] == ' b ' : NEW_LINE INDENT b . append ( i ) NEW_LINE DEDENT elif s [ i ] == ' a ' : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT for i in b : NEW_LINE INDENT if s [ i ] == ' b ' : NEW_LINE INDENT b . append ( i ) NEW_LINE DEDENT elif s [ i ] == ' a ' : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ' Yes ' if a [ i ] in b else ' No ' ) NEW_LINE DEDENT
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT div = [ 8 , 3 ] NEW_LINE rem = [ 2 , 2 ] NEW_LINE N = len ( div ) NEW_LINE print ( findNum ( div , rem , N ) ) NEW_LINE
def segregate0and1 ( arr ) : NEW_LINE INDENT type0 = 0 NEW_LINE type1 = len ( arr ) - 1 NEW_LINE while ( type0 < type1 ) : NEW_LINE INDENT if ( arr [ type0 ] == 1 ) : NEW_LINE INDENT arr [ type1 ] = arr [ type1 ] + arr [ type0 ] NEW_LINE arr [ type0 ] = arr [ type1 ] - arr [ type0 ] NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT array = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE segregate0and1 ( array ) NEW_LINE print ( " Array ▁ after ▁ segregation ▁ is " ) NEW_LINE for a in array : NEW_LINE INDENT print ( a , end = " ▁ " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE print ( len ( a ) - ( ( len ( a ) - ( i + 1 ) ) / 2 ) ) NEW_LINE
s = input ( ) NEW_LINE t = input ( ) NEW_LINE l = [ " R " , " U " , " D " ] NEW_LINE if s [ 0 ] == t [ 0 ] and s [ 1 ] == t [ 1 ] : NEW_LINE INDENT l = l + s [ 2 ] NEW_LINE DEDENT if s [ 0 ] == t [ 1 ] and s [ 1 ] == t [ 2 ] : NEW_LINE INDENT l = l + s [ 2 ] NEW_LINE DEDENT if s [ 0 ] == t [ 1 ] and s [ 1 ] == t [ 2 ] : NEW_LINE INDENT l = l + s [ 2 ] NEW_LINE DEDENT if s [ 0 ] == t [ 2 ] and s [ 1 ] == t [ 1 ] : NEW_LINE INDENT l = l + s [ 2 ] NEW_LINE DEDENT if s [ 0 ] == t [ 1 ] and s [ 1 ] == t [ 2 ] : NEW_LINE INDENT l = l + s [ 2 ] NEW_LINE DEDENT if s [ 0 ] == t [ 2 ] and s [ 1 ] == t [ 1 ] : NEW_LINE
h , w = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT ans += ( i + j + 1 ) * ( j + 1 ) ** 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT l = sorted ( l , key = lambda x : ( x [ 1 ] , x [ 0 ] ) ) NEW_LINE for i in l : NEW_LINE INDENT if i [ 1 ] != 1 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' No ' ) NEW_LINE
import sys NEW_LINE def solve ( X : int , Y : int ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( Y - 1 ) : NEW_LINE INDENT res . append ( X % i ) NEW_LINE DEDENT for i in range ( X - Y + 1 ) : NEW_LINE INDENT res . append ( X % i ) NEW_LINE DEDENT for i in range ( Y - 1 ) : NEW_LINE INDENT res . append ( X % i ) NEW_LINE DEDENT return " " . join ( [ str ( i ) for i in res ] ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT X , Y = map ( int , input ( ) . split ( ) ) NEW_LINE solve ( X , Y ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( X : int ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( len ( X ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res . append ( X [ i ] ) NEW_LINE DEDENT for i , x in enumerate ( X ) : NEW_LINE INDENT if i == len ( X ) - 1 : NEW_LINE INDENT res . append ( x ) NEW_LINE DEDENT DEDENT return " " . join ( res ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE X = int ( next ( tokens ) ) NEW_LINE solve ( X ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += s [ j ] * s [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( a * b ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == a [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 ] * MAX NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE print ( countPairs ( s ) ) NEW_LINE
prime = [ True ] * 100006 NEW_LINE def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sortedArray ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ]
def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def gcdFibonacciFreq ( arr , n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE createHash ( hash , maxElement
import math NEW_LINE def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - math . sqrt ( 2 ) ) NEW_LINE area = ( 3.14 * R * R ) / 2.0 NEW_LINE return area NEW_LINE DEDENT a = 4 NEW_LINE print ( " ▁ Area ▁ of ▁ semicircle ▁ = ▁ " , find_Area ( a ) ) NEW_LINE
def findQuadruples ( a , b , c , d , x , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 3 NEW_LINE a = [ 0 , 1 ] NEW_LINE b = [ 2 , 0 ] NEW_LINE c = [ 0 , 1 ] NEW_LINE d = [ 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findQuadruples ( a , b , c , d , x , n ) ) NEW_LINE DEDENT
def l , r , n = len ( s ) , len ( q ) NEW_LINE def printSmallest ( s , q ) : NEW_LINE INDENT N = len ( s ) NEW_LINE H = [ [ 0 ] * 26 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT H [ i ] [ ord ( s [ i - 1 ] ) - ord ( ' a ' ) ] = 1 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT H [ i ] [ j ] += H [ i - 1 ] [ j ] NEW_LINE DEDENT D
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( sum ( m + ( i ) * ( n - i ) for i in range ( n
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT print ( n // 3 + 1 ) NEW_LINE DEDENT elif n % 3 == 1 : NEW_LINE INDENT print ( n // 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n // 3 + 2 ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = " " NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT ans += s [ - n // 2 ] NEW_LINE print ( ans ) NEW_LINE DEDENT
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in v : NEW_LINE INDENT print ( - v [ i ] , v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 4 , 8 , 9 , - 4 , 1 , - 1 , - 8 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE printPairs ( arr , n ) NEW_LINE
def doublefactorial ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * doublefactorial ( n - 2 ) NEW_LINE DEDENT print ( " Double ▁ factorial ▁ is " , doublefactorial ( 5 ) ) NEW_LINE
def isPalindrome ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h - l ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minRemovals ( str ) : NEW_LINE INDENT if ( str [ 0 ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( isPalindrome ( str ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT print ( minRemovals ( "010010" ) ) NEW_LINE print ( minRemovals ( "0100101" ) ) NEW_LINE
def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ 0 ] * ( n ) NEW_LINE sumofdigit [ 0 ] = num [ 0 ] NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = num [ i ] - '0' NEW_LINE sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT num = "1234" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * ( a // n ) * ( b // n ) NEW_LINE ans += ( a // n ) * ( b % n ) NEW_LINE ans += ( ( a % n ) + ( b % n ) ) // n NEW_LINE return ans NEW_LINE DEDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE
import math NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 1000000 NEW_LINE maxN = 1 NEW_LINE maxD = 1 NEW_LINE for d in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT n = d * 3 // 7 NEW_LINE if ( d % 7 == 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT if ( n * maxD > ( n * maxN ) * d ) : NEW_LINE INDENT maxN = n NEW_LINE maxD = d NEW_LINE DEDENT DEDENT return str ( maxN ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
c = [ 1 ] * 100 ; NEW_LINE coef ( c ) ; NEW_LINE def coef ( n ) : NEW_LINE INDENT c [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ 1 + i ] = 1 ; NEW_LINE for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT c [ j ] = c [ j - 1 ] - c [ j ] ; NEW_LINE DEDENT DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT coef ( n ) ; NEW_LINE c [ 0 ] += 1 ; NEW_LINE c [ n ] -= 1 ; NEW_LINE i = n ; NEW_LINE while ( ( i ) > 0 and c [ i ] % n == 0 ) : NEW_LINE INDENT DEDENT return i < 0 ; NEW_LINE DEDENT n = 37 ; NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Prime " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime " ) ; NEW_LINE DEDENT
def count_greater ( arr , n ) : NEW_LINE INDENT min = float ( ' inf ' ) NEW_LINE counter = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > min ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT if ( arr [ i ] <= min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT arr = [ 3 , 2 , 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( count_greater ( arr , n ) ) NEW_LINE
n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if x < a [ 0 ] : NEW_LINE INDENT print ( a [ 0 ] - x ) NEW_LINE DEDENT elif x == a [ 1 ] : NEW_LINE INDENT print ( a [ 2 ] - x ) NEW_LINE DEDENT elif x > a [ 2 ] : NEW_LINE INDENT print ( x - a [ 0 ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( [ x , y ] ) NEW_LINE DEDENT l . sort ( ) NEW_LINE if l [ 0 ] [ 1 ] < 0 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
while True : NEW_LINE INDENT t , d , l = map ( int , input ( ) . split ( ) ) NEW_LINE if t == 0 and d == 0 and l == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( d ) : NEW_LINE INDENT b = a [ i ] - 1 NEW_LINE if i == 0 : NEW_LINE INDENT b = 0 NEW_LINE DEDENT ans += 1 NEW_LINE if b == 0 : NEW_LINE INDENT a [ i ] -= 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def minimumSwaps ( arr ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT while ( arr [ i ] != i + 1 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = arr [ i ] - 1 NEW_LINE arr [ arr [ i ] - 1 ] = arr [ i ] NEW_LINE arr [ i ] = temp NEW_LINE count += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 1 , 5 ] NEW_LINE print ( minimumSwaps ( arr ) ) NEW_LINE
import sys NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 500500 NEW_LINE queue = [ ] NEW_LINE for i in range ( TARGET ) : NEW_LINE INDENT item = queue . pop ( ) NEW_LINE product = ( item * item ) % MODULUS NEW_LINE queue . append ( item * product % MODULUS ) NEW_LINE if item == nextPrime : NEW_LINE INDENT nextPrime += 1 NEW_LINE while queue . append ( item * item % MODULUS ) : NEW_LINE INDENT queue . append ( item * item % MODULUS ) NEW_LINE item = queue . pop ( ) NEW_LINE DEDENT DEDENT DEDENT return str ( product ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findUniquePair ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE DEDENT set_bit_no = XOR & ~ ( XOR - 1 ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] & set_bit_no ) > 0 ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ unique ▁ pair ▁ is ▁ ( " , x , " , ▁ " , y , " ) " ) NEW_LINE DEDENT a = [ 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 ] NEW_LINE n = len ( a ) NEW_LINE findUniquePair ( a , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = ' ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += input ( ) NEW_LINE DEDENT print ( ' YES ' if s . count ( ' YES ' ) == 1 else ' NO ' ) NEW_LINE
import re NEW_LINE while True : NEW_LINE INDENT d = input ( ) NEW_LINE if d == ' @ ' or d == ' @ @ @ ' or d == ' @ @ ' : NEW_LINE INDENT break NEW_LINE DEDENT s = re . split ( ' @ @ ' , d ) NEW_LINE n = len ( s ) NEW_LINE @Adj_1 ( max = 10 ) : NEW_LINE INDENT d [ s [ 0 ] ] = d [ s [ i + 1 ] ] + d [ s [ i ] ] NEW_LINE DEDENT m = len ( d [ 0 ] ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT d [ s [ i ] ] = ' * ' + d [ s [ i ] ] NEW_LINE DEDENT m = max ( m , d [ len ( d ) - 1 ] ) NEW_LINE for i in range ( len ( d [ 0 ] ) ) : NEW_LINE INDENT d [ s [ i ] ] = ' * ' + d [ s [ i ] ] NEW_LINE DEDENT print ( ' ' . join ( re . split ( ' @ ' , d ) ) ) NEW_LINE DEDENT
def isMajority ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = mp . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] >= n // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if ( isMajority ( a , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
n , w = map ( int , input ( ) . split ( ) ) NEW_LINE knaps = sorted ( [ [ int ( input ( ) ) for _ in range ( n ) ] ] ) NEW_LINE print ( sum ( knaps [ : w ] ) ) NEW_LINE
import math NEW_LINE t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE if n == - 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a = a * i NEW_LINE DEDENT print ( math . atan2 ( a ) ) NEW_LINE print ( math . atan1 ( a ) ) NEW_LINE DEDENT DEDENT
def printKMissing ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and arr [ i ] <= 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE curr = 1 ; NEW_LINE while ( count < k and i < n ) : NEW_LINE INDENT if ( arr [ i ] != curr ) : NEW_LINE INDENT print ( curr , end = " ▁ " ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT curr += 1 ; NEW_LINE DEDENT while ( count < k ) : NEW_LINE INDENT print ( curr , end = " ▁ " ) ; NEW_LINE curr += 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 3 ; NEW_LINE printKMissing ( arr , n , k ) ; NEW_LINE
def printNumbers ( a , n ) : NEW_LINE INDENT mpp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE for j in range ( 1 , num + 1 ) : NEW_LINE INDENT if ( num % j == 0 ) : NEW_LINE INDENT if ( j in mpp . keys ( ) ) : NEW_LINE INDENT mpp [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ j ] = 1 NEW_LINE DEDENT DEDENT if ( num // j ) != j : NEW_LINE INDENT if ( mpp [ num // j ] ) : NEW_LINE INDENT mpp [ num // j ] += 1 NEW_LINE DED
s = input ( ) NEW_LINE t = len ( s ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT if s [ i ] != ' a ' and s [ i ] != ' z ' : NEW_LINE INDENT print ( s [ i ] + s [ i + 1 : ] ) NEW_LINE break NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == a [ i + 1 ] : NEW_LINE INDENT ans = max ( ans , i + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def checkIfStartsWithCapital ( str ) : NEW_LINE INDENT if ( str [ 0 ] >= ' A ' and str [ 0 ] <= ' Z ' ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT def check ( str ) : NEW_LINE INDENT if ( checkIfStartsWithCapital ( str ) ) : NEW_LINE INDENT print ( " Accepted " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Accepted " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksforGeeks " ; NEW_LINE check ( str ) ; NEW_LINE str = " geeksforgeeks " ; NEW_LINE check ( str ) ; NEW_LINE DEDENT
def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( prev_avg * n + x ) / ( n + 1 ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) NEW_LINE print ( " % .1f " % ( i + 1 ) , " numbers ▁ is ▁ " , avg ) NEW_LINE DEDENT return NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE streamAvg ( arr , n ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE primes = eulerlib . list_primes ( LIMIT ) NEW_LINE isprime = eulerlib . list_primes ( LIMIT ) NEW_LINE maxSum = 0 NEW_LINE maxRun = - 1 NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , len ( primes ) ) : NEW_LINE INDENT sum += primes [ j ] NEW_LINE if sum > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if sum > maxSum and sum > maxSum and isprime [ sum ] : NEW_LINE INDENT maxSum = sum NEW_LINE maxRun = j - i NEW_LINE DEDENT DEDENT DEDENT DEDENT return str ( maxSum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE lst = [ 1 ] * ( n ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lst [ i ] < lst [ j ] + 1 ) : NEW_LINE INDENT lst [ i ] = lst [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lst [ i ] ) : NEW_LINE INDENT max = lst [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ lst ▁ is " , lis ( arr , n ) ) NEW_LINE
a , b , k = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a * 10 ** k == b * 10 ** ( k - 1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def fix ( A ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT s . add ( A [ i ] ) NEW_LINE DEDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if ( s . count ( i ) > 0 ) : NEW_LINE INDENT A [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = - 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT A = [ - 1 , - 1 , 6 , 1 , 9 , 3 , 2 , - 1 , 4 , - 1 ] NEW_LINE print ( fix ( A ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( a + b + c , a + d , b + c , c + d ) ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if ( head_ref != None ) : NEW_LINE INDENT head_ref .
while True : NEW_LINE INDENT n , s = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and s == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if s > 10 : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( 10 * ( s - 10 ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT
mod = 1000000007 NEW_LINE fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def powmod ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT pt = powmod ( a , n // 2 ) NEW_LINE pt = ( pt * pt ) % mod NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT return ( pt * a ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return pt NEW_LINE
MAX = 1000001 NEW_LINE primeUpto = [ 0 ] * MAX ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime = [ 1 ] * ( MAX ) ; NEW_LINE isPrime [ 0 ] = isPrime [ 1 ] = 0 ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( isPrime [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT primeUpto [ i ] = primeUpto [ i - 1 ] ; NEW_LINE if (
def countOperations ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( ( i * i ) < n and ( n % i ) > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( ( i * i ) > n ) : NEW_LINE INDENT i = n NEW_LINE DEDENT return ( 1 + ( n - i ) / 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( countOperations ( n ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE for i in range ( m - 1 ) : NEW_LINE INDENT if s [ i ] == ' A ' and s [ i + 1 ] == ' C ' : NEW_LINE INDENT t [ i + 1 ] = t [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT t [ i ] = t [ i ] NEW_LINE DEDENT DEDENT for i in range ( m - 1 ) : NEW_LINE INDENT if t [ i ] == ' A ' and s [ i + 1 ] == ' C ' : NEW_LINE INDENT t [ i + 1 ] = t [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT t [ i ] = t [ i ] NEW_LINE DEDENT DEDENT for i in range ( m - 1 ) : NEW_LINE INDENT if t [ i ] == ' A ' and s [ i + 1 ] == ' C ' : NEW_LINE INDENT t [ i + 1 ] = t [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( l + r , 10 ** ( r - 1 ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE MOD = 10000000000000000 NEW_LINE ans = 0 NEW_LINE numSubsets = eulerlib . list_primality ( LIMIT * LIMIT / 2 ) NEW_LINE numSubsets = [ 0 ] * LIMIT * ( LIMIT * ( LIMIT // 2 ) ) NEW_LINE numSubsets [ 0 ] = 1 NEW_LINE maxSum = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if not isprime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT maxSum += i NEW_LINE for j in range ( maxSum , i , - 1 ) : NEW_LINE INDENT temp = numSubsets [ j ] + numSubsets [ j - i ] NEW_LINE if temp < DIVULUS : NEW_LINE INDENT numSubsets [ j ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT numSubsets [ j ] = temp - MODULUS NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for
def countOddNumber ( row_num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( row_num > 0 ) : NEW_LINE INDENT count += row_num & 1 NEW_LINE row_num >>= 1 NEW_LINE DEDENT return ( 1 << count ) NEW_LINE DEDENT def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( n ) : NEW_LINE INDENT print ( countOddNumber ( row_num ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 16 NEW_LINE gouldSequence ( n ) NEW_LINE
def deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] ; NEW_LINE ans = [ ] ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] ; NEW_LINE ans . append ( deno [ i ] ) ; NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT
import sys NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1 , 6 ) if i > 1000000 and i * i != x ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def multiplesHaveSameDigits ( x ) : NEW_LINE INDENT for i in range ( 2 , 6 ) : NEW_LINE INDENT if x in memo : NEW_LINE INDENT return memo [ i ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def is_sorted ( x ) : NEW_LINE INDENT for i in range ( 2 , 6 ) : NEW_LINE INDENT if x in memo : NEW_LINE INDENT return memo [ i ] NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def is_sorted ( x ) : NEW_LINE INDENT for i in range ( 2 , 6 ) : NEW_LINE INDENT if is_sorted ( x ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def is_sorted_numeric ( x ) : NEW_LINE INDENT if x in memo : NEW_LINE INDENT return memo [ x ] NEW_LINE DEDENT return is_sorted ( x ) NEW_LINE DEDENT for p in range ( 1 , 6 ) : NEW_LINE INDENT if is_sorted ( p ) : NEW_LINE INDENT ans =
def count ( arr , n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 NEW_LINE return ans NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE
def findEle ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == sum - arr [ i ] ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findEle ( arr , n ) ) NEW_LINE
def findExtraCharcter ( stringA , stringB ) : NEW_LINE INDENT m1 = [ 0 ] * 256 NEW_LINE for i in range ( len ( stringA ) ) : NEW_LINE INDENT m1 [ ord ( stringA [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( stringA ) ) : NEW_LINE INDENT m1 [ ord ( stringA [ i ] ) ] -= 1 NEW_LINE DEDENT for i in range ( len ( stringA ) ) : NEW_LINE INDENT if ( m1 [ i ] == 1 ) : NEW_LINE INDENT return ( chr ) NEW_LINE DEDENT DEDENT return " MIN " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT stringA = " abcd " NEW_LINE stringB = " cbdad " NEW_LINE print ( findExtraCharcter ( stringA , stringB ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = b = 0 NEW_LINE while n : NEW_LINE INDENT b += n // 6 NEW_LINE n //= 6 NEW_LINE DEDENT print ( b ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = input ( ) NEW_LINE t = input ( ) NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b += t [ i ] NEW_LINE if len ( b ) == len ( t ) : NEW_LINE INDENT print ( b ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( " YES " ) NEW_LINE
def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = - ( - arr1 [ i ] ) NEW_LINE max2 = - ( - arr2 [ i ] ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max1 ) : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( n2 ) : NEW_LINE INDENT if ( arr2 [ i ] > max2 ) : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE
operations ( op , n , k ) = 0 , 0 NEW_LINE min = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT nVal = 0 NEW_LINE min = min + op [ i ] NEW_LINE if ( k + nVal ) <= 0 : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT if ( k - ( min * abs ( nVal ) ) ) <= 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT times = ( k - abs ( min ) ) // abs ( nVal ) NEW_LINE k = ( k - ( times * abs ( nVal ) ) ) NEW_LINE count = ( times * n ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT k = k + op [ i ] NEW_LINE count = count + 1 NEW_LINE if ( k <= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW
import math NEW_LINE pref = [ 0 ] * 100010 NEW_LINE def isPerfectCube ( x ) : NEW_LINE INDENT cr = round ( math . cbrt ( x ) ) NEW_LINE if cr * cr * cr == x : NEW_LINE INDENT return x NEW_LINE DEDENT return 0 NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100010 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] NEW_LINE print ( sum , end = " ▁ " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT compute ( ) NEW_LINE Q = 4 NEW_LINE arr = [ [ 1 , 10 ] , [ 1 , 100 ] , [ 2 , 25 ] , [ 4 , 50 ] ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum (
n , r , l = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( r ) : NEW_LINE INDENT t , x = map ( int , input ( ) . split ( ) ) NEW_LINE ans = ans - t + x + 1 NEW_
def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( n , " th ▁ Centered " , " cube ▁ number : ▁ " , centered_cube ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , " th ▁ Centered " , " cube ▁ number : ▁ " , centered_cube ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE print
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; i = 0 ; NEW_LINE while ( i ) : NEW_LINE INDENT nth += pow ( i , i ) ; NEW_LINE i -= 1 ; NEW_LINE DEDENT return nth ; NEW_LINE DEDENT N = 3 ; NEW_LINE print ( nthTerm ( N ) ) ; NEW_LINE
import math NEW_LINE def isPower ( x , y ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return y == 1 NEW_LINE DEDENT pow = 1 NEW_LINE while pow < y : NEW_LINE INDENT pow *= x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT print ( " True " if isPower ( 10 , 1 ) else " False " ) NEW_LINE print ( " True " if isPower ( 1 , 20 ) else " True " ) NEW_LINE print ( " True " if isPower ( 2 , 32 ) else " True " ) NEW_LINE print ( " True " if isPower ( 3 , 30 ) else " True " ) NEW_LINE
import math NEW_LINE def isPower ( x , y ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return y == 1 NEW_LINE DEDENT pow = 1 NEW_LINE while pow < y : NEW_LINE INDENT pow *= x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT print ( isPower ( 10 , 1 ) ) NEW_LINE print ( isPower ( 1 , 20 ) ) NEW_LINE print ( isPower ( 2 , 32 ) ) NEW_LINE
def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE answer = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] NEW_LINE DEDENT return answer * ( 2 * k - 2 ) NEW_LINE DEDENT arr = [ 4 , 21 , 5 , 3 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( minimumValue ( arr , n , k ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT print ( 1 if s [ 0 ] in s else 0 ) NEW_LINE
def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) // 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return pow ( 2 , E - 1 ) NEW_LINE DEDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE
from math import gcd NEW_LINE def findLCM ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( arr [ i ] , lcm ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def countNumbers ( arr , n , l , r ) : NEW_LINE INDENT lcm = findLCM ( arr , n ) NEW_LINE count = ( r // lcm ) - ( ( l - 1 ) // lcm ) NEW_LINE return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countNumbers ( arr , n , l , r ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans . append ( a [ i ] + a [ j ] ) NEW_LINE DEDENT DEDENT print ( n - ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < a [ i + 1 ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def MinDeletion ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in mp : NEW_LINE INDENT x = i NEW_LINE frequency = mp [ x ] NEW_LINE if x <= frequency : NEW_LINE INDENT ans += ( frequency - x ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += frequency NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 3 , 2 , 3 , 4 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE print ( MinDeletion ( a , n ) ) NEW_LINE DEDENT
def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def _list ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def solves ( ) : NEW_LINE INDENT n = _input ( ) NEW_LINE a = _list ( ) NEW_LINE ans = " " NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] != a [ i + 1 ] : ans += " ▁ " + "1" NEW_LINE else : ans += " ▁ " + "0" NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solves ( ) NEW_LINE DEDENT
def nondecdigits ( n ) : NEW_LINE INDENT x = 0 NEW_LINE for x in range ( n , - 1 , - 1 ) : NEW_LINE INDENT no = x NEW_LINE prev_dig = 11 NEW_LINE flag = True NEW_LINE while ( no != 0 ) : NEW_LINE INDENT if ( prev_dig < no % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev_dig = no % 10 NEW_LINE no //= 10 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT n = 200 NEW_LINE print ( nondecdigits ( n ) ) NEW_LINE
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 == x2 : NEW_LINE INDENT if y1 != y2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( y1 , y2 ) NEW_LINE DEDENT DEDENT elif y1 == y2 : NEW_LINE INDENT if x1 != x2 : NEW_LINE INDENT print ( x1 , x2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( y1 , y2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE while x > 0 : NEW_LINE INDENT if x % 2 == 0 : NEW_LINE INDENT x = x - 2 NEW_LINE DEDENT else : NEW_LINE INDENT x = x - 1 NEW_LINE DEDENT DEDENT while y > 0 : NEW_LINE INDENT if y % 2 == 0 : NEW_LINE INDENT y = y - 2 NEW_LINE DEDENT else : NEW_LINE INDENT y = y - 1 NEW_LINE DEDENT DEDENT print ( ' Hanako ' if x == 0 or y == 0 or x < 0 or y < 0 or x > 12 or y > 12
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT print ( ' W ' , end = ' ' ) NEW_LINE DEDENT else : NEW
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT ans = max ( ans , j + 1 ) NEW_LINE DEDENT DEDENT DEDENT if ans == n : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT
def countDistictSubarray ( arr , n ) : NEW_LINE INDENT vis = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT vis [ arr [ i ] ] = 1 NEW_LINE DEDENT k = len ( vis ) NEW_LINE vis [ k ] = 1 NEW_LINE ans = 0 NEW_LINE right = 0 NEW_LINE window = 0 NEW_LINE for left in range ( n ) : NEW_LINE INDENT while ( right < n and window < k ) : NEW_LINE INDENT vis [ arr [ left ] ] += 1 NEW_LINE if vis [ arr [ left ] ] == 1 : NEW_LINE INDENT window += 1 NEW_LINE DEDENT left += 1 NEW_LINE DEDENT if ( window == k ) : NEW_LINE INDENT ans += ( n - right + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 2 , 1
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( max ( a + s , max ( a ) ) ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def primeBitsInRange ( l , r ) : NEW_LINE INDENT tot_bit , count = 0 , 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT tot_bit = bin ( i ) NEW_LINE if isPrime ( tot_bit ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT l = 6 NEW_LINE r = 10 NEW_LINE print ( primeBitsInRange ( l , r ) ) NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) NEW_LINE if ( sum == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE
from queue import Queue NEW_LINE def reverseQueueFirstKElements ( k ) : NEW_LINE INDENT if len ( k ) == 1 : NEW_LINE INDENT return k NEW_LINE DEDENT if k . count ( "0" ) == 0 or k . count ( "1" ) == 0 : NEW_LINE INDENT return k NEW_LINE DEDENT i = q . index ( "0" ) NEW_LINE return [ i + k for i in range ( len ( k ) - 1 ) ] NEW_LINE DEDENT def Print ( ) : NEW_LINE INDENT while q : NEW_LINE INDENT print ( q . index ( "0" ) , end = " ▁ " ) NEW_LINE q . pop ( ) NEW_LINE DEDENT D
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE s = ' ' NEW_LINE for i in a : NEW_LINE INDENT s += str ( i ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def xorCalc ( k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( k + 1 ) & k ) : NEW_LINE INDENT return k // 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT k = 31 NEW_LINE print ( xorCalc ( k ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def isPerfectSquare ( self , num ) : NEW_LINE INDENT low = 1 NEW_LINE high = num NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid * mid == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( mid * mid < num ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 16 NEW_LINE out = sObj . isPerfectSquare ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( " Yes " if ( a + b + c ) / 2 >= a + b + c else " No " ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == a [ i + 1 ] : NEW_LINE INDENT print ( i + 1 , i + 2 ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = sum ( m // ( n -
def findElement ( arr , ranges , rotations , index ) : NEW_LINE INDENT for i in range ( rotations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT if ( index == left ) : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index -= 1 NEW_LINE DEDENT DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE rotations = 2 NEW_LINE ranges = [ [ 0 , 2 ] , [ 0 , 3 ] ] NEW_LINE index = 1 NEW_LINE print ( findElement ( arr , ranges , rotations , index ) ) NEW_LINE
MAXN = 1000001 NEW_LINE spf = [ 0 ] * MAXN NEW_LINE hash1 = [ 1 , 1 , 1 ] NEW_LINE sieve ( ) NEW_LINE def sieve ( ) : NEW_LINE INDENT spf
def isExists ( a , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE sum += a [ i ] NEW_LINE DEDENT if ( sum % 2 == 0 ) : NEW_LINE INDENT if ( freq [ sum // 2 ] != None ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 5 , 1 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if ( isExists ( a , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE return area NEW_LINE DEDENT d1 = 4 NEW_LINE d2 = 6 NEW_LINE print ( " Area ▁ of ▁ Kite ▁ = ▁ " , areaOfKite ( d1 , d2 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT print ( " - - - - - - - " . join ( map ( str , a [ i ] ) ) ) NEW_LINE exit ( ) NEW_LINE DEDENT elif a [ i ] == 1 : NEW_LINE INDENT print ( " . " , end = " " ) NEW_LINE print ( i + 1 , end = " " ) NEW_LINE print ( i + 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] ,
n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def productEqual ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT prodOdd = 1 NEW_LINE prodEven = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE prodOdd *= digit NEW_LINE n //= 10 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT digit = n % 10 NEW_LINE prodEven *= digit NEW_LINE n //= 10 NEW_LINE DEDENT if ( prodEven == prodOdd ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 4324 NEW_LINE if ( productEqual ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT dic = { } NEW_LINE ok = [ [ False for i in range ( 10002 ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dic [ i ] = [ i ] NEW_LINE for s in input ( ) . split ( ) : NEW_LINE INDENT if s in dic : NEW_LINE INDENT ok [ i ] [ s ] = True NEW_LINE DEDENT else : NEW_LINE INDENT dic [ i ] = False NEW_LINE DEDENT DEDENT DEDENT k = input ( ) NEW_LINE for i in range ( len ( dic [ k ] ) ) : NEW_LINE INDENT if ok [ i
def checkEVENodd ( arr , n , l , r ) : NEW_LINE INDENT if ( arr [ r ] == 1 ) : NEW_LINE INDENT print ( " odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " even " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 1 , 0 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE checkEVENodd ( arr , n , 1 , 3 ) NEW_LINE
w , h , x , y , r = map ( int , input ( ) . split ( ) ) NEW_LINE if x + w <= w and y + h <= h : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( isPrime ( num ) ) : NEW_LINE INDENT return num NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( isPrime ( sum ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minNumber ( arr , n ) ) NEW_LINE
def compositeProduct ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = True NEW_LINE for p in range ( 2 , int ( max_val + 1 ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( compositeProduct ( arr , n ) ) NEW_LINE
while True : NEW_LINE INDENT try : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = a + b NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT word = input ( ) NEW_LINE if word [ 0 ] == " po " : NEW_LINE INDENT print ( word [ 1 ] + word [ 2 ] ) NEW_LINE DEDENT elif word [ 0 ] == " k " : NEW_LINE INDENT print ( word [ 1 ] + word [ 2 ] ) NEW_LINE DEDENT elif word [ 0 ] == " l " : NEW_LINE INDENT print ( word [ 1 ] + word [ 2 ] ) NEW_LINE DEDENT elif word [ 0 ] == " m " : NEW_LINE INDENT print ( word [ 1 ] + word [ 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( word ) NEW_LINE DEDENT DEDENT
def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 ] NEW_LINE queries = 3 NEW_LINE q = [ [ 2 , 4 ] , [ 2 , 6 ] , [ 5 , 6 ] , [ 5 , 6 ] ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( findSum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) + " \n " ) NEW_LINE DEDENT
def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n - i + 1 ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if ( z ) == floor ( z ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y + z ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE a = 5 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE print ( maxResult ( n , a , b , c ) ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE total = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT total += int ( input ( ) ) NEW_LINE DEDENT n = n - 1 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if n - i <= 0 : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = i NEW_LINE while n - i <= 0 : NEW_LINE INDENT n -= 1 NEW_LINE ans = ans + int ( input ( ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i NEW_LINE DEDENT return ans NEW_LINE DEDENT def numberOfPossiblePallindrome ( str , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ str [ i ] ] = mp . get ( str [ i ] , 0 ) + 1 NEW_LINE DEDENT k = 0 NEW_LINE num = 0 NEW_LINE den = 1 NEW_LINE fi = 0 NEW_LINE for it in mp : NEW_LINE INDENT if ( it [ 0 ] % 2 == 0 ) : NEW_LINE INDENT fi = it [ 1 ] // 2 NEW_LINE k += 1 NEW_LINE DEDENT else : NEW_
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT DEDENT if ans == n : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE n = toggleLastMBits ( n , m ) NEW_LINE print ( n ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = len ( s ) NEW_LINE b = len ( s [ - 1 ] ) NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def first_subString ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = 0 NEW_LINE s1 , s2 = 0 , 0 NEW_LINE mpp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ▁ ' or s [ i ] == ' # '
def countConsecutive ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 44522255 NEW_LINE print ( countConsecutive ( n ) ) NEW_LINE
def findAngle ( n ) : NEW_LINE INDENT interiorAngle = 180 / n NEW_LINE exteriorAngle = 360 / n NEW_LINE print ( " Interior ▁ angle : ▁ " , interiorAngle ) NEW_LINE print ( " Exterior ▁ angle : ▁ " , exteriorAngle ) NEW_LINE DEDENT n = 10 NEW_LINE findAngle ( n ) NEW_LINE
import math NEW_LINE def nDigitPerfectSquares ( n ) : NEW_LINE INDENT smallest = pow ( math . ceil ( math . sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) NEW_LINE print ( smallest , end = " ▁ " ) NEW_LINE largest = pow ( math . ceil ( math . sqrt ( pow ( 10 , n ) ) - 1 , 2 ) ) NEW_LINE print ( largest ) NEW_LINE DEDENT n = 4 NEW_LINE nDigitPerfectSquares ( n ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = s . count ( ' e ' ) NEW_LINE b = s . count ( ' o ' ) NEW_LINE if ( a > b ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def discard_count = 0 ; NEW_LINE power ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT p = power ( a ,
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def inorder ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( root . left ) NEW_LINE print ( root . data , end = " ▁ "
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ 0 ] * 26 NEW_LINE b = [ 0 ] * 26 NEW_LINE for i in s : NEW_LINE INDENT a [ ord ( i ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT b [ ord ( i ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) :
a , b , c , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' { : . 0f } ' . format
import math NEW_LINE class node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printArr ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def findlength ( head ) : NEW_LINE INDENT node curr = head NEW_LINE cnt = 0 NEW_LINE while curr != None : NEW_LINE INDENT cnt += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT return cnt NEW_LINE DEDENT def findlength ( head ) : NEW_LINE INDENT cnt = 0 NEW_LINE index = 0 NEW_LINE curr = head NEW_LINE while curr != None : NEW_LINE INDENT cnt += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT printArr ( arr , len (
def nonDecNums ( n ) : NEW_LINE INDENT a = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return a [ n ] [ 0 ] NEW_LINE DEDENT n = 2 NEW_LINE print ( " Non - decreasing ▁ digits ▁ = ▁ " , nonDecNums ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % n != 0 ) : NEW_LINE INDENT if ( b [ i ] == 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b [ i ] == 1 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def minMoves ( self , nums ) : NEW_LINE INDENT if nums == sorted ( nums ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT nums . sort ( ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 ] NEW_LINE out = sObj . minMoves ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a >= 0 and a <= 100 and b >= 0 : NEW_LINE INDENT if a % 2 == 0 : NEW_LINE INDENT if b % 2 == 0 : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Negative " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if b % 2 == 0 : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Negative " ) NEW_LINE DEDENT DEDENT DEDENT elif a < 0 and b >= 0 : NEW_LINE INDENT if a % 2 == 0 : NEW_LINE INDENT if b % 2 == 0 : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Negative " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if b % 2 == 0 : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Negative " ) NEW_LINE DEDENT DEDENT DEDENT elif a == 0 and b == 0 : NEW_LINE INDENT if a % 2 == 0 : NEW_LINE INDENT print ( " Positive " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Negative " ) NEW_LINE DEDENT DEDENT
def firstSetBit ( n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT n = 12 NEW_LINE print ( firstSetBit ( n ) ) NEW_LINE
MAX_CHAR = 256 NEW_LINE def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE firstInd = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT firstInd [ ord ( str [ i ] ) ] = - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT first_ind = firstInd [ ord ( str [ i ] ) ] NEW_LINE if ( first_ind == - 1 ) : NEW_LINE INDENT firstInd [ ord ( str [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abba " NEW_LINE print ( maximumChars ( str ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= k : ans += a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def findArea ( a ) : NEW_LINE INDENT area = ( 5 * math . sqrt ( 3 ) * a * a ) NEW_LINE return area NEW_LINE DEDENT def findVolume ( a ) : NEW_LINE INDENT volume = ( float ) ( ( ( int ) ( 5 / 12 ) * ( 3 + math . sqrt ( 5 ) ) * a * a ) NEW_LINE return volume NEW_LINE DEDENT a = 5 NEW_LINE print ( " Area : ▁ " , end = " " ) NEW_LINE print ( " Volume : ▁ " , end = " " ) NEW_LINE print ( " Volume : ▁ " , end = " " ) NEW_LINE print ( " \n Score : ▁ " , end = " " ) NEW_LINE print ( " \n Score : ▁ " , end = " " ) NEW_LINE print ( " \n Score : ▁ " , end = " " ) NEW_LINE
import itertools NEW_LINE n = int ( input ( ) ) NEW_LINE p = [ 0 , 1 , 1 , 1 , 1 ] NEW_LINE for i
def Even ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return n // 2 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n // 2 - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 6 NEW_LINE Even = N // 2 NEW_LINE Odd = N - Even NEW_LINE print ( Even * Odd ) NEW_LINE DEDENT
def solve ( M , N , s ) : NEW_LINE INDENT if ( N % s == 0 ) : NEW_LINE INDENT N = N // s NEW_LINE DEDENT else : NEW_LINE INDENT N = ( N // s ) + 1 NEW_LINE DEDENT if ( M % s == 0 ) : NEW_LINE INDENT M = M // s NEW_LINE DEDENT else : NEW_LINE INDENT M = ( M // s ) + 1 NEW_LINE DEDENT return M * N NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 12 NEW_LINE M = 13 NEW_LINE s = 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) / gcd ( a , b ) NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE e = int ( input ( ) ) NEW_LINE if a + b + c + d + e == a + b + c : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if a + b + c + d + e == a + b + c : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def _popcnt32 ( number ) : NEW_LINE INDENT counter = 0 NEW_LINE while ( number ) : NEW_LINE INDENT if ( number % 2 == 1 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT number = number // 2 NEW_LINE DEDENT return counter NEW_LINE DEDENT def maximize ( a ) : NEW_LINE INDENT n = _popcnt32 ( a ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = res | ( 1 << ( 32 - i ) ) NEW_LINE DEDENT return abs ( res ) NEW_LINE DEDENT a = 1 NEW_LINE print ( maximize ( a ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if ( a [ i ] <= k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE count = 0 NEW_LINE while n != 0 and k != 0 : NEW_LINE INDENT if n >= 2 : NEW_LINE INDENT n -= 2 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def xorQueries ( self , queries ) : NEW_LINE INDENT q = [ ] NEW_LINE for i in queries : NEW_LINE INDENT q = [ ] NEW_LINE q . append ( arr ) NEW_LINE arr = arr ^ arr [ i - 1 ] NEW_LINE DEDENT for i in range ( queries . count ( queries ) ) : NEW_LINE INDENT q = queries [ i ] NEW_LINE res = q [ 0 ] ^ q [ 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE queries = [ 1 , 3 , 4 , 8 ] NEW_LINE queries = [ 0 , 1 ] NEW_LINE out = sObj . xorQueries ( arr , queries ) NEW_LINE print ( out ) NEW_LINE DEDENT
def encodedChar ( string , k ) : NEW_LINE INDENT expand = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while ( i < len ( string ) and string [ i ] >= ' a ' and string [ i ] <= ' z ' ) : NEW_LINE INDENT temp += string [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( string ) and string [ i ] >= '1' and string [ i ] <= '9' ) : NEW_LINE INDENT freq = freq * 10 + string [ i ] - '0' NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT return string NEW_LINE DEDENT return ( string [ k - 1 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " ab4c12ed3" NEW_LINE k = 21 NEW
def printPossible ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 2 != 0 or a + b < c ) : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT DEDENT a = 2 ; b = 4 ; c = 2 ; NEW_LINE printPossible ( a , b , c ) ; NEW_LINE
def summation ( n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) / 2 NEW_LINE sign = n + 1 % 2 == 0 NEW_LINE result_sum = sign * abs_sum NEW_LINE return result_sum NEW_LINE DEDENT N = 2 NEW_LINE print ( summation ( N ) ) NEW_LINE
def sortSquares ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE DEDENT arr = [ - 6 , - 3 , - 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Before ▁ sort " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " After ▁ sort " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE print ( " \n " ) NEW_LINE print ( " \n " ) NEW_LINE print ( " \n " ) NEW_LINE print ( " After ▁ sort " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
n , t = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if l [ i ] == l [ i + 1 ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT if k == n - 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % n == 0 : NEW_LINE INDENT ans += 1 NEW_LINE a [ i ] = 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b = 1 NEW_LINE a = 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + ( float ) ( sqrt ( d ) ) / ( 2 * a ) ) NEW_LINE root2 = ( - b - ( float ) sqrt ( d ) ) / ( 2 * a ) NEW_LINE if ( root1 > 0 and ( root1 ) == root1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root2 > 0 and ( root2 ) == root2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT num = 55 NEW_LINE if ( isTriangular ( num ) ) : NEW_LINE INDENT print ( " The ▁ number
def printNumberWithDR ( k , d ) : NEW_LINE INDENT if ( d == 0 and k != 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d ) NEW_LINE k -= 1 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE k = k - 1 NEW_LINE DEDENT DEDENT DEDENT k = 4 NEW_LINE d = 4 NEW_LINE printNumberWithDR ( k , d ) NEW_LINE
N = 3 NEW_LINE def rotateMatrix ( mat ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE rotateMatrix ( mat ) NEW_LINE
n = int ( input ( ) ) NEW_LINE print ( n // 500 * 500 ) NEW_LINE
def getProduct ( n ) : NEW_LINE INDENT product = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 4513 NEW_LINE print ( getProduct ( n ) ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE B = [ 771 , 16843009 , 15 , 66306 , 1539 , 131841 , 774 ] NEW_LINE C = 0 NEW_LINE while True : NEW_LINE INDENT a , b , r , g , s = map ( int , readline ( ) . split ( ) ) NEW_LINE if not a : NEW_LINE INDENT break NEW_LINE DEDENT write ( " % d \n " % C * ( a - b + 1 ) // 100 + s ) NEW_LINE C += 1 NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * ( a [ i - 1 ] - 1 ) % mod NEW_LINE ans %= mod NEW_LINE DEDENT print ( ans ) NEW_LINE
PI = 3.14159265 NEW_LINE def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 7 NEW_LINE print ( length_rope ( r ) ) NEW_LINE DEDENT
def reverseDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT rev_n = reverseDigits ( n ) NEW_LINE if ( rev_n == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 4562 NEW_LINE print ( " Is ▁ " , n , " a ▁ Palindrome ▁ number ? ▁ - > " , ( isPalindrome ( n ) == 1 ) ? " True " ) NEW_LINE n = 2002 NEW_LINE print ( " Is ▁ " , n , " a ▁ Palindrome ▁ number ? ▁ - > " , ( isPalindrome ( n ) == 1 ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def addStrings ( self , num1 , num2 ) : NEW_LINE INDENT carry = 0 NEW_LINE for i in range ( len ( num1 ) - 1 , len ( num2 ) - 1 , - 1 ) : NEW_LINE INDENT x = i < 0 and num1 [ i ] - '0' NEW_LINE y = j < 0 and num2 [ i ] - '0' NEW_LINE carry = ( x + y + carry ) % 10 NEW_LINE x = ( x + carry ) // 10 NEW_LINE y = ( y + carry ) // 10 NEW_LINE DEDENT return str ( x ) + y NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE num1 = "11" NEW_LINE num2 = "123" NEW_LINE out = sObj . addStrings ( num1 , num2 ) NEW_LINE print ( out ) NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i * i != n ) : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT DEDENT if ( sum == n and n != 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT print ( " Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000" ) NEW_LINE for n in range ( 2 , 10000 ) : NEW_LINE INDENT if isPerfect ( n ) : NEW_LINE INDENT print ( n , " is ▁ a ▁ perfect ▁ number " ) NEW_LINE DEDENT DEDENT
def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT p = x ; NEW_LINE while ( p <= n ) : NEW_LINE INDENT p = p * x ; NEW_LINE if ( p == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT DEDENT return False ; NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if isPower ( i ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT y = 2 NEW_LINE p = pow ( x , y ) NEW_LINE while ( p <= n and p > 0 ) : NEW_LINE INDENT if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT y += 1 NEW_LINE p = pow ( x , y ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if isPower ( i ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def findTwoNumbers ( sum , gcd ) : NEW_LINE INDENT if ( gcd == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return __gcd ( math . gcd , sum - gcd ) NEW_LINE DEDENT def findTwoNumbers ( sum , gcd ) : NEW_LINE INDENT if ( __gcd == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return __gcd ( math . gcd , sum - gcd ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sum = 8 NEW_LINE gcd = 2 NEW_LINE findTwoNumbers ( sum , gcd ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m , r , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = r % d NEW_LINE if a < 0 : NEW_LINE INDENT a = - a NEW_LINE DEDENT if r < d : NEW_LINE INDENT r = d NEW_LINE DEDENT print ( r ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT n , a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE cost = min ( n * a , c * b , d ) NEW_LINE ans = cost NEW_LINE if ans < 0 : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = countSetBits ( arr [ i ] ) NEW_LINE if ( m . get ( count ) ) : NEW_LINE INDENT m [ count ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ count ] = 1 NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT value = value * ( value - 1 ) // 2 NEW_LINE result += ( ( value * ( value - 1 ) ) // 2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 7 , 5 , 3 , 9 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( totalPairs ( arr , n ) ) NEW_LINE
def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT n = 2 NEW_LINE print ( n , " th ▁ centered ▁ hexadecagonal ▁ number : " , center_hexadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( n , " th ▁ centered ▁ hexadecagonal ▁ number : " , center_hexadecagonal_num ( n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE Q , H , S , D = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ q * ( q + 1 ) ] NEW_LINE for i in range ( 2 , S + 1 ) : NEW_LINE INDENT a . append ( a [ i - 1 ] * i % Q ) NEW_LINE DEDENT for i in range ( 1 , D + 1 ) : NEW_LINE INDENT if a [ i ] * ( i + 1 ) >= N : NEW_LINE INDENT print ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( N // 2 ) ** 2 + a [ i ] * ( N % 2 ) ) NEW_LINE DEDENT DEDENT
def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers // 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT A , B , C , D = map ( int , readline ( ) . split ( ) ) NEW_LINE if D < B : NEW_LINE INDENT return False NEW_LINE DEDENT if A < B : NEW_LINE INDENT return True NEW_LINE DEDENT if C < D : NEW_LINE INDENT return False NEW_LINE DEDENT if D < B : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT T , A , B , C , D = map ( int , readline ( ) . split ( ) ) NEW_LINE if solve ( ) : NEW_LINE INDENT write ( " \n " . join ( map ( str , D ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT write ( " \n " . join ( map ( str , A ) ) ) NEW_LINE DEDENT
def Solution ( A ) : NEW_LINE INDENT ans = 2 NEW_LINE n = len ( A ) NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT llap = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT llap [ i ] = 2 NEW_LINE DEDENT A . sort ( ) NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k < n ) : NEW_LINE INDENT if ( A [ i ] + A [ k ] == 2 * A [ j ] ) : NEW_LINE INDENT llap [ j ] = max ( llap [ j ] + 1 , llap [ j ] ) NEW_LINE ans = max ( ans , llap [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT elif ( A [ i ] + A [ k ] < 2 *
def minimumChanges ( arr , n , d ) : NEW_LINE INDENT maxFreq = - 1 ; NEW_LINE freq = dict ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = arr [ i ] - ( i * d ) ; NEW_LINE if ( freq [ a0 ] ) : NEW_LINE INDENT freq [ a0 ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a0 ] = 1 ; NEW_LINE DEDENT if ( freq [ a0 ] > maxFreq ) : NEW_LINE INDENT maxFreq = freq [ a0 ] ; NEW_LINE DEDENT DEDENT return ( n - maxFreq ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE d = 1 ; NEW_LINE arr = [ 1 , 3 , 3 , 4 , 6 ] ; NEW_LINE print ( minimumChanges ( arr , n , d ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT l = sorted ( l , key = lambda x : ( x [ 1 ] , x [ 0 ] ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] [ 1 ] < l [ i ] [ 0 ] and l [ i ] [ 2 ] < l [ i ] [ 1 ] and l [ i ] [ 3 ] < l [ i ] [ 2 ] : NEW_LINE INDENT print ( l [ i ] [ 0 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT
def countPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < m ) : NEW_LINE INDENT if ( a [ i ] + y < b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y = 1 , 4 NEW_LINE a = [ 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 1 , 1 , 2 ] NEW_LINE m = len ( a ) NEW_LINE print ( countPoints ( n , m , a , b , x , y ) ) NEW_LINE DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) ; NEW_LINE DEDENT x = 4 ; NEW_LINE print ( multiplyWith3Point5 ( x ) ) ; NEW_LINE
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 NEW_LINE maxi = 1 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) NEW_LINE return maxi NEW_LINE DEDENT s = " ccccdeededff " NEW_LINE print ( longestSubstring ( s ) ) NEW_LINE
k = int ( input ( ) ) NEW_LINE l = 50 NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT for i in range ( len ( a ) ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE
def zeroUpto ( digits ) : NEW_LINE INDENT first = ( int ) ( ( digits [ 0 ] - 1 ) / 9 ) ; NEW_LINE second = ( int ) ( ( digits [ 9 ] ) - 48 ) ; NEW_LINE return 9 * ( first - second ) ; NEW_LINE DED
def cone ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = ( a * sqrt ( 2 ) ) / 3 NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = ( 3.14 * pow ( r , 2 ) * h ) NEW_LINE return V NEW_LINE DEDENT a = 5 NEW_LINE print ( " % . 4f " , cone ( a ) ) NEW_LINE
def Prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkSumPrime ( str ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT summ += abs ( ord ( str [ i - 1 ] ) - ord ( str [ i ] ) ) NEW_LINE DEDENT if ( Prime ( summ ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT num = 142 NEW_LINE str = "142" NEW_LINE if ( checkSumPrime ( str ) ) : NEW_LINE INDENT print ( " Prime " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime " ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = [ 1 , 1 , 8 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 ] NEW_LINE print ( " % .3f " , g . sum ( 8 ) ) NEW_LINE print ( " % . 3f " , g . sum ( 10 ) ) NEW_LINE DEDENT
def countElements ( p , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT p = [ 2 , 5 , 1 , 3 , 4 ] NEW_LINE n = len ( p ) NEW_LINE print ( countElements ( p , n ) ) NEW_LINE
s = input ( ) NEW_LINE t = input ( ) NEW_LINE if s [ : : - 1 ] == t : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT elif s [ : : - 1 ] == t : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT
def findVolume ( l , b , h ) : NEW_LINE INDENT volume = ( l * b * h ) / 2 NEW_LINE return volume NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 18 NEW_LINE b = 12 NEW_LINE h = 9 NEW_LINE print ( " Volume ▁ of ▁ triangular ▁ prism : ▁ " , findVolume ( l , b , h ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( input ( ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT ans += ( a [ i ] [ 1 ] - a [ i ] [ 0 ] ) * ( n - i - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def compute ( ) : NEW_LINE INDENT ans = ( i * ( i + 1 ) / 2 ) * 166 NEW_LINE triangle = ( i * ( i + 1 ) / 2 ) * 166 NEW_LINE k = math . ceil ( k * ( i + 1 ) / 2 ) NEW_LINE min = min ( triangle , pentagon ) NEW_LINE if min == pentagon : NEW_LINE INDENT ans = k NEW_LINE DEDENT if min == triangle : NEW_LINE INDENT ans = 286 NEW_LINE DEDENT if min == pentagon : NEW_LINE INDENT j = j + 1 NEW_LINE DEDENT if min == k : NEW_LINE INDENT ans = min NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr = [ False ] * ( N + 1 ) NEW_LINE prod = 1 NEW_LINE res = 0 NEW_LINE for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( arr [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , N + 1 , p ) : NEW_LINE INDENT arr [ i ] = True NEW_LINE DEDENT prod *= p NEW_LINE if ( prod > N ) : NEW_LINE INDENT return res NEW_LINE DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT N = 500 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE
def checkDivisors ( a , n ) : NEW_LINE INDENT X = max_element ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X // i != i ) : NEW_LINE INDENT b . append ( X // i ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 8 , 1 , 2 ,
arr = [ 1 , 2 , 3 , 4 ] NEW_LINE def subArray ( arr ) : NEW_LINE INDENT for i in range ( 0 , arr ) : NEW_LINE INDENT for j in range ( i , arr ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE def subArray ( arr ) : NEW_LINE INDENT for i in range ( 0 , arr ) : NEW_LINE INDENT for j in range ( i , arr ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT print ( " All ▁ Non - empty ▁ Subarrays " ) NEW_LINE print ( " Subarrays " ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if ( n % 6 == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n % 6 == 1 ) : NEW_LINE INDENT print ( ( n // 6 ) + 2 , ( n // 6 ) + 1 , ( n // 6 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( arr [ i ] * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
def findAnswer ( n , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 53 , 28 , 143 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAnswer ( n , arr ) ) NEW_LINE
def findSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT sum = sum + arr [ i + 1 ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n ) ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getDeepestLeftLeafNode ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ ] NEW_LINE q . append
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getDeepestRightLeafNode ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ ] NEW_LINE q .
n = int ( input ( ) ) NEW_LINE l = [ 1 , 2 , 1 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT l . append ( l [ - 1 ] + l [ i + 1 ] ) NEW_LINE DEDENT print ( l [ n - 1 ] ) NEW_LINE
from math import gcd NEW_LINE def printRatio ( a , b ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT temp = c ; NEW_LINE c = d ; NEW_LINE d = c ; NEW_LINE temp = a ; NEW_LINE a = b ; NEW_LINE b = temp ; NEW_LINE DEDENT lcm = ( a * c ) / gcd ( a , c ) ; NEW_LINE x = lcm / a ; NEW_LINE b = int ( b * c ) / int ( d ) ; NEW_LINE y = lcm / a ; NEW_LINE d = int ( int ( b - a ) ) ; NEW_LINE b /= k ; NEW_LINE print ( b , " : " , d ) ; NEW_LINE DEDENT a = 4 ; NEW_LINE b = 3 ; NEW_LINE c = 2 ; NEW_LINE d = 2 ; NEW_LINE printRatio ( a , b ) ; NEW_LINE
def maxsum_SIS ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ sum ▁ : " , maxsum_SIS ( arr , n ) ) NEW_LINE
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def findMaxSumUtil ( arr , n ) : NEW_LINE INDENT finalGCD = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT finalGCD = GCD ( arr [ i ] , finalGCD ) NEW_LINE DEDENT return finalGCD NEW_LINE DEDENT def findMaxSum ( arr , n ) : NEW_LINE INDENT maxElement = findMaxSumUtil ( arr , n ) NEW_LINE return ( maxElement * n ) NEW_LINE DEDENT arr = [ 8 , 20 , 12 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT while ( b ) : NEW_LINE INDENT t = b ; NEW_LINE b = a % b ; NEW_LINE a = t ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT def findMinDiff ( a , b , x , y ) : NEW_LINE INDENT g = gcd ( a , b ) ; NEW_LINE diff = abs ( x - y ) % g ; NEW_LINE return min ( diff , g - diff ) ; NEW_LINE DEDENT a = 20 ; NEW_LINE b = 52 ; NEW_LINE x = 5 ; NEW_LINE y = 7 ; NEW_LINE print ( findMinDiff ( a , b , x , y ) ) ; NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y , w , h = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( x + w ) : NEW_LINE INDENT if i <= x and i <= y and i >= 0 and i <= x + w : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def divisibleby37 ( n1 ) : NEW_LINE INDENT l = len ( n1 ) NEW_LINE if ( n1 == "0" ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l % 3 == 1 ) : NEW_LINE INDENT n1 = "00" + n1 NEW_LINE l += 2 NEW_LINE DEDENT elif ( l % 3 == 2 ) : NEW_LINE INDENT n1 = "0" + n1 NEW_LINE l += 1 NEW_LINE DEDENT char [ n1 ] = chr ( n1 ) NEW_LINE gSum = 0 NEW_LINE while ( l != 0 ) : NEW_
n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( [ ' - 1' , '0' ] [ ( x - y ) * ( y - 1 ) ] ) NEW_LINE
def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1
def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base / 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT base = 8 NEW_LINE print ( numberOfSquares ( base ) ) NEW_LINE DEDENT
def rmsValue ( arr , n ) : NEW_LINE INDENT square = 0 ; NEW_LINE mean = 0 ; NEW_LINE root = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT square += pow ( arr [ i ] , 2 ) ; NEW_LINE DEDENT mean = ( square / ( n ) ) ; NEW_LINE root = ( float ) ( math . sqrt ( mean ) ) ; NEW_LINE return root ; NEW_LINE DEDENT arr = [ 10 , 4 , 6 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( " % . 4f " , rmsValue ( arr , n ) ) ; NEW_LINE
m , n = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n - i + 1 , m ) : NEW_LINE INDENT if p [ j ] < p [ j + i ] : NEW_LINE INDENT ans = max ( ans , j - i + 1 ) NEW_LINE DEDENT DEDENT D
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ None ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT DEDENT if n % 2 == 1 : NEW_LINE INDENT print ( " parent ▁ key ▁ = ▁ parent ▁ key ▁ = ▁ key ▁ = " ) NEW_LINE print ( " left ▁ key ▁ = ▁ left ▁ key ▁ = ▁ left ▁ " ) NEW_LINE print ( " right ▁ key ▁ = ▁ right ▁ key ▁ = ▁ right ▁ " )
n = 6 NEW_LINE m = 6 NEW_LINE def maxSum ( arr ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]
def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y2 , y4 ) NEW_LINE x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE if ( x5 > x6 or y5 > y6 ) : NEW_LINE INDENT print ( " No ▁ intersection " ) NEW_LINE return NEW_LINE DEDENT print ( " ( " , x5 , "
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' x ' : NEW_LINE INDENT x = i NEW_LINE DEDENT elif s [ i ] == ' x ' : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE DEDENT DEDENT print ( abs ( x ) ) NEW_LINE print ( abs ( y ) ) NEW_LINE
n , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( n * 5 , ( n * d ) % d , e ) ) NEW_LINE
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT maxratio = - ( - ( - val [ i ] / wt [ i ] ) ) NEW_LINE maxindex = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( val [ i ] / wt [ i ] ) > maxratio ) : NEW_LINE INDENT maxratio = ( val [ i ] / wt [ i ] ) NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT return ( W * maxratio ) NEW_LINE DEDENT val = [ 14 , 27 , 44 , 19 ] NEW_LINE wt = [ 6 , 7 , 9 , 8 ] NEW_LINE n = len ( val ) NEW_LINE W = 50 NEW_LINE print ( knapSack ( W , wt , val , n ) ) NEW_LINE
def AlternateRearrange ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE v1 = sorted ( arr ) NEW_LINE v2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT index = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE flag = False NEW_LINE while ( index < n ) : NEW_LINE INDENT if ( flag == True ) : NEW_LINE INDENT arr [ index ] = ( v1 [ i ] ) NEW_LINE i += 1 NEW_LINE index += 1 NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = ( v2 [ j ] ) NEW_LINE
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a <= b and b <= c : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = n // 2 ; NEW_LINE i += 1 ; NEW_LINE DEDENT binary = " " ; NEW_LINE for i in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT binary += str ( binaryNum [ i ] ) ; NEW_LINE DEDENT return binary ; NEW_LINE DEDENT def countFreq ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) ; NEW_LINE N = len ( txt ) ; NEW_LINE res = 0 ; NEW_LINE for i
def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += ( arr [ i ] & 1 ) NEW_LINE DEDENT print ( min ( x , n - x ) ) NEW_LINE DEDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE makearrayequal ( arr , n ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def findKthLargest ( self , nums ) : NEW_LINE INDENT k = len ( nums ) - k NEW_LINE lo , hi = 0 , len ( nums ) - 1 NEW_LINE while True : NEW_LINE INDENT while True : NEW_LINE INDENT if ( nums [ lo ] > k ) : NEW_LINE INDENT lo = lo + 1 NEW_LINE DEDENT else
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 NEW_LINE if ( temp % k == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return " NO " NEW_LINE DEDENT n = 9876543 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT k = n % 10 NEW_LINE sum += k NEW_LINE n //= 10 NEW_LINE DEDENT if ( temp % sum == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT return " NO " NEW_LINE DEDENT n = 123 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE
import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import collections NEW_LINE from collections import deque NEW_LINE import copy NEW_LINE import heapq NEW_LINE MOD = float ( ' inf ' ) NEW_LINE INF = 10 ** 18 NEW_LINE input = lambda : sys . stdin . readline ( ) . strip ( ) NEW_LINE N , A , B = map ( int , input ( ) . split ( ) ) NEW_LINE S = list ( reversed ( input ( ) ) ) NEW_LINE ans = ' ' NEW_LINE if ( N == A ) : NEW_LINE INDENT print ( " EQUAL " ) NEW_LINE DEDENT elif ( N == B ) : NEW_LINE INDENT print ( " NOTHING " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( A - B + 1 ) : NEW_LINE INDENT if ( S [ i ] != S [ i + 1 ] ) : NEW_LINE INDENT ans = ' ' NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( B - A + 1 ) : NEW_LINE INDENT if ( S [ i ] != S [ i + 1 ] ) : NEW_LINE INDENT ans = ' ' NEW_LINE break NEW_LINE DEDENT DEDENT print (
def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE INDENT totalSquares = ( l - size + 1 ) * ( b - size + 1 ) NEW_LINE area = totalSquares * size * size NEW_LINE totalArea += area NEW_LINE size += 1 NEW_LINE DEDENT return totalArea NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 4 NEW_LINE b = 3 NEW_LINE print ( calculateAreaSum ( l , b ) ) NEW_LINE DEDENT
def arrange ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( "1" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( N == 2 or N == 3 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE return ; NEW_LINE DEDENT even = - 1 ; odd = - 1 ; NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT even = N ; NEW_LINE odd = N - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd = N ; NEW_LINE even = N - 1 ; NEW_LINE DEDENT while ( odd >= 1 ) : NEW_LINE INDENT print ( odd , end = " ▁ " ) ; NEW_LINE print ( " ▁ " , end = " ▁ " ) ; NEW_LINE odd = odd - 2 ; NEW_LINE DEDENT while ( even >= 2 ) : NEW_LINE INDENT print ( even , end = " ▁ " ) ; NEW_LINE print ( " ▁ " , end = " ▁ " ) ; NEW_LINE even = even - 2 ; NEW_LINE DEDENT DEDENT N = 5 ; NEW_LINE arrange ( N ) ; NEW_LINE
def findMinEqualSums ( a , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE min = 10 ** 9 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE sum2 = sum - sum1 NEW_LINE if ( abs ( sum1 - sum2 ) < min ) : NEW_LINE INDENT min = abs ( sum1 - sum2 ) NEW_LINE DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT a = [ 3 , 2 , 1 , 5 , 7 , 8 ] NEW_LINE N = len ( a ) NEW_LINE print ( findMinEqualSums ( a , N ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 3 == 1 : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT elif n % 3 == 2 : NEW_LINE INDENT print ( "2" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT DEDENT
def findOptimalSolution ( a , N ) : NEW_LINE INDENT a . sort ( ) NEW_LINE points = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT points += a [ i ] * i NEW_LINE DEDENT return points NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEW_LINE N = len ( a ) NEW_LINE print ( findOptimalSolution ( a , N ) ) NEW_LINE DEDENT
n , m = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( sum ( m * ( n - 1 ) // 2 + ( m - 1 ) * 2 for m in range
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( m > n ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ n - 1 ] ) NEW_LINE DEDENT DEDENT
def getPairs ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT for j in range ( 0 , len ( a ) ) : NEW_LINE INDENT if ( a [ i ] < a [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 4 , 3 , 1 ] NEW_LINE print ( getPairs ( a ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if n == 1 and k > 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( s . count ( '1' ) , s .
a , b , c , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE print ( " YES " if
N = 10000 ; NEW_LINE MOD = 1000000007 ; NEW_LINE F = [ 0 ] * N ; NEW_LINE def precompute ( ) : NEW_LINE INDENT F [ 1 ] = 2 ; NEW_LINE F [ 2 ] = 3 ; NEW_LINE F [ 3 ] = 4 ; NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; NEW_LINE DEDENT DEDENT n = 8 ; NEW_LINE precompute ( ) ; NEW_LINE print ( F [ n ] ) ; NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE while True : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT break NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT n = n / 2 NEW_LINE count += 1 NEW_LINE continue NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 3 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 4 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 5 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 6 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 8 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 9 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 10 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 11 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 12 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 13 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 14 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 15 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 16 : NEW_LINE INDENT break NEW_LINE DEDENT if n == 17 : NEW_LINE INDENT break NEW_LINE
def CeilIndex ( A , l , r , key ) : NEW_LINE INDENT while r - l > 1 : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if A [ m ] >= key : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def LongestIncreasingSubsequenceLength ( A , size ) : NEW_LINE INDENT tailTable = [ 0 for i in range ( size ) ] NEW_LINE l = size NEW_LINE tailTable [ 0 ] = A [ 0 ] NEW_LINE l = 1 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT if A [ i ] < tailTable [ 0
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = ans * ( a [ i ] - a [ i + 1 ] ) // 2 NEW_LINE DEDENT print ( ans ) NEW_LINE
def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE ans = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if ( i not in seen ) : NEW_LINE INDENT return len ( ans ) NEW_LINE DEDENT if ( ans == 60 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT FACTORIAL = [ 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 ] NEW_LINE return str ( ans ) NEW_LINE DEDENT def factorize ( n ) : NEW_LINE INDENT seen = set ( ) NEW_LINE while ( n not in seen ) : NEW_LINE INDENT n = factorize ( n ) NEW_LINE ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
colour_count = 0 NEW_LINE colour_count += 1 NEW_LINE def colour_count_ways ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 for i in range ( K + 1 ) ] NEW_LINE visible = 0 NEW_LINE max = height [ K - 1 ] NEW_LINE arr [ colour_count ] = 1 NEW_LINE for i in range ( K - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( height [ i ] > max ) : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ colour_count ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT visible += 1 NEW_LINE DEDENT DEDENT return visible NEW_LINE DEDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE colour_count = len ( colour_count ) NEW_LINE print ( colour_count_ways ( height , colour , K ) ) NEW_LINE
def checkPowerof8 ( n ) : NEW_LINE INDENT i = ( int ) ( n / pow ( 8 , n ) ) NEW_LINE return ( i - pow ( i ) < 0.000001 ) NEW_LINE DEDENT n = 65 NEW_LINE if ( checkPowerof8 ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( a + b , a + b ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT max_h = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT h = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_h [ h [ 0 ] ] += 1 NEW_LINE DEDENT max_h_ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT if max_h [ j ] >= max_h [ j ] : NEW_LINE INDENT max_h_ans = max_h [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( max_ans ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] [ 0 ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] [ 1 ] < b [ i ] [ 1 ] ) : NEW_LINE INDENT print ( a [ i ] [ 0 ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] [ 0 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) ; NEW_LINE count [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] ; NEW_LINE DEDENT elif ( i < m ) : NEW_LINE INDENT count [ i ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 ; NEW_LINE DEDENT DEDENT return count [ n ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 ; NEW_LINE m = 4 ; NEW_LINE print ( " Number ▁ of ▁ ways ▁ = ▁ " , countWays ( n , m ) ) ; NEW_LINE DEDENT
def print ( n ) : NEW_LINE INDENT print ( n // 2 ) NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE print ( n ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT H , W = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE if H % 2 == 0 : NEW_LINE INDENT ans = ( H // 2 + 1 ) * 2 - H NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( H // 2 + 1 ) * 2 NEW_LINE DEDENT for i in range ( 1 , H // 2 + 1 ) : NEW_LINE INDENT ans += i * 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE import collections NEW_LINE import bisect NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import copy NEW_LINE import decimal NEW_LINE import queue NEW_LINE sys . setrecursionlimit ( 10000001 ) NEW_LINE INF = 10 ** 16 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE ni = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE eps = 10 ** ( - 9 ) NEW_LINE def main ( ) : NEW_LINE INDENT s = list ( input ( ) ) NEW_LINE ans = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == "0" : NEW_LINE INDENT if i - 1 >= 0 : NEW_LINE INDENT if ( s [ i - 1 ] == "0" ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s [ i - 1 ] == "1" ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if ( s [ i - 1 ] == "0" ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( s [ i - 1 ] ==
while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT if a % i == 0 and b % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
MAX = 100 NEW_LINE def recur ( ind , cnt , last , a , n , k , dp ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ind == n ) : NEW_LINE INDENT return - 1e9 NEW_LINE DEDENT if ( dp [ ind ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( ind , n ) : NEW_LINE INDENT if ( cnt % 2 == 0 ) : NEW
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE if ans >= n : NEW_LINE INDENT print ( n ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def equivalentBase4 ( bin ) : NEW_LINE INDENT if ( bin == "00" ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( bin . count ( "01" ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( bin . count ( "10" ) == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT def isDivisibleBy5 ( bin ) : NEW_LINE INDENT l = len ( bin ) NEW_LINE if ( l % 2 != 0 ) : NEW_LINE INDENT bin = '0' + bin NEW_LINE DEDENT odd_sum = 0 NEW_LINE even_sum = 0 NEW_LINE isOddDigit = 1 NEW_LINE for i in range ( len ( bin ) ) : NEW_LINE INDENT if ( isOddDigit != 0 ) : NEW_LINE INDENT odd_sum += ( equivalentBase4 ( bin [ i : i + 2 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT even_sum += ( equivalentBase4 ( bin [ i : i + 2 ]
print ( * filter ( lambda x : x . isalpha ( ) , map ( len , input ( ) . split ( ) ) ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a ) NEW_LINE print ( min ( a [ n - 1 ] , a [ 0 ] ) * min ( a [ n - 1 ] , a [ 0 ] ) ) NEW_LINE
MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE for p p
x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( x - a ) % b ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT if a [ i ] != a [ i + k - 1 ] : NEW_LINE INDENT ans . append ( i + k - 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT if len ( ans ) == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k - 1 ) NEW_LINE DEDENT DEDENT
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) ; NEW_LINE DEDENT n = 7 ; NEW_LINE print ( " The ▁ number ▁ after ▁ unsetting ▁ " , " the ▁ rightmost ▁ set ▁ bit ▁ " , fun ( n ) ) ; NEW_LINE
def LongestFibSubseq ( A , n ) : NEW_LINE INDENT S = set ( ) NEW_LINE for t in A : NEW_LINE INDENT S . add ( t ) NEW_LINE DEDENT maxLen = 0 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ j ] NEW_LINE y = A [ i ] + A [ j ] NEW_LINE length = 3 NEW_LINE while ( S . count ( y ) and ( y != S [ last ] ) ) : NEW_LINE INDENT z = x + y NEW_LINE x = y NEW_LINE y = z NEW_LINE length = 3 NEW_LINE DEDENT DEDENT DEDENT return maxLen if max ( length ) >= 3 else 0 NEW_LINE DEDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE
def countPairs ( a , b , n , m ) : NEW_LINE INDENT cnt = 0 NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT sum = a [ i ] + b [ j ] NEW_LINE if ( s . isupper ( sum ) == False ) : NEW_LINE INDENT cnt += 1 NEW_LINE s . add ( sum ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 12 , 2 , 7 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 4 , 3 , 8 ] NEW_LINE m = len ( b ) NEW_LINE print ( countPairs ( a , b , n , m ) ) NEW_LINE DEDENT
def check ( arr , x , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = sqrt ( arr [ i ] ) NEW_LINE if ( y == floor ( y ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum % x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 13 NEW_LINE if ( check ( arr , x , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT command , t = map ( int , input ( ) . split ( ) ) NEW_LINE if command == 0 : NEW_LINE INDENT ans = a [ t ] [ 0 ] NEW_LINE DEDENT elif command == 1 : NEW_LINE INDENT ans = a [ t ] [ 1 ] NEW_LINE DEDENT elif command == 2 : NEW_LINE INDENT ans = a [ t ] [ 0 ] if a [ t ] [ 1 ] else 0 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def calculate_min_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE max_sum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT max_sum += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT def calculate_max_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE max_sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT max_sum += abs ( a [ n - 1 - i ] - a [ i ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , - 10 , 20 , - 40 ] NEW_LINE n = len ( a ) NEW_LINE print ( " The ▁ minimum ▁ sum
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT if a [ i ] < b [ i ] : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( 1 ) NEW_LINE
a = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT if b [ i ] % 4 == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c == 0 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def isPalindrome ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def ans ( s ) : NEW_LINE INDENT s2 = s NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s2 = s2 [ len ( s ) - 1 ] + s2 NEW_LINE s2 = s2 [ : : - 1 ] NEW_LINE if ( isPalindrome ( s2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return F
def count_numbers ( k , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT k = 10 NEW_LINE n = 3 NEW_LINE print ( count_numbers ( k , n ) ) NEW_LINE
def minCost ( n , arr , cost ) : NEW_LINE INDENT sum = 0 NEW_LINE totalCost = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT totalCost += cost * sum NEW_LINE arr [ n - 1 ] += sum NEW_LINE totalCost += ( 2 * cost * arr [ n - 1 ] ) NEW_LINE return totalCost NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE cost = 1 NEW_LINE print ( minCost ( n , arr , cost ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( b + c ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def solve ( m , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for c in m : NEW_LINE INDENT if c == ' I ' : NEW_LINE INDENT i = j = 0 NEW_LINE while i < n and c [ i ] == ' O ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( n ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in s : NEW_LINE INDENT if len ( i ) % 25 == 0 : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( root , data ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT if data < root . data : NEW_LINE INDENT root . left = insert ( root . left , data ) NEW_LINE DEDENT if data > root . data : NEW_LINE INDENT root . right = insert ( root . right , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE root = None NEW_LINE for i in range ( n ) : NEW_LINE INDENT root = insert ( root , arr [ i ] ) NEW_LINE DEDENT inOrder ( root ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def removeChars ( str , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT res = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCStuff = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCStuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_
def countOccurrences ( x , d ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 10 == d ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def maxOccurring ( x ) : NEW_LINE INDENT if ( x < 0 ) : NEW_LINE INDENT x = - x NEW_LINE DEDENT result = 0 NEW_LINE max_count = 1 NEW_LINE for d in range ( 0 , 9 + 1 ) : NEW_LINE INDENT count = countOccurrences ( x , d ) NEW_LINE if ( count >= max_count ) : NEW_LINE INDENT max_count = count NEW_LINE result = d NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT x = 1223355 NEW_LINE print ( " Max ▁ occurring ▁ digit ▁ is " , maxOccurring ( x ) ) NEW_LINE
def printLogestIncSubArr ( arr , n ) : NEW_LINE INDENT max = 1 NEW_LINE len = 1 NEW_LINE maxIndex = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( max < len ) : NEW_LINE INDENT max = len NEW_LINE maxIndex = i - max NEW_LINE DEDENT len = 1 NEW_LINE DEDENT DEDENT if ( max < len ) : NEW_LINE INDENT max = len NEW_LINE maxIndex = n - max NEW_LINE DEDENT for i in range ( maxIndex , max + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 5 , 6 , 3 , 5 , 7 , 8 , 9 , 1 , 2 ] NEW_LINE n = len NEW_LINE printLogestIncSubArr ( arr , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT k = n // 2 NEW_LINE print ( k , end = " ▁ " ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT k = n // 2 NEW_LINE print ( k , end = " ▁ " ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print (
def Max_Sum ( a , n ) : NEW_LINE INDENT b = [ 0 ] * n NEW_LINE S = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = res NEW_LINE res += a [ i ] NEW_LINE S += a [ i ] NEW_LINE res = max ( res , - S ) NEW_LINE DEDENT ans = S NEW_LINE ans = max ( ans , res ) NEW_LINE g = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT g -= a [ i ] NEW_LINE ans = max ( ans , g + b [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ - 6 , 10 , - 3 , 10 , - 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( " Maximum ▁ sum ▁ is : " , Max_Sum ( a , n ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( 2 * a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 * a - 1 ) NEW_LINE DEDENT DEDENT
def reverse ( str , x ) : NEW_LINE INDENT n = len ( str ) - x NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x , n ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE x = 3 NEW_LINE reverse ( str , x ) NEW_LINE DEDENT
lps = len ( str ( input ( ) ) ) NEW_LINE n = len ( str ( input ( ) ) ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - i + 1 ) : NEW_LINE INDENT j = i + i - 1 NEW_LINE if ( str ( i ) == str ( j ) and str ( i ) == str ( j ) ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( str ( i ) == str [ j ] ) : NEW_LINE INDENT L [ i
def bit_check ( n ) : NEW_LINE INDENT if ( ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT n = 14 ; NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( '1' ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] <= a [ i + 1 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 - 1 NEW_LINE primes = eulerlib . list_primes ( LIMIT // 2 ) NEW_LINE for i in range ( LIMIT // 2 , - 1 , - 1 ) : NEW_LINE INDENT end = primes [ i ] NEW_LINE if end >= LIMIT : NEW_LINE INDENT end += 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = - end - 1 NEW_LINE DEDENT count += end - i NEW_LINE DEDENT return str ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
m , k = 20 , 100 NEW_LINE dp = [ [ 0 for i in range ( m ) ] for j in range ( k ) ] NEW_LINE def count
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = str ( input ( ) ) NEW_LINE if ( 9 - k . index ( '9' ) ) < ( k . index ( '0' ) ) : NEW_LINE INDENT print ( 9 - k . index ( '9' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k . index ( '9' ) + 1 ) NEW_LINE DEDENT DEDENT
def isPeak ( arr , n , num , i , j ) : NEW_LINE INDENT if ( i >= 0 and arr [ i ] > num ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( j < n and arr [ j ] > num ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def isTrough ( arr , n , num , i , j ) : NEW_LINE INDENT if ( i >= 0 and arr [ i ] < num ) : NEW_LINE INDENT return False ; NEW_
def index ( i ) : NEW_LINE INDENT return 1 + ( i >> 31 ) - ( i >> 31 ) ; NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT s = [ " negative " , " zero " , " positive " ] ; NEW_LINE val = index ( n ) ; NEW_LINE print ( n , " is " , s [ val ] ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT check ( 30 ) ; NEW_LINE check ( - 20 ) ; NEW_LINE DEDENT
def frequency ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 0 , 5 , 5 , 5 , 4 ] NEW_LINE x = 5 NEW_LINE n = len ( a ) NEW_LINE print ( frequency ( a , n , x ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if len ( s ) < n : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) NEW_LINE if ( 1. * sq * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isPrime ( sq ) NEW_LINE DEDENT num = 9 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT n = ONE NEW_LINE d = sum ( n ** int ( eulerlib . sqrt ( n ) ) for eulerlib . pow in [ 0 ] * 99 ) NEW_LINE ans = 0 NEW_LINE while n != 0 : NEW_LINE INDENT divrem = n % 3 NEW_LINE ans += divrem * ( n // divrem ) NEW_LINE n = n // div rem NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def LCM ( x , y , z ) : NEW_LINE INDENT ans = ( ( x * y ) // gcd ( x , y ) ) NEW_LINE return ( ( z * ans ) / ( gcd ( ans , z ) ) ) NEW_LINE DEDENT def findDivisible ( n , x , y , z ) : NEW_LINE INDENT lcm = LCM ( x , y , z ) NEW_LINE ndigitnumber = pow ( 10 , n - 1 ) NEW_LINE reminder = ndigitnumber % lcm NEW_LINE if ( reminder == 0 ) : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT ndigitnumber += lcm - reminder NEW_LINE if ( ndigitnumber < pow ( 10 , n ) ) : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == " _
MAXN = 100001 ; NEW_LINE prime = [ True ] * MAXN ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( MAXN ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAXN , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def common_prime ( a , b ) : NEW_LINE INDENT gcd = ( a , b ) ; NEW_LINE for i in range ( 2 , int ( ( gcd ) ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( prime [ i ] and gcd % i == 0 ) : NEW_LINE INDENT print ( i
n = int ( input ( ) ) NEW_LINE s , l = [ ] , [ ] NEW_LINE for i in range ( n ) : s . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE for i in range ( n ) : l . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE for j in l
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = max ( a ) NEW_LINE print
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ input ( ) for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( m - 1 ) : NEW_LINE INDENT if a [ i ] [ j ] + a [ i + 1 ] [ j + 1 ] == a [ i + 1 ] [ j + 1 ] + a [ i + 1 ] [ j ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) . rstrip ( ) NEW_LINE ans = [ ] NEW_LINE for i in s : NEW_LINE INDENT if i != n - 1 : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT ans . append ( n ) NEW_LINE print ( len ( ans ) ) NEW_LINE
a = input ( ) NEW_LINE b = input ( ) NEW_LINE c = input ( ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT a [ i ] = a [ i ] . lower ( ) NEW_LINE DEDENT for i in range ( len ( b ) ) : NEW_LINE INDENT b [ i ] = b [ i ] . lower ( ) NEW_LINE DEDENT for i in range ( len ( c ) ) : NEW_LINE INDENT c [ i ] = c [ i ] . lower ( ) NEW_LINE DEDENT for i in range ( a . count ( ' a ' ) + 1 ) : NEW_LINE INDENT print ( " AC " if
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , l = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ input ( ) for i in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if a [ i ] [ j ] == '1' : NEW_LINE
class
def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( int ) ( ( pow ( x , 2 ) * ( pow ( x , 2 * n ) - 1 ) ) / ( pow ( x , 2 ) - 1 ) ) ; NEW_LINE sum2 = ( int ) ( ( x * y * ( pow ( x , n ) * pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ; NEW_LINE return sum1 + sum2 ; NEW_LINE DEDENT x = 2 ; y = 2 ; n = 2 ; NEW_LINE print ( sum ( x , y , n ) ) ; NEW_LINE
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return sum NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def getSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT sum = sum + n % 10 ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 687 ; NEW_LINE print ( getSum ( n ) ) ; NEW_LINE
def getSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += n % 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 687 ; NEW_LINE print ( getSum ( n ) ) ; NEW_LINE
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head head
n , m , l = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT print ( max ( a ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE x = [ ] NEW_LINE y = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE x . append ( a ) NEW_LINE y . append ( b ) NEW_LINE DEDENT if m == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x . sort ( ) NEW_LINE y . sort ( ) NEW_LINE print ( sum ( x [ 0 : m - 1 ] ) ) NEW_LINE DEDENT
h , w = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT s = input ( ) NEW_LINE for j in range ( w ) : NEW_LINE INDENT if s [ j ] == ' . ' : NEW_LINE INDENT ans . append ( j + 1 ) NEW_LINE DEDENT DEDENT DEDENT ans . append ( h - 1 ) NEW_LINE ans . append ( w - 1 ) NEW_LINE print ( max ( ans ) ) NEW_LINE
def minReplacement ( string ) : NEW_LINE INDENT if ( len ( string ) > 26 ) : NEW_LINE INDENT print ( " IMPOSSIBLE " ) NEW_LINE DEDENT else : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT if ( hash [ j ] == 0 ) : NEW_LINE INDENT hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE string = string [ : i ] + chr ( j + ord ( ' a ' ) ) + string [ i + 1 : ] NEW_LINE hash [ j ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( string ) NEW_LINE DEDENT
def longestSubseq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_0 = [ 0 ] * n + 2 NEW_LINE pre_count_1 = [ 0 ] * n + 1 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pre_count_0 [ j ] = pre_count_0 [ j - 1 ] NEW_LINE pre_count_1 [ j ] =
def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ True for i in range ( N + 1 ) ] NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 for i in range ( N + 1 ) ] NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE print ( " Factor ▁ None " ) NEW_LINE curr = s
def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num != 0 ) : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num //= 10 NEW_LINE DEDENT DEDENT longest = - 1 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 10 ) : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 63 ] NEW_LINE n = len ( a )
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + b + c ) // 2 ) NEW_LINE DEDENT
def Divisors ( x ) : NEW_LINE INDENT c = 0 NEW_LINE v = [ ] NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x //= 2 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 3 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x //= 3 NEW_LINE DEDENT v . append ( c ) NEW_LINE v . append ( x ) NEW_LINE return v NEW_LINE DEDENT def MinOperations ( a , b ) : NEW_LINE INDENT va = Divisors ( a ) NEW_LINE vb = Divisors ( b ) NEW_LINE if ( va [ 3 ] != vb [ 3 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = abs ( va [ 0 ] - vb [ 0 ] ) + abs ( va [ 1 ] - vb [ 1 ]
N = 1000001 NEW_LINE c , n , m = 0 , 1000001 NEW_LINE def dfs ( a , b , v , vis ) : NEW_LINE INDENT vis [ a ] = 1 NEW_LINE c += 1 NEW_LINE for i in v [ a ] : NEW_LINE INDENT if ( vis [ i ] == 0 and i != b ) : NEW_LINE INDENT dfs ( i , b , v , vis ) NEW_LINE DEDENT DEDENT DEDENT def Calculate
n = int ( input ( ) ) NEW_LINE while ( n ) : NEW_LINE INDENT n = str ( n % 10 ) NEW_LINE DEDENT print ( n ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = a + b NEW_LINE d = a // b NEW_LINE e = a % b NEW_LINE print ( c * d + e ) NEW_LINE
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE res = max ( res , getSum ( n // i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE
l , r = map ( int , input ( ) . split ( ) ) NEW_LINE n = 0 NEW_LINE while l <= r : NEW_LINE INDENT n += 1 NEW_LINE l = ( l + r ) // 2 NEW_LINE DEDENT print ( n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE DEDENT DEDENT print ( * a ) NEW_LINE
import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isProduct ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num /= i NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT def findNumbers ( N ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isProduct ( i ) and isPerfectSquare ( i ) ) : NEW_LINE INDENT vec . append ( i ) NEW_LINE DEDENT DEDENT for itr in vec : NEW_LINE INDENT print ( itr , end = " ▁ " ) NEW_LINE DEDENT DEDENT N = 30 NEW_LINE findNumbers (

n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if ( x < 10 ) : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( x > 0 ) : NEW_LINE INDENT print ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT DEDENT DEDENT
def divSum ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def areEquivalent ( num1 , num2 ) : NEW_LINE INDENT return divSum ( num1 ) == divSum ( num2 ) NEW_LINE DEDENT num1 = 559 NEW_LINE num2 = 703 NEW_LINE if areEquivalent ( num1 , num2 ) : NEW_LINE INDENT print ( " Equivalent " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Equivalent " ) NEW_LINE DEDENT
def findY ( x ) : NEW_LINE INDENT if ( x > 2 ) : NEW_LINE INDENT return x - 2 NEW_LINE DEDENT return x + 2 NEW_LINE DEDENT x = 5 NEW_LINE print ( findY ( x ) ) NEW_LINE
MOD = 1000000007 NEW_LINE def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( modFact ( n , m ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE ans . append ( a [ i + 1 ] ) NEW_LINE DEDENT ans . append ( a [ - 1 ] ) NEW_LINE print ( len ( ans ) ) NEW_LINE print ( * ans ) NEW_LINE
w , h = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = "
def circlearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) NEW_LINE return A NEW_LINE DEDENT a = 8 ; b = 10 NEW_LINE print ( circlearea ( a , b ) ) NEW_LINE
def find ( arr , length , s ) : NEW_LINE INDENT for i in range ( 1 , ( pow ( 2 , length ) ) + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( ( ( i >> j ) & 1 ) % 2 == 1 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT DEDENT if ( sum == s ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sum = 5 NEW_LINE arr = [ - 1 , 2 , 4 , 121 ] NEW_LINE length = len ( arr ) NEW_LINE find ( arr , length , sum ) NEW_LINE DEDENT
def K_String ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE fre = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT fre [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT str = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( fre [ i ] % k == 0 ) : NEW_LINE INDENT x = fre [ i ] // k NEW_LINE while ( x != 0 ) : NEW_LINE INDENT str += chr ( i + ord ( ' a ' ) ) NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabb " NEW_LINE k = 2 NEW_LINE print ( K_String ( s , k ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = [ [ 0.0 for j in range ( 21 ) ] for i in range ( 21 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT p [ i ] [ i ] = 1.0 NEW_LINE for j in range ( 21 ) : NEW_LINE INDENT p [ i ] [ j ] = p [ i ] [ j ] / ( p [ i ] [ j ] - p [ i ] [ j ] ) / ( p [ i ] [ j ] - p [ i ] [ j ] ) NEW_LINE DEDENT DEDENT p = p [ n - 1 ] [ 1 ] + p [ n - 1 ] [ 0 ] + p [ n - 1 ] [ 1 ]
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT a , b , n = map ( float , line . split ( ) ) NEW_LINE x = [ a / b ] * n NEW_LINE y = [ a / b ] * n NEW_LINE x . append ( b ) NEW_LINE y . append ( a / n ) NEW_LINE z . append ( n ) NEW_LINE print ( sum ( x [ 0 : a ] ) + sum ( y [ 0 : b ] ) + sum ( z [ 0 : a ] ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = 2 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] <= a [ i + 1 ] : NEW_LINE INDENT m = max ( m , i + 1 ) NEW_LINE DEDENT DEDENT print ( m ) NEW_LINE
while True : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and k == 0 : NEW_LINE INDENT break NEW_LINE DEDENT A = [ int ( input ( ) ) for _ in range ( k ) ] NEW_LINE B = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] > B [ i ] : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT
def maxFreq ( s , a , b ) : NEW_LINE INDENT fre = [ 0 ] * 10 NEW_LINE n = len ( s ) NEW_LINE if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT fre [ s [ i ] - '0' ] += 1 NEW_LINE DEDENT if ( fre [ a ] == 0 and fre [ b ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( fre [ a ] >= fre [ b ] ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 4 NEW_LINE b = 7 NEW_LINE s = "47744" NEW_LINE print ( maxFreq ( s , a , b ) ) NEW_LINE DEDENT
def maxZeros ( n ) : NEW_LINE INDENT if ( n == 0 or ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT b = 4 NEW_LINE setBit = 1 NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , b * 8 + 1 ) : NEW_LINE INDENT prev += 1 NEW_LINE if ( ( n & setBit ) == setBit ) : NEW_LINE INDENT setBit = setBit << 1 NEW_LINE break NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE DEDENT max0 = - 1 NEW_LINE cur = prev NEW_LINE for j in range ( i + 1 , b * 8 + 1 ) : NEW_LINE INDENT cur += 1 NEW_LINE if ( ( n & setBit ) == setBit ) : NEW_LINE INDENT if ( max0 < ( cur - prev - 1 ) ) : NEW_LINE INDENT max0 = cur - prev - 1 NEW_LINE DEDENT prev = cur NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE DEDENT return max0 NEW_LINE DEDENT n = 549 NEW_LINE print ( maxZeros ( n ) ) NEW_LINE
def sumPowersK ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE num = 1 NEW_LINE while ( num <= n ) : NEW_LINE INDENT sum += num NEW_LINE num *= k NEW_LINE DEDENT return sum NEW_LINE DEDENT def getSum ( n , k ) : NEW_LINE INDENT pwrK = sumPowersK ( n , k ) NEW_LINE sumAll = ( n * ( n + 1 ) ) // 2 NEW_LINE return ( sumAll - pwrK ) NEW_LINE DEDENT n = 10 NEW_LINE k = 3 NEW_LINE print ( getSum ( n , k ) ) NEW_LINE
def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT rslt = [ 0 ] * 3 NEW_LINE x = - D / A NEW_LINE y = - D / B NEW_LINE z = - D / C NEW_LINE rslt [ 0 ] = x NEW_LINE rslt [ 1 ] = y NEW_LINE rslt [ 2 ] = z NEW_LINE return rslt NEW_LINE DEDENT A = 2 NEW_LINE B = 5 NEW_LINE C = 7 NEW_LINE D = 8 NEW_LINE rslt = XandYandZintercept ( A , B , C , D ) NEW_LINE print ( rslt ) NEW_LINE
def maxSum ( a , n ) : NEW_LINE INDENT l = [ ] ; NEW_LINE s = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += abs ( a [ i ] ) ; NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT l . append ( i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( i + 1 ) ; NEW_LINE l . append ( i ) ; NEW_LINE DEDENT DEDENT print ( s ) ; NEW_LINE for i in l : NEW_LINE INDENT print ( l [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 4 ; NEW_LINE a = [ 1 , - 2 , - 3 , 4 ] ; NEW_LINE maxSum ( a , n ) ; NEW_LINE
MAX = 1000 NEW_LINE def replaceSpaces ( str ) : NEW_LINE INDENT space_count = 0 NEW_LINE i = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT space_count += 1 NEW_LINE DEDENT DEDENT while ( str [ i - 1 ] == ' ▁ ' ) : NEW_LINE INDENT space_count -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT new_length = i + space_count * 2 NEW_LINE if ( new_length > MAX ) : NEW_LINE INDENT return str NEW_LINE DEDENT index = new_length - 1 NEW_LINE new_str = str NEW_LINE str = new_str NEW_LINE for i in range ( i - 1 , - 1 , - 1 ) : NEW_
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == "1" : NEW_LINE INDENT ans . append ( i + 1 ) NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT m = n NEW_LINE while ( n ) : NEW_LINE INDENT r = n % 10 NEW_LINE if ( r > 0 ) : NEW_LINE INDENT if ( ( m % r ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def count ( l , r ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( check ( i ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT l = 10 NEW_LINE r = 20 NEW_LINE print ( count ( 10 , 20 ) ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( a , b ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ( a , b ) NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = l + l NEW_LINE mn = 10000000000 NEW_LINE idx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] == 0 : NEW_LINE INDENT idx = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if l [ i ] == 0 and l [ j ] == 0 : NEW_LINE INDENT idx = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if idx == n - 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( idx ) NEW_LINE DEDENT
n = input ( ) NEW_LINE n = int ( n ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif n % 4 == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n % 4 == 2 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif n % 4 == 4 and n != 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
k = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT a . append ( int ( s [ i ] ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT ans += ( ( a [ i ] - '0' ) * ( len ( a [ i ] ) - 1 ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE while n > 1 : NEW_LINE INDENT if n % k == 0 : NEW_LINE INDENT ans += n // k NEW_LINE n //= k NEW_LINE DEDENT else : NEW_LINE INDENT ans += n // k + 1 NEW_LINE n //= k NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def digSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 1234 NEW_LINE print ( digSum ( n ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE dp = [ 0 ] * ( m + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( a [ i ] == b [ j ] ) : NEW_LINE INDENT dp [ i + 1 ] = max ( dp [ i ] , dp [ i + 1 ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( max ( dp ) ) NEW_LINE
def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( n , " th ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ " , centered_heptagonal_num ( n ) ) NEW_LINE
def missingNum ( arr , n ) : NEW_LINE INDENT list = [ ] ; NEW_LINE for i in arr : NEW_LINE INDENT list . append ( i ) ; NEW_LINE DEDENT minvalue = min ( list ) ; NEW_LINE xornum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT xornum ^= ( minvalue ) ^ arr [ i ] ; NEW_LINE minvalue += 1 ; NEW_LINE DEDENT return xornum ^ minvalue ; NEW_LINE DEDENT arr = [ 13 , 12 , 11 , 15 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( missingNum ( arr , n ) ) ; NEW_LINE
def smallestPermute ( n ) : NEW_LINE INDENT res = [ 0 ] * ( n + 1 ) ; NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) ; NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) ; NEW_LINE DEDENT DEDENT res [ n - 1 ] = chr ( 48 + n - 2 ) ; NEW_LINE res [ n - 2 ] = chr ( 48 + n ) ; NEW_LINE res [ n - 3 ] = chr ( 48
def minOperations ( a , n , K ) : NEW_LINE INDENT map = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT try : NEW_LINE INDENT if ( map [ a [ i ] ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT except KeyError : NEW_LINE INDENT map [ a [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT b = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = a [ i ] &
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( y , x + y , y )
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 180 == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT

n , k = map ( int , input ( ) . split ( ) ) NEW_LINE h = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k >= n : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT if h [ i + k ] - h [ i ] < h [ i + k ] : NEW_LINE INDENT h [ i + k ] = h [ i + k ] - h [ i ] NEW_LINE DEDENT DEDENT if n % 2 : NEW_LINE INDENT print ( n // 60 , n // 60 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n // 60 , n // 60 ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( a , a * b , a ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT s , t = input ( ) . split ( ) NEW_LINE if t == '0' : NEW_LINE INDENT break NEW_LINE DEDENT A = 0.0 NEW_LINE B = 0.0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT if s [ i ] == t : NEW_LINE INDENT A += 1 NEW_LINE DEDENT elif s [ i ] == '1' : NEW_LINE INDENT B += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B -= 1 NEW_LINE DEDENT DEDENT if A < 0.0 : NEW_LINE INDENT A , B = 0.0 , A NEW_LINE DEDENT print ( B , B ) NEW_LINE DEDENT
def findMaxValue ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT print ( " The ▁ array ▁ should ▁ have ▁ atleast ▁ 4 ▁ elements " ) NEW_LINE DEDENT table1 = [ 0 ] * ( n + 1 ) NEW_LINE table2 =
def centeredHexagonalSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( 3 * i * ( i - 1 ) + 1 , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 10 ; NEW_LINE centeredHexagonalSeries ( n ) ; NEW_LINE
s = input ( ) NEW_LINE if s == " ABC " : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE l = [ ] NEW_LINE for i in s : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT c = 0 NEW_LINE for i in l : NEW_LINE INDENT if i == ' ▁ ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if k == ' ▁ ' : NEW_LINE INDENT print ( c , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in l : NEW_LINE INDENT if i == ' ▁ ' : NEW_LINE INDENT print ( c , end = ' ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
n = len ( mat ) ; NEW_LINE if n == 0 : NEW_LINE INDENT return ; NEW_LINE DEDENT principalMin , principalMax
n = len ( mat ) ; NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT principalMin , principalMax = mat [ 0 ] [ 0 ] , mat [ 0 ] [ 0 ] ; NEW_LINE secondaryMin
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT sum = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT count += 1 NEW_LINE sum += n NEW_LINE n = n - 2 NEW_LINE DEDENT return sum / count NEW_LINE DEDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) ; NEW_LINE return - 1 ; NEW_LINE DEDENT return ( n + 1 ) / 2 ; NEW_LINE DEDENT n = 15 ; NEW_LINE print ( averageOdd ( n ) ) ; NEW_LINE
def areElementsContiguous ( arr , n ) : NEW_LINE INDENT us = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT us [ arr [ i ] ] = i NEW_LINE DEDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while ( us [ curr_ele ] == True ) : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while ( us [ curr_ele ] == True ) : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == ( len ( us ) ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if areElementsContiguous ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def getLeftMostZero ( queue ) : NEW_LINE INDENT if ( isEmpty ( queue ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT queue . remove ( queue [ 0 ] ) NEW_LINE return 0 NEW_LINE DEDENT
def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) NEW_LINE print ( val * ( x < 0 ? - 1 : 1 ) , end = " ▁ " ) NEW_LINE print ( val * ( y < 0 ? - 1 : 1 ) , end = " ▁ " ) NEW_LINE print ( val * ( y < 0 ? - 1 : 1 ) , end = " ▁ " ) NEW_LINE DEDENT x , y = 3 , 3 NEW_LINE Vertices ( x , y ) NEW_LINE
def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 ] * n ; NEW_LINE P [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] ; NEW_LINE DEDENT S = P [ n -
def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr [ i ] = temp [ k ] NEW_LINE temp . remove ( k ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT Arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( Arr ) NEW_LINE originalArray ( Arr , n ) NEW_LINE
s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT a = input ( ) NEW_LINE if a . count ( ' r ' ) == 0 and a . count ( ' p ' ) == 0 : NEW_LINE INDENT x += 1 NEW_LINE DEDENT if a . count ( ' p ' ) == 0 and a . count ( ' r ' ) == 0 : NEW_LINE INDENT y += 1 NEW_LINE DEDENT DEDENT print ( min ( x , y ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def findRadius ( self , houses , heaters ) : NEW_LINE INDENT houses . sort ( ) NEW_LINE result = houses [ 0 ] - houses [ - 1 ] NEW_LINE for house in houses : NEW_LINE INDENT if house < 0 : NEW_LINE INDENT break NEW_LINE DEDENT dist1 = houses [ house ] - house NEW_LINE dist2 = houses [ house - 1 ] - house NEW_LINE if dist1 < dist2 : NEW_LINE INDENT dist = dist1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE houses = [ 1 , 2 , 3 ] NEW_LINE heaters = [ 2 , 2 , 3 ] NEW_LINE out = sObj . findRadius ( houses , heaters ) NEW_LINE print ( out ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( i % 5 for i in range ( 7 , 25 ) if i % 5 != 0 and i - 1 % findLeastDivisibleRepunit ( i ) == 0 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def findLeastDivisibleRepunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n > 10 ** 18 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n > 10 ** 18 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n > 10 ** 9 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n > 10 ** 9 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n > 10 ** 9 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE def checkRecursive ( num , x , k , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT if x == 0 : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT for i in range ( k + 1 , r + 1 ) : NEW_LINE INDENT a = x - ( int ) ( math . pow ( i , n ) ) NEW_LINE if a >= 0 : NEW_LINE INDENT checkRecursive ( num , x - int ( math . pow ( i , n ) ) , i , n ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def check ( x , n ) : NEW_LINE INDENT return checkRecursive ( x , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( check ( 10 , 2 ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE ans = " " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT ans += s [ - 1 ] NEW_LINE print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp = [ 0 ] * ( 10001 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10001 ) : NEW_LINE INDENT if dp [ i ] == 0 : NEW_LINE INDENT dp [
n = int ( input ( ) ) NEW_LINE s = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ i + 1 ] = str ( i ) NEW_LINE DEDENT print ( sum ( s ) - max ( s ) ) NEW_LINE
def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT sum = 0 ; NEW_LINE temp = 0 ; NEW_LINE sum = a + b ; NEW_LINE temp = 1 ; NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT temp = 2 ; NEW_LINE DEDENT while ( not prime ( sum + temp ) ) : NEW_LINE INDENT temp += 2 ; NEW_LINE DEDENT print ( temp ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 ; NEW_LINE b = 5 ; NEW_LINE thirdNumber ( a , b ) ; NEW_LINE DEDENT
def Squares ( n , m , a ) : NEW_LINE INDENT return ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) NEW_LINE DEDENT n = 6 NEW_LINE m = 6 NEW_LINE a = 4 NEW_LINE print ( Squares ( n , m , a ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if ( n % m ) == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , j * j * j + 1 ) : NEW_LINE INDENT if ( j * j * j == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT a = 7 NEW_LINE b = 30 NEW_LINE print ( " Count ▁ of ▁ Cubes ▁ is " , countCubes ( a , b ) ) NEW_LINE
n
def SubString ( str , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT print ( str [ i : j ] ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abcd " ; NEW_LINE SubString ( str , str . count ( " " ) ) ; NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countPrimePosition ( arr ) : NEW_LINE INDENT c0 = 0 NEW_LINE c1 = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 and isPrime ( i ) ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT if ( arr [ i ] == 1 and isPrime ( i ) ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ 0s ▁ = ▁ " , c0 ) NEW_LINE print ( " Number ▁ of ▁ 1s ▁ = ▁ " , c1 ) NEW_LINE DEDENT arr = [ 1 , 0 , 1 , 0 , 1 ] NEW_LINE countPrimePosition ( arr ) NEW_LINE
def angleextcyc quadrilateral ▁ is ▁ " , " The ▁ exterior ▁ angle ▁ of ▁ the " , " cyclic ▁ quadrilateral ▁ is " , " degrees " ) ; NEW_LINE print ( " The ▁ exterior ▁ angle ▁ of ▁ the " , " ▁ cyclic ▁ quadrilateral ▁ is " , " degrees " ) ; NEW_LINE
def printMinIndexChar ( str , patt ) : NEW_LINE INDENT minIndex = 10 ** 9 NEW_LINE m = len ( patt ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != 10 ** 9 ) : NEW_LINE INDENT print ( " Minimum ▁ Index ▁ Character ▁ = ▁ " , str [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ character ▁ present " ) NEW_LINE DEDENT DEDENT str = " geeksforgeeks " NEW_LINE patt = " set " NEW_LINE printMinIndexChar ( str , patt ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( ( a , b ) ) NEW_LINE DEDENT l . sort ( ) NEW_LINE for i in l : NEW_LINE INDENT print ( ' Happy ' , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE
def maxnumber ( n , k ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 1 NEW_LINE while ( n / i > 0 ) : NEW_LINE INDENT temp = ( n / ( i * 10 ) ) * i + ( n % i ) NEW_LINE i *= 10 NEW_LINE ans = max ( ans , temp ) NEW_LINE DEDENT n = ans NEW_LINE DEDENT return n NEW_LINE DEDENT n = 6358 NEW_LINE k = 1 NEW_LINE print ( maxnumber ( n , k ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE w = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE w [ a ] += 1 NEW_LINE w [ b ] -= 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( w [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE if i < n : NEW_LINE INDENT a [ i ] = a [ i ] - a [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE if i < n - 1 : NEW_LINE INDENT a [ i ] = a [ i + 1 ] - a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def get_last_two_digit ( N ) : NEW_LINE INDENT if ( N <= 10 ) : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT return ans % 100 NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT N = 1 NEW_LINE for N in range ( 1 , 10 + 1 ) : NEW_LINE INDENT print ( " For ▁ N ▁ = " , N , " : ▁ " , get_last_two_digit ( N ) ) NEW_LINE DEDENT
def binaryNumber ( ) : NEW_LINE INDENT return "1001" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT binaryNumber = "1001" NEW_LINE print ( int ( binaryNumber , 2 ) ) NEW_LINE DEDENT
def isPossible ( x , y , z ) : NEW_LINE INDENT a = x * x + y * y + z * z NEW_LINE if ( math . ceil ( a ) == 1 and math . floor ( a ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT l = 0.7071067825 NEW_LINE m = 0.5 NEW_LINE n = 0.5 NEW_LINE if ( isPossible ( l , m , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE MOD = 10000007 NEW_LINE result = [ 0 ] * MAX NEW_LINE fact = [ 0 ] * MAX NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( fact [ i - 1 ] % MOD ) * i % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT res += a [ i ] - a [ i + 1 ] NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] <= 0 : NEW_LINE INDENT arr [ i ] = - arr [ i - 1 ] NEW_LINE DEDENT DEDENT return j = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT arr [ i ] = - arr [ i - 1 ] NEW_LINE DEDENT DEDENT
mod = 1000000007 NEW_LINE def digitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT temp = digitNumber ( ( n - 1 ) / 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT DEDENT def countExcluding ( n , d ) : NEW_LINE INDENT if ( d == 0 ) : NEW_LINE INDENT return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT d = 9 NEW_LINE n = 3 NEW_LINE print ( countExcluding ( n , d ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( * ( [ 2 * ( a [ i ] + a [ i + 1 ] ) // 2 + 1 ] ) , * ( [ 2 * ( a [
def convert12 ( str ) : NEW_LINE INDENT h1 = ord ( str [ 0 ] ) - ord ( '0' ) NEW_LINE h2 = ord ( str [ 1 ] ) - ord ( '0' ) NEW_LINE hh = h1 * 10 + h2 NEW_LINE Meridien = " AM " NEW_LINE if ( hh < 12 ) : NEW_LINE INDENT Meridien = " AM " NEW_LINE DEDENT else : NEW_LINE INDENT Meridien = " PM " NEW_LINE DEDENT if ( hh % 12 != 0 ) : NEW_LINE INDENT Mag = " AM " NEW_LINE DEDENT else : NEW_LINE INDENT Mag = " PM " NEW_LINE DEDENT if ( mag < 10 ) : NEW_LINE INDENT Mag = " AM " NEW_LINE DEDENT else : NEW_LINE INDENT Mag = " PM " NEW_LINE DEDENT str = str [ : : - 1 ] NEW_LINE str = str [ : : - 1 ] NEW_LINE print ( str , " ▁ " , Meridien ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "17:35:
def check ( s , k ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 ; NEW_LINE n = len ( a ) ; NEW_LINE m = len ( b ) ; NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) ) : NEW_LINE INDENT ct += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = " xaxa " ; b = " xaxa " ; NEW_LINE print ( countCommonDivisors ( a , b ) ) ;
def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for i in range ( W + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if ( i == 0 or w == 0 ) : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif ( wt [ i - 1 ] <= w ) : NEW_LINE INDENT K [ i ] [ w ] = max (
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( [ a [ i ] [ 0 ] , a [ i ] [ 1 ] ] ) NEW_LINE DEDENT c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if b [ i ] [ j ] == a [ i ] [ j ] : NEW_LINE INDENT c . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( len ( c ) ) NEW_LINE
def indexedSubstring ( arr , n , k ) : NEW_LINE INDENT elements = [ 0 for i in range ( 20 ) ] NEW_LINE indices = [ 0 for i in range ( 20 ) ] NEW_LINE temp = 0 NEW_LINE i = 0 NEW_LINE ind = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ ind ] = arr [ i ] NEW_LINE indices [ ind ] = i NEW_LINE ind += 1 NEW_LINE DEDENT if ( k < elements [ 0 ] ) : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , ind + 1 ) : NEW_LINE INDENT if ( k == arr [ i ] ) : NEW_LINE INDENT j = 1 NEW_LINE break NEW
def larrgestPalindrome ( n ) : NEW_LINE INDENT upper_limit = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT upper_limit *= 10 NEW_LINE upper_limit += 9 NEW_LINE DEDENT lower_limit = 1 + upper_limit // 10 NEW_LINE max_product = 0 NEW_LINE for i in range ( upper_limit , lower_limit , - 1 ) : NEW_LINE INDENT for j in range ( i , lower_limit , - 1 ) : NEW_LINE INDENT product = i * j NEW_LINE if ( product < max_product ) : NEW_LINE INDENT break NEW_LINE DEDENT number = product NEW_LINE reverse = 0 NEW_LINE while number != 0 : NEW_LINE INDENT reverse = reverse * 10 + number % 10 NEW_LINE number //= 10 NEW_LINE DEDENT if ( product == reverse and product > max_product ) : NEW_LINE INDENT max_product = product NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT n = 2 NEW_LINE print ( larroringPalindrome ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < a [ i + 1 ] : NEW_LINE INDENT dp = dp + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp = dp + a [ i + 1 ] - a [ i ] NEW_LINE DEDENT DEDENT print ( dp ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a == 0 and b == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif a == 1 and b == 1 : NEW_LINE INDENT print ( c ) NEW_LINE DEDENT elif c == 0 and a == 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif a == 1 and b == 1 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif c == 0 and a == 1 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif a == 1 and b == 1 : NEW_LINE INDENT print ( 5 ) NEW_LINE D
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += max ( 0 , a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def maximumXor ( arr , n ) : NEW_LINE INDENT sForward = [ ] NEW_LINE sBackward = [ ] NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( sForward ) and arr [ i ] < arr [ sForward [ - i - 1 ] ] ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] ^ arr [ sForward [ i ] ] ) NEW_LINE sForward . pop ( ) NEW_LINE DEDENT sForward . append ( i ) NEW_LINE while ( len ( sBackward ) and arr [ n - i - 1 ] < arr [ sBackward [ - i - 1 ] ] ) : NEW_LINE INDENT ans = max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward [ i ] ] ) NEW_LINE sBackward . pop ( ) NEW_LINE DEDENT sBackward . append ( n - i - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 8 , 1 , 2 ] NEW_LINE n = len (
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ 0 ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) NEW_LINE i += 1 NEW_LINE DEDENT n = n // 16 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( hexaDeciNum [ j ] , end = " " ) NEW_LINE DEDENT DEDENT n = 2545 NEW_LINE decToHexa ( n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = max ( ans , a [ i - 1 ] + a [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT R , C = map ( int , input ( ) . split ( ) ) NEW_LINE if R == 0 and C == 0 : NEW_LINE INDENT break NEW_LINE DEDENT max_num = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s . count ( " _ " ) == 0 and s . count ( " x " ) == 0 : NEW_LINE INDENT max_num = max ( max_num , i + C ) NEW_LINE DEDENT elif s . count ( " x " ) == 0 and s . count ( " y " ) == 0 : NEW_LINE INDENT max_num = max ( max_num , i + C ) NEW_LINE DEDENT DEDENT print ( max_num ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( " Hello ▁World " ) NEW_LINE DEDENT else : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( " Hello ▁World " + a + b ) NEW_LINE DEDENT
def extractMaximum ( string ) : NEW_LINE INDENT num = 0 ; res = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT num = num * 10 + ( ord ( string [ i ] ) - ord ( '0' ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , num ) ; NEW_LINE num = 0 ; NEW_LINE DEDENT DEDENT return max ( res , num ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "100klh564abc222bg " ; NEW_LINE print ( extractMaximum ( string ) ) ; NEW_LINE DEDENT
from math import sqrt NEW_LINE def find_Indices ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * ( maxsize ) ; NEW_LINE index_1 , index_2 , index_3 , index = 0 , 0 , 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT ans = - ( 1e15 ) ; NEW_LINE index_1 = index_2 = index_3 = - 1 ; NEW_LINE for l in range ( n + 1 ) : NEW_LINE INDENT index = 0 ; NEW_LINE vmin = ( 1e15 ) ; NEW_LINE for r in range ( l , n + 1 ) : NEW_LINE INDENT if ( sum [ r ] < vmin ) : NEW_LINE INDENT vmin =
def printElements ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printElements ( arr , n ) ; NEW_LINE
def valueofX ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ar [ i ] NEW_LINE DEDENT if ( sum % n == 0 ) : NEW_LINE INDENT return sum / n NEW_LINE DEDENT else : NEW_LINE INDENT A = sum / n NEW_LINE B = sum / n + 1 NEW_LINE ValueA = 0 NEW_LINE ValueB = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ValueA += ( ar [ i ] - A ) * ( ar [ i ] - B ) NEW_LINE ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) NEW_LINE DEDENT if ( ValueA < ValueB ) : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT return B NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE arr = [ 6 , 9 , 1 , 6 , 1 , 3 , 7 ] NEW_LINE print ( valueofX ( arr , n ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , l = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
s = input ( ) NEW_LINE t = len ( s ) NEW_LINE for i in range ( t // 2 ) : NEW_LINE INDENT if s [ i ] != s [ t - 1 - i ] : NEW_LINE INDENT print ( s [ t - 1 - i ] + s [ t - 1 - i ] ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( s [ t - 1 - i ] + s [ t - 1 - i ] ) NEW_LINE
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 19 NEW_LINE while curr <= n : NEW_LINE INDENT sum = 0 NEW_LINE for x in range ( curr , 0 , - 1 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT curr += 9 NEW_LINE DEDENT DEDENT print ( findNth ( 5 ) ) NEW_LINE
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for curr in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for x in range ( curr , 10 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT DEDENT print ( findNth ( 5 ) ) NEW_LINE
def countNumber ( N , S ) : NEW_LINE INDENT countElements = 0 ; NEW_LINE currSum = 0 ; NEW_LINE while ( currSum <= S ) : NEW_LINE INDENT currSum += N ; NEW_LINE N -= 1 ; NEW_LINE countElements += 1 ; NEW_LINE DEDENT return countElements ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , S = 5 ; NEW_LINE S = 11 ; NEW_LINE count = countNumber ( N , S ) ; NEW_LINE print ( count ) ; NEW_LINE DEDENT
def strmatch ( str , pattern , n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return ( n == 0 ) NEW_LINE DEDENT lookup = [ [ 0 for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE lookup [ 0 ] [ 0 ] = True NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE while n : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( " a " if ( b - a ) % n == 0 else " b " ) NEW_LINE n -= 1 NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT fac = [ 1 ] * 100 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT fac [ i ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i ; NEW_LINE DEDENT ans = fac [ n ] // ( fac [ n - r ] * fac [ r ] ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 ; NEW_LINE k = 3 ; NEW_LINE ans = nCr ( n + k - 1 , k ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < 2 * a [ i ] : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def powGCD ( a , n , b ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a = a * a ; NEW_LINE DEDENT return gcd ( a , b ) ; NEW_LINE DEDENT a = 10 ; NEW_LINE b = 5 ; NEW_LINE n = 2 ; NEW_LINE print ( powGCD ( a , n , b ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] + b [ i ] > a [ i + 1 ] + a [ i ] : NEW_LINE INDENT print ( a [ i ] , a [ i + 1 ] + b [ i ] ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT print ( a [ n - 1 ] , a [ n - 1 ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( int ( s [ i ] ) ) NEW_LINE DEDENT ans = min ( l ) NEW_LINE print ( ans ) NEW_LINE
def sumOfDigit ( n , b ) : NEW_LINE INDENT unitDigit = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b ; NEW_LINE sum += unitDigit ; NEW_LINE n = n // b ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 50 ; NEW_LINE b = 2 ; NEW_LINE print ( sumOfDigit ( n , b ) ) ; NEW_LINE
def printLargestDivisible ( n , a ) : NEW_LINE INDENT c0 , c5 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c5 += 1 NEW_LINE DEDENT DEDENT c5 = floor ( c5 / 9 ) * 9 NEW_LINE if ( c0 == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif ( c5 == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( c5 ) : NEW_LINE INDENT print ( 5 ) NEW_LINE DEDENT for i in range ( c0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT a = [ 5 , 5 , 5 , 5 , 5 , 5 , 0 , 5 , 0 , 5 ] NEW_LINE n = len ( a ) NEW_LINE printLargestDivisible ( n , a ) NEW_LINE
def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE
def numberOfMinutes ( S , S1 ) : NEW_LINE INDENT Min = 0 NEW_LINE Min = ( ( S - S1 ) // 60 ) NEW_LINE return Min NEW_LINE DEDENT S = 30 NEW_LINE S1 = 10 NEW_LINE print ( numberOfMinutes ( S , S1 ) , " min " ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans += max ( a [ i + 1 ] - a [ i ] , b [ i ] - b [ i + 1 ] ) NEW_LINE DEDENT ans += max ( a [ - 1 ] - a [ 0 ] , b [ - 1 ] - b [ 0 ] ) NEW_LINE print ( ans ) NEW_LINE
def onesComplement ( n ) : NEW_LINE INDENT number_of_bits = ( int ) ( ( math . floor ( math . log ( n ) / math . log ( 2 ) ) ) + 1 ) NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ n NEW_LINE DEDENT n = 22 NEW_LINE print ( onesComplement ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT w , h , n = map ( int , input ( ) . split ( ) ) NEW_LINE a = 1 NEW_LINE while w % 2 == 0 and h % 2 == 0 : NEW_LINE INDENT w //= 2 NEW_LINE a *= 2 NEW_LINE DEDENT while w % 2 == 0 and n % 2 == 0 : NEW_LINE INDENT w //= 2 NEW_LINE n *= 2 NEW_LINE DEDENT if a == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( " ( " , ( 2 * x2 - x1 ) + " , " , ( 2 * y2 - y1 ) , " ) " ) ; NEW_LINE DEDENT x1 , y1 , x2 , y2 = 0 , 1 , 1 ; NEW_LINE findPoint ( x1 , y1 , x2 , y2 ) ; NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT n1 = int ( input ( ) ) NEW_LINE n2 = int ( input ( ) ) NEW_LINE n3 = int ( input ( ) ) NEW_LINE n4 = int ( input ( ) ) NEW_LINE n5 = int ( input ( ) ) NEW_LINE n6 = int ( input ( ) ) NEW_LINE n7 = int ( input ( ) ) NEW_LINE n8 = int ( input ( ) ) NEW_LINE if n1 % 2 == 0 : NEW_LINE INDENT ans = n1 - n2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = n1 - n2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def alter ( x , y ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT if ( x == 0 or y == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT elif ( x >= 2 * y ) : NEW_LINE INDENT x = x % ( 2 * y ) ; NEW_LINE DEDENT elif ( y >= 2 * x ) : NEW_LINE INDENT y = y % ( 2 * x ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT print ( " X ▁ = " , x , " , ▁ " , y ) ; NEW_LINE DEDENT x = 12 ; NEW_LINE y = 5 ; NEW_LINE alter ( x , y ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = max ( ans , a [ i ] - a [ j ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if s [ i - 1 ] != s [ i ] : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT print ( - 1 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
mod = 1000000007 ; NEW_LINE inv2 = 500000001 ; NEW_LINE modulo ( L ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( len ( L ) ) : NEW_LINE INDENT res = ( res * 10 + ord ( L [ i ] ) - ord ( '0' ) ) % mod ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findSum ( L , R ) : NEW_LINE INDENT a , b , l , r , ret = 0 , modulo ( L ) ; NEW_LINE a = modulo ( R ) ; NEW_LINE b = modulo ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; NEW_LINE l = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; NEW_LINE r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; NEW_LINE ret = ( r % mod - l % mod ) ; NEW_LINE if ( ret < 0 ) : NEW_LINE INDENT ret = ret + mod ; NEW_LINE DEDENT else : NEW
def unsort ( l , r , a , k ) : NEW_LINE INDENT if ( k < 1 or l + 1 == r ) : NEW_LINE INDENT return ; NEW_LINE DEDENT k -= 2 ; NEW_LINE mid = ( l + r ) // 2 ; NEW_LINE temp = a [ mid - 1 ] ; NEW_LINE a [ mid - 1 ] = a [ mid ] ; NEW_LINE a [ mid ] = temp ; NEW_LINE unsort ( l , mid , a , k ) ; NEW_LINE unsort ( mid , r , a , k ) ; NEW_LINE DEDENT def arrayWithKCalls ( n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( " NO ▁ SOLUTION " ) ; NEW_LINE return ; NEW_LINE DEDENT a [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = i + 1 ; NEW_LINE DEDENT k -= 1 ; NEW_LINE unsort ( 0 , n
import math NEW_LINE mean ( mid , freq , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE freqSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + mid [ i ] * freq [ i ] ; NEW_LINE freqSum = freqSum + freq [ i ] ; NEW_LINE DEDENT return sum / freqSum ; NEW_LINE DEDENT def groupedSD ( lower_limit , upper_limit , freq , n ) : NEW_LINE INDENT mid = [ 0 ] * ( n ) ; NEW_LINE sum = 0 ; NEW_LINE freqSum = 0 ; NEW_LINE sd = 0 ; NEW_LINE for i in range ( n ) : NEW
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE
def rectanglearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( rectanglearea ( a , b ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n == a == b == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " )
def getsum ( x ) : NEW_LINE INDENT return ( x * ( x + 1 ) ) / 2 NEW_LINE DEDENT def countJumps ( n ) : NEW_LINE INDENT n = abs ( n ) NEW_LINE ans = 0 NEW_LINE while ( getsum ( ans ) < n or ( ( getsum ( ans ) - n ) & 1 ) > 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 9 NEW_LINE print ( countJumps ( n ) ) NEW_LINE
MAX = 10 NEW_LINE dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE def lcs ( arr1 , arr2 , n , arr2 , m , k ) : NEW_LINE INDENT if ( k < 0 ) : NEW_LINE INDENT return - 10000000 NEW_LINE DEDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = max ( lcs
import sys NEW_LINE import math NEW_LINE from bisect import bisect_right as br NEW_LINE from bisect import bisect_left as bl NEW_LINE sys . setrecursionlimit ( 1000000 ) NEW_LINE from heapq import heappush , heappop , heappushpop NEW_LINE from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE from collections import Counter NEW_LINE from collections import deque NEW_LINE from operator import itemgetter NEW_LINE from itertools import permutations NEW_LINE mod = 10 ** 9 + 7 NEW_LINE inf = float ( ' inf ' ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE while 1 : NEW_LINE INDENT n , d , x = LI ( ) NEW_LINE if n == 0 : NEW_LINE INDENT quit ( ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += ( d * ( i - 1 ) ) // n NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def reverseorder ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for i in range ( n , 2 , - 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT N = 25 ; NEW_LINE print ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) ; NEW_LINE if ( N == 1 ) : NEW_LINE INDENT print ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT reverseorder ( N ) ; NEW_LINE DED
def pattern ( min_stars , p_height ) : NEW_LINE INDENT p_space = p_height - 1 NEW_LINE p_space = p_space - 1 NEW_LINE i , j , k , n = 0 , 0 , 0 NEW_LINE x = 1 NEW_LINE for i in range ( p_height ) : NEW_LINE INDENT for j in range ( p_space , i , - 1 ) : NEW_LINE INDENT print ( " * " , end = " ▁ " ) NEW_LINE DEDENT for k in range ( min_stars ) : NEW_LINE INDENT print ( " * " , end = " ▁ " ) NEW_LINE DEDENT for n in range ( ( p_height + p_height - 2 ) , x ) : NEW_LINE INDENT print ( " * " , end = " ▁ " ) NEW_LINE DEDENT for n in range ( ( p_height + p_height - 2 ) , x ) : NEW_LINE INDENT print ( " * " , end = " ▁ " ) NEW_LINE DEDENT for k in range ( min_stars
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( list ( input ( ) ) ) NEW_LINE DEDENT m = [ ] NEW_LINE for i in l : NEW_LINE INDENT m . append ( [ i [ 0 ] , i [ 1 ] , i [ 2 ] ] ) NEW_LINE DEDENT for i in m : NEW_LINE INDENT if ( i [ 0 ] [ 0 ] < i [ 1 ] [ 0 ] ) : NEW_LINE INDENT if ( i [ 0 ] [ 1 ] > i [ 1 ] ) : NEW_LINE INDENT if ( i [ 1 ] > i [ 0 ] ) : NEW_LINE INDENT l [ i [ 0 ] [ 0 ] ] += i [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT l [ i [ 0 ] [ 1 ] ] += i [ 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT l [ i [ 0 ] [ 1 ] ] += i [ 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i [ 1 ] > i [ 0 ]
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE
def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return round ( phi , n ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT def sumFibonacci ( k ) : NEW_LINE INDENT l = ( k * ( k - 1 ) ) / 2 NEW_LINE r = l + k NEW_LINE sum = calculateSum ( l , r - 1 ) NEW_LINE return sum NEW_LINE DEDENT k = 3 NEW_LINE print ( sumFibonacci ( k ) ) NEW_LINE
def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return round ( phi , n ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE
def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return int ( math . pow ( phi , n ) / sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return int ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( int ( calculateSum ( l , r ) ) ) NEW_LINE DEDENT
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if l == r : NEW_LINE INDENT print ( ' ' . join ( s ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT
def compareStrings ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( str1 ) - 1 and str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( str1 [ i ] > str2 [ i ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if (
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( str ( a + b ) ) NEW_LINE
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE a = ( x1 - x2 ) + ( y1 - y2 ) NEW_LINE b = ( x1 - x2 ) + ( y1 - y2 ) NEW_LINE c = ( x1 + x2 ) + ( y1 - y2 ) NEW_LINE d = ( x1 - x2 ) + ( y1 - y2 ) NEW_LINE e = ( y1 + y2 ) + ( x1 - x2 ) NEW_LINE print ( f ' { e : .6f } ' ) NEW_LINE print ( d , e .6f ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != s [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) NEW_LINE return ( n ) * ( 1 + n ) * d / 2 NEW_LINE DEDENT def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE return ( int ( n ) * ( 1 + n ) * d / 2 ) NEW_LINE DEDENT n = 20 NEW_LINE print ( sumMultiples ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , s , f = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE if sum ( a ) <= s : NEW_LINE INDENT print ( " OK " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s - sum ( a ) ) NEW_LINE DEDENT DEDENT
def fact ( num ) : NEW_LINE INDENT fact = 1 NEW_LINE while ( num > 1 ) : NEW_LINE INDENT fact *= num NEW_LINE num -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT return fact ( 2 * n ) // ( fact ( n ) * fact ( n + 1 ) ) NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE i , k = 0 , 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ k ] ) : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT catalan_leftBST = catalan ( s ) NEW_LINE catalan_rightBST = catalan ( n - s - 1 ) NEW_LINE totalBST = catalan_rightBST * catalan_leftBST NEW_LINE print ( totalBST , " ▁ " , end = " " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if abs ( a - b ) == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a % 2 == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT DEDENT
def countWays ( n , arr , len ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) ; NEW_LINE count [ 0 ] = 1 ; NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 ; NEW_LINE for j in range ( len ) : NEW_LINE INDENT if ( i - arr [ j ] >= 0 ) : NEW_LINE INDENT no_ways += count [ i - arr [ j ] ] ; NEW_LINE DEDENT count [ i ] = no_ways ; NEW_LINE DEDENT DEDENT return count [ n ] ; NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] ; NEW_LINE len = len ( arr ) ; NEW_LINE n = 5 ; NEW_LINE print ( countWays ( n , arr , len ) ) ; NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT data = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT sum += data [ i ] NEW_LINE DEDENT sum = sum - n NEW_LINE if n == 1 : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a == b and c == b ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( a == b and c == b ) or ( a == b and c == b ) : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( a , b , c ) + 2 * min ( a , b , c ) ) NEW_LINE DEDENT DEDENT
n , b , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= b : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n , key = len ( arr ) NEW_LINE print ( " Index : ▁ " , binarySearch ( arr , 0 , n , key ) ) NEW_LINE
def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE Xor = Xor ^ arr [ i ] NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE equal_xor_sum ( arr , n ) NEW_LINE DEDENT
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT print ( i + 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE
def findPairs ( arr , n ) : NEW_LINE INDENT cntEven = 0 ; cntOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 ; NEW_LINE DEDENT DEDENT evenPairs = 0 ; NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; NEW_LINE oddPairs = 0 ; NEW_LINE oddPairs += ( cntEven * cntOdd ) ; NEW_LINE print ( " Odd ▁ pairs ▁ = " , oddPairs ) ; NEW_LINE print ( " Even ▁ pairs ▁ = " , evenPairs ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findPairs ( arr , n ) ; NEW_LINE
def minBroadcastRange ( houses , towers ) : NEW_LINE INDENT n = len ( towers ) NEW_LINE m = len ( towers ) NEW_LINE leftTower = towers [ 0 ] NEW_LINE rightTower = towers [ 0 ] NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE min_range = 0 NEW_LINE while j < n : NEW_LINE INDENT if houses [ j ] < rightTower : NEW_LINE INDENT left = houses [ j ] - leftTower NEW_LINE right = rightTower - houses [ j ] NEW_LINE local_max = left NEW_LINE if ( local_max > min_range ) : NEW_LINE INDENT min_range = local_max NEW_LINE DEDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT leftTower = towers [ k ] NEW_LINE if ( k < m - 1 ) : NEW_LINE INDENT k += 1 NEW_LINE rightTo
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) ; NEW_LINE DEDENT print ( getRemainder ( 100 , 7 ) ) ; NEW_LINE
n , m , z = map ( int , input ( ) . split ( ) ) NEW_LINE print ( n + m + z ) NEW_LINE
while 1 : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == n == 0 : break NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT a [ i + 1 ] = int ( input ( ) ) NEW_LINE DEDENT print ( max ( a ) ) NEW_LINE DEDENT
n , w = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT b = sorted ( zip ( a , a [ 1 : ] ) , reverse = True ) NEW_LINE print ( sum ( b [ 1 : ] ) / w for b in b ) NEW_LINE
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE common_bit_mask = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT arr = [ 3 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is " , getSingle ( arr , n ) ) NEW_LINE
def maxdiff ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( freq [ arr [ i ] ] > freq [ j ] and arr [ i ] > freq [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ j ] ) NEW_LINE DEDENT elif ( freq [ arr [ i ] ] < freq [ j ] and arr [ i ] < freq [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ j ] - freq [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE k = n * m NEW_LINE if k % 2 == 0 : NEW_LINE INDENT print ( s - ( k - 1 ) * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT
def makeAP ( arr , n ) : NEW_LINE INDENT initial_term , common_difference = 0 , arr [ 2 ] - arr [ 1 ] NEW_LINE if ( n == 3 ) : NEW_LINE INDENT common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( arr [ 1 ] - arr [ 0 ] == arr [ 2 ] - arr [ 1 ] ) : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 0 ] ) : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT initial_term = ( arr [ 3 ] - arr [ 0
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def longestPalindrome ( self , s ) : NEW_LINE INDENT count = [ 0 ] * 32768 NEW_LINE for c in s : NEW_LINE INDENT count [ c ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for v in count : NEW_LINE INDENT ans += v // 2 * 2 NEW_LINE if ( ans % 2 == 0 and v % 2 == 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = " abccccdd " NEW_LINE out = sObj . longestPalindrome ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c / ( n + 1 ) NEW_LINE DEDENT def findWays ( n ) : NEW_LINE INDENT if ( ( n & 1 ) != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return catalan ( n / 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( " Total ▁ possible ▁ expression ▁ of ▁ length ▁ " , n , " is " , findWays ( n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE o = 0 NEW_LINE for x in s : NEW_LINE INDENT if x == ' O ' : NEW_LINE INDENT o += 1 NEW_LINE DEDENT DEDENT for x in s : NEW_LINE INDENT if x == ' X ' : NEW_LINE INDENT x = 0 NEW_LINE DEDENT DEDENT print ( x , o ) NEW_LINE
a , b , c , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT for j in range ( b ) : NEW_LINE INDENT if ( i + j ) % c == 0 and ( i + j ) % d == 0 and ( i
def isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT n = 10 NEW_LINE if ( isSumOfPowersOfTwo ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT s = [ ] NEW_LINE if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT tp = s [ : - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 9 + 1 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE print ( countNumber ( n ) ) NEW_LINE
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp
MAX = 1000000 NEW_LINE sieve_Prime = [ 0 ] * ( MAX + 4 ) NEW_LINE def sieve_count ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 4 ) : NEW_LINE INDENT if ( sieve_Prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 4 , i ) : NEW_LINE INDENT if ( sieve_Prime [ j ] == 0 ) : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( " Count ▁ = " , ( sieve_count ( ) ) ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = " , ( sieve_count [ n ] + 1 ) ) NEW_LINE DEDENT
n , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += max ( 0.0 * ( t - a [ i ] ) , 0.0 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans += max ( 0.0 * ( t - b [ i ] ) , 0.
def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE prefix = [ 0 ] * ( n ) NEW_LINE suffix = [ 0 ] * ( 26 ) NEW_LINE seen = [ 0 ] * ( 26 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = ( i - 1 >= 0 ) NEW_LINE if ( seen [ s [ i ] - ' a ' ] == 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev NEW_LINE DEDENT seen [ s [ i ] - ' a ' ] = 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT seen
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , eulerlib . sqrt ( 1 + 8 * ( i + 1 ) // 2 ) if i < i else i for i in range ( 1 + 8 * ( i + 1 ) // 2 ) if i > i else i for i in range ( 1 + 8 * ( i + 1 ) // 2 ) ) for i in range ( i + 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE D
arr1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] NEW_LINE arr2 = [ 1 , 5 , 9 , 10 , 15 , 20 ] NEW_LINE def merge ( m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = arr1 [ m - 1 ] NEW_LINE for k in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT arr1 [ k ] = arr1 [ k ] + arr1 [ k - 1 ] NEW_LINE DEDENT if ( k != m - 2 or last > arr2 [ i ] ) : NEW_LINE INDENT arr2 [ i ] = arr2 [ i ] NEW_LINE arr2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] NEW_LINE arr2 = [ 1 , 5 , 9 , 10 , 15 , 20 ] NEW_LINE n = len ( arr1
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def sameRemainder ( a , b , c ) : NEW_LINE INDENT a1 = ( b - a ) NEW_LINE b1 = ( c - b ) NEW_LINE c1 = ( c - a ) NEW_LINE return gcd ( a1 , gcd ( b1 , c1 ) ) NEW_LINE DEDENT a = 62 NEW_LINE b = 132 NEW_LINE c = 237 NEW_LINE print ( sameRemainder ( a , b , c ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE
dp = [ [ 0 for i in range ( 5001 ) ] for i in range ( 5001 ) ] NEW_LINE def countWaysUtil ( n , parts , nextPart ) : NEW_LINE INDENT if ( parts == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 or parts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ nextPart ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , parts - 1 , i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT for i in range ( 5001 ) : NEW_LINE INDENT for j in range ( 5001 ) : NEW_LINE INDENT for l in range ( 5 ) : NEW_
def find_k ( a , b ) : NEW_LINE INDENT if ( ( a + b ) % 2 == 0 ) : NEW_LINE INDENT return ( ( a + b ) // 2 ) ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT a , b = 2 , 16 ; NEW_LINE print ( find_k ( a , b ) ) ; NEW_LINE
N = 101 NEW_LINE mod = ( 1e9 + 7 ) NEW_LINE exactsum = [ [ 0 for i in range ( N ) ] for i in range (
def isValidString ( str ) : NEW_LINE INDENT freq = [ 0 ] * CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT i , freq1 , count_freq1 = 0 , 0 , 0 NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT if ( freq [ i ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE b = ' a ' NEW_LINE for i in s : NEW_LINE INDENT if i % 2 : NEW_LINE INDENT b += a NEW_LINE DEDENT else : NEW_LINE INDENT a = a + b NEW_LINE DEDENT DEDENT print ( b ) NEW_LINE DEDENT
def findMinimumSubsequences ( A , B ) : NEW_LINE INDENT numberOfSubsequences = 1 NEW_LINE sizeOfB = len ( B ) NEW_LINE sizeOfA = len ( A ) NEW_LINE inf = 1000000 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( sizeOfB ) : NEW_LINE INDENT next [ i ] [ j ] = inf NEW_LINE DEDENT DEDENT for i in range ( sizeOfB ) : NEW_LINE INDENT next [ ord ( A [ i ] ) - ord ( '
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( * ( [ * ( a - b ) for a , b in zip ( a , b ) ] ) ) NEW_LINE DED
def FindRank ( arr , length ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) ; NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT rank = 1 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT rank += 1 ; NEW_LINE DEDENT DEDENT print ( rank , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT arr = [ 88 , 14 , 69 , 30 , 29 , 89 ] ; NEW_LINE len = len ( arr ) ; NEW_LINE FindRank ( arr , len ) ; NEW_LINE
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b . sort ( ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + h NEW_LINE ans = min ( ans , a [ j ] - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product // pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE
while True : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT m , n = n , m NEW_LINE DEDENT print ( m * n ) NEW_LINE DEDENT
s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans += ( ord ( s [ i ] ) - 96 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def complement ( num ) : NEW_LINE INDENT i , len = 0 , 0 NEW_LINE temp = num NEW_LINE while ( True ) : NEW_LINE INDENT len += 1 NEW_LINE num = num // 10 NEW_LINE if ( abs ( num ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT num = temp NEW_LINE comp = pow ( 10 , len ) - num NEW_LINE return comp NEW_LINE DEDENT print ( complement ( 25 ) ) NEW_LINE print ( complement ( 456 ) ) NEW_LINE
def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return int ( bin ( x ^ n ) . count ( '1' ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT maxi = 0 NEW_LINE result = 0 NEW_LINE freq = [ 0 ] * 1000001 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x ] += 1 NEW_LINE DEDENT maxi = max ( freq ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE
def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _
def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c ; NEW_LINE DEDENT x = ( ( b // c ) * c ) + c ; NEW_LINE return x ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 4 ; NEW_LINE c = 4 ; NEW_LINE GFG ( ) ; NEW_LINE print ( getMinNum ( a , b , c ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE maxlv = 0 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == ' I ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxlv = max ( maxlv , i ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( maxlv ) NEW_LINE
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = sorted ( [ int ( input ( ) ) for i in range ( n ) ] ) NEW_LINE p . pop ( 0 ) NEW_LINE p = sorted ( p ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] <= 0 : NEW_LINE INDENT ans += m * p [ i ] NEW_LINE m -= p [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m += p [ i ] NEW_LINE ans += m * p [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , b [ i ] - a [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def countWays ( N ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) ; NEW_LINE count [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 0 , length ) : NEW_LINE INDENT if ( i >= arr [ j ] ) : NEW_LINE INDENT count [ i ] += count [ i - arr [ j ] ] ; NEW_LINE DEDENT DEDENT DEDENT return count [ N ] ; NEW_LINE DEDENT N = 7 ; NEW_LINE print ( " Total ▁ number ▁ of ▁ ways ▁ = " , countWays ( N ) ) ; NEW_LINE
def numberOfWays ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) NEW_LINE DEDENT DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def countFreq ( a , n ) : NEW_LINE INDENT sm = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT sm [ a [ i ] ] += 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += sm [ a [ i ] ] NEW_LINE if ( hm [ a [ i ] ] != 0 ) : NEW_LINE INDENT print ( a [ i ] , " - > " , cumul ) NEW_LINE DEDENT sm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 2 , 4 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE DEDENT
def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE numbersInRange = ( R - L + 1 ) ; NEW_LINE if ( numbersInRange < 3 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT elif ( numbersInRange > 3 ) : NEW_LINE INDENT flag = True ; NEW_LINE if ( L % 2 > 0 ) : NEW_LINE INDENT L += 1 ; NEW_LINE DEDENT possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L +
def get_input ( ) : NEW_LINE INDENT return input ( ) NEW_LINE DEDENT def get_input ( ) : NEW_LINE INDENT return input ( ) . strip ( ) NEW_LINE DEDENT def get_input ( ) : NEW_LINE INDENT return input ( ) . strip ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT char_list = " qwertyuiopasdfghjklmnopqrstuvwxyz " NEW_LINE s1 = " egrt " NEW_LINE s2 = " qwertyui " NEW_LINE print ( s1 , s2 ) NEW_LINE DEDENT
def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if ( count == k ) : NEW_LINE INDENT return ( num ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( " The " , size ( ) , " ▁ " , " distinct ▁ integers ▁ are : " ) NEW_LINE print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 8 , 17 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE printDistinctIntegers ( k , arr , n ) NEW_LINE DEDENT
def product ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT prod *= ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT def findNumber ( l , r ) : NEW_LINE INDENT b = str ( r ) NEW_LINE ans = r NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if ( b [ i ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT curr = b [ i ] NEW_LINE curr [ i ] = ( chr ( ord ( curr [ i ] ) - ord ( '0' ) ) - 1 ) + int ( '0' ) NEW_LINE for j in range ( i + 1 , len ( curr ) ) : NEW_LINE INDENT curr [ j ] = ( '9' ) NEW_LINE DEDENT DEDENT num
MAX = 100005 NEW_LINE isPrime = [ True for i in range ( MAX ) ] NEW_LINE def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT def minNumber ( arr , n ) : NEW_LINE INDENT sieveOfEratostheneses ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( not isPrime [ sum ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT def minNumber ( arr , n ) : NEW_LINE INDENT s
MAX = 25 NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * MAX NEW_LINE max_bit = 0 NEW_LINE sum = 0 NEW_LINE ans = 0 NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] NEW_LINE f = 0 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 NEW_LINE e = e // 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = pow ( 2 , d ) NEW_LINE if ( bits_count [ d ] > n / 2 ) : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' . ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ans > 0 : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( b [ - 1 ] + a [ i ] ) NEW_LINE DEDENT print ( * b
for _ in range ( int ( input
def findMaximumNum ( arr , n ) : NEW_LINE INDENT for i in range ( n , 1 , - 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( " P " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT DEDENT
def solve ( A , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2000 ) ] for j in range ( 2000 ) ] NEW_LINE flag = 1 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT for i in range ( - sum , - 1 , - 1
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) = map ( float , line . split ( ) ) NEW_LINE x = ( x1 * x1 + y1 * y1 + x3 * x2 + y3 * y2 ) / ( x1 * x2 + y1 * y2 ) NEW_LINE y = ( y1 * y1 + x3 * y1 + y3 * x2 + x3 * y2 ) / ( y1 * y2 + y3 * x2 + y3 * x3 ) NEW_LINE if abs ( x1 - x2 ) <= abs ( y1 - y2 ) <= abs ( y1 - y2 ) <= abs ( x1 + x2 ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
while 1 : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m + n == 0 : break NEW_LINE print ( * [ i % m for i in range ( 1 , m + n ) ] ) NEW_LINE DEDENT
l = [ [ 0 for i in range ( 1001 ) ] for i in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE DEDENT
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a == b and b == c ) * ( d == c ) or ( a == b and b == c ) * ( d == c ) or ( a == b and b == c ) * ( d == d ) or ( a == c and b == d ) * ( d == d ) ) NEW_LINE
def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = ( int ) ( a [ i ] / mul ) NEW_LINE print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map (
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = n - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == ' < ' or s [ i ] == ' > ' or s [ i ] == ' < ' : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = ' ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += str ( input ( ) ) NEW_LINE DEDENT print ( s ) NEW_LINE
import math NEW_LINE v_lines = input ( ) . split ( ) NEW_LINE v_lines = [ int ( i ) for i in v_lines ] NEW_LINE n = int ( input ( ) ) NEW_LINE t = int ( input ( ) ) NEW_LINE pas = 0.0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pas += ( float ( t * v_lines [ i ] ) / ( v_lines [ i ] - v_lines [ i ] ) ) NEW_LINE DEDENT print ( f " { pas } ▁ { t / ( v_lines [ n ] - pas ) } " ) NEW_LINE
a , b , c = map ( int , input ( ) . split ( " : " ) ) NEW_LINE print ( a + b if a + b < c else c ) NEW_LINE
def longestAlternatingSubarray ( a , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] * a [ i - 1 ] < 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE longest = max ( longest , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT return longest NEW_LINE DEDENT a = [ - 5 , - 1 , - 1 , 2 , - 2 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestAlternatingSubarray ( a , n ) ) NEW_LINE
def checkTypeOfTriangle ( a , b , c ) : NEW_LINE INDENT sqa = pow ( a , 2 ) NEW_LINE sqb = pow ( b , 2 ) NEW_LINE sqc = pow ( c , 2 ) NEW_LINE if ( sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb ) : NEW_LINE INDENT print ( " Right - angled ▁ Triangle " ) NEW_LINE DEDENT elif ( sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb ) : NEW_LINE INDENT print ( " Obtuse - angled ▁ Triangle " ) NEW_LINE DEDENT elif ( sqa > sqc + sqb or sqc > sqa + sqc or sqc > sqa + sqb ) : NEW_LINE INDENT print ( " Acute -angled ▁ Triangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Acute - angled ▁ Triangle " ) NEW_LINE DEDENT DEDENT a , b , c = 2 , 2 NEW_LINE a = 2 NEW_LINE b = 2 NEW
def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 ; cntF = 0 ; cntF = 0 ; result = 0 ; C = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT switch ( s [ i ] ) : NEW_LINE INDENT case ' G ' : cntG += 1 ; NEW_LINE result += C ; NEW_LINE break ; NEW_LINE case ' F ' : cntF += 1 ; NEW_LINE C += cntG ; NEW_LINE break ; NEW_LINE default : continue ; NEW_LINE DEDENT DEDENT print ( result ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " GFG " ; NEW_LINE n = len ( s ) ; NEW_LINE countSubsequence ( s , n ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if abs ( x [ i ] - a [ j ] ) + abs ( y [ i ] - b [ j ]
def countSteps ( n ) : NEW_LINE INDENT steps = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT largest = cbrt ( n ) ; NEW_LINE n -= ( largest * largest * largest ) ; NEW_LINE steps += 1 ; NEW_LINE DEDENT return steps ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 150 ; NEW_LINE print ( countSteps ( n ) ) ; NEW_LINE DEDENT
while True : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = [ float ( ' inf ' ) for i in range ( 8 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE DEDENT p . sort ( ) NEW_LINE s = 0 NEW_LINE for i in range (
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mx = max ( a ) NEW_LINE mn = min ( a ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == mx : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mx = a [ i ] NEW_LINE mn = mn + 1 NEW_LINE DEDENT DEDENT if mx - mn >= 0 : NEW_LINE INDENT print ( mx - mn , mx * count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE DEDENT
def find_count ( arr ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in arr : NEW_LINE INDENT x = bin ( i ) . count ( '1' ) ; NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; NEW_LINE print ( find_count ( arr ) ) ; NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ a [ i ] ] += 1 NEW_LINE DEDENT if n % 2 != 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if b [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT if sum ( b ) % n != 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( i + 1 ) NEW_LINE DEDENT DEDENT
def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT N = 390 NEW_LINE print ( maxProd ( N ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = ans * ( len ( s [ i ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE xaxis , yaxis , radius = [ ] , [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE xaxis . append ( x ) NEW_LINE yaxis . append ( y ) NEW_LINE DEDENT xaxis . sort ( ) NEW_LINE yaxis . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans += ( xaxis [ i + 1 ] - xaxis [ i ] ) ** 2 NEW_LINE DEDENT ans += ( yaxis [ n - 1 ] - yaxis [ n - 2 ] ) ** 2 NEW_LINE print ( ans ) NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count //= i NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE
def reduceString ( s , l ) : NEW_LINE INDENT count = 1 NEW_LINE steps = 0 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT steps += ( count // 2 ) NEW_LINE count = 1 NEW_LINE DEDENT DEDENT steps += count // 2 NEW_LINE return steps NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE l = len ( s ) NEW_LINE print ( reduceString ( s , l ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b >= a : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT c = [ ] NEW_LINE for i in range ( a ) : NEW_LINE INDENT if len ( str ( i ) ) == len ( str ( i ) ) : NEW_LINE INDENT c . append ( i ) NEW_LINE DEDENT DEDENT if len ( c ) == 0 : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = c [ len ( c ) - 1 ] NEW_LINE print ( * ans ) NEW_LINE DEDENT DEDENT
x , y , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( x ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT for j in range ( y ) : NEW_LINE INDENT for k in range ( a , x + 1 ) : NEW_LINE INDENT if ( l [ k ] < l [ j ] ) : NEW_LINE INDENT l [ k ] , l [ j ] = l [ j ] , l [ k ] NEW_LINE DEDENT DEDENT DEDENT print ( len ( l ) ) NEW_LINE for l1 in l : NEW_LINE INDENT print ( str ( l1 [ 0 ] ) + " ▁ " + str ( l1 [ 1 ] ) ) NEW_LINE DEDENT
mod = 1000000007 ; NEW_LINE def mult ( a , b ) : NEW_LINE INDENT return ( ( a % mod ) * ( b % mod ) ) % mod ; NEW_LINE DEDENT def calculate_factors ( n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE cnt = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE n = n // 2 ; NEW_LINE DEDENT if ( cnt % 2 == 1 ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) ; NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE n = n // i ; NEW_LINE DEDENT if ( cnt % 2 == 1 ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = mult ( ans ,
s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' - ' and s [ i + 1 ] == ' - ' : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT elif s [ i ] == ' - ' and s [ i + 1 ] == ' - ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT arr = [ 2 , 1 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxAbsDiff ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT
def minRemove ( a , b , n , m ) : NEW_LINE INDENT countA = dict ( ) NEW_LINE countB = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( countA [ a [ i ] ] ) in countB : NEW_LINE INDENT countA [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countA [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( countB [ b [ i ] ] ) in countB : NEW_LINE INDENT countB [ b [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countB [
M = 20 NEW_LINE dp = [ [ 0 for i in range ( M ) ]
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] == 1 : NEW_LINE INDENT ans *= ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans *= ( i + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def bit ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT x = x // 2 NEW_LINE ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def check ( d , x ) : NEW_LINE INDENT if ( bit ( x // d ) <= bit ( d ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def bs ( n ) : NEW_LINE INDENT l = 1 NEW_LINE r = sqrt ( n ) NEW_LINE while ( l < r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( check ( m , n ) ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( not check ( l , n ) ) : NEW_LINE INDENT return l NEW_LINE DEDENT else : NEW_LINE INDENT return l NEW_LINE DEDENT DEDENT def countDivisor ( n ) : NEW_LINE INDENT return n - bs ( n ) + 1 NEW_LINE DEDENT def bs ( n ) : NEW_LINE INDENT n = 5 NEW_LINE print ( countDivisor ( n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ '
def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ 0 ] * n ; NEW_LINE s1 = " " ; NEW_LINE s2 = " " ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE s1 += s [ 0 ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT s1 += s [ i ] ; NEW_LINE s2 = s [ i + 1 : i + 1 ] ; NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; NEW_LINE DEDENT DEDENT return dp [ n - 1 ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaaaaaaa " ; NEW_LINE n = len ( s ) ; NEW_LINE print ( minimalSteps ( s , n ) ) ; NEW_LINE DEDENT
def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num // base , dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 32 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] ; NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT return minVal ; NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal =
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ int ( i ) for i in s . split ( ) ] NEW_LINE b = [ int ( i ) for i in s . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT ans = max ( a [ 0 ] , b [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , a [ i ] + b [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x1 , y1 , x2 , y2 , x3 , y3 = [ float ( x ) for x in input ( ) . split ( ) ] NEW_LINE distance = ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 NEW_LINE if distance > x1 + y1 + x3 + y3 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT
def nthXorFib ( n , a , b ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( a ^ b ) NEW_LINE DEDENT return nthXorFib ( n % 3 , a , b ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE n = 10 NEW_LINE print ( nthXorFib ( n , a , b ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( list ( input ( ) ) ) NEW_LINE DEDENT l . sort ( ) NEW_LINE l1 = 0 NEW_LINE l2 = 0 NEW_LINE for i in l : NEW_LINE INDENT if i . count ( '1' ) == 0 : NEW_LINE INDENT l1 += 1 NEW_LINE DEDENT elif i . count ( '0' ) == 0 : NEW_LINE INDENT l0 += 1 NEW_LINE DEDENT DEDENT print ( l1 , l2 ) NEW_LINE
def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = ( float ) 1.268 * a NEW_LINE A = ( 0.70477 * pow ( h , 2 ) ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( 1 + ( x > 12 ) for x in range ( 1 , 3 , 2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def stern_brocotcount ( leftN , leftD , rightN , rightD ) : NEW_LINE INDENT n = leftN + rightN NEW_LINE d = leftD + rightD NEW_LINE if d > 12000 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + stern_brocotcount ( leftN , leftD , n , d ) + sternBrocotcount ( n , d , rightD ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE print ( ( n // 2 ) * 2 ** ( n % 2 ) ) NEW_LINE
def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = pow ( 10 , d ) - 1 ; NEW_LINE prime = [ True ] * ( maxVal + 1 ) ; NEW_LINE sieve ( prime , maxVal ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT d = 3 ; NEW_LINE print ( sumPrime ( d ) ) ; NEW_LINE DEDENT
def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = ( pow ( 2 , d ) - 1 ) ; NEW_LINE prime = [ True ] * ( maxVal + 1 ) ; NEW_LINE sieve ( prime , maxVal ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT d = 8 ; NEW_LINE print ( sumPrime ( d ) ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p = 1 NEW_LINE s = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT s += a [ i ] NEW_LINE if s // ( k * ( k * ( i + 1 ) ) ) >= k : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a == b and a != c and b != d ) or ( b == c and b != d ) or ( c == d and c != d ) : NEW_LINE INDENT print ( ( a == b ) or ( c == d ) or ( d == a ) or ( b == c ) or ( a == d ) or ( b == d ) ) NEW_LINE DEDENT elif ( a == b and a != c and b != d ) or ( c == d and c != d ) : NEW_LINE INDENT print ( ( a == b ) or ( c == d ) or ( a == c ) or ( b == d ) or ( a == d ) or ( b == c ) or ( b == d ) ) NEW_LINE DEDENT elif ( a == b and a != c and b != d ) or ( c == d and c != a ) or ( a == d ) : NEW_LINE INDENT print ( ( a == b ) or ( c == d ) or ( a == c ) or ( b == d ) or ( c == d ) or ( b == d ) ) NEW_LINE DEDENT elif ( a == c and a !=
def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE
def countMaxContiguous ( arr , n ) : NEW_LINE INDENT current_max = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT current_max = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current_max += 1 NEW_LINE max_so_far = max ( current_max , max_so_far ) NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 4 , 3 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countMaxContiguous ( arr , n ) ) NEW_LINE
def cube ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( h * r * ( float ) sqrt ( 2 ) ) / ( h + ( float ) sqrt ( 2 ) * r ) NEW_LINE return a NEW_LINE DEDENT h = 5 NEW_LINE r = 6 NEW_LINE print ( cube ( h , r ) ) NEW_LINE
def pattern ( rows_no ) : NEW_LINE INDENT for i in range ( 1 , rows_no + 1 ) : NEW_LINE INDENT for k in range ( 1 , rows_no + 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT for i in range ( rows_no - 1 , - 1 , - 1 ) : NEW_LINE INDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT rows_no = 7 NEW_LINE pattern ( rows_no ) NEW_LINE
n = input ( ) NEW_LINE ans = 0 NEW_LINE for i in n : NEW_LINE INDENT if i == "0" : NEW_LINE INDENT ans += 10 NEW_LINE DEDENT elif i == "1" : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def check_digits ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 ) % 2 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n , n , 1 ) : NEW_LINE INDENT if ( check_digits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE
def check_digits ( n ) : NEW_LINE INDENT while ( n != 0 ) : NEW_LINE INDENT if ( n % 10 ) % 2 != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( check_digits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE
def triangular_series ( n ) : NEW_LINE INDENT i , j = 1 , 1 NEW_LINE k = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( k , end = " ▁ " ) NEW_LINE j = j + 1 NEW_LINE k = k + j NEW_LINE DEDENT DEDENT n = 5 NEW_LINE triangular_series ( n ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = sum ( a ) NEW_LINE print ( b // 2 ) NEW_LINE
def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = 0 NEW_LINE i = 2 NEW_LINE while ( i != 0 ) : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = f3 NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 5 NEW_LINE k = 4 NEW_LINE print ( " Position ▁ of ▁ n ' th ▁ multiple ▁ of ▁ k ▁ in ▁ Fibonacci ▁ Series ▁ is ▁ " , end = " " ) NEW_LINE print ( findPosition ( k , n ) ) NEW_LINE
s = input ( ) NEW_LINE n = len ( s ) NEW_LINE a = [ " ABC " , " ACB " , " BAC " , " BCA " , " CAB " , " CBA " ] NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] in a : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE DEDENT if cnt % 2 == 0 : NEW_LINE INDENT a [ i ] = " First " NEW_LINE DEDENT else : NEW_LINE INDENT b = ( " Second " ) NEW_LINE DEDENT DEDENT if cnt % 2 == 0 : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Second " ) NEW_LINE DEDENT
def countMinimumMoves ( arr , n , k ) : NEW_LINE INDENT for i in range ( k - 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return i + 1 ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] ; NEW_LINE K = 4 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countMinimumMoves ( arr , n , K ) ) ; NEW_LINE
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powerGCD ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , b ) NEW_LINE DEDENT a = 5 NEW_LINE b = 4 NEW_LINE n = 2 NEW_LINE print ( powerGCD ( a , b ) ) NEW_LINE
t , s , q = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s *= q NEW_LINE s += 1 NEW_LINE DEDENT print ( s
n = int ( input ( ) ) NEW_LINE print ( n * ( n - 2 ) ) NEW_LINE
def countIdenticalRows ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( mat ) ) : NEW_LINE INDENT hs = set ( ) NEW_LINE for j in range ( len ( mat [ i ] ) ) : NEW_LINE INDENT hs . add ( mat [ i ] [ j ] ) NEW_LINE DEDENT if ( len ( hs ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT mat = [ [ 1 , 1 , 1 ] , [ 1 , 2 , 3 ] , [ 1 , 2 , 3 ] , [ 5 , 5 , 5 ] ] NEW_LINE print ( countIdenticalRows ( mat ) ) NEW_LINE
def createSorted ( a , n ) : NEW_LINE INDENT b = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( b [ 0 ] == a [ j ] ) : NEW_LINE INDENT b . append ( a [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT start = 0 NEW_LINE end = len ( b ) - 1 NEW_LINE pos = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE if ( b [ mid ] == a [ j ] ) : NEW_LINE INDENT b . append ( ( max ( 0 , mid + 1 ) ) , a [ j ] ) NEW_LINE break NEW_LINE DEDENT elif ( b [ mid ] > a [ j ] ) : NEW_LINE INDENT pos = end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = start + 1
def countTotalDistinct ( str ) : NEW_LINE INDENT cnt = 0 NEW_LINE items = set ( ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE ans = [ ] NEW_LINE for j in range ( i , len ( str ) ) : NEW_LINE INDENT temp = temp + str [ j ] NEW_LINE ans . append ( temp ) NEW_LINE if ( not items . issubset ( ) ) : NEW_LINE INDENT items . add ( temp ) NEW_LINE cnt += len ( temp ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " ABCA " NEW_LINE print ( countTotalDistinct ( str ) ) NEW_LINE DEDENT
def firstDigit ( n ) : NEW_LINE INDENT digits = int ( ( n ) ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ( 10 ** ' . . __gcd__ ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )
def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( " Array ▁ has ▁ leading ▁ zeros ▁ only " ) NEW_LINE return NEW_LINE DEDENT b = [ 0 for i in range ( n - ind ) ] NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT b [ i ] = a [ ind + i ] NEW_LINE DEDENT for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] NEW_LINE n = len ( a ) NEW_LINE removeZeros ( a , n ) NEW_LINE
def find_maxm ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for x in mp : NEW_LINE INDENT value = x NEW_LINE freq = mp [ x ] NEW_LINE if value == freq : NEW_LINE INDENT ans = max ( ans , freq ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 2 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_maxm ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def sumOfDigitsSingle ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT ans += x % 10 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def closest ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( ans * 10 + 9 <= x ) : NEW_LINE INDENT ans = ans * 10 + 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sumOfDigitsTwoParts ( N ) : NEW_LINE INDENT A = closest ( N ) NEW_LINE return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) NEW_LINE DEDENT N = 35 NEW_LINE print ( sumOfDigitsTwoParts ( N ) ) NEW_LINE
import sys NEW_LINE for e in sys . stdin : NEW_LINE INDENT e = float ( e ) NEW_LINE h = [ [ 0.0 ] * 6.5 , [ 1.0 ] * 6.5 , [ 0.0 ] * 6.5 ] , [ 1.0 ] * 6.5 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT h [ i ] [ 0 ] = i NEW_LINE for j in range ( 6 ) : NEW_LINE INDENT if h [ i ] [ j ] > h [ j ] [ 0 ] * i : h [ i ] [ j ] = h [ j ] [ 0 ] * i NEW_LINE DEDENT DEDENT for k in range ( 1 , 7 ) : NEW_LINE INDENT l = [ ] NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT l . append ( h [ i ] [ k ] * l [ k ] [ i ] ) NEW_LINE DEDENT l . sort ( ) NEW_
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( a - c , b - d ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE if l [ - 1 ] - l [ 0 ] >= 2 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def cal_cos ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE numerator , sinx , cosx = 0.0001 , 0.0001 NEW_LINE n = n * ( math . sin ( 3.142 / 180.0 ) ) NEW_LINE x1 = n NEW_LINE sinx = n NEW_LINE cosx = n NEW_LINE i = 1 NEW_LINE while ( accuracy <= sinval - sinval ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i + 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE sinx = sinx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT while ( accuracy <= sinval - sinval ) : NEW_LINE INDENT while ( accuracy <= sinval - cosx ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i + 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE sinx = sinx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT print ( sinx ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 90 NEW_LINE cal_cos ( n ) NEW_LINE DEDENT
def multiply ( arr , n , m ) : NEW_LINE INDENT pro = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pro = pro * arr [ i ] NEW_LINE DEDENT return pro NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE multiply ( arr , n , m ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( '1
def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE excl_new = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = ( excl + arr [ i ] ) NEW_LINE excl = excl_new NEW_LINE DEDENT return ( ( incl > excl ) and ( incl > excl_new ) ) NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' C ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if s [ i ] [ j ] == ' C ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE
def findMinIndex ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DED
def f ( x , y , h ) : NEW_LINE INDENT v = y - 2 * x * x + 1 NEW_LINE return v NEW_LINE DEDENT def correct ( x , y , x1 , y1 , h ) : NEW_LINE INDENT while ( abs ( y1c - y1 ) > e : NEW_LINE INDENT y1 = y1c NEW_LINE y1c = y + 0.5 * h * ( f ( x , y1 ) + f ( x1 , y1 ) ) NEW_LINE DEDENT return y1c NEW
def D_Pattern ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( j == 1 or ( ( i == 0 or i == n - 1 ) and ( j > 1 and j < n - 2 ) ) or ( j == n - 2 and i != 0 and i != n - 1 ) ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 9 NEW_LINE DEDENT n = 9 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 9 NEW_LINE DEDENT
def kthString ( n , k ) : NEW_LINE INDENT total = 0 NEW_LINE i = 1 NEW_LINE while ( total < k ) : NEW_LINE INDENT total = total + n - i NEW_LINE i += 1 NEW_LINE DEDENT first_y_position = i - 1 NEW_LINE second_y_position = k - ( total - n + first_y_position ) NEW_LINE for j in range ( 1 , first_y_position ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE j = first_y_position + 1 NEW_LINE while ( second_y_position > 1 ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE second_y_position -= 1 NEW_LINE j += 1 NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE while ( j < n ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE k = 7 NEW_LINE kthString ( n , k ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) ; NEW_LINE C [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] ; NEW_LINE DEDENT DEDENT return C [ k ] ; NEW_LINE DEDENT def count_of_subarrays ( N ) : NEW_LINE INDENT count = binomialCoeff ( 2 * N - 1 , N ) ; NEW_LINE return count ; NEW_LINE DEDENT N = 3 ; NEW_LINE print ( count_of_subarrays ( N ) ) ; NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def product except self : NEW_LINE INDENT n = len ( nums ) NEW_LINE res = [ 0 ] * n NEW_LINE res [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] * nums [ i - 1 ] NEW_LINE DEDENT right = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] * right NEW_LINE right *= nums [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 , 4 ] NEW_LINE out = sObj . product except self . product except self . product ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def getSmallestAndLargest ( s , k ) : NEW_LINE INDENT currStr = s [ 0 : k ] NEW_LINE lexMin = currStr NEW_LINE lexMax = currStr NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT currStr = currStr [ 1 : k ] + s [ i ] NEW_LINE if ( lexMax > currStr ) : NEW_LINE INDENT lexMax = currStr NEW_LINE DEDENT if ( lexMin . compareTo ( currStr ) > 0 ) : NEW_LINE INDENT lexMin = currStr NEW_LINE DEDENT DEDENT print ( lexMin ) NEW_LINE print ( lexMax ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksForGeeks " NEW_LINE k = 3 NEW_LINE getSmallestAndLargest ( str , k ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( b [ n ] ) NEW_LINE
INT_BITS = 32 NEW_LINE def maxSubarrayXOR ( set , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( INT_BITS - 1 , - 1 , - 1 ) : NEW_LINE INDENT maxInd = index NEW_LINE maxEle = set [ i ] NEW_LINE for j in range ( index , n ) : NEW_LINE INDENT if ( ( set [ j ] & ( 1 << i ) ) != 0 and set [ j ] > maxEle ) : NEW_LINE INDENT maxEle = set [ j ] NEW_LINE maxInd = j NEW_LINE DEDENT DEDENT if ( maxEle == - 2147483648 ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = set [ index ] NEW_LINE
n = int ( input ( ) ) NEW_LINE w = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE s = [ 0 , 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if w [ i ] == 0 : NEW_LINE INDENT s [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] != 0 : NEW_LINE INDENT if w [ i ] > s [ i ] : NEW_LINE INDENT s [ i ] = w [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT print ( s [ n - 1 ] , s [ n - 2 ] ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( range ( n ) ) NEW
class Solution ( object ) : NEW_LINE INDENT def firstUniqChar ( self , s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = " leetcode " NEW_LINE out = sObj . firstUniqChar ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT
def checkStackPermutation ( ip , op , n ) : NEW_LINE INDENT output = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT output . append ( op [ i ] ) NEW_LINE DEDENT output . append ( " ▁ " . join ( map ( str , output ) ) ) NEW_LINE return ( output ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ip = [ 1 , 2 , 3 ] NEW_LINE output = [ 2 , 1 , 3 ] NEW_LINE n = 3 NEW_LINE if ( checkStackPermutation ( ip , output , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW
s = input ( ) NEW_LINE t = input ( ) NEW_LINE ans = " Yes " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in ans : NEW_LINE INDENT ans = " No " NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 10 == d ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 30 NEW_LINE d = 3 NEW_LINE print ( getSum ( n , d ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , n = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT if c > n : NEW_LINE INDENT c , n = c , n NEW_LINE DEDENT if a == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif b == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n - a == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n - a ) % 2 == 0 : NEW_LINE INDENT print ( n - a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - a ) NEW_LINE DEDENT DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( s - t , n - s + 1 ) ) NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 10 NEW_LINE K = 2 NEW_LINE print ( findSum ( N , K ) ) NEW_LINE
import math NEW_LINE t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( math . floor ( ( 4 * n ) / gcd ( 4 * n , n ) ) ) NEW_LINE t -= 1 NEW_LINE DEDENT
PI = 3.14 NEW_LINE def find_area ( r , d ) : NEW_LINE INDENT R = d / PI NEW_LINE R += pow ( r , 2 ) NEW_LINE R = int ( R ** 2 ) NEW_LINE area = PI * pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 4 NEW_LINE d = 5 NEW_LINE print ( find_area ( r , d ) ) NEW_LINE DEDENT
def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( ( s % n ) > 0 ) : NEW_LINE INDENT return s // n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return s // n NEW_LINE DEDENT DEDENT n = 5 NEW_LINE s = 11 NEW_LINE print ( minimumNumbers ( n , s ) ) NEW_LINE
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE end = n - 1 NEW_LINE start = 0 NEW_LINE mid = 0 NEW_LINE for end in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while ( start < mid ) : NEW_LINE INDENT prod = arr [ end ] * arr [ start ] * arr [ mid ] NEW_LINE if ( prod > m ) : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif ( prod < m ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT else : NEW_LINE INDENT start += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE m = 1 NEW_LINE print ( countTriplets ( arr , n , m ) ) NEW_LINE
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT switch = False NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) and isVowel ( str [ i - 1 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) and isVowel ( str [ i - 1 ] ) and not isVowel ( str [ i + 1 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " acaba " NEW_LINE n = len ( str ) NEW_LINE if ( isSatisfied ( str , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) ; NEW_LINE dp [ 0 ] = 0 ; NEW_LINE dp [ 1 ] = 1 ; NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; NEW_LINE DEDENT return dp [ n ] ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( countWays ( n ) ) ; NEW_LINE
def expect ( m , n ) : NEW_LINE INDENT ans = 0.0 NEW_LINE for i in m , : NEW_LINE INDENT ans += pow ( i / m , n ) - pow ( ( i - 1 ) / m , n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT m = 6 NEW_LINE n = 3 NEW_LINE print ( " % .5f " % expect ( m , n ) ) NEW_LINE
def ProdOfPrimes ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT prod = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT prod *= i ; NEW_LINE DEDENT DEDENT return prod ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( ProdOfPrimes ( n ) ) ; NEW_LINE
import datetime NEW_LINE def compute ( ) : NEW_LINE INDENT days = 0 NEW_LINE days += 1 NEW_LINE days = 1 + days NEW_LINE return days NEW_LINE DEDENT def dayOfWeek ( year , month , day ) : NEW_LINE INDENT if year < 0 or month < 1 or month > 12 : NEW_LINE INDENT return False NEW_LINE DEDENT days = 1 + days + 1 + days NEW_LINE return days NEW_LINE DEDENT def year ( year , month , day ) : NEW_LINE INDENT if year < 0 or month > 12 : NEW_LINE INDENT return False NEW_LINE DEDENT days = year - 3 + days NEW_LINE return days NEW_LINE DEDENT def monthBirthday ( year , month , day ) : NEW_LINE INDENT if year < 0 or month > 12 : NEW_LINE INDENT return False NEW_LINE DEDENT days = month - 1 + days NEW_LINE return days NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def date ( d , m , y ) : NEW_LINE INDENT return d * 2004 - m * 2004 NEW_LINE DEDENT def monthDays ( d ) : NEW_LINE INDENT years = d . y * 365 + d . d NEW_LINE return years // 4 - years // 100 - years // 400 NEW_LINE DEDENT def countLeapYears ( Date d ) : NEW_LINE INDENT years = d . y // 31 + d . d NEW_LINE return years // 4 - years // 100 - years // 400 NEW_LINE DEDENT def getDifference ( Date d ) : NEW_LINE INDENT n1 = date ( d , m , y ) NEW_LINE n1 += monthDays [ i ] NEW_LINE n1 += countLeapYears ( d
def generateNumbers ( n , num , a , b ) : NEW_LINE INDENT if ( num > 0 and num < n ) : NEW_LINE INDENT st . add ( num ) NEW_LINE DEDENT if ( num * 10 + a > num ) : NEW_LINE INDENT generateNumbers ( n , num * 10 + a , num , a , b ) NEW_LINE DEDENT generateNumbers ( n , num * 10 + b , a , b ) NEW_LINE DEDENT def printNumbers ( n ) : NEW_LINE INDENT for i in range ( 9 ) : NEW_LINE INDENT for j in range ( i + 1 , 9 ) : NEW_LINE INDENT generateNumbers ( n , 0 , i , j ) NEW_LINE DEDENT DEDENT print ( " The ▁ numbers ▁ are : " , end = " " ) NEW_LINE print ( st ) NEW_LINE st . clear ( ) NEW_LINE DEDENT n = 12 NEW_LINE printNumbers ( n ) NEW_LINE
n , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in a : NEW_LINE INDENT print ( k , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE
while True : NEW_LINE INDENT n , q = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE querys = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE querys . reverse ( ) NEW_LINE ruia = [ 0 ] * ( n + 1 ) NEW_LINE ruia [ 0 ] = 1 NEW_LINE for m in range ( q ) : NEW_LINE INDENT a , b = querys [ m ] NEW_LINE if a == 0 : NEW_LINE INDENT ruia [ m ] = ruia [
def getOddOccurrence ( ar , ar_size ) : NEW_LINE INDENT i = 0 NEW_LINE res = 0 NEW_LINE for i in ar : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ar = [ 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE print ( getOddOccurrence ( ar , n ) ) NEW_LINE DEDENT
def isKthBitSet ( x , k ) : NEW_LINE INDENT rslt = ( ( x & ( 1 << ( k - 1 ) ) ) ) : NEW_LINE INDENT return 1 if ( isKthBitSet ( x , k ) != isKthBitSet ( x , r ) ) else 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 NEW_LINE r = ( SIZE // 8 ) * 8 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT x = 1 << 15 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE x = ( 1 << 31 ) + 1 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT flag = 0 ; NEW_LINE isPrime = [ False ] * ( n + 1 ) ; NEW_LINE SieveOfEratosthenes ( n , isPrime ) ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT x = n // i ;
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE a = 30 NEW_LINE b = 2 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE a = 31 NEW_LINE b = 2 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE a = 30 NEW_LINE b = 2 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE a = 31 NEW_LINE b = 2 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE
import sys NEW_LINE def compute ( ) : NEW_LINE INDENT SIZE_limit = 1000000 NEW_LINE type_limit = [ 0 ] * SIZE_limit + 1 NEW_LINE for n in range ( 3 , SIZE_limit + 1 ) : NEW_LINE INDENT for m in range ( n - 2 , 2 , - 1 ) : NEW_LINE INDENT if n * n - m >= 1 : NEW_LINE INDENT break NEW_LINE DEDENT type_limit [ m ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for t in type_limit : NEW_LINE INDENT if t <= type_limit : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : print ( input ( ) . strip ( '
def maxZeros ( N ) : NEW_LINE INDENT maxm = - 1 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE N >>= 1 NEW_LINE maxm = max ( maxm , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT maxm = max ( maxm , cnt ) NEW_LINE cnt = 0 NEW_LINE N = N >> 1 NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT N = 14 NEW_LINE print ( maxZeros ( N ) ) NEW_LINE
def getLongestSeq ( a , n ) : NEW_LINE INDENT maxIdx = 0 NEW_LINE maxLen = 0 NEW_LINE currLen = 0 NEW_LINE currIdx = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if ( a [ k ] > 0 ) : NEW_LINE INDENT currLen += 1 NEW_LINE if ( currLen == 1 ) : NEW_LINE INDENT currIdx = k NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( currLen > maxLen ) : NEW_LINE INDENT maxLen = currLen NEW_LINE maxIdx = currIdx NEW_LINE DEDENT currLen = 0 NEW_LINE DEDENT DEDENT if ( maxLen > 0 ) : NEW_LINE INDENT print ( " Index ▁ : ▁ " , maxIdx ) NEW_LINE print ( " ▁ , Length ▁ : ▁ " , maxLen ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ positive ▁ sequence ▁ detected . " ) NEW_LINE DEDENT return NEW_LINE DEDENT arr
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . right = None NEW_LINE self . down = None NEW_LINE DEDENT DEDENT def construct ( arr , i , j , m , n ) : NEW_LINE INDENT if ( i > n - 1 or j > m - 1 ) : NEW_LINE INDENT return None NEW_LINE DEDENT temp = Node ( ) NEW_LINE temp . data = arr [ i ] [ j ] NEW_LINE temp . right = construct ( arr , i + 1 , j + 1 , m , n ) NEW_LINE temp . down = construct ( arr , i + 1 , j , m , n ) NEW_LINE return temp NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT Rp = Node ( ) NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT Rp = head NEW_LINE while ( Rp != None ) : NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def prime ( num ) : NEW_LINE INDENT b = num NEW_LINE for i in range ( 2 , num ) : NEW_LINE INDENT if i * i > num : NEW_LINE INDENT break NEW_LINE DEDENT if b % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def modInverse ( a , p ) : NEW_LINE INDENT return pow ( a , p - 2 , p ) NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT x = n // r NEW_LINE if r == 1 : NEW_LINE INDENT return x NEW_LINE DEDENT return ( ( x * x ) // r ) % p NEW_LINE DEDENT def nHr ( n , r ) : NEW_LINE INDENT x = nCr ( n - r , r ) NEW_LINE return ( x * x ) % p NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for p in prime ( n ) : NEW_LINE INDENT ans += nHr ( p ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _
def findNthTerm ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT ans = ( N // 2 ) * 6 + ( N // 2 ) * 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N // 2 + 1 ) * 6 + ( N // 2 ) * 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT
def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( a == b and a == c and a == d and c == d ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( a == d and c == d ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( a == c and d == b ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( a == c and d == b ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c , d = 1 , 2 , 3 , 4 , 5 NEW_LINE if ( isRectangle ( a , b , c , d ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( ( sqrt ( m ) ) + 1 ) NEW_LINE an = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m NEW_LINE DEDENT value = [ 0 ] * m NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i NEW_LINE DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT for i in range ( b , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT return - 1 NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE m = 5 NEW
def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = 10 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return dp [ ind ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 ] * ( n ) NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE
from math import gcd NEW_LINE def Probability ( sum , times ) : NEW_LINE INDENT favorable = 0 NEW_LINE total = 36 NEW_LINE probability = 0 NEW_LINE for i in range ( 1 , 6 + 1 ) : NEW_LINE INDENT for j in range ( 1 , 6 ) : NEW_LINE INDENT if ( ( i + j ) == sum ) : NEW_LINE INDENT favorable += 1 NEW_LINE DEDENT DEDENT DEDENT gcd1 = gcd ( ( int ) ( favorable , int ) ( total ) ) NEW_LINE favorable = favorable // ( gcd1 ) NEW_LINE total = total // ( gcd1 ) NEW_LINE probability = ( int ) ( probability // gcd1 ) NEW_LINE return probability NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sum = 7 NEW_LINE times = 7 NEW_LINE print ( "1" , Probability ( sum , times ) ) NEW_LINE DEDENT
k , n = map ( int , input ( ) . split ( ) ) NEW_LINE mod = 998244353 NEW_LINE ans = 0 NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT ans += ( n - i ) % mod NEW_LINE n -= i NEW_LINE DEDENT print ( ans % mod ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE joy = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp2 = a [ i ] NEW_LINE joy += ( temp2 * 160 ) NEW_LINE DEDENT print ( joy ) NEW_LINE
def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == num1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT j = n - 1 NEW_LINE while ( j >= i + 1 ) : NEW_LINE INDENT if ( arr [ j ] == num2 ) : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT if ( j == i ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE num1 = 5 NEW_LINE num2 = 4 NEW_LINE print ( getCount ( arr , n , num1 , num2 ) ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT j = i + n NEW_LINE ans = min ( ans , arr [ j ] - arr [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE setBits = [ 0 ] * ( n + 1 ) ; NEW_LINE setBits [ 0 ] = 0 ; NEW_LINE setBits [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i // 2 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 ; NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( countSetBits ( n ) ) ; NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def largestGCD1Subset ( A , n ) : NEW_LINE INDENT currentGCD = A [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currentGCD = gcd ( currentGCD , A [ i ] ) ; NEW_LINE if ( currentGCD == 1 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT DEDENT return 0 ; NEW_LINE DEDENT A = [ 2 , 18 , 6 , 3 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( largestGCD1Subset ( A , n ) ) ; NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 7 NEW_LINE numDivisors = [ 0 ] * LIMIT + 1 NEW_LINE for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT for j in range ( i * 2 , LIMIT + 1 , i ) : NEW_LINE INDENT numDivisors [ j ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT if numDivisors [ i ] == i : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] ; NEW_LINE DEDENT arr [ 0 ] = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT arr = [ 5 , 1 , 3 , 2 , 4 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE updateArray ( arr , N ) ; NEW_LINE
def findEncryptedArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum - arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE findEncryptedArray ( arr , N ) NEW_LINE
def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE
def findMinDifference ( arr , n ) : NEW_LINE INDENT min = min ( arr [ 0 ] ) NEW_LINE max = max ( arr [ 1 ] ) NEW_LINE max = max ( arr [ 0 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max NEW_LINE max = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < min ) : NEW_LINE INDENT secondMin = min NEW_LINE min = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < secondMin ) : NEW_LINE INDENT secondMin = arr [ i ] NEW_LINE DEDENT DEDENT diff = min ( max - secondMin , secondMax - min ) NEW_LINE return diff NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( x ) NEW_LINE a . append ( y ) NEW_LINE DEDENT b = set ( a ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] % b [ j ] == 0 ) : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT L = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if L [ i ] > L [ i + 1 ] : NEW_LINE INDENT a += 1 NEW_LINE L [ i + 1 ] = L [ i ] NEW_LINE DEDENT DEDENT if a == n // 2 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT return ( n == 1 or n == 0 ) and ( n * factorial ( n - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( " Factorial ▁ of " , num , " is " , factorial ( n ) ) NEW_LINE DEDENT
n , d , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] + a [ j ] > d and i != j : NEW_LINE INDENT ans = max ( ans , j - i + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( a ) - sum ( a ) ) NEW_LINE
def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) ; NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT return ( st [ 2 - el1 ] ) // 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( st [ 2 - el1 ] ) // 2 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( findMinimumX ( a , n ) ) ; NEW_LINE
def findX ( n , k ) : NEW_LINE INDENT r = n NEW_LINE v = 1 NEW_LINE u = 1 NEW_LINE while ( i <= m and k > 1 ) : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT i = k NEW_LINE DEDENT for u in range ( v + 1 ) : NEW_LINE INDENT k = k // i NEW_LINE DEDENT if ( v > 0 ) : NEW_LINE INDENT t = n NEW_LINE while ( t > 0 ) : NEW_LINE INDENT t = t // i NEW_LINE u += t NEW_LINE DEDENT r = min ( r , u // u ) NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( findX ( n , k ) ) NEW_LINE DEDENT
def LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT if ( x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a , b , x , y = 7 , 4 , 5 , 5 NEW_LINE if ( LiesInsieRectangle ( a , b , x , y ) ) : NEW_LINE INDENT print ( " Given ▁ point ▁ lies ▁ inside ▁ the ▁ rectangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Given ▁ point ▁ does ▁ not ▁ " , " lie ▁ on ▁ the ▁ rectangle " ) NEW_LINE DEDENT
N = 1000 NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT size = ( 2 * N ) + 1 NEW_LINE freq = [ 0 ] * size NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x + N ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) // 2 NEW_LINE for j in range ( i + 2 , 2001 , 2 ) : NEW_LINE INDENT if ( freq [ j ] > 0 and ( freq [ ( i + j ) // 2 ] > 0 ) ) : NEW_LINE INDENT ans += ( freq [ i ] * freq [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 2 , 5 , 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_
def getAvg ( x ) : NEW_LINE INDENT sum = 0 ; NEW_LINE n = len ( x ) ; NEW_LINE while ( n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = ( int ) ( ( x [ i ] ) ) ; NEW_LINE print ( "Average ▁ of " , ( i + 1 ) , " numbers ▁ is ▁ " , avg ) ; NEW_LINE DEDENT DEDENT return ; NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE
MAX = 10000 NEW_LINE s = set ( ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT product = product * p NEW_LINE s . add ( product + 1 ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW
n , b = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] - b [ i ] ) % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def maxOperations ( string ) : NEW_LINE INDENT i = g = gk = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ' g ' ) : NEW_LINE INDENT g += 1 NEW_LINE DEDENT elif ( string [ i ] == ' k ' ) : NEW_LINE INDENT if ( g > 0 ) : NEW_LINE INDENT g -= 1 NEW_LINE string = string [ : : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT g -= 1 NEW_LINE string = string [ : : - 1 ] NEW_LINE DEDENT DEDENT elif ( string [ i ] == ' s ' ) : NEW_LINE INDENT if ( gk > 0 ) : NEW_LINE INDENT gk -= 1 NEW_LINE gk += 1 NEW_LINE DEDENT DEDENT DEDENT return gks NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = " ggkssk " NEW_LINE print ( maxOperations ( a ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = max ( ans , a [ i ] + a [ i - 1 ] - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT l . sort ( ) NEW_LINE print ( l [ - 1 ] [ - 1 ] ) NEW_LINE
def kthSmallest ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE k = 2 NEW_LINE print ( " K ' th ▁ smallest ▁ element ▁ is ▁ " , kthSmallest ( arr , k ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] == a [ i + 1 ] : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE DEDENT DEDENT print ( * a ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ans = n * ( n + 1 ) // 2 NEW_LINE print ( ans ) NEW_LINE
import math NEW_LINE def distance ( lat1 , lat2 , lon1 , lon2 ) : NEW_LINE INDENT lon1 = math . radians ( lon1 ) NEW_LINE lon2 = math . radians ( lat2 ) NEW_LINE lat1 = math . sin ( lat1 ) NEW_LINE lat2 = math . sin ( lat2 ) NEW_LINE a = pow ( math . sin ( dlon / 2 ) , 2 ) + math . cos ( lat1 ) * math . cos ( lat2 ) * math . cos ( dlon / 2 ) NEW_LINE c = 2 * math . asin ( math . sqrt ( a ) ) NEW_LINE r = 6371 NEW_LINE return ( c * r ) NEW_LINE DEDENT lat1 = 53.32055555555556 NEW_LINE lat2 = 53.3186718675672223 NEW_LINE lon1 = - 1.729722222223 NEW_LINE print ( distance ( lat1 , lat2 , lon1
def centeredOctahedral ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) // 3 NEW_LINE DEDENT n = 3 NEW_LINE print ( centeredOctahedral ( n ) ) NEW_LINE print ( ) NEW_LINE n = 9 NEW_LINE print ( centeredOctahedral ( n ) ) NEW_LINE
n , m , p = map ( int , input ( )
from math import sqrt NEW_LINE def SumDivPrime ( A ) : NEW_LINE INDENT max_val = - ( max_element ( A ) + 1 ) NEW_LINE prime = [ True ] * max_val NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( max_val ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( len ( A )
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( arr [ i % n ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 7 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE leftRotate ( arr , n , k ) ; NEW_LINE print ( ) ; NEW_LINE k = 3 ; NEW_LINE leftRotate ( arr , n , k ) ; NEW_LINE print ( ) ; NEW_LINE k = 4 ; NEW_LINE leftRotate ( arr , n , k ) ; NEW_LINE print ( ) ; NEW_LINE
def closestMultiple ( n , x ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return x NEW_LINE DEDENT n = n + x // 2 NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 56287 NEW_LINE x = 27 NEW_LINE print ( closestMultiple ( n , x ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in s : NEW_LINE INDENT if i == '0' : NEW_LINE INDENT a . append ( 0 ) NEW_LINE DEDENT elif i == '1' : NEW_LINE INDENT b . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT if a [ 0 ] % 2 != 0 and a [ 1 ] % 2 != 0 : NEW_LINE INDENT print ( " red " ) NEW_LINE DEDENT elif a [ 0 ] % 2 != 0 and a [ 1 ] % 2 != 0 : NEW_LINE INDENT print ( " green " ) NEW_LINE DEDENT elif a [ 0 ] % 2 != 0 and a [ 1 ] % 2 != 0 : NEW_LINE INDENT print ( " blue " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " yellow " ) NEW_LINE DEDENT DEDENT
dp = [ [ 0 for i in range ( 901 ) ] for j in range ( 901 ) ] NEW_LINE def minimumNumberOfDigits ( a , b ) : NEW_LINE INDENT if ( a > b or a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if (
N = 5005 NEW_LINE n , k = 5005 NEW_LINE gr = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE def ans = 0 NEW_LINE def Add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] [ y ] += 1 NEW_LINE gr [ y ] [ x ] += 1 NEW_LINE DEDENT def dfs ( v , par ) : NEW_LINE INDENT d = [ 0 for i in range ( N ) ] NEW_LINE if ( i != par ) : NEW_LINE INDENT dfs ( i , v ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT d
def findSubsequence ( arr , n ) : NEW_LINE INDENT len1 = 1 NEW_LINE tmp = arr [ 0 ] NEW_LINE i , j , d = 0 , 0 NEW_LINE dp = [ 0 ] * 10 NEW_LINE cnt = [ 0 ] * 10 NEW_LINE locMax = 0 NEW_LINE tmp = arr [ 0 ] NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 NEW_LINE tmp //= 10 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE locMax = 1 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 NEW_LINE tmp //= 10 NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] == 1 ) : NEW_LINE INDENT dp [ d ]
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = set ( a ) NEW_LINE if len ( s ) == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if a [ i ] in s : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def totalPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( ( n % 2 == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE while ( ( n % 2 == 0 ) ) : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( n ) + 1 , 2 ) : NEW_LINE INDENT if ( ( n % i == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT while ( ( n % i == 0 ) ) : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT if ( L % G != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT div = L // G NEW_LINE return ( 1 << totalPrimeFactors ( div ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT G , L , L = 2 , 12
def calculate_sum ( a , N ) : NEW_LINE INDENT m = N // a NEW_LINE sum = m * ( m + 1 ) // 2 NEW_LINE ans = a * sum NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 7 NEW_LINE N = 49 NEW_LINE print ( " Sum ▁ of ▁ multiples ▁ of " , a , " ▁ up ▁ to " , N , " = " , calculate_sum ( a , N ) ) NEW_LINE DEDENT
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT l . sort ( key = lambda x : x [ 1 ] ) NEW_LINE for i in l : NEW_LINE INDENT if k - i <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT k -= i NEW_LINE DEDENT print ( k ) NEW_
def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE
def next ( arr , target ) : NEW_LINE INDENT start = 0 ; end = len ( arr ) - 1 ; NEW_LINE ans = - 1 ; NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 ; NEW_LINE if ( arr [ mid ] <= target ) : NEW_LINE INDENT start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid ; NEW_LINE end = mid - 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 5 , 8 , 12 ] ; NEW_LINE print ( next ( arr , 8 ) ) ; NEW_LINE
def word = [ " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " ] ; NEW_LINE def printWordsWithoutIfSwitch ( n ) : NEW_LINE INDENT digits = [ 0 ] * 10 ; NEW_LINE dc = 0 ; NEW_LINE while n : NEW_LINE INDENT digits [ dc ] = n % 10 ; NEW_LINE n = n // 10 ; NEW_LINE dc += 1 ; NEW_LINE DEDENT while n : NEW_LINE INDENT print ( word [ digits [ n ] ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 350 ; NEW_LINE printWordsWithoutIfSwitch ( n ) ; NEW_LINE
n , k , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE sm = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sm += a [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT sm += a [ i ] NEW_LINE DEDENT print ( sm / n ) NEW_LINE
def solve ( a , b ) : NEW_LINE INDENT l = len ( a ) NEW_LINE min = 0 NEW_LINE max = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == ' + ' or b [ i ] == ' + ' or a [ i ] != b [ i ] ) : NEW_LINE INDENT max += 1 NEW_LINE DEDENT if ( a [ i ] != ' + ' and b [ i ] != ' + ' and a [ i ] != b [ i ] ) : NEW_LINE INDENT min += 1 NEW_LINE DEDENT DEDENT print ( min , max ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " a + c " , s2 = " + b " , " + a " NEW_LINE solve ( s1 , s2 ) NEW_LINE DEDENT
def TotalWays ( n , s , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ s - 1 ] = 1 NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE s = 2 NEW_LINE print ( " Total ▁ Ways ▁ = ▁ " , TotalWays ( n , s , k ) ) NEW_LINE
def countEvenOdd ( n ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 NEW_LINE if ( rem % 2 == 0 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT print ( " Even ▁ count ▁ : " , even_count ) NEW_LINE print ( " Odd ▁ count ▁ : " , odd_count ) NEW_LINE if ( even_count % 2 == 0 and odd_count % 2 != 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 2335453 NEW_LINE t = countEvenOdd ( n ) NEW_LINE if ( t == 1 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp = [ [ 0 ] * ( k + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - k ] + a
def findmin ( p , n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] . x <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] . x >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( p [ i ] . y >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( p [ i ] . y <= 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( a , b ) NEW_LINE DEDENT def findmax ( p , n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] . x <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] . x <= 0 ) : NEW_LINE
import math NEW_LINE def maxGCD ( N , P ) : NEW_LINE INDENT ans = 1 NEW_LINE prime_factors = dict ( ) NEW_LINE for i in range ( 2 , P + 1 ) : NEW_LINE INDENT while P % i == 0 : NEW_LINE INDENT if ( prime_factors [ i ] == 0 ) : NEW_LINE INDENT prime_factors [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime_factors [ i ] = ( prime_factors [ i ] + 1 ) NEW_LINE DEDENT P //= i NEW_LINE DEDENT DEDENT if ( P != 1 ) : NEW_LINE INDENT if ( prime_factors . get ( P ) == None ) : NEW_LINE INDENT prime_factors . update ( { 2 : , 3 : , 1 : , 1 : } ) NEW_LINE DEDENT prime_factors . update ( { 3 : , 1 : , 2 : , 1 : } ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT print ( "0 : " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "1 : " , end = " " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE
def primeFactorization ( countOfPf , primeFactor ) : NEW_LINE INDENT if ( curIndex == len ( arr ) ) : NEW_LINE INDENT print ( curDivisor , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT for i in range ( 2 , int ( ( len ( arr ) ) / i ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n //= i NEW_LINE count += 1 NEW_LINE DEDENT arr . append ( [ new primeFactorization ( count , i ) ] ) NEW_LINE DEDENT DEDENT if ( n > 1 ) : NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT dp = [ 1 ] * ( n + 1 ) NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , dp [ j - 1 ] + 1 ) NEW_LINE DEDENT DEDENT print ( dp [ n - 1 ] ) NEW_LINE
def largestPalinSub ( s ) : NEW_LINE INDENT res = " " ; NEW_LINE mx = s [ 0 ] ; NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , ord ( s [ i ] ) ) ; NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == mx ) : NEW_LINE INDENT res += s [ i ] ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " ; NEW_LINE print ( largestPalinSub ( s ) ) ; NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = input ( ) NEW_LINE ans = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def initializeDiffArray ( A , D ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D = [ 0 ] * ( n ) NEW_LINE D [ 0 ] = A [ 0 ] NEW_LINE D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT A [ i ] = D [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i
def findMaxGuests ( arrl , exit , n ) : NEW_LINE INDENT arrl . sort ( reverse = False ) NEW_LINE guests_in = 1 NEW_LINE max_guests = 1 NEW_LINE time = arrl [ 0 ] NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arrl [ i ] <= exit [ j ] ) : NEW_LINE INDENT guests_in += 1 NEW_LINE if ( guests_in > max_guests ) : NEW_LINE INDENT max_guests = guests_in NEW_LINE time = arrl [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT guests_in -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ of ▁ guests ▁ = ▁ " , max_guests , " at ▁
while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " # " : break NEW_LINE print ( [ [ 1 for i in range ( len ( s ) ) if s [ i ] != ' # ' ] + s [ i + 1 : ] ] ) NEW_
def calcFunction ( n , r ) : NEW_LINE INDENT finalDenominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i ) NEW_LINE numerator = ( int ) pow ( i - mx , i - mx ) NEW_LINE finalDenominator = ( finalDenominator * numerator ) // numerator NEW_LINE DEDENT return finalDenominator NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE r = 2 NEW_LINE print ( "1 / " + calcFunction ( n , r ) ) NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = int ( x ) ; NEW_LINE if ( sr * sr == x ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE k = 2 ; NEW_LINE isPerfectSquare ( n + k ) ; NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if w [ i ] % 2 == 1 : NEW_LINE INDENT c += 1 NEW_LINE w [ i ] = w [ i ] // 2 NEW_LINE w [ i ] %= 2 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE flag = True NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if l [ i + 1 ] == l [ i ] + l [ i + 2 ] : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = set ( a ) NEW_LINE c = len ( b ) NEW_LINE for i in range ( c ) : NEW_LINE INDENT if
def isDivisible ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( S [ n - 1 ] != '5' and S [ n - 1 ] != '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += S [ i ] NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT S1 = "15645746327462384723984023940239402394" NEW_LINE if ( isDivisible ( S1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT S1 = "156457463274623847239840239402394" NEW_LINE if ( isDivisible ( S1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " )
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT isSquare = eulerlib . sqrt ( sum ( i ** 2 for i in range ( 1 , 1000000 ) ) ) NEW_LINE ans = 10 NEW_LINE while True : NEW_LINE INDENT if ( isSquare ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , sum ( i ** 2 for i in range ( 1000000 ) ) ) NEW_LINE i += 1 NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) ; NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT countVowels = 0 ; NEW_LINE countConsonants = 0 ; NEW_LINE ans = " " ; NEW_LINE for l in range ( 0 , n - k + 1 ) : NEW_LINE INDENT countConsonants = 0 ; NEW_LINE countConsonants = 0 ; NEW_LINE for r in range ( l , l + k + 1 ) : NEW_LINE INDENT if isVowel ( s [ r ] ) : NEW_LINE INDENT countConsonants += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countConsonants += 1 ; NEW_LINE DEDENT DEDENT ans += str ( countConsonants ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " hello " ; NEW_LINE n = len ( s ) ; NEW_LINE k =
import sys NEW_LINE import math NEW_LINE for s in sys . stdin : NEW_LINE INDENT n , m = map ( int , s . split ( ) ) NEW_LINE if n == m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT xs = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE t = math . gcd ( n , m ) NEW_LINE x = xs [ m - 1 ] NEW_LINE if m % x == 0 : NEW_LINE INDENT print ( t * x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT c = 0 NEW_LINE for i in l : NEW_LINE INDENT for j in range ( i - 1 , i + 1 ) : NEW_LINE INDENT if ( i - 1 >= 0 and i - 1 < i ) : NEW_LINE INDENT for k in range ( j + 1 , i + 1 ) : NEW_LINE INDENT if ( k == 0 and j == 0 and k == m - 1 ) : NEW_LINE INDENT c = max ( c , l [ i ] [ k ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if ( c == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ list ( input ( ) ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == 1 : a [ i ] [ j ] = 0 NEW_LINE else : NEW_LINE INDENT if j - i - 1 >= 0 and j - i - 1 < n and a [ i - 1 ] [ j - 1 ] == 1 : NEW_LINE INDENT a [ i ] [ j ] = 0 NEW_LINE a [ i - 1 ] [ j - 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT DEDENT if j + 1 < n and a [ i ] [ j + 1 ] == 1 : NEW_LINE INDENT a [ i ] [ j + 1 ] = 0 NEW_LINE
def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n * n ) - n ) // 30 NEW_LINE DEDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE
def maxLengthSub ( arr ) : NEW_LINE INDENT max_val = 0 NEW_LINE start = 0 NEW_LINE map = dict . fromkeys ( arr , 0 ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT temp = 0 NEW_LINE if ( map [ arr [ i ] - 1 ] ) : NEW_LINE INDENT temp = map [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( map [ arr [ i ] ] ) : NEW_LINE INDENT temp = max ( temp , map [ arr [ i ] ] ) NEW_LINE DEDENT if ( map [ arr [ i ] + 1 ] ) : NEW_LINE INDENT temp = max ( temp , map [ arr [ i ] + 1 ] ) NEW_LINE DEDENT if ( map [ arr [ i ] + 1 ] ) : NEW_LINE INDENT temp = max ( temp , map [ arr [ i ] + 1 ] ) NEW_LINE DEDENT map [ arr [ i ] ] = temp NEW_LINE DEDENT return max_val NEW_LINE D
def rearrange ( arr ) : NEW_LINE INDENT if ( arr == None or arr [ 0 ] % 2 == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT currIdx = ( len ( arr ) - 1 ) // 2 NEW_LINE while ( currIdx > 0 ) : NEW_LINE INDENT count = currIdx NEW_LINE swapIdx = currIdx NEW_LINE while ( count ) : NEW_LINE INDENT temp = arr [ swapIdx + 1 ] NEW_LINE arr [ swapIdx + 1 ] = arr [ swapIdx ] NEW_LINE arr [ swapIdx ] = temp NEW_LINE swapIdx += 1 NEW_LINE DEDENT currIdx -= 1 NEW_LINE DEDENT return arr NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 2 , 4 , 6 ] NEW_LINE rearrange ( arr ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( " ▁ " , arr [ i ] ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( sum ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ) ) NEW_LINE DED
def countCharacterType ( string ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT elif ( ch >=
def increaseInVol ( l , b , h ) : NEW_LINE INDENT percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; NEW_LINE percentInc -= 1 ; NEW_LINE return percentInc ; NEW_LINE DEDENT l = 50 ; b = 20 ; h = 10 ; NEW_LINE print ( increaseInVol ( l , b , h ) ) ; NEW_LINE
def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and not flag ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and ( flag ) ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT a = [ 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 11 , 10 , 9 , 8 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxTotalRectangleArea ( a , n ) ) NEW_LINE

def lastFiveDigits ( n ) : NEW_LINE INDENT n = ( n // 10000 ) * 10000 + ( ( n // 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n // 10 ) % 10 ) * 10 + ( n // 1000 ) % 10 NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT n = 12345 NEW_LINE lastFiveDigits ( n ) NEW_LINE
import math NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( i ** 2 for i in range ( 1 , 100 + 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def evaluate ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( " No ▁ Pythagoras ▁ Triplet ▁ exists " ) NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT var = 1 * n * n / 4 NEW_LINE print ( " Pythagoras ▁ Triplet ▁ " + " exists ▁ i . e . " , end = " ▁ " ) NEW_LINE print ( n , " ▁ " , end = " ▁ " ) NEW_LINE print ( var - 1 , " ▁ " , end = " ▁ " ) NEW_LINE print ( var - 1 , " ▁ " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT var = 1 * n * n + 1 NEW_
a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif a != 0 and b != 0 : NEW_LINE INDENT ans = ans + a + 1 NEW_LINE DEDENT elif b != 0 and a != 0 : NEW_LINE INDENT ans = ans + b NEW_LINE DEDENT print ( ans ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def findNumber ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == ans ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 2 , 2 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findNumber ( arr , n ) ) ; NEW_LINE
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rem = A [ i ] % K NEW_LINE if ( rem != 0 ) : NEW_LINE INDENT ans += freq [ K - rem ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += freq [ 0 ] NEW_LINE DEDENT freq [ rem ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = len ( A ) NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE
a , b , c = map ( str , input ( ) . split ( " , " ) ) NEW_LINE print ( a , b , c ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE l1 = 0 NEW_LINE r = 0 NEW_LINE n = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] == 0 : NEW_LINE INDENT l [ i ] = l [ i - 1 ] NEW_LINE DEDENT elif l [ i ] == n - 1 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if n == 1 : NEW_LINE INDENT print ( l1 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( l [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while l1 < n and l [ l1 ] == 0 : NEW_LINE INDENT l1 += 1 NEW_LINE DEDENT while l1 > n and l [ l1 ] == 0 : NEW_LINE INDENT l1 -= 1 NEW_LINE DEDENT while l1 < n and l [ l1 ] == 0 : NEW_LINE INDENT l1 += 1 NEW_LINE DEDENT while r < n and l [ r ] == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT print ( max ( l1 , r ) ) NEW_LINE DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_ positive = [ 0 for i in range ( n + 1 ) ] NEW_LINE hash_negative = [ 0 for i in range ( n + 1 ) ] NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] & 1 ) == 1 ) : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Total ▁ Number ▁ of �
SIZE = 26 NEW_LINE def printChar ( string , n ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE n = len ( string ) NEW_LINE printChar ( string , n ) NEW_LINE DEDENT
def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 1 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE
def countGreater ( arr , n , k ) : NEW_LINE INDENT l = 0 ; r = n - 1 ; NEW_LINE leftGreater = n ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) // 2 ; NEW_LINE if ( arr [ m ] > k ) : NEW_LINE INDENT leftGreater = m ; NEW_LINE r = m - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 ; NEW_LINE DEDENT DEDENT return ( n - leftGreater ) ; NEW_LINE DEDENT arr = [ 3 , 3 , 4 , 7 , 7 , 7 , 7 , 11 , 13 , 13 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 7 ; NEW_LINE print ( countGreater ( arr , n , k ) ) ; NEW_LINE
h , w = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT ans *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans *= 3 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N ; NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE return ; NEW_LINE DEDENT a = ( N + sqrt ( val ) ) / 2.0 ; NEW_LINE b = ( N - sqrt ( val ) ) / 2.0 ; NEW_LINE print ( " a ▁ = ▁ " , a ) ; NEW_LINE print ( " b ▁ = ▁ " , b ) ; NEW_LINE DEDENT N = 69.0 ; NEW_LINE findAandB ( N ) ; NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE xaxis = [ ] NEW_LINE yaxis = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE xaxis . append ( x ) NEW_LINE yaxis . append ( y ) NEW_LINE DEDENT xaxis . sort ( ) NEW_LINE yaxis . sort ( ) NEW_LINE if ( ( xaxis [ 0 ] - xaxis [ 0 ] ) + ( yaxis [ 0 ] - yaxis [ 0 ] ) <= 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( ( xaxis [ 0 ] - xaxis [ 0 ] ) + ( yaxis [ 0 ] ) + ( yaxis [ 0 ] ) <= 1 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif ( ( xaxis [ 1 ] - xaxis [ 0 ] ) + ( yaxis [ 1 ] - yaxis [ 0 ] ) <= 1 ) : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif ( ( xaxis [ 0 ] - xaxis [ 1 ] ) + ( yaxis [ 1 ] - yaxis [ 0 ] ) <= 1 ) : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE x = [ ] NEW_LINE y = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = input ( ) NEW_LINE x . append ( a ) NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT b = input ( ) NEW_LINE y . append ( b ) NEW_LINE DEDENT if len ( y ) == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( ( input ( ) + '0' ) * 2 ) NEW_
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE n = a NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT n = n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = n - 2 NEW_LINE DEDENT print ( ( n * 2 ) + n ) NEW_LINE DEDENT
def minIncrementForUnique ( A ) : NEW_LINE INDENT mpp = dict ( ) NEW_LINE for i in A : NEW_LINE INDENT if ( mpp [ i ] in mpp . keys ( ) ) : NEW_LINE INDENT mpp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ i ] = 1 NEW_LINE DEDENT DEDENT taken = [ ] NEW_LINE ans = 0 NEW_LINE for x in sorted ( taken ) : NEW_LINE INDENT if ( len ( mpp ) > 0 and ( ( mpp [ x ] >= 2 ) ) ) : NEW_LINE INDENT ans += x - taken [ len ( mpp ) - 1 ] NEW_LINE DEDENT elif ( len ( mpp ) == 0 and ( ( mpp [ x ] == 0 ) or not mpp [ x ] ) ) : NEW_LINE INDENT ans += x - taken [ len ( mpp ) - 1 ] NEW_LINE DEDENT DEDENT return ans NEW
n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT print ( 3 ** n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 3 ** n - 1 ) NEW_LINE DEDENT DEDENT
MOD = 10 ** 9 + 7 NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 13 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = j NEW_LINE DEDENT for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % MOD NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] NEW_LINE dp [ i + 1 ] [ rem ] %= MOD NEW_LINE DEDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return ( dp [ n ] [ 5 ] ) NEW_LINE DEDENT if __name__ == "
def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b // c - ( a - 1 ) // c NEW_LINE y = b // d - ( a - 1 ) // d NEW_LINE k = ( c * d ) // __gcd ( c , d ) NEW_LINE z = b // k - ( a - 1 ) // k NEW_LINE return b - a + 1 - x - y + z NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return __gcd ( b , a % b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10 NEW_LINE b = 50 NEW_LINE c = 4 NEW_LINE d = 6 NEW_LINE print ( countNums ( a , b , c , d ) ) NEW_LINE DEDENT
def printSubstrings ( n ) : NEW_LINE INDENT s = int ( n ) ; NEW_LINE d = pow ( 10 , s ) + 0.5 ; NEW_LINE k = d ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( n // d , end = " " ) ; NEW_LINE d = d // 10 ; NEW_LINE DEDENT n = n % k ; NEW_LINE k = k // 10 ; NEW_LINE DEDENT DEDENT n = 123 ; NEW_LINE printSubstrings ( n ) ; NEW_LINE
NthCharacter ( n ) : NEW_LINE INDENT s = " " ; NEW_LINE c = 1 ; NEW_LINE for i in range ( 1 , 1 , 10 ) : NEW_LINE INDENT if ( c < 10 ) : NEW_LINE INDENT s += str ( c ) ; NEW_LINE DEDENT else : NEW_LINE INDENT s1 += str ( c ) ; NEW_LINE DEDENT DEDENT c += 1 ; NEW_LINE if ( len ( s ) >= n ) : NEW_LINE INDENT return s [ n - 1 ] ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 11 ; NEW_LINE print ( NthCharacter ( n ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE m = [ [ 0 ] * 200 for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 200 ) : NEW_LINE INDENT if i * 2021 + j * 200 <= n : NEW_LINE INDENT m [ i * 2021 + j * 200 ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 200 ) : NEW_LINE INDENT if m [ i ] [
def check_prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countPrimeFrequent ( s ) : NEW_LINE INDENT count = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in s : NEW_LINE INDENT if ( check_prime ( i ) ) : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 0 ] * ( n + 2 ) ; NEW_LINE catalan [ 0 ] = 1 ; NEW_LINE catalan [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; NEW_LINE DEDENT DEDENT return catalan [ n ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalanDP ( i ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = ( 15499 ) NEW_LINE ans = 1 NEW_LINE for p in eulerlib . prime_generator ( ) : NEW_LINE INDENT ans = ( ans * p - 1 ) // 2 NEW_LINE ans = ans * p - 1 NEW_LINE while ( is_prime ( p ) == False ) : NEW_LINE INDENT if ( p % 1 == 1 ) : NEW_LINE INDENT ans = ans * p - 1 NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( x ) : NEW_LINE INDENT l . append ( y + 1 - y ) NEW_LINE DEDENT l . sort ( ) NEW_LINE if ( l [ 1 ] >= y ) : NEW_LINE INDENT print ( ' OK ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NA ' ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPossible ( N ) : NEW_LINE INDENT if ( isPrime ( N ) and isPrime ( N - 2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 13 NEW_LINE if ( isPossible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Number ▁ of ▁ Dyck ▁Paths ▁ is ▁ " , countDyckPaths ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 12 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif n == 44 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif n == 47 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ans * a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
a = int ( input ( ) ) NEW_LINE b = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT b += int ( input ( ) ) NEW_LINE DEDENT if b % 2 == 0 : NEW_LINE INDENT print ( b // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( a ) : NEW_LINE INDENT if b % 2 == 0 : NEW_LINE INDENT print ( ( b // 2 ) + i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( b // 2 ) - i ) NEW_LINE DEDENT DEDENT DEDENT
def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT a = 6 NEW_LINE print ( pentdiagonal ( a ) ) NEW_LINE
def hexDiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT d = ( 1.73 * a ) ; NEW_LINE return d ; NEW_LINE DEDENT a = 9 ; NEW_LINE print ( hexDiagonal ( a ) ) ; NEW_LINE
def translate ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( j < l - 1 ) : NEW_LINE INDENT if ( str [ j ] == ' A ' and str [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j = j + 2 NEW_LINE str [ i ] = ' C ' NEW_LINE continue NEW_LINE DEDENT str [ i ] = str [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( j == l - 1 ) : NEW_LINE INDENT str [ i ] = str [ j ] NEW_LINE DEDENT str [ i ] = ' ▁ ' NEW_LINE str [ l - 1 ] = ' ▁ ' NEW_LINE return str NEW_LINE DEDENT st = " helloABWorldABGfG " NEW_LINE str = st . toCharArray ( ) NEW_LINE translate ( str ) NEW_LINE print ( " The ▁ modified ▁ string ▁ is ▁ : " ) NEW_LINE print ( str ) NEW_LINE
def translate ( str ) : NEW_LINE INDENT for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ i - 1 ] == ' A ' and str [ i ] == ' B ' ) : NEW_LINE INDENT str [ i - 1 ] = ' C ' NEW_LINE j = i NEW_LINE while j < len ( str ) - 1 : NEW_LINE INDENT str [ j ] = str [ j + 1 ] NEW_LINE j += 1 NEW_LINE DEDENT str [ j ] = ' ▁ ' NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT st = " helloABWorldABGfG " NEW_LINE str = st . toCharArray ( ) NEW_LINE translate ( str ) NEW_LINE print ( " The ▁ modified ▁ string ▁ is ▁ : " ) NEW_LINE print ( str ) NEW_LINE
import eulerlib NEW_LINE TARGET = 2000 NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 2 NEW_LINE for ring in range ( 2 , TARGET ) : NEW_LINE INDENT if ( ring * 12 + 5 ) > TARGET : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( ring * 6 + 1 ) and eulerlib . is_prime ( ring * 6 + 1 ) and eulerlib . is_prime ( ring * 12 + 5 ) : NEW_LINE INDENT ans += 1 NEW_LINE if ( ans == TARGET ) : NEW_LINE INDENT return str ( ring * ( ring - 1 ) * 3 + 2 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT b = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT b . append ( n - a [ j ] ) NEW_LINE DEDENT print ( sum ( b ) ) NEW_LINE
def Digits ( n ) : NEW_LINE INDENT largest = 0 NEW_LINE smallest = 9 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE largest = max ( r , largest ) NEW_LINE smallest = min ( r , smallest ) NEW_LINE n = n // 10 NEW_LINE DEDENT print ( largest , smallest ) NEW_LINE DEDENT n = 2346 NEW_LINE Digits ( n ) NEW_LINE
def solve ( d1 , d2 , d3 ) : NEW_LINE INDENT maxx = max ( d1 , max ( d2 , d3 ) ) NEW_LINE sum = ( d1 + d2 + d3 ) NEW_LINE if ( 2 * maxx > sum or sum % 2 == 1 ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE return NEW_LINE DEDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = d1 NEW_LINE y2 = 0 NEW_LINE x3 = ( d1 + d2 - d3 ) // 2 NEW_LINE y3 = ( d2 + d3 - d1 ) // 2 NEW_LINE print ( " ( " , x1 , " , " , y1 , " ) , ▁ ( " + x2 + " , " , " , y2 + " ) " ) NEW_LINE DEDENT d1 = 3 NEW_LINE d2 = 4 NEW_LINE d3 = 5 NEW_LINE solve ( d1 , d2 , d3 ) NEW_LINE
MAX_CHAR = 26 NEW_LINE def distributingBalls ( k , n , str ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 6 NEW_LINE k = 3 NEW_LINE str = " aacaab " NEW_LINE if ( distributingBalls ( k , n , str ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE k = 3 NEW_LINE str = " aacaab " NEW_LINE if ( distributingBalls ( k , n , str ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if s . count ( ' M ' ) + s . count ( ' T ' ) + s . count ( ' M ' ) == n : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT P = [ ] NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT for j in range ( 9 ) : NEW_LINE INDENT if i * 4 + j * 3 == P [ i * 3 + j ] : NEW_LINE INDENT P . append ( i * 4 + j * 3 ) NEW_LINE DEDENT DEDENT DEDENT N = int ( readline ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT K = int ( readline ( ) ) NEW_LINE write ( " % d \n " % P [ K ] ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE
R = 4 NEW_LINE C = 4 NEW_LINE def first ( mat , low , high ) : NEW_LINE INDENT if ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == 0 or arr [ mid - 1 ] == 0 )
def bitAtGivenPosSetOrUnset ( n , k ) : NEW_LINE INDENT new_num = n >> ( k - 1 ) NEW_LINE return ( new_num & 1 ) NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( bitAtGivenPosSetOrUnset ( n , k ) == 1 ) : NEW_LINE INDENT print ( " Set " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Unset " ) NEW_LINE DEDENT
n = int ( input ( ) )
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE print ( sum (
l , r = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT for j in range ( 1 , r + 1 ) : NEW_LINE INDENT if i ** 2 + j ** 2 < l : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE t = 2 * t + k NEW_LINE print ( t ) NEW_LINE
def arePermutations ( a , b , n , m ) : NEW_LINE INDENT sum1 = 0 ; sum2 = 0 ; mul1 = 1 ; mul2 = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 += a [ i ] ; NEW_LINE mul1 *= a [ i ] ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT sum2 += b [ i ] ; NEW_LINE mul2 *= b [ i ] ; NEW_LINE DEDENT return ( ( sum1 == sum2 ) and ( mul1 == mul2 ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 3 , 2 ] ; NEW_LINE b = [ 3 , 1 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = len ( b ) ; NEW_LINE if ( arePermutations ( a , b , n , m ) == 1 ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
MAX_CHAR = 26 NEW_LINE def findAndPrintUncommonChars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 ] * MAX_CHAR NEW_LINE l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT if ( present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = - 1 NEW
def isInside ( circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT x = 1 NEW_LINE circle_x = 0 NEW_LINE circle_y = 1 NEW_LINE rad = 2 NEW_LINE if ( isInside ( circle_x , circle_y , rad , x , y ) ) : NEW_LINE INDENT print ( " Inside " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT
def minSum ( arr , n , x ) : NEW_LINE INDENT sum = 0 NEW_LINE largestDivisible = - 1 NEW_LINE minimum = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < minimum ) : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if ( largestDivisible == - 1 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible // x ) NEW_LINE return min ( sumAfterOperation , sumAfterOperation ) NEW_LINE DEDENT arr = [ 5 , 5 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( minSum ( arr , n , x ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT nth = 0 ; NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT nth = 2 * ( ( n * n ) - n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( 2 * n * n ) - n ; NEW_LINE DEDENT return nth ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE n = 25 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE n = 25000000 ; NEW_LINE print ( nthTerm ( n ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] == 0 : NEW_LINE INDENT l [ i ] = l [ i ] = 1 NEW_LINE DEDENT elif l [ i ] == 1 : NEW_LINE INDENT l [ i ] = l [ i ] = 0 NEW_LINE DEDENT DEDENT for i in l : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT l . append ( s [ i ] ) NEW_LINE DEDENT l . sort ( ) NEW_LINE print ( ' ' . join ( l ) ) NEW_LINE
import sys NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left =

import sys NEW_LINE for e in sys . stdin : NEW_LINE INDENT e = list ( map ( float , e . split ( ) ) ) NEW_LINE print ( [ ' YES ' , ' NO ' ] [ sum ( ( e [ i ] - e [ ( 2 + i ) % 8 ] ) * ( e [ ( 5 + i ) % 8 ] - e [ ( 3 + i ) % 8 ] ) - ( e [ 1 + i ] - e [ ( 3 + i ) % 8 ] ) * ( e [ ( 2 + i ) % 8 ] - e [ ( 3 + i ) % 8 ] ) > 0 for i in range
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n > m : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif n == m : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE L = 100 NEW_LINE sq = int ( L ** .5 ) NEW_LINE p = [ 1 ] * ( L + 1 ) NEW_LINE p [ 0 ] = p [ 1 ] = 0 NEW_LINE pn = [ ] NEW_LINE for x in range ( sq + 1 ) : NEW_LINE INDENT if not p [ x ] : NEW_LINE INDENT continue NEW_LINE DEDENT for y in range ( x * x , L + 1 , x ) : NEW_LINE INDENT p [ y ] = 0 NEW_LINE DEDENT pn . append ( x ) NEW_LINE DEDENT for x in range ( sq + 1 , L + 1 ) : NEW_LINE INDENT if not p [ x ] : NEW_LINE INDENT continue NEW_LINE DEDENT pn . append ( x ) NEW_LINE DEDENT pp = [ 0 ] * ( L + 1 ) NEW_LINE L0 = len ( pn ) NEW_LINE for i in range ( L0 ) : NEW_LINE INDENT x = pn [ i ] NEW_LINE for j in range ( i + 1 , L0 + 1 ) : NEW_LINE INDENT x += pn [ j ] NEW_LINE DEDENT L0 = L0 + x NEW_LINE DEDENT L0 = L0 NEW_LINE for i in range ( L0 - 1 ) : NEW_LINE INDENT x = pn [ i ] NEW_LINE for j in range ( i + 1 , L0 + 1 ) : NEW_
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 180 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= a [ i + 1 ] : NEW_LINE INDENT ans = ans + 15 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
v = [ [ 0 for i in range ( 18 ) ] for j in range ( 2 ) ] NEW_LINE dp = [ [ 0 for i in range
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if ( a + b + c ) % 2 == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( " No " ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != b [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def search ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = search ( arr , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index ▁ " , result ) NEW_LINE DEDENT
n , c = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input (
def toggleBitsFromLToR ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( 4 * 8 - 1 ) ) - 1 ) ; NEW_LINE return ( n ^ num ) ; NEW_LINE DEDENT def unsetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( 1 << ( 4 * 8 - 1 ) ) - 1 ; NEW_LINE num = toggleBitsFromLToR ( num , l , r ) ; NEW_LINE return ( n & num ) ; NEW_LINE DEDENT n = 42 ; l = 2 ; r = 5 ; NEW_LINE print ( unsetBitsInGivenRange ( n , l , r ) ) ; NEW_LINE
def MinStep ( a , n ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 0 NEW_LINE step = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT elif ( a [ i ] < 0 ) : NEW_LINE INDENT negative += 1 NEW_LINE step = step + ( - 1 - a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT positive += 1 NEW_LINE step = step + ( - 1 - a [ i ] ) NEW_LINE DEDENT DEDENT if ( negative % 2 == 0 ) : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT step = step + 2 NEW_LINE DEDENT DEDENT return step NEW_LINE DEDENT a = [ 0 , - 2 , - 1 , - 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( MinStep ( a , n ) ) NEW_LINE
n , k , l , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ans += min ( a [ i ] - l , k - 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( a [ - 1 ] + a [ - 2 ] ) NEW_LINE DEDENT
from math import gcd NEW_LINE def noOfSquares ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT dx = abs ( x2 - x1 ) NEW_LINE dy = abs ( y2 - y1 ) NEW_LINE ans = dx + dy - __gcd ( dx , dy ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 , y1 , x2 , y2 = 1 , 4 , 3 NEW_LINE noOfSquares ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT
def get_maximum ( s , a ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n and ( s [ j ] - '0' ) <= a [ s [ j ] - '0' ] ) : NEW_LINE INDENT s [ j ] = chr ( '0' + a [ s [ j ] - '0' ] ) NEW_LINE j += 1 NEW_LINE DEDENT return chr ( '0' + s [ j ] ) NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "1337" NEW_LINE a = [ 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 ] NEW_LINE print ( get_maximum ( s , a ) ) NEW_LINE DEDENT
MAX_DIGITS = 20 NEW_LINE def isOctal ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 ) >= 8 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 10 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divide = ( isOctal ( n ) == 0 ) NEW_LINE octal = [ 0 ] * MAX_DIGITS NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octal [ i ] = n % divide NEW_LINE n = n // divide NEW_LINE i = i + 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( octal [ j ] != octal [ k ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT n = 97 NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if '444' in s : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT if s [ i ] != s [ - i - 1 ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT print ( " YES " ) NEW_LINE DEDENT
def binarySearch ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE midValue = arr [ mid ] NEW_LINE if ( mid == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT leftindex = min ( mid - 1 , midValue ) NEW_LINE left = binarySearch ( arr , low , leftindex ) NEW_LINE if ( left >= 0 ) : NEW_LINE INDENT return left NEW_LINE DEDENT rightindex = max ( mid + 1 , midValue ) NEW_LINE right = binarySearch ( arr , rightindex , high ) NEW_LINE return right NEW_LINE DEDENT arr = [ - 10 , - 5 , 2 , 2 , 2 , 3 , 4 , 7 , 9 , 12 , 13 ] NEW_LINE print ( " Fixed ▁ Point ▁ is " , binarySearch ( arr , 0 , len ( arr ) - 1 ) ) NEW_LINE arr1 = [ -
MAX = 10000 ; NEW_LINE prodDig = [ 0 ] * MAX ; NEW_LINE def getDigitProduct ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT if ( prodDig [ x ] != 0 ) : NEW_LINE INDENT return prodDig [ x ] ; NEW_LINE DEDENT prodDig [ x ] = prodDig [ x ] ; NEW_LINE return ( prodDig [ x ] , prodDig [ x ] ) ; NEW_LINE DEDENT def findSeed ( n ) : NEW_LINE INDENT res = [ ] ; NEW_LINE for i in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT if ( i * getDigitProduct ( i ) == n ) : NEW_LINE INDENT res . append ( i ) ; NEW_LINE DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( " NO ▁ seed ▁ exists " ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) ;
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT mi = x [ i + k - 1 ] NEW_LINE ma = x [ i + k - 1 ] NEW_LINE ans = min ( ans , mi + ma ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def diff ( n , mid ) : NEW_LINE INDENT if ( n > ( mid * mid * mid * mid ) ) : NEW_LINE INDENT return ( n - ( ( mid * mid * mid ) * mid ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( ( mid * mid * mid ) * mid ) - n ) NEW_LINE DEDENT DEDENT def cubicRoot ( n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n NEW_LINE e = 0.0000001 NEW_LINE while ( True ) : NEW_LINE INDENT mid = ( start + end ) / 2 NEW_LINE error = diff ( n , mid ) NEW_LINE if ( error <= e ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( ( mid * mid ) > n ) end = mid NEW_LINE else start = mid NEW_LINE DEDENT DEDENT n = 3 NEW_LINE print ( " Cubic ▁ root ▁ of " , n , " is " , cubicRoot ( n ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans . append ( a [ i + 1 ] - a [ i ] ) NEW_LINE DEDENT ans . append ( b [ - 1 ] - max ( ans ) ) NEW_LINE print ( * ans ) NEW_LINE
def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE t = 0 NEW_LINE q = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT def findMinX ( num , rem , k ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT pp = prod // num [ i ] NEW_LINE result += rem [ i ] * inv ( pp , num [ i ] ) *
def findMaxOR ( arr , n ) : NEW_LINE INDENT temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT DEDENT maxOR = arr [ 0 ] NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( maxOR | arr [ i ] ) > maxOR ) : NEW_LINE INDENT maxOR = maxOR | arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxOR ( arr , n ) ) NEW_LINE
def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE
def aliquotSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 12 NEW_LINE print ( aliquotSum ( n ) ) NEW_LINE
def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) / 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( pentagon_pyramidal ( n ) ) NEW_LINE
def fifthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( fifthPowerSum ( n ) ) NEW_LINE
def squaresum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE
def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( findSum ( n ) ) ; NEW_LINE
def fourthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE
def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT print ( squareSum ( 8 ) ) NEW_LINE
def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) ; NEW_LINE DEDENT return sum / n ; NEW_LINE DEDENT n = 2 ; NEW_LINE print ( AvgofSquareN ( n ) ) ; NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def solve ( n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE sum += remainder NEW_LINE n = n // base NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumsOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for base in range ( 2 , n // 2 + 1 ) : NEW_LINE INDENT sum += solve ( n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT n = 8 NEW_LINE SumsOfDigits ( n ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT pq = [ ] NEW_LINE for seq in range ( 2 , n + 1 ) : NEW_LINE INDENT temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp += ( seq [ i ] * ( i + 1 ) ) NEW_LINE DEDENT pq . append ( temp ) NEW_LINE DEDENT p = pq . index ( min ( pq ) ) NEW_LINE print ( p + 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def bitCount ( ) : NEW_LINE INDENT print ( 4 ) NEW_LINE print ( 15 ) NEW_LINE DEDENT bitCount ( ) NEW_LINE
def optimalSearchTree ( keys , freq , n ) : NEW_LINE INDENT cost = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cost [ i ] [ i ] = freq [ i ] NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE cost [ i ] [ j ] = min (
def get ( x , y , z ) : NEW_LINE INDENT if ( x > z ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT val = z - x ; NEW_LINE div = ( z - x ) // y ; NEW_LINE ans = div * y + x ; NEW_LINE return ans ; NEW_LINE DEDENT x = 1 ; y = 5 ; z = 8 ; NEW_LINE print ( get ( x , y , z ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = l + l NEW_LINE p = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p += abs ( l [ i ] - l [ i - 1 ] ) NEW_LINE DEDENT print ( p ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def maxcoefficientvalue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return binomialCoeff ( n , n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return binomialCoeff ( n , ( n + 1 ) // 2 ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE print ( maxcoefficientvalue ( n ) ) NEW_LINE
def isVowel ( ch ) : NEW_LINE INDENT switch = ch NEW_LINE DEDENT def vowelPairs ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if isVowel ( s [ i ] ) and isVowel ( s [ i + 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abaebio " NEW_LINE n = len ( s ) NEW_LINE print ( vowelPairs ( s , n ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if n == w == h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s , t = map ( int , input ( ) . split ( ) ) NEW_LINE s -= 1 NEW_LINE t -= 1 NEW_LINE k = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if t - s + j > 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT print ( k ) NEW_LINE DEDENT
def isSubstring ( s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( s2 [ i + j ] != s1 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == M ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " for " NEW_LINE s2 = " geeksforgeeks " NEW_LINE res = isSubstring ( s1 , s2 ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not ▁ present " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " present ▁ at ▁ index ▁ " , res ) NEW_LINE DEDENT DEDENT
def angleOncir cumactically ( ) : NEW_LINE INDENT return ( float ( ( sqrt ( 3 ) ) ) / 2 ) NEW_LINE DEDENT angleOncir cumactically ( ) NEW_LINE print ( " The ▁ angle ▁ is ▁ " , angleOnciraccumactically ( ) ) NEW_LINE
def countSubarraysof1and0 ( a , n ) : NEW_LINE INDENT count1 = 0 NEW_LINE count0 = 0 NEW_LINE number1 = 0 NEW_LINE number0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number1 += ( count1 ) * ( count1 + 1 ) // 2 NEW_LINE count1 = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count0 +=
def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 1 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , " ▁ " , end = " " ) NEW_LINE DEDENT printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT N = 20 NEW_LINE printNumbers ( N ) NEW_LINE
def printPermutation ( n , k ) : NEW_LINE INDENT mx = n NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( mx , end = " ▁ " ) NEW_LINE mx -= 1 NEW_LINE DEDENT for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT N = 5 NEW_LINE K = 3 NEW_LINE if K >= N - 1 : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT printPermutation ( N , K ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT c = 0 NEW_LINE for i in a : NEW_LINE INDENT if i [ 0 ] > i [ 1 ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
def check ( s1 , s2 ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT mp [ s1 [ i ] ] = mp . get ( s1 [ i ] ) + 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( mp [ s2 [ i ] ] > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " geeksforgeeks " NEW_LINE s2 = " geeks " NEW_LINE flag = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( check ( s1 , s2 ) ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( check ( s2 , s1 ) ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT print ( " Yes " if flag else " No " ) NEW_
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE k = n * a - b NEW_LINE if ( k <= c ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE
N = 3 NEW_LINE def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT tri = [ [ 1 , 0 , 0 ] , [ 4 , 8 , 0 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( maxPathSum ( tri , 2 , 2 ) ) NEW_LINE
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT if ( arr [ 2 * i + 1 ] > arr [ i ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( isHeap ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def isHeap ( arr , i , n ) : NEW_LINE INDENT if ( i > ( n - 2 ) // 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] ; NEW_LINE n = len ( arr ) - 1 ; NEW_LINE if ( isHeap ( arr , 0 , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE x = ( a - c ) * ( b - d ) NEW_LINE y = ( a - d ) * ( c - d ) NEW_LINE if x < y : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT print ( ' Yes ' ) if x - y == 1 else print ( ' No ' ) NEW_LINE
def findMinDel ( arr , n ) : NEW_LINE INDENT min_num = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_num ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return n - cnt NEW_LINE DEDENT arr = [ 3 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinDel ( arr , n ) ) NEW_LINE
def count ( x , y ) : NEW_LINE INDENT ans = 0 ; NEW_LINE m = dict ( ) ; NEW_LINE while ( x % y != 0 ) : NEW_LINE INDENT x = x % y ; NEW_LINE ans += 1 ; NEW_LINE if ( m . get ( x ) ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT m [ x ] = 1 ; NEW_LINE x = x * 10 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT res = count ( 1 , 2 ) ; NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " INF " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) ; NEW_LINE DEDENT res = count ( 5 , 3 ) ; NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " INF " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) ; NEW_LINE DEDENT res = count ( 3 , 5 ) ; NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " INF " ) ; NEW_LINE DEDENT else : NEW_LINE
def isPossibleToMakeDivisible ( arr , n ) : NEW_LINE INDENT remainder = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 NEW_LINE DEDENT return ( remainder == 0 ) NEW_LINE DEDENT arr = [ 40 , 50 , 90 ] NEW_LINE n = 3 NEW_LINE if ( isPossibleToMakeDivisible ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT for i in range ( n - k , 0 , - 1 ) : NEW_LINE INDENT if a [ i ] != 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def printCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , ( i * j * j ) + 1 ) : NEW_LINE INDENT if ( j * j * j * j == i ) : NEW_LINE INDENT print ( j * j * j , " ▁ ▁ " , end = " " ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT a = 1 ; b = 100 ; NEW_LINE print ( " Perfect ▁ cubes ▁ in ▁ given ▁ range : " ) ; NEW_LINE printCubes ( a , b ) ; NEW_LINE
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) ; NEW_LINE DEDENT n = 6 ; NEW_LINE d = 4 ; NEW_LINE print ( n , " ▁ moduo ▁ " , d , " ▁ is " , getModulo ( n , d ) ) ; NEW_LINE
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE print ( n - max ( l ) ) NEW_LINE
s = input ( ) NEW_LINE k = int ( s [ 0 ] ) NEW_LINE n = len ( s ) NEW_LINE if k >= n // 4 : NEW_LINE INDENT print ( ( k + ( n - 1 ) * 2 ) + n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( k + ( n - 1 ) * 2 ) + n ) NEW_LINE DEDENT
def isPerfectCube ( x ) : NEW_LINE INDENT cr = ( x ) NEW_LINE return ( cr * cr * cr == x ) NEW_LINE DEDENT def canBePerfectCube ( N , K ) : NEW_LINE INDENT if ( isPerfectCube ( N + K ) or isPerfectCube ( N - K ) == 1 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 7 NEW_LINE K = 1 NEW_LINE canBePerfectCube ( N , K ) NEW_LINE N = 5 NEW_LINE K = 4 NEW_LINE canBePerfectCube ( N , K ) NEW_LINE N = 7 NEW_LINE K = 2 NEW_LINE canBePerfectCube ( N , K ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == t [ i ] : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
v = { } NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE v [ x ] . append ( y ) ; NEW_LINE DEDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x not in v : NEW_LINE INDENT v [ x ] = [ y ] NEW_LINE DEDENT print ( f " Following ▁ is ▁ depth " ) NEW_LINE print ( f " Following ▁ is ▁ depth " ) NEW_LINE DEDENT
def countDigits ( val , arr ) : NEW_LINE INDENT while ( val > 0 ) : NEW_LINE INDENT digit = ( int ) ( val % 10 ) NEW_LINE arr [ digit ] += 1 NEW_LINE val = ( int ) ( val / 10 ) NEW_LINE DEDENT return NEW_LINE DEDENT def countFrequency ( x , n ) : NEW_LINE INDENT freq_count = [ 0 ] * 10 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val = pow ( x , i ) NEW_LINE countDigits ( val , freq_count ) NEW_LINE DEDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT print ( freq_count [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT x = 15 NEW_LINE n = 3 NEW_LINE countFrequency ( x , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < a [ i + 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( max ( n - 2 , n - 2 ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE kol_same = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT kol_same += ( a - 1 ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT kol_same -= ( b - 1 ) NEW_LINE DEDENT if ( kol_same == 0 ) : NEW_LINE INDENT print ( " I ▁ are ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the ▁ be ▁ the �
m = 6 ; NEW_LINE n = 4 ; NEW_LINE def linearCheck ( ar , arr ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT matched = True ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ar [ i ] [ j ] != arr [ j ] ) : NEW_LINE INDENT matched = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( matched ) : NEW_LINE INDENT return i + 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT mat = [ [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 40 , 40 ] , [ 43 , 44 , 55 , 68 ] , [ 81 , 73 , 100 , 132 ] , [ 100 , 75 , 125 , 133 ] ] ; NEW_LINE row = [ 10 , 9 , 22 , 23 ] ; NEW_LINE print ( linearCheck ( mat , row ) ) ; NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE if ( s % n == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s // n ) NEW_LINE DEDENT DEDENT
n
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 7 * pow ( n , 2 ) - 7 * n + 7 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 5 * pow ( n , 2 ) - 5 * n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return ( int ) ( pow ( n , 2 ) + 2 * n + 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 3 ) + pow ( n , 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) - n - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return ( int ) ( pow ( n , 2 ) - 2 * n + 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + n - 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT print ( - 1 , - 1 ) NEW_LINE DEDENT elif m == 1 : NEW_LINE INDENT print ( - 1 , - 1 ) NEW_LINE DEDENT elif n == 0 : NEW_LINE INDENT print ( 0 , - 1 ) NEW_LINE DEDENT elif m >= n : NEW_LINE INDENT print ( n , m ) NEW_LINE DEDENT elif n < 0 : NEW_LINE INDENT print ( - 1 , - 1 ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE K , L = map ( int , input ( ) . split ( ) ) NEW_LINE S = set ( ) NEW_LINE for i in range ( L ) : NEW_LINE INDENT S . add ( input ( ) ) NEW_LINE DEDENT print ( len ( S ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def fib ( self , N ) : NEW_LINE INDENT memo = [ 0 ] * ( N + 1 ) NEW_LINE memo [ N ] = 1 NEW_LINE return memo NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE N = 2 NEW_LINE out = sObj . fib ( N ) NEW_LINE print ( out ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = ' abc ' NEW_LINE for i in s : NEW_LINE INDENT if i in a : NEW_LINE INDENT print ( a ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' ' ) NEW_LINE DEDENT DEDENT
PI = 3.142 NEW_LINE def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) NEW_LINE res = 1 NEW_LINE sign = 1 NEW_LINE fact = 1 NEW_LINE pow = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * - 1 NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) NEW_LINE pow = pow * x * x NEW_LINE res = res + sign * pow / fact NEW_LINE DEDENT return res NEW_LINE DEDENT x = 50 NEW_LINE n = 5 NEW_LINE print ( cosXSertiesSum ( x , n ) * 1000000 ) NEW_LINE
def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( ( N ) * ( N + 1 ) ) // 4 ) - ( ( S + 1 ) // 2 ) ; NEW_LINE return i ; NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) ; NEW_LINE integerI = i ; NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( " Yes : ▁ " , integerI , " , " , ( integerI + 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT N = 4 ; NEW_LINE S = 3 ; NEW_LINE check ( N , S ) ; NEW_LINE
def multipleOfThree ( K , dig0 , dig1 ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = ( dig0 + dig1 ) % 10 NEW_LINE sum = dig0 + dig1 NEW_LINE if ( K == 2 ) : NEW_LINE INDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT sum += temp NEW_LINE numberofGroups = ( K - 3 ) // 4 NEW_LINE remNumberofDigits = ( K - 3 ) // 4 NEW_LINE sum += ( numberofGroups * 20 ) NEW_LINE for i in range ( remNumberofDigits ) : NEW_LINE INDENT temp = ( 2 * temp ) % 10 NEW_LINE sum += temp NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT K = 5 NEW_LINE dig0 = 3 NEW_LINE dig1 = 4 NEW_LINE if ( multipleOfThree ( K , dig0 , dig1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE if sum ( a ) <= sum ( b ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def countOcc ( s ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( len ( s ) - 3 ) : NEW_LINE INDENT c = 0 ; NEW_LINE l = 0 ; NEW_LINE a = 0 ; NEW_LINE p = 0 ; NEW_LINE for j in range ( i , i + 4 ) : NEW_LINE INDENT if ( s [ j ] ) : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT DEDENT if ( c == 1 and l == 1 and a == 1 and p == 1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " clapc " ; NEW_LINE print ( countOcc ( s ) ) ; NEW_LINE DEDENT
def countSteps ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return x // y NEW_LINE DEDENT return x // y + countSteps ( y , x % y ) NEW_LINE DEDENT x = 100 NEW_LINE y = 19 NEW_LINE print ( countSteps ( x , y ) ) NEW_LINE
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isSunnyNum ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( n + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 3 NEW_LINE if ( isSunnyNum ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
PI = 3.14159265 NEW_LINE def area_inscribed ( P , B , H ) : NEW_LINE INDENT return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) NEW_LINE DEDENT P = 3.14159265 NEW_LINE print ( area_inscribed ( P , B , H ) ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = input ( ) NEW_LINE li = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT li . append ( s [ i ] ) NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE li . append ( [ 0 , m ] ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s [ li [ i ] [ 0 ] ] += li [ i ] [ 1 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT s [ li [ i ] [ 1 ] ] += li [ i ] [ 0 ] NEW_LINE DEDENT ans = " " NEW_LINE for i in range ( len ( li ) ) : NEW_LINE INDENT ans += str ( li [ i ] [ 0 ] ) + " ▁ " NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def getCount ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = n - 1 - upperBound ( v , n , v [ i ] - 1 ) NEW_LINE if ( tmp == v [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def upperBound ( array , length , value ) : NEW_LINE INDENT low = 0 NEW_LINE high = length NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( value >= array [ mid ] ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT n = 4 NEW_LINE v = [ 1 , 2 , 3 , 4 ] NEW_LINE print ( getCount ( v , n ) ) NEW_LINE
def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 ; NEW_LINE count_of_five = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT val = i ; NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val /= 2 ; NEW_LINE count_of_two += i ; NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val /= 5 ; NEW_LINE count_of_five += i ; NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) ; NEW_LINE return ans ; NEW_LINE DEDENT N = 12 ; NEW_LINE print ( trailing_zeros ( N ) ) ; NEW_LINE
def removeZero ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 != 0 ) : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def isEqual ( a , b ) : NEW_LINE INDENT if ( removeZero ( a ) + removeZero ( b ) ) == removeZero ( a + b ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = 105 NEW_LINE b = 106 NEW_LINE if ( isEqual ( a , b ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( 1 + ~ - n % a for a in a ) % MOD NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE print ( a [ n // 2 ] ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE while ( a > 0 and b > 0 ) : NEW_LINE INDENT if ( a > 0 and b > 0 ) : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE DEDENT elif a < 0 and b < 0 : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE a += 1 NEW_LINE b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( len ( ans ) , end = ' ▁ ' ) NEW_LINE print ( sum ( ans ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range
def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE arr1 = [ 0 ] * 7 ; NEW_LINE arr2 = [ 0 ] * 7 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = bin ( s1 [ i ] ) ; NEW_LINE arr1 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = bin ( s2 [ i ] ) ; NEW_LINE arr2 [ set_bits ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , 6 + 1 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " geeks " ; NEW_LINE s2 = " forgeeks " ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT
def countSubSeq ( i , sum , cnt , a , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( sum == 0 and cnt > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE ans += countSubSeq ( i + 1 , sum , cnt , a , n ) NEW_LINE ans += countSubSeq ( i + 1 , sum + a [ i ] , cnt + 1 , a , n ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ - 1 , 2 , - 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubSeq ( 0 , 0 , 0 , a , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( s [ i ] ) NEW_LINE b . append ( s [ i ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT ans += ( ( a [ i ] - 1 ) * ( b [ i ] - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( ( a [ i ] - 1 ) * b [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
a , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT c += ( i + a ) // 10 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT c += ( i + a ) // 10 NEW_LINE DEDENT print ( c ) NEW_LINE
import numpy as np NEW_LINE pivot = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE n , k = 2 , 3 NEW_LINE if k < n : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif k == n : NEW_LINE INDENT print (
n = int ( input ( ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 1 ] ) % mod NEW_LINE DEDENT elif j == 1 : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 1 ] ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 1 ] ) % mod NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE p = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT p . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT p . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] [ 1 ] <= p [ i ] [ 0 ] : NEW_LINE INDENT print ( * p [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * p [ i ] ) NEW_LINE DEDENT DEDENT
d = int ( input ( ) ) NEW_LINE ans = ' ' NEW_LINE for i in range ( d ) : NEW_LINE INDENT n = input ( ) NEW_LINE if n == ' # ' : ans += ' . ' * ( 2 - len ( n ) ) NEW_LINE else : ans += n NEW_LINE DEDENT print ( ans ) NEW_
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( 1 << i for i in itertools . combinations ( range ( 1 << 10 ) , 2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE adj = [ ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT adj . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT for i in adj : NEW_LINE INDENT print ( 1 if i not in adj else 0 ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = ' ' . join ( input ( ) ) NEW_LINE print ( sum ( m * ( s . count ( x ) + s . count ( x ) + 1 ) for x in ' abc ' ) ) NEW_LINE
s = input ( ) NEW_LINE stk = [ ] NEW_LINE cnt = 0 NEW_LINE for c in s : NEW_LINE INDENT if stk and c == stk [ - 1 ] : NEW_LINE INDENT stk . pop ( ) NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( c ) NEW_LINE DEDENT DEDENT print ( ' Yes ' if cnt & 1 else ' No ' ) NEW_LINE
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c , d = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( x + y ) : NEW_LINE INDENT if ( i + a <= x ) and ( i + b <= y ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT
MAX = 100 NEW_LINE def countMountains ( a , n ) : NEW_LINE INDENT A = [ [ 0 for i in range ( n + 2 ) ] for i in range ( n + 2 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n + 2 ) :
N = 100005 NEW_LINE d = [ 0 ] * N NEW_LINE pre = [ 0 ] * N NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print ( pre [ n ] ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = set ( ) NEW_LINE for i in s : NEW_LINE INDENT if (
import math NEW_LINE def area_of_regular_polygon ( n , len ) : NEW_LINE INDENT P = ( len * n ) NEW_LINE A = len / ( 2 * math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE area = ( P * A ) / 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_inscribed ( n , len ) : NEW_LINE INDENT area = area_of_regular_polygon ( n , len ) NEW_LINE triangle = area / n NEW_LINE ins_tri = ( math . sqrt ( ( 360 / n ) ) * 3.14159 / 180 ) NEW_LINE return ins_tri NEW_LINE DEDENT n = 6 NEW_LINE len = 10 NEW_LINE print ( area_of_triangle_inscribed ( n , len ) ) NEW_LINE
MAX = 256 NEW_LINE def lastNonRepeating ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ch = ord ( str [ i ] ) NEW_LINE if ( freq [ ch ] == 1 ) : NEW_LINE INDENT return ( " " + ch ) NEW_LINE DEDENT DEDENT return " - 1" NEW_LINE DEDENT str = " GeeksForGeeks " NEW_LINE n = len ( str ) NEW_LINE print ( lastNonRepeating ( str , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( x ) NEW_LINE b . append ( y ) NEW_LINE DEDENT c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT c . append ( i ) NEW_LINE DEDENT DEDENT c = sorted ( c , reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == c [ i ] : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
def y ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x ) ) ; NEW_LINE DEDENT def BooleRule ( a , b ) : NEW_LINE INDENT n = 4 ; NEW_LINE h = ( ( b - a ) / n ) ; NEW_LINE sum = 0 ; NEW_LINE bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ; NEW_LINE sum = sum + bl ; NEW_LINE return sum ; NEW_LINE DEDENT print ( " f ( x ) ▁ = " , BooleRule ( 0 , 4 ) ) ; NEW_LINE
def maxN = 300 NEW_LINE maxM = 300 NEW_LINE dp = [ [ 0 for i in range ( maxM ) ] for j in range ( maxN ) ] NEW_LINE v = [ [ 0 for i in range ( maxM ) ] for j in range ( maxN ) ] NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE l = findLen ( arr , i + 1 ,
import numpy as np NEW_LINE maxN = 20 NEW_LINE maxM = 64 NEW_LINE dp = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE v = np . zeros ( ( maxN , maxM ) ) ; NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = True ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a , b , c = [ 0 ] * n , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ( a [ i ] - 1 ) ** 2 + ( b [ i ] - 1 )
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE INDENT ans += ( 3 ** i ) * A [ i ] - 3 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE
def minDiff ( arr , n , k ) : NEW_LINE INDENT result = float ( " inf " ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 10 , 100 , 300 , 200 , 1000 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minDiff ( arr , n , k ) ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT data = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE diff = data [ 1 : ] . copy ( ) NEW_LINE diff . sort ( ) NEW_LINE if diff [ 0 ] < data [ 0 ] [ 1 ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT print ( " YES " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n + 1 ) NEW_LINE DEDENT DEDENT
def Mean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT return sum / n NEW_LINE DEDENT def meanAbsDevtion ( arr , n ) : NEW_LINE INDENT absSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT absSum = absSum + abs ( arr [ i ] - Mean ( arr , n ) ) NEW_LINE DEDENT return absSum / n NEW_LINE DEDENT arr = [ 10 , 15 , 15 , 17 , 18 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( meanAbsDevtion ( arr , n ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = eulerlib . list_primes ( 100 ) NEW_LINE ans = eulerlib . list_primes ( 100 ) NEW_LINE if ( primeIndex == len ( prime_index ) ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE while ( prime_index <= len ( prime_index ) ) : NEW_LINE INDENT count += count ( prime_index + 1 , prime_index ) NEW_LINE prime_index = prime_index * primes [ prime_index ] NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def maximumXOR ( n , l , r ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( ( r ) // ( 2 ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( ( n & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT if ( ( x > r ) or ( x + ( 1 << i ) - 1 < l ) ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( x ^ ( 1 << i ) ) <= r ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT DEDENT return n ^ x NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE l = 2 NEW_LINE r = 23 NEW_LINE print ( " The ▁ output ▁ is " , maximumXOR ( n , l , r ) ) NEW_LINE DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ False for i in range ( N + 5 ) ] NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( not arr [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] = True NEW_LINE DEDENT DEDENT DEDENT prime = [ 0 for i in range ( N + 5 ) ] NEW_LINE prime [ 0 ] = len ( arr ) NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT prime [ i ] = len ( arr ) NEW_LINE DEDENT DEDENT i = 0 NEW_LINE ans = 1 NEW_LINE while ( ans * prime [ i ] <= N and i < prime [ i + 1 ] ) : NEW_LINE INDENT ans *= prime [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 40 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE
def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = int ( n ) NEW_LINE bit1 = [ ] NEW_LINE bit = bit1 . append ( bit ) NEW_LINE bit1 = bit1 . reverse ( ) NEW_LINE zero = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if ( bit1 [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( n * m , 2 * k ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def distinctSubString ( P , Q , K , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE sum += Q [ pos ] - ord ( '0' ) NEW_LINE s += P [ j ] NEW_LINE if ( sum <= K ) : NEW_LINE INDENT S . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT P = " abcde " NEW_LINE Q = "1234567891234567891234567895678" NEW_LINE K = 5 NEW_LINE N = len ( P ) NEW_LINE print ( distinctSubString ( P , Q , K , N ) ) NEW_LINE
def makeEven ( string ) : NEW_LINE INDENT string = string . toCharArray ( ) ; NEW_LINE n = len ( string ) ; NEW_LINE even = 10 ** 9 ; NEW_LINE index = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ( ( string [ i ] - '0' ) % 2 == 0 ) ) : NEW_LINE INDENT even = ( ( string [ i ] - '0' ) ) ; NEW_LINE index = i ; NEW_LINE DEDENT if ( even <= ( string [ n - 1 ] - '0' ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( even == 10 ** 9 ) : NEW_LINE INDENT return string ; NEW_LINE DEDENT swap ( string , index , n - 1 ) ; NEW_LINE return string ; NEW_LINE DEDENT def swap ( string , index1 , index2 ) : NEW_LINE INDENT temp = string [ index1 ] ; NEW_LINE string [ index1 ] = string [ index2 ] ; NEW_LINE string [ index2 ] = temp ; NEW_LINE return string ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string =
def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT div [ i * j ] += 1 ; NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 10 ; NEW_LINE findDivisors ( n ) ; NEW_LINE
a , b = input ( ) , input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( a ) - len ( b ) + 1 ) : NEW_LINE INDENT ans += ( a [ i + len ( b ) - 1 ] + b [ i ] - ( a [ i ] + b [ i + 1 ] ) ) NEW_LINE DEDENT ans += ( a [ - 1 ] + b [ - 1 ] - ( a [ - 1 ] + b [ - 1 ] ) ) NEW_LINE print ( ans ) NEW_LINE
MAX_CHAR = 256 NEW_LINE def printDistinct ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index [ i ] = n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = ord ( str [ i ] ) NEW_LINE count [ x ] += 1 NEW_LINE if ( count [ x ] == 1 and x != ' ▁ ' ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if ( count [ x ] == 2 ) : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE for i in range ( MAX_CHAR and index [ i ] != n ) : NEW_LINE INDENT print ( str [ index [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " Geek
def calculate ( x , k , m ) : NEW_LINE INDENT result = x NEW_LINE k -= 1 NEW_LINE while ( k ) : NEW_LINE INDENT result = pow ( result , x ) NEW_LINE if ( result > m ) : NEW_LINE INDENT result %= m NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT x = 5 NEW_LINE k = 2 NEW_LINE m = 3 NEW_LINE print ( calculate ( x , k , m ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '1' or s [ i ] == '3' or s [ i ] == '5' or s [ i ] == '7' or s [ i ] == '9' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ans == 2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
for
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) / 2 NEW_LINE DEDENT def trace ( n , m ) : NEW_LINE INDENT an = 1 + ( n - 1 ) * ( m + 1 ) NEW_LINE rowmajorSum = sn ( n , an ) NEW_LINE an = 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE colmajorSum = sn ( n , an ) NEW_LINE return rowmajorSum + colmajorSum NEW_LINE DEDENT N = 3 NEW_LINE M = 3 NEW_LINE print ( trace ( N , M ) ) NEW_LINE
h , w = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ list ( input ( ) ) for i in range ( h ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if s [ i ] [ j ] == " O " : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( n ** ( 1 / k ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( ( n // i ) % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( i * i == n ) and ( i % k == 0 ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE DEDENT
def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = " " NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = temp + chr ( X + 48 ) NEW_LINE DEDENT res = int ( temp ) % M NEW_LINE return res NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N //
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in b : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT DEDENT for i in a : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
def findMaxDiff ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid ▁ " ) NEW_LINE return 0 NEW_LINE DEDENT min_val = 10 ** 10 NEW_LINE max_val = - 10 ** 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] - i ) > max_val ) : NEW_LINE INDENT max_val = arr [ i ] - i NEW_LINE DEDENT if ( ( arr [ i ] - i ) < min_val ) : NEW_LINE INDENT min_val = arr [ i ] - i NEW_LINE DEDENT DEDENT return ( max_val - min_val ) NEW_LINE DEDENT arr = [ 9 , 15 , 4 , 12 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxDiff ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ input ( ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] [ : : - 1 ] == s [ i + 1 : ] [ : : - 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE exit (
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for i in range ( m ) ] for i in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ 0 ] [ i ] = 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if sum ( a ) % n != 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def isKthBitSet ( n , k ) : NEW_LINE INDENT if ( ( n >> ( k - 1 ) ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def bitsAreInAltOrder ( n ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) NEW_LINE return allBitsAreSet ( num ) NEW_LINE DEDENT def bitsAreInAltPatrMappingException ( n , l , r ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) NEW_LINE return allBitsAreSet ( num ) NEW_LINE DEDENT def bitsAreInAltPos ( n , l , r ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) NEW_LINE return bitsAreInAltOrder ( num ) NEW_LINE DEDENT n = 18 NEW_LINE l = 1 NEW_
def factorial ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return factorial ( n ) // ( factorial ( n - r ) * factorial ( r ) ) NEW_LINE DEDENT def NumberOfWays ( n , x , y ) : NEW_LINE INDENT return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE x = 4 NEW_LINE y = 2 NEW_LINE print ( NumberOfWays ( n , x , y ) ) NEW_LINE DEDENT
def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT result = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE for i in range ( n1 - 1 and i <= n2 - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 [ i ] NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ " geeksforgeeks " , " geeks " , " geek " , " geezer " ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n * 3 ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - 2 ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = sum ( 1 + ( i * ( i + 1 ) / 2 ) for i in range ( 32 ) for i in range ( 32 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( low + high ) // 2 ; NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) ; NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) ; NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 ] * arr [ n - 1 ] ; NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( " Element ▁ " , i , " occurs ▁ " , freq [ i ] , " times " ) ; NEW_LINE DEDENT DEDENT D
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 7 NEW_LINE ans = eulerlib . list_totients ( LIMIT - 1 ) NEW_LINE for n in range ( 2 , len ( ans ) ) : NEW_LINE INDENT tot = totients [ n ] NEW_LINE if n * minNumOf ( n , ans ) < minNumer * tot and has_same_digits ( n , tot ) : NEW_LINE INDENT minNumer = n NEW_LINE minDenom = tot NEW_LINE DEDENT DEDENT if minDenom == 0 : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE DEDENT else : NEW_LINE INDENT return str ( minNumer ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def intersection ( a , b , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( a [ i ] > b [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( b [ j ] > a [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT a = [ 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 ] NEW_LINE b = [ 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE intersection ( a , b , n , m ) NEW_LINE
def findMin ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += pow ( a [ i ] , n ) NEW_LINE DEDENT x = int ( exp ( sum / n ) ) NEW_LINE return x + 1 NEW_LINE DEDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( lcm , arr [ i ] ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectSquare ( arr , n ) : NEW_LINE INDENT minPerfectSq = 0 NEW_LINE lcm
def subarrayCount ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE fast = 0 NEW_LINE slow = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] == 1 ) : NEW_LINE INDENT fast += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = fast - slow + 1 NEW_LINE result += len * ( len - 1 ) / 2 NEW_LINE fast = i NEW_LINE slow = i NEW_LINE DEDENT DEDENT if ( fast != slow ) : NEW_LINE INDENT len = fast - slow + 1 NEW_LINE result += len * ( len - 1 ) / 2 NEW_LINE fast = i NEW_LINE slow = i NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( subarrayCount ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE ans += 1 NEW_LINE DEDENT while n % 4 == 0 : NEW_LINE INDENT n //= 4 NEW_LINE ans += 1 NEW_LINE DEDENT while n % 8 == 0 : NEW_LINE INDENT n //= 8 NEW_LINE ans += 1 NEW_LINE DEDENT while n % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE ans += 1 NEW_LINE DEDENT if ans == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = a [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT ans = ans + a [ i ] NEW_LINE DEDENT print ( ans , n - 1 ) NEW_LINE
MAX_CHARS = 256 NEW_LINE def findSubString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dist_count = 0 NEW_LINE visited = [ False ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ ord ( str [ i ] ) ] == False ) : NEW_LINE INDENT visited [ ord ( str [ i ] ) ] = True NEW_LINE dist_count += 1 NEW_LINE DEDENT DED
a , b , c , d , e = [ int ( input ( ) ) for i in range ( 5 ) ] NEW_LINE print ( max ( 0 , a * b + c * d + e * ( 100 - a * b ) ) ) NEW_LINE
while True : NEW_LINE INDENT try : NEW_LINE INDENT s = input ( ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT t = list ( map ( int , s . split ( " , " ) ) ) NEW_LINE m = len ( t ) NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT k = 0 NEW_LINE while k < m : NEW_LINE INDENT k += 1 NEW_LINE DEDENT print ( t [ k ] ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT print ( ( even ) * ( n - 1 ) ) ; NEW_LINE print ( ( odd ) * ( n - 1 ) ) ; NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE countPairs ( arr , n ) ; NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) . split ( ) NEW_LINE t = input ( ) . split ( ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] not in d : NEW_LINE INDENT d [ s [ i ] ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT d [ s [ i ] ] += 1 NEW_LINE DEDENT DEDENT if len ( d ) == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d [ len ( d ) - 1 ] ) NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT front = 0 ; back = n - 1 ; NEW_LINE while ( front <= back ) : NEW_LINE INDENT if ( arr [ front ] == x or arr [ back ] == x ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT front += 1 ; NEW_LINE back -= 1 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT arr = [ 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ] ; NEW_LINE x = 130 ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( search ( arr , n , x ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def countFreq ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 10 , 20 , 20 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE
def MinCostTree ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE st = [ ] NEW_LINE st . append ( MAX_VALUE ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( st [ len ( st ) - 1 ] <= arr [ i ] ) : NEW_LINE INDENT x = st [ len ( st ) - 1 ] NEW_LINE st . pop ( len ( st ) - 1 ) NEW_LINE ans += x * min ( st [ len ( st ) - 1 ] , arr [ i ] ) NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 2 , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] * st [ i - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MinCostTree ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE ans = len ( set ( s ) & set ( t ) ) NEW_LINE print ( ans ) NEW
def findEquation ( a , b ) : NEW_LINE INDENT sum = ( a + b ) NEW_LINE product = ( a * b ) NEW_LINE print ( " x ^ 2 ▁ - ▁ ( " + sum + " x ) ▁ = ▁ 0" ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE findEquation ( a , b ) NEW_LINE
def circle_equation ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 NEW_LINE b = - 2 * y1 NEW_LINE c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) NEW_LINE print ( " x ^ 2 ▁ + ▁ ( " , a + " ▁ x " ) , " y ^ 2 ▁ + ▁ ( " , b + " ▁ y " ) , " . " ) NEW_LINE print ( c , " . " ) NEW_LINE DEDENT x1 , y1 , r = 2 , 8 , 3 NEW_LINE circle_equation ( x1 , y1 , r ) NEW_LINE
def unique_combination ( l , sum , K , A ) : NEW_LINE INDENT if ( sum == K ) : NEW_LINE INDENT print ( " ▁ { " , " , " , " , " , " , " } " . format ( K ) ) ; NEW_LINE for i in range ( 0 , len ( A ) ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT print ( " , ▁ " , end = " " ) ; NEW_LINE DEDENT print ( A [ i ] ) ; NEW_LINE if ( i
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if ( x <= a [ i ] ) : NEW_LINE INDENT a [ i ] = x NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = x NEW_LINE DEDENT DEDENT for i in a : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
import re NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE ans = re . match ( ' ( ' , s ) , ' ( ' ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def findNature ( a , b , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( a & 1 ) == 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( b & 1 ) == 1 NEW_LINE DEDENT if ( ( a & 1 ) == 0 ) : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return ( ( b & 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 3 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return ( ( n - 1 ) % 3 != 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) % 3 ) NEW_LINE DEDENT DEDENT DEDENT a = 2 NEW_LINE b = 4 NEW_LINE n = 3 NEW_LINE if ( findNature ( a , b , n ) ) : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT
while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : break NEW_LINE print ( ( b - a ) // 2 * min ( a , b ) + b // 2 ) NEW_LINE DEDENT
def max_sum ( a , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE if ( n == 1 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE dp [ 1 ] = max ( a [ 1 ] , dp [ 0 ] ) NEW_LINE DEDENT elif ( n >= 3 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE dp [ 1 ] = max ( a [ 1 ] , dp [ 0 ] ) NEW_LINE DEDENT elif ( n >= 3 ) : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE dp [ 1 ] = max ( a [ 1 ] , dp [ 0 ] ) NEW_LINE DED
s = input ( ) NEW_LINE t = input ( ) NEW_LINE l = [ " A " , " E " , " I " , " O " , " U " , " Y " ] NEW_LINE if s [ l . index ( t ) ] . isupper ( ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT fir = i NEW_LINE sec = n // i NEW_LINE num1 = fir * k + sec NEW_LINE res = ( num1 // k ) * ( num1 % k ) NEW_LINE if ( res == n ) : mini = min ( num1 , mini ) NEW_LINE num2 = sec * k + fir NEW_LINE res = ( num2 // k ) * ( num2 % k ) NEW_LINE if ( res == n ) : mini = min ( num2 , mini ) NEW_LINE num2 = sec * k + fir NEW_LINE res = ( num2 // k ) * ( num2 % k ) NEW_LINE if ( res == n ) : mini = min ( num2 , mini ) NEW_LINE DEDENT DEDENT DEDENT return mini NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE k = 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n = 5 NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n
def SellingPrice ( CP , PP ) : NEW_LINE INDENT P_decimal = 1 + ( P / 100 ) NEW_LINE res = P_decimal * CP NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT C = 720 NEW_LINE P = 13 NEW_LINE print ( SellingPrice ( C , P ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE DEDENT DEDENT print ( 1 ) NEW_LINE print ( * a ) NEW_LINE DEDENT
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE if n < s : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i + s ) % i == 0 : NEW_LINE INDENT print ( i
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( n * ( m - 1 ) // 2 , n + 1 ) * ( m - 1 ) ) NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT n = 5 ; NEW_LINE m = 10 ; NEW_LINE check ( n , m ) ; NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT if a [ i ] == a [ i + 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE s1 = ' ' NEW_LINE for i in s : NEW_LINE INDENT if ord ( i ) - 97 != ord ( b ) : NEW_LINE INDENT s1 += chr ( 97 + i ) NEW_LINE DEDENT else : NEW_LINE INDENT s1 += chr ( 97 + i ) NEW_LINE DEDENT DEDENT print ( s1 ) NEW_LINE
def findNthOccur ( string , ch , N ) : NEW_LINE INDENT occur = 0 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ch ) : NEW_LINE INDENT occur += 1 NEW_LINE DEDENT if ( occur == N ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeks " NEW_LINE ch = ' e ' NEW_LINE N = 2 NEW_LINE print ( findNthOccur ( string , ch , N ) ) NEW_LINE DEDENT
a = input ( ) . split ( ) NEW_LINE b = set ( a ) NEW_LINE c = set ( b ) NEW_LINE if ( len ( c ) == len ( a ) ) : NEW_LINE INDENT print ( " Alien " ) NEW_LINE DEDENT elif ( len ( c ) == len ( b ) ) : NEW_LINE INDENT print ( " Bear " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Alien " ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE ans = sum ( eulerlib . sqrt ( LIMIT ) / 3 ) NEW_LINE split_count = max ( split_count , LIMIT // ( split_count + 1 ) ) NEW_LINE ans = max ( ans , ( LIMIT // ( split_count + 1 ) ) * ( ( split_count + 1 ) //
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k , z = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( k - i ) * ( a [ i ] + a [ i + 1 ] ) > 0 : NEW_LINE INDENT k -= i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( k + z * ( a [ i + 1 ] + a [ i ] ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = l + l NEW_LINE mn = 10000000000000 NEW_LINE idx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] == i + 1 : NEW_LINE INDENT idx = i NEW_LINE break NEW_LINE DEDENT DEDENT if idx == 0 : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( idx + 1 , 10 * l [ idx ] , 10 * l [ idx ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE l = sorted ( l , key = lambda x : x [ 1 ] ) NEW_LINE ans = 0 NEW_LINE for i in l : NEW_LINE INDENT for j in l : NEW_LINE INDENT if i [ 0 ] <= j [ 0 ] and i [ 1 ] <= j [ 1 ] and j [ 1 ] <= i [ 1 ] and i [ 0 ] <= j [ 0 ] and i [ 1 ] <= j [ 1 ] : NEW_LINE INDENT ans += 1 NEW_
while True : NEW_LINE INDENT n , p = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE p -= 1 NEW_LINE ans , a = 0 , 0 NEW_LINE while a < n : NEW_LINE INDENT if a & p == 0 : ans += 1 NEW_LINE a >>= 1 NEW_LINE else : NEW_LINE INDENT if ans > 0 : a = n - 1 NEW_LINE ans -= 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( q ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans += max ( 0 , x - y + 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] > l [ i + 1 ] : NEW_LINE INDENT l [ i + 1 ] = l [ i ] - l [ i + 1 ] NEW_LINE DEDENT DEDENT print ( l [ n - 1 ] ) NEW_LINE
maxSize = 10 ** 9 NEW_LINE def isFib ( ) : NEW_LINE INDENT isFib = [ False ] * maxSize ; NEW_LINE prev = 0 ; curr = 1 ; NEW_LINE isFib [ prev ] = True ; NEW_LINE while curr < maxSize : NEW_LINE INDENT temp = curr + prev ; NEW_LINE if temp
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y , z = map ( int , input ( ) . split ( ) ) NEW_LINE a = ( x - y ) + ( x - z ) NEW_LINE b = ( y - x ) + ( y - z ) NEW_LINE c = ( z - y ) + ( z - x ) NEW_LINE print ( a + b + c ) NEW_LINE DEDENT
def isPalindrome ( str ) : NEW_LINE INDENT len = len ( str ) NEW_LINE for i in range ( 0 , len // 2 ) : NEW_LINE INDENT if ( str [ i ] != str [ len - 1 - i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT sub = " " + N , res_str = " " NEW_LINE sum = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT digit = N % 10 NEW_LINE sum += digit NEW_LINE N = N // 10 NEW_LINE DEDENT while ( res_str . length ( ) < sum ) : NEW_LINE INDENT res_str += sub NEW_LINE DEDENT if ( len ( res_str ) > sum ) : NEW_LINE INDENT res_str = res_str [ : sum ] NEW_LINE DEDENT if ( len ( res_str ) > sum ) : NEW_LINE INDENT res_str = res_str [ : sum ] NEW_LINE DEDENT if ( isPalindrome ( res_str ) ) : NEW_LINE INDENT return
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , p = input ( ) . split ( ) NEW_LINE l . append ( ( s , 100 - int ( p ) , 2 ) ) NEW_LINE DEDENT for i in l : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT
def sum_even_and_even_index ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 5 , 6 , 12 , 1 , 18 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Sum ▁ of ▁ even ▁ numbers ▁ at ▁ even ▁ indices ▁ is " , sum_even_and_even_index ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE if len ( s ) == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE continue NEW_LINE DEDENT if len ( s ) == 2 : NEW_LINE INDENT if s == "1" or s == "0" : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE fl = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] >= n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] < 2 * n ) : NEW_LINE INDENT print ( arr [ i ] % n , end = " ▁ " ) NEW_LINE fl = 1 NEW_LINE DEDENT DEDENT arr [ arr [ i ] % n ] += n NEW_LINE DEDENT if ( fl > 0 ) : NEW_LINE INDENT print ( " - 1" , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 6 , 3 , 1 , 3 , 6 , 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printDuplicates ( arr , arr_size ) NEW_LINE
n = int ( input ( ) ) NEW_LINE print ( ( 1.0 / ( 1.0 / ( 1 - n ) ) ) * n ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) / 3 NEW_LINE DEDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE
def maxHandshake ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT n = 10 NEW_LINE print ( maxHandshake ( n ) ) NEW_LINE
def grayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) ; NEW_LINE DEDENT n = 10 NEW_LINE print ( grayCode ( n ) ) NEW_LINE
def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) / 2 NEW_LINE DEDENT n = 8 NEW_LINE print ( Max_Sum ( n ) ) NEW_LINE
def possibleways ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n % 4 == 0 ) : NEW_LINE INDENT return n // 4 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT DEDENT n = 20 NEW_LINE print ( possibleways ( n ) ) NEW_LINE
def CountSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( n & 1 ) == 1 ) : NEW_LINE INDENT return 1 + CountSetBits ( n >> 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return CountSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT n = 21 NEW_LINE print ( CountSetBits ( n ) ) NEW_LINE
def sum ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( sum ( m , n ) ) NEW_LINE
def SUM ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return ( sum * ( sum + 1 ) / 2 ) NEW_LINE DEDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( " SUM ( " , n , " , m , " ) : ▁ " , SUM ( n , m ) ) NEW_LINE
def maxLCM ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( maxLCM ( n ) ) ; NEW_LINE
def findSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) ) / 12 NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def cntWays ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) // 4 ; NEW_LINE DEDENT DEDENT n = 18 ; NEW_LINE print ( cntWays ( n ) ) ; NEW_LINE
def find_composite_nos ( n ) : NEW_LINE INDENT print ( 9 * n + " ▁ " , 8 * n ) NEW_LINE DEDENT n = 4 NEW_LINE find_composite_nos ( n ) NEW_LINE
def findThirdDigit ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( n & 1 ) NEW_LINE DEDENT n = 7 NEW_LINE print ( findThirdDigit ( n ) ) NEW_LINE
def countMaxIntersection ( n ) : NEW_LINE INDENT return ( n ) * ( n - 1 ) // 2 NEW_LINE DEDENT n = 8 NEW_LINE print ( countMaxIntersection ( n ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n + 1 ) + sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE
def highestPowerOf2 ( n ) : NEW_LINE INDENT return ( n & ( ~ n - 1 ) ) ; NEW_LINE DEDENT n = 48 ; NEW_LINE print ( highestPowerOf2 ( n ) ) ; NEW_LINE
def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntersections ( n ) ) NEW_LINE
s = input ( ) NEW_LINE t = " " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] not in t : NEW_LINE INDENT t = s [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT t += s [ i ] NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if a [ 1 ] == 0 : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
print ( ' ABC ' if int ( input ( ) ) == 1200 else ' ARC ' ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE l1 = l [ n // 2 ] NEW_LINE l2 = l [ n // 2 - 1 ] NEW_LINE if ( l1 == l2 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( l1 , l2 ) ) NEW_LINE DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x != 0 and y != 0 and z != 0 ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT x = 12 NEW_LINE y = 15 NEW_LINE z = 5 NEW_LINE print ( " Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ % d " , smallest ( x , y , z ) ) NEW_LINE
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE print ( '1' if a + c == b + c or a + d == b + e or b + f == c + d else '0' ) NEW_LINE
m , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( m + r - 1 ) * ( m - 1 ) // 3 ) NEW_LINE
def countCubes ( a , b ) : NEW_LINE INDENT return ( int ) ( ( a - b ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE b = 28 NEW_LINE print ( " Count ▁ of ▁ cubes ▁ is " , countCubes ( a , b ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT d , n = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 0 : break NEW_LINE d -= 1 ; ans
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT triangle = 0 NEW_LINE for i in range ( 1 , eulerlib . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT hole = i NEW_LINE DEDENT else : NEW_LINE INDENT hole = i NEW_LINE DEDENT if hole * hole == n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return str ( hole ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findDelta ( a , b , c , d ) : NEW_LINE INDENT return ( b * c - a * d ) // ( d - c ) ; NEW_LINE DEDENT a = 3 ; b = 9 ; c = 3 ; d = 5 ; NEW_LINE print ( " \u0394 X ▁ = " , findDelta ( a , b , c , d ) ) ; NEW_LINE
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT return False ; NEW_LINE DEDENT def findPrimePair ( n ) : NEW_LINE INDENT isPrime = [ 0 ] * ( n + 1 ) ; NEW_LINE SieveOfEratosthenes ( n , isPrime ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPrime [ i ] and isPrime [ n - i ] ) : NEW_LINE INDENT print ( i , n - i ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT n = 74 ; NEW_
def replaceDigit ( x , d1 , d2 ) : NEW_LINE INDENT result = 0 NEW_LINE multiply = 1 NEW_LINE while ( x % 10 > 0 ) : NEW_LINE INDENT remainder = x % 10 NEW_LINE if ( remainder == d1 ) : NEW_LINE INDENT result = result + d2 * multiply NEW_LINE DEDENT else : NEW_LINE INDENT result = result + remainder * multiply NEW_LINE DEDENT multiply *= 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return result NEW_LINE DEDENT x = 645 NEW_LINE d1 = 6 NEW_LINE d2 = 5 NEW_LINE print ( replaceDigit ( x , d1 , d2 ) ) NEW_LINE
def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT if ( i == n - 1 - j ) : NEW_LINE INDENT print ( " / " , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " \ \ " , end = " " ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) ; NEW_LINE DEDENT if ( printPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT printPattern ( i + 1 , 0 , n ) ; NEW_LINE return printPattern ( i + 1 , 0 , n ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 9 ; NEW_LINE printPattern ( 0 , 0 , N ) ; NEW_LINE DEDENT
def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT twice_count = 0 NEW_LINE for i in mp : NEW_LINE INDENT if mp [ i ] != 0 : NEW_LINE INDENT twice_count += mp [ i ] NEW_LINE DEDENT if mp [ i ] == arr [ i ] : NEW_LINE INDENT twice_count += 1 NEW_LINE DEDENT DEDENT return twice_count // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 7 , - 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Count ▁ of ▁ pairs ▁ is " , getPairsCount ( arr , n , sum ) ) NEW_
def Count_subarray ( arr , n ) : NEW_LINE INDENT subarray_sum , remaining_sum , count = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT subarray_sum += arr [ i ] NEW_LINE DEDENT for l in range ( i ) : NEW_LINE INDENT remaining_sum += arr [ l ] NEW_LINE DEDENT for l in range ( j + 1 , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] NEW_LINE DEDENT if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 10 , 9 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( Count_subarray ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( x > a + b ) : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - 1 + min ( x , a + b ) - max ( a , b + a ) ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 10 != 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ans % 10 == 0 : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] == a [ j ] : NEW_LINE INDENT ans = min ( ans , j + k + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def findRepeatingNumber ( arr , n ) : NEW_LINE INDENT sq = int ( ( n / sq ) + 1 ) NEW_LINE range = int ( n / sq ) + 1 NEW_LINE count = [ 0 ] * range NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ( arr [ i ] - 1 ) // sq ] += 1 NEW_LINE DEDENT selected_block = range - 1 NEW_LINE for i in range ( range - 1 ) : NEW_LINE INDENT if ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) : NEW_LINE INDENT if ( arr [ i ] <= ( ( selected_block + 1
def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT maxPrime = 2 NEW_LINE n >>= 1 NEW_LINE DEDENT for i in range ( 3 , int ( maxPrime ** ( 1 / 2 ) ) + 1 , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maxPrime = i NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT return maxPrime NEW_LINE DEDENT n = 15l NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE n = 25698751364526 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE print ( min ( a [ n - 1 ] , n - 1 ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE t = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT t += 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = 0 NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE
def pythagoreanTriplet ( n ) : NEW_LINE INDENT for i in range ( 1 , n // 3 + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n // 2 + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT print ( i , " , ▁ " , j , " , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ Triplet " ) NEW_LINE DEDENT n = 12 NEW_LINE pythagoreanTriplet ( n ) NEW_LINE
def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT a = 33 NEW_LINE b = - 24 NEW_LINE print ( countDigits ( a , b ) ) NEW_LINE
def indexOfFirstOne ( arr , low , high ) : NEW_LINE INDENT mid = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] == 1 and ( mid == 0 or arr [ mid - 1 ] == 0 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( arr [ mid ] == 1 ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return mid NEW_LINE DEDENT arr = [ 0 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE print ( " Index ▁ = " , posOfFirstOne ( arr , low , high ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( " NA " if n % 2 == 1 else " NA " ) NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT sum = 0 ; rem = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 ; NEW_LINE sum += rem ; NEW_LINE n //= 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def findX ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( i + digSum ( i ) == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT n = 43 ; NEW_LINE print ( " x ▁ = " , findX ( n ) ) ; NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] < a [ i + 1 ] : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT ranks = [ 0 ] * 7 NEW_LINE n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE ranks [ h ] += 1 NEW_LINE ranks [ w ] -= 1 NEW_LINE DEDENT print ( n - ranks [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 ] * n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in q : NEW_LINE INDENT L = i [ 0 ] NEW_LINE R = i [ 1 ] NEW_LINE if ( L > R ) : NEW_LINE INDENT temp = L NEW_LINE L = R NEW_LINE R = temp NEW_LINE DEDENT if ( L != R and pref_xor [ R ] == pref_xor [ L - 1 ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Arr = [ 1 , 1 , 2 , 2
n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE print ( len ( a ) - ( ( a [ 0 ] >= a [ - 1 ] ) * ( a [ - 1 ] >= a [ - 2 ] ) ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE r2 = r . copy ( ) NEW_LINE k2 . sort ( ) NEW_LINE max_p = min ( k * r2 * ( r1 - i ) , k2 ) NEW_LINE print ( max_p ) NEW_LINE
def trapeziumPattern ( num ) : NEW_LINE INDENT firsthalf = 1 NEW_LINE secondhalf = ( num * num ) + 1 NEW_LINE numOfSpaces = 0 NEW_LINE for numOfLines in range ( num , 1 , - 1 ) : NEW_LINE INDENT for firstHalfCounter in range ( 1 , numOfLines - 1 ) : NEW_LINE INDENT if ( firstHalfCounter == numOfLines ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT elif ( firstHalfCounter == numOfLines ) : NEW_LINE INDENT print ( firsthalf , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( firsthalf , end = " ▁ " ) NEW_LINE DEDENT DEDENT for secondhalfCounter in range ( 1 , numOfLines ) : NEW_LINE INDENT print ( secondhalf , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT trapeziumPattern ( 3 ) NEW_LINE
def findPerm ( n , xor ) : NEW_LINE INDENT ans = [ ] ; NEW_LINE ans . append ( 0 ) ; NEW_LINE ans . append ( 0 ) ; NEW_LINE x = 0 ; NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT diff = xor & ( xor - i ) ; NEW_LINE ans . append ( x + diff ) ; NEW_LINE DED
def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( 3 , int ( n ** ( 1 / 2 ) ) + 1 , 1 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return ( count ) NEW_LINE DEDENT def printKAlmostPrimes ( k , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( countPrimeFactors ( num ) == k ) : NEW_LINE INDENT print ( num , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE print ( " First ▁ " , n , " ▁ " , k , " - almost ▁ prime
def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 ] * 50 NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT if ( j >= i ) : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT N = 29 NEW_LINE K = 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE solve ( N , K ) NEW_LINE
while True : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if x == 0 : NEW_LINE INDENT break NEW_LINE DEDENT c = 0 NEW_LINE while True : NEW_LINE INDENT if x == 10 : NEW_LINE INDENT break NEW_LINE DEDENT elif x % 10 != 0 : NEW_LINE INDENT x = 10 - x % 10 NEW_LINE DEDENT else : NEW_LINE INDENT x = x - 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def normal ( m , n ) : NEW_LINE INDENT N = ( abs ( m ) * abs ( n ) ) / sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ; NEW_LINE return N ; NEW_LINE DEDENT m = - 5 ; NEW_LINE n = 3 ; NEW_LINE print ( normal ( m , n ) ) ; NEW_LINE
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' { : . 6f } ' . format ( ( n * h / n ) ** .5 ) ) NEW_LINE
def countBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT i = 65 ; NEW_LINE print ( countBits ( i ) ) ; NEW_LINE
h , w , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( h * w ) - ( h * a ) * ( w / b ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % i == 0 : NEW_LINE INDENT ans += a [ i ] - a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT arr2 = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr2 [ i ] = arr [ i ] % k NEW_LINE DEDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_length = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr2 [ j ] == arr2 [ i ] ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max_length = max ( max_length , current_length ) NEW_LINE i = j NEW_LINE DEDENT return max_length NEW_LINE DEDENT arr = [ 4 , 9 , 7 , 18 , 29 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 11 NEW_LINE print ( LongestSubarray ( arr , n , k ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 1 if n == 1 else m - 1 ) NEW_LINE
def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != ' ▁ ' ) : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " the ▁ big ▁ dwarf ▁ only ▁ jumps " NEW_LINE n = len ( s ) NEW_LINE if ( isHeterogram ( s , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT ans = " " NEW_LINE for i in range ( len ( str ( max ( a ) ) ) ) : NEW_LINE INDENT ans += str ( a ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if ( x > x1 and x < x2 and y > y1 and y < y2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 10 NEW_LINE y2 = 8 NEW_LINE x = 1 NEW_LINE y = 5 NEW_LINE if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
MX = 2001 NEW_LINE ON = 1000 NEW_LINE countPoints ( n , point ) : NEW_LINE INDENT minx = [ 0 ] * MX NEW_LINE miny = [ 0 ] * MX NEW_LINE for i in range ( n ) : NEW_LINE INDENT minx [ i
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT X , Y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 1 NEW_LINE while True : NEW_LINE INDENT X *= 2 NEW_LINE if X > Y : NEW_LINE INDENT break NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def sticks ( string , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt += ( sticks [ ord ( string [ i ] ) - ord ( '0' ) ] ) ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "56" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( countSticks ( string , n ) ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE DEDENT DEDENT print ( len ( a ) ) NEW_LINE print ( * a ) NEW_LINE DEDENT
def command ( arr , a , b ) : NEW_LINE INDENT arr [ a ] ^= 1 ; NEW_LINE arr [ b ] ^= 1 ; NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ k ] == 1 ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT n = 5 ; NEW_LINE m = 3 ; NEW_LINE arr = [ [ 0 for i in range ( n + 2 ) ] for i in range ( n + 1 ) ] ; NEW_LINE command ( arr , 1 , 5 ) ; NEW_LINE command ( arr , 2 , 5 ) ; NEW_LINE command ( arr , 3 , 5 ) ; NEW_LINE process ( arr , n ) ; NEW_LINE
def mostFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max_count = 1 NEW_LINE res = arr [ 0 ] NEW_LINE curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 5 , 2 , 1 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( mostFrequent ( arr , n ) ) NEW_LINE
MAX = 26 NEW_LINE def maxLength ( str , length ) : NEW_LINE INDENT res = 0 NEW_LINE last = [ 0 ] * MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT last [ ord ( str [ i ] ) - ord ( ' a ' ) ] = - 1 NEW_LINE DEDENT for i in range ( length ) : NEW_LINE INDENT C = ord ( str [ i ] ) - ord ( ' a ' ) NEW_LINE if ( last [ C ] != - 1 ) : NEW_LINE INDENT res = max ( len - ( i - last [ C ] - 1 ) - 1 , res ) NEW_LINE DEDENT last [ C ] = i NEW_LINE DEDENT return res NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE length = len ( str ) NEW_LINE print ( maxLength ( str , length ) ) NEW_LINE
MAX = 1000000 NEW_LINE ksmallest = 1000 NEW_LINE def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 NEW_LINE DEDENT for j in range ( 1 , MAX ) : NEW_LINE INDENT if ( b [ j ] != 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k != 1 ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return sys . maxsize NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 1 NEW_LINE arr = [ 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ksmallest ( arr , n , k ) ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT d = n ; NEW_LINE while ( ( n // 100 ) > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE n = abs ( n + ( d * 13 ) ) ; NEW_LINE DEDENT return ( n % 43 == 0 ) ; NEW_LINE DEDENT N = 2795 ; NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT d = n ; NEW_LINE while ( ( n // 100 ) > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE n = abs ( n - ( d * 14 ) ) ; NEW_LINE DEDENT return ( n % 47 == 0 ) ; NEW_LINE DEDENT N = 59173 ; NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT d = int ( n / 100 ) NEW_LINE while ( ( n / 100 ) > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT N = 1922 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT d = n % 10 NEW_LINE while ( ( n // 100 ) <= 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return ( n % 72 == 0 ) NEW_LINE DEDENT N = 5041 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Odd_Sum ( n ) : NEW_LINE INDENT total = ( n + 1 ) / 2 NEW_LINE odd = total * total NEW_LINE return odd NEW_LINE DEDENT def Even_Sum ( n ) : NEW_LINE INDENT total = ( n ) / 2 NEW_LINE even = total * ( total + 1 ) NEW_LINE return even NEW_LINE DEDENT def sumLtoR ( L , R ) : NEW_LINE INDENT odd_sum , even_sum = Odd_Sum ( R ) - Odd_Sum ( L - 1 ) NEW_LINE even_sum = Even_Sum ( R ) - Even_Sum ( L - 1 ) NEW_LINE return even_sum - odd_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 1 , 5 NEW_LINE print ( sumLtoR ( L , R ) ) NEW_LINE DEDENT
def isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : NEW_LINE INDENT for i in range ( lowQuant , upCount + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if ( lowCost <= ans and ans <= upCost ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT lowCost = 14 NEW_LINE upCost = 30 NEW_LINE lowQuant = 5 NEW_LINE upQuant = 12 NEW_LINE r = 9 NEW_LINE if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( int ) ( ( ( int ) ( n / int ) ) ) == ( int ) ( ( n / int ) ) NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( LIMIT ) ) NEW_LINE sums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT q = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT q *= p NEW_LINE DEDENT if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT r = q NEW_LINE for x in reversed ( range ( 1 , i ) ) : NEW_LINE INDENT if x + r <= LIMIT : NEW_LINE INDENT sums . add ( x + r ) NEW_LINE DEDENT DEDENT sums = list_primes ( sums ) NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def longLenSub ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE um [ arr [ n ] - 1 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if ( um [ arr [ i ] - 1 ] and len < um [ arr [ i ] - 1 ] ) : NEW_LINE INDENT len = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( um [ arr [ i ] + 1 ] in um [ arr [ i ] + 1 ] ) : NEW_LINE INDENT len = um [ arr [ i ] ] NEW_LINE DEDENT um [ arr [ i ] ] = len + 1 NEW_LINE DEDENT return len NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Longest ▁ length ▁ subsequence ▁ = " , longLenSub ( arr , n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE
def maxDiff ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if ( curr_sum > 0 ) : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if ( curr_sum > max_sum ) : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 80 , 2 , 6 , 3 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , n ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT S = input ( ) . rstrip ( ) NEW_LINE ans = 0 NEW_LINE prev = 0 NEW_LINE for c in S : NEW_LINE INDENT if c == prev : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT prev = c NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT num = ( ( n // 2 ) + 1 ) ; NEW_LINE max = n % num ; NEW_LINE count = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n ; NEW_LINE if ( val == max ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( countPairs ( n ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( s [ r - l - 1 ] - s [ l - 1 ] ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT p [ i ] = 86401 * pow ( 3 , i ) NEW_LINE DEDENT p . sort ( ) NEW_LINE s = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT s += p [ i ] * p [ i + 1 ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
MAX = 100000 NEW_LINE def print ( g1 , a , g2 , b ) : NEW_LINE INDENT for i in range ( a ) : NEW_LINE INDENT print ( g1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( "
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] - a [ j ] >= 0 and a [ i ] - a [ j ] >= 0 : NEW_LINE INDENT ans = max ( ans , ( a [ i ] - a [ j ] ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def maxSubseq ( vec , n ) : NEW_LINE INDENT suffix = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( vec [ i ] == 1 ) : NEW_LINE INDENT suffix += 1 NEW_LINE vec [ i ] = suffix NEW_LINE DEDENT DEDENT res = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vec [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( vec [ i ] > 0 ) : NEW_LINE INDENT res = max ( res , zero + vec [ i ] ) NEW_LINE DEDENT DEDENT return max ( res , zero ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = [ 0 , 1 , 0 , 0 , 1 , 0 ] NEW_LINE n = len ( input ) NEW_LINE print ( maxSubseq ( input , n ) ) NEW_LINE DEDENT
R = 4 NEW_LINE C = 4 NEW_LINE def countPaths ( maze ) : NEW_LINE INDENT if ( maze [ 0 ] [ 0 ] == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT if ( maze [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in
import math NEW_LINE def isPrime ( N ) : NEW_LINE INDENT isPrime = True NEW_LINE arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] NEW_LINE if ( N < 2 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT if ( N % 2 == 0 or N % 3 == 0 or N % 5 == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT for i in range ( int ( math . sqrt ( N ) ) + 1 , 30 ) : NEW_LINE INDENT for c in arr : NEW_LINE INDENT if ( c > math . sqrt ( N ) ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if ( N % ( c + i ) == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( not isPrime ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( isPrime ) : NEW_LINE INDENT print ( " Prime ▁ Number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Prime
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x3 , y3 = map ( int , input ( ) . split ( ) ) NEW_LINE x1 , y1 , x2 , y2 = x2 , y2 , x3 , y3 NEW_LINE print ( x1 , y1 , x2 , y2 ) NEW_LINE
def lps ( seq , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] and i + 1 == j ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT return lps ( seq , i + 1 , j - 1 ) + 2 NEW_LINE DEDENT return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d " , lps ( seq , n - 1 ) ) NEW_LINE DEDENT
def findLength ( str , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT l = i NEW_LINE r = i + 1 NEW_LINE lsum = 0 NEW_LINE rsum = 0 NEW_LINE while r < n and l >= 0 : NEW_LINE INDENT lsum += ord ( str [ l ] ) - ord ( '0' ) NEW_LINE rsum += ord ( str [ r ] ) - ord ( '0' ) NEW_LINE if lsum == rsum : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "123123" NEW_LINE print ( " Length ▁ of ▁ the ▁ substring ▁ is " , findLength ( str , len ( str ) ) ) NEW_LINE DEDENT
def print ( a , n , ind ) : NEW_LINE INDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( a [ i % n ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = 6 NEW_LINE print ( a , n , 3 ) NEW_LINE
def print ( a , n , ind ) : NEW_LINE INDENT b = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = b [ i ] + a [ i ] NEW_LINE DEDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = 6 NEW_LINE print ( a , n , 3 ) NEW_LINE
n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' * ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' * ' : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT DEDENT if ( a == b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( ans == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( ans == n - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
n , id = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT b . append ( int ( input ( ) ) ) NEW_LINE DEDENT b . reverse ( ) NEW_LINE for i in b : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE
v1 , v2 , t = map ( int , input ( ) . split ( ) ) NEW_LINE ans = - 1 NEW_LINE if ( t == 2 ) : NEW_LINE INDENT ans = v1 + v2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = v1 + v2 + t NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( s [ i ] ) NEW_LINE b . append ( s [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE ans = n - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] < b [ i ] : NEW_LINE INDENT ans = i + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE if ( m % 2 == 0 ) : NEW_LINE INDENT print ( ( m // 2 + 1 ) * ( n // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( m // 2 + 1 ) * ( n // 2 ) + ( m % 2 ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) ; NEW_LINE DEDENT print ( n & 1 ) ; NEW_LINE DEDENT bin ( 131 ) ; NEW_LINE print ( " " ) ; NEW_LINE bin ( 3 ) ; NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1000 ) if i % 3 == 0 or i % 5 == 0 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' n ' : NEW_LINE INDENT ans . append ( i + 1 ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for i in ans : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT
r , g = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 2 * r - g ) NEW_LINE
def Circular ( n ) : NEW_LINE INDENT Result = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT Result = Result * n NEW_LINE n -= 1 NEW_LINE DEDENT return Result NEW_LINE DEDENT n = 4 NEW_LINE print ( Circular ( n - 1 ) ) NEW_LINE
def productDiagonals ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] [ i ] NEW_LINE product = product * arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT product = product / arr [ n // 2 ] [ n // 2 ] NEW_LINE DEDENT return product NEW_LINE DEDENT arr1 = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 7 , 4 , 2 ] , [ 2 , 2 , 1 , 2 ] ] NEW_LINE print ( productDiagonals ( arr1 , 4 ) , " \n " ) NEW_LINE arr2 = [ [ 2 , 1 , 2 , 1 , 2 ] , [ 1 , 2 , 1 , 2 ] , [ 2 , 1 , 2 , 1 ] ] NEW_LINE print ( productDiagon
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE while True : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT break NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE count += 1 NEW_LINE continue NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE count += 1 NEW_LINE continue NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE continue NEW_LINE DEDENT
NO_OF_CHARS = 256 NEW_LINE def getSecondMostFreq ( str ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] > count [ first ] ) : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return chr ( chr ( ord ( ' ' ) + 1 ) + chr ( ord ( ' ' ) + ord ( ' ' ) ) ) NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE res = getSecondMostFreq ( str ) NEW_LINE if ( res != ' \ 0' ) : NEW
while True : NEW_LINE INDENT try : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT ret = 0 NEW_LINE for a in range ( 1000 ) : NEW_LINE INDENT for b in range ( 1000 ) : NEW_LINE INDENT for c in range ( 1000 ) : NEW_LINE INDENT if a + b + c == n : NEW_LINE INDENT ret += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ret ) NEW_LINE DEDENT
def mySort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr = arr [ : n // 2 ] NEW_LINE arr . sort ( ) NEW_LINE arr . reverse ( ) NEW_LINE return arr NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE arr = arr [ n // 2 ] NEW_LINE arr . sort ( ) NEW_LINE print ( " Modified ▁ Array ▁ : ▁ " , arr ) NEW_LINE
def minflip ( arr1 , arr2 , arr3 , p , q , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] > 0 ^ arr2 [ i ] > 0 ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT return ( flip <= p + q ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr1 = [ 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 0 , 1 , 1 , 1 , 1 , 0 , 0 ] NEW_LINE arr3 = [ 1 , 1 , 1 , 1 , 1 , 0 , 0 ] NEW_LINE n = len ( arr1 ) NEW_LINE p = 2 NEW_LINE q = 4 NEW_LINE print ( minflip ( arr1 , arr2 , arr3 , p , q , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i NEW_LINE DEDENT return s NEW_LINE DEDENT n = 5 NEW_LINE print ( " Sum ▁ is " , sum ( n ) ) NEW_LINE
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] ; NEW_LINE oddArr = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 1 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT evenArr . sort ( ) ; NEW_LINE evenArr . sort ( reverse = True ) ; NEW_LINE i = 0 ; NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE right = 0 ; NEW_LINE left = 0 ; NEW_LINE visited = [ False ] * n ; NEW_LINE while ( right < n ) : NEW_LINE INDENT while ( right < n and visited [ arr [ right ] ] ) : NEW_LINE INDENT count += ( right - left ) ; NEW_LINE visited [ arr [ right ] ] = True ; NEW_LINE right += 1 ; NEW_LINE DEDENT while ( left < right and ( right != n and visited [ arr [ left ] ] ) ) : NEW_LINE INDENT visited [ arr [ left ] ] = False ; NEW_LINE left += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPairs ( arr , n ) ) ; NEW_LINE DEDENT
class TreeNode : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . val = rootData NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def isSubtree ( self , s , t ) : NEW_LINE INDENT global self . val , self . left = self . right = s NEW_LINE self . left = self . right = t NEW_LINE self . left . left = self . left NEW_LINE self . right = self . right NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE root = TreeNode ( 3 ) NEW_LINE root . left = TreeNode ( 4 ) NEW_LINE root .
M = 1001 NEW_LINE MOD = 998244353 NEW_LINE dp = [ [ [ 0 for i in range ( M ) ] for j in range ( M ) ] for k in range ( M ) ] NEW_LINE def solve ( idx , diff , N , M , K ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT if ( diff == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ diff ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ diff ] NEW_LINE DEDENT ans = solve ( idx + 1 , diff , N , M , K ) NEW_LINE ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) NEW_LINE return dp [ idx ] [ diff ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE K = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT dp [ i ]
import math NEW_LINE def compute ( ) : NEW_LINE INDENT TrieNode = lambda : sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE return ( float ( TrieNode ( ) ) ( TrieNode ( ) ( ) ( ) ( TrieNode ( ) ( ) ( ) ( ) ( TrieNode ( ) (
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ x , y ] NEW_LINE b = [ x , y ] NEW_LINE c = [ x , y ] NEW_LINE d = [ x , y ] NEW_LINE e = [ x , y ] NEW_LINE if ( a [ 0 ] ** 2 + b [ 0 ] ** 2 + c [ 0 ] ** 2 + d [ 0 ] ** 2 + e [ 1 ] ** 2 ) ** ( 1 / 2 ) NEW_LINE elif ( a [ 1 ] ** 2 + b [ 1 ] ** 2 + c [ 1 ] ** 2 + d [ 1 ] ** 2 + e [ 0 ] ** 2 ) ** ( 1 / 2 ) NEW_LINE elif ( a [ 1 ] ** 2 + b [ 1 ] ** 2 + d [ 1 ] ** 2 + e [ 0 ] ** 2 ) ** ( 1 / 2 )
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res ^= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE
l , p , q = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( p * l ) / ( p + q ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( abs ( a [ n - 1 ] - a [ n - 2 ] ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] > 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif l [ i ] == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s
a = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE w = [ 0 ] * a NEW_LINE for i in range ( a ) : NEW_LINE INDENT w [ i ] += s [ i ] NEW_LINE DEDENT w . sort ( ) NEW_LINE ans = w [ - 1 ] + w [ - 2 ] NEW_LINE print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE if ( arr [ n ] % 2 == 0 ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ n ] % 2 ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def prime ( num ) : NEW_LINE INDENT b = num NEW_LINE for i in range ( 2 , num ) : NEW_LINE INDENT if i * i > num : NEW_LINE INDENT break NEW_LINE DEDENT if b % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def modInverse ( a , p ) : NEW_LINE INDENT return pow ( a , p - 2 , p ) NEW_LINE DEDENT def nCr ( n , r , p = 10 ** 9 + 7 ) : NEW_LINE INDENT x = 1 NEW_LINE for i in range ( r ) : NEW_LINE INDENT x = ( x * ( n - i ) ) % p NEW_LINE DEDENT d = 1 NEW_LINE for i in range ( r ) : NEW_LINE INDENT d = ( d * ( n - i ) ) % p NEW_LINE DEDENT r = x * ( n - r ) % p NEW_LINE return r NEW_LINE DEDENT def nHr ( n , r ,
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( 2 )
def powerOfTwo ( n ) : NEW_LINE INDENT return ( ( n & n - 1 ) == 0 ) NEW_LINE DEDENT def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return powerOfTwo ( n - 1 ) NEW_LINE DEDENT n = int ( "9" ) NEW_LINE if ( onlyFirstAndLastAreSet ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( reverse = False ) NEW_LINE Y . sort ( reverse = False ) NEW_LINE hzntl = 1 NEW_LINE hzntl = 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE hzntl += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i +=
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT count = 0 NEW_LINE p = G * L NEW_LINE for a in range ( 1 , L + 1 ) : NEW_LINE INDENT if ( ( p % a == 0 ) and gcd ( a , p // a ) == G ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT G = 2 ; NEW_LINE L = 12 ; NEW_LINE print ( " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ " , G ) ; NEW_LINE print ( " ▁ & ▁ LCM ▁ " , L ) ; NEW_LINE print ( " ▁ & ▁ LMI ▁ " , L ) ; NEW_LINE
def multiply ( a , b ) : NEW_LINE INDENT mul = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] = 0 NEW_LINE for k in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] NEW_LINE DEDENT DEDENT DED
def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT temp = x ; NEW_LINE x = y ; NEW_LINE y = temp ; NEW_LINE DEDENT a = 1 ; NEW_LINE b = x - 1 ; NEW_LINE c = y - b ; NEW_LINE print ( a , " ▁ " , b , " ▁ " , c ) ; NEW_LINE DEDENT x = 123 ; y = 13 ; NEW_LINE MinimumValue ( x , y ) ; NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def checkPossibility ( self , nums ) : NEW_LINE INDENT brokenPoint = 0 NEW_LINE for i in range ( 0 , len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] > nums [ i + 1 ] : NEW_LINE INDENT brokenPoint += 1 NEW_LINE if ( brokenPoint >= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] ) : NEW_LINE INDENT nums [ i ] = nums [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i + 1 ] = nums [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 4 , 2 , 3 ] NEW_LINE out = sObj . checkPossibility ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def check ( mid , array , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( array [ i ] > mid ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += array [ i ] NEW_LINE if ( sum > mid ) : NEW_LINE INDENT count += 1 NEW_LINE sum = array [ i ] NEW_LINE DEDENT DEDENT count += 1 NEW_LINE if ( count <= K ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def solve ( array , n , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT end += array [ i ] NEW_LINE DEDENT answer = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( check ( mid , array , n , K ) ) : NEW_LINE INDENT answer = mid NEW_
while True : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : break NEW_LINE m **= n NEW_LINE print ( min ( max ( 0 , m - 1 ) , min ( max ( 0 , n - 1 ) ) , max ( m , n - 1 ) ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( a + b , a * b ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def even_or_odd ( N ) : NEW_LINE INDENT len = len ( N ) NEW_LINE if ( N [ len - 1 ] == '0' or N [ len - 1 ] == '2' or N [ len - 1 ] == '4' or N [ len - 1 ] == '6' ) : NEW_LINE INDENT return ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Odd " ) NEW_LINE DEDENT DEDENT N = "735" NEW_LINE print ( even_or_odd ( N ) ) NEW_LINE
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT op , x = map ( int , input ( ) . split ( ) ) NEW_LINE if op == 0 : print ( x ) NEW_LINE else : print ( * v [ x ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 0 ] % 2 == 0 : NEW_LINE INDENT print ( a [ 1 ] // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 1 ] // 2 + 1 ) NEW_LINE DEDENT
def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * N ; NEW_LINE sol = 0 ; NEW_LINE count [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + abs ( X [ i - 1 ] - Y [ i - 1 ] ) ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT sol = max ( sol , i - j ) ; NEW_LINE DEDENT return sol ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 ; NEW_LINE X = " abcd " ; NEW_LINE K = 3 ; NEW_LINE print ( solve ( X , Y , N , K ) ) ; NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a == 0 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def isPrime ( n , i ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT n = 15 NEW_LINE if ( isPrime ( n , 2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minimumSum ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT n = 27 NEW_LINE print ( minimumSum ( n ) ) NEW_LINE
def isPrime ( x ) : NEW_LINE INDENT for i in range ( 2 , int ( x ** .5 ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def minimumCost ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n % 2 == 1 and isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT return 3 ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( minimumCost ( n ) ) ; NEW_LINE
def snoob ( x ) : NEW_LINE INDENT rightOne , nextHigherOneBit , rightOnesPattern , next = 0 , 0 , 0 , 0 NEW_LINE if ( x > 0 ) : NEW_LINE INDENT rightOne = x & - x NEW_LINE nextHigherOneBit = x + rightOne NEW_LINE rightOnesPattern = x ^ nextHigherOneBit NEW_LINE rightOnesPattern = ( rightOnesPattern ) // rightOneBit NEW_LINE rightOnesPattern >> 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT x = 156 NEW_LINE print ( " Next ▁ higher ▁ number ▁ with ▁ same ▁ number ▁ of ▁ set ▁ bits ▁ is ▁ " , snoob ( x ) ) NEW_LINE
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i / j == j ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i // j NEW_LINE DEDENT DEDENT DEDENT sum = sum - i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE
def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE result = float ( " inf " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinLength ( arr , n ) ) NEW_LINE
import math NEW_LINE def getLevenstein ( input ) : NEW_LINE INDENT revInput = input ; NEW_LINE revInput = revInput . reverse ( ) ; NEW_LINE n = len ( input ) ; NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i ; NEW_LINE dp [ i ] [ 0 ] = i ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j
import sys NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 12000 NEW_LINE minSumProduct = [ 0 ] * LIMIT NEW_LINE for i in range ( 2 , LIMIT * 2 + 1 ) : NEW_LINE INDENT factorize ( i , i , i * 0 , 0 ) NEW_LINE DEDENT items = dict ( ) NEW_LINE for n in items : NEW_LINE INDENT sum = n NEW_LINE for i in n : NEW_LINE INDENT sum += n - i NEW_LINE DEDENT if n > sum : NEW_LINE INDENT return str ( sum ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DED
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans *= a [ i ] NEW_LINE ans %= 1000000007 NEW_LINE DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE def printe ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT l1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l3 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = [ ] NEW_LINE i = 0 NEW_LINE k = 0 NEW_LINE while i < l1 [ 0 ] : NEW_LINE INDENT if l [ i ] > l1 [ 1 ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if k == l [ 0 ] : NEW_LINE INDENT printe ( " Solve " ) NEW_LINE DEDENT else : NEW_LINE INDENT printe ( " Ashish " ) NEW_LINE DEDENT DEDENT if __name__ == "
MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findDiff ( arr , n ) : NEW_LINE INDENT min = MAX + 2 NEW_LINE max = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ]
while 1 : NEW_LINE INDENT a , b , c = map ( int , input ( )
n = int ( input ( ) ) NEW_LINE s = ' ' NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s += str ( i ) NEW_LINE DEDENT print ( s ) NEW_LINE
def distinctSubString ( P , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = [ ] NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE if ( freq [ pos ] == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT freq [ pos ] = True NEW_LINE s += P [ j ] NEW_LINE S . add ( s ) NEW_LINE DEDENT DEDENT return len ( S ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = " abba " NEW_LINE N = len ( S ) NEW_LINE print ( distinctSubString ( S , N ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( n - k ) % ( k - 1 ) == 0 : NEW_LINE INDENT print ( n - k ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - k ) // ( k - 1 ) + 1 ) NEW_LINE DEDENT
def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = - sys . maxsize ; NEW_LINE for i in range ( ( 1 << n ) ) : NEW_LINE INDENT cnt = bin ( i ) . count ( '1' ) ; NEW_LINE if ( cnt == n - k ) : NEW_LINE INDENT temp = [ ] ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) ) : NEW_LINE INDENT temp . append ( a [ j ] ) ; NEW_LINE DEDENT DEDENT maxDiff = sys . maxsize ; NEW_LINE for j in range ( len ( temp ) - 1 ) : NEW_LINE INDENT maxDiff = max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ; NEW_LINE DEDENT minDiff = min ( minDiff , maxDiff ) ; NEW_LINE DEDENT DEDENT return minDiff ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ;
def difference ( arr , n ) : NEW_LINE INDENT largest = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( largest < arr [ i ] ) : NEW_LINE INDENT largest = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = largest - arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 10 , 5 , 9 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE difference ( arr , n ) NEW_LINE
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ A [ i ] % K ] += 1 NEW_LINE DEDENT sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) // 2 NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT sum += freq [ i ] * freq [ K - i ] NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT sum += ( freq [ K // 2 ] * ( freq [ K // 2 ] - 1 ) // 2 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = len ( A ) NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE
while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == "0" : NEW_LINE INDENT break NEW_LINE DEDENT print ( s . rstrip ( ) ) NEW_LINE D
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in arr : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_prev_zero NEW_LINE prev_prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Index ▁ of ▁ 0 ▁ to ▁
def minimumX ( n , k ) : NEW_LINE INDENT ans = float ( " inf " ) NEW_LINE for rem in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if n % rem == 0 : NEW_LINE INDENT ans = min ( ans , rem + ( n // rem ) * k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 4 NEW_LINE k = 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n = 5 NEW_LINE k = 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE
moduloMultiplication ( a , b , mod ) = 0 ; NEW_LINE a %= mod ; NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( ( b & 1 ) > 0 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( 2 * a ) % mod ; NEW_LINE b >>= 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10123465234878998L ; NEW_LINE b = 657463115456431 ; NEW_LINE m = 10005412336548794L ; NEW_LINE print ( moduloMultiplication ( a , b , m ) ) ; NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a , b , c = [ 0 ] * n , 0 , 0 NEW_LINE for c in input ( ) . split ( ) : a
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < 0 : NEW_LINE INDENT a [ i ] = a [ i ] * - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( a [ n - 1 ] ) NEW_LINE
def checkPalindrome ( string ) : NEW_LINE INDENT length = len ( string ) NEW_LINE length = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] != string [ length ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT length -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def printSolution ( partitions ) : NEW_LINE INDENT for i in partitions : NEW_LINE INDENT for j in i
r , c , a1 , a2 , r1 , r2 = map ( int , input ( ) . split ( ) ) NEW_LINE k = abs ( a1 - a2 ) NEW_LINE if k > r1 + r2 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( k // 2 + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k // 2 ) NEW_LINE DEDENT DEDENT
def findSubsequence ( arr , n , k ) : NEW_LINE INDENT M = dict ( ) NEW_LINE for i in range ( n ) :
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] % 2 == 1 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , odd2 ) + min ( even1 , even2 ) NEW_LINE return pairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] % 2 == 1 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , even2 ) + min ( odd2 , even1 ) NEW_LINE return pairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_
def maxDiff ( arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE min_element = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] - min_element > max_diff ) : NEW_LINE INDENT max_diff = arr [ i ] - min_element NEW_LINE DEDENT if ( arr [ i ] < min_element ) : NEW_LINE INDENT min_element = arr [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 80 , 100 ] NEW_LINE size = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , size ) ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def findMax ( n ) : NEW_LINE INDENT return binomialCoeff ( n , n // 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( findMax ( n ) ) NEW_LINE
MAX = 26 NEW_LINE def minimumExpansion ( string , length ) : NEW_LINE INDENT freq = [ 0 ] * MAX NEW_LINE for i in range ( length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max_element ( freq ) NEW_LINE minExpansion = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT minExpansion += abs ( maxFreq - freq [ i ] ) NEW_LINE DEDENT DEDENT return minExpansion NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE length = len ( string ) NEW_LINE print ( minimumExpansion ( string , length ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = s . count ( ' a ' ) NEW_LINE b = s . count ( ' b ' ) NEW_LINE c = s . count ( ' c ' ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] - b [ i ] NEW_LINE DEDENT if ( a > 0 and b > 0 and c > 0 ) : NEW_LINE INDENT sum += 10 - abs ( a - b [ i ] ) NEW_LINE DEDENT elif ( a < 0 and b < 0 and c < 0 ) : NEW_LINE INDENT sum += 10 - abs ( a - c [ i ] ) NEW_LINE DEDENT elif ( b < 0 and c == 0 ) : NEW_LINE INDENT sum += 10 - abs ( b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += a [ i ] - c [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE
MAX = 32 NEW_LINE pow2 = [ 1 ] * MAX NEW_LINE visited = [ False ] * MAX NEW_LINE ans = [ ] NEW_LINE def power_2 ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT pow2 [ i ] = ans NEW_LINE ans *= 2 NEW_LINE DEDENT DEDENT def countSetBits ( x ) : NEW_LINE INDENT setBits = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x & (
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( eulerlib . prime_generator ( range ( 1000 ) , i ) for i in range ( - 1000 , - 1 , - 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n > k : NEW_LINE INDENT print ( ( k * ( n - 1 ) ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( k * ( n - 1 ) ) // 2 + 1 ) NEW_LINE DEDENT DEDENT
MAX = 100001 ; NEW_LINE def isPrime ( a ) : NEW_LINE INDENT cnt1 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if
n , r , t = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = [ 0 ] * ( r + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ p [ i ] ] += 1 NEW_LINE DEDENT s . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT if s [ i ] < s [ i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ " H " , " O " , " N " , " o " , " p " , " q " , " r " , " s " , " t " , " u " , " v " , " w " , " x " , " y " , " z " ] NEW_LINE for i in a : NEW_LINE INDENT if i in s : NEW_LINE INDENT print ( " Yes " ) NEW_LINE exit ( ) NEW_LINE DEDENT a [ i ] = s [ i ] NEW_LINE DEDENT print ( " No " ) NEW_LINE
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high - low ) // 2 NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( arr [ high ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return ( mid ) NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , 0 , n - 1 ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k - n >= 0 : NEW_LINE INDENT print ( n - k ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DP = [ 0 for i in range ( m ) ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DP [ i ] = False ; NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp = [ ( j + arr [ i ] ) % m ] ; NEW_LINE DP [ ( j + arr [ i ] ) % m ] = True ; NEW_LINE DEDENT DP [ j ] = True ; NEW_LINE DEDENT DP [
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT b , e , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a [ b : e ] + e - k ) NEW_LINE DEDENT
n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == x : NEW_LINE INDENT ans += ( a [ i ] [ j ] - x ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
for e in iter ( input , '0 ▁ 0' ) : NEW_LINE INDENT d , w = map ( int , e . split ( )
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( a [ 0 ] , n - ( a [ 0 ] * k ) ) ) NEW_LINE DEDENT
def sum ( k , n ) : NEW_LINE INDENT sum = ( k ** n + 1 ) - ( k - 1 ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( sum ( K , n ) ) NEW_LINE DEDENT
dp = [ [ [ 0 for i in range ( 18 ) ] for j in range ( 2 ) ] for k in range ( 16 ) ] NEW_LINE def solve ( i , tight , sum_so_far , Sum , number , len ) : NEW_LINE INDENT if ( i == len ) : NEW_LINE INDENT if ( Sum ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = dp [ i ] [ 1 ] [ Sum ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = 0 NEW_LINE ntight = len
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def evenOddLevelDifference ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE level = 0 NEW_LINE evenSum = 0 NEW_LINE oddSum = 0 NEW_LINE while ( q ) : NEW_LINE INDENT size = q [ 0 ] NEW_LINE level += 1 NEW_LINE while ( size > 0 ) : NEW_LINE INDENT size = size NEW_LINE oddSum += q [ 0 ] NEW_LINE DEDENT DEDENT return oddSum - evenSum NEW_LINE DED
def countSubarrays ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE number = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number += ( count ) * ( count + 1 ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count != 0 ) : NEW_LINE INDENT number += ( count * ( count + 1 ) // 2 ) NEW_LINE DEDENT return number NEW_LINE DEDENT a = [ 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 ] NEW_LINE n = len ( a ) NEW_LINE k = 5 NEW_LINE print ( countSubarrays ( a , n , k ) ) NEW_LINE
def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE
def printLastOccurrence ( a , n ) : NEW_LINE INDENT map = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] += 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] == i ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT a = [ 1 , 5 , 5 , 1 , 6 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE printLastOccurrence ( a , n ) ; NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT arr = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = 1 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def countPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = [ 1 , 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( g [ 0 ] ) NEW_LINE DEDENT
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; NEW_LINE return sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 20 ; NEW_LINE a = 2.5 ; NEW_LINE print ( sumOfAP ( a , d , n ) ) ; NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE
def coordinateCompression ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in arr : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = BIT [ i ] NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ' YES ' if l . count ( '1
import eulerlib NEW_LINE BASE = 10 NEW_LINE INDENT DIGITS = 20 NEW_LINE INDENT return eulerlib . compute ( BASE , DIGITS ) NEW_LINE DEDENT BASE = 3 NEW_LINE INDENTENT INDENT @ eulerlib . compute ( BASE , DIGITS ) NEW_LINE DEDENT INDENT return str ( BASE ) NEW_LINE DEDENT def digitsum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT sum += BASE [ i ] [ : : - 1 ] NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT def digitsum ( n ) : NEW
s , p , t = input ( ) , input ( ) , input ( ) , " YES " NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if s [ i ] == s [ p - 1 ] and s [ i + 1 ] == t : NEW_LINE INDENT print ( " YES " ) NEW_LINE exit ( ) NEW_LINE DEDENT p = p + 1 NEW_LINE DEDENT print ( "
class Solution ( object ) : NEW_LINE INDENT def isToeplitzMatrix ( self , matrix ) : NEW_LINE INDENT for r in range ( 1 , len ( matrix ) ) : NEW_LINE INDENT if matrix [ r - 1 ] [ c - 1 ] != matrix [ r ] [ c ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE matrix = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 1 , 2 , 3 ] , [ 9 , 5 , 1 , 2 ] ] NEW_LINE out = sObj . isToeplitzMatrix ( matrix ) NEW_LINE print ( out ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE ans = 0 NEW_LINE for s in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT for t in range ( s - 2 , 0 , - 2 ) : NEW_LINE INDENT if eulerlib . gcd ( s , t ) == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * s - t * t ) // 2 NEW_LINE c = ( s * s + t * t ) // 2 NEW_LINE if a * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT if a * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT if b * 2
while 1 : NEW_LINE INDENT n , t , l , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and t == 0 and l == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( ( 1.0 * ( l / n ) + ( 1 - l / n ) * ( 1 -
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = 0 NEW_LINE DEDENT DEDENT if a [ 0 ] % 2 == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def minCreateions ( H , n , K ) : NEW_LINE INDENT inser = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT inser += ceil ( diff / K ) - 1 NEW_LINE DEDENT DEDENT return inser NEW_LINE DEDENT H = [ 2 , 4 , 8 , 16 ] NEW_LINE K = 3 NEW_LINE n = len ( H ) NEW_LINE print ( minCreateions ( H , n , K ) ) NEW_LINE
def countWords ( str , l ) : NEW_LINE INDENT count = 1 NEW_LINE if ( l == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , l - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ l - 1 ] == str [ l - 2
n = int ( input ( ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT if ans % 2 == 1 : NEW_LINE INDENT print ( n - ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - ans ) NEW_LINE DEDENT
def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current = 1 NEW_LINE i = 1 NEW
import math NEW_LINE def findHypotenuse ( side1 , side2 ) : NEW_LINE INDENT h = math . sqrt ( ( side1 * side1 ) + ( side2 * side2 ) ) NEW_LINE return h NEW_LINE DEDENT side1 = 3 NEW_LINE side2 = 4 NEW_LINE print ( findHypotenuse ( side1 , side2 ) ) NEW_LINE
def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE set_bit_no = xor2 & ~ arr [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ arr [ 0 ] NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ ODD ▁ elements ▁ are " , x , " ▁ & ▁ " , y ) NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printTwoOdd ( arr , arr_size ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] < b [ i ] ) : NEW_LINE INDENT ans = max ( ans , i + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
s = input ( ) NEW_LINE a = s . count ( ' monday ' ) NEW_LINE b = s . count ( ' tuesday ' ) NEW_LINE c = s . count ( ' wednesday ' ) NEW_LINE if ( a < b < c ) : NEW_
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE oo = " " NEW_LINE oo = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' O ' and s [ i + 1 ] == ' O ' ) : NEW_LINE INDENT oo = oo + " + " NEW_LINE DEDENT if ( s [ i ] == ' O ' and s [ i + 2 ] == ' O ' ) : NEW_LINE INDENT oo = oo + " + " NEW_LINE DEDENT if ( s [ i ] == ' O ' and s [ i + 1 ] == ' O ' ) : NEW_LINE INDENT oo = oo + " + " NEW_LINE DEDENT DEDENT if ( oo == oo ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( s )
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_
def steps ( cur , x , n ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT return abs ( ( n - cur ) // x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( ( cur - 1 ) // x ) NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , actions ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__
x1 , x2 , x3 , x4 = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if x1 > x2 and x1 < x3 and x2 < x3 : NEW_LINE INDENT print ( x1 ) NEW_LINE DEDENT elif x1 < x2 and x2 < x3 : NEW_LINE INDENT print ( x2 ) NEW_LINE DEDENT elif x1 < x3 and x3 < x4 : NEW_LINE INDENT print ( x1 ) NEW_LINE DEDENT elif x1 > x2 and x3 < x4 : NEW_LINE INDENT print ( x3 ) NEW_LINE DEDENT elif x1 < x3 and x4 < x3 : NEW_LINE INDENT print ( x4 ) NEW_LINE DEDENT elif x1 == x3 and x4 == x2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif x1 < x3 and x4 < x3 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif x1 > x4 and x2 < x3 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif x
def cntSubArr ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_gcd = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ; NEW_LINE ans += ( curr_gcd == 1 ) : NEW_LINE INDENT if ( curr_gcd == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return __gcd ( b , a % b ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( cntSubArr ( arr , n ) ) ; NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isVowelPrime ( str , n ) : NEW_LINE INDENT prime = [ True ] * n NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( isVowel ( str [ i ] ) and not prime [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE D
def minStepToDeleteString ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( N + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ]
limit = 10000000 ; NEW_LINE position = [ 0 ] * limit + 1 ; NEW_LINE def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 ; NEW_LINE position [ 1 ] = - 1 ; NEW_LINE pos = 0 ; NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT position [ i ] = pos ; NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) ; NEW_LINE n = 11 ; NEW_LINE print ( position [ n ] ) ; NEW_LINE DEDENT
DP_s = 9 NEW_LINE def getNumMonotone ( len ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( DP_s ) ] for i in range ( DP_s ) ] NEW_LINE for i in range ( len ) : NEW_LINE INDENT DP [ i ] [ 0 ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , len ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ len - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT print ( getNumMonotone ( 10 ) ) NEW_LINE
DP_s = 9 NEW_LINE def getNumMonotone ( len ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( DP_s ) ] for i in range ( DP_s ) ] NEW_LINE for i in range ( len ) : NEW_LINE INDENT DP [ i ] [ 0 ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , len ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ len - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT print ( getNumMonotone ( 10 ) ) NEW_LINE
def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * mx + 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * mx + 1 NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 ,
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT r , c = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ input ( ) for i in range ( r ) ] NEW_LINE for i in range ( r ) : NEW_LINE INDENT if a [ i ] [ 0 ] == ' R ' : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
PI = PI NEW_LINE def findArea ( r ) : NEW_LINE INDENT return ( PI * pow ( r , 2 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( " Area ▁ is ▁ " , findArea ( 5 ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE adj = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT adj [ i ] . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT for i in adj [ k : ] : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) NEW_LINE DEDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) NEW_LINE DEDENT X = 35 NEW_LINE print ( getHeight ( X ) ) NEW_LINE
import sys NEW_LINE def Warshall_floyd ( edges , v ) : NEW_LINE INDENT for k in range ( v ) : NEW_LINE INDENT for i in range ( v ) : NEW_LINE INDENT for j in range ( v ) : NEW_LINE INDENT edges [ i ] [ j ] = min ( edges [ i ] [ j ] , edges [ i ] [ k ] + edges [ k ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 4 NEW_LINE v = 3 NEW_LINE k = 2 NEW_LINE edges = [ [ 0 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE edges [ 0 ] [ 0 ] , 0 , 0 , 0 , 1 ] NEW_LINE edges [ 1 ] [ 0 ] , 1 , 1 , 1 , 1 ] NEW_LINE edges [ 2 ] [ 0 ] , 2 , 1 , 1 , 1 , 1 ] NEW_LINE edges [ 3 ] [ 1 ] , 2 , 1 , 2 ,
def findDigits ( n , b ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) NEW_LINE return ( int ) ( floor ( x ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( findDigits ( 4 , 16 ) + " \n " ) NEW_LINE print ( findDigits ( 5 , 8 ) + " \n " ) NEW_LINE print ( findDigits ( 12 , 16 ) + " \n " ) NEW_LINE print ( findDigits ( 19 , 13 ) + " \n " ) NEW_LINE DEDENT
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] == 0 : NEW_LINE INDENT t += a [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT t += a [ j ] NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return ( 2 * n ) % 1000000007 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * n ) % 1000000007 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : break NEW_LINE c = 0 ; d = 0 NEW_LINE while b > 0 : NEW_LINE INDENT if b & 1 : d += 1 ; b -= 1 ; continue NEW_LINE c += a NEW_LINE DEDENT e = d * a NEW_LINE n = 100000 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i - d < e - i : break NEW_LINE e += b >> i * i NEW_LINE DEDENT print ( c + e - d ) NEW_LINE DEDENT
def s = " " ; NEW_LINE def ReverseString ( s ) : NEW_LINE INDENT arr = s . toCharArray ( ) ; NEW_LINE for i in range ( len ( arr ) // 2 ) : NEW_LINE INDENT temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ len ( arr ) - i - 1 ] ; NEW_LINE arr [ len ( arr ) - i - 1 ] = temp ; NEW_LINE DEDENT return arr ; NEW_LINE DEDENT def binary_conversion ( m ) : NEW_LINE INDENT while ( m != 0 ) : NEW_LINE INDENT tmp = m % 2 ; NEW_LINE s += str ( tmp ) ; NEW_LINE m = ( int ) ( m / 2 ) ; NEW_LINE DEDENT s = s ; NEW_LINE DEDENT m = 5 ; NEW
def countSubsets ( arr , n ) : NEW_LINE INDENT us = dict ( ) NEW_LINE even_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT us [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT even_count = len ( us ) NEW_LINE return ( pow ( 2 , even_count ) - 1 ) NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 9 , 2 , 6 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Number ▁ of ▁ subsets ▁ = ▁ " , countSubsets ( arr , n ) ) NEW_LINE
MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return ( f [ n ] = 1 ) NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = 0 NEW_LINE if ( ( n & 1 ) != 0 ) : NEW_LINE INDENT k = ( n + 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT if ( ( n & 1 ) != 0 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1
def findNumbers ( n , w ) : NEW_LINE INDENT x = 0 NEW_LINE sum = 0 NEW_LINE if ( w >= 0 and w <= 8 ) : NEW_LINE INDENT x = 9 - w NEW_LINE DEDENT elif ( w >= - 9 and w <= - 1 ) : NEW_LINE INDENT x = 10 + w NEW_LINE DEDENT sum = ( x * sum ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE w = 4 NEW_LINE print ( findNumbers ( n , w ) ) NEW_LINE DEDENT
def findKthChar ( s , k ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < l ) : NEW_LINE INDENT if ( s [ i ] not in l ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < l and s [ i ] not in l ) : NEW_LINE INDENT n = n * 10 + ( s [ i ] - '0' ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if ( k <= next_total_len ) : NEW_LINE INDENT pos = k % total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_
def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE return n * ( n + 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abcde " NEW_LINE print ( countNonEmptySubstr ( s ) ) NEW_LINE DEDENT
