import bisect NEW_LINE prime = [ 2 , 3 , 5 , 7 , 11 , 13 ] NEW_LINE shieve1 = [ 1 ] * 257 NEW_LINE for i in prime : NEW_LINE INDENT itr = i - 1 NEW_LINE while ( itr < 256 ) : NEW_LINE INDENT shieve1 [ itr ] = 0 NEW_LINE itr += i NEW_LINE DEDENT DEDENT for i in range ( 16 , 256 ) : NEW_LINE INDENT if shieve1 [ i ] : NEW_LINE INDENT prime . append ( i + 1 ) NEW_LINE DEDENT DEDENT shieve2 = [ 1 ] * ( 50101 ) NEW_LINE for i in prime : NEW_LINE INDENT itr = i - 1 NEW_LINE while ( itr < 50100 ) : NEW_LINE INDENT shieve2 [ itr ] = 0 NEW_LINE itr += i NEW_LINE DEDENT DEDENT for i in range ( 257 , 50101 ) : NEW_LINE INDENT if shieve2 [ i ] : NEW_LINE INDENT prime . append ( i + 1 ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def countFreq ( string , freq , length ) : NEW_LINE INDENT for i in range ( length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT def canMakePalindrome ( freq , length ) : NEW_LINE INDENT count_odd = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT if ( length % 2 == 0 ) : NEW_LINE INDENT if ( count_odd > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if ( count_odd != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def findOddAndRemoveItsFreq ( freq ) : NEW_LINE INDENT odd_str = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT freq [ i ] -= 1 NEW_LINE odd_str = odd_str + chr ( i + ord ( ' a ' ) ) NEW_LINE return odd_str NEW_LINE DEDENT DEDENT return odd_str NEW_LINE DEDENT def findPalindromicString ( string ) : NEW_LINE INDENT length = len ( string ) NEW_LINE freq = [ 0 ] * MAX_CHAR NEW_LINE countFreq ( string , freq , length ) NEW_LINE if ( not canMakePalindrome ( freq , length ) ) : NEW_LINE INDENT return " No Palindromic String " NEW_LINE DEDENT odd_str = findOddAndRemoveItsFreq ( freq ) NEW_LINE front_str = " " NEW_LINE rear_str = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT temp = " " NEW_LINE if ( freq [ i ] != 0 ) : NEW_LINE INDENT ch = chr ( i + ord ( ' a ' ) ) NEW_LINE for j in range ( 1 , freq [ i ] // 2 + 1 ) : NEW_LINE INDENT temp = temp + ch NEW_LINE DEDENT front_str = front_str +
import sys NEW_LINE class Segment ( object ) : NEW_LINE INDENT __slots__ = ( ' source ' , ' target ' ) NEW_LINE def __init__ ( self , source , target ) : NEW_LINE INDENT self . source = source NEW_LINE self . target = target NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT l1 , l2 , l3 , l4 = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE i = l1 . source NEW_LINE j = l2 . target NEW_LINE while i < l3 and j < l1 : NEW_LINE INDENT if i > j : NEW_LINE INDENT mid = i NEW_LINE DEDENT else : NEW_LINE INDENT mid = j NEW_LINE DEDENT s = ( mid * ( mid - i ) ) . source NEW_LINE if s > mid : NEW_LINE INDENT l3 = mid NEW_LINE DEDENT else : NEW_LINE INDENT l4 = mid NEW_LINE DEDENT DEDENT return l3 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT result = solve ( ) NEW_LINE print ( result ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 ] * 9 NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_sum = 0 NEW_LINE continuous_zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( number [ i ] ) == '0' ) : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += ( ( number [ i ] ) - '0' ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE DEDENT return result NEW_LINE DEDENT print ( count9s ( "01809" ) ) NEW_LINE print ( count9s ( "1809" ) ) NEW_LINE print ( count9s ( "4189" ) ) NEW_LINE
def fastPow ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = fastPow ( N , K // 2 ) NEW_LINE if ( K % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return N * temp * temp NEW_LINE DEDENT DEDENT def countWays ( N , K ) : NEW_LINE INDENT return K * fastPow ( K - 1 , N - 1 ) NEW_LINE DEDENT N = 3 NEW_LINE K = 3 NEW_LINE print ( countWays ( N , K ) ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE k = [ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE d = [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k [ i ] ^= d [ i ] NEW_LINE DEDENT for i in range ( 7 ) : NEW_LINE INDENT r = " " NEW_LINE for j in range ( n ) : NEW_LINE INDENT if k [ i ] == j : NEW_LINE INDENT r += str ( k [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT r += str ( k [ i ] ) + " " NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE DEDENT DEDENT
MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
from math import sqrt NEW_LINE MAX = 1000000 NEW_LINE arr = [ ] NEW_LINE prime = [ True ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p < MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if ( not prime [ n ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n or product - 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isPrimorialPrime ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def mul_table ( N , i ) : NEW_LINE INDENT if ( i > 10 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( N , " * " , i , " = " , N * i ) NEW_LINE mul_table ( N , i + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE mul_table ( N , 1 ) NEW_LINE DEDENT
def closestNumber ( n , m ) : NEW_LINE INDENT q = n // m NEW_LINE n1 = m * q NEW_LINE n2 = ( m * ( q + 1 ) ) if ( n * m ) > 0 else ( m * ( q - 1 ) ) NEW_LINE if ( abs ( n - n1 ) < abs ( n - n2 ) ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m = 13 , 4 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = - 15 NEW_LINE m = 6 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 0 NEW_LINE m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = - 7 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE DEDENT
def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) // 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE DEDENT
def compute_lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 ] * n NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ lps [ - 1 ] ] ) : NEW_LINE INDENT lps [ i ] = lps [ - 1 ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( lps [ i ] != 0 ) : NEW_LINE INDENT lps [ i ] = lps [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT def Longestsubstring ( s ) : NEW_LINE INDENT lps = compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if ( lps [ n - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( lps [ i ] == lps [ n - 1 ] ) : NEW_LINE INDENT print ( s [ 0 : lps [ i ] ] ) NEW_LINE return NEW_LINE DEDENT DEDENT if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 0 : lps [ lps [ n - 1 ] - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " fixprefix suffix " NEW_LINE Longestsubstring ( s ) NEW_LINE DEDENT
def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = 9999999999 NEW_LINE maxEle = - 9999999999 NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < minEle ) : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = True NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag1 = False NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = True NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag2 = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( minIndex == 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT if ( flag1 and flag2 and ( arr [ n - 1 ] < arr [ minIndex - 1 ] ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE DEDENT
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT while a [ i + 1 ] > a [ i ] : NEW_LINE INDENT if a [ i + 1 ] - a [ i ] == a [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += d NEW_LINE a [ i + 1 ] -= ( a [ i ] - a [ i ] ) // d * d NEW_LINE a [ i + 1 ] += ( a [ i ] - a [ i ] ) // d NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def checkIfPowerIsolated ( num ) : NEW_LINE INDENT input = num NEW_LINE count = 0 NEW_LINE factor = [ 0 ] * ( num + 1 ) NEW_LINE if ( num % 2 == 0 ) : NEW_LINE INDENT while ( num % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE num /= 2 NEW_LINE DEDENT factor [ 2 ] = count NEW_LINE DEDENT for i in range ( 3 , int ( num ** 0.5 ) + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE num /= i NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT factor [ i ] = count NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT factor [ num ] = 1 NEW_LINE DEDENT product = 1 NEW_LINE for i in range ( 0 , num + 1 ) : NEW_LINE INDENT if ( factor [ i ] > 0 ) : NEW_LINE INDENT product = product * factor [ i ] * i NEW_LINE DEDENT DEDENT if ( product == input ) : NEW_LINE INDENT print ( " Power - A Power - A " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not a Power - A " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT checkIfPowerIsolated ( 12 ) NEW_LINE checkIfPowerIsolated ( 18 ) NEW_LINE checkIfPowerIsolated ( 35 ) NEW_LINE DEDENT
import sys NEW_LINE s = input ( ) NEW_LINE f = True NEW_LINE for c in s : NEW_LINE INDENT if c == ' A ' or c == ' Z ' : NEW_LINE INDENT f = False NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT s = s [ 0 : : 2 ] NEW_LINE print ( ' AZ ' * f ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = dict ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in d : NEW_LINE INDENT ans = max ( ans , d [ a [ i ] ] + i + 1 ) NEW_LINE d [ a [ i ] ] = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ a [ i ] ] = i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if ( len1 == 0 or len2 == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 ] * ( len1 + len2 ) NEW_LINE i_n1 = 0 NEW_LINE i_n2 = 0 NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = ord ( num1 [ i ] ) - ord ( '0' ) NEW_LINE i_n2 = 0 NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = ord ( num2 [ j ] ) - ord ( '0' ) NEW_LINE sum = n1 * n2 + ( ord ( num2 [ j ] ) - ord ( '0' ) ) NEW_LINE carry = sum // 10 NEW_LINE result [ i_n1 + i_n2 ] = sum % 10 NEW_LINE i_n2 += 1 NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT result [ i_n1 + i_n2 ] += carry NEW_LINE DEDENT i_n1 += 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while ( i >= 0 and result [ i ] == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT s = " " NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT s += ( result [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = "123542144545454545454545454544" NEW_LINE str2 = "1746546546545454545454545454544" NEW_LINE if ( ( str1 [ 0 ] == ' - ' or str2 [ 0 ] == ' - ' ) and ( str1 [ 0 ] != ' - ' or str2 [ 0 ] != ' - ' ) ) : NEW_LINE INDENT print (
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = sum ( a ) NEW_LINE y = x NEW_LINE if y >= x : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( [ ' RIGHT ' , ' LEFT ' ] [ sorted ( s ) + k > n ] ) NEW_LINE
def printDistSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT dp = [ [ False for i in range ( n + 1 ) ] for i in range ( sum + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT for j in range ( 0 , sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == True ) : NEW_LINE INDENT print ( j , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printDistSum ( arr , n ) NEW_LINE DEDENT
def Subtract ( a , b ) : NEW_LINE INDENT c = a + ( ~ b + 1 ) NEW_LINE return c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE print ( Subtract ( a , b ) ) NEW_LINE a = 9 NEW_LINE b = 7 NEW_LINE print ( Subtract ( a , b ) ) NEW_LINE DEDENT
a = int ( input ( ) ) NEW_LINE if ( a ** 2 == 1 ) : NEW_LINE INDENT print ( ( a ** 2 - 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a ** 2 - 1 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE g = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT g [ a [ i ] ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT p = g [ a [ i ] ] NEW_LINE if ( p in g ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
def nextZero ( i , occurrences ) : NEW_LINE INDENT while i < len ( occurrences ) : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def get ModifiedString ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE if n > 26 : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT ch = list ( string ) NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = nextZero ( 0 , occurrences ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT occurrences [ ord ( ch [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE ch [ i ] = chr ( ord ( ' a ' ) + index ) NEW_LINE occurrences [ index ] = 1 NEW_LINE index = nextZero ( index + 1 , occurrences ) NEW_LINE DEDENT DEDENT return " " . join ( ch ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE print ( get T ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT h , m = map ( int , input ( ) . split ( ' : ' ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ' : ' ) ) ) NEW_LINE if h * m + m < h * m : NEW_LINE INDENT print ( 0 , 0 , 0 ) NEW_LINE DEDENT elif h * m + m < h * m : NEW_LINE INDENT while h < m : NEW_LINE INDENT if l [ h ] >= h : NEW_LINE INDENT l [ h ] -= 1 NEW_LINE h += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( h , m , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , 0 , 0 ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE cnt = [ 0 ] * 105 NEW_LINE for i in a : NEW_LINE INDENT cnt [ i ] += 1 NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT cnt [ i + 1 ] += cnt [ i ] NEW_LINE ans = max ( ans , ( cnt [ i + 1 ] + i - 1 ) // i ) NEW_LINE DEDENT print ( ans ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n & 1 : NEW_LINE INDENT print ( "1" + "0" * ( n - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "1" + "0" * ( n - 1 ) ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i * i > n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i * i == n ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i - 2 >= 0 and i * i > n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT b . append ( a [ b . index ( a [ i ] ) - 1 ] ) NEW_LINE DEDENT print ( * b ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE dp = [ 1 ] * ( n + 1 ) NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT dp [ i + 1 ] += dp [ i ] NEW_LINE dp [ i + 1 ] %= m NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i + 1 ] += dp [ i ] NEW_LINE dp [ i + 1 ] %= m NEW_LINE DEDENT print ( dp [ n ] ) NEW_LINE
def printMax ( arr , n , k ) : NEW_LINE INDENT Qi = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT while ( len ( Qi ) > 0 and arr [ i ] >= arr [ Qi [ - 1 ] ] ) : NEW_LINE INDENT Qi . pop ( ) NEW_LINE DEDENT Qi . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ Qi [ - 1 ] ] , end = " " ) NEW_LINE while ( len ( Qi ) > 0 and Qi [ - 1 ] <= i - k ) : NEW_LINE INDENT Qi . pop ( ) NEW_LINE DEDENT while ( len ( Qi ) > 0 and arr [ i ] >= arr [ Qi [ - 1 ] ] ) : NEW_LINE INDENT Qi . pop ( ) NEW_LINE DEDENT Qi . append ( i ) NEW_LINE DEDENT print ( arr [ Qi [ - 1 ] ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 12 , 1 , 78 , 90 , 57 , 89 , 56 ] NEW_LINE k = 3 NEW_LINE printMax ( arr , len ( arr ) , k ) NEW_LINE DEDENT
def russianP write ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( russianP write ( 18 , 1 ) ) NEW_LINE print ( russianP write ( 20 , 12 ) ) NEW_LINE DEDENT
def isValid ( string , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if ( string [ i ] == string [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "0110" NEW_LINE length = len ( string ) NEW_LINE if ( isValid ( string , length ) ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT DEDENT
def lehmann ( n , t ) : NEW_LINE INDENT rand = random . randint ( 1 , 9 ) NEW_LINE a = ( int ( rand . randint ( 1 , n - 3 ) + 2 ) ) % n NEW_LINE while ( t > 0 ) : NEW_LINE INDENT result = ( ( int ) ( pow ( a , e ) ) ) % n NEW_LINE if ( ( result % n ) == 1 or ( result % n ) == ( n - 1 ) ) : NEW_LINE INDENT a = ( int ) ( rand . randint ( 1 , n - 3 ) + 2 ) NEW_LINE t -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT n = 13 NEW_LINE t = 10 NEW_LINE if ( n == 2 ) : NEW_LINE INDENT print ( " 2 is Prime . " ) NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( n , " is Composite " ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = lehmann ( n , t ) NEW_LINE if ( flag == 1 ) : NEW_LINE INDENT print ( n , " w value be Prime . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " is Composite . " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if l [ 0 ] == l [ 1 ] == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT j = 0 NEW_LINE while j < l [ 0 ] : NEW_LINE INDENT c = ( l [ 0 ] - j ) // l [ 1 ] NEW_LINE r = l [ 1 ] - j NEW_LINE if r < c : NEW_LINE INDENT c = r NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT DEDENT
s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE if len ( s ) < k : NEW_LINE INDENT print ( " impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT s = s [ : k ] + s [ k + 1 : ] NEW_LINE print ( s . count ( str ( k ) ) ) NEW_LINE DEDENT
N = 3 NEW_LINE def MaxTraceSub ( mat ) : NEW_LINE INDENT max_ trace = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT r = i NEW_LINE s = j NEW_LINE trace = 0 NEW_LINE while ( r < N and s < N ) : NEW_LINE INDENT trace += mat [ r ] [ s ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE max_ trace = max ( trace , max_ trace ) NEW_LINE DEDENT DEDENT DEDENT return max_ trace NEW_LINE DEDENT mat = [ [ 10 , 2 , 5 ] , [ 6 , 10 , 4 ] , [ 2 , 7 , - 10 ] ] NEW_LINE print ( MaxTraceSub ( mat ) ) NEW_LINE
import sys NEW_LINE def angleis ( p1 , p2 ) : NEW_LINE INDENT return True if p1 [ 0 ] > p2 [ 0 ] or p1 [ 1 ] > p2 [ 1 ] else False NEW_LINE DEDENT Ps = sys . stdin . readlines ( ) NEW_LINE for P in Ps : NEW_LINE INDENT xa , ya , xb , yb , xb , yb = map ( int , P . split ( ) ) NEW_LINE p = [ xb , yb ] NEW_LINE a = [ xb , yb ] NEW_LINE b = [ xb , yb ] NEW_LINE c = [ xb , yb ] NEW_LINE d = [ xb , yb ] NEW_LINE if angleis ( a [ 0 ] , a [ 1 ] ) or angleis ( b [ 0 ] , b [ 1 ] ) or angleis ( c [ 0 ] , c [ 1 ] ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for x in a : NEW_LINE INDENT if x not in d : NEW_LINE INDENT d [ x ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ x ] += 1 NEW_LINE DEDENT DEDENT d = sorted ( d . items ( ) , key = lambda e : ( - e [ 1 ] , e [ 0 ] ) ) NEW_LINE for i in d : NEW_LINE INDENT if d [ i ] [ 1 ] % i [ 0 ] != 0 : NEW_LINE INDENT print ( i + 1 , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( ( divCount % 2 ) != 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE
from math import ceil NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE m -= 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += ceil ( l [ i ] / m ) NEW_LINE if c == m : NEW_LINE INDENT c = 0 NEW_LINE m -= 1 NEW_LINE DEDENT DEDENT print ( m + 1 ) NEW_LINE
def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def replaceArray ( N , arr ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ i ] NEW_LINE DEDENT arr [ i ] = abs ( diff ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 ] NEW_LINE replaceArray ( N , arr ) NEW_LINE printArray ( N , arr ) NEW_LINE N = 6 NEW_LINE arr1 = [ - 3 , - 4 , - 2 , 5 , 1 , - 2 ] NEW_LINE replaceArray ( N , arr1 ) NEW_LINE printArray ( N , arr1 ) NEW_LINE DEDENT
def printArray ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def replaceArray ( N , arr ) : NEW_LINE INDENT pos_sum , neg_sum , i , j , diff = 0 , 0 , 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ j ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ j ] NEW_LINE DEDENT DEDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE arr [ i ] = abs ( diff ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , - 1 , 2 , 3 , - 2 ] NEW_LINE replaceArray ( N , arr ) NEW_LINE printArray ( N , arr ) NEW_LINE N = 6 NEW_LINE arr1 = [ - 3 , - 4 , - 2 , 5 , 1 , - 2 ] NEW_LINE replaceArray ( N , arr1 ) NEW_LINE printArray ( N , arr1 ) NEW_LINE DEDENT
def countDivisbleby4 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT h = ( ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) ) NEW_LINE if ( h % 4 == 0 ) : NEW_LINE INDENT count = count + i + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "124" NEW_LINE print ( countDivisbleby4 ( s ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = l [ 0 ] NEW_LINE b = l [ 1 ] NEW_LINE c = l [ 2 ] NEW_LINE d = l [ 3 ] NEW_LINE if ( min ( a , b ) > c ) and ( min ( a , b ) > d ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = ( bin ( i ) [ 2 : ] ) . replace ( '1' , '0' ) NEW_LINE if len ( x ) == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = " yes " NEW_LINE pos = 0 NEW_LINE while pos != n - 1 : NEW_LINE INDENT if a [ pos ] > d : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = 0 NEW_LINE DEDENT if pos >= n - 1 : NEW_LINE INDENT ans = " no " NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT d , ins , maxDist , n = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE M = int ( sys . stdin . readline ( ) ) NEW_LINE A = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE dp = [ [ float ( ' inf ' ) ] * ( M + 1 ) for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , M + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] + solve ( ) ) NEW_LINE DEDENT DEDENT return dp [ M ] [ M ] NEW_LINE DEDENT def debug ( x , table ) : NEW_LINE INDENT for name , val in table . items ( ) : NEW_LINE INDENT if x is val : NEW_LINE INDENT print ( ' Case # % d : % s ' % ( name , val ) ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT print ( ' Case # % d : % s ' % ( i , solve ( ) ) ) NEW_LINE DEDENT DEDENT
def solve ( ) : NEW_LINE INDENT n = 12 NEW_LINE grid = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT grid [ i ] [ i ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT grid [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT DEDENT DEDENT print ( sum ( [ 1 if grid [ i ] [ j ] == 0 else 0 for i in range ( n ) for j in range ( n ) ] ) ) NEW_LINE DEDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arraySortedOrNot ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE res = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT res += abs ( arr [ j ] - arr [ 0 ] ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def printKDistinct ( arr , n , k ) : NEW_LINE INDENT h = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in h . keys ( ) : NEW_LINE INDENT h [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT h [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if len ( h ) < k : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if h [ arr [ i ] ] == 1 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if dist_count == k : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE print ( printKDistinct ( ar , n , 2 ) ) NEW_LINE DEDENT
def fib ( f ) : NEW_LINE INDENT f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , 59 + 1 ) : NEW_LINE INDENT f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 NEW_LINE DEDENT DEDENT def findLastDigit ( n ) : NEW_LINE INDENT f = [ 0 ] * 60 NEW_LINE f . append ( f [ 0 ] ) NEW_LINE index = ( n % 60 ) NEW_LINE return f [ index ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 61 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 7 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE n = 67 NEW_LINE print ( findLastDigit ( n ) ) NEW_LINE DEDENT
top , bottom , height = map ( int , input ( ) . split ( ) ) NEW_LINE if top == bottom and height == 7 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif top == 1 and height == 5 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif top == 2 and height == 5 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif top == 3 and height == 7 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n , z , w = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( abs ( a [ - 1 ] - w ) ) NEW_LINE exit ( ) NEW_LINE DEDENT print ( max ( abs ( a [ - 2 ] - a [ - 1 ] ) , abs ( a [ - 1 ] - a [ - 2 ] ) ) ) NEW_LINE
def countEleLessThanOrEqual ( arr1 , arr2 , m , n ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr2 [ j ] <= arr1 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " " ) NEW_LINE DEDENT return m NEW_LINE DEDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] NEW_LINE countEleLessThanOrEqual ( arr1 , arr2 , len ( arr1 ) , len ( arr2 ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( min ( arr ) ) NEW_LINE DEDENT elif k == 2 : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( arr [ 0 ] , arr [ 1 ] ) ) NEW_LINE DEDENT DEDENT elif k == 3 : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( arr [ 0 ] , arr [ 1 ] ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n > 2 : NEW_LINE INDENT arr = [ min ( arr ) , max ( arr [ : - 1 ] ) ] NEW_LINE if arr [ - 1 ] == arr [ - 2 ] : NEW_LINE INDENT arr . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . pop ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT arr = [ min ( arr ) , max ( arr [ : - 1 ] ) ] NEW_LINE if arr [ - 1 ] == arr [ - 2 ] : NEW_LINE INDENT arr . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . pop ( ) NEW_LINE DEDENT DEDENT print ( max ( arr ) ) NEW_LINE DEDENT
name = input ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT name1 , name2 = input ( ) . split ( ) NEW_LINE if name1 == name2 : NEW_LINE INDENT name = name NEW_LINE DEDENT elif name1 < name2 : NEW_LINE INDENT name1 , name2 = name2 , name1 NEW_LINE DEDENT print ( name1 , name2 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE n = n >> 1 NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( a [ n // 2 - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ n // 2 ] ) NEW_LINE DEDENT
k , p = map ( int , input ( ) . split ( ) ) NEW_LINE n = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT s = str ( i ) NEW_LINE n . append ( s [ 0 ] ) NEW_LINE if len ( s ) == 1 : NEW_LINE INDENT n [ - 1 ] += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE for i in n : NEW_LINE INDENT new = i + 1 NEW_LINE while len ( n ) > 1 and n [ - 1 ] >= i : NEW_LINE INDENT new *= 10 NEW_LINE new += n [ - 1 ] NEW_LINE n . pop ( - 1 ) NEW_LINE DEDENT total += new NEW_LINE DEDENT print ( total % p ) NEW_LINE
import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE p = [ int ( x ) - 1 for x in input ( ) . split ( ) ] NEW_LINE p_set = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT p_set . add ( i ) NEW_LINE DEDENT point = [ 0 ] * n NEW_LINE for i , v in enumerate ( p ) : NEW_LINE INDENT p_set . add ( v ) NEW_LINE t = bisect . bisect_left ( p_set , i ) NEW_LINE if t - 1 >= 0 : NEW_LINE INDENT point [ t - 1 ] += 1 NEW_LINE DEDENT DEDENT point_set = sorted ( point ) NEW_LINE result = 0 NEW_LINE for i , v in enumerate ( p_set ) : NEW_LINE INDENT index = bisect . bisect_left ( point , v ) NEW_LINE if index - 1 >= 0 : NEW_LINE INDENT result += ( point [ index - 1 ] - point [ i ] ) * ( i + 1 ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE
def lps ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( seq [ i ] == seq [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The length of the LPS is " , lps ( seq ) ) NEW_LINE
def printConsecutive ( last , first ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( " + " , x , end = " " ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( 0 , last ) : NEW_LINE INDENT if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif a >= b : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def NumberOfSquares ( x , y ) : NEW_LINE INDENT s = __gcd ( x , y ) NEW_LINE ans = ( x * y ) / ( s * s ) NEW_LINE return ans NEW_LINE DEDENT m = 385 NEW_LINE n = 60 NEW_LINE print ( NumberOfSquares ( m , n ) ) NEW_LINE
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = s [ i ] NEW_LINE DEDENT c . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabbbcc " NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printKMax ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE for j in range ( 1 , k ) : NEW_LINE INDENT if ( arr [ i + j ] > max ) : NEW_LINE INDENT max = arr [ i + j ] NEW_LINE DEDENT DEDENT print ( max , end = " " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE k = 3 NEW_LINE printKMax ( arr , len ( arr ) , k ) NEW_LINE
from collections import defaultdict NEW_LINE from itertools import permutations NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE G = defaultdict ( list ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE G [ a ] . append ( b ) NEW_LINE G [ b ] . append ( a ) NEW_LINE DEDENT res = 0 NEW_LINE visited = [ False ] * n NEW_LINE q = [ ] NEW_LINE heapify ( q ) NEW_LINE heappush ( q , ( 0 , 0 ) ) NEW_LINE while q : NEW_LINE INDENT c , v = heappop ( q ) NEW_LINE if visited [ v ] : NEW_LINE INDENT continue NEW_LINE DEDENT if not visited [ v ] : NEW_LINE INDENT continue NEW_LINE DEDENT l , r = heappop ( q ) NEW_LINE visited [ v ] = True NEW_LINE if not visited [ l ] : NEW_LINE INDENT heappush ( q , ( c + 1 , v + 1 ) ) NEW_LINE DEDENT if not visited [ r ] : NEW_LINE INDENT heappush ( q , ( l + 1 , r + 1 ) ) NEW_LINE DEDENT DEDENT res += ( n - len ( visited ) ) * ( n - len ( visited ) ) NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE l , r = 0 , k NEW_LINE while r - l > 1 : NEW_LINE INDENT m += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT if m > n : NEW_LINE INDENT r += 1 NEW_LINE DEDENT print ( c ) NEW_LINE
from sys import stdin NEW_LINE input = stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE xy = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE ans = float ( ' inf ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if xy [ i ] [ 0 ] > xy [ j ] [ 0 ] : NEW_LINE INDENT xy [ i ] [ 1 ] = xy [ j ] [ 1 ] NEW_LINE ans = min ( ans , ( xy [ i ] [ 0 ] - xy [ i ] [ 0 ] ) * ( xy [ i ] [ 1 ] - xy [ j ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ input ( ) for i in range ( n ) ] NEW_LINE b = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT k = a [ i ] NEW_LINE b [ k ] = j NEW_LINE DEDENT DEDENT c = sorted ( b ) NEW_LINE for i in c : NEW_LINE INDENT print ( b [ i ] , end = " " ) NEW_LINE DEDENT
def pre_ process ( substrings , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dup = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT dup += s [ j ] NEW_LINE substrings [ count ] = dup NEW_LINE count += 1 NEW_LINE DEDENT DEDENT size = len ( substrings ) NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( substrings ) ) : NEW_LINE INDENT if ( substrings [ i ] > substrings [ j ] ) : NEW_LINE INDENT temp = substrings [ i ] NEW_LINE substrings [ i ] = substrings [ j ] NEW_LINE substrings [ j ] = temp NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geek " NEW_LINE substrings = [ 1 , 5 , 10 ] NEW_LINE q = len ( substrings ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( substrings [ queries [ i ] - 1 ] ) NEW_LINE DEDENT DEDENT
def solve ( ) : NEW_LINE INDENT from sys import stdin NEW_LINE f_i = stdin NEW_LINE while True : NEW_LINE INDENT w , h = map ( int , f_i . readline ( ) . split ( ) ) NEW_LINE if w == 0 : NEW_LINE INDENT break NEW_LINE DEDENT pos = ( w , h ) NEW_LINE ans = [ ] NEW_LINE for _ in range ( h ) : NEW_LINE INDENT f , pos = f_i . readline ( ) . split ( ) NEW_LINE pos = ( int ( pos [ 0 ] ) , int ( pos [ 1 ] ) ) NEW_LINE if f == " S " : NEW_LINE INDENT ans . append ( ( pos [ 0 ] + 1 , pos [ 1 ] + 1 ) ) NEW_LINE DEDENT elif pos [ 0 ] == " R " : NEW_LINE INDENT pos [ 1 ] -= 1 NEW_LINE if pos [ 1 ] + 1 < h : NEW_LINE INDENT pos [ 1 ] = h - 1 NEW_LINE DEDENT DEDENT elif pos [ 0 ] == " L " : NEW_LINE INDENT pos [ 1 ] += 1 NEW_LINE if pos [ 1 ] - 1 < w : NEW_LINE INDENT pos [ 1 ] = w - 1 NEW_LINE DEDENT DEDENT elif pos [ 0 ] == " B " : NEW_LINE INDENT pos [ 1 ] -= 1 NEW_LINE if pos [ 1 ] + 1 < h : NEW_LINE INDENT pos [ 1 ] = h - 1 NEW_LINE DEDENT DEDENT DEDENT print ( * ans ) NEW_LINE DEDENT solve ( ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE a = s . count ( " o " ) NEW_LINE b = s . count ( " x " ) NEW_LINE if ( a >= 3 ) : NEW_LINE INDENT ans += ( a - 2 ) NEW_LINE a = s . count ( " x " ) NEW_LINE DEDENT elif ( b >= 3 ) : NEW_LINE INDENT ans += ( b - 2 ) NEW_LINE b = s . count ( " x " ) NEW_LINE DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == "0" : NEW_LINE INDENT break NEW_LINE DEDENT c = s . count ( " A " ) NEW_LINE d = s . count ( " B " ) NEW_LINE e = s . count ( " E " ) NEW_LINE f = s . count ( " F " ) NEW_LINE g = s . count ( " G " ) NEW_LINE h = s . count ( " H " ) NEW_LINE i = s . count ( " I " ) NEW_LINE if i == c : NEW_LINE INDENT if d > f : NEW_LINE INDENT f += 1 NEW_LINE DEDENT else : NEW_LINE INDENT f += 1 NEW_LINE DEDENT DEDENT elif i == c : NEW_LINE INDENT if d > g : NEW_LINE INDENT g += 1 NEW_LINE DEDENT else : NEW_LINE INDENT g += 1 NEW_LINE DEDENT DEDENT print ( f , g ) NEW_LINE DEDENT
def fact ( N ) : NEW_LINE INDENT i , product = 1 , 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT return product NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( N * N ) * fact ( N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT k , x = map ( int , input ( ) . split ( ) ) NEW_LINE if x < k : NEW_LINE INDENT print ( x * 9 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x * 9 - ( x - k ) ) NEW_LINE DEDENT DEDENT
def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( left , right , above , below ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L , B , X , Y = 8 , 8 , 0 NEW_LINE maximumArea ( L , B , X , Y ) NEW_LINE DEDENT
NO_OF_CHARS = 256 NEW_LINE def max_distinct_char ( string , n ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( string [ i ] ) ] += 1 NEW_LINE DEDENT max_distinct = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] ) : NEW_LINE INDENT max_distinct += 1 NEW_LINE DEDENT DEDENT return max_distinct NEW_LINE DEDENT def smallesteSubstr_maxDist k k k k1 = k2 = k1 + 1 NEW_LINE string = " AABBBCBB " NEW_LINE n = len ( string ) NEW_LINE max_distinct = max_distinct_char ( string , n ) NEW_LINE minl = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT subs = [ ] NEW_LINE if ( i < j ) : NEW_LINE INDENT subs = string [ i : j ] NEW_LINE DEDENT else : NEW_LINE INDENT subs = string [ j : i ] NEW_LINE DEDENT sub_distinct_char = max_distinct_char ( subs , sub_distinct_char ) NEW_LINE if ( sub_distinct_lenght < minl and max_distinct == sub_distinct_char ) : NEW_LINE INDENT minl = sub_distinct_lenght NEW_LINE DEDENT DEDENT DEDENT return minl NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " AABBBCBB " NEW_LINE n = smallesteSubstr_maxDist k1 NEW_LINE print ( " The length of the smallest substringu of maximum distinct characters : " , n ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE g = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == " R " or a [ i ] == " G " or b [ i ] == " B " or b [ i ] == " R " : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ans == n : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findNumberOfEvenCells ( n , q , size ) : NEW_LINE INDENT row = [ 0 ] * n NEW_LINE col = [ 0 ] * n NEW_LINE for i in range ( size ) : NEW_LINE INDENT x = q [ i ] [ 0 ] NEW_LINE y = q [ i ] [ 1 ] NEW_LINE row [ x - 1 ] += 1 NEW_LINE col [ y - 1 ] += 1 NEW_LINE DEDENT r1 , r2 , c1 , c2 = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( row [ i ] % 2 == 0 ) : NEW_LINE INDENT r1 += 1 NEW_LINE DEDENT if ( row [ i ] % 2 == 1 ) : NEW_LINE INDENT r2 += 1 NEW_LINE DEDENT if ( col [ i ] % 2 == 0 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( col [ i ] % 2 == 1 ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT count = r1 * c1 + r2 * c2 NEW_LINE return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE q = [ [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , 1 ] ] NEW_LINE size = len ( q ) NEW_LINE print ( findNumberOfEvenCells ( n , q , size ) ) NEW_LINE DEDENT
def checkType ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] <= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing " ) NEW_LINE DEDENT elif ( arr [ 0 ] >= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Decreasing " ) NEW_LINE DEDENT elif ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing then decreasing " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Decreasing then increasing " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE checkType ( arr , n ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 9999999999 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT ans = min ( ans , i + 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s = s [ 1 : ] + s [ 0 ] NEW_LINE ans = min ( ans , i + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import math NEW_LINE s = input ( ) NEW_LINE s = s . split ( ) NEW_LINE a = int ( s [ 0 ] ) NEW_LINE b = int ( s [ 1 ] ) NEW_LINE c = int ( s [ 2 ] ) NEW_LINE d = int ( s [ 3 ] ) NEW_LINE div = math . gcd ( a , b ) NEW_LINE if d == 1 : NEW_LINE INDENT print ( div ) NEW_LINE DEDENT else : NEW_LINE INDENT if div % 2 == 0 : NEW_LINE INDENT p = b * c NEW_LINE q = a * d NEW_LINE DEDENT else : NEW_LINE INDENT p = a * d - b * c NEW_LINE q = b * c NEW_LINE DEDENT print ( p , q ) NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ 0 ] * ( x + 1 ) NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT return dp [ x ] NEW_LINE DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def rearrange ( arr , n ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT arr = [ - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( arr ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE DEDENT
def centered_square_num ( n ) : NEW_LINE INDENT return n * n + ( ( n - 1 ) * ( n - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE print ( n , " th Centered square number : " , centered_square_num ( n ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k > n // k : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ( n // 2 ) * ( a [ n // 2 ] + a [ n // 2 - 1 ] * a [ n // 2 ] ) ) NEW_LINE
def maxSubArraySum ( arr , size ) : NEW_LINE INDENT max_so_far = arr [ 0 ] NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( arr [ i ] , curr_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def lenOfLongSubarrWithGivenSum ( arr , n , k ) : NEW_LINE INDENT um = dict ( ) NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum == k ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT if ( sum in um . keys ( ) ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if ( sum - k in um . keys ( ) ) : NEW_LINE INDENT if ( maxLen < ( i - um [ sum - k ] ) ) : NEW_LINE INDENT maxLen = i - um [ sum - k ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT def lenLongSubarrWithMaxSum ( arr , n ) : NEW_LINE INDENT maxSum = maxSubArraySum ( arr , n ) NEW_LINE return lenOfLongSubarrWithGivenSum ( arr , n , maxSum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , - 2 , - 1 , 3 , - 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length of longest subarray having maximum sum = " , lenLongSubarrWithMaxSum ( arr , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE c = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT t = c [ i ] * c [ j ] NEW_LINE if t < ans : NEW_LINE INDENT ans = t NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def find ( dividend , divisor , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return [ 0 , dividend ] NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE n = dividend - divisor * mid NEW_LINE if ( n > divisor ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT elif ( n < 0 ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n == divisor ) : NEW_LINE INDENT mid += 1 NEW_LINE n = 0 NEW_LINE DEDENT return [ mid , n ] NEW_LINE DEDENT return find ( dividend , divisor , start , end ) NEW_LINE DEDENT def divide ( dividend , divisor ) : NEW_LINE INDENT return find ( dividend , divisor , 1 , dividend ) NEW_LINE DEDENT dividend = 10 NEW_LINE divisor = 3 NEW_LINE ans = divide ( dividend , divisor ) NEW_LINE print ( ans [ 0 ] , " , " , ans [ 1 ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ma = a [ 0 ] - a [ - 1 ] NEW_LINE mi = a [ 0 ] - a [ - 1 ] NEW_LINE ma = max ( ma , a [ 0 ] - a [ - 1 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ma = max ( ma , a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT print ( mi , ma ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE d = [ 0 ] * 8 NEW_LINE if k == 1 : NEW_LINE INDENT print ( n ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT for i in range ( 1 , k ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT d [ 0 ] = max ( d [ 0 ] , n - i ) NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT if i - 1 >= 0 and a [ i ] <= k : NEW_LINE INDENT d [ i ] += a [ i - 1 ] NEW_LINE DEDENT elif i - 1 < k - 1 and a [ i ] >= k : NEW_LINE INDENT d [ i ] += a [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( min ( d ) ) NEW_LINE
def towerOfH kitei ( n , from_rod , to_rod , aux_rod1 , aux_rod2 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( " Move disk " , n , " from rod " , from_rod , " to rod " , " to rod " , " " , " " , " " ) NEW_LINE return NEW_LINE DEDENT towerOfH kitei ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) NEW_LINE print ( " Move disk " , n , " from rod " , from_rod , " to rod " , " aux_rod2 ) NEW_LINE print ( " Move disk " , n , " from rod " , from_rod , " to rod " , " " , " " , " " , " " ) NEW_LINE print ( " Move disk " , ( n - 1 ) , " from rod " , aux_rod2 , " to rod " , " " , " " , " " ) NEW_LINE towerOfH kitei ( n - 2 , from_rod , aux_rod1 , to_rod , from_rod , aux_rod2 ) NEW_LINE DEDENT n = 4 NEW_LINE towerOfH kitei ( n , ' A ' , ' D ' , ' B ' , ' C ' ) NEW_LINE
from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def calc_distance ( word ) : NEW_LINE INDENT d = 1 NEW_LINE ans = 0 NEW_LINE for word in word : NEW_LINE INDENT if word == ' > ' : NEW_LINE INDENT d += 1 NEW_LINE DEDENT elif word == ' + ' : NEW_LINE INDENT d += 1 NEW_LINE DEDENT elif word == ' - ' : NEW_LINE INDENT d += 1 NEW_LINE DEDENT elif word == ' [ ' : NEW_LINE INDENT d += 1 NEW_LINE DEDENT elif word == ' ] ' : NEW_LINE INDENT d += 1 NEW_LINE DEDENT else : NEW_LINE INDENT word = word [ : : - 1 ] NEW_LINE ans += d * int ( word ) NEW_LINE ans %= 1000003 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT print ( calc_distance ( input ( ) ) ) NEW_LINE
import bisect NEW_LINE D = [ ] NEW_LINE N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT query = input ( ) NEW_LINE if query [ 0 ] == "0" : NEW_LINE INDENT d = list ( map ( str , query . split ( ) ) ) NEW_LINE DEDENT elif query [ 0 ] == "1" : NEW_LINE INDENT if d [ d [ d [ d [ int ( d [ int ( d [ int ( d [ int ( d [ int ( d [ int ( d [ int ( int ( d [ int ( k ) ) ) ] ) ] ) ] ] ] ] ] ) ] ) ] NEW_LINE DEDENT elif query [ 0 ] == "2" : NEW_LINE INDENT print ( d [ d [ d [ int ( d [ int ( d [ int ( d [ int ( d [ int ( d [ int ( d [ k ] ) ) ] ) ] ] ) ] ) ] ) ] ) NEW_LINE DEDENT elif query [ 0 ] == "3" : NEW_LINE INDENT D . pop ( d [ int ( d [ int ( d [ int ( d [ int ( d [ int ( d [ k ] ) ) ] ) ] ) ] ) ] ) ] ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] <= prev ) : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum = sum + prev NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE prev = arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 2 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minSum ( arr , n ) ) NEW_LINE
def findN ( k ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << ( math . log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE dp = [ [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] for k in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE DEDENT
d , g = map ( int , input ( ) . split ( ) ) NEW_LINE p = [ ] NEW_LINE c = [ ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE p . append ( x ) NEW_LINE c . append ( y ) NEW_LINE DEDENT ans = 10 ** 9 NEW_LINE for i in range ( 2 ** d ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( d ) : NEW_LINE INDENT if ( i >> j ) & 1 : NEW_LINE INDENT cnt += p [ j ] * ( i + 1 ) * 100 NEW_LINE ans += p [ j ] NEW_LINE DEDENT DEDENT if ( cnt >= g ) : NEW_LINE INDENT for j in range ( d - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i >> j ) & 1 : NEW_LINE INDENT cnt += p [ j ] NEW_LINE while ( cnt >= g ) : NEW_LINE INDENT cnt += ( cnt + 1 ) * 100 NEW_LINE ans += p [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( cnt >= g ) : NEW_LINE INDENT ans = min ( ans , ans ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k += l [ i ] NEW_LINE DEDENT if k == m : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] < a [ n - 1 ] : ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
from math import log2 NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = pow ( 2 , log2 ( n ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT
def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr1 = [ 3 , 4 , 9 , 1 ] NEW_LINE arr2 = [ 5 , 3 , 8 , 9 , 10 , 2 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( " Length of LCIS is " , LCIS ( arr1 , n , arr2 , m ) ) NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT bitCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bitCount += countSetBitsUtil ( i ) NEW_LINE DEDENT return bitCount NEW_LINE DEDENT def countSetBitsUtil ( x ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( 0 if x % 2 == 0 else 1 ) + countSetBitsUtil ( x // 2 ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Total set bit count is " , countSetBits ( n ) ) NEW_LINE
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ low ] NEW_LINE i = low - 1 NEW_LINE j = high + 1 NEW_LINE while ( True ) : NEW_LINE INDENT i += 1 NEW_LINE while ( arr [ i ] < pivot ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT while ( arr [ j ] > pivot ) : NEW_LINE INDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT if ( i >= j ) : NEW_LINE INDENT return j NEW_LINE DEDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT def quickSort ( arr , low , high ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE quickSort ( arr , low , pi ) NEW_LINE quickSort ( arr , pi + 1 , high ) NEW_LINE DEDENT return arr NEW_LINE DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE quickSort ( arr , 0 , n - 1 ) NEW_LINE print ( " Sorted array : " ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT
def Swap ( array , position1 , position2 ) : NEW_LINE INDENT temp = array [ position1 ] NEW_LINE array [ position1 ] = array [ position2 ] NEW_LINE array [ position2 ] = temp NEW_LINE DEDENT def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ high ] NEW_LINE i = ( low - 1 ) NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT if ( arr [ j ] <= pivot ) : NEW_LINE INDENT i += 1 NEW_LINE Swap ( arr , i , j ) NEW_LINE DEDENT DEDENT Swap ( arr , i + 1 , high ) NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( arr , low , high ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE quickSort ( arr , low , pi - 1 ) NEW_LINE quickSort ( arr , pi + 1 , high ) NEW_LINE DEDENT return ( i + 1 ) NEW_LINE DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE quickSort ( arr , 0 , n - 1 ) NEW_LINE print ( " Sorted array : " ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT
import sys NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT def minPossibleSum ( a , n , x ) : NEW_LINE INDENT mxSum = maxSubArraySum ( a , n ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum = sum - mxSum + mxSum / x NEW_LINE print ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE X = 2 NEW_LINE A = [ 1 , - 2 , 3 ] NEW_LINE minPossibleSum ( A , N , X ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = n - 1 NEW_LINE k = [ ] NEW_LINE while i > 0 : NEW_LINE INDENT if a [ i - 1 ] == i : NEW_LINE INDENT k . append ( a . pop ( i - 1 ) ) NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( * k , sep = " " ) NEW_LINE DEDENT
def printArray ( N , SUM , K ) : NEW_LINE INDENT minSum = ( N * ( N + 1 ) ) // 2 NEW_LINE maxSum = ( N * K ) - ( N * ( N - 1 ) ) // 2 NEW_LINE if ( minSum > SUM or maxSum < SUM ) : NEW_LINE INDENT print ( " Not Possible " ) NEW_LINE return NEW_LINE DEDENT arr = [ 0 ] * ( N + 1 ) NEW_LINE sum = minSum NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT x = sum + ( K - i ) NEW_LINE if ( x < SUM ) : NEW_LINE INDENT sum = sum + ( K - i ) NEW_LINE arr [ i ] = K NEW_LINE K -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( SUM - sum ) NEW_LINE sum = SUM NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE SUM = 15 NEW_LINE K = 8 NEW_LINE printArray ( N , SUM , K ) NEW_LINE DEDENT
COST = 3 NEW_LINE def maxItems ( x , y , z ) : NEW_LINE INDENT type1 = int ( x / COST ) NEW_LINE x %= COST NEW_LINE type2 = int ( y / COST ) NEW_LINE y %= COST NEW_LINE type3 = int ( z / COST ) NEW_LINE z %= COST NEW_LINE type4 = min ( x , min ( y , z ) ) NEW_LINE maxItems = type1 + type2 + type3 + type4 NEW_LINE return maxItems NEW_LINE DEDENT x = 4 NEW_LINE y = 5 NEW_LINE z = 6 NEW_LINE print ( maxItems ( x , y , z ) ) NEW_LINE
def run_ tasks ( A , B ) : NEW_LINE INDENT total_time = 0 NEW_LINE while ( len ( A ) > 0 ) : NEW_LINE INDENT x = A [ 0 ] NEW_LINE y = B [ 0 ] NEW_LINE if ( x == y ) : NEW_LINE INDENT A . pop ( 0 ) NEW_LINE B . pop ( 0 ) NEW_LINE total_time += 1 NEW_LINE DEDENT else : NEW_LINE INDENT A . pop ( 0 ) NEW_LINE A . append ( x ) NEW_LINE total_time += 2 NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( 3 ) NEW_LINE A . append ( 2 ) NEW_LINE A . append ( 1 ) NEW_LINE A . append ( 4 ) NEW_LINE B = [ ] NEW_LINE B . append ( 4 ) NEW_LINE B . append ( 1 ) NEW_LINE B . append ( 3 ) NEW_LINE B . append ( 2 ) NEW_LINE print ( run_ tasks ( A , B ) ) NEW_LINE DEDENT
def line ( x0 , y0 ) : NEW_LINE INDENT c = ( 2 * y0 * x0 ) NEW_LINE print ( " { } x { } y = { } " . format ( c , x0 , y0 ) ) NEW_LINE DEDENT x0 = 4 NEW_LINE y0 = 3 NEW_LINE line ( x0 , y0 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( input ( ) ) NEW_LINE DEDENT s = set ( ) NEW_LINE for i in arr : NEW_LINE INDENT l = set ( ) NEW_LINE for j in s : NEW_LINE INDENT if i not in l : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT DEDENT s . add ( i ) NEW_LINE DEDENT print ( len ( s ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l1 , r1 , l2 , r2 , l3 , r3 = [ float ( x ) for x in input ( ) . split ( ) ] NEW_LINE if l1 == r2 and l2 == r3 and l3 == r1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif l1 < r2 and l3 < r2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif l2 < r2 and l3 > r3 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
def isAnyNotPalindrome ( s ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT unique . add ( s [ i ] ) NEW_LINE DEDENT if len ( unique ) > 1 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaaaab " NEW_LINE if ( isAnyNotPalindrome ( s ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT return arr [ n // 2 ] NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMajority ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , a = input ( ) . split ( ) NEW_LINE if d == " North " : NEW_LINE INDENT x = x + int ( a ) NEW_LINE DEDENT elif d == " South " : NEW_LINE INDENT x = x - int ( a ) NEW_LINE DEDENT elif d == " East " : NEW_LINE INDENT x = x - int ( a ) NEW_LINE DEDENT elif d == " South " : NEW_LINE INDENT x = x + int ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT x = x - int ( a ) NEW_LINE DEDENT if x == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE DEDENT
def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr = [ ] NEW_LINE arr . append ( a ) NEW_LINE arr . append ( b ) NEW_LINE arr . append ( c ) NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] NEW_LINE k = k - diff NEW_LINE if ( k < 0 or k % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a1 = 6 NEW_LINE b1 = 3 NEW_LINE c1 = 2 NEW_LINE k1 = 7 NEW_LINE if ( canBeEqual ( a1 , b1 , c1 , k1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def insert ( x , y ) : NEW_LINE INDENT adjacency [ x ] . append ( y ) NEW_LINE DEDENT def dfs ( node , leaf , vis ) : NEW_LINE INDENT leaf [ node ] = 0 NEW_LINE vis [ node ] = 1 NEW_LINE for i in adjacency [ node ] : NEW_LINE INDENT it = adjacency [ node ] [ i ] NEW_LINE if ( vis [ it ] == 0 ) : NEW_LINE INDENT dfs ( it , leaf , vis ) NEW_LINE leaf [ node ] += leaf [ it ] NEW_LINE DEDENT DEDENT if ( adjacency [ node ] [ len ( adjacency [ node ] ) == 0 ) : NEW_LINE INDENT leaf [ node ] = 1 NEW_LINE DEDENT DEDENT def printLeaf ( n , leaf ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " The node " , i , " has " , leaf [ i ] , " leaf nodes " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 6 NEW_LINE adjacency = [ ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT adjacency . append ( [ ] ) NEW_LINE DEDENT insert ( 1 , 2 ) NEW_LINE insert ( 1 , 3 ) NEW_LINE insert ( 3 , 4 ) NEW_LINE insert ( 3 , 5 ) NEW_LINE insert ( 3 , 6 ) NEW_LINE leaf = [ 0 ] * ( N + 1 ) NEW_LINE vis = [ 0 ] * ( N + 1 ) NEW_LINE dfs ( 1 , leaf , vis ) NEW_LINE printLeaf ( N , leaf ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( min ( len ( n ) , k ) ) : NEW_LINE INDENT if n [ i ] != 1 : NEW_LINE INDENT print ( n [ i ] ) NEW_LINE quit ( ) NEW_LINE DEDENT DEDENT print ( 1 ) NEW_LINE
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE s1_l = len ( s1 ) NEW_LINE s2_l = len ( s2 ) NEW_LINE dict1 = { } NEW_LINE dict2 = { } NEW_LINE for i in range ( s1 ) : NEW_LINE INDENT if i not in dict1 : NEW_LINE INDENT dict1 [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dict1 [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( s2 ) : NEW_LINE INDENT if i not in dict2 : NEW_LINE INDENT dict2 [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dict2 [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in dict1 : NEW_LINE INDENT if i in dict2 : NEW_LINE INDENT ans += min ( dict2 [ i ] , dict1 [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] for z in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = " AGGT12" NEW_LINE Y = "12 txAYB " NEW_LINE Z = "12XBA " NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( " Length of LCS is " , lcsOf3 ( X , Y , Z , m , n , o ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( abs ( a [ i + 1 ] - a [ i ] ) for i in range ( n - 1 ) ) ) NEW_LINE
def is spiltPossible ( n , a ) : NEW_LINE INDENT sum = 0 NEW_LINE c1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if ( sum % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( sum // 2 ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( c1 > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE a = [ 1 , 1 , 2 ] NEW_LINE if ( is spiltPossible ( n , a ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = l . count ( 1 ) NEW_LINE b = l . count ( 2 ) NEW_LINE c = l . count ( 3 ) NEW_LINE d = l . count ( 4 ) NEW_LINE print ( max ( a , b , c , d ) ) NEW_LINE
def count_even_odd ( min , max , steps ) : NEW_LINE INDENT beven = True ; aeven = False ; NEW_LINE n = 2 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = steps [ i ] [ 0 ] ; NEW_LINE b = steps [ i ] [ 1 ] ; NEW_LINE if ( not ( aeven or ( a & 1 ) > 0 ) ) : NEW_LINE INDENT aeven = True ; NEW_LINE DEDENT if ( beven ) : NEW_LINE INDENT if ( not ( b & 1 ) ) : NEW_LINE INDENT beven = False ; NEW_LINE DEDENT DEDENT elif ( not ( a & 1 ) ) : NEW_LINE INDENT if ( not ( b & 1 ) ) : NEW_LINE INDENT beven = True ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT beven = True ; NEW_LINE DEDENT DEDENT DEDENT if ( beven ) : NEW_LINE INDENT even = max // 2 - ( min - 1 ) // 2 ; NEW_LINE odd = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT even = max // 2 - ( min - 1 ) // 2 ; NEW_LINE odd = 0 ; NEW_LINE DEDENT if ( not ( beven ^ aeven ) ) : NEW_LINE INDENT even += max - min + 1 - ( max // 2 + ( min - 1 ) // 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += max - min + 1 - ( max // 2 + ( min - 1 ) // 2 ) ; NEW_LINE DEDENT print ( " even = " , even , " , odd = " , odd ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT min = 1 ; max = 4 ; NEW_LINE steps = [ [ 1 , 2 ] , [ 3 , 4 ] ] ; NEW_LINE count_even_odd ( min , max , steps ) ; NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n + k - 1 ) * k ) NEW_LINE
def printKPFNums ( A , B , K ) : NEW_LINE INDENT prime = [ True ] * ( B + 1 ) NEW_LINE p_factors = [ 0 ] * ( B + 1 ) NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if ( p_factors [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p , B + 1 , p ) : NEW_LINE INDENT p_factors [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( p_factors [ i ] == K ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 14 NEW_LINE B = 18 NEW_LINE K = 2 NEW_LINE printKPFNums ( A , B , K ) NEW_LINE DEDENT
def reverseWords ( string ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] != ' ' ) : NEW_LINE INDENT st . append ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( len ( st ) == 0 ) : NEW_LINE INDENT print ( st . pop ( ) , end = " " ) NEW_LINE DEDENT print ( " " , end = " " ) NEW_LINE DEDENT while ( len ( st ) == 0 ) : NEW_LINE INDENT print ( st . pop ( ) , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " Geeks for Geeks " NEW_LINE reverseWords ( string ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] == 1 and r [ i ] == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif p [ i ] == 0 and r [ i ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ans == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans // ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 4 ) NEW_LINE print ( '1 \n 2' ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i % i == 0 : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE print ( '1 \n 2' ) NEW_LINE DEDENT
def cal ( operand , a , b ) : NEW_LINE INDENT if operand == " + " : NEW_LINE INDENT return int ( a ) + int ( b ) NEW_LINE DEDENT elif operand == " - " : NEW_LINE INDENT return int ( a ) - int ( b ) NEW_LINE DEDENT elif operand == " * " : NEW_LINE INDENT return int ( a ) * int ( b ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT s = list ( input ( ) . split ( ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT operand = [ ] NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE ans = 0 NEW_LINE for i in s : NEW_LINE INDENT if i . isdigit ( ) : NEW_LINE INDENT b . append ( int ( i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT a . append ( [ i , cal ( i , a [ - 1 ] , b [ - 1 ] ) ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k <= n : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif k % n == 0 : NEW_LINE INDENT print ( k // n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k // n + 1 ) NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE print ( pow ( 3 , n - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n = ( n // 2 ) + 1 NEW_LINE print ( pow ( 2 , n - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE N = 11 NEW_LINE findNthTerm ( N ) NEW_LINE DEDENT
def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] >= arr [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) // 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 7 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNonIncreasing ( arr , n ) ) NEW_LINE
def maximize ( A1 , A2 , n , x , y ) : NEW_LINE INDENT c = [ 0 for i in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = A2 [ i ] - A1 [ i ] NEW_LINE sum += A1 [ i ] NEW_LINE DEDENT temp = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( c [ i ] < c [ i + 1 ] ) : NEW_LINE INDENT temp = c [ i ] NEW_LINE c [ i ] = c [ i + 1 ] NEW_LINE c [ i + 1 ] = temp NEW_LINE DEDENT DEDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += c [ i ] NEW_LINE if ( i + 1 >= ( n - x ) ) : NEW_LINE INDENT maxi = max ( sum , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT A1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE A2 = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE n = 5 NEW_LINE x = 3 NEW_LINE y = 3 NEW_LINE print ( maximize ( A1 , A2 , n , x , y ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = input ( ) NEW_LINE a = int ( n ) NEW_LINE s = str ( a ) NEW_LINE if int ( s [ 0 ] ) == 0 : NEW_LINE INDENT print ( s . count ( "0" ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( a - 1 ) + ( len ( s ) - 1 ) * ( a - 1 ) // 2 NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE d = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT d [ i ] [ j ] = list ( map ( int , input ( ) . split ( ' , ' ) ) ) NEW_LINE DEDENT DEDENT m = int ( input ( ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT s , d , v = map ( int , input ( ) . split ( ' , ' ) ) NEW_LINE d [ s - 1 ] [ d - 1 ] = list ( map ( int , input ( ) . split ( ' , ' ) ) ) NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if d [ i ] [ j ] > d [ i ] [ s - 1 ] [ j ] : NEW_LINE INDENT d [ i ] [ j ] = d [ i ] [ s - 1 ] [ j ] NEW_LINE res = max ( res , v - i - j + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE
r1 , r2 , c1 , c2 , d1 , d2 = map ( int , input ( ) . split ( ) ) NEW_LINE if ( c1 + c2 ) % 2 != 0 or ( d1 + d2 ) % 2 != 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = [ ] NEW_LINE if ( r2 - d2 ) // 2 < ans [ 0 ] : NEW_LINE INDENT ans = [ - 1 ] NEW_LINE DEDENT d = r2 - d - c2 NEW_LINE if ( d > 1 ) : NEW_LINE INDENT x = ( d - 1 ) // 2 + c1 NEW_LINE y = c2 - x NEW_LINE if ( x < 0 or x > 9 ) : NEW_LINE INDENT ans = [ - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT x = ( d - 1 ) // 2 NEW_LINE y = c2 - x NEW_LINE if ( y < 0 or y > 9 ) : NEW_LINE INDENT ans = [ - 1 ] NEW_LINE DEDENT DEDENT if ans : NEW_LINE INDENT print ( * ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
from collections import defaultdict NEW_LINE import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE if N == 0 and M == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE W = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = defaultdict ( list ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT d [ A [ i ] ] . append ( i ) NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT d [ W [ i ] ] . append ( i ) NEW_LINE DEDENT ans = sorted ( d . items ( ) , key = lambda x : x [ 1 ] ) NEW_LINE ans0 = ans [ 0 ] [ 0 ] NEW_LINE for item in ans [ 1 : ] : NEW_LINE INDENT if item [ 0 ] != ans0 [ 1 ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE dp = [ float ( ' inf ' ) ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT v = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for j in range ( 4 ) : NEW_LINE INDENT if s [ j ] == ' A ' : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , dp [ j - 1 ] + v ) NEW_LINE DEDENT elif s [ j ] == ' B ' : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , dp [ j - 1 ] + v ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , dp [ j - 1 ] + v ) NEW_LINE DEDENT DEDENT DEDENT if dp [ - 1 ] == float ( ' inf ' ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( dp [ - 1 ] ) NEW_LINE DEDENT
def startsWith ( string , pre ) : NEW_LINE INDENT strLen = len ( string ) NEW_LINE preLen = len ( pre ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < strLen and j < preLen ) : NEW_LINE INDENT if ( string [ i ] != pre [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def endsWith ( string , suff ) : NEW_LINE INDENT i = len ( string ) - 1 NEW_LINE j = len ( suff ) - 1 NEW_LINE while ( i >= 0 and j >= 0 ) : NEW_LINE INDENT if ( string [ i ] != suff [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def checkString ( string , a , b ) : NEW_LINE INDENT if ( len ( string ) != a + b ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( startsWith ( string , a ) ) : NEW_LINE INDENT if ( endsWith ( string , b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if ( startsWith ( string , b ) ) : NEW_LINE INDENT if ( endsWith ( string , a ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeksforGeeks " NEW_LINE a = " Geeksfo " NEW_LINE b = " rGeeks " NEW_LINE if ( checkString ( string , a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 ) : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT n = 233 NEW_LINE printCombination ( n ) NEW_LINE
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n - i + 1 ) : NEW_LINE INDENT for k in range ( n - i - j + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE DEDENT
def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def getNthTerm ( n ) : NEW_LINE INDENT sum = digitSum ( n ) NEW_LINE if ( sum % 10 == 0 ) : NEW_LINE INDENT return ( n * 10 ) NEW_LINE DEDENT extra = 10 - ( sum % 10 ) NEW_LINE return ( ( n * 10 ) + extra ) NEW_LINE DEDENT def firstNTerms ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( getNthTerm ( i ) , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE firstNTerms ( n ) NEW_LINE DEDENT
def power ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while ( a > 0 ) : NEW_LINE INDENT if ( ( a & 1 ) > 0 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT maxProduct = - 1 NEW_LINE if ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , N // 3 ) NEW_LINE DEDENT elif ( N % 3 == 1 ) : NEW_LINE INDENT maxProduct = 2 * 2 * power ( 3 , ( N // 3 ) - 1 ) NEW_LINE DEDENT elif ( N % 3 == 2 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , ( N // 3 ) - 1 ) NEW_LINE DEDENT elif ( N % 3 == 3 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , ( N // 3 ) - 1 ) NEW_LINE DEDENT return maxProduct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT maxProduct = breakInteger ( 10 ) NEW_LINE print ( maxProduct ) NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT p = int ( input ( ) ) NEW_LINE if p % 2 == 0 : NEW_LINE INDENT ans = p // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = p // 2 + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
n = input ( ) NEW_LINE ans = n [ 0 ] NEW_LINE if n [ 1 ] == "2018" or n [ 1 ] == "2017" or n [ 1 ] == "2018" : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def firstNonRepeating ( string ) : NEW_LINE INDENT charCount = [ 0 ] * MAX_CHAR NEW_LINE q = [ ] NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE q . append ( ch ) NEW_LINE charCount [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT if ( charCount [ q [ - 1 ] ] > 1 ) : NEW_LINE INDENT q . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( q [ - 1 ] , end = " " ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( len ( q ) == 0 ) : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " aabc " NEW_LINE firstNonRepeating ( string ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE from math import inf NEW_LINE n = int ( input ( ) ) NEW_LINE d = defaultdict ( list ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE d [ a ] . append ( b ) NEW_LINE d [ b ] . append ( a ) NEW_LINE DEDENT def dfs ( k ) : NEW_LINE INDENT if k == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans += dfs ( k ) NEW_LINE return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if d [ i ] [ 0 ] == 1 : NEW_LINE INDENT ans += dfs ( i ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def solve ( n , m , obstacles , range1 ) : NEW_LINE INDENT val = min ( n , m ) NEW_LINE range1 . sort ( ) NEW_LINE c = 1 NEW_LINE for i in range ( obstacles - 1 , - 1 , - 1 ) : NEW_LINE INDENT range1 [ i ] = 2 * range1 [ i ] NEW_LINE val -= range1 [ i ] NEW_LINE if ( val <= 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( val > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , m , obstacles = 4 , 5 , 3 NEW_LINE range1 = [ 1.0 , 1.25 , 1.15 ] NEW_LINE print ( solve ( n , m , obstacles , range1 ) ) NEW_LINE DEDENT
a = input ( ) NEW_LINE x = int ( a [ 0 ] ) NEW_LINE y = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] == " + " : NEW_LINE INDENT x += int ( a [ i - 1 ] ) NEW_LINE y += int ( a [ i ] ) NEW_LINE DEDENT elif a [ i ] == " * " : NEW_LINE INDENT x *= int ( a [ i ] ) NEW_LINE x %= int ( a [ i ] ) NEW_LINE DEDENT DEDENT if x == y : NEW_LINE INDENT print ( " M " ) NEW_LINE DEDENT elif x == y : NEW_LINE INDENT print ( " U " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " L " ) NEW_LINE DEDENT
stack = [ ] NEW_LINE minStack = [ ] NEW_LINE def push ( x ) : NEW_LINE INDENT stack . append ( x ) NEW_LINE if ( len ( minStack ) == 0 or x <= minStack [ 0 ] ) : NEW_LINE INDENT minStack . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT minStack . append ( minStack [ 0 ] ) NEW_LINE DEDENT DEDENT def pop ( ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE minStack . pop ( ) NEW_LINE DEDENT def top ( ) : NEW_LINE INDENT return stack [ 0 ] NEW_LINE DEDENT def getMin ( ) : NEW_LINE INDENT return minStack [ 0 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = MinStack ( ) NEW_LINE m . push ( - 2 ) NEW_LINE m . push ( 0 ) NEW_LINE m . push ( - 3 ) NEW_LINE print ( getMin ( ) ) NEW_LINE m . pop ( ) NEW_LINE print ( m . top ( ) ) NEW_LINE print ( getMin ( ) ) NEW_LINE DEDENT
one = [ " " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " , " ten " , " eleven " , " twelve " , " thirteen " , " fourteen " , " fifteen " , " sixteen " , " seventeen " , " eighteen " , " nineteen " ] NEW_LINE ten = [ " " , " " , " twenty " , " thirty " , " forty " , " fifty " , " sixty " , " seventy " , " eighty " , " ninety " ] NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT if ( n > 19 ) : NEW_LINE INDENT return ( ten [ n // 10 ] + one [ n % 10 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( one [ n ] ) NEW_LINE DEDENT return s NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = " " NEW_LINE out += numToWords ( n // 10000000 ) NEW_LINE out += numToWords ( n // 100000 ) NEW_LINE out += numToWords ( ( n // 100000 ) % 100 ) NEW_LINE out += numToWords ( ( n // 1000 ) % 100 ) NEW_LINE out += " thousand " NEW_LINE out += numToWords ( ( n // 100 ) % 10 ) NEW_LINE if ( n > 100 and n % 100 > 0 ) : NEW_LINE INDENT out += " and " NEW_LINE DEDENT out += numToWords ( n % 100 ) NEW_LINE return out NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 438264 NEW_LINE print ( convertToWords ( n ) ) NEW_LINE DEDENT
def flip sign ( a ) : NEW_LINE INDENT neg = 0 NEW_LINE tmp = 1 if a < 0 else - 1 NEW_LINE while a > 0 : NEW_LINE INDENT neg += tmp NEW_LINE a += tmp NEW_LINE DEDENT return neg NEW_LINE DEDENT def areDifferent sign ( a , b ) : NEW_LINE INDENT return ( ( a < 0 and b > 0 ) or ( a > 0 and b < 0 ) ) NEW_LINE DEDENT def sub ( a , b ) : NEW_LINE INDENT return a + flip sign ( b ) NEW_LINE DEDENT def mul ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT return mul ( b , a ) NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( abs ( b ) ) : NEW_LINE INDENT sum += a NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT sum = flip sign ( sum ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def division ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT raise ArithmeticException ( ) NEW_LINE DEDENT quotient = 0 NEW_LINE dividend = flip sign ( abs ( b ) ) NEW_LINE for i in range ( abs ( a ) ) : NEW_LINE INDENT if i >= abs ( divisor ) : NEW_LINE INDENT quotient += 1 NEW_LINE DEDENT if i < abs ( divisor ) : NEW_LINE INDENT quotient = quotient + 1 NEW_LINE DEDENT if areDifferent sign ( a , b ) : NEW_LINE INDENT quotient = flip sign ( quotient ) NEW_LINE DEDENT return quotient NEW_LINE DEDENT print ( " Subtraction is " , sub ( 4 , - 2 ) ) NEW_LINE print ( " Product is " , mul ( - 9 , 6 ) ) NEW_LINE print ( " Division is " , division ( 8 , 2 ) ) NEW_LINE print ( " Exception : - Divide by 0" ) NEW_LINE
def factorial ( n ) : NEW_LINE INDENT i = n NEW_LINE fact = 1 NEW_LINE while ( n / i != n ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT num = 5 NEW_LINE print ( " Factorial of " , num , " is " , factorial ( num ) ) NEW_LINE
def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( ( number % x == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE print ( CntDivbyX ( arr , n , x ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in w : NEW_LINE INDENT if i not in d : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT DEDENT c = 0 NEW_LINE for i in d : NEW_LINE INDENT c += i * ( i - 1 ) // 2 NEW_LINE DEDENT print ( c ) NEW_LINE
def min_noOf_ operation ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) // k NEW_LINE if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT res = res + noOfSubtraction NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = 4 NEW_LINE k = 5 NEW_LINE print ( min_noOf_ operation ( arr , N , k ) ) NEW_LINE DEDENT
def CountSubSet ( arr , n , X ) : NEW_LINE INDENT N = pow ( 2 , n ) NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) != 0 ) : NEW_LINE INDENT if ( arr [ j ] == X ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 ] NEW_LINE X = 5 NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubSet ( arr , n , X ) ) NEW_LINE
n = 5 NEW_LINE def FindMaxProduct ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 ) : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 1 ) <= 0 ) : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT DEDENT DEDENT return max NEW_LINE DEDENT arr = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 6 , 7 , 8 , 9 , 1 ] , [ 2 , 3 , 4 , 5 , 6 ] , [ 7 , 8 , 9 , 1 , 0 ] , [ 9 , 6 , 4 , 2 , 3 ] ] NEW_LINE n = 5 NEW_LINE print ( FindMaxProduct ( arr , n ) ) NEW_LINE
MAX = 50002 NEW_LINE primes = [ ] NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT p = 2 NEW_LINE while p < MAX : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT p += 1 NEW_LINE DEDENT DEDENT def power ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE z = y NEW_LINE while ( x >= z ) : NEW_LINE INDENT count += ( x // z ) NEW_LINE z *= y NEW_LINE DEDENT return count NEW_LINE DEDENT def modMult ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def countWays ( n , m ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , len ( primes ) ) : NEW_LINE INDENT powers = power ( n , primes [ i ] ) NEW_LINE if ( powers == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = modMult ( ans , powers + 1 , m ) % m NEW_LINE DEDENT if ( ( ans - 1 ) % m ) < 0 : NEW_LINE INDENT return ( ans - 1 ) % m NEW_LINE DEDENT else : NEW_LINE INDENT return ( ans - 1 ) % m NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) NEW_LINE n = 4 NEW_LINE m = 7 NEW_LINE print ( countWays ( n , m ) ) NEW_LINE DEDENT
def smallestIndexsum ( arr , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 and arr [ i ] % 2 == 1 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE for j in range ( 0 , i + 1 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 6 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestIndexsum ( arr , n ) ) NEW_LINE
s = input ( ) NEW_LINE t = input ( ) NEW_LINE dd = int ( s [ 0 ] ) * 60 + int ( s [ 1 ] ) NEW_LINE m = int ( s [ 2 ] ) * 60 + int ( s [ 3 ] ) NEW_LINE print ( dd - ( m * 60 ) ) NEW_LINE
s = input ( ) NEW_LINE print ( s . count ( ' Q ' ) + sum ( s . count ( ' A ' ) == 1 and s . count ( ' Q ' ) == 2 ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( reverse = True ) NEW_LINE dp = [ [ 0 ] * K for _ in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( K + 1 ) : NEW_LINE INDENT if j < A [ i ] : NEW_LINE INDENT dp [ i + 1 ] [ j ] = dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j - A [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if dp [ i ] [ K ] > 0 : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ K ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE i = 1 NEW_LINE d = 0 NEW_LINE while n > 0 : NEW_LINE INDENT d += 1 NEW_LINE if s % i == 0 : NEW_LINE INDENT s -= ( s // i ) * i NEW_LINE n -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( d ) NEW_LINE
v = [ ] ; NEW_LINE def multiply ( x ) : NEW_LINE INDENT carry = 0 ; NEW_LINE size = len ( v ) ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT res = carry + v [ i ] * x ; NEW_LINE v [ i ] = res % 10 ; NEW_LINE carry = int ( res / 10 ) ; NEW_LINE DEDENT while ( carry != 0 ) : NEW_LINE INDENT v . append ( carry % 10 ) ; NEW_LINE carry = int ( carry / 10 ) ; NEW_LINE DEDENT DEDENT def findSumOfDigits ( n ) : NEW_LINE INDENT v . append ( 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT multiply ( i ) ; NEW_LINE DEDENT sum = 0 ; NEW_LINE size = len ( v ) ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT sum += v [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1000 ; NEW_LINE print ( findSumOfDigits ( n ) ) ; NEW_LINE DEDENT
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " L " : NEW_LINE INDENT ans [ - 1 ] += 1 NEW_LINE DEDENT elif s == " R " : NEW_LINE INDENT ans [ - 1 ] += 1 NEW_LINE DEDENT elif s == " U " : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT ans [ - 1 ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans [ - 1 ] += 1 NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT
from bisect import bisect_left NEW_LINE n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT left , right , num = map ( int , input ( ) . split ( ) ) NEW_LINE num = bisect_left ( l , num ) NEW_LINE if num == left : NEW_LINE INDENT l [ num - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT l [ num - 1 ] = 0 NEW_LINE DEDENT j = bisect_left ( l , num ) NEW_LINE while j != left : NEW_LINE INDENT if l [ j ] < num - 1 : NEW_LINE INDENT l [ j ] = num - 1 NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT print ( " " . join ( map ( str , l ) ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT b . append ( a [ n - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if a [ i ] > a [ i - 1 ] : NEW_LINE INDENT b . append ( a [ i - 1 ] - a [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( a [ i - 1 ] - a [ i ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( * b ) NEW_LINE
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 2 * pell ( n - 1 ) + pell ( n - 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( pell ( n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE odd = [ ] NEW_LINE even = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT even . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( odd [ i ] , even [ - 1 ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( even [ i ] , odd [ - 1 ] , end = " " ) NEW_LINE DEDENT DEDENT
def printSmall ( arr , asize , n ) : NEW_LINE INDENT copy_arr = arr NEW_LINE asize = len ( arr ) NEW_LINE copy_arr . sort ( ) NEW_LINE for i in range ( asize ) : NEW_LINE INDENT if ( sorted ( copy_arr , 0 , n , arr [ i ] ) > - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE asize = len ( arr ) NEW_LINE n = 5 NEW_LINE printSmall ( arr , asize , n ) NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT count += 2 ** k NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 11 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT
n , m , s = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if min ( a ) < max ( b ) : NEW_LINE INDENT min ( a ) , max ( b ) NEW_LINE DEDENT c = min ( b ) NEW_LINE i = 0 NEW_LINE while c != 0 : NEW_LINE INDENT if s - a [ i ] >= 0 : NEW_LINE INDENT s -= a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s += b [ i ] NEW_LINE i += 1 NEW_LINE DEDENT c = c + s // min ( min ( a ) , max ( b ) ) NEW_LINE i += 1 NEW_LINE DEDENT print ( s ) NEW_LINE
from math import sqrt NEW_LINE maximum = - 10 ** 9 NEW_LINE ans = sqrt ( 9 ) NEW_LINE graph = [ [ ] for i in range ( 100 ) ] NEW_LINE weight = [ 0 ] * 1001 NEW_LINE def __builtin_popcount ( x ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 60 ) : NEW_LINE INDENT if ( ( x >> i ) & 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def dfs ( node , parent ) : NEW_LINE INDENT a = __builtin_popcount ( weight [ node ] + x ) NEW_LINE if ( maximum < a ) : NEW_LINE INDENT maximum = a NEW_LINE ans = node NEW_LINE DEDENT elif ( maximum == a ) : NEW_LINE INDENT ans = min ( ans , node ) NEW_LINE DEDENT for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if ( graph [ node ] [ i ] == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( graph [ node ] [ i ] , node ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 15 NEW_LINE weight [ 0 ] = 5 NEW_LINE weight [ 1 ] = 10 NEW_LINE weight [ 2 ] = 11 NEW_LINE weight [ 3 ] = 8 NEW_LINE weight [ 4 ] = 6 NEW_LINE for i in range ( 100 ) : NEW_LINE INDENT graph [ 1 ] . append ( 2 ) NEW_LINE graph [ 2 ] . append ( 3 ) NEW_LINE graph [ 2 ] . append ( 4 ) NEW_LINE graph [ 1 ] . append ( 5 ) NEW_LINE dfs ( 1 , 1 ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
MAX = 26 NEW_LINE def updateFreq ( string , freq ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT def maxCount ( string , patt ) : NEW_LINE INDENT stringFreq = [ 0 ] * MAX NEW_LINE updateFreq ( string , stringFreq ) NEW_LINE pattFreq = [ 0 ] * MAX NEW_LINE updateFreq ( patt , pattFreq ) NEW_LINE ans = MAX_VALUE NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( pattFreq [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT ans = min ( ans , ( int ) ( stringFreq [ i ] / pattFreq [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE patt = " geeks " NEW_LINE print ( maxCount ( string , patt ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_a = 0 NEW_LINE max_b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_a = max ( max_a | a [ i ] , max_b | b [ i ] ) NEW_LINE max_b = max ( max_b | b [ i ] , max_a | a [ i ] ) NEW_LINE DEDENT print ( max_b ) NEW_LINE
n , l , r , q , l = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = min ( ans , ( a [ i ] - a [ j ] ) * l + ( a [ i ] - a [ j ] ) * r ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def wastedWater ( V , M , N ) : NEW_LINE INDENT wasted_ amt_per_min , time_to_fill = 0 , 0 NEW_LINE amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_ amt_ amt_to_fill = N * time_to_fill NEW_LINE return wasted_ amt_ amt_to_fill NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT V , M , N = 700 , 10 , 3 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE V = 1000 NEW_LINE M = 100 NEW_LINE N = 50 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE DEDENT
def maxSubStr ( strr , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT if ( count0 == count1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( count0 != count1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT strr = "0100110101" NEW_LINE n = len ( strr ) NEW_LINE print ( maxSubStr ( strr , n ) ) NEW_LINE
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( a , b ) , min ( a , b ) ) NEW_LINE
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE n = 1 NEW_LINE while ( sum < s ) : NEW_LINE INDENT sum += n NEW_LINE if ( sum == s ) : NEW_LINE INDENT return n NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = 15 NEW_LINE n = findS ( s ) NEW_LINE if ( n == - 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT
def maximumAbsolute ( arr , n ) : NEW_LINE INDENT mn = 9999999999 NEW_LINE mx = - 9999999999 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 and arr [ i ] == - 1 and arr [ i - 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i - 1 ] ) NEW_LINE mx = max ( mx , arr [ i - 1 ] ) NEW_LINE DEDENT if ( i < n - 1 and arr [ i ] == - 1 and arr [ i + 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i + 1 ] ) NEW_LINE mx = max ( mx , arr [ i + 1 ] ) NEW_LINE DEDENT DEDENT common_integer = ( mn + mx ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == - 1 ) : NEW_LINE INDENT arr [ i ] = common_integer NEW_LINE DEDENT DEDENT max_diff = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE if ( diff > max_diff ) : NEW_LINE INDENT max_diff = diff NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 1 , - 1 , 11 , - 1 , 3 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maximumAbsolute ( arr , n ) ) NEW_LINE DEDENT
def countStrings ( N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( N + 1 ) ] NEW_LINE MOD = 1000000007 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( 9 , 3 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT dp [ 1 ] [ 0 ] , dp [ 1 ] [ 1 ] , dp [ 1 ] [ 2 ] = 0 , 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 2 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE print ( countStrings ( N ) ) NEW_LINE DEDENT
def longest_subseq ( n , k , s ) : NEW_LINE INDENT dp = [ 0 ] * n ; NEW_LINE max_length = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = ord ( s [ i ] ) - ord ( ' a ' ) ; NEW_LINE lower = max ( 0 , curr - k ) ; NEW_LINE upper = min ( 25 , curr + k ) ; NEW_LINE for j in range ( lower , upper + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , max_length [ j ] + 1 ) ; NEW_LINE DEDENT max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] ) ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( dp ) : NEW_LINE INDENT ans = max ( i , ans ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " ; NEW_LINE n = len ( s ) ; NEW_LINE k = 3 ; NEW_LINE print ( longest_subseq ( n , k , s ) ) ; NEW_LINE DEDENT
def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT len = 2 NEW_LINE mx = - 2147483648 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = 2 NEW_LINE DEDENT mx = max ( mx , len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE a = [ 2 , 4 , 6 , 10 , 2 ] NEW_LINE print ( longestFibonacciSubarray ( n , a ) ) NEW_LINE DEDENT
def minimumSubarrays ( ar , n ) : NEW_LINE INDENT se = [ ] NEW_LINE cnt = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ar [ i ] in se ) : NEW_LINE INDENT se . append ( ar [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE se . clear ( ) NEW_LINE se . append ( ar [ i ] ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT ar = [ 1 , 2 , 1 , 3 , 4 , 2 , 4 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE print ( minimumSubarrays ( ar , n ) ) NEW_LINE
def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE r , i = 0 , 0 NEW_LINE while ( s ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = int ( s / 10 ) NEW_LINE freq [ r ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT xor__ = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor__ = xor__ ^ freq [ i ] NEW_LINE if ( xor__ == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m <= a [ i ] : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE m = a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE DEDENT DEDENT ans . append ( m ) NEW_LINE ans = [ ] NEW_LINE for i in ans : NEW_LINE INDENT ans . append ( str ( ( a [ i ] + m - i ) // m ) ) NEW_LINE DEDENT print ( ' ' . join ( ans ) ) NEW_LINE
MAXN = 1000005 NEW_LINE even = [ 0 ] * MAXN NEW_LINE odd = [ 0 ] * MAXN NEW_LINE def precompute ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd [ i ] = 1 NEW_LINE DEDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT even [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT even [ i ] = even [ i ] + even [ i - 1 ] NEW_LINE odd [ i ] = odd [ i ] + odd [ i - 1 ] NEW_LINE DEDENT DEDENT def isOdd ( L , R ) : NEW_LINE INDENT cnt = odd [ R ] NEW_LINE if ( L > 0 ) : NEW_LINE INDENT cnt -= odd [ L - 1 ] NEW_LINE DEDENT if ( cnt == R - L + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def performQueries ( a , n , q , m ) : NEW_LINE INDENT precompute ( a , n ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT L = q [ i ] [ 0 ] NEW_LINE R = q [ i ] [ 1 ] NEW_LINE if ( isOdd ( L , R ) ) : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 1 , 5 , 7 , 6 , 8 , 9 ] NEW_LINE n = len ( a ) NEW_LINE q = [ [ 0 , 2 ] , [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 6 ] ] NEW_LINE m = len ( q ) NEW_LINE performQueries ( a , n , q , m ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( n <= 5 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif ( n <= 7 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( j * 3 + j * 5 ) % 7 == 0 and ( j * 3 + j * 5 ) // 7 >= n : NEW_LINE INDENT print ( j , i , j ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE h , m = map ( int , input ( ) . split ( ) ) NEW_LINE t = input ( ) NEW_LINE tt = h * 60 + m NEW_LINE tt += t NEW_LINE cnt = 0 NEW_LINE for i in range ( tt , 300 ) : NEW_LINE INDENT if tt <= i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT main ( ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ 1 , 2 ] NEW_LINE x = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == x [ i + 1 ] and a [ i ] == x [ i + 2 ] : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def times ( steps , n ) : NEW_LINE INDENT current_level = 0 NEW_LINE previous_level = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT previous_level = current_level NEW_LINE current_level = current_level + steps [ i ] NEW_LINE if ( ( previous_level < 0 and current_level >= 0 ) or ( previous_level > 0 and current_level <= 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT steps = [ 1 , - 1 , 0 , 0 , 1 , 1 , - 3 , 2 ] NEW_LINE n = len ( steps ) NEW_LINE print ( times ( steps , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE H = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT h , m , n = map ( int , input ( ) . split ( ) ) NEW_LINE H . append ( h ) NEW_LINE DEDENT ans = 360 - ( H [ 0 ] * 2 ) NEW_LINE for k in range ( 1 , 122 ) : NEW_LINE INDENT for l in range ( n ) : NEW_LINE INDENT c = H [ k ] [ l ] - H [ k - 1 ] [ l ] NEW_LINE if c < ans : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT DEDENT s = ans NEW_LINE for k in range ( 1 , 122 ) : NEW_LINE INDENT s = s + 30 * ( H [ k ] [ l ] - H [ k - 1 ] [ l ] ) NEW_LINE if s > ans : NEW_LINE INDENT s = s - 30 * ( H [ k ] [ l ] - H [ k - 1 ] [ l ] ) NEW_LINE DEDENT ans = min ( ans , s ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Um_nik = 0 NEW_LINE P_max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not p [ i ] : NEW_LINE INDENT Um_nik = 1 NEW_LINE DEDENT else : NEW_LINE INDENT P_max += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT j = i NEW_LINE while not P_max % 2 == 0 : NEW_LINE INDENT P_max -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT P_max += 1 NEW_LINE DEDENT DEDENT if ( Um_nik + P_max ) % 2 == 0 : NEW_LINE INDENT print ( " Um _ nik " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Petr " ) NEW_LINE DEDENT
def smallest ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = " " NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT ans += s [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT ans = s [ 0 : l - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abcda " NEW_LINE print ( smallest ( s ) ) NEW_LINE DEDENT
import sys NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE if N == M : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
import sys NEW_LINE def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = sys . maxsize NEW_LINE found = False NEW_LINE sum = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif ( sum > k ) : NEW_LINE INDENT while ( sum > k ) : NEW_LINE INDENT sum = sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( FindMinNumber ( arr , n , k ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def nthPalindrome ( n , k ) : NEW_LINE INDENT temp = ( k // 2 ) if ( k & 1 ) else ( k // 2 - 1 ) NEW_LINE palindrome = pow ( 10 , temp ) NEW_LINE palindrome += n - 1 NEW_LINE print ( palindrome ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT palindrome = palindrome // 10 NEW_LINE DEDENT while ( palindrome > 0 ) : NEW_LINE INDENT print ( palindrome % 10 , palindrome // 10 ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE k = 5 NEW_LINE print ( n , " th palindrome of " , k , " digit = " , nthPalindrome ( n , k ) ) NEW_LINE n = 10 NEW_LINE k = 6 NEW_LINE print ( n , " th palindrome of " , k , " digit = " , nthPalindrome ( n , k ) ) NEW_LINE DEDENT
n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if i > n - 1 : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , x * i + a [ i ] + x * ( i + 1 ) + x * ( n - i ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
MAX = 10000 NEW_LINE hashTable = [ 0 ] * MAX NEW_LINE def minOperations ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hashTable [ arr [ i ] ] != 0 ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT hashTable [ arr [ j ] ] = 0 NEW_LINE DEDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( a , b ) * min ( c , d ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT numer = 1 NEW_LINE denom = 1 NEW_LINE for d in range ( 10 , 100 ) : NEW_LINE INDENT for n in range ( 10 , d ) : NEW_LINE INDENT n0 = n % 10 NEW_LINE n1 = n // 10 NEW_LINE d0 = d % 10 NEW_LINE d1 = d // 10 NEW_LINE if ( n1 == d0 and n0 * d == n * d1 or n0 == d1 and n1 * d == n * d0 ) : NEW_LINE INDENT numer *= n NEW_LINE denom *= d NEW_LINE DEDENT DEDENT DEDENT return str ( denom // eulerlib . gcd ( numer , denom ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countOfOddsPascal ( n ) : NEW_LINE INDENT c = countSetBits ( n ) NEW_LINE return int ( pow ( 2 , c ) ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddsPascal ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( x , a - 1 - x ) * b , max ( y , b - 1 - y ) ) NEW_LINE DEDENT
def minSwaps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arrpos = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrpos [ i ] . append ( ( arr [ i ] , i ) ) NEW_LINE DEDENT arrpos . sort ( ) NEW_LINE arrpos . sort ( ) NEW_LINE arrpos . reverse ( ) NEW_LINE vis = [ False ] * n NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] or arrpos [ i ] [ 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while ( not vis [ j ] ) : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = arrpos [ j ] [ 1 ] NEW_LINE cycle_size += 1 NEW_LINE DEDENT if ( cycle_size > 0 ) : NEW_LINE INDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 5 , 4 , 3 , 2 ] NEW_LINE print ( minSwaps ( a ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE N = 1000005 NEW_LINE prime = [ True ] * N ; NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( i * 2 , N , i ) : NEW_LINE INDENT prime [ j ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumTruncatablePrimes ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT num = i ; NEW_LINE flag = True ; NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( not prime [ num ] ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT num //= 10 ; NEW_LINE DEDENT num = i ; NEW_LINE power = 10 ; NEW_LINE while ( num // power > 0 ) : NEW_LINE INDENT if ( not prime [ num % power ] ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT power *= 10 ; NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 25 ; NEW_LINE sieve ( ) ; NEW_LINE print ( sumTruncatablePrimes ( n ) ) ; NEW_LINE DEDENT
def find weights ( X ) : NEW_LINE INDENT sum = 0 NEW_LINE power = 0 NEW_LINE number = 3 NEW_LINE while ( sum < X ) : NEW_LINE INDENT sum = number - 1 NEW_LINE sum = sum // 2 NEW_LINE power += 1 NEW_LINE number *= 3 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 1 , power + 1 ) : NEW_LINE INDENT print ( ans , end = " " ) NEW_LINE ans = ans * 3 NEW_LINE DEDENT DEDENT X = 2 NEW_LINE find weights ( X ) NEW_LINE
def addToArrayForm ( A , K ) : NEW_LINE INDENT v = [ ] NEW_LINE ans = [ ] NEW_LINE rem = 0 NEW_LINE i = 0 NEW_LINE for i in range ( len ( A ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT my = A [ i ] + K % 10 + rem NEW_LINE if my > 9 : NEW_LINE INDENT rem = 1 NEW_LINE v . append ( my % 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( my ) NEW_LINE rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT while K > 0 : NEW_LINE INDENT my = K % 10 + rem NEW_LINE v . append ( my % 10 ) NEW_LINE if my > 0 : NEW_LINE INDENT rem = 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT if rem > 0 : NEW_LINE INDENT v . append ( rem ) NEW_LINE DEDENT for j in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans . append ( v [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 2 , 7 , 4 , 2 , 181 ] NEW_LINE K = 181 NEW_LINE ans = addToArrayForm ( A , K ) NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def printPaths ( input , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( input , " " , 0 , i , R , C ) ; NEW_LINE print ( ) ; NEW_LINE DEDENT DEDENT def dfs ( input , res , i , j , R , C ) : NEW_LINE INDENT if ( i == R ) : NEW_LINE INDENT print ( res + " " , end = " " ) ; NEW_LINE return ; NEW_LINE DEDENT res = res + input [ i ] [ j ] ; NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( input , res , i + 1 , k , R , C ) ; NEW_LINE if ( i + 1 == R ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = [ [ ' a ' , ' b ' ] , [ ' d ' , ' e ' ] ] ; NEW_LINE R = len ( input [ 0 ] ) ; NEW_LINE C = len ( input [ 0 ] ) ; NEW_LINE printPaths ( input , R , C ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if s == " RL " : NEW_LINE INDENT s = " " NEW_LINE DEDENT elif s == " L " : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE DEDENT res = s . count ( " R " ) NEW_LINE if s == " R " : NEW_LINE INDENT res += "1" * ( n - len ( s ) ) NEW_LINE DEDENT print ( res ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if a == c and b == d : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT elif a == c and b == d : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT elif a == d and b == c : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT
def precisionCompute ( x , y , n ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT print ( " Infinite " ) NEW_LINE return NEW_LINE DEDENT if ( x == 0 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE return NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT print ( int ( x / y ) ) NEW_LINE return NEW_LINE DEDENT if ( ( ( x > 0 ) and ( y < 0 ) ) or ( ( x < 0 ) and ( y > 0 ) ) ) : NEW_LINE INDENT print ( " - " , end = " " ) NEW_LINE x = - x NEW_LINE y = - y NEW_LINE DEDENT d = int ( x / y ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE x = x - ( y * d ) NEW_LINE if ( x == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT x = x * 10 NEW_LINE d = int ( x / y ) NEW_LINE if ( i == 0 ) : NEW_LINE INDENT print ( " . " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT x = 22 NEW_LINE y = 7 NEW_LINE n = 15 NEW_LINE precisionCompute ( x , y , n ) NEW_LINE print ( ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( lcm , arr [ i ] ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectCube ( arr , n ) : NEW_LINE INDENT minPerfectCube = 0 NEW_LINE lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectCube = lcm NEW_LINE cnt = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT if ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= 2 NEW_LINE DEDENT elif ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= 4 NEW_LINE DEDENT i = 3 NEW_LINE while ( lcm > 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( lcm % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= i NEW_LINE DEDENT if ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= i * i NEW_LINE DEDENT elif ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectCube NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 125 , 14 , 42 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectCube ( arr , n ) ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printSpecificLevelOrderUtil ( root , s ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root . left ) NEW_LINE q . append ( root . right ) NEW_LINE first = None NEW_LINE second = None NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT first = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE second = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE s . append ( second . left ) NEW_LINE s . append ( first . right ) NEW_LINE s . append ( second . right ) NEW_LINE s . append ( first . left ) NEW_LINE if ( first . left != None ) : NEW_LINE INDENT q . append ( first . right ) NEW_LINE q . append ( second . left ) NEW_LINE s . append ( first . left ) NEW_LINE q . append ( second . right ) NEW_LINE DEDENT DEDENT def printSpecificLevelOrder ( root ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( root ) NEW_LINE if ( root . left != None ) : NEW_LINE INDENT s . append ( root . right ) NEW_LINE s . append ( root . left ) NEW_LINE DEDENT if ( root . left != None ) : NEW_LINE INDENT printSpecificLevelOrderUtil ( root , s ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT print ( s [ - 1 ] . data , end = " " ) NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE print ( " I am not clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear clear
def h setSquare ( rows ) : NEW_LINE INDENT for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT if ( i == 1 or i == rows ) : NEW_LINE INDENT for j in range ( 1 , rows + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT elif ( j == 1 or j == rows ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " " , end = " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT def setPattern ( rows ) : NEW_LINE INDENT print ( " Solid Square : " ) NEW_LINE setSquare ( rows ) NEW_LINE print ( " Hollow Square : " ) NEW_LINE h setSquare ( rows ) NEW_LINE DEDENT rows = 5 NEW_LINE setPattern ( rows ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = " a " NEW_LINE while n > 0 : NEW_LINE INDENT ans = ans + " ab " * ( n // 4 ) NEW_LINE n -= 1 NEW_LINE DEDENT if n > 0 : NEW_LINE INDENT ans = ans + " abc " * ( ( n - 1 ) // 4 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE dp = [ [ float ( " inf " ) for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE dp [ i + 1 ] [ 0 ] = min ( dp [ i + 1 ] [ 0 ] , dp [ i ] [ 1 ] + y ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = min ( dp [ i - 1 ] [ 1 ] , dp [ i ] [ 0 ] + x ) NEW_LINE DEDENT print ( max ( dp [ n ] ) ) NEW_LINE
a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE if ( x < a ) or ( x > b + x ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
from math import gcd NEW_LINE def findLargest ( arr , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = gcd ( arr [ i ] , gcd ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 6 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findLargest ( arr , n ) ) NEW_LINE DEDENT
def findWinner ( n ) : NEW_LINE INDENT if ( ( n - 1 ) % 6 == 0 ) : NEW_LINE INDENT print ( " Second Player wins the game " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First Player wins the game " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE findWinner ( n ) NEW_LINE DEDENT
def Breadth ( v ) : NEW_LINE INDENT global V , adj NEW_LINE adj = [ [ ] for i in range ( v ) ] NEW_LINE DEDENT def addEdge ( v , w ) : NEW_LINE INDENT adj [ v ] . append ( w ) NEW_LINE DEDENT def Bfs ( s ) : NEW_LINE INDENT visited = [ False ] * V NEW_LINE visited [ s ] = True NEW_LINE queue = [ ] NEW_LINE while ( len ( queue ) != 0 ) : NEW_LINE INDENT s = queue . pop ( ) NEW_LINE print ( s , end = " " ) NEW_LINE for i in adj [ s ] : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT visited [ i ] = True NEW_LINE queue . append ( i ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = Graph ( 4 ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( " Following is Breadth First Traversal " + " ( starting from vertex 2 ) " ) NEW_LINE Breadth ( 2 ) NEW_LINE DEDENT
def Breadth ( v ) : NEW_LINE INDENT global V , adj NEW_LINE adj = [ [ ] for i in range ( v ) ] NEW_LINE DEDENT def addEdge ( v , w ) : NEW_LINE INDENT adj [ v ] . append ( w ) NEW_LINE DEDENT def Bfs ( s ) : NEW_LINE INDENT visited = [ False ] * V NEW_LINE visited [ s ] = True NEW_LINE queue = [ ] NEW_LINE while ( len ( queue ) != 0 ) : NEW_LINE INDENT s = queue . pop ( ) NEW_LINE print ( s , end = " " ) NEW_LINE for i in adj [ s ] : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT visited [ i ] = True NEW_LINE queue . append ( i ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = Graph ( 4 ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( " Following is Breadth First Traversal " + " ( starting from vertex 2 ) " ) NEW_LINE Breadth ( 2 ) NEW_LINE DEDENT
def kmp ( a , arr , n ) : NEW_LINE INDENT elements = [ 0 ] * ( n + 1 ) ; NEW_LINE elements [ 0 ] = a ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 13 , 2 , 6 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE a = 5 ; NEW_LINE kmp ( a , arr , n ) ; NEW_LINE DEDENT
import sys NEW_LINE def solve ( n , r , p , s ) : NEW_LINE INDENT k = { " P " : 0 , " R " : 0 , " S " : 0 , " P " : 0 , " R " : 0 , " S " : 0 } NEW_LINE for c in range ( 1 , n + 1 ) : NEW_LINE INDENT t = " . " NEW_LINE if c in k : NEW_LINE INDENT t += k [ c ] NEW_LINE DEDENT elif c == r and c == p and c == s : NEW_LINE INDENT t += " S " NEW_LINE DEDENT elif c == p and c == r and c == s : NEW_LINE INDENT t += " P " NEW_LINE DEDENT elif c == r and c == s : NEW_LINE INDENT t += " R " NEW_LINE DEDENT elif c == p and c == r and c == s : NEW_LINE INDENT t += " S " NEW_LINE DEDENT DEDENT return t NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 10000 ) NEW_LINE T = int ( input ( ) ) NEW_LINE for X in range ( 1 , T + 1 ) : NEW_LINE INDENT n , r , p , s = [ int ( c ) for c in input ( ) . split ( ) ] NEW_LINE print ( " Case # { } : { } " . format ( X , solve ( n , r , p , s ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( [ a , b ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if n % 2 == 0 and i == n // 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif i == n // 2 and i == n // 2 : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT elif i == n // 2 and i == n // 2 : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT elif i == n // 2 and i == n // 2 : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
from math import sqrt NEW_LINE def printRepeating ( arr , size ) : NEW_LINE INDENT S = 0 NEW_LINE P = 1 NEW_LINE x , y = 0 , 0 NEW_LINE n = size - 2 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE DEDENT S = S - n * ( n + 1 ) // 2 NEW_LINE P = P // fact ( n ) NEW_LINE D = int ( sqrt ( S * S - 4 * P ) ) NEW_LINE x = ( D + S ) // 2 NEW_LINE y = ( S - D ) // 2 NEW_LINE print ( " The two repeating elements are : " , end = " " ) NEW_LINE print ( x , end = " " ) NEW_LINE print ( " & " , end = " " ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT return 1 if n == 0 else n * fact ( n - 1 ) NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE
import math NEW_LINE Q_MAX = 2 << 15 NEW_LINE def primes ( n ) : NEW_LINE INDENT p = [ True ] * ( n + 1 ) NEW_LINE p [ 0 ] = p [ 1 ] = False NEW_LINE for i in range ( 2 , int ( math . sqrt ( n + 1 ) ) ) : NEW_LINE INDENT if p [ i ] : NEW_LINE INDENT for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT p [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return p NEW_LINE DEDENT P = [ i for i , x in enumerate ( primes ( Q_MAX ) ) if x ] NEW_LINE while True : NEW_LINE INDENT q = int ( input ( ) ) NEW_LINE if q == 0 : break NEW_LINE count = 0 NEW_LINE for p in P : NEW_LINE INDENT if p > q / 2 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( q - 1 , 0 , - 1 ) : NEW_LINE INDENT if p * i == q : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE info = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = info [ i ] NEW_LINE info [ i ] = ( math . atan2 ( y - x , x ) , x , y ) NEW_LINE DEDENT info = sorted ( info ) NEW_LINE info = info + info NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = info [ i ] NEW_LINE a , b = info [ i + 1 ] NEW_LINE if a >= b : NEW_LINE INDENT x , y = b , info [ i + 1 ] NEW_LINE DEDENT ans = max ( ans , ( info [ i + 1 ] - info [ i ] ) / ( 2 * math . pi ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def solve ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' qwertyuiopasdfghjklzxcvbnm ' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif c == ' q ' or c == ' wxyzABC ' or c == ' xvVVWXYZ ' or c == ' befghijklmnopqrstuvwxyz ' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " # " : NEW_LINE INDENT break NEW_LINE DEDENT print ( solve ( s ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE f = s . count ( " S " ) NEW_LINE s = s . replace ( " F " , " " ) NEW_LINE s = s . replace ( " S " , " " ) NEW_LINE if s . count ( " F " ) < 2 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( a [ 0 ] * a [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT min_ = max ( a [ 0 ] * a [ 1 ] , a [ 1 ] * a [ 0 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if a [ i - 1 ] > a [ i ] * a [ i + 1 ] and a [ i ] > min_ : NEW_LINE INDENT min_ = a [ i ] * a [ i + 1 ] NEW_LINE DEDENT DEDENT print ( min_ ) NEW_LINE DEDENT DEDENT
def FindLCM ( a , b ) : NEW_LINE INDENT return ( a * b ) // ( a * b ) // ( a * b ) NEW_LINE DEDENT def rangeDivisor ( m , n , a , b ) : NEW_LINE INDENT lcm = FindLCM ( a , b ) NEW_LINE a_divisor = n // a - ( m - 1 ) // a NEW_LINE b_divisor = n // b - ( m - 1 ) // b NEW_LINE common_divisor = n // lcm - ( m - 1 ) // lcm NEW_LINE ans = a_divisor + b_divisor - common_divisor NEW_LINE return ans NEW_LINE DEDENT m = 3 NEW_LINE n = 11 NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) NEW_LINE m = 11 NEW_LINE n = 1000000 NEW_LINE a = 6 NEW_LINE b = 35 NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) NEW_LINE
s = input ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] . isalpha ( ) : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE DEDENT elif s [ i ] == ' . ' or s [ i ] == ' ? ' : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE DEDENT DEDENT if len ( ans ) == 1 : NEW_LINE INDENT ans . append ( s [ 0 ] ) NEW_LINE DEDENT elif len ( ans ) == 2 : NEW_LINE INDENT ans . append ( s [ 1 ] ) NEW_LINE DEDENT elif len ( ans ) == 3 : NEW_LINE INDENT ans . append ( s [ 2 ] ) NEW_LINE DEDENT elif len ( ans ) == 4 : NEW_LINE INDENT ans . append ( s [ 1 ] ) NEW_LINE DEDENT elif len ( ans ) == 5 : NEW_LINE INDENT ans . append ( s [ 2 ] ) NEW_LINE DEDENT elif len ( ans ) == 6 : NEW_LINE INDENT ans . append ( s [ 3 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( s [ 4 ] ) NEW_LINE DEDENT s = " " . join ( list ( map ( str , ans ) ) ) NEW_LINE print ( s ) NEW_LINE
import sys NEW_LINE def smallestKFreq ( a , n , k ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] = m . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT res = sys . maxsize NEW_LINE for s in m : NEW_LINE INDENT if m [ s ] == k : NEW_LINE INDENT res = min ( res , s ) NEW_LINE DEDENT DEDENT if res != sys . maxsize : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 2 , 1 , 3 , 1 ] NEW_LINE k = 2 NEW_LINE print ( smallestKFreq ( arr , len ( arr ) , k ) ) NEW_LINE DEDENT
def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = chr ( 64 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' i ' or s [ i ] == ' o ' or s [ i ] == ' u ' ) : NEW_LINE INDENT if ( s [ i ] < c ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabbbddeecc " NEW_LINE if ( areVowelsInOrder ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def solve ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = [ 1 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if A [ i ] % 2 == 1 : NEW_LINE INDENT A [ i ] = min ( A [ i ] , A [ i - 1 ] + A [ i - 1 ] ) NEW_LINE DEDENT DEDENT B = [ 1 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if B [ i ] % 2 == 1 : NEW_LINE INDENT B [ i ] = min ( B [ i ] , B [ i - 1 ] + A [ i - 1 ] ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( * solve ( n ) ) NEW_LINE DEDENT
def countOfLetters ( string ) : NEW_LINE INDENT letter = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ( string [ i ] >= ' A ' and string [ i ] <= ' Z ' ) or ( string [ i ] >= ' a ' and string [ i ] <= ' z ' ) ) : NEW_LINE INDENT letter += 1 NEW_LINE DEDENT DEDENT return letter NEW_LINE DEDENT def countOfNumbers ( string ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] >= '0' and string [ i ] <= '9' ) : NEW_LINE INDENT number += 1 NEW_LINE DEDENT DEDENT return number NEW_LINE DEDENT def check ( string ) : NEW_LINE INDENT if ( countOfLetters ( string ) == countOfNumbers ( string ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeKs01324" NEW_LINE check ( string ) NEW_LINE DEDENT
ans = [ 0 ] * 10 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT ans [ int ( input ( ) ) ] += 1 NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( * ans , sep = " \n " ) NEW_LINE
from collections import deque NEW_LINE n , x = map ( int , input ( ) . split ( ) ) NEW_LINE q = deque ( [ 1 ] ) NEW_LINE if x > 1 : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT if x >= 2 * n : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE q . append ( x ) NEW_LINE DEDENT elif x == 1 : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE q . appendleft ( x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT q . append ( - 1 ) NEW_LINE if q [ 0 ] == - 1 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE q . appendleft ( x ) NEW_LINE DEDENT DEDENT
MAX = 100001 NEW_LINE perfectDiv = [ 0 ] * MAX NEW_LINE def precomputeCounts ( ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i < MAX : NEW_LINE INDENT for j in range ( i * i , MAX , i * i ) : NEW_LINE INDENT perfectDiv [ j ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT return perfectDiv [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT precomputeCounts ( ) NEW_LINE n = 16 NEW_LINE print ( " Total perfect divisors of " , n , " = " , countPerfectDivisors ( n ) ) NEW_LINE n = 12 NEW_LINE print ( " Total perfect divisors of " , n , " = " , countPerfectDivisors ( n ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE suma = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT suma += a [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT sumb += b [ i ] NEW_LINE DEDENT print ( suma * sumb ) NEW_LINE
n = int ( input ( ) ) NEW_LINE t , e = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x [ i ] * t > e : NEW_LINE INDENT print ( i + 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE
from math import ceil NEW_LINE def cal_ist ( h , r ) : NEW_LINE INDENT IST = ( h * r * 1.0 ) / 360 NEW_LINE int_ dic = int ( IST ) NEW_LINE float_ dic = ceil ( ( IST - int_ dic ) * 60 ) NEW_LINE print ( int_ dic , " : " , float_ dic ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT h = 20 NEW_LINE r = 150 NEW_LINE cal_ist ( h , r ) NEW_LINE DEDENT
from math import * NEW_LINE def printRoots ( n ) : NEW_LINE INDENT theta = pi * 2 / n NEW_LINE for k in range ( n ) : NEW_LINE INDENT real = cos ( k * theta ) NEW_LINE img = sin ( k * theta ) NEW_LINE print ( f " { real : . 3 f } " , end = " " ) NEW_LINE if ( img >= 0 ) : NEW_LINE INDENT print ( " + i " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - i " , end = " " ) NEW_LINE DEDENT print ( f " { abs ( img ) : . 3 f } " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT printRoots ( 1 ) NEW_LINE printRoots ( 2 ) NEW_LINE printRoots ( 3 ) NEW_LINE DEDENT
def findOrder ( arr1 , arr2 , n , n1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n1 ) : NEW_LINE INDENT print ( " { " , arr1 [ i ] , " , " , arr2 [ j ] , " } , " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE findOrder ( arr1 , arr2 , n1 , n2 ) NEW_LINE
def no_of_ways ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count_left = 0 NEW_LINE count_right = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == s [ 0 ] ) : NEW_LINE INDENT count_left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ n - 1 ] ) : NEW_LINE INDENT count_right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ n - 1 ] ) : NEW_LINE INDENT return ( ( count_left + 1 ) * ( count_right + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( count_left + count_right + 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( no_of_ways ( s ) ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE SumOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def solve ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE solve ( arr , n , k ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = True NEW_LINE prime [ 0 ] = True NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT def productOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( product ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] NEW_LINE productOfKthPrimes ( arr , n , k ) NEW_LINE DEDENT
def findAllSequences ( diff , out , start , end ) : NEW_LINE INDENT if ( abs ( diff ) > ( end - start + 1 ) / 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT if ( diff == 0 ) : NEW_LINE INDENT out = out + '0' * ( len ( out ) - 1 ) NEW_LINE print ( " " . join ( out ) ) NEW_LINE DEDENT return NEW_LINE DEDENT out [ start ] = '0' NEW_LINE out [ end ] = '1' NEW_LINE findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = '1' NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = '0' NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = '1' NEW_LINE findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) NEW_LINE print ( " " . join ( out ) ) NEW_LINE DEDENT n = 2 NEW_LINE out = [ ' ' ] * ( 2 * n + 1 ) NEW_LINE out [ 2 * n ] = ' - ' NEW_LINE findAllSequences ( 0 , out , 0 , 2 * n - 1 ) NEW_LINE print ( " " . join ( out ) ) NEW_LINE
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l , r = 0 , n NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > h : NEW_LINE INDENT h -= a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT r = i + 1 NEW_LINE break NEW_LINE DEDENT flag = 0 NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT r = i + 1 NEW_LINE DEDENT print ( r ) NEW_LINE
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = " - > " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( " NULL " ) NEW_LINE DEDENT def cntNodes ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + cntNodes ( node . next ) ) NEW_LINE DEDENT def updateList ( head , m ) : NEW_LINE INDENT cnt = cntNodes ( head ) NEW_LINE if ( cnt != m and m < cnt ) : NEW_LINE INDENT skip = cnt - m NEW_LINE prev = None NEW_LINE curr = head NEW_LINE while ( skip > 0 ) : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE skip -= 1 NEW_LINE DEDENT prev . next = None NEW_LINE tempHead = head NEW_LINE head = curr NEW_LINE while ( curr . next != None ) : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT curr . next = tempHead NEW_LINE DEDENT printList ( head ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT head = Node ( 4 ) NEW_LINE head . next = Node ( 5 ) NEW_LINE head . next . next = Node ( 6 ) NEW_LINE head . next . next . next = Node ( 1 ) NEW_LINE head . next . next . next = Node ( 2 ) NEW_LINE head . next . next . next = Node ( 2 ) NEW_LINE head . next . next . next . next = Node ( 3 ) NEW_LINE m = 3 NEW_LINE updateList ( head , m ) NEW_LINE DEDENT
def maxSubStrings ( s , k ) : NEW_LINE INDENT maxSubStr = 0 NEW_LINE n = len ( s ) NEW_LINE for c in range ( 26 ) : NEW_LINE INDENT ch = chr ( ord ( ' a ' ) + c ) NEW_LINE curr = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT if ( s [ i ] != ch ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE while ( i < n and s [ i ] == ch and cnt != k ) : NEW_LINE INDENT i += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE if ( cnt == k ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT DEDENT maxSubStr = max ( maxSubStr , curr ) NEW_LINE DEDENT return maxSubStr NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaacaabbaa " NEW_LINE k = 2 NEW_LINE print ( maxSubStrings ( s , k ) ) NEW_LINE DEDENT
def ansQueries ( prefeven , prefodd , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * 100 NEW_LINE prefeven = [ 0 ] * 100 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i ) % 2 == 0 ) : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = [ 2 , 3 , 4 ] NEW_LINE q = len ( l ) NEW_LINE wrapper ( arr , n , l , r , q ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE mops = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mops . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = 0 NEW_LINE if mops [ i ] <= mops [ i - 1 ] : NEW_LINE INDENT a = mops [ i - 1 ] - mops [ i ] NEW_LINE DEDENT ans += a NEW_LINE DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT sum += a [ n // 2 - i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT
from collections import deque NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE st = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . append ( deque ( input ( ) . split ( ) ) ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT query = st [ i ] [ 1 ] NEW_LINE if query == 0 : NEW_LINE INDENT if st [ i ] [ 0 ] == '0' : NEW_LINE INDENT st [ i ] . appendleft ( st [ i ] [ 1 ] ) NEW_LINE DEDENT elif query == 1 : NEW_LINE INDENT print ( st [ i ] [ 0 ] ) NEW_LINE DEDENT elif query == 2 : NEW_LINE INDENT if st [ i ] [ 0 ] == '1' : NEW_LINE INDENT print ( st [ i ] [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT st [ i ] . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT maxVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) NEW_LINE DEDENT else removeFromMax ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE modifyArray ( arr , n , k ) NEW_LINE DEDENT
def find_Cent cur cur cur_pos ( v ) : NEW_LINE INDENT ans = [ 0 ] * 2 ; NEW_LINE n = len ( v ) ; NEW_LINE sign = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x0 , y0 = v [ i ] ; NEW_LINE x1 , y1 = v [ ( i + 1 ) % n ] [ 0 ] , v [ ( i + 1 ) % n ] [ 1 ] ; NEW_LINE A = ( x0 * y1 ) - ( x1 * y0 ) ; NEW_LINE sign += A ; NEW_LINE sign += A ; NEW_LINE ans [ 0 ] += ( x0 + x1 ) * A ; NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A ; NEW_LINE DEDENT sign *= 0.5 ; NEW_LINE ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * sign ) ; NEW_LINE ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * sign ) ; NEW_LINE return ans ; NEW_LINE DEDENT vp = [ [ 1 , 2 ] , [ 3 , - 4 ] , [ 6 , - 7 ] ] ; NEW_LINE ans = find_Cent cur_pos ( vp ) ; NEW_LINE print ( str ( ans [ 0 ] ) + " " + str ( ans [ 1 ] ) ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT s1 = " blue " NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT print ( s1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] != s [ i + 1 ] : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( s1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE DEDENT DEDENT
def minOperations ( ar , k ) : NEW_LINE INDENT ar . sort ( ) NEW_LINE opsNeeded = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT opsNeeded += ar [ k - 1 ] - ar [ i ] NEW_LINE DEDENT ans = opsNeeded NEW_LINE for i in range ( k , len ( ar ) ) : NEW_LINE INDENT opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) NEW_LINE opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) NEW_LINE ans = min ( ans , opsNeeded ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 1 , 9 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minOperations ( arr , k ) ) NEW_LINE DEDENT
def charCheck ( input_char ) : NEW_LINE INDENT if ( ( input_char >= 65 and input_char <= 90 ) or ( input_char >= 97 and input_char <= 122 ) ) : NEW_LINE INDENT print ( " Alphabet " ) NEW_LINE DEDENT elif ( input_char >= 48 and input_char <= 57 ) : NEW_LINE INDENT print ( " Digit " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Special Character " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input_char = ' $ ' NEW_LINE charCheck ( input_char ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l1 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = l . index ( l [ i ] ) NEW_LINE l1 . append ( l [ i ] ) NEW_LINE while k != 0 : NEW_LINE INDENT print ( k , end = " " ) NEW_LINE k = k - 1 NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = dict ( ) NEW_LINE ans = 3000003 NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d [ a ] = [ b ] NEW_LINE for i in d [ b ] : NEW_LINE INDENT if i in d . keys ( ) : NEW_LINE INDENT ans = min ( ans , p [ i ] + p [ b ] + p [ i ] ) NEW_LINE DEDENT DEDENT d [ a ] . append ( b ) NEW_LINE d [ b ] . append ( a ) NEW_LINE DEDENT print ( ans if ans < 3000003 else - 1 ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = 0 NEW_LINE while a [ i ] > 0 and a [ i ] >= i + k : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE while a [ i ] > 0 and a [ i ] >= i + k : NEW_LINE INDENT i += 1 NEW_LINE DEDENT a [ i ] -= 1 NEW_LINE DEDENT print ( * a ) NEW_LINE
n = int ( input ( ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( c [ i ] ) : NEW_LINE INDENT ans . append ( [ i + 1 , j + 1 , c [ i ] [ j ] ] ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE ans1 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( c [ i ] ) : NEW_LINE INDENT if ans [ i ] [ j ] == ans1 [ i ] [ j ] : NEW_LINE INDENT ans1 . append ( [ i + 1 , j + 1 , c [ i ] [ j ] ] ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( ans1 ) ) NEW_LINE print ( * ans1 ) NEW_LINE
def sameOccurrence ( arr , n , x , y ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ctX = 0 NEW_LINE ctY = 0 NEW_LINE for j in range ( i , n - 1 ) : NEW_LINE INDENT if ( arr [ j ] == x ) : NEW_LINE INDENT ctX += 1 NEW_LINE DEDENT elif ( arr [ j ] == y ) : NEW_LINE INDENT ctY += 1 NEW_LINE DEDENT if ( ctX == ctY ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE x , y = 2 , 3 NEW_LINE print ( sameOccurrence ( arr , n , x , y ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = s . count ( '1' ) NEW_LINE b = s . count ( '0' ) NEW_LINE if ( a > b ) : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT elif ( b > a ) : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a - 1 ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c == n : NEW_LINE INDENT print ( " Conan " ) NEW_LINE DEDENT elif c % 2 == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( " Agasa " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Conan " ) NEW_LINE DEDENT
a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT
target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT toFind = target // ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if arr [ k ] == toFind : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( " Total number of triplets found : " , totalCount ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE print ( 0 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 2 , 1 ) NEW_LINE print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE print ( - a [ 0 ] ) NEW_LINE print ( 1 , n ) NEW_LINE print ( 0 , * a [ 1 : ] , * ( - n * a [ 1 : ] ) , sep = ' ' ) NEW_LINE DEDENT
from math import gcd NEW_LINE def finalNum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = gcd ( result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 9 , 6 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( finalNum ( arr , n ) ) NEW_LINE DEDENT
N = 1000 NEW_LINE def lastElement ( a , n ) : NEW_LINE INDENT steps = 1 NEW_LINE v = [ [ ] for i in range ( N ) ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT v [ steps ] . append ( a [ i ] | a [ i + 1 ] ) NEW_LINE DEDENT while ( len ( v [ steps ] ) > 1 ) : NEW_LINE INDENT steps += 1 NEW_LINE for i in range ( len ( v [ steps - 1 ] ) ) : NEW_LINE INDENT if ( steps % 2 == 1 ) : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] | v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return v [ steps ] [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE index = 0 NEW_LINE value = 2 NEW_LINE a [ 0 ] = 2 NEW_LINE print ( lastElement ( a , n ) ) NEW_LINE index = 3 NEW_LINE value = 5 NEW_LINE a [ index ] = value NEW_LINE print ( lastElement ( a , n ) ) NEW_LINE DEDENT
def number_cake ( n ) : NEW_LINE INDENT return ( n * n * n + 5 * n + 6 ) // 6 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 8 NEW_LINE print ( number_cake ( n ) ) NEW_LINE n = 25 NEW_LINE print ( number_cake ( n ) ) NEW_LINE DEDENT
import bisect NEW_LINE import heapq NEW_LINE import math NEW_LINE import random NEW_LINE import sys NEW_LINE from collections import Counter , defaultdict , deque NEW_LINE from decimal import ROUND_CEILING , ROUND_HALF_UP , Decimal NEW_LINE from functools import lru_cache , reduce NEW_LINE from itertools import combinations , combinations_with_replacement , product , permutations NEW_LINE from operator import add , mul , sub NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE def read_int ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def read_int_n ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def read_float ( ) : NEW_LINE INDENT return float ( input ( ) ) NEW_LINE DEDENT def read_float_n ( ) : NEW_LINE INDENT return list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE DEDENT def read_str ( ) : NEW_LINE INDENT return input ( ) . strip ( ) NEW_LINE DEDENT def read_str_n ( ) : NEW_LINE INDENT return list ( map ( str , input ( ) . split ( ) ) ) NEW_LINE DEDENT def error_print ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT def mt ( f ) : NEW_LINE INDENT import time NEW_LINE def wrap ( * args , ** kwargs ) : NEW_LINE INDENT s = time . time ( ) NEW_LINE ret = f ( * args , ** kwargs ) NEW_LINE e = time . time ( ) NEW_LINE error_print ( e - s , ' sec ' ) NEW_LINE return ret NEW_LINE DEDENT return wrap NEW_LINE DEDENT @ mt NEW_LINE def slv ( S ) : NEW_LINE INDENT p = S . count ( ' p ' ) NEW_LINE return len ( S ) // 2 - p NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT S = read_str ( ) NEW_LINE print ( slv ( ' ' . join ( S ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def pattern ( N ) : NEW_LINE INDENT k = 0 NEW_LINE space = 1 NEW_LINE rows = N NEW_LINE for i in range ( rows , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT if i != rows : NEW_LINE INDENT for k in range ( 1 , space + 1 ) : NEW_LINE INDENT print ( " " , end = " " ) NEW_LINE DEDENT space = space + 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if j != rows : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT N = 6 NEW_LINE pattern ( N ) NEW_LINE
def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) // 2 NEW_LINE high = ( n + 1 - k ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE k = 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n = 9 NEW_LINE k = 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def pathSum ( self , rootData ) : NEW_LINE INDENT if rootData == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ [ - 1 ] * 3 for _ in range ( 3 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE return dp [ 0 ] [ 1 ] NEW_LINE DEDENT def pathSum helper ( self , root , target , soFar ) : NEW_LINE INDENT if root != None : NEW_LINE INDENT complement = soFar + root . val - target NEW_LINE if complement in dp : NEW_LINE INDENT result += dp [ complement ] [ 0 ] NEW_LINE dp [ soFar + root . val ] [ 0 ] += 1 NEW_LINE DEDENT self . pathSum helper ( root . left , target , soFar + root . val ) NEW_LINE self . pathSum helper ( root . right , target , soFar + root . val ) NEW_LINE dp [ soFar + root . val ] [ 0 ] -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE root = TreeNode ( 10 ) NEW_LINE root . left = TreeNode ( 5 ) NEW_LINE root . right = TreeNode ( - 3 ) NEW_LINE root . left . left = TreeNode ( 3 ) NEW_LINE root . left . right = TreeNode ( 2 ) NEW_LINE root . right . right = TreeNode ( 11 ) NEW_LINE root . left . left = TreeNode ( 3 ) NEW_LINE root . left . left . right = TreeNode ( - 2 ) NEW_LINE root . left . right . right = TreeNode ( 1 ) NEW_LINE _ , out = sObj . pathSum ( root , _ , _ ) NEW_LINE print ( out ) NEW_LINE DEDENT
def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10000000 ) NEW_LINE def solve ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE s1 = int ( s [ : 2 ] ) NEW_LINE s2 = int ( s [ 2 : ] ) NEW_LINE if s1 > s2 : NEW_LINE INDENT ans . append ( s1 ) NEW_LINE DEDENT DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for case in range ( 1 , n + 1 ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = solve ( n ) NEW_LINE print ( ' Case { 0 } : { 1 } ' . format ( case , ans ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
import math NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n + 1 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) NEW_LINE DEDENT DEDENT return maxVal NEW_LINE DEDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxOR ( arr , n ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def numJewelsInStones ( self , J , S ) : NEW_LINE INDENT result = 0 NEW_LINE jHash = dict ( ) NEW_LINE for j in range ( len ( J ) ) : NEW_LINE INDENT jHash [ J [ j ] ] = 1 NEW_LINE DEDENT for s in range ( len ( S ) ) : NEW_LINE INDENT if S [ s ] in jHash : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE J = ' aA ' NEW_LINE S = ' aAAb solves ' NEW_LINE out = sObj . numJewelsInStones ( J , S ) NEW_LINE print ( out ) NEW_LINE DEDENT
MAX = 100 NEW_LINE store = [ 0 ] * MAX NEW_LINE graph = [ [ 0 ] * MAX ] NEW_LINE d = [ 0 ] * MAX NEW_LINE def is_clique ( b ) : NEW_LINE INDENT for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( i + 1 , b ) : NEW_LINE INDENT if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT return True NEW_LINE DEDENT def maxCliques ( i , l ) : NEW_LINE INDENT max_ = 0 NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT store [ l ] = j NEW_LINE if ( is_clique ( l + 1 ) ) : NEW_LINE INDENT max_ = max ( max_ , l ) NEW_LINE max_ = max ( max_ , max_ , max_clique ( j , l + 1 ) ) NEW_LINE DEDENT DEDENT return max_ NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 1 ] , [ 4 , 2 ] ] NEW_LINE size = len ( edges ) NEW_LINE n = 4 NEW_LINE for i in range ( size ) : NEW_LINE INDENT graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 NEW_LINE graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 NEW_LINE d [ edges [ i ] [ 1 ] ] += 1 NEW_LINE DEDENT print ( maxCliques ( 0 , 1 ) ) NEW_LINE DEDENT
import math NEW_LINE def setBitNumber ( n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) ; NEW_LINE return int ( pow ( 2 , k ) ) ; NEW_LINE DEDENT n = 273 ; NEW_LINE print ( setBitNumber ( n ) ) ; NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE r , c = map ( int , input ( ) . split ( ) ) NEW_LINE f = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( r ) ] NEW_LINE f = [ [ ] for _ in range ( c ) ] NEW_LINE for _ in range ( c ) : NEW_LINE INDENT k , x , y = f [ _ ] NEW_LINE f [ k ] . append ( [ x , y ] ) NEW_LINE f [ k ] . append ( [ x , y ] ) NEW_LINE DEDENT f [ 0 ] = [ 0 , 0 ] NEW_LINE r = 0 NEW_LINE c = 0 NEW_LINE while r < c : NEW_LINE INDENT c += 1 NEW_LINE r += 1 NEW_LINE DEDENT for r in range ( c ) : NEW_LINE INDENT c -= 1 NEW_LINE r += 1 NEW_LINE DEDENT for l in range ( r ) : NEW_LINE INDENT c -= 1 NEW_LINE r += 1 NEW_LINE DEDENT r = ' L ' if r < c else ' R ' NEW_LINE c += r NEW_LINE while c < c : NEW_LINE INDENT c += 1 NEW_LINE r += 1 NEW_LINE DEDENT for l in range ( c ) : NEW_LINE INDENT c -= 1 NEW_LINE r += 1 NEW_LINE DEDENT r = ' R ' if r < c else ' L ' NEW_LINE c += r NEW_LINE for l in range ( c ) : NEW_LINE INDENT c -= 1 NEW_LINE r += 1 NEW_LINE DEDENT for r in range ( c ) : NEW_LINE INDENT c -= 1 NEW_LINE r += 1 NEW_LINE DEDENT r = ' X ' if r < c else ' R ' NEW_LINE print ( r ) NEW_LINE
def subsetPairNotDivisibleByK ( arr , N , K ) : NEW_LINE INDENT f = [ 0 for i in range ( K ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT f [ arr [ i ] % K ] += 1 NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT f [ K // 2 ] = min ( f [ K // 2 ] , 1 ) NEW_LINE DEDENT res = min ( f [ 0 ] , 1 ) NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT res += max ( f [ i ] , f [ K - i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 3 , 7 , 2 , 9 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( subsetPairNotDivisibleByK ( arr , N , K ) ) NEW_LINE
from math import ceil NEW_LINE def calc ( n , p ) : NEW_LINE INDENT if p < n : NEW_LINE INDENT return n NEW_LINE DEDENT k = ceil ( ( n - p ) / 2 ) NEW_LINE return ( k * ( n - k ) ) // k NEW_LINE DEDENT n , p , q = map ( int , input ( ) . split ( ) ) NEW_LINE if p == q : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT x = p - 1 NEW_LINE c = 1 NEW_LINE i = 1 NEW_LINE while c < x : NEW_LINE INDENT m = x + ceil ( i / 2 ) NEW_LINE if calc ( m , p ) <= q : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
def printRoots ( a , b , c ) : NEW_LINE INDENT print ( 1 , " , " , c // ( a * 1.0 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE c = - 5 NEW_LINE printRoots ( a , b , c ) NEW_LINE DEDENT
memo = [ [ - 1 for i in range ( 32 ) ] for j in range ( 2 ) ] NEW_LINE def dp ( pos , fl , pr , bin ) : NEW_LINE INDENT if ( pos == len ( bin ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( memo [ pos ] [ fl ] [ pr ] != - 1 ) : NEW_LINE INDENT return memo [ pos ] [ fl ] [ pr ] NEW_LINE DEDENT val = 0 NEW_LINE if ( bin [ pos ] == '0' ) : NEW_LINE INDENT val = val + dp ( pos + 1 , fl , 0 , bin ) NEW_LINE DEDENT elif ( bin [ pos ] == '1' ) : NEW_LINE INDENT val = val + dp ( pos + 1 , 1 , 0 , bin ) NEW_LINE DEDENT if ( pr == 0 ) : NEW_LINE INDENT if ( fl == 1 ) : NEW_LINE INDENT val += dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT elif ( bin [ pos ] == '1' ) : NEW_LINE INDENT val += dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT DEDENT return memo [ pos ] [ fl ] [ pr ] NEW_LINE DEDENT def findIntegers ( num ) : NEW_LINE INDENT bin = " " NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( num % 2 == 1 ) : NEW_LINE INDENT bin += "1" NEW_LINE DEDENT else : NEW_LINE INDENT bin += "0" NEW_LINE DEDENT num = num // 2 NEW_LINE DEDENT bin = bin [ : : - 1 ] NEW_LINE bin = bin [ : : - 1 ] NEW_LINE return dp ( 0 , 0 , 0 , bin ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 12 NEW_LINE print ( findIntegers ( N ) ) NEW_LINE DEDENT
N = 4 NEW_LINE def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if mat [ 0 ] [ 0 ] == 1 : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ 0 ] [ i ] == 1 : NEW_LINE INDENT dp [ 0 ] [ i ] = ( dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ 0 ] == 1 : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ j ] == 1 : NEW_LINE INDENT dp [ i ] [ j ] = ( max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ] NEW_LINE print ( MaximumDecimalValue ( mat , 4 ) ) NEW_LINE
def createHash ( maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr < maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def findFibonacciPair ( n ) : NEW_LINE INDENT hash = createHash ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash . count ( i ) and hash . count ( n - i ) ) : NEW_LINE INDENT print ( i , " , " , n - i ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 90 NEW_LINE findFibonacciPair ( N ) NEW_LINE DEDENT
def countgroup ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT if ( xs == 0 ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countgroup ( a , n ) ) NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT ans = - float ( " inf " ) NEW_LINE A = [ ] NEW_LINE L = [ ] NEW_LINE R = [ ] NEW_LINE freq = [ 0 ] * ( n + 5 ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ord ( s [ j ] ) - ord ( ' a ' ) == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT freq [ j ] = count NEW_LINE DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT L . append ( ( 2 * freq [ j - 1 ] ) - j ) NEW_LINE R . append ( ( 2 * freq [ j ] ) - j ) NEW_LINE DEDENT max_len = float ( " inf " ) NEW_LINE min_val = float ( " inf " ) NEW_LINE for j in range ( len ( L ) ) : NEW_LINE INDENT min_val = min ( min_val , L [ j ] ) NEW_LINE A . append ( min_val ) NEW_LINE l = 0 NEW_LINE r = j NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE if ( A [ mid ] <= R [ j ] ) : NEW_LINE INDENT max_len = max ( max_len , j - mid + 1 ) NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT DEDENT ans = max ( ans , max_len ) NEW_LINE A . clear ( ) NEW_LINE R . clear ( ) NEW_LINE L . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ababbbacbcbcca " NEW_LINE n = len ( s ) NEW_LINE print ( maxLength ( s , n ) ) NEW_LINE DEDENT
def add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] . append ( y ) NEW_LINE gr [ y ] . append ( x ) NEW_LINE edges . append ( [ x , y ] ) NEW_LINE DEDENT def dfs ( x , col ) : NEW_LINE INDENT colour [ x ] = col NEW_LINE for i in gr [ x ] : NEW_LINE INDENT if ( 1 not in memo [ i ] ) : NEW_LINE INDENT dfs ( i , col ^ 1 ) NEW_LINE DEDENT elif ( 1 not in memo [ i ] ) : NEW_LINE INDENT bip = False NEW_LINE DEDENT DEDENT DEDENT def N ( n ) : NEW_LINE INDENT global memo NEW_LINE for i in range ( N ) : NEW_LINE INDENT memo [ i ] = - 1 NEW_LINE DEDENT bip = True NEW_LINE dfs ( 1 , 1 ) NEW_LINE if ( not bip ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( memo [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT memo [ i ] [ 0 ] , memo [ i ] [ 1 ] ] = memo [ i ] [ 1 ] , memo [ i ] [ 1 ] NEW_LINE DEDENT print ( memo [ i ] [ 0 ] , memo [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE m = 3 NEW_LINE add_edge ( 1 , 2 ) NEW_LINE add_edge ( 1 , 3 ) NEW_LINE add_edge ( 1 , 4 ) NEW_LINE add_edge ( 1 , 2 ) NEW_LINE add_edge ( 1 , 4 ) NEW_LINE add_edge ( 1 , 1 ) NEW_LINE print ( - 1 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT DEDENT if len ( b ) > 0 : NEW_LINE INDENT b . sort ( ) NEW_LINE DEDENT for i in b : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
o , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( 0 , min ( o * ( n - 1 ) , n ) - m ) ) NEW_LINE
def isPrime ( k ) : NEW_LINE INDENT if ( k <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , k ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT if ( num % k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findCount ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE if ( isPrime ( k ) == False ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT ans = check ( i , k ) NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2020 NEW_LINE b = 6300 NEW_LINE k = 29 NEW_LINE print ( findCount ( a , b , k ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ ' a ' ] * n NEW_LINE if n > k : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if n == k : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT ans [ i ] = ans [ i ] * 2 NEW_LINE DEDENT DEDENT elif k == 1 : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT ans [ i ] = ans [ i ] * 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT ans [ i ] = ans [ i ] * 2 + 1 NEW_LINE DEDENT DEDENT print ( ' ' . join ( ans ) ) NEW_LINE
maxn = 16 NEW_LINE def precompute ( ) : NEW_LINE INDENT dp = [ - 1 ] * maxn NEW_LINE arr = [ 4 , 6 , 9 ] NEW_LINE for i in range ( maxn ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , maxn ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT j = arr [ k ] NEW_LINE if ( i >= j and dp [ i - j ] != - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp NEW_LINE DEDENT def Maximum_Sum x kandi ( dp , n ) : NEW_LINE INDENT if ( n < maxn ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT t = ( n - maxn ) // 4 + 1 NEW_LINE return t + dp [ n - 4 * t ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE dp = precompute ( ) NEW_LINE print ( Maximum_Sum xandi ( dp , n ) ) NEW_LINE DEDENT
def countSquares ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( " Count of squares is " , countSquares ( n ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] + a [ i ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE d = dict ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if b [ i ] == 0 : NEW_LINE INDENT if d [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = b [ i ] NEW_LINE if d [ x ] : NEW_LINE INDENT ans += d [ x ] * ( d [ x ] - 1 ) NEW_LINE DEDENT d [ x ] = d [ x ] - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE def FindSubarray ( arr , n , k ) : NEW_LINE INDENT count_one = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_one [ i ] = bin ( arr [ i ] ) . count ( '1' ) NEW_LINE DEDENT sum = count_one [ 0 ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT if ( count_one [ 0 ] >= k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( k == count_one [ j ] ) : NEW_LINE INDENT ans = 1 NEW_LINE break NEW_LINE DEDENT elif ( k == count_one [ i ] ) : NEW_LINE INDENT ans = 1 NEW_LINE break NEW_LINE DEDENT elif ( sum + count_one [ i ] < k ) : NEW_LINE INDENT sum += count_one [ i ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( sum + count_one [ i ] > k ) : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) NEW_LINE sum -= count_one [ j ] NEW_LINE j += 1 NEW_LINE DEDENT elif ( sum + count_one [ i ] == k ) : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) NEW_LINE sum += count_one [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if ( ans != sys . maxsize ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( FindSubarray ( arr , n , k ) ) NEW_LINE
def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 ; NEW_LINE loss = ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; NEW_LINE print ( " Loss = " , round ( loss , 3 ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SP = 2400 ; P = 30 ; NEW_LINE Loss ( SP , P ) ; NEW_LINE DEDENT
n , m , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if x in a : NEW_LINE INDENT print ( sum ( a [ : x ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( sum ( a [ x : ] ) , sum ( a [ x + 1 : ] ) ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE li = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ones = li . count ( 1 ) NEW_LINE twos = li . count ( 2 ) NEW_LINE print ( min ( ones , twos ) ) NEW_LINE
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 7 NEW_LINE ans = sum ( 1 for i in itertools . count ( 1 ) if is_Class89 ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_Class89 ( x ) : NEW_LINE INDENT while True : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT elif x == 89 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT x = next ( x ) NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def countStrings ( string , n ) : NEW_LINE INDENT distinct_char = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char [ string [ i ] ] = 1 NEW_LINE DEDENT return fact ( len ( distinct_char ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE n = len ( string ) NEW_LINE print ( countStrings ( string , n ) ) NEW_LINE DEDENT
M = 4 NEW_LINE N = 5 NEW_LINE def printCommonElements ( mat ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT mp [ mat [ 0 ] [ j ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if mat [ i ] [ j ] in mp . keys ( ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] += 1 NEW_LINE if ( i == M - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT mat = [ [ 1 , 2 , 1 , 4 , 8 ] , [ 3 , 7 , 8 , 5 , 1 ] , [ 8 , 7 , 7 , 3 , 1 ] , [ 8 , 1 , 2 , 7 , 9 ] , ] NEW_LINE printCommonElements ( mat ) NEW_LINE
n = int ( input ( ) ) NEW_LINE start , end = map ( int , input ( ) . split ( ) ) NEW_LINE f = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE f . append ( [ x , y ] ) NEW_LINE DEDENT f . sort ( key = lambda x : ( f [ 0 ] + eps , f [ 1 ] + eps ) ) NEW_LINE t = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if f [ i ] [ 1 ] != f [ i + 1 ] [ 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def calc ( arr , l , r ) : NEW_LINE INDENT if l < 0 or r < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = l // r + 1 NEW_LINE return arr [ mid ] * r NEW_LINE DEDENT n , t = map ( int , input ( ) . split ( ) ) NEW_LINE arr = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE arr . append ( [ x , y ] ) NEW_LINE DEDENT r = [ 0 ] * n NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] [ 0 ] >= t : NEW_LINE INDENT r [ i ] = calc ( arr , r [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT r [ i ] = calc ( arr , r [ i ] [ 1 ] , arr [ i ] [ 0 ] ) NEW_LINE c = 1 NEW_LINE DEDENT DEDENT if c == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if r [ i ] - r [ i ] > t : NEW_LINE INDENT c = - 1 NEW_LINE DEDENT DEDENT print ( c + 1 ) NEW_LINE DEDENT
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + a NEW_LINE a = a + d NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE DEDENT
def find3Numbers ( arr , n ) : NEW_LINE INDENT small = + 2147483647 NEW_LINE large = + 2147483647 NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= small ) : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] <= large ) : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( " No such triplet found " ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( arr [ j ] < large ) : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small , large , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 7 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE find3Numbers ( arr , n ) NEW_LINE DEDENT
def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT print ( " Numbers with 3 divisors : " ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT n = 96 NEW_LINE numbersWith3Divisors ( n ) NEW_LINE
def findPairCount ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE rem = [ 0 ] * K NEW_LINE rem [ 0 ] = N // K NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem [ i ] = ( N - i ) // K + 1 NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT count += ( rem [ K // 2 ] * ( rem [ K // 2 ] - 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 10 NEW_LINE K = 4 NEW_LINE print ( findPairCount ( N , K ) ) NEW_LINE
import sys NEW_LINE def solve ( cards ) : NEW_LINE INDENT if len ( cards ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = len ( cards ) // 2 NEW_LINE count = 0 NEW_LINE for i in range ( mid ) : NEW_LINE INDENT if cards [ i ] >= mid : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mid - count NEW_LINE DEDENT DEDENT return max ( cards ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT cards = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) NEW_LINE ans = solve ( cards ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE if sum ( arr ) % 2 == 0 and arr [ n - 1 ] >= sum ( arr ) / 2 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
PHI = 1.6180 m NEW_LINE f = [ 0 , 1 , 1 , 2 , 3 , 5 ] NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n < 6 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while ( t < n ) : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT n = 9 NEW_LINE print ( n , " th Fibonacci Number = " , fib ( n ) ) NEW_LINE
def kthSmallest ( n , k ) : NEW_LINE INDENT return ( 2 * k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE k = 4 NEW_LINE print ( kthSmallest ( n , k ) ) NEW_LINE DEDENT
n = 5 NEW_LINE def printSumTricky ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT stripSum = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT stripSum [ 0 ] [ j ] = sum NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) NEW_LINE stripSum [ i ] [ j ] = sum NEW_LINE DEDENT DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT sum += stripSum [ i ] [ j ] NEW_LINE DEDENT print ( sum , end = " " ) NEW_LINE for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) NEW_LINE print ( sum , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT mat = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 ] , ] NEW_LINE k = 3 NEW_LINE printSumTricky ( mat , k ) NEW_LINE
a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE if a * b == n : NEW_LINE INDENT print ( " No solution " ) NEW_LINE DEDENT else : NEW_LINE INDENT l = - 1000 NEW_LINE r = + 1 NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if m * a == n : NEW_LINE INDENT print ( m ) NEW_LINE exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT print ( " No solution " ) NEW_LINE DEDENT
def ncr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT def totalWays ( X , Y , M , W ) : NEW_LINE INDENT return ( ncr ( M , X ) * ncr ( W , Y ) ) NEW_LINE DEDENT X = 4 ; Y = 3 ; M = 6 ; W = 5 NEW_LINE print ( totalWays ( X , Y , M , W ) ) NEW_LINE
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT n = n >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT def removeElement ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = nextPowerOf2 ( n ) NEW_LINE if ( n == a or n == a - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == a - 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( removeElement ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE YesNo = lambda b : bool ( [ print ( ' Yes ' ) ] if b else print ( ' No ' ) ) NEW_LINE YESNO = lambda b : bool ( [ print ( ' YES ' ) ] if b else print ( ' NO ' ) ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE def main ( ) : NEW_LINE INDENT N , P = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = INF NEW_LINE if P == 0 : NEW_LINE INDENT x = 1 NEW_LINE ans = 0 NEW_LINE DEDENT else : NEW_LINE INDENT x = [ 0 ] * N NEW_LINE ans = 0 NEW_LINE for a in A : NEW_LINE INDENT x [ a % 2 ] += 1 NEW_LINE DEDENT DEDENT if x [ 0 ] == 0 : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE DEDENT
def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sum += x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 and sumOfDigits ( i ) % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 1000 NEW_LINE r = 6000 NEW_LINE print ( countNumbers ( l , r ) ) NEW_LINE DEDENT
from math import log NEW_LINE def findGreater ( a , b ) : NEW_LINE INDENT x = a * log ( b ) NEW_LINE y = b * log ( a ) NEW_LINE if ( y > x ) : NEW_LINE INDENT print ( " a ^ b is greater " ) NEW_LINE DEDENT elif ( y < x ) : NEW_LINE INDENT print ( " b ^ a is greater " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " both are equal " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE b = 5 NEW_LINE c = 2 NEW_LINE d = 4 NEW_LINE findGreater ( a , b ) NEW_LINE findGreater ( c , d ) NEW_LINE DEDENT
def findAnswer ( str1 , str2 , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = 0 NEW_LINE ans = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT l = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( r < l ) : NEW_LINE INDENT return 26 * ( n + 1 ) NEW_LINE DEDENT elif ( l == r ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i - 1 ] ) : NEW_LINE INDENT ans -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] != str2 [ i ] ) : NEW_LINE INDENT ans -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " toy " NEW_LINE str2 = " try " NEW_LINE n = len ( str1 ) NEW_LINE print ( findAnswer ( str1 , str2 , n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , x , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( [ l , r ] ) NEW_LINE DEDENT ma , mi = a [ 0 ] [ 0 ] , a [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ma <= a [ i ] [ 0 ] and mi >= x : NEW_LINE INDENT ma = max ( ma , a [ i ] [ 1 ] ) NEW_LINE DEDENT elif ma >= a [ i ] [ 1 ] and mi <= x : NEW_LINE INDENT mi = min ( ma , a [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT print ( ma - mi + 1 ) NEW_LINE DEDENT
def bitsAreInAlt pat re n n n , l , r : NEW_LINE INDENT num = n >> ( l - 1 ) NEW_LINE prev = num & 1 NEW_LINE num = num >> 1 NEW_LINE for i in range ( 1 , r - l + 1 ) : NEW_LINE INDENT curr = num & 1 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE num = num >> 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 18 NEW_LINE l , r = 1 , 3 NEW_LINE if ( bitsAreInAlt pat re n , l , r ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = [ ] NEW_LINE if ( a [ 0 ] == 1 ) : NEW_LINE INDENT s . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( 0 ) NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if ( r - l + 1 ) % 2 == 0 : NEW_LINE INDENT if ( r - l + 1 ) // 2 <= s [ r - 1 ] <= ( r - l + 1 ) // 2 : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT l , r = l - 1 , r - 1 NEW_LINE if ( r - l + 1 ) % 2 == 0 : NEW_LINE INDENT if ( r - l + 1 ) // 2 <= s [ r - 1 ] <= ( r - l + 1 ) // 2 : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . append ( x ) NEW_LINE DEDENT ans = sum ( a ) NEW_LINE if len ( a ) == 1 : NEW_LINE INDENT print ( ans ) NEW_LINE exit ( ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT if cnt > 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == 0 : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT DEDENT DEDENT if cnt == 0 : NEW_LINE INDENT print ( ans ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT print ( cnt ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE m = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT m . append ( l [ i + 1 ] + l [ i ] ) NEW_LINE DEDENT m . append ( l [ - 1 ] ) NEW_LINE print ( s - max ( m ) ) NEW_LINE print ( * m ) NEW_LINE
MAX = 1000000 NEW_LINE def maximumOcc p ( L , R , n ) : NEW_LINE INDENT arr = [ 0 for i in range ( MAX ) ] NEW_LINE maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ L [ i ] ] += 1 NEW_LINE arr [ R [ i ] + 1 ] -= 1 NEW_LINE if ( R [ i ] > maxi ) : NEW_LINE INDENT maxi = R [ i ] NEW_LINE DEDENT DEDENT msum = arr [ 0 ] NEW_LINE ind = 0 NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE if ( msum < arr [ i ] ) : NEW_LINE INDENT msum = arr [ i ] NEW_LINE ind = i NEW_LINE DEDENT DEDENT return ind NEW_LINE DEDENT L = [ 1 , 4 , 9 , 13 , 21 ] NEW_LINE R = [ 15 , 8 , 12 , 20 , 30 ] NEW_LINE n = len ( L ) NEW_LINE print ( maximumOcc p ( L , R , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] != arr [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE DEDENT elif m > n : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT print ( 1 , n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , n + 1 ) NEW_LINE DEDENT DEDENT
def func ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x * x ) ) NEW_LINE DEDENT def calculate ( lower_limit , upper_limit , interval_limit ) : NEW_LINE INDENT global interval_limit NEW_LINE interval_size = ( upper_limit - lower_limit ) / interval_limit NEW_LINE sum = func ( lower_limit ) + func ( upper_limit ) NEW_LINE for i in range ( 1 , interval_limit ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT sum = sum + 2 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + 3 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT DEDENT return ( 3 * interval_size / 8 ) * sum NEW_LINE DEDENT interval_limit = 10 NEW_LINE lower_limit = 1 NEW_LINE upper_limit = 10 NEW_LINE integral_res = calculate ( lower_limit , upper_limit , interval_limit ) NEW_LINE print ( " % . 4 f " % integral_res ) NEW_LINE
N , K , X , Y = map ( int , input ( ) . split ( ) ) NEW_LINE X = min ( X , K ) NEW_LINE Y = max ( Y , K ) NEW_LINE print ( X * N + Y * ( N - K ) ) NEW_LINE
import math NEW_LINE while True : NEW_LINE INDENT x , h = map ( int , input ( ) . split ( ) ) NEW_LINE if ( x == 0 and h == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT s = math . sqrt ( h * h + x * x * x ) NEW_LINE ans = s / 2 NEW_LINE print ( ans ) NEW_LINE DEDENT
k = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE while ( True ) : NEW_LINE INDENT s = str ( k ) NEW_LINE c += 1 NEW_LINE n = len ( s ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( n % 10 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = s [ 1 : ] NEW_LINE DEDENT k = k - 1 NEW_LINE DEDENT print ( c ) NEW_LINE
from math import sqrt NEW_LINE MAX = 1000000 NEW_LINE prime = [ True ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p < MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def printPrimeQuad ( n ) : NEW_LINE INDENT for i in range ( n - 7 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] ) : NEW_LINE INDENT print ( i , i + 2 , i + 6 , i + 8 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 20 NEW_LINE sieve ( ) NEW_LINE printPrime y = 0 NEW_LINE printPrime y += 1 NEW_LINE DEDENT
MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( 1 + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT x = " ABCD " NEW_LINE y = " BACdb dcD " NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE print ( maxSubsequenceSubstring ( x , y , n , m ) ) NEW_LINE
def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE dict1 = { } NEW_LINE dict2 = { } NEW_LINE s1_l = list ( s1 ) NEW_LINE s2_l = list ( s2 ) NEW_LINE dict1 [ s1_l [ 0 ] ] = s1_l [ 1 ] NEW_LINE s2_l = list ( s2 ) NEW_LINE dict2 [ s2_l [ 0 ] ] = s2_l [ 1 ] NEW_LINE s1_l = ' ' NEW_LINE s2_l = list ( s2 ) NEW_LINE s1_r = ' ' NEW_LINE s2_r = ' ' NEW_LINE s1_l = list ( s1_r ) NEW_LINE s2_l = list ( s2_l ) NEW_LINE cur = 0 NEW_LINE for i in range ( len ( s1_l ) ) : NEW_LINE INDENT if dict1 [ s1_l [ i ] ] == dict2 [ s2_l [ i ] ] : NEW_LINE INDENT dict1 [ s1_l [ i ] ] += 1 NEW_LINE cur += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict2 [ s1_l [ i ] ] = 1 NEW_LINE cur += 1 NEW_LINE DEDENT DEDENT cur = 0 NEW_LINE for i in range ( len ( s1_r ) ) : NEW_LINE INDENT if dict1 [ s1_r [ i ] ] == dict2 [ s2_l [ i ] ] : NEW_LINE INDENT dict1 [ s1_r [ i ] ] -= 1 NEW_LINE cur += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict2 [ s1_r [ i ] ] = 1 NEW_LINE cur += 1 NEW_LINE DEDENT DEDENT cur = 0 NEW_LINE for i in range ( len ( s2_l ) ) : NEW_LINE INDENT if dict2 [ s2_l [ i ] ] == dict1 [ s2_l [ i ] ] : NEW_LINE INDENT dict2 [ s2_l [ i ] ] += 1 NEW_LINE cur += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict2 [ s2_l [ i ] ] = 1 NEW_LINE cur += 1 NEW_LINE DEDENT DEDENT print ( cur , dict2 . get ( s1_l [ - 1 ] , 0 ) ) NEW_
MAX = 1000 NEW_LINE sequence = [ 0 ] * MAX NEW_LINE defen ( ) : NEW_LINE INDENT global MAX NEW_LINE for i in range ( MAX - 1 ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getNthTerm ( n ) : NEW_LINE INDENT return sequence [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENTen ( ) NEW_LINE n = 6 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE n = 100 NEW_LINE print ( getNthTerm ( n ) ) NEW_LINE DEDENT
MAX = 100000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) NEW_LINE defen ( ) : NEW_LINE INDENT global MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT count = 1 NEW_LINE i = n - 1 NEW_LINE while ( sequence [ i + 1 ] != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE i = i - sequence [ i + 1 ] NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( getCount ( n ) ) NEW_LINE n = 11 NEW_LINE print ( getCount ( n ) ) NEW_LINE DEDENT
MAX = 100000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) NEW_LINE defenckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT nthTerm = sequence [ n - 1 ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( sequence [ i ] == nthTerm ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENTenckSequence ( ) NEW_LINE n = 5 NEW_LINE print ( getCount ( n ) ) NEW_LINE n = 11 NEW_LINE print ( getCount ( n ) ) NEW_LINE DEDENT
def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def nthElement ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) // __gcd ( a , b ) NEW_LINE l = 1 NEW_LINE r = min ( a , b ) * n NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE val = mid // a + mid // b - mid // lcm NEW_LINE if ( val == n ) : NEW_LINE INDENT return max ( ( mid // a ) * a , ( mid // b ) * b ) NEW_LINE DEDENT if ( val < n ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 5 NEW_LINE print ( nthElement ( a , b , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE i = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if i == n : NEW_LINE INDENT i = i + 3 NEW_LINE DEDENT elif i == n : NEW_LINE INDENT i = i + 7 NEW_LINE DEDENT elif i > n - 1 : NEW_LINE INDENT if i == n - 2 : NEW_LINE INDENT i = i + 7 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE
def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE f = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " HIT " : NEW_LINE INDENT f . append ( 1 ) NEW_LINE DEDENT elif s == " OUT " : NEW_LINE INDENT f . append ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT t = 0 NEW_LINE j = 0 NEW_LINE while i < n : NEW_LINE INDENT if f [ i ] == 1 and s [ i ] == " out " : NEW_LINE INDENT f [ i ] = 0 NEW_LINE j += 1 NEW_LINE DEDENT elif f [ i ] == 0 and s [ i ] == " out " : NEW_LINE INDENT f [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT elif f [ i ] == 0 and s [ i ] == " out " : NEW_LINE INDENT f [ i ] = 0 NEW_LINE j += 1 NEW_LINE DEDENT elif f [ i ] == 1 and s [ i ] == " out " : NEW_LINE INDENT f [ i ] = 0 NEW_LINE j += 1 NEW_LINE DEDENT elif f [ i ] == 0 and s [ i ] == " out " : NEW_LINE INDENT f [ i ] = 0 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT print ( len ( f ) ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
from math import gcd NEW_LINE def findValue ( x , y , z ) : NEW_LINE INDENT g = gcd ( y , z ) NEW_LINE return ( x * g ) // gcd ( x , g ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y , z = 30 , 40 , 400 NEW_LINE print ( findValue ( x , y , z ) ) NEW_LINE DEDENT
def foot ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) NEW_LINE x2 = a * k + x1 NEW_LINE y2 = b * k + y1 NEW_LINE z2 = c * k + z1 NEW_LINE print ( " x2 = " , int ( x2 ) , " y2 = " , int ( y2 ) , " z2 = " , int ( z2 ) ) NEW_LINE DEDENT a , b , c , d = 1 , - 2 , 0 , 3 , 4 NEW_LINE foot ( a , b , c , d , x1 , y1 , z1 ) NEW_LINE
s = input ( ) NEW_LINE t = input ( ) NEW_LINE if s [ 0 ] == t [ 0 ] and s [ 1 ] == t [ 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE def getMinimumOps ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = min ( ar ) NEW_LINE large = max ( ar ) NEW_LINE dp = [ [ 0 for i in range ( large + 1 ) ] for j in range ( n ) ] NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( ar [ 0 ] - j ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT minimum = sys . maxsize NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ar = [ 1 , 2 , 1 , 4 , 3 ] NEW_LINE print ( getMinimumOps ( ar ) ) NEW_LINE DEDENT
PI = 3.14159265 NEW_LINE def area_leaf ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 - 1 ) ) NEW_LINE DEDENT a = 7 NEW_LINE print ( area_leaf ( a ) ) NEW_LINE
def removeAlternate ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 * removeAlternate ( n // 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) // 2 ) ) + 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE n = 10 NEW_LINE print ( removeAlternate ( n ) ) NEW_LINE DEDENT
def check ( n , m ) : NEW_LINE INDENT if ( n == 2 or m == 2 or n % m == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 3 NEW_LINE n = 9 NEW_LINE check ( n , m ) NEW_LINE DEDENT
from sys import stdin , stdout NEW_LINE import math NEW_LINE def get_ints ( ) : return map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE def get_arr ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE def get_string ( ) : return stdin . readline ( ) . strip ( ) NEW_LINE t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE m , n , k = get_ints ( ) NEW_LINE a = get_arr ( ) NEW_LINE s = 0 NEW_LINE for i in a : NEW_LINE INDENT s += i // m NEW_LINE DEDENT if s < n : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT if a . count ( s ) < 2 : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT DEDENT
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( negProdSubArr ( arr , n ) ) NEW_LINE DEDENT
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT def posProdSubArr ( arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) // 2 NEW_LINE cntNeg = negProdSubArr ( arr , n ) NEW_LINE return ( total - cntNeg ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( posProdSubArr ( arr , n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k <= n : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT elif k == n : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT s = 0 NEW_LINE while 2 ** s <= n : NEW_LINE INDENT s += 2 ** s NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( y , x % y ) NEW_LINE DEDENT DEDENT def lcm ( x , y ) : NEW_LINE INDENT return ( x * y ) // gcd ( x , y ) NEW_LINE DEDENT x , y , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE lcm = lcm ( x , y ) NEW_LINE x , y = min ( a , b ) , max ( a , b ) NEW_LINE while y > x : NEW_LINE INDENT x , y = y , x % y NEW_LINE DEDENT print ( x + y ) NEW_LINE
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return n - len NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE
def print_max ( a , n , k ) : NEW_LINE INDENT max_upto = [ 0 ] * n NEW_LINE s = [ ] NEW_LINE s . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) != 0 and a [ s [ - 1 ] ] < a [ i ] ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = i - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT s . append ( i ) NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = n - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT while ( j < i or max_upto [ j ] < i + k - 1 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print ( a [ j ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 9 , 7 , 2 , 4 , 6 , 8 , 2 , 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print_max ( a , n , k ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = max ( digit_sum ( i ** j ) for i in range ( 1 , 101 ) for j in range ( 1 , 101 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def digit_sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT sum += int ( n [ i ] ) * ( ord ( n [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countDistinct ( win , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( win [ i ] == win [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT DEDENT return dist_count NEW_LINE DEDENT def countDistinct ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( countDistinct ( arr , i , n - k + 1 ) , k ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 1 , 3 , 4 , 2 , 3 ] NEW_LINE k = 4 NEW_LINE countDistinct ( arr , len ( arr ) , k ) NEW_LINE
def evenNumSubstring ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "1234" NEW_LINE print ( evenNumSubstring ( str ) ) NEW_LINE DEDENT
def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ index ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += countWays ( 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE dp [ index ] [ cnt ] = ans NEW_LINE return dp [ index ] [ cnt ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m , k = 3 , 3 , 2 NEW_LINE dp = [ [ - 1 for i in range ( max ) ] for j in range ( n + 1 ) ] NEW_LINE print ( countWays ( 1 , 0 , dp , n , m , k ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return sum - n NEW_LINE DEDENT def print alp ( n ) : NEW_LINE INDENT print ( n ) NEW_LINE s = set ( ) NEW_LINE s . add ( n ) NEW_LINE next = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = getSum ( n ) NEW_LINE if n in s : NEW_LINE INDENT print ( " \n Repeats with " , n ) NEW_LINE break NEW_LINE DEDENT print ( n , end = " " ) NEW_LINE s . add ( n ) NEW_LINE DEDENT DEDENT print alp ( 12 ) NEW_LINE
n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) . split ( ) NEW_LINE d = { } NEW_LINE for i in s : NEW_LINE INDENT if i in d : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 2 NEW_LINE DEDENT DEDENT ans = ' ' NEW_LINE for i in d : NEW_LINE INDENT ans += str ( d [ i ] ) + ' ' NEW_LINE DEDENT print ( ans ) NEW_LINE
def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 ] = arr [ ( n + ~ i + 1 ) + ~ 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE a = 1 NEW_LINE cnt = 0 NEW_LINE flag = True NEW_LINE sum += a NEW_LINE while ( cnt < N ) : NEW_LINE INDENT hasMoreElements = 0 NEW_LINE if ( flag == True ) : NEW_LINE INDENT hasMoreElements = a * 2 NEW_LINE sum += hasMoreElements NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT hasMoreElements = a * 3 / 2 NEW_LINE sum += hasMoreElements NEW_LINE flag = not flag NEW_LINE DEDENT a = hasMoreElements NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 8 NEW_LINE printSeriesSum ( N ) NEW_LINE DEDENT
import math NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a % 2 == 0 or b % 2 == 0 : NEW_LINE INDENT print ( '1 0 0' ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ( '1 1 0' ) NEW_LINE DEDENT else : NEW_LINE INDENT k = math . gcd ( a , b ) NEW_LINE print ( k // 2 + 1 , k // 2 + 1 ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE sz = 10 ** 5 NEW_LINE isPrime = [ True ] * ( sz + 1 ) NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( sqrt ( sz ) ) + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def minDifference ( L , R ) : NEW_LINE INDENT fst = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT fst = i NEW_LINE break NEW_LINE DEDENT DEDENT snd = 0 NEW_LINE for i in range ( fst + 1 , R + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT snd = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( snd == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT diff = snd - fst NEW_LINE left = snd + 1 NEW_LINE right = R NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT if ( i - snd <= diff ) : NEW_LINE INDENT fst = snd NEW_LINE snd = i NEW_LINE diff = snd - fst NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) NEW_LINE L = 21 NEW_LINE R = 50 NEW_LINE print ( minDifference ( L , R ) ) NEW_LINE DEDENT
def getMaxLength ( arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE preCnt = 0 NEW_LINE while ( start < n and arr [ start ] == 1 ) : NEW_LINE INDENT preCnt += 1 NEW_LINE start += 1 NEW_LINE DEDENT end = n - 1 NEW_LINE suffCnt = 0 NEW_LINE while ( end >= 0 and arr [ end ] == 1 ) : NEW_LINE INDENT suffCnt += 1 NEW_LINE end -= 1 NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT return n NEW_LINE DEDENT midCnt = 0 NEW_LINE result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT midCnt += 1 NEW_LINE result = max ( result , midCnt ) NEW_LINE DEDENT else : NEW_LINE INDENT midCnt = 0 NEW_LINE DEDENT DEDENT return max ( result , preCnt + suffCnt ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMaxLength ( arr , n ) ) NEW_LINE DEDENT
d , n = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i == 0 and x [ i ] <= y [ j ] : NEW_LINE INDENT ans = max ( ans , abs ( x [ i ] - y [ j ] ) ) NEW_LINE DEDENT elif i == n - 1 and x [ i ] > y [ j ] : NEW_LINE INDENT ans = max ( ans , abs ( x [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while i < n - 1 and s [ i ] > s [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n - 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( i + 1 , i + 2 ) NEW_LINE DEDENT
def sqroot ( s ) : NEW_LINE INDENT pSq = 0 NEW_LINE N = 0 NEW_LINE for i in range ( s ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i NEW_LINE N = j NEW_LINE break NEW_LINE DEDENT DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT d = s - pSq NEW_LINE P = d / ( 2.0 * N ) NEW_LINE A = N + P NEW_LINE sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) NEW_LINE return sqrt_of_s NEW_LINE DEDENT num = 9.2345 NEW_LINE sqroot_of_num = sqroot ( num ) NEW_LINE print ( " Square root of " , num , " = " , round ( sqroot_of_num * 100000.0 ) / 100000.0 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE last = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if last <= a [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE break NEW_LINE DEDENT last = a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
from math import sqrt NEW_LINE while True : NEW_LINE INDENT r , n = map ( int , input ( ) . split ( ) ) NEW_LINE if r == 0 : break NEW_LINE ma = [ [ 0 ] * 20 for _ in range ( 20 ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y , h = map ( int , input ( ) . split ( ) ) NEW_LINE ma [ max ( 0 , y - 20 ) ] [ 0 ] = h NEW_LINE DEDENT for i in range ( 20 ) : NEW_LINE INDENT for j in range ( 20 ) : NEW_LINE INDENT ma [ i + 1 ] [ j + 1 ] = ma [ i ] [ j ] NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = ma [ i ] [ 0 ] NEW_LINE y = ma [ i ] [ 1 ] NEW_LINE r = ma [ i ] [ 2 ] NEW_LINE ans = min ( ans , ( x + 20 ) * ( y + r ) - ( y + r ) * ( r ** 2 - 4 ) ) NEW_LINE DEDENT print ( " % .10f " % ans ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] > j + 1 : NEW_LINE INDENT ans = 2 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE while n != 0 : NEW_LINE INDENT n = n * - 1 NEW_LINE m = min ( n % 10 , n // 10 % 10 ) NEW_LINE b = ' - ' + str ( n // 10 ) + str ( m ) NEW_LINE a = b . replace ( ' . ' , ' ' ) NEW_LINE n = n - a NEW_LINE if n == a : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT n = int ( n ) NEW_LINE DEDENT
def maxAlternateSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ 0 ] * n NEW_LINE inc = [ 0 ] * n NEW_LINE dec [ 0 ] = inc [ 0 ] = arr [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ j ] < arr [ i ] and flag == 1 ) : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT result = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < inc [ i ] ) : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if ( result < dec [ i ] ) : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 8 , 2 , 3 , 5 , 7 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum sum = " , maxAlternateSum ( arr , n ) ) NEW_LINE
def generateArr ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] & arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev & arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev & arr [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev + arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev + arr [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if ( i * k > j * j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A , B , C = 3 , 2 , 2 NEW_LINE print ( countTriplets ( A , B , C ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX + 1 ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def smallestPrime ( d ) : NEW_LINE INDENT l = int ( sqrt ( d - 1 ) ) NEW_LINE r = int ( sqrt ( d ) ) - 1 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def largestPrime ( d ) : NEW_LINE INDENT l = int ( sqrt ( d - 1 ) ) NEW_LINE r = int ( sqrt ( d ) ) - 1 NEW_LINE for i in range ( r , l + 1 , - 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE queries = [ 2 , 5 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( smallestPrime ( queries [ i ] ) , largestPrime ( queries [ i ] ) ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE c = [ int ( input ( ) ) for _ in range ( m ) ] NEW_LINE dp = [ [ 10 ** 9 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + d [ j ] * c [ i ] ) NEW_LINE DEDENT DEDENT print ( dp [ m ] [ n ] ) NEW_LINE
n , k , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i + k >= n : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += x NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n , m , a , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x , y = 1 , a [ 0 ] + 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT x = a [ i ] NEW_LINE DEDENT if a [ i ] < y : NEW_LINE INDENT y = a [ i ] NEW_LINE DEDENT DEDENT s = 0 NEW_LINE i , j = 0 , 0 NEW_LINE c = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if a [ i ] + d <= y : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT c += 1 NEW_LINE while ( j < m ) : NEW_LINE INDENT if a [ j ] + d <= y : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT s += 1 NEW_LINE print ( s ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = n * ( n + 1 ) // 2 - n * ( n + 1 ) // 2 NEW_LINE print ( ans , ans + 1 ) NEW_LINE DEDENT
s = input ( ) NEW_LINE first_win = False NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == " a " : NEW_LINE INDENT first_win = True NEW_LINE DEDENT elif s [ i ] == " z " : NEW_LINE INDENT first_win = False NEW_LINE DEDENT DEDENT if first_win : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( s ) - 1 ) % 2 == 0 : NEW_LINE INDENT print ( " Second " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT DEDENT
def reverse ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT def getSum ( n ) : NEW_LINE INDENT n = reverse ( n ) NEW_LINE sumOdd = 0 NEW_LINE sumEven = 0 NEW_LINE c = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( c % 2 == 0 ) : NEW_LINE INDENT sumEven += n % 10 NEW_LINE DEDENT else : NEW_LINE INDENT sumOdd += n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE c += 1 NEW_LINE DEDENT print ( " Sum odd = " , sumOdd ) NEW_LINE print ( " Sum even = " , sumEven ) NEW_LINE DEDENT n = 457892 NEW_LINE getSum ( n ) NEW_LINE
def disp ( row_no , block ) : NEW_LINE INDENT print ( row_no * block ) NEW_LINE DEDENT def row ( ht , h ) : NEW_LINE INDENT return ht // h NEW_LINE DEDENT def calculate ( l , w , h , a , ht ) : NEW_LINE INDENT no_ block = ( 4 * a ) // l NEW_LINE if ( h < w ) : NEW_LINE INDENT row_no = row ( ht , w ) NEW_LINE DEDENT else : NEW_LINE INDENT row_no = row ( ht , h ) NEW_LINE DEDENT disp ( row_no , no_ block ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , w , h = 50 , 20 , 35 NEW_LINE a = 700 NEW_LINE ht = 140 NEW_LINE calculate ( l , w , h , a , ht ) NEW_LINE DEDENT
bin = [ "000" , "001" , "010" , "011" , "100" , "101" , "110" , "111" ] ; NEW_LINE def maxFreq ( s ) : NEW_LINE INDENT binary = " " ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT binary += bin [ ord ( s [ i ] ) - ord ( '0' ) ] ; NEW_LINE DEDENT binary = binary [ : - 1 ] ; NEW_LINE count = 1 ; prev = - 1 ; i = 0 ; j = 0 ; NEW_LINE for i in range ( len ( binary ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( binary [ i ] == '1' ) : NEW_LINE INDENT count = max ( count , j - prev ) ; NEW_LINE prev = j ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT octal = "13" ; NEW_LINE print ( maxFreq ( octal ) ) ; NEW_LINE
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) ; NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT cv = [ 0 ] * n ; NEW_LINE cc = [ 0 ] * n ; NEW_LINE if ( isVowel ( s [ 0 ] ) ) : NEW_LINE INDENT cv [ 0 ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cc [ 0 ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT cv [ i ] = cv [ i - 1 ] + ( isVowel ( s [ i ] ) ) ; NEW_LINE cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) ) ; NEW_LINE DEDENT ans = " " ; NEW_LINE prod = 0 ; NEW_LINE prod = cc [ k - 1 ] * cv [ k - 1 ] ; NEW_LINE ans += str ( prod ) ; NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ; NEW_LINE ans += str ( prod ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " hello " ; NEW_LINE n = len ( s ) ; NEW_LINE k = 2 ; NEW_LINE print ( encryptString ( s , n , k ) ) ; NEW_LINE DEDENT
def harmonicMean ( arr , freq , n ) : NEW_LINE INDENT sum = 0 NEW_LINE frequency_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + freq [ i ] / arr [ i ] NEW_LINE frequency_sum = frequency_sum + freq [ i ] NEW_LINE DEDENT return ( int ) ( frequency_sum / sum ) NEW_LINE DEDENT num = [ 13 , 14 , 15 , 16 , 17 ] NEW_LINE freq = [ 2 , 5 , 13 , 7 , 3 ] NEW_LINE n = len ( num ) NEW_LINE print ( harmonicMean ( num , freq , n ) ) NEW_LINE
from math import pi NEW_LINE def polyarea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * pi / 180 ) ) NEW_LINE return A NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , n = 9 , 6 NEW_LINE print ( round ( polyarea ( n , a ) , 3 ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def getMinValue ( c ) : NEW_LINE INDENT ans = float ( " inf " ) NEW_LINE for i in range ( 1 , int ( sqrt ( c ) ) + 1 ) : NEW_LINE INDENT if c % i == 0 and lcm ( i , c // i ) == c : NEW_LINE INDENT ans = min ( ans , max ( i , c // i ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT c = 6 NEW_LINE print ( getMinValue ( c ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT m , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m == n == 0 : break NEW_LINE p = [ int ( input ( ) ) for _ in range ( m ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n - m + 1 ) : NEW_LINE INDENT p . append ( p [ - 1 ] - p [ i ] ) NEW_LINE if i > n - 1 : ans = max ( ans , i + 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
inf = float ( ' inf ' ) NEW_LINE def solve ( ) : NEW_LINE INDENT s , d , n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if s > d : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE inf = 1 << 30 NEW_LINE if s == 0 : NEW_LINE INDENT print ( inf ) NEW_LINE return NEW_LINE DEDENT if ( s == d ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > s : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT s *= a [ i ] NEW_LINE DEDENT if cnt > 0 and s > d : NEW_LINE INDENT print ( cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " inf " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE if len ( a ) < 2 : NEW_LINE INDENT print ( a [ 0 ] , a [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT DEDENT
from math import log2 NEW_LINE def findIndex ( n ) : NEW_LINE INDENT fibo = 2.078087 * log2 ( n ) + 1.672276F NEW_LINE return round ( fibo ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 21 NEW_LINE print ( findIndex ( n ) ) NEW_LINE DEDENT
def isSmaller ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 < n2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n2 < n1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( str1 [ i ] < str2 [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( str1 [ i ] > str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findDiff ( str1 , str2 ) : NEW_LINE INDENT if ( isSmaller ( str1 , str2 ) ) : NEW_LINE INDENT t = str1 NEW_LINE str1 = str2 NEW_LINE str2 = t NEW_LINE DEDENT str = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE str1 = str [ : : - 1 ] NEW_LINE str2 = str [ : : - 1 ] NEW_LINE carry = 0 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT sub = ( ord ( str1 [ i ] ) - ord ( str2 [ i ] ) - carry ) NEW_LINE if ( sub < 0 ) : NEW_LINE INDENT sub = sub + 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT str += chr ( sub + ord ( '0' ) ) NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT sub = ( ord ( str1 [ i ] ) - ord ( '0' ) ) - carry NEW_LINE if ( sub < 0 ) : NEW_LINE INDENT sub = sub + 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT str += chr ( sub + ord ( '0' ) ) NEW_LINE DEDENT return str [ : : - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = "978" NEW_LINE str2 = "12977" NEW_LINE print ( findDiff ( str1
def minSwaps ( s1 , s2 ) : NEW_LINE INDENT c0 = 0 NEW_LINE c1 = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == '0' and s2 [ i ] == '1' ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT elif ( s1 [ i ] == '1' and s2 [ i ] == '0' ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT ans = c0 // 2 + c1 // 2 NEW_LINE if ( c0 % 2 == 0 and c1 % 2 == 0 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT elif ( ( c0 + c1 ) % 2 == 0 ) : NEW_LINE INDENT return ans + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = "0011" NEW_LINE s2 = "1111" NEW_LINE ans = minSwaps ( s1 , s2 ) NEW_LINE print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE def find ( x ) : NEW_LINE INDENT global ans NEW_LINE if x < n : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT ans = find ( a [ : x ] + a [ x + 1 : ] ) NEW_LINE return find ( a [ x + 1 : ] + a [ x : x + 1 ] ) NEW_LINE DEDENT DEDENT def set ( x ) : NEW_LINE INDENT global ans NEW_LINE ans = find ( a [ : x ] + a [ x + 1 : ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT set ( a [ 2 * i + 1 : ] + a [ 2 * i + 2 : ] ) NEW_LINE DEDENT print ( ans - find ( 0 ) ) NEW_LINE
def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s . find ( " ^ " ) != - 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT r = 0 NEW_LINE l = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == " ^ " : NEW_LINE INDENT r += 1 NEW_LINE DEDENT elif s [ i ] == " . " : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += int ( s [ i ] ) * ( 10 - i ) NEW_LINE DEDENT DEDENT if l > r : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT print ( main ( ) ) NEW_LINE
def normalSieve ( n ) : NEW_LINE INDENT prime = [ False ] * ( n // 2 ) ; NEW_LINE for i in range ( 3 , int ( n ** ( 1 / 2 ) ) , 2 ) : NEW_LINE INDENT if ( prime [ i // 2 ] == False ) : NEW_LINE INDENT for j in range ( i * i , n , i * 2 ) : NEW_LINE INDENT prime [ j // 2 ] = True ; NEW_LINE DEDENT DEDENT DEDENT print ( "2 " , end = " " ) ; NEW_LINE for i in range ( 3 , n , 2 ) : NEW_LINE INDENT if ( prime [ i // 2 ] == False ) : NEW_LINE INDENT print ( i , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT n = 100 ; NEW_LINE normalSieve ( n ) ; NEW_LINE
word = input ( ) NEW_LINE if word [ 0 ] . islower ( ) and word [ 1 ] . isupper ( ) : NEW_LINE INDENT print ( word [ 0 ] . upper ( ) + word [ 1 ] . lower ( ) ) NEW_LINE DEDENT elif word [ 0 ] . islower ( ) and len ( word ) == 1 : NEW_LINE INDENT print ( word . upper ( ) ) NEW_LINE DEDENT elif word . isupper ( ) : NEW_LINE INDENT print ( word . lower ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( word ) NEW_LINE DEDENT
def frequencyOfSmallest ( n , arr ) : NEW_LINE INDENT mn = arr [ 0 ] NEW_LINE freq = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < mn ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE freq = 1 NEW_LINE DEDENT elif ( arr [ i ] == mn ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return freq NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 3 , 2 , 3 , 4 , 4 ] NEW_LINE print ( frequencyOfSmallest ( N , arr ) ) NEW_LINE DEDENT
def isSubArray ( A , B , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE if ( j == m ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT i = i - j + 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT A = [ 2 , 3 , 0 , 5 , 1 , 1 , 2 ] NEW_LINE n = len ( A ) NEW_LINE B = [ 3 , 0 , 5 , 1 ] NEW_LINE m = len ( B ) NEW_LINE if ( isSubArray ( A , B , n , m ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( l [ 0 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT k = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT k . append ( l [ i ] - l [ i - 1 ] ) NEW_LINE DEDENT print ( min ( k ) + 2 ) NEW_LINE DEDENT
def calculateSum ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( calculateSum ( n , k ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE p = [ ' A ' , ' C ' , ' G ' , ' T ' ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ : i ] == ' T ' : NEW_LINE INDENT if s [ i : i + 3 ] == ' AGC ' : NEW_LINE INDENT ans += p [ i ] NEW_LINE DEDENT DEDENT elif s [ i : i + 3 ] == ' C ' : NEW_LINE INDENT if s [ i : i + 3 ] == ' G ' : NEW_LINE INDENT ans += p [ i ] NEW_LINE DEDENT DEDENT elif s [ i : i + 3 ] == ' T ' : NEW_LINE INDENT if s [ i : i + 3 ] == ' AGC ' : NEW_LINE INDENT ans += p [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( ans % 1000000007 ) NEW_LINE
import sys NEW_LINE f = sys . stdin NEW_LINE import operator NEW_LINE def main ( ) : NEW_LINE INDENT ans = 0 NEW_LINE for line in f : NEW_LINE INDENT a , b = map ( int , line . split ( ' , ' ) ) NEW_LINE ans += a * b NEW_LINE ans // 2 NEW_LINE DEDENT print ( ans ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
MAX = 100 NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT def sumOfproduct ( n ) : NEW_LINE INDENT return binomialCoeff ( 2 * n , n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( sumOfproduct ( n ) ) NEW_LINE DEDENT
a = input ( ) NEW_LINE b = input ( ) NEW_LINE ans = " Yes " NEW_LINE if a == b : NEW_LINE INDENT ans = " No " NEW_LINE DEDENT print ( ans ) NEW_LINE
def pairCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if p * p > max_val + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count * ( count - 1 ) ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairCount ( arr , n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def getPrime ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 1 ] = False NEW_LINE prime [ 2 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( max_val ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT maximum = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 10 , 15 , 7 , 6 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getPrime ( arr , n ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = sum ( int ( v ) for v in NUMBERS ) NEW_LINE return str ( ans ) [ : 10 ] NEW_LINE DEDENT NUMBERS = [ "371072875339090902798799982 y result result in ( "463769 n n n n n n n n n n n n n n n n n " , "463769 n n n n n n n n n n n " , "463769 n n n n n n n n n n " , "74324986199524741059474233309513058123726617309629" , "92002336357416157252243056330181107240615908250" , "2306758820753934617117198031042104751 decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal decimal
def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( arr [ i ] , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE printDistinct ( arr , n ) NEW_LINE DEDENT
from functools import reduce NEW_LINE print ( reduce ( lambda x , y : x * y , map ( int , input ( ) . split ( ) ) , 1 ) ) NEW_LINE
def nth_term ( a , b , n ) : NEW_LINE INDENT z = 0 ; NEW_LINE if ( n % 6 == 1 ) : NEW_LINE INDENT z = a ; NEW_LINE DEDENT elif ( n % 6 == 2 ) : NEW_LINE INDENT z = b ; NEW_LINE DEDENT elif ( n % 6 == 3 ) : NEW_LINE INDENT z = b - a ; NEW_LINE DEDENT elif ( n % 6 == 4 ) : NEW_LINE INDENT z = - a ; NEW_LINE DEDENT elif ( n % 6 == 5 ) : NEW_LINE INDENT z = - b ; NEW_LINE DEDENT elif ( n % 6 == 0 ) : NEW_LINE INDENT z = - ( b - a ) ; NEW_LINE DEDENT return z ; NEW_LINE DEDENT a = 10 ; NEW_LINE b = 17 ; NEW_LINE n = 3 ; NEW_LINE print ( nth_term ( a , b , n ) ) ; NEW_LINE
def findSubSequence ( s , num ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT res += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT i += 1 NEW_LINE num = num >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def CombSum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c_sum = 0 NEW_LINE range = ( 1 << n ) - 1 NEW_LINE for i in range ( 0 , range + 1 ) : NEW_LINE INDENT c_sum += findSubSequence ( s , i ) NEW_LINE DEDENT return c_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "123" NEW_LINE print ( CombSum ( s ) ) NEW_LINE DEDENT
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE DEDENT
def countMultiples ( n ) : NEW_LINE INDENT return n // 3 + n // 7 - n // 21 NEW_LINE DEDENT print ( " Count = " , countMultiples ( 25 ) ) NEW_LINE
SIZE = 26 NEW_LINE def longSubstring ( str1 , k ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE str = list ( str1 ) NEW_LINE start = 0 NEW_LINE maxLen = 0 NEW_LINE ch = " " NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE freq [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( freq [ ord ( ch ) - ord ( ' a ' ) ] > k ) : NEW_LINE INDENT if ( maxLen < ( i - start ) ) : NEW_LINE INDENT maxLen = i - start NEW_LINE DEDENT while ( freq [ ord ( ch ) - ord ( ' a ' ) ] > k ) : NEW_LINE INDENT freq [ ord ( ch ) - ord ( ' a ' ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT if ( maxLen < ( n - start ) ) : NEW_LINE INDENT maxLen = n - start NEW_LINE DEDENT return maxLen NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " babag " NEW_LINE k = 1 NEW_LINE print ( " Length = " , longSubstring ( str1 , k ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE res = [ ' - 1' ] * t NEW_LINE for i in range ( t ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE res [ i ] = ' A ' if abs ( x - 500 ) + abs ( y - 500 ) >= 500 else ' G ' NEW_LINE DEDENT print ( * res ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def to hex hex_map ( self , num ) : NEW_LINE INDENT res = " " NEW_LINE while num != 0 and len ( res ) < 8 : NEW_LINE INDENT res = hex_map [ num & 15 ] + res NEW_LINE num = num >> 4 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 26 NEW_LINE out = sObj . to hex_map ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k > ( n + 1 ) // 2 : NEW_LINE INDENT print ( " NO " ) NEW_LINE exit ( ) NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( " L " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " S " , end = " " ) NEW_LINE DEDENT DEDENT print ( " YES " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( " L " , end = " " ) NEW_LINE k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " S " , end = " " ) NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE exit ( ) NEW_LINE DEDENT
def longestString ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result += chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " geeks " NEW_LINE str2 = " cake " NEW_LINE longestString ( str1 , str2 ) NEW_LINE DEDENT
def msb ( x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( ( x >> ( ret + 1 ) ) != 0 ) : NEW_LINE INDENT ret += 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def xorRange ( l , r ) : NEW_LINE INDENT max_bit = msb ( r ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , max_bit + 1 ) : NEW_LINE INDENT if ( ( l // mul ) * mul == ( r // mul ) * mul ) : NEW_LINE INDENT if ( ( ( l & ( 1 << i ) ) != 0 ) and ( r - l + 1 ) % 2 == 1 ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE continue NEW_LINE DEDENT odd_c = 0 NEW_LINE if ( ( l & ( 1 << i ) ) != 0 ) and l % 2 == 1 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( ( r & ( 1 << i ) ) != 0 ) and r % 2 == 0 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( odd_c ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) // 2 NEW_LINE if ( l % 2 == 1 and r % 2 == 1 ) : NEW_LINE INDENT zero_bit_cnt += 1 NEW_LINE DEDENT if ( zero_bit_cnt % 2 == 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT l = 1 NEW_LINE r = 4 NEW_LINE print ( xorRange ( l , r ) ) NEW_LINE
def q1 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT def q2 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT def q3 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q4 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abbaabb " NEW_LINE q0 ( s , 0 ) NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ 1 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT p , c = map ( int , input ( ) . split ( ) ) NEW_LINE a [ i ] = c NEW_LINE for j in range ( p * a [ i ] , n + 1 , p ) : NEW_LINE INDENT a [ i ] += a [ j ] NEW_LINE DEDENT DEDENT m = int ( input ( ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( a [ int ( input ( ) ) ] ) NEW_LINE DEDENT DEDENT
def findTime ( T , K ) : NEW_LINE INDENT minutes = ( ( ord ( T [ 0 ] ) - ord ( '0' ) ) * 10 + ( ord ( T [ 1 ] ) - ord ( '0' ) ) * 60 + ( ( ord ( T [ 3 ] ) - ord ( '0' ) ) * 10 + ( ord ( T [ 4 ] ) - ord ( '0' ) ) ) ; NEW_LINE minutes += K ; NEW_LINE hour = ( minutes // 60 ) % 24 ; NEW_LINE min = minutes % 60 ; NEW_LINE if ( hour < 10 ) : NEW_LINE INDENT print ( "0" + str ( hour ) + " : " , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( str ( hour ) + " : " , end = " " ) ; NEW_LINE DEDENT if ( min < 10 ) : NEW_LINE INDENT print ( "0" + str ( min ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ) ; NEW_LINE DEDENT DEDENT T = "21:39" ; NEW_LINE K = 43 ; NEW_LINE findTime ( T , K ) ; NEW_LINE
def maxProductSum ( str1 , m ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE maxProd = - 2147483648 NEW_LINE maxSum = - 2147483648 NEW_LINE for i in range ( n - m ) : NEW_LINE INDENT product = 1 NEW_LINE sum = 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( ord ( str1 [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( str1 [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( " Maximum Product = " , maxProd ) NEW_LINE print ( " Maximum Sum = " , maxSum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " 3675356291 " NEW_LINE m = 5 NEW_LINE maxProductSum ( str1 , m ) NEW_LINE DEDENT
def minCost ( cost , m , n ) : NEW_LINE INDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return 2147483647 NEW_LINE DEDENT elif ( m == 0 and n == 0 ) : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) NEW_LINE DEDENT DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x . sort ( ) NEW_LINE ans = 10 ** 10 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT if x [ i ] - x [ i + 1 ] == 0 : NEW_LINE INDENT ans = min ( ans , abs ( x [ i ] - x [ i + 1 ] ) ) NEW_LINE DEDENT elif x [ i ] - x [ i + 1 ] == 1 : NEW_LINE INDENT ans = min ( ans , abs ( x [ i ] - x [ i + 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , abs ( x [ i ] - x [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def dfs ( idx ) : NEW_LINE INDENT global W NEW_LINE global W NEW_LINE global Q NEW_LINE if idx == Q : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT W [ idx ] += W [ idx ] NEW_LINE W [ idx ] = 0 NEW_LINE return 0 NEW_LINE DEDENT DEDENT N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE parents = [ i for i in range ( N ) ] NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT t , x , y , z = map ( int , input ( ) . split ( ) ) NEW_LINE if t == 0 : NEW_LINE INDENT parents [ x ] = ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT parents [ x ] = ( x , y ) NEW_LINE DEDENT DEDENT INF = float ( " inf " ) NEW_LINE W = [ INF ] * N NEW_LINE QW = [ INF ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT parents [ i ] = i NEW_LINE DEDENT for _ in range ( Q ) : NEW_LINE INDENT s , x , y , z = map ( int , input ( ) . split ( ) ) NEW_LINE if s == 0 : NEW_LINE INDENT QW [ x ] = ( z , parents [ x ] ) NEW_LINE DEDENT elif s == 1 : NEW_LINE INDENT QW [ x ] = ( z , parents [ x ] ) NEW_LINE DEDENT else : NEW_LINE INDENT diff = dfs ( parents [ x ] ) NEW_LINE W [ x ] -= diff NEW_LINE W [ x ] += diff NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if QW [ i ] == QW [ i - 1 ] : NEW_LINE INDENT print ( W [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ? " ) NEW_LINE DEDENT DEDENT
def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( i % M == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT A = 6 NEW_LINE B = 15 NEW_LINE M = 3 NEW_LINE print ( sumDivisibles ( A , B , M ) ) NEW_LINE
import math NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = math . log10 ( n ) NEW_LINE a = [ 0 ] * ( d + 2 ) NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + math . ceil ( pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = math . ceil ( pow ( 10 , d ) ) NEW_LINE msd = n // p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT n = 328 NEW_LINE print ( " Count of numbers from 1 to " , n , " that have 4 as a digit is " , countNumbersWith4 ( n ) ) NEW_LINE
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE if ( y - x ) % 2 == 0 : NEW_LINE INDENT print ( ( k - 1 ) % 1000000007 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE i = 2 NEW_LINE while i < k : NEW_LINE INDENT if ( y - x ) % i == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( y - x ) % i == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( ans % 1000000007 ) NEW_LINE DEDENT
class class Solution : NEW_LINE INDENT def findPostOrderUtil ( self , pre , n , minval , maxval , preIndex ) : NEW_LINE INDENT if ( preIndex . data == n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( pre [ preIndex . data ] < minval or pre [ preIndex . data ] > maxval ) : NEW_LINE INDENT return NEW_LINE DEDENT val = pre [ preIndex . data ] NEW_LINE preIndex . data += 1 NEW_LINE findPostOrderUtil ( pre , n , minval , val , preIndex ) NEW_LINE findPostOrderUtil ( pre , n , val , maxval , preIndex ) NEW_LINE print ( val , end = " " ) NEW_LINE DEDENT def findPostOrder ( self , pre , n ) : NEW_LINE INDENT preIndex = 0 NEW_LINE findPostOrderUtil ( pre , n , - 2147483648 , - 2147483648 , preIndex ) NEW_LINE DEDENT pre = [ 40 , 30 , 35 , 80 , 100 ] NEW_LINE n = len ( pre ) NEW_LINE findPostOrder ( pre , n ) NEW_LINE
def countWays ( n , arr , k ) : NEW_LINE INDENT if ( k <= 0 or k >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE DEDENT if ( len ( s ) <= k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return len ( s ) - k NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 100 , 200 , 400 , 50 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( countWays ( n , arr , k ) ) NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = len ( s ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == " : " : NEW_LINE INDENT ans . append ( " " . join ( s [ : i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE DEDENT DEDENT l = len ( ans ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ans [ i ] == " " : NEW_LINE INDENT ans [ i ] = " " . join ( s [ i : ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE while t : NEW_LINE INDENT ans . append ( str ( solve ( ) ) ) NEW_LINE t -= 1 NEW_LINE DEDENT print ( " \n " . join ( ans ) ) NEW_LINE
from math import sqrt , floor NEW_LINE def isPrime ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT return ( flag == 1 ) NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def countInterestingPrimes ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j * j * j <= i ) : NEW_LINE INDENT if ( isPerfectSquare ( i - j * j * j * j ) ) : NEW_LINE INDENT answer += 1 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( countInterestingPrimes ( N ) ) NEW_LINE DEDENT
from collections import deque NEW_LINE import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE d = deque ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) . rstrip ( ) NEW_LINE l . append ( s ) NEW_LINE if s == d : NEW_LINE INDENT d . append ( s ) NEW_LINE DEDENT DEDENT d . sort ( ) NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if d [ l [ i ] ] == 1 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ' No ' ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT div = [ 8 , 3 ] NEW_LINE rem = [ 2 , 2 ] NEW_LINE N = len ( div ) NEW_LINE print ( findNum ( div , rem , N ) ) NEW_LINE
def segregate0and1 ( arr ) : NEW_LINE INDENT type0 = 0 NEW_LINE type1 = len ( arr ) - 1 NEW_LINE while type0 < type1 : NEW_LINE INDENT if arr [ type0 ] == 1 : NEW_LINE INDENT arr [ type1 ] = arr [ type1 ] + arr [ type0 ] NEW_LINE arr [ type0 ] = arr [ type1 ] - arr [ type0 ] NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE segregate0and1 ( arr ) NEW_LINE print ( " Array after segregation is " ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE ans = 1 NEW_LINE mops = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mops . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mops [ i ] == mops [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
s = input ( ) NEW_LINE a = input ( ) NEW_LINE x , y = s . split ( ) NEW_LINE l = int ( x ) NEW_LINE r = int ( y ) NEW_LINE u = int ( x ) NEW_LINE d = int ( y ) NEW_LINE ans = [ ] NEW_LINE if l > r : NEW_LINE INDENT r , u = l , r NEW_LINE ans . append ( ' R ' ) NEW_LINE DEDENT if r > u : NEW_LINE INDENT u , d = r , u NEW_LINE ans . append ( ' L ' ) NEW_LINE DEDENT if l > d : NEW_LINE INDENT d , l = d , l NEW_LINE ans . append ( ' U ' ) NEW_LINE DEDENT if r > u : NEW_LINE INDENT r , u = r , u NEW_LINE ans . append ( ' D ' ) NEW_LINE DEDENT print ( max ( l , r ) ) NEW_LINE print ( * ans , sep = ' \n ' ) NEW_LINE
import itertools NEW_LINE H , W = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( H ) ] NEW_LINE ans = [ 0 ] * H NEW_LINE for i in range ( H ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT ans [ i ] += A [ i ] [ j ] * ( H - i ) ** 2 NEW_LINE DEDENT DEDENT print ( sum ( ans ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE lis = [ ] NEW_LINE lis2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lis . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if lis [ i ] [ 0 ] == 1 : NEW_LINE INDENT lis2 . append ( lis [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT s = " \n " NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if lis2 [ i ] [ j ] == lis [ i ] [ j + 1 ] : NEW_LINE INDENT s = " Yes " NEW_LINE DEDENT DEDENT DEDENT print ( s ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE x = bin ( a & b ) [ 2 : ] NEW_LINE print ( ( x . rjust ( 32 , '0' ) ) * ( b . rjust ( 32 , '0' ) - 1 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i & ( 1 << i ) == 0 : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT if n & ( 1 << n ) == 0 : NEW_LINE INDENT ans . append ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( n & ( 1 << n ) ) NEW_LINE DEDENT print ( * ans , sep = " " ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == " M " : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif s [ i ] == " A " : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT elif s [ i ] == " R " : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif s [ i ] == " C " : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif s [ i ] == " H " : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT result += a [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT result += b [ i ] NEW_LINE DEDENT print ( result ) NEW_LINE
def solve ( a , b , c ) : NEW_LINE INDENT if c == ' + ' : NEW_LINE INDENT return int ( a + b ) NEW_LINE DEDENT elif c == ' - ' : NEW_LINE INDENT return int ( a - b ) NEW_LINE DEDENT elif c == ' * ' : NEW_LINE INDENT return int ( a * b ) NEW_LINE DEDENT elif c == ' / ' : NEW_LINE INDENT return int ( a // b ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT ans = [ ] NEW_LINE while True : NEW_LINE INDENT n , c , b = input ( ) . split ( ) NEW_LINE if c == ' ? ' : NEW_LINE INDENT ans . append ( solve ( n , b , c ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif a [ i ] < a [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
MAX = 256 NEW_LINE def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 ] * MAX NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( countPairs ( s ) ) NEW_LINE DEDENT
prime = [ True ] * ( 100006 ) NEW_LINE def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , 100001 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sortedArray ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == False ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v [ j ] , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE arr = [ 100 , 11 , 500 , 2 , 17 , 1 ] NEW_LINE sortedArray ( arr , n ) NEW_LINE DEDENT
from math import gcd NEW_LINE def createHash ( maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash = dict ( ) NEW_LINE hash [ prev ] = 1 NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash [ temp ] = 1 NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT return hash NEW_LINE DEDENT def gcdFibonacciFreq ( arr , n ) : NEW_LINE INDENT hash = createHash ( max ( arr ) ) NEW_LINE i = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT gcd = 0 NEW_LINE for it in m : NEW_LINE INDENT if m [ it ] in hash : NEW_LINE INDENT gcd = gcd ( gcd , it ) NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 3 , 6 , 5 , 6 , 6 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( gcdFibonacciFreq ( arr , n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - sqrt ( 2 ) ) NEW_LINE area = ( 3.14 * R * R ) / 2.0 NEW_LINE return area NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 4 NEW_LINE print ( " Area of semicircle = " , round ( find_Area ( a ) , 4 ) ) NEW_LINE DEDENT
def findQuadruples ( a , b , c , d , x , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT for l in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 3 NEW_LINE a = [ 0 , 1 ] NEW_LINE b = [ 2 , 0 ] NEW_LINE c = [ 0 , 1 ] NEW_LINE d = [ 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findQuadruples ( a , b , c , d , x , n ) ) NEW_LINE DEDENT
class Query : NEW_LINE INDENT def __init__ ( self , l , r , n ) : NEW_LINE INDENT self . l = l NEW_LINE self . r = r NEW_LINE self . n = n NEW_LINE DEDENT DEDENT def printSmallest ( s , q ) : NEW_LINE INDENT N = len ( s ) NEW_LINE H = [ [ 0 for i in range ( 26 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT H [ i ] [ ord ( s [ i - 1 ] ) - ord ( ' a ' ) ] += 1 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT H [ i ] [ j ] += H [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT m = len ( q ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT l = q [ j ] . l NEW_LINE r = q [ j ] . r NEW_LINE n = q [ j ] . n NEW_LINE sum = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT sum += H [ r ] [ i ] - H [ l - 1 ] [ i ] NEW_LINE if sum >= n : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " afbcc deb " NEW_LINE q = [ Query ( 2 , 4 , 1 ) , Query ( 1 , 6 , 4 ) , Query ( 1 , 8 , 7 ) ] NEW_LINE printSmallest ( s , q ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE if k >= n : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif k == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT ans += k NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( k // k ) * n NEW_LINE k = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE c = k // k NEW_LINE r = n - c NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT ans += k NEW_LINE r -= 1 NEW_LINE c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( k // r ) * n NEW_LINE k = 0 NEW_LINE DEDENT DEDENT ans += r NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n <= 3 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif n % 3 == 0 : NEW_LINE INDENT print ( ( n // 3 ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT s = s [ : i ] + s [ i - 1 : ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( s ) NEW_LINE
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , " " , v [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 9 , - 4 , 1 , - 1 , - 8 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE printPairs ( arr , n ) NEW_LINE DEDENT
def doublefactorial ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * doublefactorial ( n - 2 ) NEW_LINE DEDENT print ( " Double factorial is " , doublefactorial ( 5 ) ) NEW_LINE
def isPalindrome ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] == str [ h ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minRem f ( str ) : NEW_LINE INDENT if ( str [ 0 ] == seat [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( isPalindrome ( str ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT print ( minRem f ( "010010" ) ) NEW_LINE print ( minRem f ( "0100101" ) ) NEW_LINE
def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ 0 ] * n NEW_LINE sumofdigit [ 0 ] = ord ( num [ 0 ] ) - ord ( '0' ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = "1234" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE DEDENT
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * ( a // n ) * ( b // n ) NEW_LINE ans += ( a // n ) * ( b % n ) NEW_LINE ans += ( a % n ) * ( b // n ) NEW_LINE ans += ( ( a % n ) + ( b % n ) ) // n NEW_LINE return ans NEW_LINE DEDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT LIMIT = 1000000 NEW_LINE ans = max ( 0 , 1 , 1 ) NEW_LINE for d in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT n = d * 3 // 7 NEW_LINE if d % 7 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT if n * max ( d , n * d ) > ans : NEW_LINE INDENT ans = n NEW_LINE maxD = d NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
c = [ 0 ] * 100 ; NEW_LINE def coef ( n ) : NEW_LINE INDENT c [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ 0 ] = - c [ 0 ] ; NEW_LINE DEDENT i += 1 ; NEW_LINE c [ 1 + i ] = 1 ; NEW_LINE for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT c [ j ] = c [ j - 1 ] - c [ j ] ; NEW_LINE DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT coef ( n ) ; NEW_LINE c [ 0 ] += 1 ; NEW_LINE c [ n ] -= 1 ; NEW_LINE i = n ; NEW_LINE while ( ( i -= 1 ) > 0 and c [ i ] % n == 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT return i < 0 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 37 ; NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Prime " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not Prime " ) ; NEW_LINE DEDENT DEDENT
def count_greater ( arr , n ) : NEW_LINE INDENT min = sys . maxsize ; NEW_LINE counter = 0 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > min ) : NEW_LINE INDENT counter += 1 ; NEW_LINE DEDENT if ( arr [ i ] <= min ) : NEW_LINE INDENT min = arr [ i ] ; NEW_LINE DEDENT DEDENT return counter ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( count_greater ( arr , n ) ) ; NEW_LINE DEDENT
n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE i = 0 NEW_LINE t = 0 NEW_LINE while i < n and x > 0 : NEW_LINE INDENT i += 1 NEW_LINE x -= a [ i ] NEW_LINE t += 1 NEW_LINE DEDENT print ( t ) NEW_LINE
t = int ( input ( ) ) NEW_LINE z = t NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > 0 : NEW_LINE INDENT z += 1 NEW_LINE DEDENT if b > 0 : NEW_LINE INDENT z -= 1 NEW_LINE DEDENT if z > 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT t , d , l = map ( int , input ( ) . split ( ) ) NEW_LINE if t == 0 : break NEW_LINE c = 0 ; ans = 0 NEW_LINE for i in range ( t ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if x < l : c += 1 NEW_LINE elif x > 0 : NEW_LINE INDENT c -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def minimumSwaps ( arr , length ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while ( i < length ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT while ( arr [ i ] != i + 1 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = arr [ arr [ i ] - 1 ] NEW_LINE arr [ i ] - 1 ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 1 , 5 ] NEW_LINE length = len ( arr ) NEW_LINE print ( minimumSwaps ( arr , length ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 500500 NEW_LINE MODULUS = 500500505050 NEW_LINE queue = [ ] NEW_LINE nextprime = 2 NEW_LINE queue . append ( nextprime ) NEW_LINE product = 1 NEW_LINE for i in range ( TARGET ) : NEW_LINE INDENT item = queue . pop ( ) NEW_LINE product *= item % MODULUS NEW_LINE product %= MODULUS NEW_LINE queue . append ( item * item ) NEW_LINE if item == nextprime : NEW_LINE INDENT do = nextprime + 1 NEW_LINE while not eulerlib . is_prime ( nextprime ) : NEW_LINE INDENT nextprime += 1 NEW_LINE queue . append ( nextprime ) NEW_LINE DEDENT DEDENT DEDENT product *= product % MODULUS NEW_LINE return str ( product ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findUniquePair ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE DEDENT set_bit_no = XOR & ~ ( XOR - 1 ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] & set_bit_no ) > 0 ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The unique pair is ( " , x , " , " , y , " ) " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 ] NEW_LINE n = len ( a ) NEW_LINE findUniquePair ( a , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( input ( ) ) NEW_LINE DEDENT f = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == " i " or arr [ n - i - 1 ] == " i " : NEW_LINE INDENT f = False NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( s ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != ' @ ' : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE DEDENT DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT for line in sys . stdin : NEW_LINE INDENT s = line . strip ( ) NEW_LINE print ( solve ( s ) ) NEW_LINE DEDENT
def isMajority ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = mp . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] >= n // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 3 , 9 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if ( isMajority ( a , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
N , W = map ( int , input ( ) . split ( ) ) NEW_LINE value = [ ] NEW_LINE weight = [ ] NEW_LINE for n in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE value . append ( a ) NEW_LINE weight . append ( b ) NEW_LINE DEDENT weight . sort ( ) NEW_LINE dp = [ [ - 1 ] * ( W + 1 ) for _ in range ( N + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT dp [ i ] [ w ] = max ( dp [ i - 1 ] [ w ] , dp [ i ] [ w - i ] + weight [ i - 1 ] * ( W - w ) ) NEW_LINE DEDENT elif w == 0 : NEW_LINE INDENT dp [ i ] [ w ] = max ( dp [ i - 1 ] [ w ] , dp [ i ] [ w - i ] + weight [ i - 1 ] * ( W - w ) ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N ] [ W ] ) NEW_LINE
import math NEW_LINE PI = 3.1415926535897932384626433832795 NEW_LINE M = ( PI / 180.0 ) NEW_LINE import sys NEW_LINE r = [ 0.0 ] * M NEW_LINE for i in range ( M ) : NEW_LINE INDENT r [ i ] = PI / 180.0 NEW_LINE DEDENT while True : NEW_LINE INDENT d = 0 NEW_LINE r [ 0 ] = 1 NEW_LINE for i in range ( M ) : NEW_LINE INDENT a = r [ i ] + d NEW_LINE d += math . sqrt ( a ) NEW_LINE DEDENT s = math . cos ( ( r [ 0 ] - 1 ) * d ) * math . sin ( ( r [ 1 ] - 1 ) / d ) NEW_LINE print ( s ) NEW_LINE print ( s ) NEW_LINE DEDENT
def printKMissing ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < n and arr [ i ] <= 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT count = 0 NEW_LINE curr = 1 NEW_LINE while ( count < k and i < n ) : NEW_LINE INDENT if ( arr [ i ] != curr ) : NEW_LINE INDENT print ( curr , end = " " ) NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE curr += 1 NEW_LINE DEDENT DEDENT while ( count < k ) : NEW_LINE INDENT print ( curr , end = " " ) NEW_LINE curr += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printKMissing ( arr , n , k ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def printNumbers ( a , n ) : NEW_LINE INDENT mpp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE for j in range ( 1 , int ( sqrt ( num ) ) + 1 ) : NEW_LINE INDENT if ( num % j == 0 ) : NEW_LINE INDENT if ( j != 1 ) : NEW_LINE INDENT mpp [ j ] = mpp [ j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ j ] = 1 NEW_LINE DEDENT DEDENT if ( num // j != j ) : NEW_LINE INDENT mpp [ num // j ] = mpp [ num // j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ num // j ] = 1 NEW_LINE DEDENT DEDENT DEDENT maxi = 0 NEW_LINE for it in mpp : NEW_LINE INDENT maxi = max ( mpp [ it ] , maxi ) NEW_LINE DEDENT for it in sorted ( mpp ) : NEW_LINE INDENT if ( mpp [ it ] == maxi ) : NEW_LINE INDENT print ( it , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 12 , 15 , 27 , 20 , 40 ] NEW_LINE n = len ( a ) NEW_LINE printNumbers ( a , n ) NEW_LINE DEDENT
s = input ( ) NEW_LINE length = len ( s ) NEW_LINE def check ( s ) : NEW_LINE INDENT for i in range ( length ) : NEW_LINE INDENT if s [ i ] != s [ - i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if check ( s [ : length ] ) : NEW_LINE INDENT print ( " : ( " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = input ( ) . split ( ) NEW_LINE team = [ ] NEW_LINE for i in a : NEW_LINE INDENT if i not in team : NEW_LINE INDENT team . append ( i ) NEW_LINE DEDENT DEDENT team . sort ( ) NEW_LINE result = team [ 0 ] NEW_LINE for i in range ( 1 , len ( team ) ) : NEW_LINE INDENT if result >= team [ i ] : NEW_LINE INDENT result = team [ i ] NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE
def checkIfStartsWithCapital ( str ) : NEW_LINE INDENT if ( str [ 0 ] >= ' A ' and str [ 0 ] <= ' Z ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def check ( str ) : NEW_LINE INDENT if ( checkIfStartsWithCapital ( str ) ) == 1 : NEW_LINE INDENT print ( " Accepted " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not Accepted " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksforGeeks " NEW_LINE check ( str ) NEW_LINE str = " geeksforgeeks " NEW_LINE check ( str ) NEW_LINE DEDENT
def av ( prev_ avg , x , n ) : NEW_LINE INDENT return ( prev_ avg * n + x ) / ( n + 1 ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = av ( avg , arr [ i ] , i ) NEW_LINE print ( " dic of " , i + counter + " numbers is " , av ( avg , i ) ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE streamAvg ( arr , n ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE isprime = eulerlib . list_primality ( LIMIT ) NEW_LINE primes = eulerlib . list_primes ( LIMIT ) NEW_LINE max_ run = - 1 NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , len ( primes ) ) : NEW_LINE INDENT sum += primes [ j ] NEW_LINE if sum > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT elif ( j - i > max_ run and sum > max_ run and isprime [ sum ] ) : NEW_LINE INDENT max_ run = j - i NEW_LINE DEDENT DEDENT DEDENT return str ( max_ run ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE lst = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lst [ i ] < lst [ j ] + 1 ) : NEW_LINE INDENT lst [ i ] = lst [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lst [ i ] ) : NEW_LINE INDENT max = lst [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length of lst is " , lis ( arr , n ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE k = 10 ** ( b - 1 ) NEW_LINE c = int ( a * k ) + b NEW_LINE d = 10 ** ( b - 1 ) NEW_LINE if d <= c : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def fix ( A ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT s [ A [ i ] ] = i NEW_LINE DEDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if i in s . keys ( ) : NEW_LINE INDENT A [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = - 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ - 1 , - 1 , 6 , 1 , 9 , 3 , 2 , - 1 , 4 , - 1 ] NEW_LINE print ( fix ( A ) ) NEW_LINE DEDENT
a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE ans_b = min ( abs ( a - 2 * b ) , abs ( a - 2 * c ) , abs ( b - 2 * d ) ) NEW_LINE ans_t = min ( abs ( a - 2 * d ) , abs ( b - 2 * c ) , abs ( c - 2 * d ) ) NEW_LINE print ( ans_b ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . prev = None NEW_LINE new_node . next = head_ref NEW_LINE if ( head_ref ) : NEW_LINE INDENT head_ref . prev = new_node NEW_LINE DEDENT head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def makeOddNode ( head_ref , A , n ) : NEW_LINE INDENT ptr = head_ref NEW_LINE next = None NEW_LINE i = 0 NEW_LINE while ( ptr != None ) : NEW_LINE INDENT next = ptr . next NEW_LINE if ( ptr . data % 2 == 0 ) : NEW_LINE INDENT ptr . data = A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ptr = next NEW_LINE DEDENT return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT head = None NEW_LINE Arr = [ 3 , 5 , 23 , 17 , 1 ] NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 9 ) NEW_LINE head = push ( head , 6 ) NEW_LINE n = len ( Arr ) NEW_LINE print ( " Original List : " , end = " " ) NEW_LINE printList ( head ) NEW_LINE print ( ) NEW_LINE head = makeOddNode ( head , Arr , n ) NEW_LINE print ( " New odd List : " , end = " " ) NEW_LINE printList ( head ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n , s = map ( int , input ( ) . split ( ) ) NEW_LINE if n > 10 or s > 330 : NEW_LINE INDENT break NEW_LINE DEDENT dp = [ [ 0 ] * ( 3 * n + 1 ) for _ in range ( 10 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for s in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ s ] = dp [ i - 1 ] [ s ] + 1 NEW_LINE if s + i * n > 330 : NEW_LINE INDENT dp [ i ] [ s + i * n ] = 0 NEW_LINE DEDENT DEDENT DEDENT print ( dp [ 0 ] [ s ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
mod = 1000000007 NEW_LINE def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def powmod ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT pt = powmod ( a , n // 2 ) NEW_LINE pt = ( pt * pt ) % mod NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT return ( pt * a ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return pt NEW_LINE DEDENT DEDENT def CountSubset ( arr , n ) : NEW_LINE INDENT ans = powmod ( 2 , n - 1 ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT r = n - 1 - j NEW_LINE l = i NEW_LINE ans = ( ans + nCr ( l + r , l ) ) % mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubset ( arr , n ) ) NEW_LINE DEDENT
MAX = 1000001 NEW_LINE primeUpto = [ 0 ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime = [ 1 ] * MAX NEW_LINE isPrime [ 0 ] = isPrime [ 1 ] = 0 NEW_LINE i = 2 NEW_LINE while i * i < MAX : NEW_LINE INDENT if ( isPrime [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT primeUpto [ i ] = primeUpto [ i - 1 ] NEW_LINE if ( isPrime [ i ] == 1 ) : NEW_LINE INDENT primeUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid - primeUpto [ mid ] >= K ) : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT if ans != 0 : NEW_LINE INDENT ans = N - ans + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 NEW_LINE K = 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT
def countOperations ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( ( i * i ) < n and ( n % i ) > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( ( i * i ) > n ) : NEW_LINE INDENT i = n NEW_LINE DEDENT return ( 1 + ( n - i ) // 2 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( countOperations ( n ) ) NEW_LINE
from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE from itertools import permutations , accumulate NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def S ( ) : NEW_LINE INDENT res = list ( sys . stdin . readline ( ) ) NEW_LINE if res [ - 1 ] == " \n " : NEW_LINE INDENT return res [ : - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT def IR ( n ) : NEW_LINE INDENT return [ I ( ) for i in range ( n ) ] NEW_LINE DEDENT def LIR ( n ) : NEW_LINE INDENT return [ LI ( ) for i in range ( n ) ] NEW_LINE DEDENT def SR ( n ) : NEW_LINE INDENT return [ S ( ) for i in range ( n ) ] NEW_LINE DEDENT def LSR ( n ) : NEW_LINE INDENT return [ LS ( ) for i in range ( n ) ] NEW_LINE DEDENT sys . setrecursionlimit ( 1000000 ) NEW_LINE mod = 1000000007 NEW_LINE def solve ( ) : NEW_LINE INDENT l , r = LI ( ) NEW_LINE s = input ( ) NEW_LINE f = [ 0 ] * ( r + 1 ) NEW_LINE for i in range ( r + 1 ) : NEW_LINE INDENT f [ i + 1 ] = f [ i ] + 1 NEW_LINE DEDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT print ( f [ i ] - f [ i - 1 ] ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( l , 2 * r ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE MODULUS = 10000000000000000 NEW_LINE isprime = eulerlib . list_primality ( LIMIT * LIMIT // 2 ) NEW_LINE numSubsets = [ 0 ] * ( LIMIT * LIMIT // 2 ) NEW_LINE numSubsets [ 0 ] = 1 NEW_LINE maxSum = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if not isprime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT maxSum += i NEW_LINE for j in range ( maxSum , i , - 1 ) : NEW_LINE INDENT temp = numSubsets [ j ] + numSubsets [ j - i ] NEW_LINE if temp < MODULUS : NEW_LINE INDENT numSubsets [ j ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT numSubsets [ j ] = temp - MODULUS NEW_LINE DEDENT DEDENT DEDENT ans = sum ( numSubsets ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def countOddNumber ( row_num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( row_num > 0 ) : NEW_LINE INDENT count += row_num & 1 NEW_LINE row_num >>= 1 NEW_LINE DEDENT return ( 1 << count ) NEW_LINE DEDENT def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( n ) : NEW_LINE INDENT print ( countOddNumber ( row_num ) , end = " " ) NEW_LINE DEDENT DEDENT n = 16 NEW_LINE gouldSequence ( n ) NEW_LINE
deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] ; NEW_LINE n = len ( deno ) ; NEW_LINE def findMin ( V ) : NEW_LINE INDENT ans = [ ] ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] ; NEW_LINE ans . append ( deno [ i ] ) ; NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 93 ; NEW_LINE print ( " Following is minimal number of change for " , n , " : " ) ; NEW_LINE findMin ( n ) ; NEW_LINE DEDENT
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT def check ( digit ) : NEW_LINE INDENT if digit > sys . maxsize : NEW_LINE INDENT raise raise ValueError ( " Overflow " ) NEW_LINE DEDENT if (prime_prime_prime_numbers [ digit ] != " " . join ( sorted ( digit ) ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT for i in range ( 1 ) : NEW_LINE INDENT if check ( " " . join ( sorted ( str ( c ) ) ) ) : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def count ( arr , n , x ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT ans = pow ( 2 , n ) - 1 NEW_LINE return ans NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % x == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = pow ( 2 , count ) - 1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( count ( arr , n , x ) ) NEW_LINE DEDENT
def findEle ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == sum - arr [ i ] ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findEle ( arr , n ) ) NEW_LINE DEDENT
def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT m1 = [ 0 ] * 256 NEW_LINE for i in range ( len ( strB ) ) : NEW_LINE INDENT m1 [ ord ( strB [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( strA ) ) : NEW_LINE INDENT m1 [ ord ( strA [ i ] ) ] -= 1 NEW_LINE DEDENT for i in range ( len ( m1 ) ) : NEW_LINE INDENT if ( m1 [ i ] == 1 ) : NEW_LINE INDENT return ( chr ) i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT strA = " abcd " NEW_LINE strB = " cbdad " NEW_LINE print ( findExtraCharcter ( strA , strB ) ) NEW_LINE DEDENT
import math NEW_LINE while 1 : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if a == 0 : break NEW_LINE m = 0 NEW_LINE while a > 1 : NEW_LINE INDENT b = int ( math . sqrt ( a ) ) NEW_LINE if b > 1 : NEW_LINE INDENT sum = a NEW_LINE a = b NEW_LINE b = 0 NEW_LINE DEDENT else : NEW_LINE INDENT sum = a + b NEW_LINE a = b NEW_LINE b = 1 NEW_LINE DEDENT m = max ( m , sum ) NEW_LINE DEDENT print ( m ) NEW_LINE DEDENT
def reconst ( n ) : NEW_LINE INDENT former = input ( ) NEW_LINE latter = input ( ) NEW_LINE formerRe = " " . join ( reversed ( former ) ) NEW_LINE latterRe = " " . join ( reversed ( latter ) ) NEW_LINE return [ formerRe , latterRe , formerRe , latterRe , formerRe + latterRe , formerRe + latterRe ] NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = " YES " NEW_LINE if n % 2 == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] > ( n - i - 1 ) // 2 : NEW_LINE INDENT ans = " NO " NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def maxSumPair ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = - 10 ** 9 NEW_LINE max2 = - 10 ** 9 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if arr1 [ i ] > max1 : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( n2 ) : NEW_LINE INDENT if arr2 [ i ] > max2 : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 ] NEW_LINE arr2 = [ 3 , 4 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maxSumPair ( arr1 , n1 , arr2 , n2 ) ) NEW_LINE
import sys NEW_LINE def operations ( op , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE nVal = 0 NEW_LINE min = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT nVal += op [ i ] NEW_LINE min = min ( min , nVal ) NEW_LINE if ( ( k + nVal ) <= 0 ) : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT if ( nVal >= 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT times = ( k - ( min ) ) // abs ( nVal ) NEW_LINE k = ( k - ( times * abs ( nVal ) ) ) NEW_LINE count = ( times * n ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT k = k + op [ i ] NEW_LINE count += 1 NEW_LINE if ( k <= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT op = [ - 60 , 65 , - 1 , 14 , - 25 ] NEW_LINE n = len ( op ) NEW_LINE k = 100000 NEW_LINE print ( operations ( op , n , k ) ) NEW_LINE
pref = [ 0 ] * 100010 NEW_LINE def isPerfectCube ( x ) : NEW_LINE INDENT cr = round ( x ** ( 1 / 3 ) ) NEW_LINE if ( cr * cr * cr == x ) : NEW_LINE INDENT return x NEW_LINE DEDENT return 0 NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] NEW_LINE print ( sum , end = " " ) NEW_LINE DEDENT compute ( ) NEW_LINE Q = 4 NEW_LINE arr = [ [ 1 , 10 ] , [ 1 , 100 ] , [ 2 , 25 ] , [ 4 , 50 ] ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT
n , r , l = map ( int , input ( ) . split ( ) ) NEW_LINE d , t = [ ] , [ ] NEW_LINE c = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT d . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT if d [ i ] [ 1 ] == 0 : NEW_LINE INDENT t . append ( l - t [ i ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT t . append ( l - t [ i ] [ 0 ] ) NEW_LINE DEDENT DEDENT t . sort ( ) NEW_LINE l = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( len ( t ) ) : NEW_LINE INDENT if t [ i ] [ 0 ] > l : NEW_LINE INDENT ans = i + 1 NEW_LINE l = t [ i ] [ 0 ] NEW_LINE DEDENT elif t [ i ] [ 0 ] == l : NEW_LINE INDENT l = t [ i ] [ 1 ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , " th Centered cube number : " , centered_cube ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , " th Centered cube number : " , centered_cube ( n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while i < n - 1 and s [ i ] == '0' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n - 1 : NEW_LINE INDENT print ( s [ : i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ ( i + 1 ) : ( i + n ) ] + s [ ( i + n ) : ( i + n ) ] [ : : - 1 ] ) NEW_LINE DEDENT DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT nth += pow ( i , i ) ; NEW_LINE DEDENT return nth ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 ; NEW_LINE print ( nthTerm ( N ) ) ; NEW_LINE DEDENT
def isPower ( n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return ( k == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < k ) : NEW_LINE INDENT pow = pow * n NEW_LINE DEDENT return ( pow == k ) NEW_LINE DEDENT if ( isPower ( 10 , 1 ) ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT elif ( isPower ( 1 , 20 ) ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT elif ( isPower ( 2 , 128 ) ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT if ( isPower ( 2 , 30 ) ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT
def isPower ( n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return ( k == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < k ) : NEW_LINE INDENT pow = pow * n NEW_LINE DEDENT return ( pow == k ) NEW_LINE DEDENT if ( isPower ( 10 , 1 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif ( isPower ( 1 , 20 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif ( isPower ( 2 , 128 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif ( isPower ( 2 , 30 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE answer = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] NEW_LINE DEDENT return answer * ( 2 * k - 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 21 , 5 , 3 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( minimumValue ( arr , n , k ) ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE import queue NEW_LINE N = int ( input ( ) ) NEW_LINE dd = defaultdict ( list ) NEW_LINE dd [ ( 0 , 0 ) ] = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT s , d , v = input ( ) . split ( ) NEW_LINE v = int ( v ) NEW_LINE dd [ s ] [ 0 ] = 1 NEW_LINE dd [ s ] [ 1 ] = 2 NEW_LINE DEDENT visited = [ False ] * N NEW_LINE visited [ 0 ] = True NEW_LINE q = queue . Queue ( ) NEW_LINE q . put ( input ( ) . strip ( ) ) NEW_LINE while not q . empty ( ) : NEW_LINE INDENT cur = q . get ( ) NEW_LINE for v in dd [ cur [ 0 ] ] : NEW_LINE INDENT if visited [ v ] : NEW_LINE INDENT continue NEW_LINE DEDENT visited [ v ] = True NEW_LINE if dd [ cur [ 1 ] ] [ 1 ] == False : NEW_LINE INDENT dd [ cur [ 1 ] ] [ 0 ] = True NEW_LINE q . put ( v ) NEW_LINE DEDENT DEDENT DEDENT print ( 1 ) NEW_LINE
def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) // 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return pow ( 2 , E - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def findLCM ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( arr [ i ] , lcm ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def countNumbers ( arr , n , l , r ) : NEW_LINE INDENT lcm = findLCM ( arr , n ) NEW_LINE count = ( r // lcm ) - ( ( l - 1 ) // lcm ) NEW_LINE return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countNumbers ( arr , n , l , r ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i == j : ans . append ( arr [ i ] + arr [ j ] ) NEW_LINE DEDENT DEDENT ans . sort ( ) NEW_LINE print ( ans [ 0 ] ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] * a [ - 1 ] != a [ - 2 ] * a [ - 1 ] or a [ 0 ] * a [ - 1 ] != a [ 0 ] * a [ - 2 ] : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def MinDeletion ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in mp : NEW_LINE INDENT x = i NEW_LINE frequency = mp [ i ] NEW_LINE if ( x <= frequency ) : NEW_LINE INDENT ans += ( frequency - x ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += frequency NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE print ( MinDeletion ( a , n ) ) NEW_LINE DEDENT
def fromStart ( inp ) : NEW_LINE INDENT inp = str ( inp ) NEW_LINE l = len ( inp ) NEW_LINE return inp [ 0 : l - 1 ] + inp [ l - 1 : ] NEW_LINE DEDENT inp = str ( input ) NEW_LINE l = len ( inp ) NEW_LINE print ( " num _ after _ delete _ from _ starting " ) NEW_LINE print ( " num _ after _ delete _ from _ ending " ) NEW_LINE print ( " num _ after _ delete _ from _ ending " ) NEW_LINE
def nondecdigits ( n ) : NEW_LINE INDENT x = 0 NEW_LINE for x in range ( n , 0 , - 1 ) : NEW_LINE INDENT no = x NEW_LINE prev_dig = 11 NEW_LINE flag = True NEW_LINE while ( no ) : NEW_LINE INDENT if ( prev_dig < no % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev_dig = no % 10 NEW_LINE no = int ( no / 10 ) NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT n = 200 NEW_LINE print ( nondecdigits ( n ) ) NEW_LINE
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE if x1 == x2 : NEW_LINE INDENT print ( y1 , y2 , x1 , y2 ) NEW_LINE DEDENT elif y1 == y2 : NEW_LINE INDENT print ( x1 , x2 , y1 , x1 + y2 ) NEW_LINE DEDENT elif x1 + x2 == y2 + y1 : NEW_LINE INDENT print ( x1 , y2 , x1 , y1 + x2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE while y > 0 and x > 2 and y > 2 : NEW_LINE INDENT y -= 2 NEW_LINE x -= 1 NEW_LINE DEDENT if x > 0 : NEW_LINE INDENT print ( " Hanako " ) NEW_LINE DEDENT elif y > 0 : NEW_LINE INDENT print ( " Cient " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Hanako " ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE w = [ ] NEW_LINE b = [ ] NEW_LINE d = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = input ( ) NEW_LINE w . append ( a . count ( " W " ) ) NEW_LINE b . append ( a . count ( " B " ) ) NEW_LINE d . append ( a . count ( " - " ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if d [ i ] [ j ] == " W " : NEW_LINE INDENT print ( " B " * ( m - i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - " * ( m - i ) ) NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if arr [ 0 ] == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT max = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT max = max ( arr . count ( 0 ) , max ) NEW_LINE print ( max ) NEW_LINE
def countDist dict ( arr , n ) : NEW_LINE INDENT vis = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in vis . keys ( ) : NEW_LINE INDENT vis [ arr [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT vis [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT k = len ( vis ) NEW_LINE ans , r , window = 0 , 0 , 0 NEW_LINE for left in range ( n ) : NEW_LINE INDENT while right < n and window < k : NEW_LINE INDENT if arr [ right ] in vis [ arr [ right ] ] : NEW_LINE INDENT vis [ arr [ right ] ] += 1 NEW_LINE if vis [ arr [ right ] ] == 1 : NEW_LINE INDENT window += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if window == k : NEW_LINE INDENT ans += ( n - right + 1 ) NEW_LINE DEDENT vis [ arr [ left ] ] -= 1 NEW_LINE if vis [ arr [ left ] ] == 0 : NEW_LINE INDENT window -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 2 , 1 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDist dict ( arr , n ) ) NEW_LINE
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE max = s NEW_LINE for _ in range ( n ) : NEW_LINE INDENT f , t = map ( int , input ( ) . split ( ) ) NEW_LINE if f > max : NEW_LINE INDENT max = f NEW_LINE DEDENT if f + t > s : NEW_LINE INDENT s = f + t NEW_LINE DEDENT DEDENT print ( max ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def primeBitsInRange ( l , r ) : NEW_LINE INDENT tot_bit , count = 0 , 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT tot_bit = bin ( i ) . count ( '1' ) NEW_LINE if ( isPrime ( tot_bit ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 6 NEW_LINE r = 10 NEW_LINE print ( primeBitsInRange ( l , r ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def pairs ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = ( countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) ) NEW_LINE if ( sum == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( pairs ( arr , n , k ) ) NEW_LINE DEDENT
from queue import Queue NEW_LINE def reverseQueueFirstKElements ( k ) : NEW_LINE INDENT if ( len ( queue ) == True or k > len ( queue ) ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT stack = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT stack . append ( queue [ 0 ] ) NEW_LINE stack . pop ( 0 ) NEW_LINE DEDENT while ( len ( stack ) > 0 ) : NEW_LINE INDENT stack . append ( stack [ 0 ] ) NEW_LINE stack . pop ( 0 ) NEW_LINE DEDENT for i in range ( len ( queue ) - k ) : NEW_LINE INDENT queue . append ( queue [ i ] ) NEW_LINE queue . pop ( 0 ) NEW_LINE DEDENT return [ ] NEW_LINE DEDENT def Print ( i ) : NEW_LINE INDENT while ( len ( queue ) > 0 ) : NEW_LINE INDENT print ( queue [ i ] , end = " " ) NEW_LINE queue . pop ( i ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT queue = Queue ( ) NEW_LINE queue . put ( 10 ) NEW_LINE queue . put ( 20 ) NEW_LINE queue . put ( 30 ) NEW_LINE queue . put ( 40 ) NEW_LINE queue . put ( 50 ) NEW_LINE queue . put ( 60 ) NEW_LINE queue . put ( 70 ) NEW_LINE queue . put ( 80 ) NEW_LINE queue . put ( 90 ) NEW_LINE queue . put ( 100 ) NEW_LINE k = 5 NEW_LINE reverseQueueFirstKElements ( k ) NEW_LINE Print ( queue ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( b ) % 2 == 0 : NEW_LINE INDENT print ( " maomao90" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " errorgorn " ) NEW_LINE DEDENT DEDENT
def xorCalc ( k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( ( k + 1 ) & k ) == 0 ) : NEW_LINE INDENT return k // 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = 31 NEW_LINE print ( xorCalc ( k ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def isPerfectSquare ( self , num ) : NEW_LINE INDENT low = 1 NEW_LINE high = num NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( mid * mid == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( mid * mid < num ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 16 NEW_LINE out = sObj . isPerfectSquare ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a + b + c == a + b or a + c == b + c or b + c == a + c ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE summ = sum ( a ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == summ : NEW_LINE INDENT ans . append ( i + 1 ) NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for i in ans : NEW_LINE INDENT print ( i + 1 , end = ' ' ) NEW_LINE DEDENT
from collections import deque NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE que = deque ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT name , num = map ( str , input ( ) . split ( ) ) NEW_LINE if num <= k : NEW_LINE INDENT que . appendleft ( [ name , num ] ) NEW_LINE DEDENT else : NEW_LINE INDENT k -= num NEW_LINE que . append ( [ name , num ] ) NEW_LINE DEDENT DEDENT total_length = 0 NEW_LINE for i in que : NEW_LINE INDENT total_length += i [ 1 ] NEW_LINE DEDENT while que : NEW_LINE INDENT cur = que . popleft ( ) NEW_LINE if cur [ 0 ] == cur [ 1 ] : NEW_LINE INDENT total_length += cur [ 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT total_length += cur [ 2 ] NEW_LINE DEDENT DEDENT print ( " % d % d " % ( total_length , total_length ) ) NEW_LINE
def findElement ( arr , ranges , rotations , index ) : NEW_LINE INDENT for i in range ( rotations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT if ( index == left ) : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index -= 1 NEW_LINE DEDENT DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE rotations = 2 NEW_LINE ranges = [ [ 0 , 2 ] , [ 0 , 3 ] ] NEW_LINE index = 1 NEW_LINE print ( findElement ( arr , ranges , rotations , index ) ) NEW_LINE DEDENT
MAXN = 1000001 NEW_LINE spf = [ 0 ] * MAXN NEW_LINE hash1 = [ 0 ] * MAXN NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN , 2 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT temp = 0 NEW_LINE while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( x ) : NEW_LINE INDENT temp = 0 NEW_LINE while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 8 , 4 , 10
def isExists ( a , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] = freq . get ( a [ i ] , 0 ) + 1 NEW_LINE sum += a [ i ] NEW_LINE DEDENT if ( sum % 2 == 0 ) : NEW_LINE INDENT if ( freq [ sum // 2 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 5 , 1 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if ( isExists ( a , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d1 = 4 NEW_LINE d2 = 6 NEW_LINE print ( " Area of Kite = " , areaOfKite ( d1 , d2 ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE fibo = [ ' O . ' , ' # . ' , ' . ' , ' - - ' , ' - - ' , ' ' ] NEW_LINE day = n // 3 NEW_LINE for i in range ( 1 , day + 1 ) : NEW_LINE INDENT if n % 3 == 0 : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + ' | ' NEW_LINE DEDENT elif n % 3 == 1 : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + ' | ' NEW_LINE DEDENT else : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + ' | ' NEW_LINE DEDENT DEDENT day = n - 1 NEW_LINE for i in range ( 1 , day + 1 ) : NEW_LINE INDENT print ( " " + " . " * ( n - i ) + " . " * ( fibo [ i - 1 ] - 1 ) + " | " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n % 2 == 0 and n != 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
def productEqual ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT prodOdd = 1 NEW_LINE prodEven = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE prodOdd *= digit NEW_LINE n //= 10 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT digit = n % 10 NEW_LINE prodEven *= digit NEW_LINE n //= 10 NEW_LINE DEDENT if ( prodEven == prodOdd ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4324 NEW_LINE if ( productEqual ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = input ( ) . split ( ) NEW_LINE b = input ( ) NEW_LINE ans = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] . isdigit ( ) : NEW_LINE INDENT ans += chr ( ord ( b [ i ] ) - 1 ) NEW_LINE DEDENT elif b [ i ] . isdigit ( ) : NEW_LINE INDENT ans += chr ( ord ( b [ i ] ) + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def checkEVENodd ( arr , n , l , r ) : NEW_LINE INDENT if arr [ r ] == 1 : NEW_LINE INDENT print ( " odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " even " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE checkEVENodd ( arr , n , 1 , 3 ) NEW_LINE DEDENT
import sys NEW_LINE w , h , x , y , r = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( r + 1 ) : NEW_LINE INDENT for j in range ( h + 1 ) : NEW_LINE INDENT if i * 2 + j * 2 >= w : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( ' No ' ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( isPrime ( num ) ) : NEW_LINE INDENT return num NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( isPrime ( sum ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minNumber ( arr , n ) ) NEW_LINE DEDENT
def compositeProduct ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = True NEW_LINE prime [ 1 ] = True NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not prime [ arr [ i ] ] ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( compositeProduct ( arr , n ) ) NEW_LINE DEDENT
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x == 0 and y == 0 : NEW_LINE INDENT exit ( ) NEW_LINE DEDENT if x > y : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT print ( x , y ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ - 1 ] == " po " or s [ - 1 ] == " n " or s [ - 1 ] == " e " or s [ - 1 ] == " o " : NEW_LINE INDENT print ( " Korean " ) NEW_LINE DEDENT elif s [ - 1 ] == " a " or s [ - 1 ] == " e " or s [ - 1 ] == " o " : NEW_LINE INDENT print ( " JAPANESE " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Korean " ) NEW_LINE DEDENT DEDENT
def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left ; NEW_LINE d = arr [ 1 ] - arr [ 0 ] ; NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) ; NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) // 2 ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 ] ; NEW_LINE queries = 3 ; NEW_LINE q = [ [ 2 , 4 ] , [ 2 , 6 ] , [ 5 , 6 ] ] ; NEW_LINE n = len ( arr ) ; NEW_LINE for i in range ( queries ) : NEW_LINE INDENT print ( findSum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) ) ; NEW_LINE DEDENT DEDENT
def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n - i + 1 ) : NEW_LINE INDENT z = ( n - ( i + j ) ) // c NEW_LINE if ( z == ( floor ( z ) ) ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y + z ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE a = 5 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE print ( maxResult ( n , a , b , c ) ) NEW_LINE DEDENT
a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE e = int ( input ( ) ) NEW_LINE f = int ( input ( ) ) NEW_LINE g = int ( input ( ) ) NEW_LINE h = int ( input ( ) ) NEW_LINE i = int ( input ( ) ) NEW_LINE j = int ( input ( ) ) NEW_LINE print ( a + b + c + d + e + f + g + h + i + j ) NEW_LINE
def fact ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT def numberOfPossiblePallindrome ( string , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ string [ i ] ] = mp . get ( string [ i ] ) + 1 NEW_LINE DEDENT k = 0 NEW_LINE num = 0 NEW_LINE den = 1 NEW_LINE fi = 1 NEW_LINE for it in mp : NEW_LINE INDENT if ( mp [ it ] % 2 == 0 ) : NEW_LINE INDENT fi = ( mp [ it ] // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT fi = ( mp [ it ] - 1 ) // 2 NEW_LINE k += 1 NEW_LINE DEDENT num = num + fi NEW_LINE den = den * fact ( fi ) NEW_LINE DEDENT if ( num != 0 ) : NEW_LINE INDENT num = fact ( num ) NEW_LINE DEDENT ans = num // den NEW_LINE if ( k != 0 ) : NEW_LINE INDENT ans = ans * k NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " ababab " NEW_LINE n = len ( string ) NEW_LINE print ( numberOfPossiblePallindrome ( string , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE def check ( x ) : NEW_LINE INDENT if a [ x // 2 ] >= a [ x // 2 - 1 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( x ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT return check ( i + 1 ) NEW_LINE DEDENT DEDENT return check ( a [ 1 : ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 107 NEW_LINE m = 4 NEW_LINE n = toggleLastMBits ( n , m ) NEW_LINE print ( n ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE a_c = 0 NEW_LINE b_c = 0 NEW_LINE c_c = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT a_c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b_c += 1 NEW_LINE DEDENT DEDENT if a_c > b_c : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if b_c > c_c : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if a_c == b_c : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT
def first_subString ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = 0 NEW_LINE s1 , s2 = " " , " " NEW_LINE mpp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ' or s [ i ] == ' # ' ) : NEW_LINE INDENT s1 = s [ c : i ] NEW_LINE mpp [ s1 ] = 1 NEW_LINE c = i + 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ' ) : NEW_LINE INDENT break NEW_LINE DEDENT s1 = s [ i : j - i + 1 ] NEW_LINE s2 = s1 NEW_LINE s1 = s [ : : - 1 ] NEW_LINE mpp [ s1 ] = 1 NEW_LINE return s2 NEW_LINE DEDENT DEDENT return " - 1" NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = " mango is sweet empty en tastes it # " NEW_LINE s1 = first_subString ( s ) NEW_LINE print ( s1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countConsecutive ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 44522255 NEW_LINE print ( countConsecutive ( n ) ) NEW_LINE DEDENT
def findAngle ( n ) : NEW_LINE INDENT interiorAngle = ( n - 2 ) * 180 // n NEW_LINE exteriorAngle = 360 // n NEW_LINE print ( " Interior angle : " , interiorAngle ) NEW_LINE print ( " Exterior angle : " , exteriorAngle ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE findAngle ( n ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def nDigitPerfectSquares ( n ) : NEW_LINE INDENT smallest = pow ( ceil ( sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) NEW_LINE print ( smallest , end = " " ) NEW_LINE largest = pow ( ceil ( sqrt ( pow ( 10 , n ) ) ) - 1 , 2 ) NEW_LINE print ( largest ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE nDigitPerfectSquares ( n ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) . split ( ) NEW_LINE ans = " No " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == " ( " : NEW_LINE INDENT ans += " ) " NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = n - 1 NEW_LINE r = min ( ans ) NEW_LINE if r == l : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE l = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 2 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE l = i + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE if l != - 1 : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT
import math NEW_LINE discard_count = 0 NEW_LINE def power ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) NEW_LINE p = p * p NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT p = p * a NEW_LINE DEDENT return p NEW_LINE DEDENT def solve ( i , n , sum , k , a , prefix ) : NEW_LINE INDENT if ( sum > k ) : NEW_LINE INDENT discard_count += power ( 2 , n - i ) NEW_LINE return NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return NEW_LINE DEDENT rem = prefix [ n - 1 ] - prefix [ i ] NEW_LINE if ( sum + a [ i ] + rem > k ) : NEW_LINE INDENT solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) NEW_LINE DEDENT if ( sum + rem > k ) : NEW_LINE INDENT solve ( i + 1 , n , sum , k , a , prefix ) NEW_LINE DEDENT DEDENT def countSubsequences ( arr , n , K ) : NEW_LINE INDENT sum = 0.0 NEW_LINE k = math . log ( K ) NEW_LINE prefix = [ 0 ] * n NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = math . log ( arr [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT prefix [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + a [ i ] NEW_LINE DEDENT total = power ( 2 , n ) - 1 NEW_LINE if ( sum <= k ) : NEW_LINE INDENT return total NEW_LINE DEDENT solve ( 0 , n , 0.0 , k , a , prefix ) NEW_LINE return ( total - discard_count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 7 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( countSubsequences (
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT node = Node ( data ) NEW_LINE node . data = data NEW_LINE node . left = None NEW_LINE node . right = None NEW_LINE return node NEW_LINE DEDENT def inorder ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( root . left ) NEW_LINE print ( root . data , end = " " ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT def isIdentical ( root1 , root2 ) : NEW_LINE INDENT if root1 == None and root2 == None : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif root1 != None and root2 == None : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif root1 == None and root2 != None : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if root1 . data == root2 . data and isIdentical ( root1 . left , root2 . left ) == 1 and isIdentical ( root1 . right , root2 . right ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT root1 = newNode ( 5 ) NEW_LINE root2 = newNode ( 5 ) NEW_LINE root1 . left = newNode ( 3 ) NEW_LINE root1 . right = newNode ( 8 ) NEW_LINE root1 . left . left = newNode ( 2 ) NEW_LINE root1 . left . right = newNode ( 4 ) NEW_LINE root2 . left = newNode ( 3 ) NEW_LINE root2 . left = newNode ( 2 ) NEW_LINE root2 . right = newNode ( 8 ) NEW_LINE root2 . left . left = newNode ( 2 ) NEW_LINE root2 . left . right = newNode ( 4 ) NEW_LINE if isIdentical ( root1 , root2 ) == 1 : NEW_LINE INDENT print ( " both BSTs are differ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print (
def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE end = len ( s ) NEW_LINE ind = 0 NEW_LINE ans = 0 NEW_LINE while ind < end : NEW_LINE INDENT j_num = 0 NEW_LINE o_num = 0 NEW_LINE i_num = 0 NEW_LINE while ind < end and s [ ind ] == " J " : NEW_LINE INDENT ind += 1 NEW_LINE DEDENT while ind < end and s [ ind ] == " J " : NEW_LINE INDENT j_num += 1 NEW_LINE ind += 1 NEW_LINE DEDENT while ind < end and s [ ind ] == " O " : NEW_LINE INDENT o_num += 1 NEW_LINE ind += 1 NEW_LINE DEDENT while ind < end and s [ ind ] == " I " : NEW_LINE INDENT i_num += 1 NEW_LINE ind += 1 NEW_LINE DEDENT if o_num <= i_num and o_num > ans : NEW_LINE INDENT ans = o_num NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT main ( ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = [ 1 , 2 , 3 ] NEW_LINE ans = [ 0 , 0 , 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' W ' : NEW_LINE INDENT ans [ i ] = 5 - sum ( d [ : i ] ) NEW_LINE d [ i ] = 5 - sum ( d [ i : ] ) NEW_LINE DEDENT elif s [ i ] == ' E ' : NEW_LINE INDENT ans [ i ] = 5 - sum ( d [ : i ] ) NEW_LINE d [ i ] = 5 - sum ( d [ i : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = sum ( d [ i : ] ) NEW_LINE d [ i ] = 1 - sum ( d [ i : ] ) NEW_LINE DEDENT DEDENT print ( ans [ n ] ) NEW_LINE
class node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def add ( data ) : NEW_LINE INDENT newnode = node ( data ) NEW_LINE newnode . data = data NEW_LINE newnode . next = None NEW_LINE return newnode NEW_LINE DEDENT def printArr ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT def findlength ( head ) : NEW_LINE INDENT curr = head NEW_LINE cnt = 0 NEW_LINE while ( curr != None ) : NEW_LINE INDENT cnt += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT return cnt NEW_LINE DEDENT def convertArr ( head ) : NEW_LINE INDENT len1 = findlength ( head ) NEW_LINE arr = [ 0 ] * len1 NEW_LINE index = 0 NEW_LINE curr = head NEW_LINE while ( curr != None ) : NEW_LINE INDENT arr [ index ] = curr . data NEW_LINE curr = curr . next NEW_LINE index += 1 NEW_LINE DEDENT printArr ( arr , len1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT head = node ( 1 ) NEW_LINE head . next = add ( 2 ) NEW_LINE head . next . next = add ( 3 ) NEW_LINE head . next . next . next = add ( 4 ) NEW_LINE head . next . next . next . next = add ( 5 ) NEW_LINE convertArr ( head ) NEW_LINE DEDENT
def nonDecNums ( n ) : NEW_LINE INDENT a = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = ( a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return a [ n ] [ 0 ] NEW_LINE DEDENT n = 2 NEW_LINE print ( " Non - decreasing digits = " , nonDecNums ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = ( i + arr [ i ] ) % n NEW_LINE if x < 0 : NEW_LINE INDENT x += n NEW_LINE DEDENT if x > 0 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 or flag == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT t -= 1 NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def minMoves ( self , nums ) : NEW_LINE INDENT if nums == [ ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT nums . sort ( ) NEW_LINE min_num = nums [ 0 ] NEW_LINE ans = 0 NEW_LINE for num in nums : NEW_LINE INDENT ans += num - min_num NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 ] NEW_LINE out = sObj . minMoves ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
import math NEW_LINE from functools import reduce NEW_LINE from collections import deque NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def get_nums_l ( ) : NEW_LINE INDENT return [ int ( s ) for s in input ( ) . split ( " " ) ] NEW_LINE DEDENT def get_nums_n ( n ) : NEW_LINE INDENT return [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a , b = get_nums_l ( ) NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( ' Zero ' ) NEW_LINE DEDENT elif ( a - b ) % 2 == 0 : NEW_LINE INDENT print ( ' Negative ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Negative ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def firstSetBit ( n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE print ( firstSetBit ( n ) ) NEW_LINE DEDENT
MAX_CHAR = 256 NEW_LINE def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE firstInd = [ - 1 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT first_ind = firstInd [ ord ( str [ i ] ) ] NEW_LINE if ( first_ind == - 1 ) : NEW_LINE INDENT firstInd [ ord ( str [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abba " NEW_LINE print ( maximumChars ( str ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c , d = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( [ c , d ] ) NEW_LINE DEDENT a . sort ( key = lambda x : x [ 1 ] ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < n and j < n : NEW_LINE INDENT if a [ i ] [ 1 ] - a [ j ] [ 1 ] >= k : NEW_LINE INDENT ans += a [ i ] [ 0 ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += a [ i ] [ 0 ] - a [ j ] [ 1 ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT ans = max ( ans , i ) NEW_LINE DEDENT print ( ans ) NEW_LINE
from math import sqrt NEW_LINE def findArea ( a ) : NEW_LINE INDENT area = ( 5 * sqrt ( 3 ) * a * a ) NEW_LINE return area NEW_LINE DEDENT def findVolume ( a ) : NEW_LINE INDENT volume = ( 5 / 12 ) * ( 3 + sqrt ( 5 ) * a * a * a ) NEW_LINE return volume NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 5 NEW_LINE print ( " Area : " , int ( findArea ( a ) ) ) NEW_LINE print ( " Volume : " , int ( findVolume ( a ) ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT PYramIDAL_didiE_ zip zip zip zip ( * [ map ( int , open ( 0 ) . read ( ) . split ( ) ) ] for _ in range ( 9 ) ] ) : NEW_LINE INDENT ninePyramidal_ k = convolve ( ninePyramidal_ k , PYramIDAL_diE_ zip ( PYramIDAL_diE_ zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) ) for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) ) for x in zip ( * [ sum ( x ) ) ] for x in zip ( * [ sum ( x ) ) ] for _ in range ( 9 ) ] ) ] ) ) ] ) ) NEW_LINE denom = sum ( ninePyramidal_ k , PYramIDAL_diE_ zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) ) ] for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) ) ] for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) ) ] for x in zip ( * [ sum ( x ) ) ] for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) ) ] for x in zip ( * [ sum ( x ) ) ] for x in zip ( * [ sum ( x ) for x in zip ( * [ sum ( x ) ) ] for x in zip ( * [ sum ( x ) ] ) ] ) ] ) ) ] ) ) ) ) ) NEW_LINE return f " { denom / denom } " NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT N = 6 NEW_LINE Even = N // 2 NEW_LINE Odd = N - Even NEW_LINE print ( Even * Odd ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def solve ( M , N , s ) : NEW_LINE INDENT if ( N % s == 0 ) : NEW_LINE INDENT N = N // s NEW_LINE DEDENT else : NEW_LINE INDENT N = ( N // s ) + 1 NEW_LINE DEDENT if ( M % s == 0 ) : NEW_LINE INDENT M = M // s NEW_LINE DEDENT else : NEW_LINE INDENT M = ( M // s ) + 1 NEW_LINE DEDENT return M * N NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , M , s = 12 , 13 , 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) ; NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPairs ( arr , n ) ) ; NEW_LINE DEDENT
a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE e = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( b ) ) : NEW_LINE INDENT for k in range ( len ( c ) ) : NEW_LINE INDENT if a [ i ] + b [ j ] + c [ k ] == d [ i ] : NEW_LINE INDENT e . append ( " YES " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if e == b : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def _popcnt32 ( number ) : NEW_LINE INDENT counter = 0 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT if ( number % 2 == 1 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT number = number // 2 NEW_LINE DEDENT return counter NEW_LINE DEDENT def maximize ( a ) : NEW_LINE INDENT n = _popcnt32 ( a ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = res | ( 1 << ( 32 - i ) ) NEW_LINE DEDENT return abs ( res ) NEW_LINE DEDENT a = 1 NEW_LINE print ( maximize ( a ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in l : NEW_LINE INDENT if i > k : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE while a > 0 and b > 0 : NEW_LINE INDENT if a >= b : NEW_LINE INDENT a -= 1 NEW_LINE b -= 1 NEW_LINE c += 1 NEW_LINE DEDENT elif a < b : NEW_LINE INDENT a += 1 NEW_LINE b -= 2 NEW_LINE c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT a += 1 NEW_LINE b += 1 NEW_LINE c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def xorQueries ( self , arr , queries ) : NEW_LINE INDENT res = [ 0 ] * len ( queries ) NEW_LINE for i in range ( 1 , len ( queries ) ) : NEW_LINE INDENT arr [ i ] ^= arr [ i - 1 ] NEW_LINE DEDENT for q in queries : NEW_LINE INDENT if q [ 0 ] > 0 : NEW_LINE INDENT res [ i ] = arr [ q [ 0 ] - 1 ] ^ arr [ q [ 1 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = arr [ q [ 1 ] ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE arr = [ 1 , 3 , 4 , 8 ] NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 2 ] , [ 0 , 3 ] , [ 3 , 3 ] ] NEW_LINE out = sObj . xorQueries ( arr , queries ) NEW_LINE print ( out ) NEW_LINE DEDENT
def encodedChar ( strr , k ) : NEW_LINE INDENT expanded = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE i = 0 NEW_LINE while i < len ( strr ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while i < len ( strr ) and ord ( strr [ i ] ) >= ord ( ' a ' ) and ord ( strr [ i ] ) <= ord ( ' z ' ) : NEW_LINE INDENT temp += strr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while i < len ( strr ) and ord ( strr [ i ] ) >= ord ( ' a ' ) and ord ( strr [ i ] ) <= ord ( ' z ' ) : NEW_LINE INDENT freq = freq * 10 + ord ( strr [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 ) : NEW_LINE INDENT expanded += temp NEW_LINE DEDENT if ( freq == 0 ) : NEW_LINE INDENT expanded += temp NEW_LINE DEDENT return expanded [ k - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT strr = " ab4c12ed3" NEW_LINE k = 21 NEW_LINE print ( encodedChar ( strr , k ) ) NEW_LINE DEDENT
def printPossible ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 2 != 0 or a + b < c ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c = 2 , 4 , 2 NEW_LINE printPossible ( a , b , c ) NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) / 2 NEW_LINE sign = 1 if n + 1 % 2 == 0 else - 1 NEW_LINE result_sum = sign * abs_sum NEW_LINE return result_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2 NEW_LINE print ( summation ( N ) ) NEW_LINE DEDENT
def sortSquares ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 6 , - 3 , - 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Before sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT sortSquares ( arr ) NEW_LINE print ( " " ) NEW_LINE print ( " After sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
n , t = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE pos = 0 NEW_LINE while pos < n - 1 : NEW_LINE INDENT pos += a [ pos ] NEW_LINE if pos == n - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " YES " if pos == t else " NO " ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 2147483647 ) NEW_LINE INF = float ( " inf " ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE L = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT L [ ( i + A [ i ] ) % N ] += 1 NEW_LINE DEDENT A = A [ : : - 1 ] NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b = 1 NEW_LINE a = 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE if ( root1 > 0 and math . floor ( root1 ) == root1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT num = 55 NEW_LINE if ( isTriangular ( num ) ) : NEW_LINE INDENT print ( " The number is a triangular number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The number is NOT a triangular number " ) NEW_LINE DEDENT
def printNumberWith DR ( k , d ) : NEW_LINE INDENT if ( d == 0 and k != 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d ) NEW_LINE k -= 1 NEW_LINE while ( k ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT k = 4 NEW_LINE d = 4 NEW_LINE printNumberWith DR ( k , d ) NEW_LINE
N = 3 NEW_LINE def rotateMatrix ( mat ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " " ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE rotateMatrix ( mat ) NEW_LINE
import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE def solve ( n ) : NEW_LINE INDENT ans = n // 500 * 500 NEW_LINE n %= 500 NEW_LINE return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( solve ( n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def getProduct ( n ) : NEW_LINE INDENT product = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 4513 NEW_LINE print ( getProduct ( n ) ) NEW_LINE
def solve ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT b , r , g , c , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE if not b : NEW_LINE INDENT return NEW_LINE DEDENT if t == 0 : NEW_LINE INDENT return solve ( b , r , g , c , s , t ) + 100 NEW_LINE DEDENT else : NEW_LINE INDENT if r > 0 and g > 0 and t > 0 : NEW_LINE INDENT return solve ( b , r - 1 , g - 1 , c - 1 , s - t ) NEW_LINE DEDENT if t == 0 : NEW_LINE INDENT return ( ( r * 3 ) + ( g * 2 ) + ( c * 2 ) + ( s * 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( r * 5 ) + ( g * 2 ) + ( t * 1 ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE from sys import stdin , stdout NEW_LINE import math NEW_LINE import bisect NEW_LINE def get_ints ( ) : return map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE def get_arr ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE def get_string ( ) : return stdin . readline ( ) . strip ( ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE n = int ( input ( ) ) NEW_LINE arr = get_arr ( ) NEW_LINE arr = get_arr ( ) NEW_LINE ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans *= arr [ i ] NEW_LINE ans %= MOD NEW_LINE DEDENT print ( ans ) NEW_LINE
PI = 3.14159265 NEW_LINE def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 7 NEW_LINE print ( length_rope ( r ) ) NEW_LINE DEDENT
def reverseDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT rev_n = reverseDigits ( n ) NEW_LINE if ( rev_n == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4562 NEW_LINE print ( " Is " , n , " a Palindrome number ? - > " , ( isPalindrome ( n ) == 1 ) ) NEW_LINE n = 1001 NEW_LINE print ( " Is " , n , " a Palindrome number ? - > " , ( isPalindrome ( n ) == 1 ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def addStrings ( self , num1 , num2 ) : NEW_LINE INDENT sb = " " NEW_LINE carry = 0 NEW_LINE for i in range ( len ( num1 ) - 1 , len ( num2 ) - 1 ) : NEW_LINE INDENT if ( i >= 0 or j >= 0 or carry == 1 ) : NEW_LINE INDENT x = 0 if i < 0 else int ( num1 [ i ] ) NEW_LINE y = 0 if j < 0 else int ( num2 [ j ] ) NEW_LINE sb += ( ( x + y + carry ) % 10 ) NEW_LINE carry = ( x + y + carry ) // 10 NEW_LINE DEDENT DEDENT return sb [ : : - 1 ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE num1 = "11" NEW_LINE num2 = "123" NEW_LINE out = sObj . addStrings ( num1 , num2 ) NEW_LINE print ( out ) NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i * i != n ) : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT DEDENT if ( sum == n and n != 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( " below are all perfect numbers hoge " ) NEW_LINE for n in range ( 2 , 10000 ) : NEW_LINE INDENT if ( isPerfect ( n ) ) : NEW_LINE INDENT print ( n , " is a perfect number " ) NEW_LINE DEDENT DEDENT DEDENT
from math import sqrt NEW_LINE def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT p = x NEW_LINE while ( p <= n ) : NEW_LINE INDENT p = p * x NEW_LINE if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT y = 2 NEW_LINE p = pow ( x , y ) NEW_LINE while ( p <= n and p > 0 ) : NEW_LINE INDENT if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT y += 1 NEW_LINE p = pow ( x , y ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
from math import gcd NEW_LINE def findTwoNumbers ( sum , gcd ) : NEW_LINE INDENT if ( gcd ( sum - gcd ) == gcd and sum != gcd ) : NEW_LINE INDENT print ( " a = " , min ( gcd , sum - gcd ) , " , b = " , ( sum - min ( gcd , sum - gcd ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT sum = 8 NEW_LINE gcd = 2 NEW_LINE findTwoNumbers ( sum , gcd ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE t1 = 1 NEW_LINE t2 = 1 NEW_LINE while not ( t1 == t2 ) : NEW_LINE INDENT if ( t1 < c ) : NEW_LINE INDENT t1 = c NEW_LINE DEDENT if ( t2 < d ) : NEW_LINE INDENT t2 = d NEW_LINE DEDENT t1 += 1 NEW_LINE DEDENT print ( t1 ) NEW_LINE DEDENT
n , a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( n * b , ( n - a + 1 ) * d , a + 1 ) ) NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def totalPairs ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = countSetBits ( arr [ i ] ) NEW_LINE if count in m . keys ( ) : NEW_LINE INDENT m [ count ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ count ] = 1 NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for it in m : NEW_LINE INDENT value = m [ it ] NEW_LINE result += ( ( value * ( value - 1 ) ) // 2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 7 , 5 , 3 , 9 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( totalPairs ( arr , n ) ) NEW_LINE
def center_ hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , " th centered hexadecagonal " + " number : " , center_ hexadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( n , " th centered hexadecagonal " + " number : " , center_ hexadecagonal_num ( n ) ) NEW_LINE DEDENT
Q , H , S , D , N = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( D * 2 , H * 2 , S * 4 ) ) NEW_LINE
def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers // 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE DEDENT
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( c , b ) * ( a + f ) + max ( 0 , d - min ( c , b ) ) * e ) NEW_LINE
def Solution ( A ) : NEW_LINE INDENT ans = 2 NEW_LINE n = len ( A ) NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT llap = [ 2 ] * n NEW_LINE llap . sort ( ) NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while i >= 0 and k < n : NEW_LINE INDENT if A [ i ] + A [ k ] == 2 * A [ j ] : NEW_LINE INDENT llap [ j ] = max ( llap [ k ] + 1 , llap [ j ] ) NEW_LINE ans = max ( ans , llap [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT elif A [ i ] + A [ k ] < 2 * A [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 9 , 4 , 7 , 2 , 10 ] NEW_LINE print ( Solution ( a ) ) NEW_LINE DEDENT
def minimumChanges ( arr , n , d ) : NEW_LINE INDENT maxFreq = - 1 NEW_LINE freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = arr [ i ] - ( i ) * d NEW_LINE if a0 in freq : NEW_LINE INDENT freq [ a0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a0 ] = 1 NEW_LINE DEDENT if ( freq [ a0 ] > maxFreq ) : NEW_LINE INDENT maxFreq = freq [ a0 ] NEW_LINE DEDENT DEDENT return ( n - maxFreq ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , d = 5 , 1 NEW_LINE arr = [ 1 , 3 , 3 , 4 , 6 ] NEW_LINE print ( minimumChanges ( arr , n , d ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ans = 500 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , z , w = map ( int , input ( ) . split ( ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if x > y and x < z and y < w : NEW_LINE INDENT ans = j NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def countPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < m ) : NEW_LINE INDENT if ( a [ i ] + y < b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 1 NEW_LINE y = 4 NEW_LINE a = [ 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 1 , 1 , 2 ] NEW_LINE m = len ( b ) NEW_LINE print ( countPoints ( n , m , a , b , x , y ) ) NEW_LINE DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 4 NEW_LINE print ( multiplyWith3Point5 ( x ) ) NEW_LINE
n , s = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l , r = 0 , 10000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l += a [ i ] NEW_LINE r = min ( r , a [ i ] ) NEW_LINE DEDENT if l > s : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT while r - l > 1 : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if s - m <= m : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE
def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 NEW_LINE maxi = 1 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) NEW_LINE return maxi NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ccccd nff " NEW_LINE print ( longestSubstring ( s ) ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( k ) : NEW_LINE INDENT from sys import stdin NEW_LINE f_i = stdin NEW_LINE ans = [ 0 ] * 50 NEW_LINE n = int ( f_i . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = i + n // 50 NEW_LINE ans [ a ] += 1 NEW_LINE DEDENT print ( len ( ans ) ) NEW_LINE print ( * ans ) NEW_LINE DEDENT k = int ( f_i . readline ( ) ) NEW_LINE solve ( k ) NEW_LINE
def zeroUpto ( digits ) : NEW_LINE INDENT first = ( pow ( 10 , digits ) - 1 ) // 9 NEW_LINE second = ( pow ( 9 , digits ) - 1 ) // 8 NEW_LINE return 9 * ( first - second ) NEW_LINE DEDENT def toInt ( c ) : NEW_LINE INDENT return ( ord ( c ) - 48 ) NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT k = len ( num ) NEW_LINE total = zeroUpto ( k - 1 ) NEW_LINE non_zero = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT if ( num [ i ] == '0' ) : NEW_LINE INDENT non_zero -= 1 NEW_LINE break NEW_LINE DEDENT non_zero += ( int ( toInt ( num [ i ] ) - 1 ) * ( pow ( 9 , k - 1 - i ) ) ) NEW_LINE DEDENT no = 0 NEW_LINE remaining = 0 NEW_LINE calculatedUpto = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT no = no * 10 + ( toInt ( num [ i ] ) ) NEW_LINE if ( i != 0 ) : NEW_LINE INDENT calculatedUpto = calculatedUpto * 10 + 9 NEW_LINE DEDENT DEDENT remaining = no - calculatedUpto NEW_LINE ans = zeroUpto ( k - 1 ) + ( remaining - non_zero - 1 ) NEW_LINE return ans NEW_LINE DEDENT num = "107" NEW_LINE print ( " Count of numbers from 1" , " to " , num , " is " , countZero ( num ) ) NEW_LINE num = "1264" NEW_LINE print ( " Count of numbers from 1" , " to " , num , " is " , countZero ( num ) ) NEW_LINE
from math import sqrt NEW_LINE def cone ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a * sqrt ( 2 ) NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = 3.14 * pow ( r , 2 ) * h NEW_LINE return V NEW_LINE DEDENT a = 5 NEW_LINE print ( round ( cone ( a ) , 4 ) ) NEW_LINE
def Prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkSumPrime ( string ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , len ( string ) ) : NEW_LINE INDENT summ += ( abs ( ord ( string [ i - 1 ] ) - ord ( string [ i ] ) ) ) NEW_LINE DEDENT if ( Prime ( summ ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 142 NEW_LINE string = "142" NEW_LINE if ( checkSumPrime ( string ) ) : NEW_LINE INDENT print ( " Prime " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not Prime " ) NEW_LINE DEDENT DEDENT
def sum ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( sum ( 8 ) ) NEW_LINE print ( sum ( 10 ) ) NEW_LINE DEDENT
def countElements ( p , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = [ 2 , 5 , 1 , 3 , 4 ] NEW_LINE n = len ( p ) NEW_LINE print ( countElements ( p , n ) ) NEW_LINE DEDENT
a , b = input ( ) . split ( ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE if a > b : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif a < b : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT
def findVolume ( l , b , h ) : NEW_LINE INDENT volume = ( l * b * h ) / 2 NEW_LINE return volume NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 18 NEW_LINE b = 12 NEW_LINE h = 9 NEW_LINE print ( " Volume of triangular prism : " , findVolume ( l , b , h ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ 0 ] * 26 NEW_LINE for i in s : NEW_LINE INDENT a [ ord ( i ) - ord ( " A " ) ] += 1 NEW_LINE DEDENT s = sorted ( a ) NEW_LINE s = " " . join ( a ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while r < k : NEW_LINE INDENT if r >= n : NEW_LINE INDENT break NEW_LINE DEDENT while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if a [ m ] < s [ m - 1 ] : NEW_LINE INDENT a [ m ] = s [ m - 1 ] NEW_LINE l += m NEW_LINE r += m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT l += 1 NEW_LINE r += 1 NEW_LINE DEDENT print ( r ) NEW_LINE
def compute ( ) : NEW_LINE INDENT i = 286 NEW_LINE j = 166 NEW_LINE k = 144 NEW_LINE while True : NEW_LINE INDENT triangle = i * ( i + 1 ) // 2 NEW_LINE pentagon = j * ( j * 3 - 1 ) // 2 NEW_LINE hexagon = k * ( k * 2 - 1 ) // 2 NEW_LINE if triangle == triangle and pentagon == hexagon and triangle == pentagon : NEW_LINE INDENT return str ( min ( triangle , pentagon ) ) NEW_LINE DEDENT if triangle == pentagon : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if triangle == pentagon : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if triangle == hexagon : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def maxPrimefactorNum ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr = [ False ] * ( N + 1 ) NEW_LINE prod = 1 NEW_LINE res = 0 NEW_LINE p = 2 NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( arr [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , N + 1 , p ) : NEW_LINE INDENT arr [ i ] = True NEW_LINE DEDENT prod *= p NEW_LINE if ( prod > N ) : NEW_LINE INDENT return res NEW_LINE DEDENT res += 1 NEW_LINE DEDENT p += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 500 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE DEDENT
def checkDivisors ( a , n ) : NEW_LINE INDENT X = max ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , int ( X ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE if ( X // i != i ) : NEW_LINE INDENT b . append ( X // i ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( b ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT b . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 8 , 1 , 2 , 12 , 48 , 6 , 4 , 24 , 16 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE if ( checkDivisors ( arr , N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def subArray ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " All Non - empty Subarrays " ) NEW_LINE subArray ( n ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 6 == 0 : NEW_LINE INDENT x = min ( n // 6 , ( n - 1 ) // 6 ) NEW_LINE y = max ( n // 6 , ( n - 2 ) // 6 ) NEW_LINE DEDENT elif n % 6 == 2 : NEW_LINE INDENT x = min ( n // 6 , 2 ) NEW_LINE y = max ( n // 6 , ( n - 2 ) // 6 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = min ( n // 6 , 2 ) NEW_LINE y = max ( n // 6 , ( n - 2 ) // 6 ) NEW_LINE DEDENT if n % 6 == 3 : NEW_LINE INDENT x = min ( n // 6 , 3 ) NEW_LINE y = max ( n // 6 , ( n - 3 ) // 6 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = min ( n // 6 , 3 ) NEW_LINE y = max ( n // 6 , ( n - 2 ) // 6 ) NEW_LINE DEDENT if n % 6 == 4 : NEW_LINE INDENT x = min ( n // 4 , 4 ) NEW_LINE y = max ( n // 4 , ( n - 4 ) // 4 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = min ( n // 6 , 4 ) NEW_LINE y = max ( n // 6 , ( n - 4 ) // 6 ) NEW_LINE DEDENT if x == y : NEW_LINE INDENT print ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( arr [ i ] * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
def findAnswer ( n , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT sum += ( ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 53 , 28 , 143 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAnswer ( n , arr ) ) NEW_LINE DEDENT
def findSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT sum = sum + arr [ i + 1 ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n ) ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getDeepestLeftLeafNode ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE result = None NEW_LINE while ( not len ( q ) ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE if ( temp . left . left == None and temp . left . right == None ) : NEW_LINE INDENT result = temp NEW_LINE DEDENT DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . right . left = Node ( 5 ) NEW_LINE root . right . left = Node ( 6 ) NEW_LINE root . right . left . right = Node ( 7 ) NEW_LINE root . right . right . right = Node ( 8 ) NEW_LINE root . right . left . right . left = Node ( 9 ) NEW_LINE root . right . left . right . left = Node ( 10 ) NEW_LINE result = getDeepestLeftLeafNode ( root ) NEW_LINE if ( result != None ) : NEW_LINE INDENT print ( " deepest Left leaf Node : " , result . data ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No result , " , " left leaf not found " ) NEW_LINE DEDENT DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def getDeepestRightLeafNode ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE result = None NEW_LINE while ( not len ( q ) ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT if ( temp . right . left == None and temp . right . right == None ) : NEW_LINE INDENT result = temp . right NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . right = Node ( 4 ) NEW_LINE root . left . left = Node ( 5 ) NEW_LINE root . right . right = Node ( 6 ) NEW_LINE root . right . left . right = Node ( 7 ) NEW_LINE root . right . right . right = Node ( 8 ) NEW_LINE root . right . left . right . left = Node ( 9 ) NEW_LINE root . right . right . right . right = Node ( 10 ) NEW_LINE result = getDeepestRightLeafNode ( root ) NEW_LINE if ( result != None ) : NEW_LINE INDENT print ( " deepest Right leaf Node : " , result . data ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No result , right leaf not found " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n * 2 ) // 2 + 1 ) NEW_LINE DEDENT
def printRatio ( a , b , c , d ) : NEW_LINE INDENT if ( b * c > a * d ) : NEW_LINE INDENT temp = c NEW_LINE c = d NEW_LINE d = c NEW_LINE temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT lcm = ( a * c ) // __gcd ( a , c ) NEW_LINE x = lcm // a NEW_LINE b *= x NEW_LINE y = lcm // c NEW_LINE d *= y NEW_LINE k = __gcd ( b , d ) NEW_LINE b //= k NEW_LINE d //= k NEW_LINE print ( b , " : " , d ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 4 NEW_LINE b = 3 NEW_LINE c = 2 NEW_LINE d = 2 NEW_LINE printRatio ( a , b , c , d ) NEW_LINE DEDENT
def maxsum_ lp ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum sum : " , maxsum_ lp ( arr , n ) ) NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def findMaxSumUtil ( arr , n ) : NEW_LINE INDENT finalGCD = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT finalGCD = GCD ( arr [ i ] , finalGCD ) NEW_LINE DEDENT return finalGCD NEW_LINE DEDENT def findMaxSum ( arr , n ) : NEW_LINE INDENT maxElement = findMaxSumUtil ( arr , n ) NEW_LINE return ( maxElement * n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 8 , 20 , 12 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT while ( b != 0 ) : NEW_LINE INDENT t = b NEW_LINE b = a % b NEW_LINE a = t NEW_LINE DEDENT return a NEW_LINE DEDENT def findMinDiff ( a , b , x , y ) : NEW_LINE INDENT g = gcd ( a , b ) NEW_LINE diff = abs ( x - y ) % g NEW_LINE return min ( diff , g - diff ) NEW_LINE DEDENT a = 20 NEW_LINE b = 52 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( findMinDiff ( a , b , x , y ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT x , y , w , h = map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT px , py = map ( int , input ( ) . split ( ) ) NEW_LINE if ( px <= x and px + w <= y and py <= y + h ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def divisibleby37 ( n1 ) : NEW_LINE INDENT l = len ( n1 ) NEW_LINE if ( n1 == "0" ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l % 3 == 1 ) : NEW_LINE INDENT n1 = "00" + n1 NEW_LINE l += 2 NEW_LINE DEDENT elif ( l % 3 == 2 ) : NEW_LINE INDENT n1 = "0" + n1 NEW_LINE l += 1 NEW_LINE DEDENT n = list ( n1 ) NEW_LINE gSum = 0 NEW_LINE while ( l != 0 ) : NEW_LINE INDENT gvalue = 0 NEW_LINE if ( l == 2 ) : NEW_LINE INDENT gvalue = ( ( n [ ( l - 2 ) ] - 48 ) * 100 + ( n [ ( l - 1 ) ] - 48 ) * 10 ) NEW_LINE DEDENT elif ( l == 1 ) : NEW_LINE INDENT gvalue = ( ( n [ ( l - 1 ) ] - 48 ) * 100 ) NEW_LINE DEDENT else : NEW_LINE INDENT gvalue = ( ( n [ ( l - 3 ) ] - 48 ) * 100 + ( n [ ( l - 2 ) ] - 48 ) * 10 + ( n [ ( l - 1 ) ] - 48 ) * 1 ) NEW_LINE l = l - 3 NEW_LINE gSum = gSum + gvalue NEW_LINE DEDENT if ( gSum >= 1000 ) : NEW_LINE INDENT return ( divisibleby37 ( str ( gSum ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 1 if ( gSum % 37 == 0 ) else 0 ) NEW_LINE DEDENT l = l - 1 NEW_LINE DEDENT if ( divisibleby37 ( " " ) ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT
n , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if ( x - y <= 1 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif ( x - y <= n ) : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif ( x - y <= n ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT print ( p ) NEW_LINE DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT def findMinCost ( X , Y , costX , costY ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE len_LCS = lcs ( X , Y , m , n ) NEW_LINE return ( costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = " ef " NEW_LINE Y = " gh " NEW_LINE print ( " Minimum Cost to make two strings " + " same is = " + findMinCost ( X , Y , 10 , 20 ) ) NEW_LINE DEDENT
def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base // 2 NEW_LINE return base * ( base + 1 ) // 2 NEW_LINE DEDENT base = 8 NEW_LINE print ( numberOfSquares ( base ) ) NEW_LINE
from math import sqrt NEW_LINE def rmsValue ( arr , n ) : NEW_LINE INDENT square = 0 NEW_LINE mean = 0 NEW_LINE root = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT square += pow ( arr [ i ] , 2 ) NEW_LINE DEDENT mean = ( square / n ) NEW_LINE root = sqrt ( mean ) NEW_LINE return root NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 4 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( rmsValue ( arr , n ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import bisect NEW_LINE n , m , * p = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE p = sorted ( p ) NEW_LINE ans = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT c , e = map ( int , input ( ) . split ( ) ) NEW_LINE ans . append ( [ c , e ] ) NEW_LINE DEDENT ans . sort ( reverse = True ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m - i ) : NEW_LINE INDENT tmp = dp [ j ] NEW_LINE for k in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT tmp += p [ k ] NEW_LINE if tmp > ans [ k ] [ 1 ] : NEW_LINE INDENT ans [ k ] = tmp NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans [ 0 ] [ 0 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i // 2 > 0 : NEW_LINE INDENT print ( " node { } : parent = { } , key = { } , " . format ( i , a [ i // 2 ] ) ) NEW_LINE DEDENT elif 2 * i < n : NEW_LINE INDENT print ( " node { } : right = { } , key = { } , " . format ( i , a [ 2 * i + 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " node { } : null " . format ( i ) ) NEW_LINE DEDENT DEDENT
n = 6 ; m = 6 ; NEW_LINE def maxSum ( arr ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( n + 1 ) ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m1 = 0 ; m2 = 0 ; m3 = 0 ; NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( j // ( m // 3 ) ) == 0 : NEW_LINE INDENT m1 = max ( m1 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT elif ( j // ( m // 3 ) ) == 1 : NEW_LINE INDENT m2 = max ( m2 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT elif ( j // ( m // 3 ) ) == 2 : NEW_LINE INDENT m3 = max ( m3 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; NEW_LINE dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; NEW_LINE DEDENT print ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] , dp [ n ] [ 2 ] ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 2 , 2 ] , [ 1 , 5 , 2 , 4 , 6 ] ] ; NEW_LINE maxSum ( arr ) ; NEW_LINE DEDENT
def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y1 , y3 ) NEW_LINE x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE if ( x5 > x6 or y5 > y6 ) : NEW_LINE INDENT print ( " No intersection " ) NEW_LINE return NEW_LINE DEDENT print ( " ( " , x5 , " , " , y5 , " ) " , " ( " , x6 , " , " , y6 , " ) " , end = " " ) NEW_LINE x7 = x5 NEW_LINE y7 = y6 NEW_LINE print ( " ( " , x7 , " , " , y7 , " ) " , end = " " ) NEW_LINE x8 = x6 NEW_LINE y8 = y5 NEW_LINE print ( " ( " , x8 , " , " , y8 , " ) " , end = " " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 10 NEW_LINE y2 = 8 NEW_LINE x3 = 2 NEW_LINE y3 = 3 NEW_LINE x4 = 7 NEW_LINE y4 = 9 NEW_LINE FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = s . count ( " X " ) NEW_LINE b = s . count ( " X " ) NEW_LINE print ( min ( n , a - b ) ) NEW_LINE for i in range ( a - b + 1 ) : NEW_LINE INDENT if s [ i ] == " x " : NEW_LINE INDENT s [ i ] = " x " NEW_LINE DEDENT DEDENT print ( s [ - 1 ] ) NEW_LINE
n , d , e = map ( int , input ( ) . split ( ) ) NEW_LINE ans = n NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if i * 5 > n : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , ( n - i * 5 ) % d ) NEW_LINE DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE def knapSack ( W , wt , val , n ) : NEW_LINE INDENT maxratio = - ( sys . maxsize - 1 ) NEW_LINE maxindex = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( val [ i ] / wt [ i ] ) > maxratio ) : NEW_LINE INDENT maxratio = ( val [ i ] / wt [ i ] ) NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT return ( W * maxratio ) NEW_LINE DEDENT val = [ 14 , 27 , 44 , 19 ] NEW_LINE wt = [ 6 , 7 , 9 , 8 ] NEW_LINE n = len ( val ) NEW_LINE W = 50 NEW_LINE print ( knapSack ( W , wt , val , n ) ) NEW_LINE
def AlternateRearrange ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT index = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE flag = False NEW_LINE if ( arr [ 0 ] % 2 == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT while ( index < n ) : NEW_LINE INDENT if ( flag == True ) : NEW_LINE INDENT arr [ index ] = v1 [ i ] NEW_LINE i += 1 NEW_LINE index += 1 NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = v2 [ j ] NEW_LINE j += 1 NEW_LINE index += 1 NEW_LINE flag = not flag NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 9 , 8 , 13 , 2 , 19 , 14 ] NEW_LINE n = len ( arr ) NEW_LINE AlternateRearrange ( arr , n ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if ( c >= a ) and ( c <= b ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = n // 2 ; NEW_LINE i += 1 ; NEW_LINE DEDENT binary = " " ; NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT binary += str ( binaryNum [ j ] ) ; NEW_LINE DEDENT return binary ; NEW_LINE DEDENT def countFreq ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) ; NEW_LINE N = len ( txt ) ; NEW_LINE res = 0 ; NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 ; NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( j == M ) : NEW_LINE INDENT res += 1 ; NEW_LINE j = 0 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT def findOccurrence ( arr , n , pattern ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT binary = decToBinary ( arr [ i ] ) ; NEW_LINE print ( countFreq ( pattern , binary ) , end = " " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 105 , 7 , 8 ] ; NEW_LINE pattern = "10" ; NEW_LINE n = len ( arr ) ; NEW_LINE findOccurrence ( arr , n , pattern ) ; NEW_LINE DEDENT
def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += ( arr [ i ] & 1 ) NEW_LINE DEDENT print ( min ( x , n - x ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE makearrayequal ( arr , n ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def findKthLargest ( self , nums , k ) : NEW_LINE INDENT shuffle ( nums ) NEW_LINE k = len ( nums ) - k NEW_LINE lo = 0 NEW_LINE hi = len ( nums ) - 1 NEW_LINE while lo < hi : NEW_LINE INDENT j = partition ( nums , lo , hi ) NEW_LINE if j < k : NEW_LINE INDENT lo = j + 1 NEW_LINE DEDENT elif j > k : NEW_LINE INDENT hi = j - 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return nums [ k ] NEW_LINE DEDENT def partition ( nums , lo , hi ) : NEW_LINE INDENT i = lo NEW_LINE j = hi + 1 NEW_LINE while True : NEW_LINE INDENT while i < hi and less ( nums [ i ] , nums [ lo ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while j > lo and less ( nums [ lo ] , nums [ j ] ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if i >= j : NEW_LINE INDENT break NEW_LINE DEDENT exch ( nums , i , j ) NEW_LINE DEDENT exch ( nums , lo , j ) NEW_LINE return j NEW_LINE DEDENT def exch ( nums , i , j ) : NEW_LINE INDENT tmp = nums [ i ] NEW_LINE nums [ i ] = nums [ j ] NEW_LINE nums [ j ] = tmp NEW_LINE return nums [ k ] NEW_LINE DEDENT def less ( v , w ) : NEW_LINE INDENT return v < w NEW_LINE DEDENT def shuffle ( nums ) : NEW_LINE INDENT random = list ( map ( int , nums ) ) NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT random [ i ] = random [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( nums ) ) : NEW_LINE INDENT exch ( nums , i , j ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 3 , 2 , 1 , 5 , 6 ,
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( n > 0 ) : NEW_LINE INDENT k = n % 10 NEW_LINE if ( temp % k == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return " NO " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 9876543 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 NEW_LINE sum += k NEW_LINE n //= 10 NEW_LINE DEDENT if ( temp % sum == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT return " NO " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 123 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE s = input ( ) . rstrip ( ) NEW_LINE t = input ( ) . rstrip ( ) NEW_LINE ans = " EQUAL " NEW_LINE if len ( s ) != len ( t ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == t [ i ] : NEW_LINE INDENT ans = " BIGSS " NEW_LINE DEDENT elif s [ i ] > t [ i ] : NEW_LINE INDENT ans = " BIGSS " NEW_LINE DEDENT elif s [ i ] < t [ i ] : NEW_LINE INDENT ans = " BIGSS " NEW_LINE DEDENT DEDENT DEDENT elif len ( s ) > len ( t ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] > t [ i ] : NEW_LINE INDENT ans = " BIGSS " NEW_LINE DEDENT elif s [ i ] < t [ i ] : NEW_LINE INDENT ans = " BIGSS " NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE INDENT totalSquares = ( l - size + 1 ) * ( b - size + 1 ) NEW_LINE area = totalSquares * size * size NEW_LINE totalArea += area NEW_LINE size += 1 NEW_LINE DEDENT return totalArea NEW_LINE DEDENT l = 4 NEW_LINE b = 3 NEW_LINE print ( calculateAreaSum ( l , b ) ) NEW_LINE
def arrange ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE return NEW_LINE DEDENT if ( N == 2 or N == 3 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT even = - 1 NEW_LINE odd = - 1 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT even = N NEW_LINE odd = N - 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = N NEW_LINE even = N - 1 NEW_LINE DEDENT while ( odd >= 1 ) : NEW_LINE INDENT print ( odd , end = " " ) NEW_LINE odd = odd - 2 NEW_LINE DEDENT while ( even >= 2 ) : NEW_LINE INDENT print ( even , end = " " ) NEW_LINE even = even - 2 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE arrange ( N ) NEW_LINE
import sys NEW_LINE def findMinEqualSums ( a , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE min = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE sum2 = sum - sum1 NEW_LINE if ( abs ( sum1 - sum2 ) < min ) : NEW_LINE INDENT min = abs ( sum1 - sum2 ) NEW_LINE DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 2 , 1 , 5 , 7 , 8 ] NEW_LINE N = len ( a ) NEW_LINE print ( findMinEqualSums ( a , N ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( ( n // 3 ) * [ 12 ] * ( n % 3 + 1 ) ) NEW_LINE DEDENT
def findoptimalSolution ( a , N ) : NEW_LINE INDENT a . sort ( ) NEW_LINE points = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT points += a [ i ] * i NEW_LINE DEDENT return points NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEW_LINE N = len ( a ) NEW_LINE print ( findoptimalSolution ( a , N ) ) NEW_LINE DEDENT
from heapq import heappush , heappop NEW_LINE def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE edges = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT edges . append ( tuple ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT time = [ 0 ] * ( n + 1 ) NEW_LINE visited = [ False ] * ( n + 1 ) NEW_LINE dist = [ 0 ] * ( n + 1 ) NEW_LINE que = [ ] NEW_LINE heappush ( que , ( 0 , 0 ) ) NEW_LINE while que : NEW_LINE INDENT c , v = heappop ( que ) NEW_LINE if c % 2 == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if visited [ v ] : NEW_LINE INDENT continue NEW_LINE DEDENT visited [ v ] = True NEW_LINE for t in edges [ v ] : NEW_LINE INDENT heappush ( que , ( c + 2 , t ) ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for t in edges [ 1 : ] : NEW_LINE INDENT c , v = heappop ( que ) NEW_LINE if c % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( " % d " % ( count ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE if ( m > sum ( a [ : n ] ) ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT elif ( m == sum ( a [ n : ] ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def getPairs ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( a ) ) : NEW_LINE INDENT if ( a [ i ] < a [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 4 , 3 , 1 ] NEW_LINE print ( getPairs ( a ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT if s . count ( '1' ) > 0 : NEW_LINE INDENT ans . append ( s [ : i ] ) NEW_LINE DEDENT DEDENT if s . count ( '0' ) > 0 : NEW_LINE INDENT ans . append ( s [ : k ] ) NEW_LINE DEDENT print ( * ans , sep = ' ' ) NEW_LINE
arr = [ ] NEW_LINE for _ in range ( 4 ) : NEW_LINE INDENT x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . append ( x ) NEW_LINE DEDENT for i in range ( 1 , 4 ) : NEW_LINE INDENT if arr [ i ] [ 0 ] + arr [ i ] [ 1 ] + arr [ i ] [ 2 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT for i in range ( 1 , 4 ) : NEW_LINE INDENT if arr [ i ] [ 0 ] + arr [ i ] [ 1 ] + arr [ i ] [ 2 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE
N = 10000 NEW_LINE MOD = 1000000007 NEW_LINE F = [ 0 ] * N NEW_LINE def precompute ( ) : NEW_LINE INDENT F [ 1 ] = 2 NEW_LINE F [ 2 ] = 3 NEW_LINE F [ 3 ] = 4 NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE precompute ( ) NEW_LINE print ( F [ n ] ) NEW_LINE DEDENT
import itertools NEW_LINE def solve ( n ) : NEW_LINE INDENT is_ok = True NEW_LINE for t in itertools . repeat ( n , 0 ) : NEW_LINE INDENT if is_ok : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += int ( t ) NEW_LINE DEDENT is_ok = False NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( n ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def CeilIndex ( A , l , r , key ) : NEW_LINE INDENT while ( r - l > 1 ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( A [ m ] >= key ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def LongestIncreasingSubsequenceLength ( A , size ) : NEW_LINE INDENT tailTable = [ 0 for i in range ( size ) ] NEW_LINE tailTable [ 0 ] = A [ 0 ] NEW_LINE length = 1 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT if ( A [ i ] < tailTable [ 0 ] ) : NEW_LINE INDENT tailTable [ 0 ] = A [ i ] NEW_LINE DEDENT elif ( A [ i ] > tailTable [ length - 1 ] ) : NEW_LINE INDENT tailTable [ length - 1 ] = A [ i ] NEW_LINE length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tailTable [ CeilIndex ( tailTable , - 1 , length - 1 , A [ i ] ) ] = A [ i ] NEW_LINE DEDENT DEDENT return length NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 ] NEW_LINE n = len ( A ) NEW_LINE print ( " Length of Longest Increasing Subsequence is " , LongestIncreasingSubsequenceLength ( A , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ n - 1 ] - a [ 0 ] <= 1 : NEW_LINE INDENT print ( ( a [ n - 1 ] - a [ 0 ] ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( a [ n - 1 ] - a [ 0 ] + 1 ) // 2 ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE ans = sum ( Fastime ( i ) for i in range ( LIMIT ) if Fastime ( i ) == 60 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def Fastime ( n ) : NEW_LINE INDENT seen = set ( ) NEW_LINE while True : NEW_LINE INDENT if n not in seen : NEW_LINE INDENT return len ( seen ) NEW_LINE DEDENT n = eulerlib . factor sz sz sz ( n ) NEW_LINE DEDENT DEDENT Fastime ( 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 ) NEW_LINE def sz ( n ) : NEW_LINE INDENT return Fastime ( n // 10 ) + Fastime ( n % 10 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def colourVisible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 ] * ( K + 1 ) NEW_LINE l = 0 NEW_LINE l1 = height [ K - 1 ] NEW_LINE arr [ K - 1 ] = 1 NEW_LINE for i in range ( K - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( height [ i ] > l ) : NEW_LINE INDENT l = height [ i ] NEW_LINE arr [ T ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT l1 += 1 NEW_LINE DEDENT DEDENT return l1 NEW_LINE DEDENT height = [ 3 , 5 , 1 , 2 , 3 ] NEW_LINE k = len ( height ) NEW_LINE print ( k ) NEW_LINE
from math import log NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = log ( n ) / log ( 8 ) ; NEW_LINE return ( i - floor ( i ) < 0.000001 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 65 ; NEW_LINE if ( checkPowerof8 ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if l <= r : NEW_LINE INDENT print ( l ) NEW_LINE DEDENT elif l > r : NEW_LINE INDENT if l <= r : NEW_LINE INDENT print ( r ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( l + r ) // 4 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( l ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE if N == 0 and M == 0 : NEW_LINE INDENT break NEW_LINE DEDENT sum = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT sum . append ( 0 ) NEW_LINE DEDENT smax = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ans [ j ] > sum [ j ] : NEW_LINE INDENT sum [ j ] += ans [ j ] NEW_LINE DEDENT DEDENT if smax < sum [ M - 1 ] : NEW_LINE INDENT smax = sum [ M - 1 ] NEW_LINE DEDENT print ( max ( ans ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( l ) NEW_LINE b . append ( r ) NEW_LINE DEDENT ans = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] > ans [ j ] : NEW_LINE INDENT ans . append ( ans [ j ] ) NEW_LINE DEDENT elif a [ j ] < ans [ j ] : NEW_LINE INDENT ans . append ( ans [ j ] ) NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif ( i < m ) : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE m = 4 NEW_LINE print ( " Number of ways = " , countWays ( n , m ) ) NEW_LINE DEDENT
def print ( n ) : NEW_LINE INDENT print ( n + n // 2 ) NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( n ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = n NEW_LINE while ans % 2 == 0 : NEW_LINE INDENT ans //= 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
s = input ( ) NEW_LINE while s != " " : NEW_LINE INDENT s = s . replace ( " B " , " " ) NEW_LINE DEDENT print ( s ) NEW_LINE
while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT h = [ ] NEW_LINE for i in range ( a ) : NEW_LINE INDENT for j in range ( a ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT h . append ( [ i , j ] ) NEW_LINE DEDENT elif i + j == b : NEW_LINE INDENT h . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT DEDENT h = sorted ( h ) NEW_LINE print ( len ( h ) ) NEW_LINE DEDENT
MAX = 100 NEW_LINE def recur ( ind , cnt , last , a , n , k , dp ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ind == n ) : NEW_LINE INDENT return - 1e9 NEW_LINE DEDENT if ( dp [ ind ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( ind , n ) : NEW_LINE INDENT if ( cnt % 2 == 0 ) : NEW_LINE INDENT ans = max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) NEW_LINE DEDENT DEDENT dp [ ind ] [ cnt ] = ans NEW_LINE return dp [ ind ] [ cnt ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 4 , 5 , 3 , 7 , 8 , 10 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE k = 4 NEW_LINE dp = [ [ - 1 ] * MAX ] * n NEW_LINE print ( recur ( 0 , 0 , 0 , a , n , k , dp ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE arr = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE s = sum ( arr ) NEW_LINE x = s // 2 NEW_LINE if arr [ - 1 ] > s : NEW_LINE INDENT print ( s - x ) NEW_LINE exit ( ) NEW_LINE DEDENT y = n - 1 NEW_LINE u = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > u : NEW_LINE INDENT u += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y -= arr [ i ] NEW_LINE DEDENT DEDENT z = y - x NEW_LINE if z > 0 : NEW_LINE INDENT print ( min ( z , 1 - u ) ) NEW_LINE DEDENT elif z < 0 : NEW_LINE INDENT print ( 0 - z ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( z , 1 - y ) ) NEW_LINE DEDENT
def equivalentBase4 ( bin ) : NEW_LINE INDENT if ( bin > "00" ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( bin > "01" ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( bin > "10" ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT def isDivisibleBy5 ( bin ) : NEW_LINE INDENT l = len ( bin ) NEW_LINE if ( l % 2 != 0 ) : NEW_LINE INDENT bin = '0' + bin NEW_LINE DEDENT odd_sum = 0 NEW_LINE even_sum = 0 NEW_LINE isOddDigit = 1 NEW_LINE for i in range ( 0 , len ( bin ) , 2 ) : NEW_LINE INDENT if ( isOddDigit != 0 ) : NEW_LINE INDENT odd_sum += equivalentBase4 ( bin [ i : i + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT even_sum += equivalentBase4 ( bin [ i : i + 2 ] ) NEW_LINE DEDENT isOddDigit ^= 1 NEW_LINE DEDENT if ( abs ( odd_sum - even_sum ) % 5 == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT bin = "10000101001" NEW_LINE print ( isDivisibleBy5 ( bin ) ) NEW_LINE DEDENT
from collections import deque NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT f = [ [ 0 ] * 7 for _ in range ( 9 ) ] NEW_LINE f [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT l = list ( map ( int , list ( input ( ) ) ) ) NEW_LINE for j in range ( 7 ) : NEW_LINE INDENT x = f [ l [ 0 ] ] [ j ] NEW_LINE y = f [ l [ 1 ] ] [ j ] NEW_LINE if x + y <= 9 : NEW_LINE INDENT f [ l [ 0 ] ] [ j + y ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT f [ l [ 1 ] ] [ j + y ] = 2 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 7 ) : NEW_LINE INDENT for j in range ( 7 ) : NEW_LINE INDENT if f [ i ] [ j ] != 0 : NEW_LINE INDENT f [ i ] [ j ] = f [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 7 ) : NEW_LINE INDENT for j in range ( 7 ) : NEW_LINE INDENT if f [ i ] [ j ] != 0 : NEW_LINE INDENT f [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 7 ) : NEW_LINE INDENT for j in range ( 7 ) : NEW_LINE INDENT if f [ i ] [ j ] != 1 : NEW_LINE INDENT f [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 7 ) : NEW_LINE INDENT print ( f [ 7 ] [ i ] ) NEW_LINE DEDENT DEDENT
def solve ( arr , op ) : NEW_LINE INDENT if op == ' + ' : NEW_LINE INDENT arr [ 0 ] += arr [ 1 ] NEW_LINE DEDENT elif op == ' * ' : NEW_LINE INDENT arr [ 1 ] += arr [ 0 ] NEW_LINE DEDENT elif op == ' + ' : NEW_LINE INDENT arr [ 0 ] *= arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ 1 ] = min ( arr [ 1 ] , arr [ 0 ] ) NEW_LINE DEDENT return arr NEW_LINE DEDENT def main ( arr , op ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if op == ' + ' : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE DEDENT elif op == ' * ' : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT ans = solve ( arr , op ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( arr , op ) NEW_LINE DEDENT
MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT p = 2 NEW_LINE while p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT p += 1 NEW_LINE DEDENT DEDENT def minimumSquareFreeDivisors ( N ) : NEW_LINE INDENT primes = [ ] NEW_LINE SieveOfEratosthenes ( primes ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( primes ) and primes [ i ] * primes [ i ] <= N : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N = int ( N / primes [ i ] ) NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 24 NEW_LINE print ( " Minimum Number of SquareFree Divisors is " , minimumSquareFreeDivisors ( N ) ) NEW_LINE N = 6 NEW_LINE print ( " Minimum Number of SquareFree Divisors is " , minimumSquareFreeDivisors ( N ) ) NEW_LINE DEDENT
x , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( x - a ) % b ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = - 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if a [ i ] != a [ k - 1 ] : NEW_LINE INDENT ans = - 1 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ans == - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE print ( " The number after un set bit " , " the rightmost set bit " , fun ( n ) ) NEW_LINE DEDENT
def LongestFibSubseq ( A , n ) : NEW_LINE INDENT S = set ( ) NEW_LINE for t in A : NEW_LINE INDENT S . add ( t ) NEW_LINE DEDENT maxLen = 0 NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ j ] NEW_LINE y = A [ i ] + A [ j ] NEW_LINE length = 3 NEW_LINE while y in S and ( y != S [ - 1 ] ) : NEW_LINE INDENT z = x + y NEW_LINE x = y NEW_LINE y = z NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE DEDENT DEDENT DEDENT if maxLen >= 3 : NEW_LINE INDENT return maxLen NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE DEDENT
def countPairs ( a , b , n , m ) : NEW_LINE INDENT cnt = 0 NEW_LINE s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT sum = a [ i ] + b [ j ] NEW_LINE if sum in s . keys ( ) : NEW_LINE INDENT cnt += 1 NEW_LINE s [ sum ] = 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 12 , 2 , 7 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 4 , 3 , 8 ] NEW_LINE m = len ( b ) NEW_LINE print ( countPairs ( a , b , n , m ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def check ( arr , x , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = sqrt ( arr [ i ] ) NEW_LINE if ( floor ( y ) == ceil ( y ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum % x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 13 NEW_LINE if ( check ( arr , x , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE l = [ list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE l . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( l [ i ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT l [ i ] [ 1 ] = l [ i ] [ 0 ] NEW_LINE DEDENT DEDENT
def calculate_min_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE min_sum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT min_sum += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT return min_sum NEW_LINE DEDENT def calculate_max_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE max_sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT max_sum += abs ( a [ n - 1 - i ] - a [ i ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 10 , - 10 , 20 , - 40 ] NEW_LINE n = len ( a ) NEW_LINE print ( " The minimum sum of pairs is " , calculate_min_sum ( a , n ) ) NEW_LINE print ( " The maximum sum of pairs is " , calculate_max_sum ( a , n ) ) NEW_LINE DEDENT
if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif a [ i ] < b [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] %= 4 NEW_LINE DEDENT ans = " No " NEW_LINE if a [ n // 2 ] == 0 : NEW_LINE INDENT ans = " Yes " NEW_LINE DEDENT elif a [ n // 2 ] > 0 and a [ n // 2 + 1 ] == 0 : NEW_LINE INDENT ans = " Yes " NEW_LINE DEDENT elif a [ n // 2 ] == 1 and a [ n // 2 + 1 ] == 0 : NEW_LINE INDENT ans = " Yes " NEW_LINE DEDENT print ( ans ) NEW_LINE
def isPalindrome ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def ans ( s ) : NEW_LINE INDENT s2 = s NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s2 = s2 [ len ( s2 ) - 1 ] + s2 NEW_LINE s2 = s2 [ : len ( s2 ) - 1 ] NEW_LINE if ( s == None or s != s2 ) and isPalindrome ( s2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT if len ( s ) <= 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 ] * 25 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if ( max ( cnt ) >= ( len ( s ) - 1 ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 if ( ans ( s ) ) else 2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " nolon " NEW_LINE print ( solve ( s ) ) NEW_LINE DEDENT
def count_numbers ( k , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 2 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 10 NEW_LINE n = 3 NEW_LINE print ( count_numbers ( k , n ) ) NEW_LINE DEDENT
def minCost ( n , arr , cost ) : NEW_LINE INDENT sum = 0 NEW_LINE totalCost = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT totalCost += cost * sum NEW_LINE arr [ n - 1 ] += sum NEW_LINE totalCost += ( 2 * cost * arr [ n - 1 ] ) NEW_LINE return totalCost NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE cost = 1 NEW_LINE print ( minCost ( n , arr , cost ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = l [ 0 ] NEW_LINE a = l [ 1 ] NEW_LINE b = l [ 2 ] NEW_LINE if c >= 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif c >= 3 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE m = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE ans = 0 NEW_LINE while i < m : NEW_LINE INDENT if s [ i ] == " I " : NEW_LINE INDENT j = i NEW_LINE while j < n : NEW_LINE INDENT if s [ j ] == " I " : j += 1 NEW_LINE else : NEW_LINE INDENT s [ j ] = " O " NEW_LINE DEDENT j += 2 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE n = len ( s ) NEW_LINE while i < n and s [ i ] == '0' : NEW_LINE INDENT if s [ i ] == '5' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while i < n and s [ i ] == '0' : NEW_LINE INDENT if s [ i ] == '5' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def insert ( root , data ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT if data < root . data : NEW_LINE INDENT root . left = insert ( root . left , data ) NEW_LINE DEDENT if data > root . data : NEW_LINE INDENT root . right = insert ( root . right , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT def inorder ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( root . left ) NEW_LINE print ( root . data , end = " " ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 , 5 , 4 , 4 ] NEW_LINE root = None NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT root = insert ( root , arr [ i ] ) NEW_LINE DEDENT inorder ( root ) NEW_LINE
MAX_CHAR = 26 NEW_LINE def removeChars ( str , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT res = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LC D = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LC D [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LC D [ i ] [ j ] = LC D [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LC D [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LC D [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = " old n n n n n n n " NEW_LINE Y = " New n n n n n " NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( " Length of Longest common Substring is " , LCSubStr ( X , Y , m , n ) ) NEW_LINE DEDENT
def countOccurrences ( x , d ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 10 == d ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def maxOccurring ( x ) : NEW_LINE INDENT if ( x < 0 ) : NEW_LINE INDENT x = - x NEW_LINE DEDENT result = 0 NEW_LINE max_count = 1 NEW_LINE for d in range ( 0 , 10 + 1 ) : NEW_LINE INDENT count = countOccurrences ( x , d ) NEW_LINE if ( count >= max_count ) : NEW_LINE INDENT max_count = count NEW_LINE result = d NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT x = 1223355 NEW_LINE print ( " Max occuring digit is " , maxOccurring ( x ) ) NEW_LINE
def printLogestIncSubArr ( arr , n ) : NEW_LINE INDENT max = 1 NEW_LINE len = 1 NEW_LINE maxIndex = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( max < len ) : NEW_LINE INDENT max = len NEW_LINE maxIndex = i - max NEW_LINE DEDENT len = 1 NEW_LINE DEDENT DEDENT if ( max < len ) : NEW_LINE INDENT max = len NEW_LINE maxIndex = n - max NEW_LINE DEDENT for i in range ( maxIndex , max + maxIndex ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 3 , 5 , 7 , 8 , 9 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE printLogestIncSubArr ( arr , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT print ( n , * a ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT l , r , x = map ( int , input ( ) . split ( ) ) NEW_LINE w [ x - 1 ] -= 1 NEW_LINE w [ x - 1 ] += 1 NEW_LINE if r - l > 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE if w [ x - 1 ] > 0 : NEW_LINE INDENT flag = False NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT w [ i + 1 ] -= 1 NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT w [ i + 1 ] += 1 NEW_LINE DEDENT flag = True NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if w [ i + 1 ] > 0 : NEW_LINE INDENT w [ i + 1 ] -= 1 NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def Max_Sum ( a , n ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE S = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = res NEW_LINE res += a [ i ] NEW_LINE S += a [ i ] NEW_LINE res = max ( res , - S ) NEW_LINE DEDENT ans = S NEW_LINE ans = max ( ans , res ) NEW_LINE g = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT g -= a [ i ] NEW_LINE ans = max ( ans , g + b [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 6 , 10 , - 3 , 10 , - 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( " Maximum sum is : " , Max_Sum ( a , n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if l [ 0 ] == l [ 1 ] : NEW_LINE INDENT print ( l [ 0 ] * 2 - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l [ 1 ] * 2 ) NEW_LINE DEDENT DEDENT
def reverse ( string , x ) : NEW_LINE INDENT n = ( len ( string ) - x ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x - 1 , n , - 1 ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x , len ( string ) , 1 ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE x = 3 NEW_LINE reverse ( string , x ) NEW_LINE DEDENT
def lps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( str [ i ] == str [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT def minimumNumberOfDeletions ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE lps = lps ( str ) NEW_LINE return ( n - lps ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE print ( " Minimum number of deleteions = " , minimumNumberOfDeletions ( str ) ) NEW_LINE DEDENT
def bit_check ( n ) : NEW_LINE INDENT if ( n & ( n - 1 ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 14 ; NEW_LINE if ( bit_check ( n ) ) : NEW_LINE INDENT print ( '1' ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) ; NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE m = l [ - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if m == l [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif m < l [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 - 1 NEW_LINE ans = sum ( eulerlib . list_primes ( LIMIT // 2 ) for i in range ( len ( eulerlib . list_primes ( LIMIT // 2 ) ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
M = 20 NEW_LINE dp = [ [ [ [ - 1 for i in range ( M ) ] for j in range ( M ) ] for k in range ( 2 ) ] for i in range ( M ) ] NEW_LINE def count ( pos , cnt , tight , nonz , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT if ( cnt == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = 9 if ( tight ) else num [ pos ] NEW_LINE for dig in range ( limit + 1 ) : NEW_LINE INDENT currCnt = cnt NEW_LINE if ( dig == d ) : NEW_LINE INDENT if ( d != 0 or ( d == 0 and nonz ) ) : NEW_LINE INDENT currCnt += 1 NEW_LINE DEDENT DEDENT currTight = tight NEW_LINE if ( dig < num [ pos ] ) : NEW_LINE INDENT currTight = 1 NEW_LINE DEDENT ans += count ( pos + 1 , currCnt , currTight , ( dig != 0 ) , num ) NEW_LINE DEDENT dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans NEW_LINE return dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT num = [ ] NEW_LINE while ( x != 0 ) : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT num . reverse ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( 2 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = - 1 NEW_LINE DEDENT DEDENT ans += count ( 0 , 0 , 0 , num ) NEW_LINE DEDENT dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " :
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 10 == 9 : NEW_LINE INDENT n = n // 10 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n -= 1 NEW_LINE ans += n // 10 * 10 ** ( len ( str ( n ) ) - 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def isP n , num , i , j ) : NEW_LINE INDENT if ( i >= 0 and arr [ i ] > num ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( j < n and arr [ j ] > num ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def isT p p p p_1 ( arr , n , num , i , j ) : NEW_LINE INDENT if ( i >= 0 and arr [ i ] < num ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( j < n and arr [ j ] < num ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def printPeaksT p_1 ( arr , n ) : NEW_LINE INDENT print ( " P Bs : " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isP n , arr [ i ] , i - 1 , i + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( " T p Bs : " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isT p_1 ( arr , n , arr [ i ] , i - 1 , i + 1 ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 10 , 5 , 7 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printPeaksT p_1 ( arr , n ) NEW_LINE DEDENT
def index ( i ) : NEW_LINE INDENT return 1 + ( i >> 31 ) - ( - i >> 31 ) ; NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT s = [ " negative " , " zero " , " positive " ] ; NEW_LINE val = index ( n ) ; NEW_LINE print ( n , " is " , s [ val ] ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT check ( 30 ) ; NEW_LINE check ( - 20 ) ; NEW_LINE check ( 0 ) ; NEW_LINE DEDENT
def frequency ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 0 , 5 , 5 , 5 , 4 ] NEW_LINE x = 5 NEW_LINE n = len ( a ) NEW_LINE print ( frequency ( a , n , x ) ) NEW_LINE DEDENT
def isNum balanced ( num ) : NEW_LINE INDENT num = abs ( num ) NEW_LINE string = str ( num ) NEW_LINE l = len ( string ) NEW_LINE m = len ( set ( string ) ) NEW_LINE if ( l <= m / 2 or l == m ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 1234567890 NEW_LINE flag = isNum balanced ( N ) NEW_LINE if ( flag ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) NEW_LINE if ( 1 * sq * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isPrime ( sq ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 9 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 12397923568441 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT n = 1 NEW_LINE d = 0 NEW_LINE for i in range ( 99 , - 1 , - 1 ) : NEW_LINE INDENT temp = ( continindFractionTerm ( i ) * n ) + d NEW_LINE d = n NEW_LINE n = temp NEW_LINE DEDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT divrem = n // 2 and rem % 10 NEW_LINE sum += div rem NEW_LINE n = div rem NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT def continindFractionTerm ( i ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif i % 3 == 2 : NEW_LINE INDENT return i // 3 * 2 + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from math import pow NEW_LINE def LCM ( x , y , z ) : NEW_LINE INDENT ans = ( ( x * y ) // ( pow ( x , y ) ) ) ; NEW_LINE return ( ( z * ans ) // ( pow ( ans , z ) ) ) ; NEW_LINE DEDENT def findDivisible ( n , x , y , z ) : NEW_LINE INDENT lcm = LCM ( x , y , z ) ; NEW_LINE ndigitnumber = pow ( 10 , n - 1 ) ; NEW_LINE reminder = ndigitnumber % lcm ; NEW_LINE if ( reminder == 0 ) : NEW_LINE INDENT return ndigitnumber ; NEW_LINE DEDENT ndigitnumber += lcm - reminder ; NEW_LINE if ( ndigitnumber < pow ( 10 , n ) ) : NEW_LINE INDENT return ndigitnumber ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 ; x = 2 ; y = 3 ; z = 5 ; NEW_LINE res = findDivisible ( n , x , y , z ) ; NEW_LINE if ( res != 0 ) : NEW_LINE INDENT print ( res ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not possible " ) ; NEW_LINE DEDENT DEDENT
MAXN = 100001 NEW_LINE prime = [ True ] * MAXN NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAXN ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAXN , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def common_prime ( a , b ) : NEW_LINE INDENT gcd = gcd ( a , b ) NEW_LINE for i in range ( 2 , gcd + 1 ) : NEW_LINE INDENT if ( prime [ i ] and gcd % i == 0 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE a = 6 NEW_LINE b = 12 NEW_LINE common_prime ( a , b ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE data = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT s , l , p = map ( int , input ( ) . split ( ) ) NEW_LINE data . append ( ( s , l , p ) ) NEW_LINE DEDENT m = int ( input ( ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT r = int ( input ( ) ) NEW_LINE data . append ( r ) NEW_LINE DEDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for s , l , p in data : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if dp [ i ] < 0 : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - s ] + p ) NEW_LINE DEDENT DEDENT DEDENT ans = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if dp [ i ] < 0 : NEW_LINE INDENT ans [ i ] = dp [ i ] NEW_LINE DEDENT DEDENT if ans [ 0 ] == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ans [ i ] < ans [ i - 1 ] : NEW_LINE INDENT ans [ i ] = ans [ i - 1 ] NEW_LINE DEDENT DEDENT print ( * ans , sep = " \n " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from collections import deque NEW_LINE import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE G = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE G [ a ] . append ( b ) NEW_LINE G [ b ] . append ( a ) NEW_LINE DEDENT def dfs ( v ) : NEW_LINE INDENT if v == n : NEW_LINE INDENT return True NEW_LINE DEDENT if G [ v ] == [ ] : NEW_LINE INDENT return False NEW_LINE DEDENT if G [ v ] [ 0 ] != v : NEW_LINE INDENT return False NEW_LINE DEDENT if G [ v ] [ 0 ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if G [ v ] [ 1 ] != v : NEW_LINE INDENT return False NEW_LINE DEDENT return dfs ( G [ v ] [ 1 ] ) and ( dfs ( G [ v ] [ 0 ] ) or dfs ( G [ v ] [ 1 ] ) ) NEW_LINE DEDENT r = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r *= 2 NEW_LINE DEDENT if dfs ( 0 ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT r %= 2 NEW_LINE if r == 1 : NEW_LINE INDENT r *= 2 NEW_LINE DEDENT print ( ' Second ' if r == n else ' First ' ) NEW_LINE
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE grid = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT grid . append ( input ( ) ) NEW_LINE DEDENT s = ' YES ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if grid [ i ] [ j ] == '1' or grid [ i ] [ j ] == '3' : NEW_LINE INDENT s = ' NO ' NEW_LINE DEDENT DEDENT DEDENT print ( s ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE min_count = 0 NEW_LINE max_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT length = input ( ) NEW_LINE m = len ( length ) NEW_LINE if m == 0 : NEW_LINE INDENT min_count += 1 NEW_LINE DEDENT elif m > 0 : NEW_LINE INDENT min_count += 1 NEW_LINE DEDENT if k > min_count : NEW_LINE INDENT max_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_count += 5 NEW_LINE DEDENT DEDENT if min_count > max_count : NEW_LINE INDENT max_count += 1 NEW_LINE DEDENT print ( min_count , max_count ) NEW_LINE
k = [ input ( ) . lower ( ) for _ in range ( int ( input ( ) ) ) ] NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] in k and s [ 1 ] in k and s [ 2 ] in k : NEW_LINE INDENT print ( ' ACC ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' WA ' ) NEW_LINE DEDENT DEDENT
from sys import stdin , stdout NEW_LINE import sys NEW_LINE def solve ( ) : NEW_LINE INDENT n , l = map ( int , input ( ) . split ( ) ) NEW_LINE POSSIBLE = { 0 : - 1 } NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = input ( ) NEW_LINE POSSIBLE [ line . count ( '1' ) ] = 1 NEW_LINE DEDENT last = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = input ( ) NEW_LINE POSSIBLE [ line . count ( '1' ) ] = 1 NEW_LINE last = 0 NEW_LINE for j in range ( l ) : NEW_LINE INDENT if line [ j ] == '1' : NEW_LINE INDENT last ^= 1 NEW_LINE DEDENT POSSIBLE [ line . count ( '1' ) ] = min ( POSSIBLE [ line . count ( '1' ) ] , last ^ 1 ) NEW_LINE DEDENT DEDENT return min ( POSSIBLE ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT print ( " Case # { } : { } " . format ( case , solve ( ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def maxAreaOfIsland ( self , grid ) : NEW_LINE INDENT dr = [ 1 , - 1 , 0 , 0 ] NEW_LINE dc = [ 0 , 0 , 1 , - 1 ] NEW_LINE ans = 0 NEW_LINE for r in range ( len ( grid ) ) : NEW_LINE INDENT for c in range ( len ( grid [ 0 ] ) ) : NEW_LINE INDENT if grid [ r ] [ c ] == 1 : NEW_LINE INDENT shape = 0 NEW_LINE stack = [ ] NEW_LINE stack . append ( ( r , c ) ) NEW_LINE grid [ r ] [ c ] = 0 NEW_LINE while len ( stack ) > 0 : NEW_LINE INDENT r , c = stack . pop ( ) NEW_LINE x , y = x , y NEW_LINE shape += 1 NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT nr = r + dr [ k ] NEW_LINE nc = c + dc [ k ] NEW_LINE if 0 <= nr < len ( grid ) and 0 <= nc < len ( grid [ 0 ] ) and grid [ nr ] [ nc ] == 1 : NEW_LINE INDENT stack . append ( ( nr , nc ) ) NEW_LINE grid [ nr ] [ nc ] = 0 NEW_LINE DEDENT DEDENT DEDENT ans = max ( ans , shape ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE grid = [ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ] , [ 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 ] , [ 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 1 , 1
def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( ( pow ( x , 2 ) * ( pow ( x , 2 ) - 1 ) ) // ( pow ( x , 2 ) - 1 ) ) NEW_LINE sum2 = ( ( x * y * ( pow ( x , n ) * pow ( y , n ) - 1 ) ) // ( x * y - 1 ) ) NEW_LINE return sum1 + sum2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x , y , n = 2 , 2 , 2 NEW_LINE print ( sum ( x , y , n ) ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) // 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) // 6 NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 687 NEW_LINE print ( getSum ( n ) ) NEW_LINE DEDENT
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = head_ref NEW_LINE ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def deleteNonPrimeNodes ( head_ref ) : NEW_LINE INDENT ptr = head_ref NEW_LINE while ( ptr != None and isPrime ( ptr . data ) == False ) : NEW_LINE INDENT temp = ptr NEW_LINE ptr = ptr . next NEW_LINE DEDENT head_ref = ptr NEW_LINE if ( ptr == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT curr = ptr . next NEW_LINE while ( curr != None ) : NEW_LINE INDENT if ( not isPrime ( curr . data ) ) : NEW_LINE INDENT ptr . next = curr . next NEW_LINE curr = ptr . next NEW_LINE DEDENT else : NEW_LINE INDENT ptr = curr NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 17 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head
def main ( ) : NEW_LINE INDENT n , m , l = map ( int , input ( ) . split ( ) ) NEW_LINE INF = 10 ** 20 NEW_LINE cs = [ [ ] for _ in range ( n * m ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT d , a , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE cs [ a - 1 ] . append ( ( k << 16 ) | t ) NEW_LINE DEDENT dp = [ [ INF ] * ( l + 1 ) for _ in range ( n * m ) ] NEW_LINE for i in range ( n * m ) : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT c = cs [ i ] NEW_LINE l = j // 2 NEW_LINE if c > 0 : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j - c ] + t ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n * m - 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
N , M = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT k , t = map ( int , input ( ) . split ( ) ) NEW_LINE A [ k ] . append ( t ) NEW_LINE DEDENT A . sort ( ) NEW_LINE flag = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if flag == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( M ) : NEW_LINE INDENT if A [ i ] [ j ] == 0 : NEW_LINE INDENT A [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = 0 NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if flag == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE H , W = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( H ) : NEW_LINE INDENT s = input ( ) . rstrip ( ) NEW_LINE if ' B ' in s : NEW_LINE INDENT ans = max ( ans , abs ( ( s . index ( ' B ' ) + 1 ) // W ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , abs ( ( s . index ( ' B ' ) + 1 ) // W ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def minReplacement ( string ) : NEW_LINE INDENT if len ( string ) > 26 : NEW_LINE INDENT print ( " IMPOSSIBLE " ) NEW_LINE DEDENT else : NEW_LINE INDENT hash = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT if ( hash [ j ] == 0 ) : NEW_LINE INDENT hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE string = list ( string ) NEW_LINE string [ i ] = chr ( j + ord ( ' a ' ) ) + string [ i + 1 ] NEW_LINE hash [ j ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " xxxxyyyy " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " xxxxyyyy " NEW_LINE minReplacement ( string ) NEW_LINE DEDENT
def longestSubseq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_0 = [ 0 ] * ( n + 2 ) NEW_LINE pre_count_1 = [ 0 ] * ( n + 1 ) NEW_LINE post_count_0 = [ 0 ] * ( n + 2 ) NEW_LINE pre_count_0 [ 0 ] = 0 NEW_LINE post_count_0 [ n + 1 ] = 0 NEW_LINE pre_count_1 [ 0 ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pre_count_0 [ j ] = pre_count_0 [ j - 1 ] NEW_LINE pre_count_1 [ j ] = pre_count_1 [ j - 1 ] NEW_LINE post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] NEW_LINE if ( s [ j - 1 ] == '0' ) : NEW_LINE INDENT pre_count_0 [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre_count_1 [ j ] += 1 NEW_LINE DEDENT if ( s [ n - j ] == '0' ) : NEW_LINE INDENT post_count_0 [ n - j + 1 ] += 1 NEW_LINE DEDENT DEDENT if ( pre_count_0 [ n ] == n or pre_count_0 [ n ] == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "000011100000" NEW_LINE print ( longestSubseq ( s ) ) NEW_LINE DEDENT
def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , N + 1 , 2 ) : NEW_LINE INDENT if ( j * i > N + 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT def generatePrimeFactors ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE print ( " Factor Power " ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N //= s [ N ] NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print ( curr , " \ t " , cnt ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 360 NEW_LINE generatePrimeFactors ( N ) NEW_LINE DEDENT
def longestSubarray ( a , n ) : NEW_LINE INDENT hash = [ [ 0 for i in range ( 10 ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num != 0 ) : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num //= 10 NEW_LINE DEDENT DEDENT longest = - 10 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] [ j ] == 1 and hash [ i + 1 ] [ j ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if j == 10 : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 11 , 22 , 33 , 44 , 54 , 56 , 63 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestSubarray ( a , n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( ( a + b + c ) // 2 ) NEW_LINE DEDENT
def Divisors ( x ) : NEW_LINE INDENT c = 0 NEW_LINE v = [ ] NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x //= 2 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 3 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x //= 3 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 7 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x //= 7 NEW_LINE DEDENT v . append ( c ) NEW_LINE v . append ( x ) NEW_LINE return v NEW_LINE DEDENT def MinOperations ( a , b ) : NEW_LINE INDENT va = Divisors ( a ) NEW_LINE vb = Divisors ( b ) NEW_LINE if ( va [ 3 ] != vb [ 3 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = ( abs ( va [ 0 ] - vb [ 0 ] ) + abs ( va [ 1 ] - vb [ 1 ] ) + abs ( va [ 2 ] - vb [ 2 ] ) ) NEW_LINE return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 14 NEW_LINE b = 28 NEW_LINE print ( MinOperations ( a , b ) ) NEW_LINE DEDENT
N = 1000001 NEW_LINE c , n , m , a , b = c , n , m , a , b NEW_LINE def dfs ( a , b , v , vis ) : NEW_LINE INDENT vis [ a ] = 1 NEW_LINE c += 1 NEW_LINE for i in v : NEW_LINE INDENT if ( vis [ i ] == 0 and i != b ) : NEW_LINE INDENT dfs ( i , b , v , vis ) NEW_LINE DEDENT DEDENT DEDENT def Calculate ( v ) : NEW_LINE INDENT vis = [ 0 for i in range ( n + 1 ) ] NEW_LINE c = 0 NEW_LINE dfs ( a , b , vis ) NEW_LINE ans1 = n - c - 1 NEW_LINE dfs ( b , a , v , vis ) NEW_LINE ans2 = n - c - 1 NEW_LINE print ( ans1 * ans2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , m = 7 , 3 , 5 NEW_LINE edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 4 ] , [ 3 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 7 , 5 ] ] NEW_LINE v = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT v [ i ] = list ( ) NEW_LINE v [ edges [ i ] [ 0 ] ] . append ( edges [ i ] [ 1 ] ) NEW_LINE v [ edges [ i ] [ 1 ] ] . append ( edges [ i ] [ 0 ] ) NEW_LINE DEDENT Calculate ( v ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ans = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 10 == 9 : NEW_LINE INDENT ans = max ( ans , n * ( 9 ** ( 10 - 1 ) ) ) NEW_LINE n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , n * 9 ** ( 10 - 1 ) ) NEW_LINE n -= 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT i += a // b NEW_LINE a = a % b NEW_LINE if a < b : NEW_LINE INDENT t = a NEW_LINE a = b NEW_LINE b = t NEW_LINE DEDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE
import math NEW_LINE def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def largestDigitSumdivisior ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT res = max ( res , getSum ( i ) ) NEW_LINE res = max ( res , getSum ( n // i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE print ( largestDigitSumdivisior ( n ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE l , r = map ( int , input ( ) . split ( ) ) NEW_LINE def gcd ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT if x == y : NEW_LINE INDENT return x NEW_LINE DEDENT return gcd ( y , x % y ) NEW_LINE DEDENT l = list ( gcd ( l [ 0 ] , l [ 1 ] ) ) NEW_LINE r = list ( gcd ( r [ 0 ] , r [ 1 ] ) ) NEW_LINE l = list ( gcd ( l [ 0 ] , l [ 1 ] ) ) NEW_LINE r = list ( gcd ( r [ 0 ] , r [ 1 ] ) ) NEW_LINE l = list ( gcd ( l [ 0 ] , l [ 1 ] ) ) NEW_LINE r = list ( gcd ( r [ 0 ] , r [ 1 ] ) ) NEW_LINE l = list ( gcd ( l [ 0 ] , l [ 1 ] ) ) NEW_LINE r = list ( gcd ( r [ 0 ] , r [ 1 ] ) ) NEW_LINE l = list ( gcd ( l [ 0 ] , l [ 1 ] ) ) NEW_LINE r = list ( gcd ( r [ 0 ] , r [ 1 ] ) ) NEW_LINE l = list ( gcd ( l [ 0 ] , l [ 1 ] ) ) NEW_LINE r = list ( gcd ( r [ 0 ] , r [ 1 ] ) ) NEW_LINE ans = 0 NEW_LINE for i in l : NEW_LINE INDENT ans = max ( ans , i * ( i - l [ 0 ] ) // 2 ) NEW_LINE DEDENT for i in r : NEW_LINE INDENT ans = max ( ans , i * ( i - r [ 0 ] ) // 2 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT k = l [ i ] NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT l [ j ] = l [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT l [ j + 1 ] = k NEW_LINE DEDENT print ( * l ) NEW_LINE
from math import sqrt , floor NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isProduct ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 2 NEW_LINE while ( cnt < 2 and i * i <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num /= i NEW_LINE cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT def findNumbers ( N ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isProduct ( i ) and isPerfectSquare ( i ) ) : NEW_LINE INDENT vec . append ( i ) NEW_LINE DEDENT DEDENT for itr in vec : NEW_LINE INDENT print ( itr , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 30 NEW_LINE findNumbers ( N ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( " " . join ( [ " { } " . format ( n ) for n in list ( " ABCDEFGHIJKLMNOPQRSTUVWXYZ " [ n : ] ) ] ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = input ( ) NEW_LINE ans = 0 NEW_LINE while ( n >= 9 ) : NEW_LINE INDENT ans += 9 NEW_LINE n = n // 10 NEW_LINE DEDENT while ( n >= 10 ) : NEW_LINE INDENT ans += 10 NEW_LINE n = n // 10 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def divSum ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def areEquivalent ( num1 , num2 ) : NEW_LINE INDENT return divSum ( num1 ) == divSum ( num2 ) NEW_LINE DEDENT num1 = 559 NEW_LINE num2 = 703 NEW_LINE if ( areEquivalent ( num1 , num2 ) ) : NEW_LINE INDENT print ( " Equivalent " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not Equivalent " ) NEW_LINE DEDENT
def findY ( x ) : NEW_LINE INDENT if ( x > 2 ) : NEW_LINE INDENT return x - 2 NEW_LINE DEDENT return x + 2 NEW_LINE DEDENT x = 5 NEW_LINE print ( findY ( x ) ) NEW_LINE
MOD = 1000000007 NEW_LINE def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( modFact ( n , m ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT minj = i NEW_LINE c = 0 NEW_LINE for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT if a [ minj ] > a [ j ] : NEW_LINE INDENT minj = j NEW_LINE c += 1 NEW_LINE DEDENT DEDENT if c == 1 : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE a [ i ] , a [ minj ] = a [ minj ] , a [ i ] NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE print ( * ans ) NEW_LINE
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT import itertools NEW_LINE import time NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE from collections import deque NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE ni = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE eps = 10 ** ( - 9 ) NEW_LINE def main ( ) : NEW_LINE INDENT x , y = ns ( ) NEW_LINE graph = [ na ( ) for _ in range ( y ) ] NEW_LINE search_table = [ [ False ] * x for _ in range ( y ) ] NEW_LINE def dfs ( i , j ) : NEW_LINE INDENT global search_table NEW_LINE if graph [ i ] [ j ] : NEW_LINE INDENT return NEW_LINE DEDENT if i > 0 and j > 0 and graph [ i - 1 ] [ j ] : NEW_LINE INDENT return NEW_LINE DEDENT if j > 0 and graph [ i + 1 ] [ j ] : NEW_LINE INDENT return NEW_LINE DEDENT if i > 0 and j > 0 and graph [ i - 1 ] [ j - 1 ] : NEW_LINE INDENT return NEW_LINE DEDENT dfs ( i + 1 , j - 1 ) NEW_LINE search_table [ i ] [ j + 1 ] = True NEW_LINE return NEW_LINE DEDENT dfs ( 0 , 0 ) NEW_LINE print ( sum ( dfs ( 1 , 0 ) for _ in range ( y ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = [ ] NEW_LINE r = [ ] NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT l . append ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT r . append ( max ( r [ - 1 ] , a [ i ] ) ) NEW_LINE DEDENT DEDENT l . append ( a [ - 1 ] ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT ans . append ( l [ i ] ) NEW_LINE DEDENT l . reverse ( ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT ans . append ( r [ i ] ) NEW_LINE DEDENT print ( * ans ) NEW_LINE
def circlearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ) NEW_LINE return A NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = 8 , 10 NEW_LINE print ( circlearea ( a , b ) ) NEW_LINE DEDENT
def find ( arr , length , s ) : NEW_LINE INDENT for i in range ( 1 , length + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( ( i >> j ) & 1 ) % 2 == 1 : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT DEDENT if ( sum == s ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT sum = 5 NEW_LINE arr = [ - 1 , 2 , 4 , 121 ] NEW_LINE length = len ( arr ) NEW_LINE find ( arr , length , sum ) NEW_LINE
def K_String ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE fre = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT fre [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT str = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( fre [ i ] % k == 0 ) : NEW_LINE INDENT x = fre [ i ] // k NEW_LINE while ( x ) : NEW_LINE INDENT str += chr ( i + ord ( ' a ' ) ) NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabb " NEW_LINE k = 2 NEW_LINE print ( K_String ( s , k ) ) NEW_LINE DEDENT
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT N = int ( readline ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT E = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT c = 1 NEW_LINE for j in range ( 25 ) : NEW_LINE INDENT c *= 2 NEW_LINE E . append ( c ) NEW_LINE DEDENT E . append ( ( 1 + sum ( E ) ) / 2 ) NEW_LINE DEDENT write ( " % .16f \n " % sum ( map ( float , E ) ) ) NEW_LINE return True NEW_LINE DEDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT
a , b , n = map ( int , input ( ) . split ( ) ) NEW_LINE f = b / a NEW_LINE if a < b : NEW_LINE INDENT a = a NEW_LINE b = b NEW_LINE DEDENT if b < a : NEW_LINE INDENT print ( f ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( f + ( n - 1 ) // b ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def count ( a , x ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( a ) - 1 NEW_LINE while r - l > 1 : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE b = [ 0 ] * ( m + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= x : NEW_LINE INDENT b [ a [ i ] - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT r = count ( a , 1 ) NEW_LINE while r > 0 : NEW_LINE INDENT m = ( r - l ) // 2 NEW_LINE b = [ 0 ] * ( m + 1 ) NEW_LINE r = count ( a , m ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT b [ a [ i ] - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT l = count ( a , 1 ) NEW_LINE DEDENT print ( r ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 0 and k == 0 : NEW_LINE INDENT exit ( ) NEW_LINE DEDENT lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT lst [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT lst . sort ( key = lambda x : x [ 1 ] ) NEW_LINE f = 0 NEW_LINE for r in lst : NEW_LINE INDENT if r [ 0 ] < 0 : NEW_LINE INDENT f = 1 NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
def maxFreq ( s , a , b ) : NEW_LINE INDENT fre = [ 0 ] * 10 NEW_LINE n = len ( s ) NEW_LINE if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT fre [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT if ( fre [ a ] == 0 and fre [ b ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( fre [ a ] >= fre [ b ] ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT a = 4 NEW_LINE b = 7 NEW_LINE s = "47744" NEW_LINE print ( maxFreq ( s , a , b ) ) NEW_LINE
def maxZeros ( n ) : NEW_LINE INDENT if ( n == 0 or ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT b = 4 NEW_LINE setBit = 1 NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , b * 8 + 1 ) : NEW_LINE INDENT prev += 1 NEW_LINE if ( ( n & setBit ) == setBit ) : NEW_LINE INDENT setBit = setBit << 1 NEW_LINE break NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE DEDENT max0 = - 1 NEW_LINE cur = prev NEW_LINE for j in range ( i + 1 , b * 8 + 1 ) : NEW_LINE INDENT cur += 1 NEW_LINE if ( ( n & setBit ) == setBit ) : NEW_LINE INDENT if ( max0 < ( cur - prev - 1 ) ) : NEW_LINE INDENT max0 = cur - prev - 1 NEW_LINE DEDENT prev = cur NEW_LINE DEDENT setBit = setBit << 1 NEW_LINE DEDENT return max0 NEW_LINE DEDENT n = 549 NEW_LINE print ( maxZeros ( n ) ) NEW_LINE
def sumPowersK ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE num = 1 NEW_LINE while ( num <= n ) : NEW_LINE INDENT sum += num NEW_LINE num *= k NEW_LINE DEDENT return sum NEW_LINE DEDENT def getSum ( n , k ) : NEW_LINE INDENT pwrK = sumPowersK ( n , k ) NEW_LINE sumAll = ( n * ( n + 1 ) ) // 2 NEW_LINE return ( sumAll - pwrK ) NEW_LINE DEDENT n = 10 NEW_LINE k = 3 NEW_LINE print ( getSum ( n , k ) ) NEW_LINE
def XandYandZintercept ( A , B , C , D ) : NEW_LINE INDENT rslt = [ 0 ] * 3 NEW_LINE x = - D / A NEW_LINE y = - D / B NEW_LINE z = - D / C NEW_LINE rslt [ 0 ] = x NEW_LINE rslt [ 1 ] = y NEW_LINE rslt [ 2 ] = z NEW_LINE return rslt NEW_LINE DEDENT A , B , C , D = 2 , 5 , 7 , 8 NEW_LINE rslt = XandYandZintercept ( A , B , C , D ) NEW_LINE print ( round ( rslt , 2 ) ) NEW_LINE
def maxSum ( a , n ) : NEW_LINE INDENT l = [ ] NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += abs ( a [ i ] ) NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE l . append ( i ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT print ( l [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE a = [ 1 , - 2 , - 3 , 4 ] NEW_LINE maxSum ( a , n ) NEW_LINE DEDENT
MAX = 1000 NEW_LINE def replaceSpace ( string ) : NEW_LINE INDENT space_count = 0 NEW_LINE i = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ' ' ) : NEW_LINE INDENT space_count += 1 NEW_LINE DEDENT while ( string [ i - 1 ] == ' ' ) : NEW_LINE INDENT space_count -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT new_length = i + space_count * 2 NEW_LINE if ( new_length > MAX ) : NEW_LINE INDENT return string NEW_LINE DEDENT index = new_length - 1 NEW_LINE new_str = string NEW_LINE string = [ 0 ] * ( new_length ) NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( new_str [ j ] == ' ' ) : NEW_LINE INDENT string [ index ] = '0' NEW_LINE string [ index - 1 ] = '2' NEW_LINE string [ index - 2 ] = ' % ' NEW_LINE index = index - 3 NEW_LINE DEDENT else : NEW_LINE INDENT string [ index ] = new_str [ j ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return string NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " Mr John Smith " NEW_LINE string = replaceSpace ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s , m = map ( str , input ( ) . split ( ) ) NEW_LINE a = int ( input ( ) ) NEW_LINE ans = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT if s == '0' : NEW_LINE INDENT ans += '1' NEW_LINE DEDENT else : NEW_LINE INDENT ans += '0' * ( n - i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s == '1' : NEW_LINE INDENT ans += '1' NEW_LINE DEDENT else : NEW_LINE INDENT ans += '0' * ( n - i ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def check ( n ) : NEW_LINE INDENT m = n NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE if ( r > 0 ) : NEW_LINE INDENT if ( ( m % r ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT def count ( l , r ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( check ( i ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 10 NEW_LINE r = 20 NEW_LINE print ( count ( 10 , 20 ) ) NEW_LINE DEDENT
l = list ( input ( ) . split ( ) ) NEW_LINE l [ 0 ] = int ( l [ 0 ] ) NEW_LINE l [ 1 ] = int ( l [ 1 ] ) NEW_LINE if l [ 1 ] == l [ 0 ] + 1 : NEW_LINE INDENT print ( l [ 0 ] , l [ 1 ] ) NEW_LINE DEDENT elif l [ 1 ] == l [ 0 ] + 1 : NEW_LINE INDENT print ( l [ 1 ] , l [ 0 ] + 2 ) NEW_LINE DEDENT elif l [ 1 ] == l [ 0 ] + 1 : NEW_LINE INDENT print ( l [ 0 ] , l [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE heights = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE heights . sort ( ) NEW_LINE result = 10 ** 9 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT diff = heights [ i + 1 ] - heights [ j ] NEW_LINE if diff > result : NEW_LINE INDENT result = diff NEW_LINE DEDENT DEDENT elif i == j : NEW_LINE INDENT diff = heights [ i + 1 ] - heights [ i ] NEW_LINE if diff > result : NEW_LINE INDENT result = diff NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( result ) NEW_LINE
num = input ( ) NEW_LINE n = int ( num [ - 1 ] ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif n % 4 == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
k = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE s = s . replace ( ' ' , ' ' ) NEW_LINE s = s . replace ( ' '9' , ' ' ) NEW_LINE s = s . replace ( '0' , ' ' ) NEW_LINE s = s . replace ( '1' , ' ' ) NEW_LINE s = s . replace ( '0' , ' ' ) NEW_LINE s = s . replace ( '1' , ' ' ) NEW_LINE s = s . replace ( '9' , ' ' ) NEW_LINE print ( k - len ( s ) ) NEW_LINE
n , k , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( 1 * a ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT q = k - 1 NEW_LINE r = a NEW_LINE while q > r : NEW_LINE INDENT m = ( q - r ) // k NEW_LINE tmp = m * a NEW_LINE m -= ( m + 1 ) // k NEW_LINE if tmp > b : NEW_LINE INDENT print ( m * b + tmp ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT r = m + 1 NEW_LINE DEDENT print ( m * a ) NEW_LINE
def digSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum += n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 1234 NEW_LINE print ( digSum ( n ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE dp = [ [ 0 ] * ( m + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if s [ i ] == t [ j ] : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = max ( dp [ i ] [ j + 1 ] , dp [ i ] [ j ] + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = max ( dp [ i ] [ j + 1 ] , dp [ i ] [ j ] + 2 ) NEW_LINE DEDENT DEDENT DEDENT print ( max ( dp [ n ] ) ) NEW_LINE
def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( n , " th Centered heptagonal number : " , centered_heptagonal_num ( n ) ) NEW_LINE DEDENT
def missingNum ( arr , n ) : NEW_LINE INDENT l = list ( ) NEW_LINE for i in arr : NEW_LINE INDENT l . append ( int ( i ) ) NEW_LINE DEDENT minvalue = min ( l ) NEW_LINE xornum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xornum ^= ( minvalue ) ^ arr [ i ] NEW_LINE minvalue += 1 NEW_LINE DEDENT return xornum ^ minvalue NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 13 , 12 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( missingNum ( arr , n ) ) NEW_LINE DEDENT
def smallestPermute ( n ) : NEW_LINE INDENT res = [ ' ' ] * ( n + 1 ) ; NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) ; NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) ; NEW_LINE DEDENT DEDENT res [ n - 1 ] = chr ( 48 + n - 2 ) ; NEW_LINE res [ n - 2 ] = chr ( 48 + n ) ; NEW_LINE res [ n - 3 ] = chr ( 48 + n - 1 ) ; NEW_LINE DEDENT res [ n ] = ' \ 0' ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE smallestPermute ( n ) ; NEW_LINE
def minOperations ( a , n , K ) : NEW_LINE INDENT map = dict . fromkeys ( a , False ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] = True ; NEW_LINE DEDENT b = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = a [ i ] & K ; NEW_LINE DEDENT map . clear ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT map [ b [ i ] ] = True ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT map . clear ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( map [ b [ i ] ] ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( map [ b [ i ] ] ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT K = 3 ; NEW_LINE a = [ 1 , 2 , 3 , 7 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( minOperations ( a , n , K ) ) ; NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT w = int ( input ( ) ) NEW_LINE if w == 0 : NEW_LINE INDENT break NEW_LINE DEDENT h = int ( input ( ) ) NEW_LINE grid = [ ] NEW_LINE for _ in range ( h ) : NEW_LINE INDENT grid . append ( list ( input ( ) ) ) NEW_LINE DEDENT res = [ [ 0 ] * w for _ in range ( h ) ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if grid [ i ] [ j ] == ' . ' : NEW_LINE INDENT B = 0 NEW_LINE x1 , y1 = i - 1 , j - 1 NEW_LINE dx = [ 0 , 1 , 0 , - 1 ] NEW_LINE for dx_ in range ( - 1 , 2 ) : NEW_LINE INDENT for dy_ in range ( - 1 , 2 ) : NEW_LINE INDENT if grid [ i + dx_ ] [ dy_ ] == ' . ' and grid [ i + dx_ ] [ dy_ ] == ' x ' : NEW_LINE INDENT x1 , y1 = i + dx_ , j + dy_ NEW_LINE if grid [ i ] [ dy_ ] == ' x ' : NEW_LINE INDENT res [ i ] [ dy_ ] += dx_ NEW_LINE DEDENT if grid [ i ] [ dy_ ] == ' y ' : NEW_LINE INDENT res [ i ] [ dy_ ] += dy_ NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( * res ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % ( 180 - n ) == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT NUM_VALUEVALUE_MAX = 20 NEW_LINE NUM_VALUE_MIN = - 20 NEW_LINE numerator = 0 NEW_LINE denominator = eulerlib . binomial ( NUM_VALUE_MAX , B max ( N_VALUE_MIN , N_VALUE_MIN ) ) NEW_LINE num = ( numerator ) // ( den ) NEW_LINE den = ( denominator ) // 9 NEW_LINE return str ( num // den ) NEW_LINE DEDENT def explore ( remain , limit , history ) : NEW_LINE INDENT if remain == 0 : NEW_LINE INDENT hist = [ 0 ] * ( NUM_VALUE_MAX + 1 ) NEW_LINE for i in range ( len ( hist ) ) : NEW_LINE INDENT hist [ i ] = hist [ i ] + 1 NEW_LINE DEDENT hist_new = [ 0 ] * ( B_VALUE_MAX + 1 ) NEW_LINE for x in hist : NEW_LINE INDENT hist_new [ x ] += 1 NEW_LINE DEDENT count = eulerlib . binomial ( NUM_VALUE_MAX , B_VALUE_MAX ) NEW_LINE for x in hist : NEW_LINE INDENT count = divide ( count , eulerlib . binomial ( x , B_VALUE_MAX ) ) NEW_LINE DEDENT distinct colors = len ( hist ) NEW_LINE numerator = numerator + distinct colors * ( hist_new [ : - 1 ] ) NEW_LINE DEDENT elif remain == 1 : NEW_LINE INDENT hist = [ 0 ] * ( NUM_VALUE_MAX + 1 ) NEW_LINE for x in hist : NEW_LINE INDENT hist [ x ] += 1 NEW_LINE DEDENT count = eulerlib . binomial ( NUM_VALUE_MAX , B_VALUE_MAX ) NEW_LINE for x in hist : NEW_LINE INDENT count = divide ( count , eulerlib . binomial ( x , B_VALUE_MAX ) ) NEW_LINE DEDENT distinct colors = len ( hist ) NEW_LINE numerator = numerator + distinct colors * ( hist [ : - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( history ) >= NUM_VALUE_MAX : NEW_LINE INDENT for i in range ( min ( limit , remain ) , distinct ) : NEW_LINE INDENT hist [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT n , t = map ( int , input ( ) . split ( ) ) NEW_LINE star = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = star [ i ] [ 1 ] NEW_LINE b = star [ i ] [ 0 ] NEW_LINE if a >= t : NEW_LINE INDENT c = a - t NEW_LINE if c > 2 * c : NEW_LINE INDENT ans . append ( " { } { } " . format ( c // 60 , c % 60 ) ) NEW_LINE DEDENT DEDENT elif b >= t : NEW_LINE INDENT ans . append ( " { } { } " . format ( c // 60 , c % 60 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( " { } { } " . format ( c // 60 , c % 60 ) ) NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT elif b == 2 : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( a , " " , a * b , " " , ( b + 1 ) * a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( a , " " , a * b , " " , ( b + 1 ) * a ) NEW_LINE DEDENT DEDENT
while True : NEW_LINE INDENT hit , blow = 0 , 0 NEW_LINE a = list ( input ( ) ) NEW_LINE b = list ( input ( ) ) NEW_LINE if a [ 0 ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if 0 in a : NEW_LINE INDENT hit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT if b [ i ] == a [ i ] : NEW_LINE INDENT blow += 1 NEW_LINE DEDENT DEDENT DEDENT blow -= hit NEW_LINE print ( hit , blow ) NEW_LINE DEDENT
def findMaxValue ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT print ( " The array should have " , " NET 4 elements " ) NEW_LINE DEDENT table1 = [ 0 ] * ( n + 1 ) NEW_LINE table2 = [ 0 ] * ( n + 1 ) NEW_LINE table3 = [ 0 ] * ( n - 1 ) NEW_LINE table4 = [ 0 ] * ( n - 2 ) NEW_LINE for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT arr = [ 4 , 8 , 9 , 2 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxValue ( arr , n ) ) NEW_LINE
def centeredHexagonalSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( 3 * i * ( i - 1 ) + 1 , end = " " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE centeredHexagonalSeries ( n ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def I ( ) : return int ( input ( ) ) NEW_LINE def MI ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def LI2 ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def LS ( ) : return input ( ) . split ( ) NEW_LINE def S3 ( ) : return input ( ) . split ( ) NEW_LINE def LS3 ( ) : return input ( ) . split ( ) NEW_LINE S = S3 ( ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE from collections import deque NEW_LINE S = deque ( list ( S ) ) NEW_LINE if S [ 0 ] == " A " : NEW_LINE INDENT S . append ( " B " ) NEW_LINE DEDENT elif S [ 1 ] == " B " : NEW_LINE INDENT S . append ( " C " ) NEW_LINE DEDENT elif S [ 2 ] == " C " : NEW_LINE INDENT S . append ( " D " ) NEW_LINE DEDENT else : NEW_LINE INDENT S . append ( " E " ) NEW_LINE DEDENT S . append ( " F " ) NEW_LINE S . append ( " G " ) NEW_LINE S . append ( " H " ) NEW_LINE S . append ( " I " ) NEW_LINE S . append ( " J " ) NEW_LINE S . append ( " K " ) NEW_LINE S . append ( " L " ) NEW_LINE S . append ( " M " ) NEW_LINE S . append ( " N " ) NEW_LINE print ( " A " * len ( S ) ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = [ ] NEW_LINE for i in range ( a ) : NEW_LINE INDENT s = input ( ) NEW_LINE c . append ( s ) NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( b ) : NEW_LINE INDENT c_i = 0 NEW_LINE for j in range ( a ) : NEW_LINE INDENT if c [ i ] [ j ] == 66 : NEW_LINE INDENT c_i += 1 NEW_LINE DEDENT DEDENT ans . append ( c_i ) NEW_LINE DEDENT print ( len ( ans ) // len ( ans ) , end = " " ) NEW_LINE print ( ans [ 0 ] // len ( ans ) ) NEW_LINE
def diagonalsMinMax ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT principalMin , principalMax = mat [ 0 ] [ 0 ] , principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin , secondaryMax = mat [ n - 1 ] [ 0 ] , secondaryMax = mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < principalMin ) : NEW_LINE INDENT principalMin = mat [ i ] [ j ] NEW_LINE DEDENT if ( mat [ i ] [ j ] > principalMax ) : NEW_LINE INDENT principalMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( ( i + j ) == n - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < secondaryMin ) : NEW_LINE INDENT secondaryMin = mat [ i ] [ j ] NEW_LINE DEDENT if ( mat [ i ] [ j ] > secondaryMax ) : NEW_LINE INDENT secondaryMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Principal Diagonal Smallest Element : " , principalMin ) NEW_LINE print ( " Principal Diagonal Greatest Element : " , principalMax ) NEW_LINE print ( " Secondary Diagonal Smallest Element : " , secondaryMin ) NEW_LINE print ( " Secondary Diagonal Greatest Element : " , secondaryMax ) NEW_LINE DEDENT matrix = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] NEW_LINE diagonalsMinMax ( matrix ) NEW_LINE
def diagonalsMinMax ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT principalMin , principalMax = mat [ 0 ] [ 0 ] , principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin , secondaryMax = mat [ n - 1 ] [ 0 ] , secondaryMax = mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ i ] < principalMin ) : NEW_LINE INDENT principalMin = mat [ i ] [ i ] NEW_LINE DEDENT if ( mat [ i ] [ i ] > principalMax ) : NEW_LINE INDENT principalMax = mat [ i ] [ i ] NEW_LINE DEDENT if ( mat [ n - 1 - i ] [ i ] < secondaryMin ) : NEW_LINE INDENT secondaryMin = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT if ( mat [ n - 1 - i ] [ i ] > secondaryMax ) : NEW_LINE INDENT secondaryMax = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT DEDENT print ( " Principal Diagonal Smallest Element : " , principalMin ) NEW_LINE print ( " Principal Diagonal Greatest Element : " , principalMax ) NEW_LINE print ( " Secondary Diagonal Smallest Element : " , secondaryMin ) NEW_LINE print ( " Secondary Diagonal Greatest Element : " , secondaryMax ) NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] NEW_LINE diagonalsMinMax ( mat ) NEW_LINE
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid Input " ) NEW_LINE return - 1 NEW_LINE DEDENT sum = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT count += 1 NEW_LINE sum += n NEW_LINE n = n - 2 NEW_LINE DEDENT return sum // count NEW_LINE DEDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid Input " ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE DEDENT
def areElementsContiguous ( arr , n ) : NEW_LINE INDENT us = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT us [ arr [ i ] ] = 1 NEW_LINE DEDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while ( curr_ele in us ) : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while ( curr_ele in us ) : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def getLeftMostZero ( zero ) : NEW_LINE INDENT if ( zero . empty ( ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT zero . pop ( ) NEW_LINE return 0 NEW_LINE DEDENT def getLeftMostOne ( one ) : NEW_LINE INDENT if ( one . empty ( ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT one . pop ( ) NEW_LINE return 1 NEW_LINE DEDENT def getLeftMostElement ( zero , one ) : NEW_LINE INDENT if ( zero . empty ( ) and one . empty ( ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( zero . empty ( ) ) : NEW_LINE INDENT one . pop ( ) NEW_LINE return 1 NEW_LINE DEDENT elif ( one . empty ( ) ) : NEW_LINE INDENT zero . pop ( ) NEW_LINE return 0 NEW_LINE DEDENT res = 1 if ( zero . empty ( ) and one . empty ( ) ) else 0 NEW_LINE if ( res == 0 ) : NEW_LINE INDENT zero . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT one . pop ( ) NEW_LINE DEDENT return res NEW_LINE DEDENT def performQueries ( arr , n , queries , q ) : NEW_LINE INDENT zero = [ ] NEW_LINE one = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT zero . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT one . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( q ) : NEW_LINE INDENT type , value = queries [ i ] NEW_LINE if ( type == 1 ) : NEW_LINE INDENT print ( getLeftMostZero ( zero ) ) NEW_LINE DEDENT elif ( type == 2 ) : NEW_LINE INDENT print ( getLeftMostOne ( one ) ) NEW_LINE DEDENT elif ( type == 3 ) : NEW_LINE INDENT print ( getLeftMostElement ( zero , one ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE queries = [ 1 , 3 , 1 ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( arr , n ,
def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) NEW_LINE print ( val * ( - 1 ) , 0 , end = " " ) NEW_LINE print ( val * ( - 1 ) , end = " " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x , y = 3 , 3 NEW_LINE Vertices ( x , y ) NEW_LINE DEDENT
def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 ] * n NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = P [ n - 1 ] NEW_LINE hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ P [ i ] ] = 1 NEW_LINE DEDENT res = dict ( ) NEW_LINE for i in range ( 1 , S + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT pres = True NEW_LINE div1 = i NEW_LINE div2 = S // i NEW_LINE for j in range ( div1 , S + 1 , div1 ) : NEW_LINE INDENT if ( hash [ j ] != 1 ) : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div1 != S ) : NEW_LINE INDENT res [ div1 ] = 1 NEW_LINE DEDENT pres = True NEW_LINE for j in range ( S // i , S + 1 , S // i ) : NEW_LINE INDENT if ( hash [ j ] != 1 ) : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div2 != S ) : NEW_LINE INDENT res [ div2 ] = 1 NEW_LINE DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 2 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE getSum ( a , n ) NEW_LINE DEDENT
def originalArray ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr [ i ] = temp [ k ] NEW_LINE temp . pop ( k ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Arr = [ 6 , 3 , 2 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( Arr ) NEW_LINE originalArray ( Arr , n ) NEW_LINE DEDENT
s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE s_cnt = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT t = input ( ) NEW_LINE s_cnt += 1 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ j ] == t [ 0 ] : NEW_LINE INDENT s_cnt += 1 NEW_LINE DEDENT elif s [ j ] == t [ 1 ] : NEW_LINE INDENT s_cnt -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( s_cnt ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def findRadius ( self , houses , heaters ) : NEW_LINE INDENT heaters . sort ( ) NEW_LINE result = - 999999999 NEW_LINE for house in houses : NEW_LINE INDENT index = binarySearch ( heaters , house ) NEW_LINE if index < 0 : NEW_LINE INDENT index = - ( index + 1 ) NEW_LINE DEDENT if index - 1 >= 0 : NEW_LINE INDENT result = house - heaters [ index - 1 ] NEW_LINE DEDENT if index < len ( heaters ) : NEW_LINE INDENT result = max ( result , min ( result , heaters [ index ] - house ) ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE houses = [ 1 , 2 , 3 ] NEW_LINE heaters = [ 2 ] NEW_LINE out = sObj . findRadius ( houses , heaters ) NEW_LINE print ( out ) NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( itertools . islice ( filter ( is_prime , itertools . count ( 2 ) ) , 25 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def find_ least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n > 10 ** ( - 1 ) : NEW_LINE INDENT raise ValueError ( " Arithmetic overflow " ) NEW_LINE DEDENT sum = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while ( sum % n != 0 ) : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE def checkRecursive ( num , x , k , n ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT r = int ( math . floor ( num ** 1.0 / n ) ) NEW_LINE for i in range ( k + 1 , r + 1 ) : NEW_LINE INDENT a = x - pow ( i , n ) NEW_LINE if ( a >= 0 ) : NEW_LINE INDENT checkRecursive ( num , x - pow ( i , n ) , i , n ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def check ( x , n ) : NEW_LINE INDENT return checkRecursive ( x , x , 0 , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( check ( 10 , 2 ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE s = input ( ) [ : - 1 ] NEW_LINE dp = [ [ ] for _ in range ( len ( s ) ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE if len ( s ) > 1 : NEW_LINE INDENT dp [ 0 ] [ 1 ] = s [ 0 ] NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if i > 1 and s [ i ] == s [ i - 1 ] : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] + 1 NEW_LINE DEDENT elif i > 1 : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT if len ( s ) > 1 : NEW_LINE INDENT dp [ len ( s ) ] [ 0 ] = 7 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ len ( s ) ] [ 1 ] = dp [ len ( s ) - 1 ] [ 0 ] NEW_LINE DEDENT print ( ' = ' . join ( s ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = [ ] NEW_LINE brr = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT arr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE brr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT dp = [ [ - 1 ] * ( 10001 ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = sum ( brr [ : n ] ) / 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j + brr [ i ] ] + arr [ i ] ) / 2 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j + brr [ i ] ] + arr [ i ] ) / 2 NEW_LINE DEDENT DEDENT print ( max ( dp [ n ] ) , end = " " ) NEW_LINE
from math import log10 , ceil NEW_LINE def log10 ( x ) : NEW_LINE INDENT return log10 ( x - 1 ) + ceil ( log10 ( x % 10 ) ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE print ( log10 ( n ) ) NEW_LINE
def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = 0 NEW_LINE sum = a + b NEW_LINE temp = 1 NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( not prime ( sum + temp ) ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE
def Squares ( n , m , a ) : NEW_LINE INDENT return ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m , a = 6 , 6 , 4 NEW_LINE print ( Squares ( n , m , a ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a % b == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j * j <= i ) : NEW_LINE INDENT if ( j * j * j == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT a = 7 NEW_LINE b = 30 NEW_LINE print ( " Count of Cubes is " , countCubes ( a , b ) ) NEW_LINE
from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE oddo , eveno = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT oddo . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT eveno . append ( i ) NEW_LINE DEDENT DEDENT if len ( oddo ) == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif len ( eveno ) == 1 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( oddo ) % 2 == 0 : NEW_LINE INDENT if eveno [ 0 ] > n : NEW_LINE INDENT print ( eveno [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT elif len ( eveno ) % 2 == 1 : NEW_LINE INDENT if oddo [ 0 ] > n : NEW_LINE INDENT print ( oddo [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if len ( oddo ) % 2 == 1 : NEW_LINE INDENT if eveno [ 0 ] > n : NEW_LINE INDENT print ( oddo [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if oddo [ 1 ] > n : NEW_LINE INDENT print ( oddo [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT DEDENT
def SubString ( strr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT print ( strr [ i : j ] ) NEW_LINE DEDENT DEDENT DEDENT strr = " abcd " NEW_LINE SubString ( strr , len ( strr ) ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countPrimePosition ( arr ) : NEW_LINE INDENT c0 = 0 NEW_LINE c1 = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 and isPrime ( i ) ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT if ( arr [ i ] == 1 and isPrime ( i ) ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT print ( " Number of 0s = " , c0 ) NEW_LINE print ( " Number of 1s = " , c1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 ] NEW_LINE countPrimePosition ( arr ) NEW_LINE DEDENT
def angleext cyc m i : NEW_LINE INDENT print ( " The exterior angle of the " , " cyclic quadrilateral is " , i , " degrees " ) NEW_LINE DEDENT z = 48 NEW_LINE angleext cyc m = i NEW_LINE
import sys NEW_LINE def printMinIndexChar ( str , patt ) : NEW_LINE INDENT minIndex = sys . maxsize ; NEW_LINE m = len ( str ) ; NEW_LINE n = len ( patt ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != sys . maxsize ) : NEW_LINE INDENT print ( " Minimum Index Character = " , str [ minIndex ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No character present " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " ; NEW_LINE patt = " set " ; NEW_LINE printMinIndexChar ( str , patt ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < b : NEW_LINE INDENT print ( " beautiful or x for x in range ( a , b + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " poor primes " ) NEW_LINE DEDENT DEDENT
def maxnumber ( n , k ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 1 NEW_LINE while ( n // i > 0 ) : NEW_LINE INDENT temp = ( n // ( i * 10 ) ) * i + ( n % i ) NEW_LINE i *= 10 NEW_LINE ans = max ( ans , temp ) NEW_LINE DEDENT n = ans NEW_LINE DEDENT return n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6358 NEW_LINE k = 1 NEW_LINE print ( maxnumber ( n , k ) ) NEW_LINE DEDENT
N , M = map ( int , input ( ) . split ( ) ) NEW_LINE AB = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE AB . append ( ( a , b ) ) NEW_LINE DEDENT AB = sorted ( AB , key = lambda x : ( - x [ 1 ] , x [ 0 ] ) ) NEW_LINE count = 0 NEW_LINE pb = AB [ 0 ] [ 1 ] NEW_LINE for a , b in AB [ 1 : ] : NEW_LINE INDENT if a >= pb : NEW_LINE INDENT count += 1 NEW_LINE pb = b NEW_LINE DEDENT DEDENT count += 1 NEW_LINE for a , b in AB [ 1 : ] : NEW_LINE INDENT if b >= pb : NEW_LINE INDENT count += 1 NEW_LINE pb = b NEW_LINE DEDENT DEDENT count += 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if count + 1 < pb : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if count + 1 < pb : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if count + 1 < pb : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if count + 1 < pb : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if count + 1 < pb : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if count + 1 < pb : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if count + 1 < pb : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i , count ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ans = float ( " Inf " ) NEW_LINE ary = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE total = sum ( ary ) NEW_LINE a = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a += ary [ i ] NEW_LINE total -= ary [ i ] NEW_LINE ans = min ( ans , a - total ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def get_last_two_digit ( N ) : NEW_LINE INDENT if ( N <= 10 ) : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT return ans % 100 NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 1 NEW_LINE for N in range ( 1 , 10 + 1 ) : NEW_LINE INDENT print ( " For N = " , N , " : " , get_last_two_digit ( N ) ) NEW_LINE DEDENT DEDENT
binaryNumber = "1001" NEW_LINE print ( int ( binaryNumber ) ) NEW_LINE
from math import ceil , floor NEW_LINE def isPossible ( x , y , z ) : NEW_LINE INDENT a = x * x + y * y + z * z NEW_LINE if ( ceil ( a ) == 1 and floor ( a ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 0.ire10678 NEW_LINE m = 0.5 NEW_LINE n = 0.5 NEW_LINE if ( isPossible ( l , m , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
MAX = 1000000 NEW_LINE MOD = 10000007 NEW_LINE result = [ 0 ] * ( MAX + 1 ) NEW_LINE fact = [ 0 ] * ( MAX + 1 ) NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) NEW_LINE ans = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT ans += ( a [ j ] - a [ j - 1 ] ) * ( j - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT def findMissingPositive ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT x = abs ( arr [ i ] ) NEW_LINE if ( x - 1 < size and arr [ x - 1 ] > 0 ) : NEW_LINE INDENT arr [ x - 1 ] = - arr [ x - 1 ] NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return size + 1 NEW_LINE DEDENT def findMissing ( arr , size ) : NEW_LINE INDENT shift = segregate ( arr , size ) NEW_LINE arr2 = [ 0 for i in range ( size - shift ) ] NEW_LINE j = 0 NEW_LINE for i in range ( shift , size ) : NEW_LINE INDENT arr2 [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT return findMissingPositive ( arr2 , j ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 0 , 10 , 2 , - 10 , - 20 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissing ( arr , arr_size ) NEW_LINE print ( " The smallest positive missing number is " , missing ) NEW_LINE DEDENT
mod = 1000000007 NEW_LINE def digitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT temp = digitNumber ( ( n - 1 ) // 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT DEDENT def count ex prison ( n , d ) : NEW_LINE INDENT if ( d == 0 ) : NEW_LINE INDENT return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT d = 9 NEW_LINE n = 3 NEW_LINE print ( count ex prison ( n , d ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = a [ 0 ] NEW_LINE y = a [ - 1 ] NEW_LINE if x > y : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , 2 , n ) NEW_LINE DEDENT DEDENT
def convert12 ( str1 ) : NEW_LINE INDENT h1 = ord ( str1 [ 0 ] ) - ord ( '0' ) NEW_LINE h2 = ord ( str1 [ 1 ] ) - ord ( '0' ) NEW_LINE hh = h1 * 10 + h2 NEW_LINE if ( hh < 12 ) : NEW_LINE INDENT Mer tmp = " AM " NEW_LINE DEDENT else : NEW_LINE INDENT tmp = " pm " NEW_LINE DEDENT hh %= 12 NEW_LINE if ( hh == 0 ) : NEW_LINE INDENT print ( "12" , end = " " ) NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( hh , end = " " ) NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( " " + merge12 ( str1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = "17 17 17 17 17 17 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19
def check ( s , k ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i % k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonDivisors ( a , b ) : NEW_LINE INDENT ct = 0 NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE for i in range ( 1 , min ( n , m ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 and m % i == 0 ) : NEW_LINE INDENT if ( a [ 0 : i ] == b [ 0 : i ] ) : NEW_LINE INDENT if ( check ( a , i ) and check ( b , i ) ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = " xaxa " NEW_LINE b = " xaxaxa " NEW_LINE print ( countCommonDivisors ( a , b ) ) NEW_LINE DEDENT
def print knapSack ( W , wt , val , n ) : NEW_LINE INDENT i , w = 0 , 0 NEW_LINE K = [ [ 0 for i in range ( W + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if ( i == 0 or w == 0 ) : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif ( wt [ i - 1 ] <= w ) : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE print ( res ) NEW_LINE w = W NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( res == K [ i - 1 ] [ w ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] , end = " " ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE print knapSack ( W , wt , val , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = input ( ) NEW_LINE x , y = list ( map ( int , line . split ( ) ) ) NEW_LINE if x == y : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def D D D D D index ( arr , n , k ) : NEW_LINE INDENT elements = [ 0 ] * 20 NEW_LINE indices = [ 0 ] * 20 NEW_LINE j , ind , start , end = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ ind ] = arr [ i ] NEW_LINE indices [ ind ] = i NEW_LINE ind += 1 NEW_LINE DEDENT if ( k < elements [ 0 ] ) : NEW_LINE INDENT print ( " Not found " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , ind + 1 ) : NEW_LINE INDENT if ( k < elements [ i ] ) : NEW_LINE INDENT start = indices [ i - 1 ] NEW_LINE end = indices [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( k == arr [ i ] ) : NEW_LINE INDENT j = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == 1 ) : NEW_LINE INDENT print ( " Found at index " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not found " ) NEW_LINE DEDENT DEDENT arr = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 8 NEW_LINE D index ( arr , n , k ) NEW_LINE
def larr BIG_Pindrome ( n ) : NEW_LINE INDENT upper_limit = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT upper_limit *= 10 NEW_LINE upper_limit += 9 NEW_LINE DEDENT lower_limit = 1 + int ( upper_limit / 10 ) NEW_LINE max_product = 0 NEW_LINE for i in range ( upper_limit , lower_limit + 1 ) : NEW_LINE INDENT for j in range ( i , lower_limit + 1 ) : NEW_LINE INDENT product = i * j NEW_LINE if ( product < max_product ) : NEW_LINE INDENT break NEW_LINE DEDENT number = product NEW_LINE reverse = 0 NEW_LINE while ( number != 0 ) : NEW_LINE INDENT reverse = reverse * 10 + number % 10 NEW_LINE number = int ( number / 10 ) NEW_LINE DEDENT if ( product == reverse and product > max_product ) : NEW_LINE INDENT max_product = product NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT n = 2 NEW_LINE print ( larr BIG_Pindrome ( n ) ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE L = { } NEW_LINE for a in A : NEW_LINE INDENT if a not in L : NEW_LINE INDENT L [ a ] = L [ a ] NEW_LINE L [ a ] = L [ a ] NEW_LINE DEDENT elif L [ a ] < a : NEW_LINE INDENT L [ a ] = L [ a ] NEW_LINE L [ a ] = L [ a ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if L [ i ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l = [ int ( i ) for i in input ( ) . split ( " " ) ] NEW_LINE if min ( l [ 0 ] , l [ 1 ] , l [ 2 ] ) == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif min ( l [ 0 ] , l [ 1 ] , l [ 2 ] ) == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT max = max ( l [ 0 ] , l [ 1 ] ) NEW_LINE min = min ( l [ 0 ] , l [ 1 ] ) NEW_LINE l [ 0 ] -= max NEW_LINE l [ 1 ] -= min NEW_LINE l [ 2 ] -= max NEW_LINE if max > min : NEW_LINE INDENT print ( max ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if i == n - 1 : NEW_LINE INDENT ans = max ( ans , abs ( a [ i ] - a [ i + 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , abs ( a [ i ] - a [ i + 1 ] ) - abs ( a [ i ] - a [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def maximumXor ( arr , n ) : NEW_LINE INDENT sForward = [ ] NEW_LINE sBackward = [ ] NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( sForward ) != 0 and arr [ i ] < arr [ sForward [ - 1 ] ] ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] ^ arr [ sForward [ - 1 ] ] ) NEW_LINE sForward . pop ( ) NEW_LINE DEDENT sForward . append ( i ) NEW_LINE while ( len ( sBackward ) != 0 and arr [ n - i - 1 ] < arr [ sBackward [ - 1 ] ] ) : NEW_LINE INDENT ans = max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward [ - 1 ] ] ) NEW_LINE sForward . pop ( ) NEW_LINE DEDENT sForward . append ( n - i - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 8 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maximumXor ( arr , n ) ) NEW_LINE
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ ' ' ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = n % 16 ; NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT n = n // 16 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( hexaDeciNum [ j ] , end = " " ) ; NEW_LINE DEDENT DEDENT n = 2545 ; NEW_LINE decToHexa ( n ) ; NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = { } NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = a [ i ] NEW_LINE if k in b : NEW_LINE INDENT b [ k ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ k ] = 1 NEW_LINE DEDENT ans = max ( ans , k ) NEW_LINE DEDENT print ( ans ) NEW_LINE
while 1 : NEW_LINE INDENT r , c = map ( int , input ( ) . split ( ) ) NEW_LINE if r == 0 : break NEW_LINE a = [ input ( ) for _ in range ( r ) ] NEW_LINE b = [ input ( ) for _ in range ( c ) ] NEW_LINE d = { } NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT if b [ i ] [ j ] == ' _ ' : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT d [ i ] = j NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = j NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( c ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT if b [ i ] [ j ] == ' _ ' : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT d [ i ] = j NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = j NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in d : NEW_LINE INDENT ans += abs ( i - 1 ) + abs ( c - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( " Hello World " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a + b ) NEW_LINE DEDENT
def extractMaximum ( str ) : NEW_LINE INDENT num = 0 NEW_LINE res = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] . isDigit ( ) : NEW_LINE INDENT num = num * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , num ) NEW_LINE num = 0 NEW_LINE DEDENT DEDENT return max ( res , num ) NEW_LINE DEDENT str = "100klh564abc365bg " NEW_LINE print ( extractMaximum ( str ) ) NEW_LINE
max = 50009 NEW_LINE def find_Indices ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * max NEW_LINE index_1 , index_2 , index_3 , index = 1 , 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ k ] NEW_LINE k += 1 NEW_LINE DEDENT ans = - ( 1e15 ) NEW_LINE index_1 , index_2 , index_3 = - 1 , - 1 , - 1 NEW_LINE for l in range ( n + 1 ) : NEW_LINE INDENT index = 0 NEW_LINE vmin = float ( 1e15 ) NEW_LINE for r in range ( l , n + 1 ) : NEW_LINE INDENT if ( sum [ r ] < vmin ) : NEW_LINE INDENT vmin = sum [ r ] NEW_LINE index = r NEW_LINE DEDENT if ( sum [ l ] + sum [ r ] - vmin > ans ) : NEW_LINE INDENT ans = sum [ l ] + sum [ r ] - vmin NEW_LINE index_1 = l NEW_LINE index_2 = index NEW_LINE index_3 = r NEW_LINE DEDENT DEDENT print ( index_1 , index_2 , index_3 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE find_Indices ( arr , n ) NEW_LINE DEDENT
def printElements ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printElements ( arr , n ) NEW_LINE DEDENT
def valueofX ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ar [ i ] NEW_LINE DEDENT if ( sum % n == 0 ) : NEW_LINE INDENT return sum // n NEW_LINE DEDENT else : NEW_LINE INDENT A = sum // n NEW_LINE B = sum // n + 1 NEW_LINE ValueA = 0 NEW_LINE ValueB = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) NEW_LINE ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) NEW_LINE DEDENT if ( ValueA < ValueB ) : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT return B NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE arr = [ 6 , 9 , 1 , 6 , 1 , 3 , 7 ] NEW_LINE print ( valueofX ( arr , n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , l = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT c = bin ( a [ i ] ) [ 2 : ] NEW_LINE ans = [ int ( c ) ] + ans NEW_LINE for j in range ( l ) : NEW_LINE INDENT c = bin ( a [ j ] ) [ 2 : ] NEW_LINE ans . append ( int ( c ) ) NEW_LINE DEDENT DEDENT ans = ans [ : : - 1 ] NEW_LINE print ( * ans , sep = " " ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import functools NEW_LINE import copy NEW_LINE import heapq NEW_LINE import decimal NEW_LINE import statistics NEW_LINE import queue NEW_LINE sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = 10 ** 16 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE ni = lambda : int ( sys . stdin . readline ( ) ) NEW_LINE ns = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE na = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT s = list ( input ( ) ) NEW_LINE s . reverse ( ) NEW_LINE l = len ( s ) NEW_LINE ans = l // 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if s [ i ] == s [ l - i - 1 ] : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 19 NEW_LINE while ( curr < 9 ) : NEW_LINE INDENT sum = 0 NEW_LINE x = curr NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT curr += 1 NEW_LINE DEDENT DEDENT print ( findNth ( 5 ) ) NEW_LINE
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 1 NEW_LINE while ( curr <= n ) : NEW_LINE INDENT sum = 0 NEW_LINE x = curr NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT curr += 1 NEW_LINE DEDENT DEDENT print ( findNth ( 5 ) ) NEW_LINE
def countNumber ( N , S ) : NEW_LINE INDENT countElements = 0 NEW_LINE currSum = 0 NEW_LINE while ( currSum <= S ) : NEW_LINE INDENT currSum += N NEW_LINE N -= 1 NEW_LINE countElements += 1 NEW_LINE DEDENT return countElements NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , S = 5 , 11 NEW_LINE count = countNumber ( N , S ) NEW_LINE print ( count ) NEW_LINE DEDENT
def strmatch ( str , pattern , n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return ( n == 0 ) NEW_LINE DEDENT lookup = [ [ 0 for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE lookup [ 0 ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ j - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ 0 ] [ j ] = lookup [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ j - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ i ] [ j ] = ( lookup [ i ] [ j - 1 ] or lookup [ i - 1 ] [ j ] ) NEW_LINE DEDENT elif ( pattern [ j - 1 ] == ' ? ' or str [ i - 1 ] == pattern [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return lookup [ n ] [ m ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " baaabab " NEW_LINE pattern = " * * * * * ba * * * * * * * ab " NEW_LINE if ( strmatch ( str , pattern , len ( str ) , len ( pattern ) ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE def is_prime ( x ) : NEW_LINE INDENT if x < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 , int ( x ** 0.5 ) + 1 ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT def is_prime ( x ) : NEW_LINE INDENT if x < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 , int ( x ** 0.5 ) + 1 ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT def solve ( a , b ) : NEW_LINE INDENT if is_prime ( a ) : NEW_LINE INDENT return [ ' a ' , ' b ' ] NEW_LINE DEDENT m = len ( a ) NEW_LINE l = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT if a [ i ] == '1' : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if b [ i ] == '1' : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT DEDENT o = [ ] NEW_LINE c = [ ] NEW_LINE r = 0 NEW_LINE while True : NEW_LINE INDENT if l [ 0 ] == l [ 1 ] : NEW_LINE INDENT o . append ( l [ 0 ] ) NEW_LINE l . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT c . append ( l [ 1 ] ) NEW_LINE DEDENT if l [ 0 ] == l [ 1 ] : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT o . sort ( reverse = True ) NEW_LINE for i in range ( r ) : NEW_LINE INDENT p = l [ i ] NEW_LINE if is_prime ( p ) : NEW_LINE INDENT c . append ( ' a ' ) NEW_LINE DEDENT else : NEW_LINE INDENT c . append ( ' b ' ) NEW_LINE DEDENT DEDENT return o NEW_LINE DEDENT while True : NEW_LINE INDENT a , b = map ( int , input (
def nCr ( n , r ) : NEW_LINE INDENT fac = [ 1 ] * 100 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT ans = fac [ n ] // ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 3 , 3 NEW_LINE ans = ( nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT b . append ( abs ( a [ n - 1 ] - a [ i ] * 2 ) ) NEW_LINE DEDENT print ( a [ - 1 ] , * b ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def powGCD ( a , n , b ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a = a * a ; NEW_LINE DEDENT return gcd ( a , b ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10 ; b = 5 ; n = 2 ; NEW_LINE print ( powGCD ( a , n , b ) ) ; NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE counter = defaultdict ( int ) NEW_LINE for a in A : NEW_LINE INDENT counter [ a ] += 1 NEW_LINE DEDENT A = counter . values ( ) NEW_LINE counter = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT counter [ A [ i ] ] += 1 NEW_LINE DEDENT answer = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer . append ( counter [ A [ i ] ] ) NEW_LINE DEDENT answer . reverse ( ) NEW_LINE print ( * answer ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '8' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans // 11 ) NEW_LINE
def sumOfDigit ( n , b ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 50 NEW_LINE b = 2 NEW_LINE print ( sumOfDigit ( n , b ) ) NEW_LINE DEDENT
import math NEW_LINE def printLargestDivisible ( n , a ) : NEW_LINE INDENT c0 = 0 NEW_LINE c5 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c5 += 1 NEW_LINE DEDENT DEDENT c5 = int ( math . floor ( c5 / 9 ) ) * 9 NEW_LINE if ( c0 == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif ( c5 == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( c5 ) : NEW_LINE INDENT print ( 5 ) NEW_LINE DEDENT for i in range ( c0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 5 , 5 , 5 , 5 , 5 , 0 , 5 , 5 ] NEW_LINE n = len ( a ) NEW_LINE printLargestDivisible ( n , a ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE
def numberOfMinutes ( S , S1 ) : NEW_LINE INDENT Min = 0 NEW_LINE Min = ( ( S - S1 ) // // 60 ) * 60 NEW_LINE return Min NEW_LINE DEDENT S = 30 NEW_LINE S1 = 10 NEW_LINE print ( numberOfMinutes ( S , S1 ) , " min " ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] - 1 ) NEW_LINE DEDENT b . sort ( reverse = True ) NEW_LINE i = 0 NEW_LINE t = 0 NEW_LINE while k > 0 and i < n : NEW_LINE INDENT k -= 1 NEW_LINE i += 1 NEW_LINE t += b [ i ] NEW_LINE DEDENT print ( t ) NEW_LINE
from math import floor NEW_LINE def onesComplement ( n ) : NEW_LINE INDENT number_of_bits = floor ( log2 ( n ) ) + 1 NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ n NEW_LINE DEDENT n = 22 NEW_LINE print ( onesComplement ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = l [ 0 ] NEW_LINE y = l [ 1 ] NEW_LINE z = l [ 2 ] NEW_LINE if y <= x and y <= y : NEW_LINE INDENT while y % 2 == 0 and x % 2 == 0 : NEW_LINE INDENT y = y // 2 NEW_LINE x = x // 2 NEW_LINE DEDENT while z % 2 == 0 and x % 2 == 0 : NEW_LINE INDENT x = x // 2 NEW_LINE z = x // 2 NEW_LINE DEDENT if z >= n : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( " ( " + str ( 2 * x2 - x1 ) + " , " + str ( 2 * y2 - y1 ) + " ) " ) NEW_LINE DEDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 1 NEW_LINE y2 = 1 NEW_LINE findPoint ( x1 , y1 , x2 , y2 ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif m == 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( m - 1 ) - max ( abs ( m - 1 ) , abs ( n - m ) ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if m % 2 == 0 : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT if m == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT elif m % 2 == 1 : NEW_LINE INDENT if n == 2 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def alter ( x , y ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT if ( x == 0 or y == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( x >= 2 * y ) : NEW_LINE INDENT x = x % ( 2 * y ) NEW_LINE DEDENT elif ( y >= 2 * x ) : NEW_LINE INDENT y = y % ( 2 * x ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " X = " , x , " , " , " Y = " , y ) NEW_LINE DEDENT x = 12 NEW_LINE y = 5 NEW_LINE alter ( x , y ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE ans = 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT while a [ j ] - a [ i ] > 2 : NEW_LINE INDENT a [ j ] += 1 NEW_LINE DEDENT ans = max ( ans , j - i + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = [ ] NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if s [ i ] != s [ i + 1 ] : NEW_LINE INDENT ans . append ( i + 1 ) NEW_LINE i += 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( - 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT if len ( ans ) == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * ans ) NEW_LINE DEDENT DEDENT
mod = 1000000007 NEW_LINE inv2 = 50000000 NEW_LINE def modulo ( num ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + ( ord ( num [ i ] ) - ord ( '0' ) ) ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT def findSum ( L , R ) : NEW_LINE INDENT a = modulo ( L ) NEW_LINE b = modulo ( R ) NEW_LINE l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod NEW_LINE r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod NEW_LINE ret = ( r % mod - l % mod ) NEW_LINE if ( ret < 0 ) : NEW_LINE INDENT ret = ret + mod NEW_LINE DEDENT else : NEW_LINE INDENT ret = ret % mod NEW_LINE DEDENT return ret NEW_LINE DEDENT L = "88949273204" NEW_LINE R = "98429474298592" NEW_LINE print ( findSum ( L , R ) ) NEW_LINE
def unsort ( l , r , a , k ) : NEW_LINE INDENT if ( k < 1 or l + 1 == r ) : NEW_LINE INDENT return NEW_LINE DEDENT k -= 2 NEW_LINE mid = ( l + r ) // 2 NEW_LINE temp = a [ mid - 1 ] NEW_LINE a [ mid - 1 ] = a [ mid ] NEW_LINE a [ mid ] = temp NEW_LINE unsort ( l , mid , a , k ) NEW_LINE unsort ( mid , r , a , k ) NEW_LINE DEDENT def arrayWithKCalls ( n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT print ( " NO Solution Solution " ) NEW_LINE return NEW_LINE DEDENT a = [ 0 ] * ( n + 1 ) NEW_LINE a [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = i + 1 NEW_LINE DEDENT k -= 1 NEW_LINE unsort ( 0 , n , a , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE k = 17 NEW_LINE arrayWithKCalls ( n , k ) NEW_LINE DEDENT
import math NEW_LINE def mean ( mid , freq , n ) : NEW_LINE INDENT sum = 0 NEW_LINE freqSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + mid [ i ] * freq [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT return sum / freqSum NEW_LINE DEDENT def groupedSD ( lower_limit , upper_limit , freq , n ) : NEW_LINE INDENT mid = [ None ] * n NEW_LINE sum = 0 NEW_LINE freqSum = 0 NEW_LINE sd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 NEW_LINE sum = sum + mid [ i ] * mid [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT sd = math . sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) NEW_LINE return sd NEW_LINE DEDENT lower_limit = [ 50 , 61 , 71 , 86 , 96 ] NEW_LINE upper_limit = [ 60 , 70 , 85 , 95 , 100 ] NEW_LINE freq = [ 9 , 7 , 9 , 12 , 8 ] NEW_LINE n = len ( lower_limit ) NEW_LINE print ( groupedSD ( lower_limit , upper_limit , freq , n ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE DEDENT
def rectanglearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( rectanglearea ( a , b ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if n > a : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif n == a : NEW_LINE INDENT if b == n : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT elif b // ( a - a ) >= n : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def getsum ( x ) : NEW_LINE INDENT return ( x * ( x + 1 ) ) // 2 NEW_LINE DEDENT def countJumps ( n ) : NEW_LINE INDENT n = abs ( n ) NEW_LINE ans = 0 NEW_LINE while ( getsum ( ans ) < n or ( ( getsum ( ans ) - n ) & 1 ) > 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 9 NEW_LINE print ( countJumps ( n ) ) NEW_LINE DEDENT
MAX = 10 NEW_LINE def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if ( k < 0 ) : NEW_LINE INDENT return - 10000000 NEW_LINE DEDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT try : NEW_LINE INDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE return ans NEW_LINE DEDENT except Exception : NEW_LINE INDENT return ans NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 1 NEW_LINE arr1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE arr2 = [ 5 , 3 , 1 , 4 , 2 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE dp = [ [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX ) ] for k in range ( MAX ) ] NEW_LINE print ( lcs ( dp , arr1 , n , arr2 , m , k ) ) NEW_LINE
n , d , x = map ( int , input ( ) . split ( ) ) NEW_LINE i = 0 NEW_LINE while n > 1 : NEW_LINE INDENT d , x = ( d + x ) / 2 , ( x - 1 ) / 2 NEW_LINE i += 1 NEW_LINE n -= 1 NEW_LINE DEDENT print ( i ) NEW_LINE
def reverseorder ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for i in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT N = 25 NEW_LINE print ( " Prime number in reverse order " ) NEW_LINE if ( N == 1 ) : NEW_LINE INDENT print ( " No prime no exist in this range " ) NEW_LINE DEDENT else : NEW_LINE INDENT reverseorder ( N ) NEW_LINE DEDENT
def pattern ( min_stars , p_height ) : NEW_LINE INDENT p_space = p_height - 1 NEW_LINE x = 1 NEW_LINE for i in range ( p_height ) : NEW_LINE INDENT for j in range ( p_space , i , - 1 ) : NEW_LINE INDENT print ( " " , end = " " ) NEW_LINE DEDENT for k in range ( min_stars ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT for n in range ( p_height + p_height - 2 , - 1 , - 1 ) : NEW_LINE INDENT print ( " " , end = " " ) NEW_LINE DEDENT for k in range ( min_stars ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT min_stars = min_stars + 2 NEW_LINE x = x + 2 NEW_LINE print ( " " ) NEW_LINE DEDENT min_stars = 1 NEW_LINE p_height = 5 NEW_LINE pattern ( min_stars , p_height ) NEW_LINE
n = int ( input ( ) ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sy , inp = input ( ) . split ( ) NEW_LINE inp = int ( inp ) NEW_LINE if sy == " M " : NEW_LINE INDENT res = max ( res , inp - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , inp - 1 ) NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE
from math import sqrt NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return round ( pow ( phi , n ) / sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT def sumFibonacci ( k ) : NEW_LINE INDENT l = ( k * ( k - 1 ) ) / 2 NEW_LINE r = l + k NEW_LINE sum = calculateSum ( l , r - 1 ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = 3 NEW_LINE print ( sumFibonacci ( k ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return round ( pow ( phi , n ) / sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 4 NEW_LINE r = 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return round ( pow ( phi , n ) / sqrt ( 5 ) ) NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , r = 4 , 8 NEW_LINE print ( calculateSum ( l , r ) ) NEW_LINE DEDENT
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE s1 = s [ : n ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE c1 , c2 = s [ l - 1 : r ] , s [ l - 1 : l ] NEW_LINE if c1 == c2 : NEW_LINE INDENT s1 = s [ l - 1 : l ] NEW_LINE DEDENT else : NEW_LINE INDENT s1 = s [ l - 1 : l ] + c1 NEW_LINE DEDENT DEDENT print ( * s1 , sep = " " ) NEW_LINE
def compareStrings ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( str1 ) - 1 and str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( str1 [ i ] > str2 [ i ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( str1 [ i ] < str2 [ i ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def searchStr ( arr , str , first , last ) : NEW_LINE INDENT if ( first > last ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( last + first ) // 2 NEW_LINE if ( arr [ mid ] . isEmpty ( ) ) : NEW_LINE INDENT left = mid - 1 NEW_LINE right = mid + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( left < right and right > last ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( right <= last and not arr [ right ] . isEmpty ( ) ) : NEW_LINE INDENT mid = right NEW_LINE break NEW_LINE DEDENT if ( left >= right and not arr [ left ] . isEmpty ( ) ) : NEW_LINE INDENT mid = left NEW_LINE break NEW_LINE DEDENT right += 1 NEW_LINE left -= 1 NEW_LINE DEDENT DEDENT if ( compareStrings ( str , arr [ mid ] ) == 0 ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( compareStrings ( str , arr [ mid ] ) < 0 ) : NEW_LINE INDENT return searchStr ( arr , str , mid + 1 , last ) NEW_LINE DEDENT return searchStr ( arr , str , first , mid - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ " for " , " , " , " , " geeks " , " ide " , " " , " practice " , " " , " " , "q " , " 101 " , " " ] NEW_LINE str = " 101 101 " NEW_LINE n = len ( arr ) NEW_LINE print ( searchStr ( arr , str , 0 , n - 1 ) ) NEW_LINE DEDENT
def toNum ( lis ) : NEW_LINE INDENT ret = 0 NEW_LINE for i in range ( len ( lis ) ) : NEW_LINE INDENT ret += lis [ - i - 1 ] * 10 ** i NEW_LINE DEDENT return ret NEW_LINE DEDENT def solve ( list , n ) : NEW_LINE INDENT c = 0 NEW_LINE i = 0 NEW_LINE digit = 1 NEW_LINE while i + digit <= n : NEW_LINE INDENT c += i NEW_LINE digit = int ( str ( c ) + str ( digit ) ) NEW_LINE i += 1 NEW_LINE DEDENT return toNum ( list , n ) NEW_LINE DEDENT a , b = input ( ) . split ( ) NEW_LINE print ( solve ( int ( a ) , int ( b ) ) ) NEW_LINE
x1 , y1 , x2 , y2 , x3 , y3 = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ x1 , x2 , x3 , x3 ] NEW_LINE l . sort ( ) NEW_LINE print ( l [ 0 ] + l [ 1 ] - x3 , l [ 2 ] - l [ 1 ] , l [ 3 ] - l [ 2 ] ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE a = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . add ( s [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b = a . copy ( ) NEW_LINE b . sort ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if b [ j ] == a [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) NEW_LINE return ( n ) * ( 1 + n ) * d // 2 NEW_LINE DEDENT def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE return ( sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 20 NEW_LINE print ( sumMultiples ( n ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s , f = map ( int , input ( ) . split ( ) ) NEW_LINE c += f - s NEW_LINE DEDENT print ( ' OK ' if c <= c else c ) NEW_LINE DEDENT
def fact ( num ) : NEW_LINE INDENT fact = 1 NEW_LINE while ( num > 1 ) : NEW_LINE INDENT fact *= num NEW_LINE num -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT return fact ( 2 * n ) // ( fact ( n ) * fact ( n + 1 ) ) NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE for k in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ k ] ) : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT catalan_leftBST = catalan ( s ) NEW_LINE catalan_rightBST = catalan ( n - s - 1 ) NEW_LINE totalBST = catalan_rightBST * catalan_leftBST NEW_LINE print ( totalBST , end = " " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE if l - r == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if l [ 0 ] > l [ 1 ] or l [ 1 ] > l [ 0 ] : NEW_LINE INDENT print ( l [ 0 ] - l [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if l [ 0 ] % 2 == 0 or l [ 1 ] % 2 == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT
def countWays ( n , arr , Len ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in range ( Len ) : NEW_LINE INDENT if ( i - arr [ j ] >= 0 ) : NEW_LINE INDENT no_ways += count [ i - arr [ j ] ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 5 ] NEW_LINE Len = len ( arr ) NEW_LINE n = 5 NEW_LINE print ( countWays ( n , arr , Len ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ 0 ] * 12 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b , c = map ( int , input ( ) . split ( ) ) NEW_LINE a [ i ] = b - c NEW_LINE DEDENT f = False NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT if a [ i ] >= n : NEW_LINE INDENT f = True NEW_LINE print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b and b == c : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( abs ( a - b ) , abs ( b - c ) , abs ( c - a ) + abs ( a - b ) - 4 ) ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE b , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b : NEW_LINE INDENT if a [ i ] > b : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT elif a [ i ] < b : NEW_LINE INDENT if a [ i ] > b : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE key = 10 NEW_LINE print ( " Index : " , binarySearch ( arr , 0 , n , key ) ) NEW_LINE
def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE Xor = Xor ^ arr [ i ] NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 3 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE equal_xor_sum ( arr , n ) NEW_LINE DEDENT
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = { } NEW_LINE for i in range ( m ) : NEW_LINE INDENT b [ a [ i ] ] = 1 NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT c = input ( ) NEW_LINE if c [ b [ c [ 0 ] ] ] == 1 : NEW_LINE INDENT print ( b [ c [ 0 ] ] ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( b [ c [ 0 ] ] ) NEW_LINE
def findPairs ( arr , n ) : NEW_LINE INDENT cntEven = 0 ; cntOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 ; NEW_LINE DEDENT DEDENT evenPairs = 0 ; NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) // 2 ) ; NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) // 2 ) ; NEW_LINE oddPairs = 0 ; NEW_LINE oddPairs += ( cntEven * cntOdd ) ; NEW_LINE print ( " Odd pairs = " , oddPairs ) ; NEW_LINE print ( " Even pairs = " , evenPairs ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findPairs ( arr , n ) ; NEW_LINE DEDENT
def min mp mp ( houses , towers ) : NEW_LINE INDENT n = len ( houses ) NEW_LINE m = len ( towers ) NEW_LINE leftTower = - 2147483648 NEW_LINE rightTower = towers [ 0 ] NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE min_range = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( houses [ j ] < rightTower ) : NEW_LINE INDENT left = houses [ j ] - leftTower NEW_LINE right = rightTower - houses [ j ] NEW_LINE if ( left < right ) : NEW_LINE INDENT min_range = left NEW_LINE DEDENT if ( min_max > right ) : NEW_LINE INDENT min_range = right NEW_LINE DEDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT leftTower = towers [ k ] NEW_LINE if ( k < m - 1 ) : NEW_LINE INDENT k += 1 NEW_LINE rightTower = towers [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT rightTower = towers [ k ] NEW_LINE DEDENT DEDENT DEDENT return min_range NEW_LINE DEDENT a = [ 12 , 13 , 11 , 80 ] NEW_LINE b = [ 4 , 6 , 15 , 60 ] NEW_LINE print ( min mp ( a , b ) ) NEW_LINE
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( getRemainder ( 100 , 7 ) ) NEW_LINE DEDENT
n , m , z = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( m , z + 1 ) : NEW_LINE INDENT if i > n : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( n , z + 1 ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == n == 0 : break NEW_LINE a = [ 0 ] + [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE b = [ 0 ] + [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i > m : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( ) : NEW_LINE INDENT n , w = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE inf = float ( ' inf ' ) NEW_LINE dist = [ inf ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT vi , wi = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE dist [ vi ] = min ( dist [ vi ] , wi ) NEW_LINE DEDENT ans = 0 NEW_LINE wi = w NEW_LINE while wi > 0 : NEW_LINE INDENT if wi <= w : NEW_LINE INDENT ans += 1 NEW_LINE wi -= w NEW_LINE if wi == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans += 1 + wi * ( w / wi ) NEW_LINE wi = wi - wi * ( w / wi ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE common_bit_mask = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT arr = [ 3 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The element with single occurrence is " , getSingle ( arr , n ) ) NEW_LINE
def maxdiff ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) NEW_LINE DEDENT elif ( freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 1 , 3 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxdiff ( arr , n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT arr [ i ] = 0 - arr [ i ] NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT if ans % 2 == 0 : NEW_LINE INDENT ans -= arr [ 0 ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def makeAP ( arr , n ) : NEW_LINE INDENT if n == 3 : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) // 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( initial_term + ( i * common_difference ) , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def longestPalindrome ( self , s ) : NEW_LINE INDENT count = [ 0 ] * 128 NEW_LINE for c in s : NEW_LINE INDENT count [ ord ( c ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for v in count : NEW_LINE INDENT ans += v // 2 * 2 NEW_LINE if ( ans % 2 == 0 and v % 2 == 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = " abccdd " NEW_LINE out = sObj . longestPalindrome ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT def findWays ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return catalan ( n // 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( " Total possible expression of length " , n , " is " , findWays ( 6 ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " X " : NEW_LINE INDENT ans . append ( " 1x12" ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( " 12x1" ) NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE for j in range ( 2 , 6 ) : NEW_LINE INDENT if ( 12 % j == 0 ) : NEW_LINE INDENT for k in range ( 1 , 12 // j ) : NEW_LINE INDENT if ( ans [ j ] == " O " ) : NEW_LINE INDENT ans . append ( j + " x " + 12 // j ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for k in range ( 1 , 12 ) : NEW_LINE INDENT if ( ans [ j ] == " O " ) : NEW_LINE INDENT ans . append ( j + " x " + 12 // j ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if len ( ans ) == 0 : NEW_LINE INDENT print ( * ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * ans ) NEW_LINE DEDENT
import math NEW_LINE n , t , a , b , ta , tb = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT for j in range ( t ) : NEW_LINE INDENT if i * ta + j * tb == n : NEW_LINE INDENT print ( " YES " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT DEDENT print ( " NO " ) NEW_LINE
def isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE if ( isSumOfPowersOfTwo ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT s = [ ] NEW_LINE if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 10 + 1 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE print ( countNumber ( n ) ) NEW_LINE
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 6 , 5 , 4 ] , [ 7 , 3 , 9 ] ] NEW_LINE print ( maxAverageOfPath ( cost , 3 ) ) NEW_LINE
MAX = 1000000 NEW_LINE sieve_Prime = [ 0 ] * ( MAX + 4 ) NEW_LINE sieve_count = [ 0 ] * ( MAX + 4 ) NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( sieve_Prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if ( sieve_Prime [ j ] == 0 ) : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( " Count = " , sieve_count [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count = " , sieve_count [ n ] + 1 ) NEW_LINE
n , k , t , u , v , l = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE pos = 0 NEW_LINE tot = 0 NEW_LINE count = 0 NEW_LINE while pos < l : NEW_LINE INDENT if pos >= d [ - 1 ] : NEW_LINE INDENT pos += t * v NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = d [ - 1 ] NEW_LINE tot += ( pos - 1 ) / v NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( tot ) NEW_LINE
def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE prefix = [ 0 ] * n NEW_LINE suffix = [ 0 ] * n NEW_LINE seen = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = 0 NEW_LINE if ( i - 1 >= 0 ) : NEW_LINE INDENT prev = prefix [ i - 1 ] NEW_LINE DEDENT if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT seen [ i ] = 0 NEW_LINE DEDENT suffix [ n - 1 ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev NEW_LINE seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ababa " NEW_LINE print ( waysToSplit ( s ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT TURNS = 15 NEW_LINE ways = [ [ 0 ] * ( TURNS + 1 ) for i in range ( TURNS + 1 ) ] NEW_LINE for i in range ( 1 , TURNS + 1 ) : NEW_LINE INDENT ways [ i ] = [ i + 1 ] * ( i + 1 ) NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT temp = 0 NEW_LINE if j < i : NEW_LINE INDENT temp = ( ways [ i - 1 ] [ j ] + ways [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT temp = ( temp + ways [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT ways [ i ] [ j ] = temp NEW_LINE DEDENT DEDENT numer = 0 NEW_LINE for i in range ( TURNS // 2 + 1 , TURNS + 1 ) : NEW_LINE INDENT numer = numer + ways [ TURNS ] [ i ] NEW_LINE DEDENT denom = eulerlib . factorial ( TURNS + 1 ) NEW_LINE return str ( denom // numer ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE r = [ ] NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT r . append ( a [ i ] ) NEW_LINE ans . append ( i ) NEW_LINE DEDENT ans . append ( 1 ) NEW_LINE st = [ ] NEW_LINE np = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT st . append ( i ) NEW_LINE np = set ( ans ) NEW_LINE DEDENT DEDENT st . reverse ( ) NEW_LINE if np == set ( ans ) : NEW_LINE INDENT print ( len ( ans ) ) NEW_LINE print ( * ans , sep = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT if np == 1 : NEW_LINE INDENT ans [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT st = [ ] NEW_LINE np = set ( ans ) NEW_LINE DEDENT st . reverse ( ) NEW_LINE if np == 1 : NEW_LINE INDENT ans = st [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT st = [ ] NEW_LINE DEDENT st . append ( st [ : - 1 ] ) NEW_LINE np = set ( ans ) NEW_LINE st . append ( st [ 1 : ] ) NEW_LINE DEDENT ans = st [ : - 1 ] NEW_LINE print ( * ans , sep = " " ) NEW_LINE
def merge ( m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = arr1 [ m - 1 ] NEW_LINE for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT arr1 [ j + 1 ] = arr1 [ j ] NEW_LINE DEDENT if j != m - 2 or last > arr2 [ i ] : NEW_LINE INDENT arr1 [ j + 1 ] = arr2 [ i ] NEW_LINE arr2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] NEW_LINE arr2 = [ 2 , 3 , 8 , 13 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE merge ( n , m ) NEW_LINE print ( " After Merging \n First Array : " ) NEW_LINE print ( arr1 ) NEW_LINE print ( " Second Array : " ) NEW_LINE print ( arr2 ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def sameRemainder ( a , b , c ) : NEW_LINE INDENT a1 = ( b - a ) NEW_LINE b1 = ( c - b ) NEW_LINE c1 = ( c - a ) NEW_LINE return gcd ( a1 , gcd ( b1 , c1 ) ) NEW_LINE DEDENT a = 62 NEW_LINE b = 132 NEW_LINE c = 237 NEW_LINE print ( sameRemainder ( a , b , c ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( abs ( a - c ) , abs ( b - d ) , abs ( c - d ) ) ) NEW_LINE
dp = [ [ [ - 1 for i in range ( 5001 ) ] for j in range ( 5001 ) ] for k in range ( 5001 ) ] NEW_LINE def countWaysUtil ( n , parts , nextPart ) : NEW_LINE INDENT if ( parts == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 or parts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , parts - 1 , i ) NEW_LINE DEDENT dp [ n ] [ nextPart ] [ parts ] = ans NEW_LINE return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT for i in range ( 5001 ) : NEW_LINE INDENT for j in range ( 5001 ) : NEW_LINE INDENT for l in range ( 5 ) : NEW_LINE INDENT dp [ i ] [ j ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT
def find_k ( a , b ) : NEW_LINE INDENT if ( ( a + b ) % 2 == 0 ) : NEW_LINE INDENT return ( ( a + b ) // 2 ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = 2 , 16 NEW_LINE print ( find_k ( a , b ) ) NEW_LINE DEDENT
N = 101 NEW_LINE mod = 1000000007 NEW_LINE exactsum = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE exactnum = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE exactnum [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k ] % mod NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] % mod NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y , z = 1 , 1 , 1 NEW_LINE print ( getSum ( x , y , z ) % mod ) NEW_LINE DEDENT
CHARS = 26 ; NEW_LINE def isValidString ( string ) : NEW_LINE INDENT freq = [ 0 ] * CHARS ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT i , freq1 , count_freq1 = 0 , 0 ; NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT freq1 = freq [ i ] ; NEW_LINE count_freq1 = 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT j , freq2 , count_freq2 = 0 , 0 , 0 ; NEW_LINE for j in range ( i + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ j ] != 0 ) : NEW_LINE INDENT if ( freq [ j ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 += 1 ; NEW_LINE freq2 = freq [ j ] ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ k ] != 0 ) : NEW_LINE INDENT if ( freq [ k ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 ; NEW_LINE DEDENT if ( freq [ k ] == freq2 ) : NEW_LINE INDENT count_freq2 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT if ( count_freq1 > 1 and count_freq2 > 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " abcbc " ; NEW_LINE if ( isValidString ( string ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE s1 = " " NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT if s [ j ] not in " abcdefghijklmnopqrstuvwxyz " : NEW_LINE INDENT s1 += s [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s1 += s [ j ] NEW_LINE DEDENT DEDENT print ( s1 ) NEW_LINE DEDENT
def findMinimumSubsequences ( A , B ) : NEW_LINE INDENT numberOfSubsequences = 1 NEW_LINE sizeOfB = len ( B ) NEW_LINE sizeOfA = len ( A ) NEW_LINE inf = 1000000 NEW_LINE next = [ [ inf ] * ( 26 ) for i in range ( 26 ) ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( sizeOfB ) : NEW_LINE INDENT next [ i ] [ j ] = inf NEW_LINE DEDENT DEDENT for i in range ( sizeOfB ) : NEW_LINE INDENT next [ B [ i ] ] [ i ] = i NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( sizeOfB - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( next [ i ] [ j ] == inf ) : NEW_LINE INDENT next [ i ] [ j ] = next [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT pos = 0 NEW_LINE i = 0 NEW_LINE while ( i < sizeOfA ) : NEW_LINE INDENT if ( pos == 0 and next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] == inf ) : NEW_LINE INDENT numberOfSubsequences = - 1 NEW_LINE break NEW_LINE DEDENT elif ( pos < sizeOfB and next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] < inf ) : NEW_LINE INDENT nextIndex = next [ ord ( A [ i ] ) - ord ( ' a ' ) ] [ pos ] + 1 NEW_LINE pos = nextIndex NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT numberOfSubsequences += 1 NEW_LINE pos = 0 NEW_LINE DEDENT DEDENT return numberOfSubsequences NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = " aacbe " NEW_LINE B = " aceab " NEW_LINE print ( findMinimumSubsequences ( A , B ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( [ 0 , 0 , n * m ] ) NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT k = 0 NEW_LINE for l in range ( 4 ) : NEW_LINE INDENT k = max ( k , abs ( a [ i ] [ 0 ] - j ) + abs ( a [ i ] [ 1 ] - k ) ) NEW_LINE DEDENT b . append ( [ k , 0 , n * m ] ) NEW_LINE DEDENT DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] [ 0 ] , end = " " ) NEW_LINE DEDENT print ( * b ) NEW_LINE DEDENT
def FindRank ( arr , length ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT rank = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT rank += 1 NEW_LINE DEDENT DEDENT print ( rank , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 88 , 14 , 69 , 30 , 29 , 89 ] NEW_LINE length = len ( arr ) NEW_LINE FindRank ( arr , length ) NEW_LINE DEDENT
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( x ) NEW_LINE b . append ( y ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE b . reverse ( ) NEW_LINE ans = h // a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] > h : NEW_LINE INDENT break NEW_LINE DEDENT while h - 1 >= i : NEW_LINE INDENT h -= b [ i ] NEW_LINE ans = min ( ans , i + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while product // pow ( 10 , k ) != 0 : NEW_LINE INDENT product = product // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE DEDENT
m , n = map ( int , input ( ) . split ( ) ) NEW_LINE b = m % n NEW_LINE print ( b if b == 0 else ( ( m - b ) // n + 1 ) ) NEW_LINE
s = input ( ) NEW_LINE n = len ( s ) NEW_LINE cnt = [ 0 ] * ( ord ( ' a ' ) - ord ( ' z ' ) + 1 ) NEW_LINE for c in s : NEW_LINE INDENT cnt [ ord ( c ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT sm = 0 NEW_LINE for i in cnt : NEW_LINE INDENT sm += i % 2 NEW_LINE DEDENT print ( sm // 2 ) NEW_LINE
def complement ( num ) : NEW_LINE INDENT l = 0 ; NEW_LINE l = num ; NEW_LINE while ( True ) : NEW_LINE INDENT l += 1 ; NEW_LINE num = int ( num / 10 ) ; NEW_LINE if ( abs ( num ) == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT num = temp ; NEW_LINE comp = ( 10 ** l - num ) ; NEW_LINE return comp ; NEW_LINE DEDENT print ( complement ( 25 ) ) ; NEW_LINE print ( complement ( 456 ) ) ; NEW_LINE
def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( x ^ n ) NEW_LINE DEDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE
def minOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE freq = [ 0 ] * 1000001 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x ] += 1 NEW_LINE DEDENT maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE
def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c = 2 , 4 , 4 NEW_LINE print ( getMinNum ( a , b , c ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE I = s . count ( " I " ) NEW_LINE if ( I > n ) : NEW_LINE INDENT n = I NEW_LINE DEDENT print ( n ) NEW_LINE
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE query = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT query [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT query . sort ( key = lambda x : ( - x [ 1 ] , x [ 0 ] ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if m >= query [ i ] [ 0 ] : NEW_LINE INDENT ans += query [ i ] [ 1 ] * query [ i ] [ 0 ] NEW_LINE m -= query [ i ] [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - 1 ) * ( query [ i ] [ 0 ] - 1 ) NEW_LINE m = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE import heapq NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE a = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE heapq . heapify ( a ) NEW_LINE heapq . heapify ( b ) NEW_LINE result = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT heapq . heappush ( a , - a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT heapq . heappush ( b , - b [ i ] ) NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT a [ i ] += a [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT a [ i ] -= a [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT a [ i + 1 ] += a [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT a [ i + 1 ] -= a [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] += a [ i - 1 ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT a [ i + 1 ] += a [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT a [ i + 1 ] -= a [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT a [ i + 1 ] += a [ i ] NEW_LINE DEDENT result . append ( max ( result ) ) NEW_LINE print ( result [ 0 ] ) NEW_LINE
arr = [ 1 , 5 , 6 ] NEW_LINE def countWays ( N ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( len ( arr ) ) : NEW_LINE INDENT if ( i >= arr [ j ] ) : NEW_LINE INDENT count [ i ] += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT DEDENT return count [ N ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 7 NEW_LINE print ( " Total number of ways = " , countWays ( N ) ) NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) NEW_LINE DEDENT DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def countFreq ( a , n ) : NEW_LINE INDENT hm = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] += 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if ( hm [ a [ i ] ] != 0 ) : NEW_LINE INDENT print ( a [ i ] , " - > " , cumul ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 2 , 4 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE DEDENT
def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False NEW_LINE possibleA = 0 NEW_LINE possibleB = 0 NEW_LINE possibleC = 0 NEW_LINE numbersInRange = ( R - L + 1 ) NEW_LINE if ( numbersInRange < 3 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT elif ( numbersInRange > 3 ) : NEW_LINE INDENT flag = True NEW_LINE if ( L % 2 > 0 ) : NEW_LINE INDENT L += 1 NEW_LINE DEDENT possibleA = L NEW_LINE possibleB = L + 1 NEW_LINE possibleC = L + 2 NEW_LINE DEDENT else : NEW_LINE INDENT if ( not ( L % 2 > 0 ) ) : NEW_LINE INDENT flag = True NEW_LINE possibleA = L NEW_LINE possibleB = L + 1 NEW_LINE possibleC = L + 2 NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( " ( " , possibleA , " , " , possibleB , " , " , possibleC , " ) " , " is one such possible triplet between " , L , " and " , R ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No Such Triplet exists between " , L , " and " , R ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 2 NEW_LINE R = 10 NEW_LINE possibleTripletInRange ( L , R ) NEW_LINE L = 23 NEW_LINE R = 46 NEW_LINE possibleTripletInRange ( L , R ) NEW_LINE DEDENT
alphabets = " abcdefghijklmnopqrstuvwxyz " NEW_LINE def convert ( charSet , str1 ) : NEW_LINE INDENT s2 = " " NEW_LINE for i in str1 : NEW_LINE INDENT s2 += alphabets [ ord ( charSet [ ord ( i ) - 1 ] ) ] NEW_LINE DEDENT return s2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT charSet = " qwertyuiopasdfghjklzxcvbnm " NEW_LINE str1 = " egrt " NEW_LINE print ( convert ( charSet , str1 ) ) NEW_LINE DEDENT
def generateNumber ( count , a , n , num , k ) : NEW_LINE INDENT if ( count == k ) : NEW_LINE INDENT a . append ( num ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT generateNumber ( count + 1 , a , n , num + a [ i ] , k ) NEW_LINE DEDENT DEDENT def printDistinctIntegers ( k , a , n ) : NEW_LINE INDENT generateNumber ( 0 , a , n , 0 , k ) NEW_LINE print ( " The " , len ( a ) , " distinct integers are : " ) NEW_LINE print ( * a ) NEW_LINE for i in sorted ( set ( a ) ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT arr = [ 3 , 8 , 17 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE printDistinctIntegers ( k , arr , n ) NEW_LINE
def product ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT prod *= ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT def findNumber ( l , r ) : NEW_LINE INDENT b = str ( r ) NEW_LINE ans = r NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if ( b [ i ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT curr = b [ i ] NEW_LINE curr [ i ] = chr ( ( ord ( curr [ i ] ) - ord ( '0' ) ) - 1 + ord ( '0' ) ) NEW_LINE for j in range ( i + 1 , len ( curr ) ) : NEW_LINE INDENT curr [ j ] = '9' NEW_LINE DEDENT num = 0 NEW_LINE for j in range ( len ( curr ) ) : NEW_LINE INDENT num = num * 10 + ( ord ( curr [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT if ( num >= l and product ( ans ) < product ( num ) ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT l = 1 NEW_LINE r = 10 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE l = 51 NEW_LINE r = 62 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE
MAX = 100005 NEW_LINE isPrime = [ True ] * MAX NEW_LINE def sieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime [ 1 ] = True NEW_LINE for i in range ( 2 , int ( MAX ** ( 1 / 2 ) ) ) : NEW_LINE INDENT if ( isPrime [ i ] == True ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( isPrime [ num ] == False ) : NEW_LINE INDENT return num NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr , n ) : NEW_LINE INDENT sieveOfEratosthenes ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( isPrime [ sum ] == False ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minNumber ( arr , n ) ) NEW_LINE DEDENT
MAX = 25 NEW_LINE def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * MAX NEW_LINE max_bit = 0 NEW_LINE sum = 0 NEW_LINE ans = 0 NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] NEW_LINE f = 0 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 NEW_LINE e = e // 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = pow ( 2 , d ) NEW_LINE if ( bits_count [ d ] > n // 2 ) : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans NEW_LINE sum = sum + arr [ d ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 5 , 7 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinSum ( arr , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE index = s . find ( " # " ) NEW_LINE if index < 0 : NEW_LINE INDENT index = s . find ( " # " ) NEW_LINE DEDENT count = 1 NEW_LINE if len ( s ) < n : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] == " # " or s [ i ] == " ! " : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif s [ i ] == " ? " : NEW_LINE INDENT if count > n : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE exit ( ) NEW_LINE DEDENT count = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if index == 0 : NEW_LINE INDENT j = s . find ( " . " ) NEW_LINE if j < 0 : NEW_LINE INDENT j = s . find ( " ? " ) NEW_LINE DEDENT else : NEW_LINE INDENT j = s . find ( " ! " ) NEW_LINE if j + 1 > n : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( count ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr = [ - 1 ] * n NEW_LINE arr [ 0 ] = 0 NEW_LINE rem = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != i + 1 : NEW_LINE INDENT arr [ i ] = a [ i ] NEW_LINE rem . add ( i ) NEW_LINE DEDENT DEDENT arr [ n - 1 ] = 0 NEW_LINE rem . add ( n - 1 ) NEW_LINE q = [ 0 ] NEW_LINE while q : NEW_LINE INDENT v = q . pop ( ) NEW_LINE for u in rem : NEW_LINE INDENT if arr [ u ] == - 1 : NEW_LINE INDENT rem . add ( u ) NEW_LINE arr [ u ] = v + 1 NEW_LINE DEDENT DEDENT q . append ( v ) NEW_LINE DEDENT print ( * arr ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT ans += b [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def findMaximumNum ( arr , n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i <= arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 8 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaximumNum ( arr , n ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT l = input ( ) . split ( ) NEW_LINE l1 = int ( l [ 0 ] ) NEW_LINE l2 = int ( l [ 1 ] ) NEW_LINE if l [ 0 ] == " p " : NEW_LINE INDENT print ( l [ 1 ] + l2 ) NEW_LINE DEDENT else : NEW_LINE INDENT if l [ 1 ] == " r " : NEW_LINE INDENT print ( l [ 0 ] + l2 + l [ 2 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT l2 = l [ 1 : ] NEW_LINE l [ 0 ] = l2 [ 0 ] - 1 NEW_LINE print ( l [ 1 ] + l2 + l [ 2 : ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( A , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2000 ) ] for i in range ( 2000 ) ] NEW_LINE flag = 1 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT for i in range ( - sum , sum + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = sys . maxsize NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE INDENT dp [ flag ] [ j ] = sys . maxsize NEW_LINE if ( j - A [ i - 1 ] <= sum and j - A [ i - 1 ] >= - sum ) : NEW_LINE INDENT dp [ flag ] [ j ] = dp [ flag ^ 1 ] [ j - A [ i - 1 ] ] NEW_LINE DEDENT if ( j + A [ i - 1 ] <= sum and j + A [ i - 1 ] >= - sum and dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] != sys . maxsize ) : NEW_LINE INDENT dp [ flag ] [ j ] = min ( dp [ flag ] [ j ] , dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] + 1 ) NEW_LINE DEDENT DEDENT flag = flag ^ 1 NEW_LINE DEDENT for i in range ( 0 , sum + 1 ) : NEW_LINE INDENT if ( dp [ flag ^ 1 ] [ i ] != sys . maxsize ) : NEW_LINE INDENT return dp [ flag ^ 1 ] [ i ] NEW_LINE DEDENT DEDENT return n - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE print ( solve ( arr , n ) ) NEW_LINE DEDENT
import sys NEW_LINE for e in sys . stdin : NEW_LINE INDENT e = list ( map ( float , e . split ( ) ) ) NEW_LINE print ( ' YES ' if abs ( e [ 0 ] - e [ 2 ] ) ** 2 + abs ( e [ 1 ] - e [ 3 ] ) ** 2 >= e [ 2 ] * e [ 3 ] else ' NO ' ) NEW_LINE DEDENT
def f ( n , p ) : NEW_LINE INDENT return " FizzBuzz " if p % 15 == 0 else " Fizz " if p % 3 == 0 else " Buzz " if p % 5 == 0 else str ( n ) NEW_LINE DEDENT while 1 : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE fizz = [ ] NEW_LINE fizzbuzz = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = input ( ) NEW_LINE fizz . append ( line ) NEW_LINE DEDENT fizzbuzz . reverse ( ) NEW_LINE fizz . reverse ( ) NEW_LINE for p in range ( n ) : NEW_LINE INDENT if fizz [ p ] == " Fizz " : NEW_LINE INDENT fizz [ p ] = " " NEW_LINE DEDENT DEDENT ans = " " NEW_LINE for p in fizz : NEW_LINE INDENT tmp = " " NEW_LINE for n in p : NEW_LINE INDENT if n % p == 0 : NEW_LINE INDENT tmp += " Fizz " NEW_LINE DEDENT elif n % p == 1 : NEW_LINE INDENT tmp += " Buzz " NEW_LINE DEDENT else : NEW_LINE INDENT tmp += str ( n ) NEW_LINE DEDENT ans += tmp NEW_LINE DEDENT ans += p * ans NEW_LINE DEDENT print ( ans [ : - 1 ] ) NEW_LINE DEDENT
l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE
a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( [ a [ i ] - a [ i + 1 ] for i in range ( 1 , 7 ) ] ) ) NEW_LINE
import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = math . floor ( a [ i ] / mul ) NEW_LINE print ( x , end = " " ) NEW_LINE DEDENT DEDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE
def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b . sort ( ) NEW_LINE c . sort ( ) NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( a [ i ] < j ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( a [ j ] > j ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i <= j ) : NEW_LINE INDENT a [ i ] , a [ j ] = a [ j ] , a [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT if ( d < j ) : NEW_LINE INDENT a [ d ] = a [ d ] NEW_LINE a [ d - 1 ] = a [ d - 1 ] NEW_LINE DEDENT if ( i < c ) : NEW_LINE INDENT b [ c ] = b [ i ] NEW_LINE b [ c - 1 ] = b [ c - 1 ] NEW_LINE DEDENT print ( a [ n ] ) NEW_LINE print ( b [ n ] ) NEW_LINE print ( a [ n - 1 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while i < n and s [ i ] == ' < ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while i < n and s [ i ] == ' > ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( i ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE while n > 0 : NEW_LINE INDENT ans += 1 NEW_LINE n //= 2 NEW_LINE if n == 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
v , d , t , f , c = map ( int , input ( ) . split ( ) ) NEW_LINE s = ( v - 1 ) * t NEW_LINE a = s NEW_LINE ans = 1 NEW_LINE while a < c : NEW_LINE INDENT a += ( s - a ) / ( v - 1 ) NEW_LINE ans += 1 NEW_LINE s = s + a NEW_LINE DEDENT print ( ans ) NEW_LINE
d = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE h , m = d ( ) NEW_LINE h2 , m2 = d ( ) NEW_LINE print ( h - h2 + m - m2 ) NEW_LINE
def longestAlternatingSubarray ( a , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] * a [ i - 1 ] < 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE longest = max ( longest , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT return longest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 5 , - 1 , - 1 , 2 , - 2 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( longestAlternatingSubarray ( a , n ) ) NEW_LINE DEDENT
def checkTypeOfTriangle ( a , b , c ) : NEW_LINE INDENT sqa = pow ( a , 2 ) NEW_LINE sqb = pow ( b , 2 ) NEW_LINE sqc = pow ( c , 2 ) NEW_LINE if ( sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb ) : NEW_LINE INDENT print ( " Right - angled Triangle " ) NEW_LINE DEDENT elif ( sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb ) : NEW_LINE INDENT print ( " Obtuse - angled Triangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Acute - angled Triangle " ) NEW_LINE DEDENT DEDENT a = 2 NEW_LINE b = 2 NEW_LINE c = 2 NEW_LINE checkTypeOfTriangle ( a , b , c ) NEW_LINE
def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' G ' ) : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE DEDENT elif ( s [ i ] == ' F ' ) : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " GFGFG " NEW_LINE n = len ( s ) NEW_LINE countSubsequence ( s , n ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10000000 ) NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x = [ 0 ] * n NEW_LINE y = [ 0 ] * n NEW_LINE h = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT x [ i ] , y [ i ] , h [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT d1 = abs ( x [ i ] - x [ i - 1 ] ) + abs ( y [ i ] - y [ i - 1 ] ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT if h [ k ] > d1 : NEW_LINE INDENT print ( i , k , d1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if h [ i ] > d1 : NEW_LINE INDENT print ( i , j , d1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT largest = cbrt ( n ) NEW_LINE n -= ( largest * largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 150 NEW_LINE print ( countSteps ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT ranks = [ 0 ] * 18 NEW_LINE for line in sys . stdin : NEW_LINE INDENT line = line . split ( ) NEW_LINE h , s = map ( int , line [ 0 ] . split ( ) ) NEW_LINE ranks [ h ] = s NEW_LINE DEDENT for i in range ( 3 , 18 ) : NEW_LINE INDENT for j in range ( 8 ) : NEW_LINE INDENT h1 , s1 = map ( int , line [ 1 ] . split ( ) ) NEW_LINE ranks [ j ] = min ( ranks [ j ] , s1 ) NEW_LINE DEDENT DEDENT ranks . sort ( ) NEW_LINE print ( ranks [ 0 ] , ranks [ 1 ] , end = ' ' ) NEW_LINE print ( ranks [ 2 ] , end = ' ' ) NEW_LINE print ( ranks [ 3 ] , end = ' ' ) NEW_LINE print ( ranks [ 4 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mx1 , mn1 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > mx1 : NEW_LINE INDENT mx1 = a [ i ] NEW_LINE DEDENT if a [ i ] < mn1 : NEW_LINE INDENT mn1 = a [ i ] NEW_LINE DEDENT DEDENT mx2 , mn2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == mn2 : NEW_LINE INDENT mn2 += 1 NEW_LINE DEDENT if a [ i ] == mx2 : NEW_LINE INDENT mx2 += 1 NEW_LINE DEDENT DEDENT res = mx2 - mn2 , mx1 - mn1 NEW_LINE print ( res , mx2 * ( mx2 - 1 ) // 2 ) NEW_LINE
def find_count ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = bin ( i ) . count ( '1' ) NEW_LINE if ( i % x == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( find_count ( arr ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( w ) NEW_LINE if s % ( n * ( n + 1 ) // 2 ) != 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT d = s // ( n * ( n + 1 ) // 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if w [ i + 1 ] - w [ i ] > d : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT elif w [ i + 1 ] - w [ i ] < d : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT
def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT N = 390 NEW_LINE print ( maxProd ( N ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = input ( ) NEW_LINE s = arr . replace ( " " , " " ) NEW_LINE ans = max ( len ( arr ) , s ) + 1 NEW_LINE print ( ans ) NEW_LINE
from math import sqrt NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE x = [ ] NEW_LINE y = [ ] NEW_LINE for _ in range ( 2 * n ) : NEW_LINE INDENT b , c = map ( int , input ( ) . split ( ) ) NEW_LINE x . append ( b ) NEW_LINE y . append ( c ) NEW_LINE DEDENT if len ( x ) == 0 : NEW_LINE INDENT x . sort ( ) NEW_LINE y . sort ( ) NEW_LINE print ( sqrt ( ( x [ 0 ] ** 2 + y [ 0 ] ** 2 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT x . sort ( ) NEW_LINE y . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += sqrt ( ( x [ i ] ** 2 + y [ i ] ** 2 ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count //= i NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE DEDENT
def reduceString ( s , l ) : NEW_LINE INDENT count = 1 NEW_LINE steps = 0 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT steps += ( count // 2 ) NEW_LINE count = 1 NEW_LINE DEDENT DEDENT steps += count // 2 NEW_LINE return steps NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE l = len ( s ) NEW_LINE print ( reduceString ( s , l ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if b == a : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE exit ( ) NEW_LINE DEDENT if a > b : NEW_LINE INDENT c = "1" + "0" * ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT c = "0" * ( b - a ) NEW_LINE DEDENT d = "1" + "0" * ( a - b ) NEW_LINE e = ( " ? " + c ) NEW_LINE if e . find ( " ! " ) != - 1 : NEW_LINE INDENT print ( e . replace ( " ! " , " ! " ) ) NEW_LINE DEDENT else : NEW_LINE INDENT r = e . replace ( " ? " , " ! " ) NEW_LINE print ( r ) NEW_LINE DEDENT
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( a , x + 1 ) : NEW_LINE INDENT for j in range ( b , y + 1 ) : NEW_LINE INDENT if i <= j : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( ans ) ) NEW_LINE for i in ans : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT
mod = 1000000007 ; NEW_LINE def mult ( a , b ) : NEW_LINE INDENT return ( ( a % mod ) * ( b % mod ) ) % mod ; NEW_LINE DEDENT def calculate_factors ( n ) : NEW_LINE INDENT ans , cnt = 0 , 0 ; NEW_LINE cnt = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE n = n // 2 ; NEW_LINE DEDENT if ( cnt % 2 == 1 ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) ; NEW_LINE DEDENT for i in range ( 3 , int ( pow ( n , 2 ) ) + 1 , 2 ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE n = n // i ; NEW_LINE DEDENT if ( cnt % 2 == 1 ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = mult ( ans , ( 2 ) ) ; NEW_LINE DEDENT return ans % mod ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 193748576239475639 ; NEW_LINE mod = 17 ; NEW_LINE print ( calculate_factors ( n ) ) ; NEW_LINE DEDENT
s = input ( ) NEW_LINE ans = " " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == " . " : NEW_LINE INDENT ans += "0" NEW_LINE DEDENT elif s [ i ] == " - " and s [ i + 1 ] == " . " : NEW_LINE INDENT ans += "1" NEW_LINE DEDENT else : NEW_LINE INDENT ans += "2" NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxAbsDiff ( arr , n ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : break NEW_LINE n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE continue NEW_LINE DEDENT L = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT l , r , s = map ( int , input ( ) . split ( ) ) NEW_LINE L . append ( ( l , r , s ) ) NEW_LINE DEDENT L . sort ( ) NEW_LINE if L [ 0 ] [ 0 ] == L [ 1 ] [ 0 ] == L [ 2 ] [ 0 ] == L [ 1 ] [ 1 ] == L [ 2 ] [ 1 ] == L [ 2 ] [ 2 ] : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif L [ 0 ] [ 1 ] == L [ 2 ] [ 1 ] == L [ 3 ] [ 1 ] == L [ 2 ] [ 2 ] : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif L [ 0 ] [ 1 ] == L [ 2 ] [ 1 ] == L [ 3 ] [ 1 ] == L [ 2 ] [ 2 ] : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif L [ 0 ] [ 1 ] == L [ 2 ] [ 1 ] == L [ 3 ] [ 1 ] == L [ 2 ] [ 2 ] : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
def minRemove ( a , b , n , m ) : NEW_LINE INDENT countA = dict . fromkeys ( a , 0 ) ; NEW_LINE countB = dict . fromkeys ( b , 0 ) ; NEW_LINE res = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( countA [ a [ i ] ] ) : NEW_LINE INDENT countA [ a [ i ] ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countA [ a [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( countB [ b [ i ] ] ) : NEW_LINE INDENT countB [ b [ i ] ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countB [ b [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT res = 0 ; NEW_LINE for x in countA : NEW_LINE INDENT if ( countB [ x ] ) : NEW_LINE INDENT res += min ( countB [ x ] , countA [ x ] ) ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 ] ; NEW_LINE b = [ 2 , 3 , 4 , 5 , 8 ] ; NEW_LINE n = len ( a ) ; NEW_LINE m = len ( b ) ; NEW_LINE print ( minRemove ( a , b , n , m ) ) ; NEW_LINE DEDENT
M = 20 NEW_LINE def count ( pos , firstD , lastD , tight , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT if ( firstD == lastD ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ firstD ] [ lastD ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ firstD ] [ lastD ] [ tight ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = 9 if ( tight == 1 ) else num [ pos ] NEW_LINE for dig in range ( limit + 1 ) : NEW_LINE INDENT currFirst = firstD NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT currFirst = dig NEW_LINE DEDENT if ( currFirst == 0 and dig != 0 ) : NEW_LINE INDENT currFirst = dig NEW_LINE DEDENT currTight = tight NEW_LINE if ( dig < num [ pos ] ) : NEW_LINE INDENT currTight = 1 NEW_LINE DEDENT ans += count ( pos + 1 , currFirst , dig , currTight , num ) NEW_LINE DEDENT dp [ pos ] [ firstD ] [ lastD ] [ tight ] = ans NEW_LINE return dp [ pos ] [ firstD ] [ lastD ] [ tight ] NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT num = [ ] NEW_LINE while ( x > 0 ) : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( M ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = - 1 NEW_LINE DEDENT DEDENT ans += count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 2 NEW_LINE R = 60 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE L = 1 NEW_LINE R = 1000 NEW_LINE print ( solve ( R ) - solve ( L -
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 1 NEW_LINE if a [ 0 ] == 1 : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT ans *= ( i - a [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def bit ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT x = int ( x / 2 ) NEW_LINE ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def check ( d , x ) : NEW_LINE INDENT if ( bit ( x // d ) <= bit ( d ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def bs ( n ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( math . sqrt ( n ) ) NEW_LINE while ( l < r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( check ( m , n ) ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( check ( l , n ) == False ) : NEW_LINE INDENT return l + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return l NEW_LINE DEDENT DEDENT def countDivisor ( n ) : NEW_LINE INDENT return n - bs ( n ) + 1 NEW_LINE DEDENT n = 5 NEW_LINE print ( countDivisor ( n ) ) NEW_LINE
import sys NEW_LINE def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ sys . maxsize ] * n NEW_LINE s1 , s2 = " " , " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 ] NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if s1 == s2 : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaaaa aaa " NEW_LINE n = len ( s ) NEW_LINE print ( minimalSteps ( s , n ) // 2 ) NEW_LINE DEDENT
def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num // base , dig - 1 , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 32 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT def getMin ( arr , i , j ) : NEW_LINE INDENT minVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE DEDENT def getMax ( arr , i , j ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE i += 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT def generateArr ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT tmpArr = [ 0 for i in range ( n ) ] NEW_LINE tmpArr [ 0 ] = getMax ( arr , 1 , n - 1 ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT tmpArr [ i ] = abs ( getMax ( arr , i + 1 , n - 1 ) - getMin ( arr , 0 , i - 1 ) ) NEW_LINE DEDENT tmpArr [ n - 1 ] = getMin ( arr , 0 , n - 2 ) NEW_LINE printArray ( tmpArr , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE generateArr ( arr , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans -= a [ i ] NEW_LINE DEDENT DEDENT ans = max ( ans , ans ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == ' B ' : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans -= a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT x1 , y1 , x2 , y2 , x3 , y3 = map ( int , input ( ) . split ( ) ) NEW_LINE a = x3 - x2 NEW_LINE b = y3 - y2 NEW_LINE c = x3 - x2 NEW_LINE d = y1 - y2 NEW_LINE if ( c / a == d ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def nthXorFib ( n , a , b ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( a ^ b ) NEW_LINE DEDENT return nthXorFib ( n % 3 , a , b ) NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE n = 10 NEW_LINE print ( nthXorFib ( n , a , b ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE if int ( a ) == int ( b ) : NEW_LINE INDENT x += 3 NEW_LINE DEDENT elif int ( a ) > int ( b ) : NEW_LINE INDENT x += 3 NEW_LINE DEDENT else : NEW_LINE INDENT y += 3 NEW_LINE DEDENT DEDENT print ( x , y ) NEW_LINE
import math as mt NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1. li * a NEW_LINE A = 0.70477 * pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT return str ( stern_brocot_count ( 1 , 3 , 1 , 2 ) ) NEW_LINE DEDENT def stern_brocot_count ( leftN , leftD , rightN , rightD ) : NEW_LINE INDENT n = leftN + rightN NEW_LINE d = leftD + rightD NEW_LINE if d > 12000 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + ( stern_brocot_count ( leftN , leftD , n , d ) + stern_brocot_count ( n , d , rightN , rightD ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n % 2 == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT print ( 2 ** n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ** ( n // 2 ) ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = int ( sqrt ( d ) ) - 1 ; NEW_LINE prime = [ True ] * ( maxVal + 1 ) ; NEW_LINE sieve ( prime , maxVal ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT d = 3 ; NEW_LINE print ( sumPrime ( d ) ) ; NEW_LINE DEDENT
from math import sqrt NEW_LINE def sieve ( prime , n ) : NEW_LINE INDENT prime [ 0 ] = False ; NEW_LINE prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumPrime ( d ) : NEW_LINE INDENT maxVal = int ( pow ( 2 , d ) - 1 ) ; NEW_LINE prime = [ True ] * ( maxVal + 1 ) ; NEW_LINE sieve ( prime , maxVal ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT d = 8 ; NEW_LINE print ( sumPrime ( d ) ) ; NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE c = 0 NEW_LINE i = n - 1 NEW_LINE while ( k > 0 and i > 0 ) : NEW_LINE INDENT k -= l [ i ] NEW_LINE c += 1 NEW_LINE i -= 1 NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT
d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = d [ 0 ] NEW_LINE b = d [ 1 ] NEW_LINE c = d [ 2 ] NEW_LINE d = d [ 3 ] NEW_LINE e = d [ 4 ] NEW_LINE f = d [ 5 ] NEW_LINE g = d [ 6 ] NEW_LINE h = d [ 7 ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( d ) and j < len ( e ) : NEW_LINE INDENT if a < d [ i ] : NEW_LINE INDENT a = d [ i ] NEW_LINE DEDENT elif b < d [ i ] : NEW_LINE INDENT b = d [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT c = d [ i ] NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT if a == b and c == e and i == j : NEW_LINE INDENT print ( f + 1 ) NEW_LINE DEDENT elif a == b and c == e and i == j : NEW_LINE INDENT print ( g + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( f + 2 ) NEW_LINE DEDENT
def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 ; max_so_far = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) ; NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxPartitions ( arr , n ) ) ; NEW_LINE DEDENT
def countMaxContiguous ( arr , n ) : NEW_LINE INDENT current_max = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT current_max = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current_max += 1 NEW_LINE max_so_far = max ( current_max , max_so_far ) NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 4 , 3 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countMaxContiguous ( arr , n ) ) NEW_LINE
from math import sqrt NEW_LINE def cube ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( h * r * sqrt ( 2 ) ) / ( h + sqrt ( 2 ) * r ) NEW_LINE return a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT h , r = 5 , 6 NEW_LINE print ( cube ( h , r ) ) NEW_LINE DEDENT
def pattern ( rows_no ) : NEW_LINE INDENT for i in range ( 1 , rows_no + 1 ) : NEW_LINE INDENT for k in range ( 1 , rows_no + 1 ) : NEW_LINE INDENT print ( end = " " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT for i in range ( rows_no - 1 , 0 , - 1 ) : NEW_LINE INDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( end = " " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT rows_no = 7 NEW_LINE pattern ( rows_no ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT print ( 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT s = str ( n ) NEW_LINE if '0' in s : NEW_LINE INDENT print ( int ( s . replace ( '0' , ' ' ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( s . replace ( '0' , ' ' ) ) ) NEW_LINE DEDENT DEDENT
def check_digits ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( check_digits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE DEDENT
def check_digits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( check_digits ( i ) != 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 2397 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE DEDENT
def triangular_series ( n ) : NEW_LINE INDENT j = 1 NEW_LINE k = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( k , end = " " ) NEW_LINE j = j + 1 NEW_LINE k = k + j NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE triangular_series ( n ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE d = n * ( n + 1 ) NEW_LINE ans = s // 2 NEW_LINE for i in range ( m ) : NEW_LINE INDENT ans += d - a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = 0 NEW_LINE i = 2 NEW_LINE while ( i != 0 ) : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = f3 NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 5 NEW_LINE k = 4 NEW_LINE print ( " Position of n ' th multiple of k in Fibonacci series is " ) NEW_LINE print ( findPosition ( k , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE s = input ( ) [ : - 1 ] NEW_LINE n = len ( s ) NEW_LINE d = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] not in d : NEW_LINE INDENT d [ s [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ s [ i ] ] += 1 NEW_LINE DEDENT DEDENT if n % 2 == 1 : NEW_LINE INDENT print ( ' First ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Second ' ) NEW_LINE DEDENT
def countMinimumMoves ( arr , n , k ) : NEW_LINE INDENT for i in range ( k - 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE K = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( countMinimumMoves ( arr , n , K ) ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powerGCD ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 5 NEW_LINE b = 4 NEW_LINE n = 2 NEW_LINE print ( powerGCD ( a , b , n ) ) NEW_LINE DEDENT
t , s , q = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE while s > t : NEW_LINE INDENT s -= q NEW_LINE c += 1 NEW_LINE DEDENT print ( c ) NEW_LINE
n = int ( input ( ) ) NEW_LINE print ( ( n - 2 ) ** 2 ) NEW_LINE
def countIdenticalRows ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( mat ) ) : NEW_LINE INDENT hs = dict ( ) NEW_LINE for j in range ( len ( mat [ i ] ) ) : NEW_LINE INDENT hs [ mat [ i ] [ j ] ] = 1 NEW_LINE DEDENT if ( len ( hs ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 1 , 1 , 1 ] , [ 1 , 2 , 3 ] , [ 5 , 5 , 5 ] ] NEW_LINE print ( countIdenticalRows ( mat ) ) NEW_LINE DEDENT
def createSorted ( a , n ) : NEW_LINE INDENT b = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( len ( b ) == 0 ) : NEW_LINE INDENT b . append ( a [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT start , end = 0 , len ( b ) - 1 NEW_LINE pos = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE if ( b [ mid ] == a [ j ] ) : NEW_LINE INDENT b . append ( ( max ( 0 , mid + 1 ) , a [ j ] ) ) NEW_LINE break NEW_LINE DEDENT elif ( b [ mid ] > a [ j ] ) : NEW_LINE INDENT pos = end NEW_LINE DEDENT else : NEW_LINE INDENT pos = mid - 1 NEW_LINE DEDENT DEDENT if ( start > end ) : NEW_LINE INDENT pos = start NEW_LINE b . append ( ( max ( 0 , pos ) , a [ j ] ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 5 , 4 , 9 , 8 ] NEW_LINE n = len ( a ) NEW_LINE createSorted ( a , n ) NEW_LINE DEDENT
def countTotalDistinct ( str ) : NEW_LINE INDENT cnt = 0 NEW_LINE items = set ( ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE ans = set ( ) NEW_LINE for j in range ( i , len ( str ) ) : NEW_LINE INDENT temp += str [ j ] NEW_LINE ans . add ( str [ j ] ) NEW_LINE if temp not in items : NEW_LINE INDENT items . add ( temp ) NEW_LINE cnt += len ( ans ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " ABCA " NEW_LINE print ( countTotalDistinct ( str ) ) NEW_LINE DEDENT
from math import log10 , ceil NEW_LINE def firstDigit ( n ) : NEW_LINE INDENT digits = ceil ( log10 ( n ) ) NEW_LINE n = int ( n / pow ( 10 , digits ) ) NEW_LINE return n NEW_LINE DEDENT def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 98562 NEW_LINE print ( firstDigit ( n ) , " " , lastDigit ( n ) ) NEW_LINE DEDENT
def removeZeros ( a , n ) : NEW_LINE INDENT ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 0 ) : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind == - 1 ) : NEW_LINE INDENT print ( " Array has leading zeros only " ) NEW_LINE return NEW_LINE DEDENT b = [ 0 ] * ( n - ind ) NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT b [ i ] = a [ ind + i ] NEW_LINE DEDENT for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 0 , 0 , 1 , 2 , 0 , 3 ] NEW_LINE n = len ( a ) NEW_LINE removeZeros ( a , n ) NEW_LINE DEDENT
def find_maxm ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT ans = 0 NEW_LINE for x in mp : NEW_LINE INDENT value , freq = x , mp [ x ] NEW_LINE if ( value == freq ) : NEW_LINE INDENT ans = max ( ans , value ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 2 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( find_maxm ( arr , n ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE from collections import Counter , deque NEW_LINE from collections import defaultdict NEW_LINE from itertools import combinations , permutations , accumulate , groupby , product NEW_LINE from bisect import bisect_left , bisect_right NEW_LINE from heapq import heapify , heappop , heappush NEW_LINE from math import floor , ceil NEW_LINE from operator import itemgetter NEW_LINE from itertools import product , permutations , combinations_with_replacement NEW_LINE from copy import deepcopy NEW_LINE inf = float ( ' inf ' ) NEW_LINE def I ( ) : return int ( input ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def LI_ ( ) : return list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) NEW_LINE def MXI ( ) : return [ [ LI ( ) ] for _ in range ( n ) ] NEW_LINE def SI ( ) : return input ( ) . rstrip ( ) NEW_LINE def printns ( x ) : print ( ' \n ' . join ( x ) ) NEW_LINE def printni ( x ) : print ( ' \n ' . join ( list ( map ( str , x ) ) ) ) NEW_LINE inf = 10 ** 17 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE n = I ( ) NEW_LINE a = LI ( ) NEW_LINE ans = n * ( n + 1 ) // 2 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while l < r : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if a [ mid ] > ans : NEW_LINE INDENT r = mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def sumOfDigitsSingle ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT ans += x % 10 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def closest ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( ans * 10 + 9 <= x ) : NEW_LINE INDENT ans = ans * 10 + 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sumOfDigitsTwoParts ( N ) : NEW_LINE INDENT A = closest ( N ) NEW_LINE return ( sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ) NEW_LINE DEDENT N = 35 NEW_LINE print ( sumOfDigitsTwoParts ( N ) ) NEW_LINE
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT a , b = [ float ( i ) for i in line . split ( ) ] NEW_LINE tos = [ " A " , " B " , " C " , " D " , " E " , " F " ] NEW_LINE count = 0 NEW_LINE if a > b : NEW_LINE INDENT count = max ( count , b ) NEW_LINE DEDENT elif a < b : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif a == b : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == 3 : NEW_LINE INDENT count = max ( count , a ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == 4 : NEW_LINE INDENT count = max ( count , a ) NEW_LINE DEDENT elif count == 5 : NEW_LINE INDENT count = max ( count , a ) NEW_LINE DEDENT elif count == 6 : NEW_LINE INDENT count = max ( count , a ) NEW_LINE DEDENT print ( " % d \n % d \n % d " % ( count , count ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( c - 1 , a - c ) + max ( d - 1 , b - d ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE if a [ n - 1 ] - a [ n - 2 ] >= 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
from math import sin NEW_LINE def cal_ sin ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = n NEW_LINE sinx = n NEW_LINE sinval = sin ( n ) NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT denominator = 2 * i * ( 2 * i + 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE sinx = sinx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT while True : NEW_LINE INDENT accuracy = max ( accuracy , sinval - sinx ) NEW_LINE print ( sinx ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 90 NEW_LINE cal_ sin ( n ) NEW_LINE DEDENT
arr = 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE def multiply ( ) : NEW_LINE INDENT pro = 1 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT pro = pro * arr [ i ] NEW_LINE DEDENT return pro NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( multiply ( ) ) NEW_LINE DEDENT
Q = int ( input ( ) ) NEW_LINE N = [ ] NEW_LINE flag = 0 NEW_LINE for i in range ( Q ) : NEW_LINE INDENT line = input ( ) . split ( ) NEW_LINE if line [ 0 ] == "0" : NEW_LINE INDENT N . append ( line [ 1 ] ) NEW_LINE DEDENT elif line [ 0 ] == "1" : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif line [ 0 ] == "2" : NEW_LINE INDENT N . append ( line [ 1 ] ) NEW_LINE DEDENT elif line [ 0 ] == "3" : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT elif line [ 0 ] == "4" : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif line [ 0 ] == "5" : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT elif line [ 0 ] == "6" : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif line [ 0 ] == "7" : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT elif line [ 0 ] == "8" : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif line [ 0 ] == "9" : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT if flag == 0 : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT elif flag == 1 : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT elif flag == 2 : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT elif flag == 3 : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT elif flag == 4 : NEW_LINE INDENT print ( "2" ) NEW_LINE DEDENT elif flag == 5 : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT elif flag == 6 : NEW_LINE INDENT print ( "1" + "0" * ( N [ 1 ] - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" * ( N [ 1 ] - 1 ) + N [ 0 ] ) NEW_LINE DEDENT DEDENT
def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT m = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE excl_new = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = m if ( m > excl ) else excl NEW_LINE m = excl + arr [ i ] NEW_LINE excl = excl_new NEW_LINE DEDENT if ( m > excl ) : NEW_LINE INDENT excl = m NEW_LINE DEDENT return ( ( m > excl ) ) NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE
a = int ( input ( ) ) NEW_LINE arr = [ ] NEW_LINE for i in range ( a ) : NEW_LINE INDENT sub = input ( ) NEW_LINE arr . append ( sub ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT if arr [ i ] [ 0 ] == ' C ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT v = c * a // 2 NEW_LINE print ( v ) NEW_LINE
def findMinIndex ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return findMinIndex ( arr , low , mid - 1 ) NEW_LINE DEDENT return findMinIndex ( arr , mid + 1 , high ) NEW_LINE DEDENT def binary_search ( arr , l , h , x ) : NEW_LINE INDENT while ( l <= h ) : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if ( arr [ mid ] <= x ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT return h NEW_LINE DEDENT def countEleLessThanOrEqual ( arr , n , x ) : NEW_LINE INDENT min_index = findMinIndex ( arr , 0 , n - 1 ) NEW_LINE if ( x <= arr [ n - 1 ] ) : NEW_LINE INDENT return ( binary_search ( arr , min_index , n - 1 , x ) + 1 - min_index ) NEW_LINE DEDENT if ( ( min_index - 1 ) >= 0 and x <= arr [ min_index - 1 ] ) : NEW_LINE INDENT return ( n - min_index + binary_search ( arr , 0 , min_index - 1 , x ) + 1 ) NEW_LINE DEDENT return n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 10 , 12 , 15 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 14 NEW_LINE print ( " Count = " , countEleLessThanOrEqual ( arr , n , x ) ) NEW_LINE DEDENT
def f ( x , y ) : NEW_LINE INDENT v = y - 2 * x * x + 1 NEW_LINE return v NEW_LINE DEDENT def Sum ( x , y , h ) : NEW_LINE INDENT y1p = y + h * f ( x , y ) NEW_LINE return y1p NEW_LINE DEDENT def correct ( x , y , x1 , y1 , h ) : NEW_LINE INDENT e = 0.00001 NEW_LINE y1c = y1 NEW_LINE while ( abs ( y1c - y1 ) > e ) : NEW_LINE INDENT y1 = y1c NEW_LINE y1c = y + 0.5 * h * ( f ( x , y ) + f ( x1 , y1 ) ) NEW_LINE DEDENT return y1c NEW_LINE DEDENT def print final value of y at x = 0 NEW_LINE y = 0.5 NEW_LINE xn = 1 NEW_LINE h = 0.2 NEW_LINE print final value of y at x = 0 NEW_LINE while ( x < xn ) : NEW_LINE INDENT x1 = x + h NEW_LINE y1p = Sum ( x , y , h ) NEW_LINE y1c = correct ( x , y , x1 , y1p , h ) NEW_LINE x = x1 NEW_LINE y = y1c NEW_LINE DEDENT print ( " The final value of y at x = " , int ( x ) , " is : " , " " , int ( y ) , " f " , y ) NEW_LINE
def D_Pattern ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j == 1 or ( ( i == 0 or i == n - 1 ) and ( j > 1 and j < n - 2 ) ) or ( j == n - 2 and i != 0 and i != n - 1 ) ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 9 NEW_LINE D_Pattern ( n ) NEW_LINE
def kthString ( n , k ) : NEW_LINE INDENT total = 0 NEW_LINE i = 1 NEW_LINE while ( total < k ) : NEW_LINE INDENT total += n - i NEW_LINE i += 1 NEW_LINE DEDENT first_y_position = i - 1 NEW_LINE second_y_position = k - ( total - n + first_y_position ) NEW_LINE for j in range ( 1 , first_y_position ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE j = first_y_position + 1 NEW_LINE while ( second_y_position > 1 ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE second_y_position -= 1 NEW_LINE j += 1 NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE while ( j < n ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT n = 5 NEW_LINE k = 7 NEW_LINE kthString ( n , k ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) ; NEW_LINE C [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] ; NEW_LINE DEDENT DEDENT return C [ k ] ; NEW_LINE DEDENT def count_of_subarrays ( N ) : NEW_LINE INDENT count = binomialCoeff ( 2 * N - 1 , N ) ; NEW_LINE return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 ; NEW_LINE print ( count_of_subarrays ( N ) ) ; NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def product except exceptlist ( self , n ) : NEW_LINE INDENT return [ ] NEW_LINE DEDENT DEDENT def product exceptlist ( n ) : NEW_LINE INDENT return [ 1 ] * n NEW_LINE DEDENT def product exceptlist2 ( n ) : NEW_LINE INDENT return [ 0 ] * n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = '1234 '12345678910111213' NEW_LINE out = sObj . product exceptlist2 ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
def getSmallestAndLargest ( s , k ) : NEW_LINE INDENT currStr = s [ 0 : k ] NEW_LINE lexMin = currStr NEW_LINE lexMax = currStr NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT currStr = currStr [ 1 : k ] + s [ i ] NEW_LINE if lexMax > currStr : NEW_LINE INDENT lexMax = currStr NEW_LINE DEDENT if lexMin > currStr : NEW_LINE INDENT lexMin = currStr NEW_LINE DEDENT DEDENT print ( lexMin ) NEW_LINE print ( lexMax ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksForGeeks " NEW_LINE k = 3 NEW_LINE getSmallestAndLargest ( str , k ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( b [ i ] , end = " " ) NEW_LINE DEDENT
INT_BITS = 32 NEW_LINE def maxSubarrayXOR ( set , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( INT_BITS - 1 , - 1 , - 1 ) : NEW_LINE INDENT maxInd = index NEW_LINE maxEle = - 2147483648 NEW_LINE for j in range ( index , n ) : NEW_LINE INDENT if ( ( set [ j ] & ( 1 << i ) ) and set [ j ] > maxEle ) : NEW_LINE INDENT maxEle = set [ j ] NEW_LINE maxInd = j NEW_LINE DEDENT DEDENT if ( maxEle == - 2147483648 ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = set [ index ] NEW_LINE set [ index ] = set [ maxInd ] NEW_LINE set [ maxInd ] = temp NEW_LINE maxInd = index NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( j != maxInd and ( set [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT set [ j ] = set [ j ] ^ set [ maxInd ] NEW_LINE DEDENT DEDENT index += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res ^= set [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT set = [ 9 , 8 , 5 ] NEW_LINE n = len ( set ) NEW_LINE print ( " Max subset XOR is " , end = " " ) NEW_LINE print ( maxSubarrayXOR ( set , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] == a [ j ] : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( temp , n - temp ) NEW_LINE
def minAbsSumPair ( arr , n ) : NEW_LINE INDENT sum = 999999 NEW_LINE l , r = 0 , n - 1 NEW_LINE min_l , min_r = l , n - 1 NEW_LINE if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid Input " ) NEW_LINE return NEW_LINE DEDENT arr . sort ( ) NEW_LINE while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( abs ( sum ) < abs ( min_sum ) ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT if ( sum < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT print ( " The two elements whose " + " sum is minimum are " + str ( arr [ min_l ] ) + " and " + str ( arr [ min_r ] ) ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE min abs ( minAbsSumPair ( arr , n ) ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def firstUn uniqChar ( self , s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = " leetcode " NEW_LINE out = sObj . firstUn uniqChar ( s ) NEW_LINE print ( out ) NEW_LINE DEDENT
def checkStackPermutation ( ip , op , n ) : NEW_LINE INDENT input = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT input . append ( ip [ i ] ) NEW_LINE DEDENT output = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT output . append ( op [ i ] ) NEW_LINE DEDENT tempStack = [ ] NEW_LINE while ( len ( input ) != 0 ) : NEW_LINE INDENT ele = input [ 0 ] NEW_LINE if ( ele == output [ - 1 ] ) : NEW_LINE INDENT output . pop ( ) NEW_LINE while ( len ( tempStack ) != 0 ) : NEW_LINE INDENT if ( tempStack [ - 1 ] == output [ - 2 ] ) : NEW_LINE INDENT tempStack . pop ( ) NEW_LINE output . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT tempStack . append ( ele ) NEW_LINE DEDENT DEDENT return ( len ( input ) and len ( output ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = [ 1 , 2 , 3 ] NEW_LINE output = [ 2 , 1 , 3 ] NEW_LINE n = 3 NEW_LINE if ( checkStackPermutation ( input , output , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not Possible " ) NEW_LINE DEDENT DEDENT
s = input ( ) NEW_LINE t = input ( ) NEW_LINE s = " " . join ( s ) NEW_LINE t = " " . join ( t ) NEW_LINE l = len ( s ) NEW_LINE k = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if s [ i ] == t [ i ] : NEW_LINE INDENT s = s [ : i ] + s [ i + 1 : ] NEW_LINE k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT if k == 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE break NEW_LINE DEDENT DEDENT
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 10 == d ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 30 NEW_LINE d = 3 NEW_LINE print ( getSum ( n , d ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT st , end = map ( int , input ( ) . split ( ) ) NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if st > end : NEW_LINE INDENT end -= st NEW_LINE DEDENT elif end - st > n : NEW_LINE INDENT end -= end - st NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT if st > end : NEW_LINE INDENT print ( end - st ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end - st + 1 ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT e , s , t = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( e - s , t - e + 1 ) ) NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 NEW_LINE K = 2 NEW_LINE print ( findSum ( N , K ) ) NEW_LINE DEDENT
from math import * NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n < 3 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT elif n % 4 == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a = ( n - 3 ) // 4 NEW_LINE b = n - 2 NEW_LINE c = 1 NEW_LINE while b > 0 : NEW_LINE INDENT if b % a == 0 : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif a % a == 0 : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b -= 1 NEW_LINE DEDENT c += 1 NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE PI = 3.14 NEW_LINE def find_area ( r , d ) : NEW_LINE INDENT R = d / PI NEW_LINE R += pow ( r , 2 ) NEW_LINE R = sqrt ( R ) NEW_LINE area = PI * pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r , d = 4 , 5 NEW_LINE print ( find_area ( r , d ) ) NEW_LINE DEDENT
def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( ( s % n ) > 0 ) : NEW_LINE INDENT return s // n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return s // n NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE s = 11 NEW_LINE print ( minimumNumbers ( n , s ) ) NEW_LINE DEDENT
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE end = n - 1 NEW_LINE while ( end >= 2 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while ( start < mid ) : NEW_LINE INDENT prod = arr [ end ] * arr [ start ] * arr [ mid ] NEW_LINE if ( prod > m ) : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif ( prod < m ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT elif ( prod == m ) : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT end -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE m = 1 NEW_LINE print ( countTriplets ( arr , n , m ) ) NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def isSatisfied ( string , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) and isVowel ( string [ i - 1 ] ) ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) and isVowel ( string [ i - 1 ] ) and isVowel ( string [ i + 1 ] ) ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " acaba " ; NEW_LINE n = len ( string ) ; NEW_LINE if ( isSatisfied ( string , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT
def expect ( m , n ) : NEW_LINE INDENT ans = 0.0 ; NEW_LINE for i in range ( m , 0 , - 1 ) : NEW_LINE INDENT ans += ( ( pow ( i / m , n ) ) - ( pow ( ( i - 1 ) / m , n ) ) * i ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 6 ; n = 3 ; NEW_LINE print ( expect ( m , n ) ) ; NEW_LINE DEDENT
from math import sqrt NEW_LINE def ProdOfPrimes ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT prod = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT prod *= i NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( ProdOfPrimes ( n ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for y in range ( 1901 , 2000 + 1 ) for m in range ( 1 , 12 + 1 ) if dayOfWeek ( y , m , 1 ) == 0 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def dayOfWeek ( y , m , day ) : NEW_LINE INDENT if ( y < 0 or y > 10000 or m < 1 or m > 12 or day < 1 or day > 31 ) : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT m = ( month - 3 + 4800 ) % 4800 NEW_LINE y = ( y + m // 12 ) % 4800 NEW_LINE m %= 12 NEW_LINE return ( y // 4 - y // 100 + ( 13 * m + 2 ) // 5 + day + 2 ) % 7 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def getDifference ( d , m , y ) : NEW_LINE INDENT n1 = y * 365 + y NEW_LINE n2 = y * 365 + y NEW_LINE return n1 + n2 NEW_LINE DEDENT def countLeapYear ( d ) : NEW_LINE INDENT years = d NEW_LINE if ( d <= 2 ) : NEW_LINE INDENT years -= 1 NEW_LINE DEDENT return years // 4 - years // 100 + years // 400 NEW_LINE DEDENT def getDifference ( dt1 , dt2 ) : NEW_LINE INDENT n1 = dt1 . y * 365 + dt1 . d NEW_LINE for i in range ( m - 1 ) : NEW_LINE INDENT n1 += monthDays [ i ] NEW_LINE DEDENT n1 += countLeapYear ( dt1 ) NEW_LINE n2 = dt2 . y * 365 + dt2 . d NEW_LINE for i in range ( m - 1 ) : NEW_LINE INDENT n2 += monthDays [ i ] NEW_LINE DEDENT n2 += countLeapYear ( dt2 ) NEW_LINE return ( n2 - n1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT dt1 = ( 1 , 2 , 2000 ) NEW_LINE dt2 = ( 1 , 2 , 2004 ) NEW_LINE print ( " Difference between two dates is " , getDifference ( dt1 , dt2 ) ) NEW_LINE DEDENT
st = dict ( ) ; NEW_LINE def generateNumbers ( n , num , a , b ) : NEW_LINE INDENT if ( num > 0 and num < n ) : NEW_LINE INDENT st [ num ] = 1 ; NEW_LINE DEDENT if ( num >= n ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( num * 10 + a > num ) : NEW_LINE INDENT generateNumbers ( n , num * 10 + a , a , b ) ; NEW_LINE DEDENT generateNumbers ( n , num * 10 + b , a , b ) ; NEW_LINE DEDENT def printNumbers ( n ) : NEW_LINE INDENT for i in range ( 0 , 10 + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , 10 + 1 ) : NEW_LINE INDENT generateNumbers ( n , 0 , i , j ) ; NEW_LINE DEDENT DEDENT print ( " The numbers are : " , end = " " ) ; NEW_LINE print ( st . values ( ) ) ; NEW_LINE st . clear ( ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE printNumbers ( n ) ; NEW_LINE
n , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( t * k ) / 100 ) NEW_LINE k *= n NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , q = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE ma = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE ma [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT hq = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT for i in ma : NEW_LINE INDENT hq . append ( hq [ - 1 ] + j ) NEW_LINE DEDENT DEDENT hq . sort ( ) NEW_LINE hq . reverse ( ) NEW_LINE max = 0 NEW_LINE for i in hq : NEW_LINE INDENT if max < i [ 1 ] : max = i [ 1 ] NEW_LINE DEDENT print ( max ) NEW_LINE DEDENT
def getOddOccurrence ( ar , ar_size ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( ar_size ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT OddOccurance = OddOccurance ( ) NEW_LINE ar = [ 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE print ( getOddOccurrence ( ar , n ) ) NEW_LINE DEDENT
def isKthBitSet ( x , k ) : NEW_LINE INDENT rslt = 1 if ( x & ( 1 << ( k - 1 ) ) ) else 0 NEW_LINE return rslt NEW_LINE DEDENT def isPalindrome ( x ) : NEW_LINE INDENT l = 1 NEW_LINE r = ( int ) ( ( 1 << 31 ) * 8 ) NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT x = 1 << 15 + 1 << 16 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE x = ( 1 << 31 ) + 1 NEW_LINE print ( isPalindrome ( x ) ) NEW_LINE
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True ; NEW_LINE DEDENT p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT flag = 0 ; NEW_LINE isPrime = [ False ] * ( n + 1 ) ; NEW_LINE SieveOfEratosthenes ( n , isPrime ) ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT x = n // i ; NEW_LINE if ( isPrime [ i ] and isPrime [ x ] and x != i and x * i == n ) : NEW_LINE INDENT print ( i , x ) ; NEW_LINE flag = 1 ; NEW_LINE return ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( " No such pair found " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 39 ; NEW_LINE findPrimePair ( n ) ; NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) = " , g ) NEW_LINE a = 35 NEW_LINE b = 10 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) = " , g ) NEW_LINE a = 31 NEW_LINE b = 2 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) = " , g ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT a = 10 NEW_LINE b = 15 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) = " , g ) NEW_LINE a = 35 NEW_LINE b = 10 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) = " , g ) NEW_LINE a = 31 NEW_LINE b = 2 NEW_LINE g = gcd ( a , b ) NEW_LINE print ( " GCD ( " , a , " , " , b , " ) = " , g ) NEW_LINE
def compute ( ) : NEW_LINE INDENT SIZE_limit = 10 NEW_LINE type = { } NEW_LINE for n in range ( 3 , SIZE_limit + 1 ) : NEW_LINE INDENT for m in range ( n - 2 , 0 , - 2 ) : NEW_LINE INDENT tiles = n * n - m * m NEW_LINE if tiles > SIZE_limit : NEW_LINE INDENT break NEW_LINE DEDENT type [ tiles ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for t in type : NEW_LINE INDENT if 1 <= t <= SIZE_limit : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ - 1 ] == '0' : NEW_LINE INDENT c = 0 NEW_LINE while s [ - 1 ] == '0' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if c > 0 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def maxZeros ( N ) : NEW_LINE INDENT maxm = - 1 ; NEW_LINE cnt = 0 ; NEW_LINE while ( N != 0 ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE N >>= 1 ; NEW_LINE maxm = max ( maxm , cnt ) ; NEW_LINE DEDENT else : NEW_LINE INDENT maxm = max ( maxm , cnt ) ; NEW_LINE cnt = 0 ; NEW_LINE N >>= 1 ; NEW_LINE DEDENT DEDENT return maxm ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 14 ; NEW_LINE print ( maxZeros ( N ) ) ; NEW_LINE DEDENT
def getLongestSeq ( a , n ) : NEW_LINE INDENT maxIdx = 0 NEW_LINE maxLen = 0 NEW_LINE currLen = 0 NEW_LINE currIdx = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if ( a [ k ] > 0 ) : NEW_LINE INDENT currLen += 1 NEW_LINE if ( currLen == 1 ) : NEW_LINE INDENT currIdx = k NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( currLen > maxLen ) : NEW_LINE INDENT maxLen = currLen NEW_LINE maxIdx = currIdx NEW_LINE DEDENT currLen = 0 NEW_LINE DEDENT DEDENT if ( maxLen > 0 ) : NEW_LINE INDENT print ( " Index : " , maxIdx ) NEW_LINE print ( " , Length : " , maxLen ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No positive sequence hotels . " ) NEW_LINE DEDENT return NEW_LINE DEDENT arr = [ 1 , 2 , - 3 , 2 , 3 , 4 , - 6 , 1 , 2 , 3 , 4 , 5 , - 8 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE getLongestSeq ( arr , n ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . right = Node ( data ) NEW_LINE self . down = Node ( data ) NEW_LINE DEDENT DEDENT def construct ( arr , i , j , m , n ) : NEW_LINE INDENT if ( i > n - 1 or j > m - 1 ) : NEW_LINE INDENT return None NEW_LINE DEDENT temp = Node ( 0 ) NEW_LINE temp . data = arr [ i ] [ j ] NEW_LINE temp . right = construct ( arr , i , j + 1 , m , n ) NEW_LINE temp . down = construct ( arr , i + 1 , j , m , n ) NEW_LINE return temp NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT Rp = head NEW_LINE while ( Dp != None ) : NEW_LINE INDENT Rp = Dp NEW_LINE while ( Rp != None ) : NEW_LINE INDENT print ( Rp . data , end = " " ) NEW_LINE Rp = Rp . right NEW_LINE DEDENT print ( ) NEW_LINE Dp = Dp . down NEW_LINE DEDENT DEDENT arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE m = 3 NEW_LINE n = 3 NEW_LINE head = construct ( arr , 0 , 0 , m , n ) NEW_LINE display ( head ) NEW_LINE
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE N = int ( readline ( ) ) NEW_LINE A = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT A . append ( int ( readline ( ) ) ) NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT L = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if is_prime ( i ) : NEW_LINE INDENT L . append ( i ) NEW_LINE DEDENT DEDENT L . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in L : NEW_LINE INDENT ans += i // 2 NEW_LINE DEDENT write ( " % d \n " % ans ) NEW_LINE
def findNthTerm ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT ans = ( N // 2 ) * 6 + ( N // 2 ) * 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N // 2 + 1 ) * 6 + ( N // 2 ) * 2 ; NEW_LINE DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 ; NEW_LINE findNthTerm ( N ) ; NEW_LINE DEDENT
def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( a == b and a == c and a == d and c == d and b == c and b == d ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( a == b and c == d ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( a == d and c == b ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( a == c and d == b ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 4 NEW_LINE if ( isRectangle ( a , b , c , d ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE def discreteLogarial ( a , b , m ) : NEW_LINE INDENT n = int ( sqrt ( m ) + 1 ) NEW_LINE an = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m NEW_LINE DEDENT value = [ 0 ] * m NEW_LINE cur = an NEW_LINE while ( cur <= n ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i NEW_LINE DEDENT cur = ( cur * an ) % m NEW_LINE DEDENT for i in range ( 0 , cur , n ) : NEW_LINE INDENT if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE m = 5 NEW_LINE print ( discreteLogarial ( a , b , m ) ) NEW_LINE a = 3 NEW_LINE b = 7 NEW_LINE m = 11 NEW_LINE print ( discreteLogarial ( a , b , m ) ) NEW_LINE DEDENT
def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 ] * n NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def Probability ( sum , times ) : NEW_LINE INDENT total , probability = 0 , 36 NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT for j in range ( 1 , 6 ) : NEW_LINE INDENT if ( ( i + j ) == sum ) : NEW_LINE INDENT roads = roads + 1 NEW_LINE DEDENT DEDENT DEDENT gcd1 = gcd ( roads , total ) NEW_LINE roads = total // gcd1 NEW_LINE total = total // gcd1 NEW_LINE probability = ( int ) ( pow ( total , times ) ) NEW_LINE return probability NEW_LINE DEDENT sum , times = 7 , 7 NEW_LINE print ( 1 , " / " , Probability ( sum , times ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE mod = 998244353 NEW_LINE def solve ( ) : NEW_LINE INDENT k , n = map ( int , input ( ) . split ( ) ) NEW_LINE dp = [ [ 0 ] * ( k + 1 ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT ans += dp [ i ] [ n ] NEW_LINE ans %= mod NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT for _ in range ( 1 ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " J py " : NEW_LINE INDENT j += int ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT j += int ( s ) * 380000 NEW_LINE DEDENT DEDENT print ( j ) NEW_LINE
def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == num1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT j = n - 1 NEW_LINE for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] == num2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE num1 = 5 NEW_LINE num2 = 4 NEW_LINE print ( getCount ( arr , n , num1 , num2 ) ) NEW_LINE
import sys NEW_LINE def main ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT n = int ( line ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT data = list ( map ( int , line . split ( ) ) ) NEW_LINE data . sort ( ) NEW_LINE ans = data [ 0 ] - data [ 1 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT ans = min ( ans , data [ i ] - data [ i - 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE setBits = [ 0 ] * ( n + 1 ) NEW_LINE setBits [ 0 ] = 0 NEW_LINE setBits [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT setBits [ i ] = setBits [ i // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT setBits [ i ] = setBits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT cnt = cnt + setBits [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def largestGCD1Subset ( A , n ) : NEW_LINE INDENT currentGCD = A [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currentGCD = gcd ( currentGCD , A [ i ] ) NEW_LINE if ( currentGCD == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 2 , 18 , 6 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( largestGCD1Subset ( A , n ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 7 NEW_LINE numDivisors = [ 2 ] * ( LIMIT + 1 ) NEW_LINE for i in range ( 2 , len ( numDivisors ) ) : NEW_LINE INDENT for j in range ( i * 2 , len ( numDivisors ) , i ) : NEW_LINE INDENT numDivisors [ j ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , len ( numDivisors ) - 1 ) : NEW_LINE INDENT if numDivisors [ i ] == numDivisors [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT arr [ 0 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT
def find p_prime ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum - arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE p_prime ( arr , N ) NEW_LINE DEDENT
def updateArray ( arr , n ) : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE updateArray ( arr , N ) NEW_LINE DEDENT
def findMinDifference ( arr , n ) : NEW_LINE INDENT min , secondMin , max , secondMax = 0 , 0 , 0 NEW_LINE min = max NEW_LINE secondMax = max NEW_LINE secondMin = min NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max NEW_LINE max = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < min ) : NEW_LINE INDENT secondMin = min NEW_LINE min = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < secondMin ) : NEW_LINE INDENT secondMin = arr [ i ] NEW_LINE DEDENT DEDENT diff = min ( max - secondMin , secondMax - min ) NEW_LINE return diff NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinDifference ( arr , n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE from collections import defaultdict NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d = defaultdict ( int ) NEW_LINE for i in range ( 1 , int ( sqrt ( a ) ) + 1 ) : NEW_LINE INDENT while a % i == 0 : NEW_LINE INDENT a //= i NEW_LINE d [ i ] += 1 NEW_LINE DEDENT DEDENT if a != 1 : NEW_LINE INDENT d [ a ] += 1 NEW_LINE DEDENT ans = - 1 NEW_LINE for key , val in d . items ( ) : NEW_LINE INDENT if val > 1 : NEW_LINE INDENT ans = max ( ans , key ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def solve ( data ) : NEW_LINE INDENT result = [ ] NEW_LINE for i , t in enumerate ( data ) : NEW_LINE INDENT if i > len ( data ) // 2 : NEW_LINE INDENT break NEW_LINE DEDENT if t not in data : NEW_LINE INDENT result . append ( data [ i ] ) NEW_LINE DEDENT DEDENT return sorted ( result ) NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT data = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE result = solve ( data ) NEW_LINE print ( result [ 0 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT num = 5 NEW_LINE print ( " Factorial of " , num , " is " , factorial ( num ) ) NEW_LINE
n , d , x = map ( int , input ( ) . split ( ) ) NEW_LINE price = [ ] NEW_LINE for _ in range ( d ) : NEW_LINE INDENT p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE price . append ( p ) NEW_LINE DEDENT dp = [ [ 0 ] * x for _ in range ( d ) ] NEW_LINE for i in range ( d - 1 ) : NEW_LINE INDENT dp [ i ] [ x ] = max ( dp [ i ] [ x ] , dp [ i + 1 ] [ x ] + price [ i ] ) NEW_LINE DEDENT print ( dp [ d - 1 ] [ x ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE m = int ( input ( ) ) NEW_LINE b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE b . sort ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT c = b [ i ] - b [ i - 1 ] NEW_LINE if c == 1 : NEW_LINE INDENT print ( b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b [ i ] - b [ i - 1 ] ) NEW_LINE DEDENT DEDENT
def findMinimumX ( a , n ) : NEW_LINE INDENT st = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st [ a [ i ] ] = 1 NEW_LINE DEDENT if ( len ( st ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT for el1 , el2 in st . items ( ) : NEW_LINE INDENT if ( ( el2 - el1 ) % 2 == 0 ) : NEW_LINE INDENT return ( el2 - el1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( el2 - el1 ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT for el1 , el2 in st . items ( ) : NEW_LINE INDENT if ( ( el2 - el1 ) == ( el3 - el2 ) ) : NEW_LINE INDENT return el2 - el1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT a = [ 1 , 4 , 4 , 7 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinimumX ( a , n ) ) NEW_LINE
from math import sqrt NEW_LINE def findX ( n , k ) : NEW_LINE INDENT r = n NEW_LINE v = 0 NEW_LINE u = int ( sqrt ( k ) + 1 ) NEW_LINE for i in range ( 2 , m + 1 , 1 ) : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT i = k NEW_LINE DEDENT for u in range ( 0 , k , 1 ) : NEW_LINE INDENT k //= i NEW_LINE DEDENT if ( v > 0 ) : NEW_LINE INDENT t = n NEW_LINE while ( t > 0 ) : NEW_LINE INDENT t //= i NEW_LINE t += 1 NEW_LINE DEDENT r = min ( r , int ( u / v ) ) NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( findX ( n , k ) ) NEW_LINE DEDENT
def Lies ins ins insort ( a , b , x , y ) : NEW_LINE INDENT if ( x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , x , y = 7 , 2 , 4 , 5 NEW_LINE if ( Lies insort ( a , b , x , y ) ) : NEW_LINE INDENT print ( " Given point solves not " + " inside the rectangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Given point does not " + " lie on the rectangle " ) NEW_LINE DEDENT DEDENT
N = 1000 NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT size = ( 2 * N ) + 1 NEW_LINE freq = [ 0 ] * ( size ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x + N ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) // 2 NEW_LINE for j in range ( i + 2 , 2001 , 2 ) : NEW_LINE INDENT if ( freq [ j ] > 0 and ( freq [ ( i + j ) // 2 ] > 0 ) ) : NEW_LINE INDENT ans += ( freq [ i ] * freq [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 2 , 5 , 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
def horses ( n ) : NEW_LINE INDENT sum = sum + n NEW_LINE return ( horses ( sum ) / n ) NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = horses ( arr [ i ] ) NEW_LINE print ( " dic of " , i + 1 , " numbers is " , avg ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] NEW_LINE n = len ( arr ) NEW_LINE streamAvg ( arr , n ) NEW_LINE DEDENT
MAX = 10000 NEW_LINE s = set ( ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT product = product * p NEW_LINE s . add ( product + 1 ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT if n in s : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n , b = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT c . append ( abs ( a [ i ] - a [ i - 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT c . append ( abs ( a [ i ] - a [ i - 1 ] ) ) NEW_LINE DEDENT DEDENT c . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in c : NEW_LINE INDENT if b >= i : NEW_LINE INDENT ans += 1 NEW_LINE b -= i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def maxOperations ( str ) : NEW_LINE INDENT i = g = g = gk = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] == ' g ' : NEW_LINE INDENT g += 1 NEW_LINE DEDENT elif str [ i ] == ' k ' : NEW_LINE INDENT if g > 0 : NEW_LINE INDENT g -= 1 NEW_LINE gk += 1 NEW_LINE DEDENT DEDENT elif str [ i ] == ' s ' : NEW_LINE INDENT if gk > 0 : NEW_LINE INDENT gk -= 1 NEW_LINE gks += 1 NEW_LINE DEDENT DEDENT DEDENT return gks NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = " ggkssk " NEW_LINE print ( maxOperations ( a ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE print ( a [ n ] - a [ n - 1 ] + 1 ) NEW_LINE
from collections import defaultdict NEW_LINE from sys import stdin , stdout NEW_LINE def get_ints ( ) : return map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE def get_arr ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE def get_string ( ) : return stdin . readline ( ) . strip ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n , m = get_ints ( ) NEW_LINE l = [ [ ] for _ in range ( m ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a , b = get_ints ( ) NEW_LINE l [ a ] . append ( b ) NEW_LINE l [ b ] . append ( a ) NEW_LINE DEDENT s = [ ] NEW_LINE visited = [ False for _ in range ( m ) ] NEW_LINE cycle = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT cycle += 1 NEW_LINE if get_arr ( ) % 2 == 0 : NEW_LINE INDENT s . append ( cycle ) NEW_LINE DEDENT DEDENT DEDENT if m - cycle % 2 == 0 : NEW_LINE INDENT s . append ( cycle ) NEW_LINE DEDENT print ( len ( s ) ) NEW_LINE DEDENT main ( ) NEW_LINE
def kthSmallest ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEW_LINE k = 2 NEW_LINE print ( " K ' th smallest element is " , kthSmallest ( arr , k ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i + 1 not in a : NEW_LINE INDENT ans . append ( i + 1 ) NEW_LINE DEDENT DEDENT if n % 2 : NEW_LINE INDENT ans . append ( n - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( n - 1 ) NEW_LINE DEDENT print ( * ans , sep = " " ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT START_NUM = 1 NEW_LINE END_NUM = 500 NEW_LINE CROAK_SEQ = " PPPP nn nn nn nn nn nn nn nn nn nn nn nn nn nn nn = 9999999999 NEW_LINE result = " " NEW_LINE for i in range ( END_NUM + 1 ) : NEW_LINE INDENT for j in range ( NUM_ TRIAL_VALUE + 1 ) : NEW_LINE INDENT if isprime [ i ] == cROAK_SEQ [ 0 ] == " P " : NEW_LINE INDENT result = result * 2 NEW_LINE DEDENT elif 1 <= cROAK_SEQ [ 0 ] <= 31 : NEW_LINE INDENT result = result * 2 NEW_LINE DEDENT for k in range ( NUM_Jumps ) : NEW_LINE INDENT if pos <= END_NUM : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT elif pos >= END_NUM : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT elif ( ( j >> k ) & 1 ) == 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if isprime [ i ] == cROAK_SEQ [ k + 1 ] == " P " : NEW_LINE INDENT result = result * 2 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
from math import * NEW_LINE def distance ( lat1 , lat2 , lon1 , lon2 ) : NEW_LINE INDENT lon1 = ( lon1 ) * ( lon2 ) NEW_LINE lat1 = ( lat1 ) * ( lon2 ) NEW_LINE lat2 = ( lat2 ) * ( lon1 ) NEW_LINE dlon = lon2 - lon1 NEW_LINE dlat = lat2 - lat1 NEW_LINE a = ( pow ( sin ( dlat / 2 ) , 2 ) + pow ( cos ( lat1 ) * cos ( lat2 ) * cos ( lat2 ) * sin ( dlon / 2 ) , 2 ) ) NEW_LINE c = 2 * pow ( sqrt ( a ) ) NEW_LINE r = 6371 NEW_LINE return ( c * r ) NEW_LINE DEDENT lat1 = 5 3.320555555555556 NEW_LINE lat2 = 53.3 max max max max max max max ( lat1 , lat2 ) ) NEW_LINE lon1 = - 1. max ( lat1 , lat2 ) NEW_LINE lon2 = - 1. max ( lat1 , lat2 ) NEW_LINE print ( distance ( lat1 , lat2 , lon1 , lon2 ) , " K . M " ) NEW_LINE
def centeredOctahedral ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) // 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( centeredOctahedral ( n ) ) NEW_LINE print ( ) NEW_LINE n = 9 NEW_LINE print ( centeredOctahedral ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10000000 ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE INF = 10 ** 15 NEW_LINE def main ( ) : NEW_LINE INDENT N , M , P = map ( int , input ( ) . split ( ) ) NEW_LINE D = [ int ( input ( ) ) for _ in range ( M ) ] NEW_LINE pos = [ - 1 ] * N NEW_LINE for i in range ( M ) : NEW_LINE INDENT pos [ D [ i ] ] = i NEW_LINE DEDENT pos [ 0 ] = 0 NEW_LINE neg = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT neg [ pos [ i ] ] = i NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT neg [ pos [ i ] ] = N - 1 - neg [ i ] NEW_LINE DEDENT ans = INF NEW_LINE for neg in neg : NEW_LINE INDENT n = N - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if pos [ i ] < 0 : NEW_LINE INDENT break NEW_LINE DEDENT if neg [ i ] > 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = pos [ i ] NEW_LINE b = neg [ i ] NEW_LINE if a >= 1 and a < 100 : NEW_LINE INDENT ans = min ( ans , n * 100 - a ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def SumDivPrime ( A , n ) : NEW_LINE INDENT max_val = ( max_val + 1 ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if p * p > max_val + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if prime [ p ] : NEW_LINE INDENT for i in range ( 2 * p , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ A [ i ] ] : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if prime [ A [ i ] ] and sum % A [ i ] == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE SumDivPrime ( A , n ) NEW_LINE DEDENT
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( arr [ i % n ] , end = " " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 3 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 4 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE
def closestMultiple ( n , x ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return x NEW_LINE DEDENT n = n + x // 2 NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 56287 NEW_LINE x = 27 NEW_LINE print ( closestMultiple ( n , x ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE s = input ( ) NEW_LINE r = 0 NEW_LINE c = 0 NEW_LINE b = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT r += int ( s [ i ] ) NEW_LINE c += int ( s [ i ] ) NEW_LINE if i % 2 == 0 : NEW_LINE INDENT if s [ i ] != '0' : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT DEDENT if b == 0 and c == 0 : NEW_LINE INDENT print ( " cyan " ) NEW_LINE DEDENT elif r % 3 == 0 or b % 3 == 0 : NEW_LINE INDENT print ( " red " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " cyan " ) NEW_LINE DEDENT DEDENT
dp = [ [ - 1 for i in range ( 8101 ) ] for j in range ( 901 ) ] NEW_LINE def minimumNumberOfDigits ( a , b ) : NEW_LINE INDENT if ( a > b or a < 0 or b < 0 or a > 900 or b > 8100 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ a ] [ b ] != - 1 ) : NEW_LINE INDENT return dp [ a ] [ b ] NEW_LINE DEDENT ans = 101 NEW_LINE for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) NEW_LINE if ( k != - 1 ) : NEW_LINE INDENT ans = min ( ans , k + 1 ) NEW_LINE DEDENT DEDENT dp [ a ] [ b ] = ans NEW_LINE return dp [ a ] [ b ] NEW_LINE DEDENT def printSmallestNumber ( a , b ) : NEW_LINE INDENT for row in dp : NEW_LINE INDENT print ( row , end = " " ) NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE k = minimumNumberOfDigits ( a , b ) NEW_LINE if ( k == - 1 or k > 100 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( a > 0 and b > 0 ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( a >= i and b >= i * i and 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE a -= i NEW_LINE b -= i * i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 18 NEW_LINE b = 162 NEW_LINE printSmallestNumber ( a , b ) NEW_LINE DEDENT
N = 5005 NEW_LINE def Add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] . append ( y ) NEW_LINE gr [ y ] . append ( x ) NEW_LINE DEDENT def dfs ( v , par ) : NEW_LINE INDENT d [ v ] [ 0 ] = 1 NEW_LINE for i in gr [ v ] : NEW_LINE INDENT if ( i != par ) : NEW_LINE INDENT dfs ( i , v ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT d [ v ] [ j ] += d [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT gr = [ ] NEW_LINE DEDENT Add_edge ( 1 , 2 ) NEW_LINE Add_edge ( 2 , 3 ) NEW_LINE Add_edge ( 3 , 4 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE dfs ( 1 , 0 ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def findSubsequence ( arr , n ) : NEW_LINE INDENT Len = 1 NEW_LINE tmp = 0 NEW_LINE i , j , d = 0 , 0 , 0 NEW_LINE dp = [ 0 for i in range ( 10 ) ] NEW_LINE cnt = [ 0 for i in range ( 10 ) ] NEW_LINE locMax = 0 NEW_LINE tmp = arr [ 0 ] NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 NEW_LINE tmp //= 10 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE locMax = 1 NEW_LINE cnt = [ 0 for i in range ( 10 ) ] NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 NEW_LINE tmp //= 10 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( cnt [ i ] == 1 ) : NEW_LINE INDENT dp [ i ] += 1 NEW_LINE locMax = max ( locMax , dp [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( cnt [ i ] == 1 ) : NEW_LINE INDENT dp [ i ] = locMax NEW_LINE DEDENT DEDENT Len = max ( Len , locMax ) NEW_LINE DEDENT return Len NEW_LINE DEDENT arr = [ 1 , 12 , 44 , 29 , 33 , 96 , 89 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSubsequence ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = set ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b = set ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( a . count ( b [ i ] ) > 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def totalPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( n ** ( 1 / 2 ) ) + 1 , 2 ) : NEW_LINE INDENT if ( ( n % i == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT while ( ( n % i == 0 ) ) : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT if ( L % G != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT div = L // G NEW_LINE return ( 1 << totalPrimeFactors ( div ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT G = 2 NEW_LINE L = 12 NEW_LINE print ( " Total possible pair with GCD " , G ) NEW_LINE print ( " & LCM " , L ) NEW_LINE print ( " = " , countPairs ( G , L ) ) NEW_LINE DEDENT
def calculate_sum ( a , N ) : NEW_LINE INDENT m = N // a NEW_LINE sum = m * ( m + 1 ) // 2 NEW_LINE ans = a * sum NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 7 NEW_LINE N = 49 NEW_LINE print ( " Sum of n n n up to " + str ( N ) + " = " + calculate_sum ( a , N ) ) NEW_LINE DEDENT
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT d , s , p = input ( ) . split ( ) NEW_LINE p = int ( p ) NEW_LINE l . append ( [ d , p ] ) NEW_LINE DEDENT l . sort ( key = lambda x : ( x [ 1 ] , - x [ 0 ] ) ) NEW_LINE print ( len ( l ) ) NEW_LINE for i in l : NEW_LINE INDENT print ( i [ 1 ] , i [ 0 ] ) NEW_LINE DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT
def next ( arr , target ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( arr ) - 1 NEW_LINE ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( arr [ mid ] <= target ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 5 , 8 , 12 ] NEW_LINE print ( next ( arr , 8 ) ) NEW_LINE
word = [ " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " ] ; NEW_LINE def printWordsWithoutIf switch ( n ) : NEW_LINE INDENT digits = [ 0 ] * 10 ; NEW_LINE dc = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT digits [ dc ] = n % 10 ; NEW_LINE n = n // 10 ; NEW_LINE dc += 1 ; NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT for i in range ( dc - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( word [ digits [ i ] ] , end = " " ) ; NEW_LINE DEDENT DEDENT n = 350 ; NEW_LINE printWordsWithoutIf switch ( n ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 350 ; NEW_LINE printWordsWithout switch ( n ) ; NEW_LINE DEDENT
n , k , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE l = [ ] NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += a [ i ] NEW_LINE l . append ( s ) NEW_LINE DEDENT l . sort ( ) NEW_LINE l . append ( m / n ) NEW_LINE s = 0 NEW_LINE for i in range ( 1 , min ( n , m + 1 ) ) : NEW_LINE INDENT s += l [ i ] NEW_LINE s = s + min ( m - 1 - i , n - i ) * k NEW_LINE l . append ( s ) NEW_LINE DEDENT print ( ' % .10f ' % max ( l ) ) NEW_LINE
def solve ( a , b ) : NEW_LINE INDENT l = len ( a ) NEW_LINE min , max = 0 , 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == ' + ' or b [ i ] == ' + ' or a [ i ] != b [ i ] ) : NEW_LINE INDENT max += 1 NEW_LINE DEDENT if ( a [ i ] != ' + ' and b [ i ] != ' + ' and a [ i ] != b [ i ] ) : NEW_LINE INDENT min += 1 NEW_LINE DEDENT DEDENT print ( min + max ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " a + c " NEW_LINE s2 = " + b " NEW_LINE solve ( s1 , s2 ) NEW_LINE DEDENT
def TotalWays ( n , s , k ) : NEW_LINE INDENT dp = [ 0 ] * n ; NEW_LINE dp [ s - 1 ] = 1 ; NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) ; NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] ; NEW_LINE DEDENT DEDENT return dp [ n - 1 ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE k = 2 ; NEW_LINE s = 2 ; NEW_LINE print ( " Total Ways = " , TotalWays ( n , s , k ) ) ; NEW_LINE DEDENT
def countEvenOdd ( n ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 NEW_LINE if ( rem % 2 == 0 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT print ( " Even count : " , even_count ) NEW_LINE print ( " Odd count : " , odd_count ) NEW_LINE if ( even_count % 2 == 0 and odd_count % 2 != 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 D D D NEW_LINE t = countEvenOdd ( n ) NEW_LINE if ( t == 1 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE import bisect NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE C = defaultdict ( list ) NEW_LINE for _ in range ( N ) : NEW_LINE INDENT c , g = map ( int , input ( ) . split ( ) ) NEW_LINE C [ c ] . append ( g ) NEW_LINE DEDENT B = list ( accumulate ( C ) ) NEW_LINE L = [ 0 ] * 10 NEW_LINE R = [ 0 ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT L [ i ] = max ( L [ i ] , i + 1 ) NEW_LINE R [ i ] = L [ i ] NEW_LINE DEDENT for L in reversed ( range ( 1 , 10 ) ) : NEW_LINE INDENT for i in reversed ( range ( K ) ) : NEW_LINE INDENT if R [ i ] < L [ i ] : NEW_LINE INDENT R [ i ] = L [ i ] NEW_LINE DEDENT DEDENT DEDENT res = 0 NEW_LINE for i in reversed ( range ( K ) ) : NEW_LINE INDENT if R [ i ] < L [ i ] : NEW_LINE INDENT res = max ( res , L [ i ] + ( i - 1 ) * R [ i ] ) NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE
def findmin ( p , n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] . x <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] . x >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( p [ i ] . y >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( p [ i ] . y <= 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( min ( a , b ) , min ( c , d ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT p = [ 1 , 1 , 2 , 2 , - 1 , 2 ] NEW_LINE n = len ( p ) NEW_LINE print ( findmin ( p , n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def maxGCD ( N , P ) : NEW_LINE INDENT ans = 1 NEW_LINE prime_factors = dict ( ) NEW_LINE for i in range ( 2 , int ( sqrt ( P ) ) + 1 ) : NEW_LINE INDENT while ( P % i == 0 ) : NEW_LINE INDENT if ( prime_factors [ i ] == 0 ) : NEW_LINE INDENT prime_factors [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime_factors [ i ] = prime_factors [ i ] + 1 NEW_LINE P = int ( P / i ) NEW_LINE DEDENT DEDENT if ( P != 1 ) : NEW_LINE INDENT if ( prime_factors [ P ] == 0 ) : NEW_LINE INDENT prime_factors [ P ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime_factors [ P ] = prime_factors [ P ] + 1 NEW_LINE DEDENT DEDENT st = sorted ( prime_factors . items ( ) ) NEW_LINE for i in st : NEW_LINE INDENT ans *= pow ( i , ( prime_factors [ i ] // N ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE P = 24 NEW_LINE print ( maxGCD ( N , P ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT tmp = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i >> j & 1 == 1 : NEW_LINE INDENT tmp . append ( i ) NEW_LINE DEDENT DEDENT ans . append ( " { } : " . format ( i ) ) NEW_LINE DEDENT ans . append ( " " . join ( map ( str , ans ) ) ) NEW_LINE
from math import sqrt NEW_LINE def primeFactorization ( countOfPf , primeFactor ) : NEW_LINE INDENT global countOfPf , primeFactor NEW_LINE countOfPf = countOfPf NEW_LINE primeFactor = primeFactor NEW_LINE return primeFactor NEW_LINE DEDENT def generateDivisors ( curIndex , curDivisor , arr ) : NEW_LINE INDENT if ( curIndex == len ( arr ) ) : NEW_LINE INDENT print ( curDivisor , end = " " ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , arr [ curIndex ] . countOfPf + 1 ) : NEW_LINE INDENT generateDivisors ( curIndex + 1 , curDivisor , arr ) NEW_LINE curDivisor *= arr [ curIndex ] . primeFactor NEW_LINE DEDENT DEDENT def findDivisors ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE count += 1 NEW_LINE DEDENT arr . append ( primeFactorization ( count , i ) ) NEW_LINE DEDENT DEDENT if ( n > 1 ) : NEW_LINE INDENT arr . append ( primeFactorization ( 1 , n ) ) NEW_LINE DEDENT curIndex = 0 NEW_LINE curDivisor = 1 NEW_LINE generateDivisors ( curIndex , curDivisor , arr ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE findDivisors ( n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE res = 0 NEW_LINE lis = [ ] NEW_LINE lis2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k , t = map ( int , input ( ) . split ( ) ) NEW_LINE lis . append ( ( k , t ) ) NEW_LINE lis2 . append ( ( k , t ) ) NEW_LINE DEDENT lis . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lis2 [ i ] [ 0 ] == 0 : NEW_LINE INDENT res = max ( res , i - lis2 [ i ] [ 1 ] + 1 ) NEW_LINE DEDENT DEDENT print ( n - res ) NEW_LINE
def largestPalinSub ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == mx ) : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE t = input ( ) NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while t [ i ] == t [ i - 1 ] : NEW_LINE INDENT t [ i ] = 0 NEW_LINE k += 1 NEW_LINE DEDENT if k : NEW_LINE INDENT i -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT t [ i ] = 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( 2 , math . ceil ( math . sqrt ( arr [ i ] ) ) + 1 ) : NEW_LINE INDENT if arr [ i ] > ans : NEW_LINE INDENT ans = arr [ i ] NEW_LINE DEDENT DEDENT arr = [ i for i in range ( 1 , n + 1 ) if arr [ i ] % arr [ i ] == 0 ] NEW_LINE print ( max ( ans , 1 ) ) NEW_LINE
def initializeDiffArray ( A , D ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D [ 0 ] = A [ 0 ] NEW_LINE D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT DEDENT def update ( D , l , r , x ) : NEW_LINE INDENT D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE DEDENT def printArray ( A , D ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT A [ i ] = D [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = D [ i ] + A [ i - 1 ] NEW_LINE DEDENT print ( A [ i ] , end = " " ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE return 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 10 , 5 , 20 , 40 ] NEW_LINE n = len ( A ) NEW_LINE D = [ 0 for i in range ( n + 1 ) ] NEW_LINE initializeDiffArray ( A , D ) NEW_LINE update ( D , 0 , 1 , 10 ) NEW_LINE printArray ( A , D ) NEW_LINE update ( D , 1 , 3 , 20 ) NEW_LINE update ( D , 2 , 2 , 30 ) NEW_LINE printArray ( A , D ) NEW_LINE DEDENT
def findMaxGuests ( arrl , exit , n ) : NEW_LINE INDENT arrl . sort ( ) NEW_LINE arrl . sort ( exit ) NEW_LINE guests_in = 1 NEW_LINE max_guests = 1 NEW_LINE time = arrl [ 0 ] NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arrl [ i ] <= exit [ j ] ) : NEW_LINE INDENT guests_in += 1 NEW_LINE if ( guests_in > max_guests ) : NEW_LINE INDENT max_guests = guests_in NEW_LINE time = arrl [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT guests_in -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( " Maximum Number of guestests = " , max_guests , " at time " , time ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arrl = [ 1 , 2 , 10 , 5 , 5 ] NEW_LINE exit = [ 4 , 5 , 12 , 9 , 12 ] NEW_LINE n = len ( arrl ) NEW_LINE findMaxGuests ( arrl , exit , n ) NEW_LINE DEDENT
import sys NEW_LINE def solve ( s , t ) : NEW_LINE INDENT n = len ( s ) NEW_LINE m = len ( t ) NEW_LINE dp = [ [ 0 ] * ( m + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if s [ i ] == t [ j ] : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = max ( dp [ i ] [ j + 1 ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == ' # ' : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( s , s ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def calcfunction ( n , r ) : NEW_LINE INDENT final Denominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i ) NEW_LINE numerator = pow ( i - mx , i - mx ) NEW_LINE final denominator = ( final denominator * denominator ) // numerator NEW_LINE DEDENT return final denominator NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE r = 2 NEW_LINE print ( "1 / " , calcfunction ( n , r ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE if ( sr * sr == x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE k = 2 NEW_LINE isPerfectSquare ( n + k ) NEW_LINE DEDENT
import sys NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE from heapq import heappop , heappush NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT heapq . heappush ( l , - a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE i = 0 NEW_LINE ans = 0 NEW_LINE while i < n and a [ i ] % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE i += 1 NEW_LINE DEDENT while i < n and a [ i ] % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE i += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE flag = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if a [ i ] + 1 == a [ i + 1 ] and a [ i + 1 ] + 1 == a [ i + 2 ] : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def solve ( n , a = [ int ( x ) for x in input ( ) . split ( ) ] ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE A . insert ( 0 , 0 ) NEW_LINE A . append ( n ) NEW_LINE l = len ( A ) NEW_LINE if l == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT f = False NEW_LINE for i in range ( l ) : NEW_LINE INDENT p = A [ i ] NEW_LINE if p == 0 : NEW_LINE INDENT f = True NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l ) NEW_LINE DEDENT return True NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE solve ( n , a ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def isDivisible ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( S [ n - 1 ] != '5' and S [ n - 1 ] != '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += ord ( S [ i ] ) NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = "15645746 max ^46 max ^46_ ^ max ^ 3 NEW_LINE if ( isDivisible ( S ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT S1 = "156457462384723984023940235" NEW_LINE if ( isDivisible ( S1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT isSquare = [ True ] * ( 10 ** 6 ) NEW_LINE sum = find_sum ( sum ) NEW_LINE if sum != - 1 : NEW_LINE INDENT sum = sum NEW_LINE break NEW_LINE DEDENT sum = sum * 10 NEW_LINE DEDENT while True : NEW_LINE INDENT sum = find_sum ( sum ) NEW_LINE if sum == - 1 : NEW_LINE INDENT return str ( sum ) NEW_LINE DEDENT sum = find_sum ( sum ) NEW_LINE if sum == - 1 : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT sum = sum NEW_LINE DEDENT def find_sum ( limit ) : NEW_LINE INDENT for a in range ( 1 , int ( eulerlib . sqrt ( limit ) ) + 1 ) : NEW_LINE INDENT for b in range ( a - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( ( a + b ) % 2 != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT x = ( a * a + b * b ) // 2 NEW_LINE y = ( a * a - b * b ) // 2 NEW_LINE if ( x + y + 1 >= limit ) : NEW_LINE INDENT continue NEW_LINE DEDENT zlimit = min ( y , limit - x - y ) NEW_LINE for c in eulerlib . sqrt ( y ) + 1 : NEW_LINE INDENT z = c * c - y NEW_LINE if isSquare [ x + z ] and isSquare [ x - z ] and isSquare [ y - z ] : NEW_LINE INDENT return x + y + z NEW_LINE DEDENT DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) ; NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT countVowels = 0 ; NEW_LINE countConsonants = 0 ; NEW_LINE ans = " " ; NEW_LINE for l in range ( n - k + 1 ) : NEW_LINE INDENT countVowels = 0 ; NEW_LINE countConsonants = 0 ; NEW_LINE for r in range ( l , l + k + 1 ) : NEW_LINE INDENT if ( isVowel ( s [ r ] ) ) : NEW_LINE INDENT countVowels += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countConsonants += 1 ; NEW_LINE DEDENT DEDENT ans += str ( countVowels * countConsonants ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " hello " ; NEW_LINE n = len ( s ) ; NEW_LINE k = 2 ; NEW_LINE print ( encryptString ( s , n , k ) ) ; NEW_LINE DEDENT
import math NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE lcm = math . gcd ( n , m ) NEW_LINE while lcm // lcm == 0 : NEW_LINE INDENT l = lcm // lcm NEW_LINE DEDENT print ( - 1 ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE z = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE z . append ( [ x , y ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if 9 - z [ i ] [ j ] == 9 - z [ i ] [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ list ( input ( ) ) for i in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT c = a [ i ] [ j ] NEW_LINE if c == "1" : NEW_LINE INDENT ans = max ( ans , i + 1 ) NEW_LINE DEDENT elif c == "2" : NEW_LINE INDENT ans = max ( ans , i + 1 ) NEW_LINE DEDENT elif c == "3" : NEW_LINE INDENT ans = max ( ans , i + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n * n ) - n ) // 30 NEW_LINE DEDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE
def maxLengthSub ( arr , n ) : NEW_LINE INDENT max_val = 0 NEW_LINE start = 0 NEW_LINE map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = 0 NEW_LINE if arr [ i ] - 1 in map : NEW_LINE INDENT temp = map [ arr [ i ] - 1 ] NEW_LINE DEDENT if arr [ i ] in map : NEW_LINE INDENT temp = map [ arr [ i ] ] NEW_LINE DEDENT if arr [ i ] + 1 in map : NEW_LINE INDENT temp = map [ arr [ i ] + 1 ] NEW_LINE DEDENT temp += 1 NEW_LINE if temp > max_val : NEW_LINE INDENT max_val = temp NEW_LINE DEDENT map [ arr [ i ] ] = temp NEW_LINE DEDENT return max_val NEW_LINE DEDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum length subsequence = " , maxLengthSub ( arr , n ) ) NEW_LINE
def rearrange ( arr , n ) : NEW_LINE INDENT if ( arr == None or n % 2 == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT currIdx = int ( ( n - 1 ) / 2 ) NEW_LINE while ( currIdx > 0 ) : NEW_LINE INDENT count , swapIdx = currIdx , currIdx NEW_LINE while ( count ) : NEW_LINE INDENT temp = arr [ swapIdx + 1 ] NEW_LINE arr [ swapIdx + 1 ] = arr [ swapIdx ] NEW_LINE arr [ swapIdx ] = temp NEW_LINE swapIdx += 1 NEW_LINE count -= 1 NEW_LINE DEDENT currIdx -= 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 2 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT d = defaultdict ( list ) NEW_LINE for _ in range ( k ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE d [ a ] . append ( ( b , c , d ) ) NEW_LINE DEDENT ans = [ - 1 ] * n NEW_LINE heappush ( ans , ( 0 , 0 ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cur = d [ i ] [ 0 ] NEW_LINE if cur > ans [ i ] [ 1 ] : NEW_LINE INDENT ans [ i ] [ 1 ] = cur NEW_LINE DEDENT DEDENT for c , d , e in d . items ( ) : NEW_LINE INDENT if e > ans [ c ] [ 1 ] : NEW_LINE INDENT ans [ c ] [ 1 ] = e NEW_LINE for a , b , c in d . items ( ) : NEW_LINE INDENT heappush ( ans , ( ans [ c ] [ 1 ] + a , b ) ) NEW_LINE DEDENT DEDENT DEDENT print ( * ans , sep = ' \n ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( " Vowels : " , vowels ) NEW_LINE print ( " Consonant : " , consonant ) NEW_LINE print ( " Digit : " , digit ) NEW_LINE print ( " Special Character : " , specialChar ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeks for geeks121" NEW_LINE countCharacterType ( str ) NEW_LINE DEDENT
def increaseIn vol vol vol vol vol vol vol vol vol vol ( l , b , h ) : NEW_LINE INDENT percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ) NEW_LINE percentInc -= 1 NEW_LINE percentInc *= 100 NEW_LINE return percentInc NEW_LINE DEDENT l = 50 NEW_LINE b = 20 NEW_LINE h = 10 NEW_LINE print ( increaseIn vol vol vol ( l , b , h ) , " % " ) NEW_LINE
def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE Len = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and not flag ) : NEW_LINE INDENT flag = True NEW_LINE Len = a [ i + 1 ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and ( flag ) ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * Len NEW_LINE flag = False NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxTotalRectangleArea ( a , n ) ) NEW_LINE DEDENT
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE newNode . data = data NEW_LINE return newNode NEW_LINE DEDENT def insertEnd ( head , new_node ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT new_node . next = new_node NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT last = head . prev NEW_LINE new_node . next = head NEW_LINE ( head ) . prev = new_node NEW_LINE new_node . prev = last NEW_LINE last . next = new_node NEW_LINE return head NEW_LINE DEDENT def reverse ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE last = head . prev NEW_LINE curr = last NEW_LINE while ( curr . prev != last ) : NEW_LINE INDENT prev = curr . prev NEW_LINE new_head = insertEnd ( new_head , curr ) NEW_LINE curr = prev NEW_LINE DEDENT new_head = insertEnd ( new_head , curr ) NEW_LINE return new_head NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print ( " forward direction : " , end = " " ) NEW_LINE while ( temp . next != head ) : NEW_LINE INDENT print ( temp . data , end = " " ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data , end = " " ) NEW_LINE last = head . prev NEW_LINE temp = last NEW_LINE print ( " \n Backward direction : " , end = " " ) NEW_LINE while ( temp . prev != last ) : NEW_LINE INDENT print ( temp . data , end = " " ) NEW_LINE temp = temp . prev NEW_LINE DEDENT print ( temp . data , end = " " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE
def lastFiveDigits ( n ) : NEW_LINE INDENT n = ( n // 10000 ) * 10000 + ( ( n // 100 ) % 10 ) * 1000 + ( ( n // 10 ) * 100 + ( ( n // 10 ) % 10 ) * 10 + ( n // 1000 ) % 10 ) NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12345 NEW_LINE lastFiveDigits ( n ) NEW_LINE DEDENT
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in itertools . count ( 1 ) for x in range ( 1 , 101 ) ) NEW_LINE x = x * 10 ** 100 NEW_LINE y = ( int ) ( sqrt ( x ) ) NEW_LINE if ( y * y == x ) : NEW_LINE INDENT s = str ( y ) NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT s += ord ( s [ j ] ) - ord ( '0' ) NEW_LINE DEDENT return str ( s ) NEW_LINE DEDENT return compute ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def evaluate ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( " No Pythagoras Triplet exists " ) NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT var = 1 * n * n // 4 NEW_LINE print ( " Pythagoras Triplets " , " exist i . e . " , end = " " ) NEW_LINE print ( n , end = " " ) NEW_LINE print ( var - 1 , end = " " ) NEW_LINE print ( var + 1 , end = " " ) NEW_LINE DEDENT elif ( n % 2 != 0 ) : NEW_LINE INDENT var = 1 * n * n + 1 NEW_LINE print ( " Pythagoras Triplets " , " exist i . e . " , end = " " ) NEW_LINE print ( n , end = " " ) NEW_LINE print ( var // 2 - 1 , end = " " ) NEW_LINE print ( var // 2 , end = " " ) NEW_LINE DEDENT DEDENT n = 22 NEW_LINE evaluate ( n ) NEW_LINE
a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE if a == 0 : NEW_LINE INDENT ans = b // x + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if x < b : NEW_LINE INDENT ans = x + b // x + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = x - ( b - 1 ) // x + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def findNumber ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == ans ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 2 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findNumber ( arr , n ) ) ; NEW_LINE DEDENT
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rem = A [ i ] % K NEW_LINE if ( rem != 0 ) : NEW_LINE INDENT ans += freq [ K - rem ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += freq [ 0 ] NEW_LINE DEDENT freq [ rem ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = len ( A ) NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE DEDENT
s = input ( ) . split ( " , " ) NEW_LINE l = len ( s [ 0 ] ) NEW_LINE r = len ( s [ 1 ] ) NEW_LINE print ( s [ 0 ] [ l ] , s [ 1 ] [ r ] , sep = " " ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l , r = 0 , 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ n - i - 1 ] != a [ 0 ] : NEW_LINE INDENT r = n - i - 1 NEW_LINE DEDENT elif a [ n - i - 1 ] != a [ n - 1 ] : NEW_LINE INDENT l = n - i - 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = n - i NEW_LINE DEDENT ans = max ( ans , l ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_ positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_ positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_ positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_ positive [ - difference ] NEW_LINE hash_ positive [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_ positive [ difference ] NEW_LINE hash_ positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Total Number of Even - Odd subarrays are " , countSubarrays ( arr , n ) ) NEW_LINE DEDENT
SIZE = 26 NEW_LINE def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT
def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 1 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT
def countGreater ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE leftGreater = n NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( arr [ m ] > k ) : NEW_LINE INDENT leftGreater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ( n - leftGreater ) NEW_LINE DEDENT arr = [ 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 7 NEW_LINE print ( countGreater ( arr , n , k ) ) NEW_LINE
H , W = map ( int , input ( ) . split ( ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE dp = [ [ 0 ] * W for _ in range ( H ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for h in range ( H ) : NEW_LINE INDENT for w in range ( W ) : NEW_LINE INDENT for a in range ( H ) : NEW_LINE INDENT if h + w == H : NEW_LINE INDENT dp [ h ] [ w ] = 1 NEW_LINE DEDENT elif a == w : NEW_LINE INDENT dp [ h ] [ w ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ h ] [ w ] += dp [ h - w ] [ a ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = dp [ H - 1 ] [ W - 1 ] * 2 % MOD NEW_LINE print ( ans ) NEW_LINE
from math import sqrt NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - sqrt ( val ) ) / 2.0 NEW_LINE print ( " a = " , a ) NEW_LINE print ( " b = " , b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 69.0 NEW_LINE findAandB ( N ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for x , y in zip ( * [ map ( int , input ( ) . split ( ) ) ] * n ) : NEW_LINE INDENT a . append ( max ( x , y ) ) NEW_LINE b . append ( min ( x , y ) ) NEW_LINE DEDENT print ( max ( 0 , max ( a ) - min ( b ) ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s . count ( " X " ) == 1 : NEW_LINE INDENT l . append ( s ) NEW_LINE DEDENT DEDENT if len ( l ) > 1 and l [ 0 ] == l [ 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT data = input ( ) NEW_LINE if data == "0" : NEW_LINE INDENT break NEW_LINE DEDENT data = data + data NEW_LINE ans = [ [ 0 ] * 10 for i in range ( len ( data ) ) ] NEW_LINE for i in range ( len ( data ) ) : NEW_LINE INDENT if data [ i ] == "1" : NEW_LINE INDENT ans [ i ] [ 0 ] = 1 NEW_LINE DEDENT elif data [ i ] == " ? " : NEW_LINE INDENT ans [ i ] [ 1 ] = - 1 NEW_LINE DEDENT elif data [ i ] == " ? " : NEW_LINE INDENT ans [ i ] [ 2 ] = - 1 NEW_LINE DEDENT elif data [ i ] == " ? " : NEW_LINE INDENT ans [ i ] [ 3 ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] [ 0 ] = ans [ i ] [ 0 ] * 10 - data [ i ] [ 1 ] * 10 - data [ i ] [ 2 ] NEW_LINE DEDENT DEDENT mod = 10 ** 9 + 7 NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT if ans [ i ] [ 0 ] == "1" : NEW_LINE INDENT ans [ i ] [ 0 ] = ans [ i ] [ 0 ] NEW_LINE DEDENT elif ans [ i ] [ 1 ] == " ? " : NEW_LINE INDENT ans [ i ] [ 1 ] = ans [ i ] [ 1 ] * ( ans [ i ] [ 0 ] - ans [ i - 1 ] [ 1 ] ) NEW_LINE if i - 1 >= 0 : NEW_LINE INDENT ans [ i ] [ 0 ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( sum ( ans [ i ] ) % mod ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n <= 3 : NEW_LINE INDENT print ( - 1 ) NEW_LINE continue NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT elif n % 3 == 0 : NEW_LINE INDENT n = n // 3 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( n >= 3 ) : NEW_LINE INDENT print ( ( n - 3 ) * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def minIncrementForUnique ( A ) : NEW_LINE INDENT mpp = dict ( ) NEW_LINE for i in A : NEW_LINE INDENT mpp [ i ] = mpp . get ( i , 0 ) + 1 NEW_LINE DEDENT return max ( mpp . values ( ) ) NEW_LINE DEDENT def minIncrementForUnique ( A ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 100000 ) : NEW_LINE INDENT if ( mpp [ x ] >= 2 and mpp [ x ] >= 2 ) : NEW_LINE INDENT ans += x * ( mpp [ x ] - 1 ) NEW_LINE DEDENT elif ( len ( mpp ) > 0 and ( ( mpp [ x ] == 0 and mpp [ x ] == 0 ) or not mpp [ x ] ) ) : NEW_LINE INDENT ans += x - - - - len ( - 1 ) NEW_LINE - 1 -= len ( - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 3 , 2 , 1 , 2 , 1 , 7 ] NEW_LINE print ( minIncrementForUnique ( A ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( 3 ** ( n - 1 ) ) * ( 3 ** ( n - 2 ) ) ) % 1000003 ) NEW_LINE DEDENT
MOD = 1000000007 NEW_LINE def modulo_13 ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 13 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( s [ i ] == ' ? ' ) : NEW_LINE INDENT nxt = j NEW_LINE DEDENT for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 * k + nxt ) % 13 NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] NEW_LINE dp [ i + 1 ] [ rem ] %= MOD NEW_LINE DEDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ 5 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ? 44" NEW_LINE n = len ( s ) NEW_LINE print ( modulo_13 ( s , n ) ) NEW_LINE DEDENT
def countNums ( a , b , c , d ) : NEW_LINE INDENT x = b // c - ( a - 1 ) // c NEW_LINE y = b // d - ( a - 1 ) // d NEW_LINE k = ( c * d ) // __gcd ( c , d ) NEW_LINE z = b // k - ( a - 1 ) // k NEW_LINE return b - a + 1 - x - y + z NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c , d = 10 , 50 , 4 , 6 NEW_LINE print ( countNums ( a , b , c , d ) ) NEW_LINE DEDENT
import math NEW_LINE def printSubstrings ( n ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) NEW_LINE d = int ( math . pow ( 10 , s ) + 0.5 ) NEW_LINE k = d NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( n // d ) NEW_LINE d = d // 10 NEW_LINE DEDENT n = n % k NEW_LINE k = k // 10 NEW_LINE d = k NEW_LINE DEDENT DEDENT n = 123 NEW_LINE printSubstrings ( n ) NEW_LINE
def NthCharacter ( n ) : NEW_LINE INDENT s = " " NEW_LINE c = 1 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if c < 10 : NEW_LINE INDENT s += str ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT s1 = " " NEW_LINE dup = c NEW_LINE while dup : NEW_LINE INDENT s1 += str ( dup % 10 ) NEW_LINE dup //= 10 NEW_LINE DEDENT s1 += str ( s1 ) NEW_LINE temp = temp [ : : - 1 ] NEW_LINE s += temp NEW_LINE DEDENT c += 1 NEW_LINE if len ( s ) >= n : NEW_LINE INDENT return s [ n - 1 ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 11 NEW_LINE print ( NthCharacter ( n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE tosts = [ ] NEW_LINE cmpr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d , h , m , d = map ( int , input ( ) . split ( ) ) NEW_LINE tosts . append ( d ) NEW_LINE cmpr . append ( m ) NEW_LINE DEDENT total_cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if tosts [ i ] % 3 == 0 : NEW_LINE INDENT total_cost += 200 NEW_LINE DEDENT else : NEW_LINE INDENT total_cost += 195 NEW_LINE DEDENT DEDENT if tosts [ 0 ] % 3 == 0 : NEW_LINE INDENT if cmpr [ 1 ] % 2 == 0 : NEW_LINE INDENT total_cost += 20 NEW_LINE DEDENT else : NEW_LINE INDENT total_cost += 195 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if cmpr [ 1 ] % 2 == 0 : NEW_LINE INDENT total_cost += 20 NEW_LINE DEDENT else : NEW_LINE INDENT total_cost += 195 NEW_LINE DEDENT DEDENT print ( total_cost ) NEW_LINE
from math import sqrt NEW_LINE def check_prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def countPrimeFrequent ( s ) : NEW_LINE INDENT count = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT for it in mp : NEW_LINE INDENT if ( check_prime ( mp [ it ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( countPrimeFrequent ( s ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b [ ans ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 1 ] * ( n + 2 ) ; NEW_LINE catalan [ 0 ] = 1 ; NEW_LINE catalan [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) ; NEW_LINE DEDENT DEDENT return catalan [ n ] ; NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalanDP ( i ) , end = " " ) ; NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 15499 NEW_LINE denominator = 1 NEW_LINE for p in range ( 2 , eulerlib . sqrt ( p - 1 ) ) : NEW_LINE INDENT totient = totient * ( p - 1 ) NEW_LINE denominator = denominator * p NEW_LINE while not eulerlib . is_prime ( p ) : NEW_LINE INDENT if ( ( totient * ( p - 1 ) ) // 2 < TARGET ) : NEW_LINE INDENT for i in range ( 1 , p ) : NEW_LINE INDENT numer = ( i * totient ) NEW_LINE denom = ( i * denominator ) NEW_LINE if ( ( numer * denom - 1 ) // 2 < TARGET ) : NEW_LINE INDENT return str ( denom ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE s = list ( input ( ) . rstrip ( ) ) NEW_LINE g = { " L " : 0 , " U " : 0 , " R " : 0 } NEW_LINE for i in s : NEW_LINE INDENT g [ i ] += 1 NEW_LINE DEDENT ok = True NEW_LINE for i in range ( len ( s ) - 3 ) : NEW_LINE INDENT for j in range ( i + 3 , len ( s ) ) : NEW_LINE INDENT if g [ i ] > g [ j ] : NEW_LINE INDENT ok = False NEW_LINE DEDENT DEDENT DEDENT if ok : NEW_LINE INDENT print ( " OK " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " BUG " ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPossible ( N ) : NEW_LINE INDENT if ( isPrime ( N ) and isPrime ( N - 2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 13 NEW_LINE if ( isPossible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res // ( n + 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Number of DyckPaths is " , countDyckPaths ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n > 30 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT elif n == 36 or n == 40 or n == 44 : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( 6 10 15 , n - 30 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( 6 10 14 , n - 30 ) NEW_LINE DEDENT DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if math . gcd ( a [ i ] , a [ i + 1 ] ) > 1 : NEW_LINE INDENT result = math . gcd ( a [ i ] , a [ i + 1 ] ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE
a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT ans += a [ i ] // 14 NEW_LINE DEDENT else : NEW_LINE INDENT ans += a [ i ] // 14 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT a = 6 NEW_LINE print ( pentdiagonal ( a ) ) NEW_LINE
def hexDiagonal ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.73 * a NEW_LINE return d NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 9 NEW_LINE print ( hexDiagonal ( a ) ) NEW_LINE DEDENT
def translate ( string ) : NEW_LINE INDENT l = len ( string ) NEW_LINE if l < 2 : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while j < l - 1 : NEW_LINE INDENT if ( string [ j ] == ' A ' and string [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j = j + 2 NEW_LINE string [ i ] = ' C ' NEW_LINE i += 1 NEW_LINE i += 1 NEW_LINE string [ j ] = string [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if j == l - 1 : NEW_LINE INDENT string [ i ] = string [ j ] NEW_LINE i += 1 NEW_LINE DEDENT string [ i ] = ' ' NEW_LINE string [ l - 1 ] = ' ' NEW_LINE DEDENT string = " helloAB worldABGfG " NEW_LINE string = list ( string ) NEW_LINE translate ( string ) NEW_LINE print ( " The l string is : " ) NEW_LINE print ( string ) NEW_LINE
def translate ( string ) : NEW_LINE INDENT for i in range ( 1 , len ( string ) ) : NEW_LINE INDENT if ( string [ i - 1 ] == ' A ' and string [ i ] == ' B ' ) : NEW_LINE INDENT string [ i - 1 ] = ' C ' NEW_LINE j = i NEW_LINE while ( j < len ( string ) - 1 ) : NEW_LINE INDENT string [ j ] = string [ j + 1 ] NEW_LINE j += 1 NEW_LINE DEDENT string [ j ] = ' ' NEW_LINE DEDENT DEDENT return string NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " helloAB worldGfG " NEW_LINE string = list ( string ) NEW_LINE translate ( string ) NEW_LINE print ( " The Modified string is : " ) NEW_LINE print ( string ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT target = 2000 NEW_LINE count = 2 NEW_LINE for ring in range ( 2 ) : NEW_LINE INDENT if ring * 12 + 5 > eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( eulerlib . sqrt ( euler [ euler [ euler [ ring ] ) ) ) ) ) ) ) ) ) ) for e in range ( 2 ) : NEW_LINE INDENT if count == target : NEW_LINE INDENT return str ( ring * ( ring - 1 ) * 3 + 2 ) NEW_LINE DEDENT if count == target : NEW_LINE INDENT return str ( ring * ( ring - 1 ) * 3 + 2 ) NEW_LINE DEDENT DEDENT if ring * 6 - 1 == eulerlib . sqrt ( euler [ ring * 6 + 5 ] ) and euler [ ring * 12 - 7 ] == euler [ ring * 12 - 7 ] : NEW_LINE INDENT count += 1 NEW_LINE if count == target : NEW_LINE INDENT return str ( ring * ( ring + 1 ) * 3 + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( max ( a , b ) + 1 ) : NEW_LINE INDENT for j in range ( max ( a , b ) + 1 ) : NEW_LINE INDENT if i * i == a + j * j == b : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE
def Digits ( n ) : NEW_LINE INDENT largest = 0 NEW_LINE smallest = 9 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE largest = max ( r , largest ) NEW_LINE smallest = min ( r , smallest ) NEW_LINE n = n // 10 NEW_LINE DEDENT print ( largest , smallest ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2346 NEW_LINE Digits ( n ) NEW_LINE DEDENT
def solve ( d1 , d2 , d3 ) : NEW_LINE INDENT maxx = max ( d1 , max ( d2 , d3 ) ) NEW_LINE sum = ( d1 + d2 + d3 ) NEW_LINE if ( 2 * maxx > sum or sum % 2 == 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = d1 NEW_LINE y2 = 0 NEW_LINE x3 = ( d1 + d2 - d3 ) // 2 NEW_LINE y3 = ( d2 + d3 - d1 ) // 2 NEW_LINE print ( " ( " , x1 , " , " , y1 , " ) , ( " , x2 , " , " , y2 , " ) and ( " , x3 , " , " , y3 , " ) " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d1 , d2 , d3 = 3 , 4 , 5 NEW_LINE solve ( d1 , d2 , d3 ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE defDistendingBalls ( k , n , string ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE k = 3 NEW_LINE string = " aacaab " NEW_LINE if (DistendingBalls ( k , n , string ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if s . count ( ' M ' ) > s . count ( ' T ' ) or s . count ( ' M ' ) < s . count ( ' T ' ) : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == ' M ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if s [ i ] == ' T ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if s [ i ] == ' M ' : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
a = [ int ( input ( ) ) for _ in range ( 12 ) ] NEW_LINE print ( [ " no " , " yes " ] [ sum ( a ) == 12 ] ) NEW_LINE
R = 4 NEW_LINE C = 4 NEW_LINE def first ( arr , low , high ) : NEW_LINE INDENT if ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == 0 or arr [ mid - 1 ] == 0 ) and arr [ mid ] == 1 ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( arr [ mid ] == 0 ) : NEW_LINE INDENT return first ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return first ( arr , low , ( mid - 1 ) ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def rowWith0s ( mat ) : NEW_LINE INDENT max_row_index = 0 NEW_LINE max = - 1 NEW_LINE min_row_index = 0 NEW_LINE min = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT index = first ( mat [ i ] , 0 , C - 1 ) NEW_LINE cntZeroes = 0 NEW_LINE if ( index == - 1 ) : NEW_LINE INDENT cntZeroes = C NEW_LINE DEDENT else : NEW_LINE INDENT cntZeroes = index NEW_LINE DEDENT if ( max < cntZeroes ) : NEW_LINE INDENT max = cntZeroes NEW_LINE max_row_index = i NEW_LINE DEDENT if ( min > cntZeroes ) : NEW_LINE INDENT min = cntZeroes NEW_LINE min_row_index = i NEW_LINE DEDENT DEDENT print ( "Row with min 0s : " , min_row_index + 1 ) NEW_LINE print ( "Row with max 0s : " , max_row_index + 1 ) NEW_LINE DEDENT mat = [ [ 0 , 0 , 0 , 1 ] , [ 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE rowWith0s ( mat ) NEW_LINE
def bitAtGivenPosSetOrUnset ( n , k ) : NEW_LINE INDENT new_num = n >> ( k - 1 ) NEW_LINE return ( new_num & 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( bitAtGivenPosSetOrUnset ( n , k ) == 1 ) : NEW_LINE INDENT print ( " Set " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Unset " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = [ ] NEW_LINE for i in s : NEW_LINE INDENT if i == ' A ' : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT elif i == ' G ' : NEW_LINE INDENT ans . append ( 2 ) NEW_LINE DEDENT elif i == ' T ' : NEW_LINE INDENT ans . append ( 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT DEDENT if len ( ans ) % 4 != 0 : NEW_LINE INDENT print ( " = = " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " = = " ) NEW_LINE DEDENT
def solve ( ) : NEW_LINE INDENT from sys import stdin NEW_LINE f_i = stdin NEW_LINE while True : NEW_LINE INDENT n = int ( f_i . readline ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT pos = [ 0 ] * 9 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT pos [ i ] = ( pos [ i ] + f_i . readline ( ) ) / 4 NEW_LINE pos [ i + 1 ] = ( pos [ i ] + f_i . readline ( ) ) / 4 NEW_LINE pos [ i + 2 ] = ( pos [ i + 1 ] + f_i . readline ( ) ) / 4 NEW_LINE DEDENT print ( " % .10f " % pos [ n ] ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE
l , r = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT if i * 2 > r : NEW_LINE INDENT break NEW_LINE DEDENT if i * 3 >= l : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( n * 2 , k + 1 , sum ( map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE
def arePermutations ( a , b , n , m ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE mul1 = 1 NEW_LINE mul2 = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE mul1 *= a [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT sum2 += b [ i ] NEW_LINE mul2 *= b [ i ] NEW_LINE DEDENT return ( ( sum1 == sum2 ) and ( mul1 == mul2 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 3 , 2 ] NEW_LINE b = [ 3 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if ( arePermutations ( a , b , n , m ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
MAX_CHAR = 26 NEW_LINE def findAndPrintUncommonChars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT if ( present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 2 NEW_LINE DEDENT DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( present [ i ] == 1 or present [ i ] == 2 ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " characters " NEW_LINE str2 = " alphabets " NEW_LINE findAndPrintUncommonChars ( str1 , str2 ) NEW_LINE DEDENT
def isInside ( circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y = 1 , 1 NEW_LINE circle_x , circle_y , rad = 0 , 1 , 2 NEW_LINE if ( isInside ( circle_x , circle_y , rad , x , y ) ) : NEW_LINE INDENT print ( " inside " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT DEDENT
def minSum ( arr , n , x ) : NEW_LINE INDENT sum = 0 NEW_LINE largestDivisible = - 1 NEW_LINE minimum = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < minimum ) : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if ( largestDivisible == - 1 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible // x ) NEW_LINE return min ( sum , sumAfterOperation ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( minSum ( arr , n , x ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT nth = 2 * ( ( n * n ) - n ) NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( 2 * n * n ) - n NEW_LINE DEDENT return nth NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 25 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 25000000 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE DEDENT
from collections import deque NEW_LINE q = int ( input ( ) ) NEW_LINE S = deque ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT query = input ( ) NEW_LINE if query [ 0 ] == '0' : NEW_LINE INDENT if query [ 1 ] == '0' : NEW_LINE INDENT S . appendleft ( query [ 2 ] ) NEW_LINE DEDENT elif query [ 1 ] == '1' : NEW_LINE INDENT _ , x = map ( int , query [ 2 ] . split ( ) ) NEW_LINE S . appendleft ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT _ , x = map ( int , query [ 2 ] . split ( ) ) NEW_LINE S . append ( x ) NEW_LINE DEDENT DEDENT elif query [ 0 ] == '1' : NEW_LINE INDENT _ , x = map ( int , query [ 2 ] . split ( ) ) NEW_LINE if x == '2' : NEW_LINE INDENT _ , x = map ( int , query [ 2 ] . split ( ) ) NEW_LINE S . popleft ( ) NEW_LINE DEDENT elif x == '1' : NEW_LINE INDENT _ , x = map ( int , query [ 2 ] . split ( ) ) NEW_LINE S . pop ( ) NEW_LINE DEDENT DEDENT for s in S : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT if s [ 0 : i + 1 ] == s [ - i - 1 : ] : NEW_LINE INDENT ans . append ( i + 1 ) NEW_LINE DEDENT DEDENT ans . append ( s [ 0 : n ] ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT ans . append ( s [ n : ] ) NEW_LINE DEDENT print ( * ans , sep = ' ' ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT temp = Node ( data ) NEW_LINE temp . data = data NEW_LINE temp . left = temp . right = None NEW_LINE return temp NEW_LINE DEDENT def printInorder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( node . left ) NEW_LINE print ( node . data ) NEW_LINE printInorder ( node . right ) NEW_LINE DEDENT def conBinaryTreeUtil ( pre , preM , preIndex , l , h , size ) : NEW_LINE INDENT if ( preIndex . a >= size or l > h ) : NEW_LINE INDENT return None NEW_LINE DEDENT root = newNode ( pre [ preIndex . a ] ) NEW_LINE preIndex . a += 1 NEW_LINE if ( l == h ) : NEW_LINE INDENT return root NEW_LINE DEDENT i = l NEW_LINE while ( i <= h ) : NEW_LINE INDENT if ( pre [ preIndex . a ] == preM [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i <= h ) : NEW_LINE INDENT root . left = conBinaryTreeUtil ( pre , preM , preIndex , l + 1 , i , h , size ) NEW_LINE root . right = conBinaryTreeUtil ( pre , preM , preIndex , l + 1 , i - 1 , size ) NEW_LINE DEDENT return root NEW_LINE DEDENT def conBinaryTree ( root , pre , preMirror , size ) : NEW_LINE INDENT preIndex = 0 NEW_LINE preMIndex = 0 NEW_LINE root = newNode ( pre [ preIndex . a ] ) NEW_LINE preIndex . a += 1 NEW_LINE if ( l == h ) : NEW_LINE INDENT return root NEW_LINE DEDENT i = l NEW_LINE while ( i <= h ) : NEW_LINE INDENT if ( pre [ preIndex . a ] == preM [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i <= h
no_of_chars = 256 NEW_LINE def findSubString ( str , pat ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( pat ) NEW_LINE if ( len1 < len2 ) : NEW_LINE INDENT print ( " No such window exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 ] * no_of_chars NEW_LINE hash_str = [ 0 ] * no_of_chars NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT hash_pat [ pat [ i ] ] += 1 NEW_LINE DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = 10 ** 9 NEW_LINE count = 0 NEW_LINE for j in range ( len1 ) : NEW_LINE INDENT hash_str [ ord ( str [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( str [ j ] ) ] != 0 and hash_str [ ord ( str [ j ] ) ] <= hash_pat [ ord ( str [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == len2 ) : NEW_LINE INDENT while ( hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] or hash_pat [ ord ( str [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( str [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT DEDENT len_window = j - start + 1 NEW_LINE if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT if ( start_index == - 1 ) : NEW_LINE INDENT print ( " No such window exists " ) NEW_LINE return " " NEW_LINE DEDENT return str [ start_index : start_index + min_len ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " this is a test string " NEW_LINE pat
from math import atan , pi NEW_LINE E = 10 ** - 10 NEW_LINE def cross ( a0 , a1 , b0 , b1 ) : NEW_LINE INDENT return a0 * b1 - a1 * b0 NEW_LINE DEDENT while ( 1 ) : NEW_LINE INDENT a = [ 0 for i in range ( 2 ) ] NEW_LINE b = [ 0 for i in range ( 2 ) ] NEW_LINE c = [ 0 for i in range ( 2 ) ] NEW_LINE d = [ 0 for i in range ( 2 ) ] NEW_LINE try : NEW_LINE INDENT a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] , c [ 0 ] , c [ 1 ] , d [ 0 ] , d [ 1 ] = [ float ( i ) for i in input ( ) . split ( ) ] NEW_LINE E [ 0 ] , E [ 1 ] , c [ 0 ] , d [ 1 ] = [ float ( i ) for i in input ( ) . split ( ) ] NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT if cross ( E [ 1 ] - E [ 0 ] , E [ 2 ] - E [ 1 ] , E [ 3 ] - E [ 2 ] ) >= 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE stones = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT stones . append ( input ( ) ) NEW_LINE DEDENT stones . sort ( ) NEW_LINE flag = 0 NEW_LINE for i in stones : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT if flag == 1 and m > n : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT return ( n == 3 or n == 5 or n == 7 ) NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( 0 , len ( v ) and n > 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 NEW_LINE a = a // 10 NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = sum + v [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE DEDENT
a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = sum ( a ) NEW_LINE e = b [ 0 ] NEW_LINE f = c [ 1 ] NEW_LINE g = d [ 2 ] NEW_LINE h = e [ 3 ] NEW_LINE i = 1 NEW_LINE while i <= f and i <= e : NEW_LINE INDENT if e - g >= 0 : NEW_LINE INDENT e -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT g -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( e + g + h ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = 9999999999 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] <= ans : NEW_LINE INDENT ans = s [ i ] + 15 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def memo ( index , evenSum , oddSum , tight ) : NEW_LINE INDENT if ( index == len ( v ) ) : NEW_LINE INDENT if ( evenSum > oddSum ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ index ] [ evenSum ] [ oddSum ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ evenSum ] [ oddSum ] [ tight ] NEW_LINE DEDENT limit = v [ index ] NEW_LINE ans = 0 NEW_LINE for d in range ( limit + 1 ) : NEW_LINE INDENT currTight = 0 NEW_LINE if ( d == v [ index ] ) : NEW_LINE INDENT currTight = tight NEW_LINE DEDENT if ( d % 2 != 0 ) : NEW_LINE INDENT ans += memo ( index + 1 , evenSum , oddSum + d , currTight ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += memo ( index + 1 , evenSum + d , oddSum , currTight ) NEW_LINE DEDENT DEDENT dp [ index ] [ evenSum ] [ oddSum ] [ tight ] = ans NEW_LINE return ans NEW_LINE DEDENT def CountNum ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT v . append ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT v . reverse ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 18 ) : NEW_LINE INDENT for j in range ( 180 ) : NEW_LINE INDENT for k in range ( 180 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = - 1 NEW_LINE DEDENT DEDENT DEDENT return memo ( 0 , 0 , 0 , 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT v = [ ] NEW_LINE dp = [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 18 ) ] for k in range ( 180 ) ] NEW_LINE l = 2 NEW_LINE r = 10 NEW_LINE print ( CountNum ( r ) - CountNum ( l - 1 ) ) NEW_LINE DEDENT
def isCoffee ( s1 , s2 , s3 ) : NEW_LINE INDENT return s1 == s2 and s2 == s3 NEW_LINE DEDENT s1 = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE s2 = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE s3 = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE res = ' Yes ' if isCoffee ( s1 , s2 , s3 ) else ' No ' NEW_LINE print ( res ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE f = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > 0 and a [ i ] > 0 : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT ans . append ( a [ i ] ) NEW_LINE DEDENT if f : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * ans ) NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def search ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = search ( arr , x ) NEW_LINE if result == - 1 : NEW_LINE INDENT print ( " Element is not present in array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element is present at index " , result ) NEW_LINE DEDENT
n , c = map ( int , input ( ) . split ( ) ) NEW_LINE forward = [ 0 ] * ( n + 1 ) NEW_LINE backward = [ 0 ] * ( n + 1 ) NEW_LINE forward_i = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT forward [ i ] , forward [ i + 1 ] = map ( int , input ( ) . split ( ) ) NEW_LINE backward [ i ] , backward [ i + 1 ] = forward [ i + 1 ] , forward [ i ] NEW_LINE DEDENT forward_i = [ 0 ] * ( n + 1 ) NEW_LINE backward_i = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT forward_i [ i ] , forward_i [ i + 1 ] = forward_i [ i + 1 ] , forward_i [ i ] NEW_LINE DEDENT forward_i [ 0 ] , forward_i [ 1 ] = 0 , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT backward_i [ i ] , backward_i [ i + 1 ] = backward_i [ i + 1 ] , backward_i [ i ] NEW_LINE DEDENT ans = max ( 0 , backward_i [ 1 ] - ( c - forward_i [ 1 ] ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = max ( ans , backward_i [ 1 ] - ( c - backward_i [ 1 ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def toggleBitsFromLToR ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def unsetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( 1 << ( 4 * 8 - 1 ) ) - 1 NEW_LINE num = toggleBitsFromLToR ( num , l , r ) NEW_LINE return ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE print ( unsetBitsInGivenRange ( n , l , r ) ) NEW_LINE
def MinStep ( a , n ) : NEW_LINE INDENT positive , negative , zero , step = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT elif ( a [ i ] < 0 ) : NEW_LINE INDENT negative += 1 NEW_LINE step = step + ( - 1 - a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT positive += 1 NEW_LINE step = step + ( a [ i ] - 1 ) NEW_LINE DEDENT DEDENT if ( negative % 2 == 0 ) : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT step = step + 2 NEW_LINE DEDENT DEDENT return step NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 0 , - 2 , - 1 , - 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( MinStep ( a , n ) ) NEW_LINE DEDENT
n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE if int ( s [ a ] ) == int ( s [ b ] ) : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT else : NEW_LINE INDENT x = int ( s [ a ] ) - int ( s [ b ] ) NEW_LINE ans = abs ( x - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE print ( a [ n - 1 ] + a [ n - 2 ] ) NEW_LINE DEDENT
from math import gcd NEW_LINE def noOfSquares ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT dx = abs ( x2 - x1 ) NEW_LINE dy = abs ( y2 - y1 ) NEW_LINE ans = dx + dy - gcd ( dx , dy ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 , y1 , x2 , y2 = 1 , 1 , 4 , 3 NEW_LINE noOfSquares ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT
def get_ maximum ( s , a ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) < ord ( a [ ord ( s [ i ] ) - ord ( '0' ) ] ) ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n and ( ord ( s [ j ] ) - ord ( '0' ) <= ord ( a [ ord ( s [ j ] ) - ord ( '0' ) ] ) ) : NEW_LINE INDENT s [ j ] = chr ( ord ( '0' ) + a [ ord ( s [ j ] ) - ord ( '0' ) ] ) NEW_LINE j += 1 NEW_LINE DEDENT return s NEW_LINE DEDENT DEDENT return " " . join ( s ) NEW_LINE DEDENT s = "1337" NEW_LINE a = [ 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 ] NEW_LINE print ( maximum ( s , a ) ) NEW_LINE
MAX_DIGITS = 20 NEW_LINE def isOctal ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n % 10 ) >= 8 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 10 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divide = 8 if ( isOctal ( n ) == 0 ) else 10 NEW_LINE octal = [ 0 ] * ( MAX_DIGITS ) NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octal [ i ] = n % divide NEW_LINE i += 1 NEW_LINE n = n // divide NEW_LINE DEDENT j = i - 1 NEW_LINE k = 0 NEW_LINE while ( k <= j ) : NEW_LINE INDENT if ( octal [ j ] != octal [ k ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 97 NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE k = 0 NEW_LINE for i in s : NEW_LINE INDENT if i == '4' and i == '7' : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif i == '7' and i > n : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT if k == n : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def binarySearch ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE midValue = arr [ mid ] NEW_LINE if ( mid == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT leftindex = min ( mid - 1 , midValue ) NEW_LINE left = binarySearch ( arr , low , leftindex ) NEW_LINE if ( left >= 0 ) : NEW_LINE INDENT return left NEW_LINE DEDENT rightindex = max ( mid + 1 , midValue ) NEW_LINE right = binarySearch ( arr , rightindex , high ) NEW_LINE return right NEW_LINE DEDENT arr = [ - 10 , - 5 , 2 , 2 , 2 , 3 , 4 , 7 , 9 , 12 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " fixed Point is " , binarySearch ( arr , 0 , n - 1 ) ) NEW_LINE arr1 = [ - 10 , - 1 , 3 , 3 , 10 , 30 , 30 , 50 , 100 ] NEW_LINE print ( " fixed Point is " , binarySearch ( arr1 , 0 , n - 1 ) ) NEW_LINE
MAX = 10000 NEW_LINE prodDig = [ 0 ] * MAX NEW_LINE def getDigitProduct ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT if ( prodDig [ x ] != 0 ) : NEW_LINE INDENT return prodDig [ x ] NEW_LINE DEDENT prod = ( x % 10 ) * getDigitProduct ( x // 10 ) NEW_LINE return ( prodDig [ x ] = prod ) NEW_LINE DEDENT def find seed ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT if ( i * getDigitProduct ( i ) == n ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( " NO seed exists " ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE find seed ( n ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT if x [ i + k - 1 ] <= x [ i ] : NEW_LINE INDENT ans = min ( ans , x [ i ] + x [ i + k - 1 ] - x [ i ] + min ( x [ i + k - 1 ] , x [ i ] + min ( x [ i + k - 1 ] , x [ i ] + min ( x [ i + k - 1 ] , x [ i ] + min ( x [ i + k - 1 ] , x [ i ] + min ( x [ i + k - 1 ] ) ) ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def diff ( n , mid ) : NEW_LINE INDENT if ( n > ( mid * mid * mid ) ) : NEW_LINE INDENT return ( n - ( mid * mid * mid ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( mid * mid * mid ) - n ) NEW_LINE DEDENT DEDENT def cubicRoot ( n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n NEW_LINE e = 0.0000001 NEW_LINE while ( True ) : NEW_LINE INDENT mid = ( start + end ) / 2 NEW_LINE error = diff ( n , mid ) NEW_LINE if ( error <= e ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( ( mid * mid * mid ) > n ) : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT return end NEW_LINE DEDENT n = 3 NEW_LINE print ( " Cubic root of " , n , " is " , cubicRoot ( n ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = { } NEW_LINE c = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in b : NEW_LINE INDENT b [ a [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ a [ i ] ] += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT c [ a [ i ] ] = b [ a [ i ] ] - 1 NEW_LINE DEDENT d = b . values ( ) NEW_LINE e = d . values ( ) NEW_LINE x = [ ] NEW_LINE for i in e : NEW_LINE INDENT x . append ( i [ 1 ] ) NEW_LINE DEDENT print ( f " { x [ 0 ] } { x [ 1 ] } " ) NEW_LINE
def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE t = q = 1 NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT def findMinX ( num , rem , k ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT prod *= num [ i ] NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT pp = prod // num [ i ] NEW_LINE result += rem [ i ] * inv ( pp , num [ i ] ) * pp NEW_LINE DEDENT return result % prod NEW_LINE DEDENT num = [ 3 , 4 , 5 ] NEW_LINE rem = [ 2 , 3 , 1 ] NEW_LINE k = len ( num ) NEW_LINE print ( " x is " , findMinX ( num , rem , k ) ) NEW_LINE
def compare ( a , b ) : NEW_LINE INDENT return a > b NEW_LINE DEDENT def findMaxOR ( arr , n ) : NEW_LINE INDENT temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT DEDENT maxOR = arr [ 0 ] NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( maxOR | arr [ i ] ) > maxOR ) : NEW_LINE INDENT maxOR = maxOR | arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxOR ( arr , n ) ) NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) // 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE
def aliquotSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE print ( aliquotSum ( n ) ) NEW_LINE DEDENT
def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) // 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( pentagon_pyramidal ( n ) ) NEW_LINE
def fifthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( fifthPowerSum ( n ) ) NEW_LINE DEDENT
def squaresum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE
def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) // 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) // 6 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
def fourthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE
def squareSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT print ( squareSum ( 8 ) ) NEW_LINE
def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum / n NEW_LINE DEDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
def solve ( n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE sum += remainder NEW_LINE n = n // base NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumsOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for base in range ( 2 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT sum += solve ( n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE SumsOfDigits ( n ) NEW_LINE DEDENT
import itertools NEW_LINE def sieve ( n ) : NEW_LINE INDENT is_prime = [ True ] * ( n + 1 ) NEW_LINE is_prime [ 0 ] = False NEW_LINE is_prime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if not is_prime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT is_prime [ j ] = False NEW_LINE DEDENT DEDENT return is_prime NEW_LINE DEDENT prime = sieve ( 40000 ) NEW_LINE c = [ 0 ] * ( n + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE c [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if c [ i ] : NEW_LINE INDENT for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT c [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( sum ( c [ n ] ) ) NEW_LINE DEDENT
def bitCount ( n ) : NEW_LINE INDENT return n . bit_length ( ) - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( bitCount ( 4 ) ) NEW_LINE print ( bitCount ( 15 ) ) NEW_LINE DEDENT
import sys NEW_LINE def optimalSearchTree ( keys , freq , n ) : NEW_LINE INDENT cost = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cost [ i ] [ i ] = freq [ i ] NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE cost [ i ] [ j ] = sys . maxsize NEW_LINE for r in range ( i , j + 1 ) : NEW_LINE INDENT c = ( ( r > i ) if r > i else cost [ i ] [ r - 1 ] ) + ( cost [ i + 1 ] [ j ] if r < j else cost [ i ] [ j ] ) + sum ( freq , i , j ) NEW_LINE if c < cost [ i ] [ j ] : NEW_LINE INDENT cost [ i ] [ j ] = c NEW_LINE DEDENT DEDENT DEDENT DEDENT return cost [ 0 ] [ n - 1 ] NEW_LINE DEDENT def sum ( freq , i , j ) : NEW_LINE INDENT s = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT if k >= freq [ 0 ] : NEW_LINE INDENT continue NEW_LINE DEDENT s += freq [ k ] NEW_LINE DEDENT return s NEW_LINE DEDENT keys = [ 10 , 12 , 20 ] NEW_LINE freq = [ 34 , 8 , 50 ] NEW_LINE n = len ( keys ) NEW_LINE print ( " Cost of Optimal BST is " , optimalSearchTree ( keys , freq , n ) ) NEW_LINE
def get ( x , y , z ) : NEW_LINE INDENT if ( x > z ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) // y NEW_LINE ans = div * y + x NEW_LINE return ans NEW_LINE DEDENT x = 1 NEW_LINE y = 5 NEW_LINE z = 8 NEW_LINE print ( get ( x , y , z ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE k = None NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if k == None : NEW_LINE INDENT k = a [ i ] NEW_LINE continue NEW_LINE DEDENT if k == n - 1 : NEW_LINE INDENT ans += a [ i ] NEW_LINE k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += abs ( a [ i ] - k ) NEW_LINE k = 0 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def maxcoefficientvalue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return binomialCoeff ( n , n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return binomialCoeff ( n , ( n + 1 ) // 2 ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE print ( maxcoefficientvalue ( n ) ) NEW_LINE
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def vowelPairs ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) and isVowel ( s [ i + 1 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abaebio " NEW_LINE n = len ( s ) NEW_LINE print ( vowelPairs ( s , n ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE w , h = map ( int , input ( ) . split ( ) ) NEW_LINE s , t = [ ] , [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE s . append ( a [ 1 ] ) NEW_LINE t . append ( a [ 2 ] ) NEW_LINE DEDENT s . append ( a [ 1 ] ) NEW_LINE t . append ( a [ 2 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT for k in range ( i , h ) : NEW_LINE INDENT ans = max ( ans , sum ( s [ i : i + h ] ) ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def isSubstring ( s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( s2 [ i + j ] != s1 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == M ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = " for " NEW_LINE s2 = " geeksforgeeks " NEW_LINE res = isSubstring ( s1 , s2 ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not present " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Present at index " , res ) NEW_LINE DEDENT DEDENT
def angleOncirCumference ( z ) : NEW_LINE INDENT return ( z / 2 ) NEW_LINE DEDENT angle = 65 NEW_LINE z = angleOncirCumference ( angle ) NEW_LINE print ( " The angle is " , z , " degrees " ) NEW_LINE
def countSubarraysof1and0 ( a , n ) : NEW_LINE INDENT count1 = 0 NEW_LINE count0 = 0 NEW_LINE number1 = 0 NEW_LINE number0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number1 += ( count1 ) * ( count1 + 1 ) / 2 NEW_LINE count1 = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number0 += ( count0 ) * ( count0 + 1 ) / 2 NEW_LINE count0 = 0 NEW_LINE DEDENT DEDENT if ( count1 > 0 ) : NEW_LINE INDENT number1 += ( count1 ) * ( count1 + 1 ) / 2 NEW_LINE DEDENT if ( count0 > 0 ) : NEW_LINE INDENT number0 += ( count0 ) * ( count0 + 1 ) / 2 NEW_LINE DEDENT print ( " Count of subarrays of 0 only : " , number0 ) NEW_LINE print ( " \n Count of subarrays of 1 only : " , number1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countSubarraysof1and0 ( a , n ) NEW_LINE DEDENT
def printNumbers ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if ( N > 0 ) : NEW_LINE INDENT while ( x > 0 and flag == 1 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE if ( digit != 1 and digit != 3 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( N , end = " " ) NEW_LINE DEDENT printNumbers ( N - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE printNumbers ( N ) NEW_LINE DEDENT
def printPermutation ( n , k ) : NEW_LINE INDENT i , mx = n , 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( mx , end = " " ) NEW_LINE mx -= 1 NEW_LINE DEDENT for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , K = 5 , 3 NEW_LINE if ( K >= N - 1 ) : NEW_LINE INDENT print ( " Not Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT printPermutation ( N , K ) NEW_LINE DEDENT DEDENT
rank = 1 NEW_LINE lista = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y , z , w = map ( int , input ( ) . split ( ) ) NEW_LINE lista . append ( x + y + z ) NEW_LINE DEDENT lista . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < len ( lista ) ) : NEW_LINE INDENT if lista [ i ] == lista [ i - 1 ] : NEW_LINE INDENT rank += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j = 0 NEW_LINE while ( j < len ( lista ) ) : NEW_LINE INDENT if lista [ j ] == lista [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 0 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT print ( rank ) NEW_LINE
def check ( s1 , s2 ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT mp [ s1 [ i ] ] = mp . get ( s1 [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( mp [ s2 [ i ] ] > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " geeksforgeeks " NEW_LINE s2 = " geeks " NEW_LINE yes_or_no = check ( s1 , s2 ) NEW_LINE if ( yes_or_no == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE n , a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if t == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if a + b > n * c or a + c > n * d : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE DEDENT
N = 3 NEW_LINE def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT tri = [ [ 1 , 0 , 0 ] , [ 4 , 8 , 0 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( maxPathSum ( tri , 2 , 2 ) ) NEW_LINE
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( n // 2 + 1 ) : NEW_LINE INDENT if ( arr [ 2 * i + 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isHeap ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isHeap ( arr , i , n ) : NEW_LINE INDENT if ( i > ( n - 2 ) // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) - 1 NEW_LINE if ( isHeap ( arr , 0 , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT ax , ay = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE bx , by = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cx , cy = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( ( bx - ax ) * ( cy - ay ) == ( cx - ax ) * ( cy - ay ) ) or ( ( bx - ax ) * ( cx - bx ) == ( cy - by ) * ( cy - by ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
def findMinDel ( arr , n ) : NEW_LINE INDENT min_num = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_num ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return n - cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 3 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findMinDel ( arr , n ) ) ; NEW_LINE DEDENT
def count ( x , y ) : NEW_LINE INDENT ans = 0 NEW_LINE m = dict ( ) NEW_LINE while ( x % y != 0 ) : NEW_LINE INDENT x = x % y NEW_LINE ans += 1 NEW_LINE if ( x in m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT m [ x ] = 1 NEW_LINE x = x * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT res = count ( 1 , 2 ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " INF " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT res = count ( 5 , 3 ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " INF " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT res = count ( 3 , 5 ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " INF " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT
def isPossibleToMakeDivisible ( arr , n ) : NEW_LINE INDENT remainder = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 NEW_LINE DEDENT return ( remainder == 0 ) NEW_LINE DEDENT arr = [ 40 , 50 , 90 ] NEW_LINE n = 3 NEW_LINE if ( isPossibleToMakeDivisible ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] == 0 : NEW_LINE INDENT B [ A [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT B [ A [ i ] ] += 1 NEW_LINE DEDENT DEDENT C = list ( accumulate ( B ) ) NEW_LINE C = [ 0 ] * N NEW_LINE for k in range ( N ) : NEW_LINE INDENT if B [ k ] == 1 : NEW_LINE INDENT C [ k ] = C [ k ] + 1 NEW_LINE DEDENT elif B [ k ] == 0 : NEW_LINE INDENT C [ k ] = C [ k ] - 1 NEW_LINE DEDENT DEDENT answer = C . count ( 0 ) NEW_LINE print ( answer ) NEW_LINE
def printCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j * j <= i ) : NEW_LINE INDENT if ( j * j * j == i ) : NEW_LINE INDENT print ( j * j * j , end = " " ) NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT a = 1 NEW_LINE b = 100 NEW_LINE print ( " Perfect cubes in given range : " ) NEW_LINE printCubes ( a , b ) NEW_LINE
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE d = 4 NEW_LINE print ( n , " moduo " , d , " is " , getModulo ( n , d ) ) NEW_LINE DEDENT
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i - d <= a [ i ] + d : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
s = input ( ) NEW_LINE f = s . find ( " d " ) NEW_LINE t = s . rfind ( " a " ) NEW_LINE print ( min ( f , ( t + 1 ) // 2 ) * 2 + t ) NEW_LINE
def isPerfectCube ( x ) : NEW_LINE INDENT cr = ( int ) ( x ) ; NEW_LINE return ( cr * cr * cr == x ) ; NEW_LINE DEDENT def canBePerfectCube ( N , K ) : NEW_LINE INDENT if ( isPerfectCube ( N + K ) or isPerfectCube ( N - K ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 7 ; NEW_LINE K = 1 ; NEW_LINE canBePerfectCube ( N , K ) ; NEW_LINE N = 5 ; NEW_LINE K = 4 ; NEW_LINE canBePerfectCube ( N , K ) ; NEW_LINE N = 7 ; NEW_LINE K = 2 ; NEW_LINE canBePerfectCube ( N , K ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE s = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += t [ i ] NEW_LINE DEDENT print ( n * 2 - len ( s ) ) NEW_LINE
def DFSUtil ( v , visited ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE print ( v , end = " " ) NEW_LINE for i in adj [ v ] : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT DFSUtil ( i , visited ) NEW_LINE DEDENT DEDENT DEDENT def DFS ( v ) : NEW_LINE INDENT visited = [ False ] * v NEW_LINE DFSUtil ( v , visited ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = [ ] NEW_LINE v = 4 NEW_LINE g . append ( [ 0 , 1 ] ) NEW_LINE g . append ( [ 1 , 2 ] ) NEW_LINE g . append ( [ 2 , 0 ] ) NEW_LINE g . append ( [ 2 , 3 ] ) NEW_LINE g . append ( [ 3 , 3 ] ) NEW_LINE print ( " First Traversal is depth First Traversal ( starting from vertex 2 ) " ) NEW_LINE DFS ( 2 ) NEW_LINE DEDENT
def countDigits ( val , arr ) : NEW_LINE INDENT while ( val > 0 ) : NEW_LINE INDENT digit = val % 10 NEW_LINE arr [ digit ] += 1 NEW_LINE val = int ( val / 10 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT def countFrequency ( x , n ) : NEW_LINE INDENT freq_count = [ 0 ] * 10 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT val = x ** i NEW_LINE countDigits ( val , freq_count ) NEW_LINE DEDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT print ( freq_count [ i ] , end = " " ) NEW_LINE DEDENT DEDENT x = 15 NEW_LINE n = 3 NEW_LINE countFrequency ( x , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE flag = 0 NEW_LINE x = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == x or a [ i ] > x * 2 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT x = a [ i ] NEW_LINE DEDENT if flag : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n <= 2 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n > 2 : NEW_LINE INDENT print ( n - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ( a [ 0 ] == b [ 0 ] ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ a [ i ] - 1 ] = 1 NEW_LINE DEDENT DEDENT elif ( a [ 0 ] == b [ 0 ] ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT b [ a [ i ] - 1 ] = 1 NEW_LINE DEDENT DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == n ) : NEW_LINE INDENT print ( ' I co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' I co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co co
m = 6 ; n = 4 ; NEW_LINE def linearCheck ( ar , arr ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT matched = True ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ar [ i ] [ j ] != arr [ j ] ) : NEW_LINE INDENT matched = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( matched ) : NEW_LINE INDENT return i + 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT mat = [ [ 0 , 0 , 1 , 0 ] , [ 10 , 9 , 22 , 23 ] , [ 40 , 40 , 40 , 40 ] , [ 43 , 44 , 55 , 68 ] , [ 81 , 73 , 100 , 132 ] , [ 100 , 75 , 125 , 133 ] ] ; NEW_LINE row = [ 10 , 9 , 22 , 23 ] ; NEW_LINE print ( linearCheck ( mat , row ) ) ; NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE print ( - 1 if s % n else sum ( map ( lambda x : s // n , a ) ) ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE t = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE v = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE t_diff = [ 0 ] * ( t [ 0 ] + 1 ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT t_diff [ i ] = t [ i ] - t [ i - 1 ] NEW_LINE DEDENT prev = [ 0 ] * ( t [ 0 ] + 1 ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if prev [ i ] > v [ i ] : NEW_LINE INDENT prev [ i ] = v [ i ] NEW_LINE DEDENT DEDENT prev = [ 0 ] * ( t [ 0 ] + 1 ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if prev [ i ] > v [ i ] : NEW_LINE INDENT prev [ i ] = v [ i ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if prev [ i ] > v [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT prev [ i ] = v [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 7 * pow ( n , 2 ) - 7 * n + 7 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 5 * pow ( n , 2 ) - 5 * n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return ( n ** 2 ) + 2 * n + 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 3 ) + pow ( n , 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) - n - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return ( n ** 2 ) - 2 * n + 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + n - 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a > b ) : NEW_LINE INDENT x = a + b NEW_LINE DEDENT else : NEW_LINE INDENT x = 0 NEW_LINE DEDENT if ( a >= b ) : NEW_LINE INDENT print ( x , 0 , x , 1 ) NEW_LINE DEDENT elif ( a < b ) : NEW_LINE INDENT print ( x + 1 , b + 1 , x , 2 ) NEW_LINE DEDENT elif ( a > b ) : NEW_LINE INDENT print ( x - 1 , a + b , x , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , 0 , 0 , 1 ) NEW_LINE DEDENT
import sys NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE sys . setrecursionlimit ( max ( 1000 , 10 ** 9 ) ) NEW_LINE write = lambda x : sys . stdout . write ( x + " \n " ) NEW_LINE s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE s = s [ : k ] NEW_LINE n = len ( s ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( s [ i : i + n ] ) NEW_LINE DEDENT v . sort ( ) NEW_LINE print ( v [ k - 1 ] ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def fib ( self , n ) : NEW_LINE INDENT if n < len ( memo ) : NEW_LINE INDENT return memo [ n ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT memo [ i ] = ( memo [ i - 1 ] + memo [ i - 2 ] ) NEW_LINE DEDENT return memo [ n ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE n = 2 NEW_LINE out = sObj . fib ( n ) NEW_LINE print ( out ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a = input ( ) NEW_LINE b = input ( ) NEW_LINE ans = " " NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE n1 = len ( a ) NEW_LINE m1 = len ( b ) NEW_LINE if a [ n - 1 ] == " a " : NEW_LINE INDENT ans += chr ( 97 + i ) NEW_LINE DEDENT elif b [ n - 1 ] == " b " : NEW_LINE INDENT ans += chr ( 97 + i ) NEW_LINE DEDENT elif a [ n - 1 ] == " a " : NEW_LINE INDENT ans += chr ( 97 + i ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += chr ( 97 + i ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
PI = 3.1442 NEW_LINE def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) NEW_LINE res = 1 NEW_LINE sign = 1 NEW_LINE fact = 1 NEW_LINE pow = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * - 1 NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) NEW_LINE pow = pow * x * x NEW_LINE res = res + sign * pow / fact NEW_LINE DEDENT return res NEW_LINE DEDENT x = 50 NEW_LINE n = 5 NEW_LINE print ( ( cosXSertiesSum ( x , 5 ) * 1000000 ) / 1000000 ok ) NEW_LINE
def findNumber ( N , S ) : NEW_LINE INDENT i = ( ( N ) * ( N + 1 ) ) / 4 - ( S + 1 ) / 2 ) NEW_LINE return i NEW_LINE DEDENT def check ( N , S ) : NEW_LINE INDENT i = findNumber ( N , S ) NEW_LINE integerI = i NEW_LINE if ( i - integerI == 0 ) : NEW_LINE INDENT print ( " Yes : " , integerI , " , " , int ( integerI + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE S = 3 NEW_LINE check ( N , S ) NEW_LINE N = 5 NEW_LINE S = 3 NEW_LINE check ( N , S ) NEW_LINE DEDENT
def multipleOfThree ( K , dig0 , dig1 ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = ( dig0 + dig1 ) % 10 NEW_LINE sum = dig0 + dig1 NEW_LINE if ( K == 2 ) : NEW_LINE INDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT sum += temp NEW_LINE numberofGroups = ( K - 3 ) // 4 NEW_LINE remNumberofDigits = ( K - 3 ) % 4 NEW_LINE sum += ( numberofGroups * 20 ) NEW_LINE for i in range ( remNumberofDigits ) : NEW_LINE INDENT temp = ( 2 * temp ) % 10 NEW_LINE sum += temp NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K = 5 NEW_LINE dig0 = 3 NEW_LINE dig1 = 4 NEW_LINE if ( multipleOfThree ( K , dig0 , dig1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE if ( a [ n - 1 ] + a [ n - 2 ] ) <= ( b [ n - 1 ] + b [ n - 2 ] ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def countOcc ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( s ) - 3 ) : NEW_LINE INDENT c = 0 NEW_LINE l = 0 NEW_LINE a = 0 NEW_LINE p = 0 NEW_LINE for j in range ( i , i + 4 ) : NEW_LINE INDENT if s [ j ] == ' c ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if s [ j ] == ' l ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT if s [ j ] == ' a ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT if s [ j ] == ' p ' : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT if c == 1 and l == 1 and a == 1 and p == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " clapc " NEW_LINE print ( countOcc ( s ) ) NEW_LINE DEDENT
def countSteps ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return x // y NEW_LINE DEDENT return x // y + countSteps ( y , x % y ) NEW_LINE DEDENT x = 100 NEW_LINE y = 19 NEW_LINE print ( countSteps ( x , y ) ) NEW_LINE
from math import sqrt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isSunnyNum ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( n + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE if ( isSunnyNum ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
PI = 3.14159265 NEW_LINE def area_inscribed ( P , B , H ) : NEW_LINE INDENT return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT P = 3 NEW_LINE B = 4 NEW_LINE H = 5 NEW_LINE print ( area_inscribed ( P , B , H ) ) NEW_LINE DEDENT
def solve ( n , m , k , c ) : NEW_LINE INDENT ans = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = c [ i ] , c [ i ] NEW_LINE if a == b : NEW_LINE INDENT ans += a NEW_LINE DEDENT else : NEW_LINE INDENT ans += b NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT c = [ list ( input ( ) ) for i in range ( n ) ] NEW_LINE m = int ( input ( ) ) NEW_LINE k_list = [ input ( ) for i in range ( m ) ] NEW_LINE ans = solve ( n , m , k_list , c ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
def getCount ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = n - 1 - upperBound ( v , n , v [ i ] - 1 ) NEW_LINE if ( tmp == v [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def upperBound ( array , length , value ) : NEW_LINE INDENT low = 0 NEW_LINE high = length NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( value >= array [ mid ] ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE v = [ 1 , 2 , 3 , 4 ] NEW_LINE print ( getCount ( v , n ) ) NEW_LINE DEDENT
def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 ; NEW_LINE count_of_five = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT val = i ; NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val //= 2 ; NEW_LINE count_of_two += i ; NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val //= 5 ; NEW_LINE count_of_five += i ; NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 12 ; NEW_LINE print ( trailing_zeros ( N ) ) ; NEW_LINE DEDENT
def removeZero ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 != 0 ) : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def isEqual ( a , b ) : NEW_LINE INDENT if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = 105 NEW_LINE b = 105 NEW_LINE if ( isEqual ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) NEW_LINE def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE def main ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE edges = [ [ ] for _ in range ( n ) ] NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT si , ti = LI ( ) NEW_LINE edges [ si ] . append ( ti ) NEW_LINE DEDENT ans = 1 NEW_LINE for c in ' R ' : NEW_LINE INDENT if c == ' A ' : NEW_LINE INDENT cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT edges [ i + 1 ] . append ( ( cnt * edges [ i ] [ - 1 ] ) % 1000000007 ) NEW_LINE DEDENT cnt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT edges [ i + 1 ] . append ( ( cnt * edges [ i ] [ - 1 ] ) % 1000000007 ) NEW_LINE DEDENT cnt = 0 NEW_LINE DEDENT ans *= ( cnt + 1 ) NEW_LINE DEDENT print ( ans % 1000000007 ) NEW_LINE DEDENT main ( ) NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE print ( arr [ n // 2 ] ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a == 0 and b == 0 ) : NEW_LINE INDENT print ( "0 0" ) NEW_LINE DEDENT elif ( a >= b ) : NEW_LINE INDENT print ( ( a + b ) // 2 - 1 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a // 2 + b // 2 - 1 , 0 ) NEW_LINE DEDENT
from math import ceil NEW_LINE m , n = map ( int , input ( ) . split ( ) ) NEW_LINE m1 = ceil ( m / m ) NEW_LINE print ( f " { m1 } { n - m } " ) NEW_LINE
def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE arr1 = [ 0 for i in range ( 7 ) ] NEW_LINE arr2 = [ 0 for i in range ( 7 ) ] NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = bin ( s1 [ i ] ) . count ( '1' ) NEW_LINE arr1 [ set_bits ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = bin ( s2 [ i ] ) . count ( '1' ) NEW_LINE arr2 [ set_bits ] += 1 NEW_LINE DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = " geeks " NEW_LINE s2 = " forgeeks " NEW_LINE print ( totalPairs ( s1 , s2 ) ) NEW_LINE DEDENT
def countSubSeq ( i , sum , cnt , a , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( sum == 0 and cnt > 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE ans += countSubSeq ( i + 1 , sum , cnt , a , n ) NEW_LINE ans += countSubSeq ( i + 1 , sum + a [ i ] , cnt + 1 , a , n ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 1 , 2 , - 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( countSubSeq ( 0 , 0 , 0 , a , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i < n - 1 and j >= 0 : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE s = s [ i : i + j ] + s [ i + j : ] NEW_LINE if i == n - 1 : NEW_LINE INDENT s = s [ 0 : i + j ] + s [ i + j : ] NEW_LINE DEDENT else : NEW_LINE INDENT s = s [ i + j : ] + s [ i + j + 1 : ] NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT print ( s ) NEW_LINE
a , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = str ( i ) NEW_LINE y = list ( map ( int , x ) ) NEW_LINE x = x [ : : - 1 ] NEW_LINE y . sort ( ) NEW_LINE if y [ m - 1 ] == i : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
def pivotedBinarySearch ( arr , n , key ) : NEW_LINE INDENT pivot = findPivot ( arr , 0 , n - 1 ) NEW_LINE if ( pivot == - 1 ) : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) NEW_LINE DEDENT if ( arr [ pivot ] == key ) : NEW_LINE INDENT return pivot NEW_LINE DEDENT if ( arr [ 0 ] <= key ) : NEW_LINE INDENT return binarySearch ( arr , 0 , pivot - 1 , key ) NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) NEW_LINE DEDENT def findPivot ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( mid < high and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( arr [ low ] >= arr [ mid ] ) : NEW_LINE INDENT return findPivot ( arr , low , mid - 1 ) NEW_LINE DEDENT return findPivot ( arr , mid + 1 , high ) NEW_LINE DEDENT def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT arr1 = [ 5 , 6 , 7 , 8 , 9 , 10 , 1 , 2 , 3 ] NEW_LINE n = len ( arr1 ) NEW_LINE key = 3 NEW_LINE print ( " Index of the element is : " , pivotedBinarySearch ( arr1 , n , key ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE mod = 1000000007 NEW_LINE c = [ [ 0 ] * ( 4050 + 1 ) for i in range ( 4050 + 1 ) ] NEW_LINE c [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT c [ i ] [ j ] = ( c [ i - 1 ] [ j - 1 ] + c [ i - 1 ] [ j ] ) % mod NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT ans += c [ i ] [ j ] * ( c [ n ] [ j ] - c [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE p = [ ] NEW_LINE for x in range ( n ) : NEW_LINE INDENT p . append ( [ int ( x ) , i + 1 ] ) NEW_LINE DEDENT p . sort ( ) NEW_LINE ans = [ ] NEW_LINE ans . append ( p . index ( 1 ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] [ 1 ] == 1 : NEW_LINE INDENT ans . append ( i + 1 ) NEW_LINE DEDENT DEDENT ans . append ( p . index ( 1 ) ) NEW_LINE print ( len ( ans ) ) NEW_LINE print ( * ans ) NEW_LINE
import sys NEW_LINE file_input = sys . stdin NEW_LINE d = int ( file_input . readline ( ) ) NEW_LINE for line in file_input : NEW_LINE INDENT n = int ( line . strip ( ) ) NEW_LINE left = [ - 1 ] * n NEW_LINE right = [ - 1 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] = n NEW_LINE right [ i ] = n + 1 - i NEW_LINE DEDENT left_row = [ 0 ] * n NEW_LINE right_row = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT row = left [ i ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT right_row [ j ] = max ( right [ j ] , row [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT left_row [ j ] = left_row [ j ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ' ' . join ( left [ i ] ) ) NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 << 10 ) for j in range ( i , 1 << 10 ) if ( bin ( i ) . count ( '1' ) == '1' and bin ( j ) . count ( '1' ) == '0' ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def bin ( a ) : NEW_LINE INDENT return bin ( a ) [ : : - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE tbl = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = [ int ( j ) for j in input ( ) . split ( ) ] NEW_LINE k = temp [ 0 ] NEW_LINE tbl . append ( temp [ 1 : ] ) NEW_LINE DEDENT tbl . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if tbl [ i ] [ j ] == 1 : NEW_LINE INDENT print ( 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE list1 = [ ] NEW_LINE list1 . append ( input ( ) ) NEW_LINE list1 . append ( ' f ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' e ' ) NEW_LINE list1 . append ( ' a ' ) NEW_LINE list1 . append ( ' f ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' e ' ) NEW_LINE list1 . append ( ' f ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' e ' ) NEW_LINE list1 . append ( ' f ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' e ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' a ' ) NEW_LINE list1 . append ( ' f ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' e ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' a ' ) NEW_LINE list1 . append ( ' f ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' e ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' f ' ) NEW_LINE list1 . append ( ' a ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' e ' ) NEW_LINE list1 . append ( ' f ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' a ' ) NEW_LINE list1 . append ( ' f ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' e ' ) NEW_LINE list1 . append ( ' f ' ) NEW_LINE list1 . append ( ' c ' ) NEW_LINE list1 . append ( ' e ' ) NEW_LINE list1 . append ( ' f ' ) NEW_LINE list1 . append (
s = input ( ) NEW_LINE stk = [ ] NEW_LINE for c in s : NEW_LINE INDENT if stk and c == stk [ - 1 ] : NEW_LINE INDENT stk . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( c ) NEW_LINE DEDENT DEDENT print ( ' Yes ' if stk else ' No ' ) NEW_LINE
from collections import defaultdict NEW_LINE from itertools import permutations NEW_LINE from heapq import heappop , heappush NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return list ( map ( list , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def S ( ) : return list ( sys . stdin . readline ( ) ) [ : - 1 ] NEW_LINE def IR ( n ) : NEW_LINE INDENT return [ I ( ) for i in range ( n ) ] NEW_LINE DEDENT def LIR ( n ) : NEW_LINE INDENT return [ LI ( ) for i in range ( n ) ] NEW_LINE DEDENT def SR ( n ) : NEW_LINE INDENT return [ S ( ) for i in range ( n ) ] NEW_LINE DEDENT def LSR ( n ) : NEW_LINE INDENT return [ LS ( ) for i in range ( n ) ] NEW_LINE DEDENT sys . setrecursionlimit ( 1000000 ) NEW_LINE mod = 1000000007 NEW_LINE def solve ( ) : NEW_LINE INDENT x , y , e = LI ( ) NEW_LINE graph = defaultdict ( list ) NEW_LINE for i in range ( e ) : NEW_LINE INDENT u = LI ( ) NEW_LINE graph [ u [ 0 ] ] . append ( u [ 1 ] ) NEW_LINE graph [ u [ 1 ] ] . append ( u [ 0 ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( x ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( y ) : NEW_LINE INDENT if graph [ i ] [ j ] == 0 : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
MAX = 100 NEW_LINE def countMountains ( a , n ) : NEW_LINE INDENT A = [ [ 0 for i in range ( n + 2 ) ] for j in range ( n + 2 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT for j in range ( n + 2 ) : NEW_LINE INDENT if ( ( i == 0 ) or ( j == 0 ) or ( i == n + 1 ) or ( j == n + 1 ) ) : NEW_LINE INDENT A [ i ] [ j ] = - 2147483648 NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j ] ) and ( A [ i ] [ j ] > A [ i ] [ j - 1 ] ) and ( A [ i ] [ j ] > A [ i ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE n = 3 NEW_LINE print ( countMountains ( a , n ) ) NEW_LINE DEDENT
N = 100005 NEW_LINE d = [ 0 ] * N ; pre = [ 0 ] * N ; NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , int ( i ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 ; NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT pre [ i ] = ans ; NEW_LINE DEDENT DEDENT Positive_Divisors ( ) ; NEW_LINE n = 15 ; NEW_LINE print ( pre [ n ] ) ; NEW_LINE
t , m = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s [ 0 ] == " p " : NEW_LINE INDENT ans . append ( m ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( " h " ) NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if s [ 2 ] == " erase " : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE erase = 0 NEW_LINE last_ erase = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ans [ i ] == x : NEW_LINE INDENT erase += 1 NEW_LINE DEDENT else : NEW_LINE INDENT last_ erase = 1 NEW_LINE DEDENT DEDENT if erase == 0 : NEW_LINE INDENT ans . append ( " IL t eratosthen " ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( " h " ) NEW_LINE DEDENT DEDENT for k in ans : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT
from math import tan NEW_LINE def area_of_ li1 ( n , len1 ) : NEW_LINE INDENT P = ( len1 * n ) NEW_LINE A = ( len1 / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) NEW_LINE area = ( P * A ) / 2 NEW_LINE return area NEW_LINE DEDENT def area_of_triangle_inscribed ( n , len1 ) : NEW_LINE INDENT area = area_of_ li1 ( n , len1 ) NEW_LINE triangle = area / n NEW_LINE ins_tri = ( triangle * 3 ) NEW_LINE return ins_tri NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE len1 = 10 NEW_LINE print ( " % .3f " % ( area_of_triangle_inscribed ( n , len1 ) ) ) NEW_LINE DEDENT
MAX = 256 NEW_LINE def lastNonRepeating ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( freq [ ch ] == 1 ) : NEW_LINE INDENT return ( " " + ch ) NEW_LINE DEDENT DEDENT return " - 1" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksForGeeks " NEW_LINE n = len ( str ) NEW_LINE print ( lastNonRepeating ( str , n ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( x ) NEW_LINE b . append ( y ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == min ( a [ i ] , b [ i ] ) : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def y ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x ) ) NEW_LINE DEDENT def Point ( a , b ) : NEW_LINE INDENT n = 4 NEW_LINE h = ( b - a ) / n NEW_LINE sum = 0 NEW_LINE bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 NEW_LINE sum = sum + bl NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( " f ( x ) = { 0 : . 4f } " . format ( Point ( 0 , 4 ) ) ) NEW_LINE DEDENT
maxN = 300 NEW_LINE maxM = 300 NEW_LINE dp = [ [ 0 for i in range ( maxN ) ] for j in range ( maxM ) ] NEW_LINE v = [ [ 0 for i in range ( maxN ) ] for j in range ( maxM ) ] NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) NEW_LINE r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) NEW_LINE dp [ i ] [ curr ] = l NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE ans = findLen ( arr , 0 , ( ( 1 << 8 ) - 1 ) , n , m ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT
maxN = 20 NEW_LINE maxM = 64 NEW_LINE dp = [ [ 0 for i in range ( maxN ) ] for j in range ( maxM ) ] NEW_LINE v = [ [ 0 for i in range ( maxN ) ] for j in range ( maxM ) ] NEW_LINE def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) NEW_LINE r = findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) NEW_LINE dp [ i ] [ curr ] = l NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 7 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE m = 3 NEW_LINE ans = findLen ( arr , 0 , 0 , n , m ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT
from collections import defaultdict NEW_LINE def dfs ( G , u ) : NEW_LINE INDENT n = len ( G ) NEW_LINE if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT r = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if G [ u ] [ k ] == - 1 : NEW_LINE INDENT r += dfs ( G , u ) NEW_LINE DEDENT else : NEW_LINE INDENT r -= dfs ( G , k ) NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT G = defaultdict ( list ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT u , v , w = map ( int , input ( ) . split ( ) ) NEW_LINE G [ u ] . append ( v ) NEW_LINE G [ v ] . append ( w ) NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dfs ( G , i ) NEW_LINE s += s NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE def count_zeros ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT if x % 3 == 0 and x % 5 == 0 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT elif x % 7 == 0 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def count_zeros ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT if x % 3 == 0 and x % 5 == 0 : NEW_LINE INDENT result += count_zeros ( x ) NEW_LINE DEDENT elif x % 7 == 1 : NEW_LINE INDENT result += count_zeros ( x ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if n % 3 == 0 or n % 5 == 0 or n % 7 == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count_zeros ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE def minDiff ( arr , n , k ) : NEW_LINE INDENT result = sys . maxsize ; NEW_LINE arr . sort ( ) ; NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 100 , 300 , 200 , 1000 , 20 , 30 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 3 ; NEW_LINE print ( minDiff ( arr , n , k ) ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT l = 0 NEW_LINE r = 0 NEW_LINE n = [ int ( num ) for num in input ( ) . split ( ) ] NEW_LINE while r < n and l > 0 : NEW_LINE INDENT if l > n [ r ] : NEW_LINE INDENT l = n [ l ] NEW_LINE DEDENT elif r > n [ l ] : NEW_LINE INDENT r = n [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT l = n [ l ] NEW_LINE r += 1 NEW_LINE DEDENT DEDENT if l > r : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE c = int ( 1e9 ) + 1 NEW_LINE p = 1 NEW_LINE while c > 0 : NEW_LINE INDENT p += 1 NEW_LINE c -= 1 NEW_LINE DEDENT print ( p ) NEW_LINE DEDENT
def Mean ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT return sum / n NEW_LINE DEDENT def meanAbsDEVtion ( arr , n ) : NEW_LINE INDENT absSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT absSum = absSum + abs ( arr [ i ] - Mean ( arr , n ) ) NEW_LINE DEDENT return absSum / n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 15 , 15 , 17 , 18 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( meanAbsDEVtion ( arr , n ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = count ( 0 , 1 ) NEW_LINE LIMIT = 10 ** 9 NEW_LINE primes = eulerlib . list_primes ( 100 ) NEW_LINE def count ( primeIndex , product ) : NEW_LINE INDENT if primeIndex == len ( primes ) : NEW_LINE INDENT return 1 if product <= LIMIT else 0 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE while product <= LIMIT : NEW_LINE INDENT count += count ( primeIndex + 1 , product ) NEW_LINE product *= primes [ primeIndex ] NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE def maximumXOR ( n , l , r ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( ( int ) ( math . log2 ( r ) ) , - 1 , - 1 ) : NEW_LINE INDENT if ( n & ( 1 << i ) ) : NEW_LINE INDENT if ( ( x > r ) or ( x + ( 1 << i ) - 1 < l ) ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( x ^ ( 1 << i ) ) <= r ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT return n ^ x NEW_LINE DEDENT n = 7 NEW_LINE l = 2 NEW_LINE r = 23 NEW_LINE print ( " The output is " , maximumXOR ( n , l , r ) ) NEW_LINE
from math import sqrt NEW_LINE def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ False ] * ( N + 5 ) NEW_LINE i = 3 NEW_LINE while i * i <= N : NEW_LINE INDENT if ( arr [ i ] == False ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] = True NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT prime = [ ] NEW_LINE prime . append ( 2 ) NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] == False ) : NEW_LINE INDENT prime . append ( i ) NEW_LINE DEDENT DEDENT i = 0 NEW_LINE ans = 1 NEW_LINE while ( ans * prime [ i ] <= N and i < len ( prime ) ) : NEW_LINE INDENT ans *= prime [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 40 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE DEDENT
def CountTrailingZeros ( n ) : NEW_LINE INDENT bit = int ( toBinary ( n ) ) NEW_LINE bit1 = bin ( bit ) [ 2 : ] NEW_LINE bit1 = bit1 [ : : - 1 ] NEW_LINE zero = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if ( bit1 [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return zero NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE ans = CountTrailingZeros ( n ) NEW_LINE print ( ans ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( 2 * ( a + b ) , 2 * ( a + c ) , 2 * ( b + c ) ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def distinctSubString ( P , Q , K , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE sum += ord ( Q [ pos ] ) - ord ( '0' ) NEW_LINE s += P [ j ] NEW_LINE if ( sum <= K ) : NEW_LINE INDENT S . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT P = " abcde " NEW_LINE Q = "123456789123456789" NEW_LINE K = 5 NEW_LINE N = len ( P ) NEW_LINE print ( distinctSubString ( P , Q , K , N ) ) NEW_LINE DEDENT
import sys NEW_LINE def makeEven ( string ) : NEW_LINE INDENT string = list ( string ) NEW_LINE n = len ( string ) NEW_LINE even = sys . maxsize NEW_LINE index = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ( ord ( string [ i ] ) - ord ( '0' ) ) % 2 == 0 ) : NEW_LINE INDENT even = ( ord ( string [ i ] ) - ord ( '0' ) ) NEW_LINE index = i NEW_LINE DEDENT if ( even <= ( ord ( string [ n - 1 ] ) - ord ( '0' ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( even == sys . maxsize ) : NEW_LINE INDENT return string NEW_LINE DEDENT if ( even == sys . maxsize ) : NEW_LINE INDENT return string NEW_LINE DEDENT string [ index ] , string [ n - 1 ] = string [ n - 1 ] , string [ index ] NEW_LINE return string NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "13564 25 NEW_LINE print ( makeEven ( string ) ) NEW_LINE DEDENT
def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( j * i <= n ) : NEW_LINE INDENT div [ i * j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 ; NEW_LINE findDivisors ( n ) ; NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE pre = 0 NEW_LINE pre1 = 0 NEW_LINE pre2 = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s1 [ i ] == "1" : NEW_LINE INDENT pre += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre1 += 1 NEW_LINE DEDENT if s2 [ i ] == "1" : NEW_LINE INDENT pre2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += m - pre1 - pre2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
MAX_CHAR = 256 NEW_LINE def printDistinct ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index [ i ] = n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = str [ i ] NEW_LINE count [ x ] += 1 NEW_LINE if ( count [ x ] == 1 and x != ' ' ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if ( count [ x ] == 2 and x != ' ' ) : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE for i in range ( MAX_CHAR and index [ i ] != n ) : NEW_LINE INDENT print ( str [ index [ i ] ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksforGeeks " NEW_LINE printDistinct ( str ) NEW_LINE DEDENT
def calculate ( x , k , m ) : NEW_LINE INDENT result = x NEW_LINE k -= 1 NEW_LINE while ( k ) : NEW_LINE INDENT result = pow ( result , x ) NEW_LINE if ( result > m ) : NEW_LINE INDENT result %= m NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 NEW_LINE k = 2 NEW_LINE m = 3 NEW_LINE print ( calculate ( x , k , m ) ) NEW_LINE DEDENT
def converth number ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE res = " " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' or s [ i ] == '3' or s [ i ] == '5' or s [ i ] == '7' or s [ i ] == '9' ) : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT n = 18720 NEW_LINE converth number ( n ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = " " NEW_LINE for j in range ( n ) : NEW_LINE INDENT if s [ j ] not in ans : NEW_LINE INDENT ans += s [ j ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT k = a . count ( 1 ) NEW_LINE b . append ( a [ i ] ) NEW_LINE i += k NEW_LINE DEDENT b . sort ( ) NEW_LINE print ( * b ) NEW_LINE DEDENT
def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) // 2 NEW_LINE DEDENT def trace ( n , m ) : NEW_LINE INDENT an = 1 + ( n - 1 ) * ( m + 1 ) NEW_LINE rowMajorSum = sn ( n , an ) NEW_LINE an = 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE colMajorSum = sn ( n , an ) NEW_LINE return row w + col w NEW_LINE DEDENT N = 3 NEW_LINE M = 3 NEW_LINE print ( trace ( N , M ) ) NEW_LINE
from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE from typing import Counter NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE import math NEW_LINE h , w = map ( int , input ( ) . split ( ) ) NEW_LINE count = [ ] NEW_LINE for _ in range ( h ) : NEW_LINE INDENT data = input ( ) NEW_LINE count . append ( 0 ) NEW_LINE for j in range ( w ) : NEW_LINE INDENT if data [ j ] == " J " : NEW_LINE INDENT count [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT count = [ ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if data [ i ] == " O " : NEW_LINE INDENT count [ i ] += count [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT sm = 0 NEW_LINE for i in count : NEW_LINE INDENT sm += i * j NEW_LINE DEDENT print ( sm ) NEW_LINE
from math import sqrt NEW_LINE def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( ( n // i ) % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( ( i * i == n ) and ( i % k == 0 ) ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE DEDENT
def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE k = 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = " " NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp += chr ( X + 48 ) NEW_LINE DEDENT res = int ( temp ) % M NEW_LINE return res NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N // 2 , M ) % M NEW_LINE res = ( half * power ( 10 , N // 2 , M ) + half ) % M NEW_LINE return res NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N // 2 , M ) % M NEW_LINE res = ( half * power ( 10 , N // 2 + 1 , M ) + half * 10 + X ) % M NEW_LINE return res NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 6 NEW_LINE N = 14 NEW_LINE M = 9 NEW_LINE print ( findModuloByM ( X , N , M ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = a [ 0 ] * m NEW_LINE y = b [ 0 ] * m NEW_LINE r1 = x NEW_LINE r2 = y NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT r1 += ( i + 1 ) * ( ( a [ i ] - 1 ) // 2 ) NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT r2 += ( i + 1 ) * ( ( m - i ) // 2 ) NEW_LINE DEDENT print ( r1 + r2 ) NEW_LINE DEDENT
import sys NEW_LINE def findMaxDiff ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE return 0 NEW_LINE DEDENT min_val = sys . maxsize NEW_LINE max_val = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] - i ) > max_val ) : NEW_LINE INDENT max_val = arr [ i ] - i NEW_LINE DEDENT if ( ( arr [ i ] - i ) < min_val ) : NEW_LINE INDENT min_val = arr [ i ] - i NEW_LINE DEDENT DEDENT return ( max_val - min_val ) NEW_LINE DEDENT arr = [ 9 , 15 , 4 , 12 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxDiff ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE temp = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE temp . append ( s ) NEW_LINE DEDENT temp . sort ( ) NEW_LINE flag = True NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT if ( temp [ i ] [ j ] == ' # ' ) : NEW_LINE INDENT temp [ i + 1 ] [ j ] = ' # ' NEW_LINE temp [ i + 2 ] [ j ] = ' # ' NEW_LINE flag = False NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " YES " if flag else " NO " ) NEW_LINE
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = ( count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( a ) NEW_LINE f = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == s // n : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def isKthBitSet ( n , k ) : NEW_LINE INDENT if ( ( n >> ( k - 1 ) ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def setKthBit ( n , k ) : NEW_LINE INDENT return ( ( 1 << ( k - 1 ) ) | n ) NEW_LINE DEDENT def allBitsAreSet ( n ) : NEW_LINE INDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def bitsAreInAltOrder ( n ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) NEW_LINE return allBitsAreSet ( num ) NEW_LINE DEDENT def bitsAreInAltPatternInGivenRange ( n , l , r ) : NEW_LINE INDENT num = 0 NEW_LINE left_ shift = r NEW_LINE if ( isKthBitSet ( n , r ) ) : NEW_LINE INDENT num = n NEW_LINE left_ shift = r NEW_LINE DEDENT else : NEW_LINE INDENT num = setKthBit ( n , ( r + 1 ) ) NEW_LINE left_ shift = r + 1 NEW_LINE DEDENT num = num & ( ( 1 << left_ shift ) - 1 ) NEW_LINE num = num >> ( l - 1 ) NEW_LINE return bitsAreInAltOrder ( num ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 18 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if ( bitsAreInAltPatternInGivenRange ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) // ( factorial ( n - r ) * factorial ( r ) ) ) NEW_LINE DEDENT def NumberOfWays ( n , x , y ) : NEW_LINE INDENT return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE x = 4 NEW_LINE y = 2 NEW_LINE print ( NumberOfWays ( n , x , y ) ) NEW_LINE DEDENT
def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT result = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i <= n1 - 1 and j <= n2 - 1 : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 [ i ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ " geeksforgeeks " , " geeks " , " geek " , " geezer " ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT
from sys import stdin NEW_LINE point = 0 NEW_LINE n = int ( stdin . readline ( ) . rstrip ( ) ) NEW_LINE li = list ( map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) ) NEW_LINE li . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT point += min ( li [ 2 * i ] , li [ 2 * i + 1 ] , li [ 2 * i + 2 ] ) NEW_LINE DEDENT print ( point ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE now = int ( input ( ) ) NEW_LINE if now != 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT zero = False NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE if a == now + 1 : NEW_LINE INDENT ans += 1 NEW_LINE now = a NEW_LINE DEDENT elif a == now + 2 : NEW_LINE INDENT zero = True NEW_LINE now = a NEW_LINE DEDENT elif a != now + 2 : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def compute ( ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return str ( a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def findFrequencyUtil ( arr , low , high , freq ) : NEW_LINE INDENT if ( arr [ low ] == arr [ high ] ) : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE findFrequencyUtil ( arr , low , mid , freq ) NEW_LINE findFrequencyUtil ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT DEDENT def findFrequency ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( arr [ n - 1 ] + 1 ) ] NEW_LINE findFrequencyUtil ( arr , 0 , n - 1 , freq ) NEW_LINE for i in range ( 0 , arr [ n - 1 ] + 1 ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT print ( " Element " , i , " occurs " , freq [ i ] , " times " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 9 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE findFrequency ( arr , n ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 7 NEW_LINE totients = eulerlib . list_Totients ( LIMIT - 1 ) NEW_LINE for n in range ( 2 , len ( totients ) ) : NEW_LINE INDENT totients [ n ] = totients [ n ] NEW_LINE if n * min denominator < ( totients [ n ] + 1 ) * totients [ n ] and has_same_digits ( n , totients [ n ] ) : NEW_LINE INDENT minNumer = n NEW_LINE min denominator = totients [ n ] NEW_LINE DEDENT DEDENT if min denominator == 0 : NEW_LINE INDENT raise raise raise ValueError ( " Not found " ) NEW_LINE DEDENT return str ( minNumer ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def intersection ( a , b , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( a [ i ] > b [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( b [ j ] > a [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] , end = " " ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 ] NEW_LINE b = [ 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE intersection ( a , b , n , m ) NEW_LINE DEDENT
import math NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log ( a [ i ] ) NEW_LINE DEDENT x = math . exp ( sum / n ) NEW_LINE return int ( x + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectSquare ( arr , n ) : NEW_LINE INDENT minPerfectSq = 0 NEW_LINE lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectSq = lcm NEW_LINE cnt = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT if ( cnt % 2 != 0 ) : NEW_LINE INDENT minPerfectSq *= 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( lcm > 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( lcm % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= i NEW_LINE DEDENT if ( cnt % 2 != 0 ) : NEW_LINE INDENT minPerfectSq *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectSq NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectSquare ( arr , n ) ) NEW_LINE DEDENT
def subarrayCount ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE fast = 0 NEW_LINE slow = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] == 1 ) : NEW_LINE INDENT fast += 1 NEW_LINE DEDENT else : NEW_LINE INDENT length = fast - slow + 1 NEW_LINE result += length * ( length - 1 ) / 2 NEW_LINE fast = i NEW_LINE slow = i NEW_LINE DEDENT DEDENT if ( fast != slow ) : NEW_LINE INDENT length = fast - slow + 1 NEW_LINE result += length * ( length - 1 ) / 2 NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( subarrayCount ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE flag = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT if n % 4 == 0 : NEW_LINE INDENT if ( n // 2 ) % 4 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n // 2 >= 3 : NEW_LINE INDENT n -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += n NEW_LINE DEDENT n //= 2 NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT ans += flag NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < a [ i + 1 ] : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE DEDENT DEDENT ans . append ( a [ n - 1 ] ) NEW_LINE print ( * ans ) NEW_LINE
MAX_CHARS = 256 NEW_LINE def findSubString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dist_count = 0 NEW_LINE visited = [ False ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ ord ( str [ i ] ) ] == False ) : NEW_LINE INDENT visited [ ord ( str [ i ] ) ] = True NEW_LINE dist_count += 1 NEW_LINE DEDENT DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = MAX_CHARS NEW_LINE count = 0 NEW_LINE curr_count = [ 0 ] * MAX_CHARS NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count [ ord ( str [ j ] ) ] += 1 NEW_LINE if ( curr_count [ ord ( str [ j ] ) ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == dist_count ) : NEW_LINE INDENT while ( curr_count [ ord ( str [ start ] ) ] > 1 ) : NEW_LINE INDENT if ( curr_count [ ord ( str [ start ] ) ] > 1 ) : NEW_LINE INDENT curr_count [ ord ( str [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT return str [ start_index : start_index + min_len ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " aabcbcdbca " NEW_LINE print ( " Smallest window all distinct characters is : " , findSubString ( str ) ) NEW_LINE DEDENT
import math NEW_LINE import sys NEW_LINE e = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT a , b , c , d , e , f = map ( int , e . split ( ) ) NEW_LINE ans = 0 NEW_LINE if f > 1e9 : NEW_LINE INDENT print ( ( e + 1 ) / ( 1 + f ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE if a > 1e9 : NEW_LINE INDENT print ( max ( 0 , math . ceil ( ( e + c ) / ( 1 + f ) ) ) , ans ) NEW_LINE DEDENT else : NEW_LINE INDENT if b > 1e9 : NEW_LINE INDENT print ( max ( 0 , math . ceil ( ( e + c ) / ( 1 + f ) ) ) , ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( 0 , math . ceil ( ( e + c ) / ( 1 + f ) ) ) , ans ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
while True : NEW_LINE INDENT try : NEW_LINE INDENT data = list ( map ( int , input ( ) . split ( " , " ) ) ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT times = [ ] NEW_LINE for i in range ( 1 , len ( data ) ) : NEW_LINE INDENT times . append ( data [ i ] + data [ i - 1 ] ) NEW_LINE DEDENT times . sort ( ) NEW_LINE ans = sum ( times ) NEW_LINE if ans >= len ( times ) : NEW_LINE INDENT ans = len ( times ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT print ( ( even ) * ( n - 1 ) ) ; NEW_LINE print ( ( odd ) * ( n - 1 ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE countPairs ( arr , n ) ; NEW_LINE DEDENT
from sys import stdin , stdout NEW_LINE import math NEW_LINE from collections import defaultdict NEW_LINE import bisect NEW_LINE from sys import stdin , stdout NEW_LINE import operator NEW_LINE from math import gcd NEW_LINE import collections NEW_LINE import itertools NEW_LINE from collections import Counter NEW_LINE from collections import deque NEW_LINE from itertools import * NEW_LINE import heapq NEW_LINE import bisect NEW_LINE import random NEW_LINE import re NEW_LINE import sys NEW_LINE def get_input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def get_list ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def get_string ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE POWER = { 1 : 1 , 10 : 100 , 1000 : 1000 , 100000 : 100000 } NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x1 , x2 , p1 , p2 = get_input ( ) NEW_LINE if p1 > p2 : NEW_LINE INDENT print ( " > " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " < " ) NEW_LINE DEDENT DEDENT for _ in range ( n ) : NEW_LINE INDENT x1 , x2 , p1 , p2 = get_input ( ) NEW_LINE if p1 > p2 : NEW_LINE INDENT print ( " < " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " = " ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if i > x2 : NEW_LINE INDENT print ( " > " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " < " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if s [ i ] [ j ] == ' S ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def search ( arr , n , x ) : NEW_LINE INDENT front = 0 NEW_LINE back = n - 1 NEW_LINE while ( front <= back ) : NEW_LINE INDENT if ( arr [ front ] == x or arr [ back ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ] NEW_LINE x = 130 NEW_LINE n = len ( arr ) NEW_LINE if ( search ( arr , n , x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countFreq ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countFreq ( arr , n ) NEW_LINE DEDENT
import sys NEW_LINE def MinCostTree ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE st = [ sys . maxsize ] * n NEW_LINE st [ - 1 ] = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( st [ - 1 ] <= arr [ i ] ) : NEW_LINE INDENT x = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE ans += x * min ( st [ - 1 ] , arr [ i ] ) NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT ans += st [ i ] * st [ i - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MinCostTree ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE t = input ( ) NEW_LINE s_count = 0 NEW_LINE t_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ord1 = ord ( s [ i ] ) NEW_LINE ord2 = ord ( t [ i ] ) NEW_LINE if ord1 == ord2 : NEW_LINE INDENT s_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s_count += 1 NEW_LINE DEDENT if ord1 == ord2 : NEW_LINE INDENT t_count += 1 NEW_LINE DEDENT DEDENT print ( s_count ) NEW_LINE print ( * t_count , sep = ' ' ) NEW_LINE
def findEquation ( a , b ) : NEW_LINE INDENT sum = ( a + b ) NEW_LINE product = ( a * b ) NEW_LINE print ( " x ^ 2 - ( " , sum , " x ) + ( " , product , " ) = 0" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b = 2 , 3 NEW_LINE findEquation ( a , b ) NEW_LINE DEDENT
def circle_equation ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 NEW_LINE b = - 2 * y1 NEW_LINE c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) NEW_LINE print ( " x ^ 2 + ( " + str ( a ) + " x ) = " , " y ^ 2 + ( " + str ( b ) + " y ) = " , end = " " ) NEW_LINE print ( c ) NEW_LINE DEDENT x1 = 2 NEW_LINE y1 = - 3 NEW_LINE r = 8 NEW_LINE circle_ equation ( x1 , y1 , r ) NEW_LINE
def unique_combination ( l , sum , K , local , A ) : NEW_LINE INDENT if ( sum == K ) : NEW_LINE INDENT print ( " { " , end = " " ) NEW_LINE for i in range ( len ( local ) ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT print ( " " , end = " " ) NEW_LINE DEDENT print ( local [ i ] , end = " " ) NEW_LINE if ( i != len ( local ) - 1 ) : NEW_LINE INDENT print ( " , " , end = " " ) NEW_LINE DEDENT DEDENT print ( " } " ) NEW_LINE return NEW_LINE DEDENT for i in range ( l , len ( A ) ) : NEW_LINE INDENT if ( sum + A [ i ] > K ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == 1 and A [ i ] == A [ i - 1 ] and i > l ) : NEW_LINE INDENT continue NEW_LINE DEDENT local . append ( A [ i ] ) NEW_LINE unique_combination ( i + 1 , sum + A [ i ] , K , local , A ) NEW_LINE local . pop ( ) NEW_LINE DEDENT DEDENT def Combination ( A , K ) : NEW_LINE INDENT global global A NEW_LINE A . sort ( ) NEW_LINE local = [ ] NEW_LINE unique_combination ( 0 , 0 , K , local , A ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 10 , 1 , 2 , 7 , 6 , 1 , 5 ] NEW_LINE K = 8 NEW_LINE Combination ( A , K ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT k = int ( input ( ) ) NEW_LINE print ( k - a [ n - 1 ] - 1 ) NEW_LINE DEDENT
import re NEW_LINE n = int ( input ( ) ) NEW_LINE while n : NEW_LINE INDENT s = input ( ) NEW_LINE li = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT l = re . findall ( " [ abcdefghijklmnopqrstuvwxyz ] " , s ) NEW_LINE li . append ( l ) NEW_LINE DEDENT for i in range ( len ( li ) ) : NEW_LINE INDENT a = li [ i ] [ 0 ] NEW_LINE b = li [ i ] [ 1 ] NEW_LINE c = a + b NEW_LINE if c > 26 : NEW_LINE INDENT li [ i ] = c NEW_LINE n -= 1 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE n -= 1 NEW_LINE DEDENT
def findNature ( a , b , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( a & 1 ) NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( b & 1 ) NEW_LINE DEDENT if ( ( a & 1 ) == 0 ) : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 3 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return ( ( n - 1 ) % 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) % 3 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE n = 3 NEW_LINE if ( findNature ( a , b , n ) ) : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : break NEW_LINE c = math . sqrt ( a // 2 + 1 ) NEW_LINE for i in range ( 1 , c + 1 ) : NEW_LINE INDENT x = ( a - i ) / 2 NEW_LINE y = ( b - x ) / 2 + 1 NEW_LINE if x + y > c : break NEW_LINE elif x + y > c : NEW_LINE INDENT print ( c - x - y ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def max_sum ( a , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE if n == 1 : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE dp [ 1 ] = max ( a [ 1 ] , dp [ 0 ] ) NEW_LINE DEDENT elif n >= 3 : NEW_LINE INDENT dp [ 0 ] = max ( 0 , a [ 0 ] ) NEW_LINE dp [ 1 ] = max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) NEW_LINE dp [ 2 ] = max ( a [ 2 ] , max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) ) NEW_LINE i = 3 NEW_LINE while i < n : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , - 2 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( max_sum ( arr , n ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE vowels = { ' A ' , ' E ' , ' I ' , ' O ' , ' U ' , ' Y ' } NEW_LINE for ch in s : NEW_LINE INDENT if ch in vowels or ch in vowels : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
import sys NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT mini = sys . maxsize ; NEW_LINE for i in range ( 1 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT fir = i ; NEW_LINE sec = n // i ; NEW_LINE num1 = fir * k + sec ; NEW_LINE res = ( num1 // k ) * ( num1 % k ) ; NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num1 , mini ) ; NEW_LINE DEDENT num2 = sec * k + fir ; NEW_LINE res = ( num2 // k ) * ( num2 % k ) ; NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num2 , mini ) ; NEW_LINE DEDENT DEDENT DEDENT return mini ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 ; k = 6 ; NEW_LINE print ( minimumX ( n , k ) ) ; NEW_LINE n = 5 ; NEW_LINE k = 5 ; NEW_LINE print ( minimumX ( n , k ) ) ; NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE import collections NEW_LINE import itertools NEW_LINE import fractions NEW_LINE import functools NEW_LINE import heapq NEW_LINE import itertools NEW_LINE import numpy as np NEW_LINE def solve ( n , b ) : NEW_LINE INDENT return max ( solve ( n , b ) , solve ( n + 1 , b ) + solve ( n - 1 , b ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for ti in range ( 1 , t + 1 ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ' Case # { } : { } ' . format ( ti , solve ( n , b ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def SellingPrice ( CP , PP ) : NEW_LINE INDENT P_decimal = 1 + ( PP / 100 ) NEW_LINE res = P_decimal * CP NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT C = 720 NEW_LINE P = 13 NEW_LINE print ( SellingPrice ( C , P ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i , x in enumerate ( a ) : NEW_LINE INDENT if x > a [ i ] : NEW_LINE INDENT a [ i ] = x NEW_LINE DEDENT elif x < a [ i ] : NEW_LINE INDENT a [ i ] = x NEW_LINE DEDENT DEDENT print ( len ( ans ) ) NEW_LINE DEDENT
import math NEW_LINE n , s = map ( int , input ( ) . split ( ) ) NEW_LINE ans = - 1 NEW_LINE def f ( b , n ) : NEW_LINE INDENT if n < b : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return f ( b , n // b + 1 ) NEW_LINE DEDENT DEDENT def abc ( N , S ) : NEW_LINE INDENT if N == S : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT else : NEW_LINE INDENT for b in range ( 2 , int ( math . sqrt ( N ) ) + 2 ) : NEW_LINE INDENT if f ( b , N ) == S : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT tmp = - 1 NEW_LINE for p in range ( 1 , 11 ) : NEW_LINE INDENT if ( N - S ) % p != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT b = ( N - S ) // p + 1 NEW_LINE if f ( b , N ) == S : NEW_LINE INDENT tmp = b NEW_LINE DEDENT DEDENT return tmp NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT N , S = abc ( i , N ) NEW_LINE if N < S : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
m , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for x in range ( 1 , m * b + 1 ) : NEW_LINE INDENT y = x - ( x // m ) NEW_LINE r = y - ( x % m ) NEW_LINE ans = max ( ans , ( r * ( y + 1 ) ) * ( r + 1 ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE m = 10 NEW_LINE check ( n , m ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] - i ) // 2 != 1 ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT if ( k >= 2 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
a , b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if a > b : NEW_LINE INDENT print ( b - a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a - b ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = [ ' a ' ] * n NEW_LINE for i in range ( k ) : NEW_LINE INDENT t = input ( ) NEW_LINE b = input ( ) NEW_LINE b = b . replace ( t [ 0 ] , ' a ' ) NEW_LINE a = a . index ( b ) NEW_LINE ans [ a ] = b NEW_LINE DEDENT ans = ' ' . join ( ans ) NEW_LINE print ( ans ) NEW_LINE
def findNthOccur ( str , ch , N ) : NEW_LINE INDENT occur = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT occur += 1 NEW_LINE DEDENT if ( occur == N ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT str = " geeks " NEW_LINE ch = ' e ' NEW_LINE N = 2 NEW_LINE print ( findNthOccur ( str , ch , N ) ) NEW_LINE
a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = [ ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT k . append ( a . count ( i + 1 ) ) NEW_LINE DEDENT if len ( k ) == 1 and k . count ( 4 ) == 1 : NEW_LINE INDENT print ( ' Bear ' ) NEW_LINE DEDENT elif len ( k ) == 2 and k . count ( 2 ) == 1 : NEW_LINE INDENT print ( ' Elephant ' ) NEW_LINE DEDENT elif len ( k ) == 3 and k . count ( 4 ) == 1 : NEW_LINE INDENT print ( ' Bear ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' extenden ' ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 1000000000000000 NEW_LINE MODULUS = 10 ** 9 NEW_LINE splitCount = max ( splitCount // 3 , 1 ) NEW_LINE splitAt = int ( LIMIT // ( splitCount + 1 ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , splitAt + 1 ) : NEW_LINE INDENT count = LIMIT // i % MODULUS NEW_LINE term = i * i % MODULUS NEW_LINE term = term * count % MODULUS NEW_LINE ans = ( ans + term ) % MODULUS NEW_LINE DEDENT for i in range ( splitCount , 1 ) : NEW_LINE INDENT start = LIMIT // ( i + 1 ) NEW_LINE end = LIMIT // i NEW_LINE sumSquares = sumSquares % MODULUS - sumSquares % MODULUS NEW_LINE sumSquares = ( sumSquares + MODULUS ) % MODULUS NEW_LINE sum = ( sum + i * sumSquares % MODULUS ) % MODULUS NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE n , k , z = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( z + 1 ) : NEW_LINE INDENT d = k - 2 * i NEW_LINE if d < 0 : NEW_LINE INDENT break NEW_LINE DEDENT s += a [ d ] NEW_LINE ans = max ( ans , s + d * ( n - 1 ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != i + 1 : NEW_LINE INDENT ans . append ( str ( i + 1 ) ) NEW_LINE DEDENT DEDENT x = len ( ans ) NEW_LINE if x == 2 : NEW_LINE INDENT ans . append ( "0" ) NEW_LINE DEDENT elif x % 2 == 0 : NEW_LINE INDENT x = 2 * x - 1 NEW_LINE ans . append ( str ( x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( str ( x ) ) NEW_LINE DEDENT print ( * ans ) NEW_LINE
def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE z = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = input ( ) . split ( ) NEW_LINE key = int ( line [ 0 ] ) * 60 + int ( line [ 1 ] ) NEW_LINE z . append ( [ key , line [ 2 ] ] ) NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if z [ i ] [ j ] [ k ] >= z [ k ] [ 2 ] : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( result ) NEW_LINE DEDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , p = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE r = [ 0 ] * n NEW_LINE f = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ i ] = r [ i ] % n NEW_LINE f += 1 NEW_LINE if f > p : NEW_LINE INDENT p = r [ i ] NEW_LINE DEDENT DEDENT ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if r [ i ] == p : ans = i NEW_LINE else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
from collections import deque NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE q_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q_list = deque ( q_list ) NEW_LINE ans = [ ] NEW_LINE for q in q_list : NEW_LINE INDENT q = int ( input ( ) ) NEW_LINE q_list . append ( q ) NEW_LINE cnt = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE tmp = 0 NEW_LINE while left < n : NEW_LINE INDENT while right < n and q_list [ right ] - q_list [ left ] > 0 : NEW_LINE INDENT q_list . popleft ( ) NEW_LINE right += 1 NEW_LINE DEDENT if left == n - 1 : NEW_LINE INDENT break NEW_LINE DEDENT cnt += right - left + 1 NEW_LINE left += 1 NEW_LINE tmp += q_list [ left ] NEW_LINE DEDENT ans . append ( tmp ) NEW_LINE DEDENT for q in q_list : NEW_LINE INDENT print ( ans [ q ] ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = [ int ( num ) for num in input ( ) . split ( ) ] NEW_LINE toadd = 0 NEW_LINE cmpr = '9' * len ( b ) NEW_LINE if int ( a ) == int ( b ) : NEW_LINE INDENT toadd = 1 NEW_LINE DEDENT print ( ( int ( a ) + 1 + toadd ) ) NEW_LINE DEDENT
maxSize = 10 ** 5 + 5 NEW_LINE isFib = [ False ] * maxSize NEW_LINE prefix = [ 0 ] * maxSize NEW_LINE def digitSum ( num ) : NEW_LINE INDENT s = 0 NEW_LINE while ( num != 0 ) : NEW_LINE INDENT s = s + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return s NEW_LINE DEDENT def generateFibonacci ( ) : NEW_LINE INDENT global isFib , prefix , isFib NEW_LINE prev , curr = 0 , 1 NEW_LINE isFib [ prev ] = isFib [ curr ] = True NEW_LINE while ( curr < maxSize ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if ( temp < maxSize ) : NEW_LINE INDENT isFib [ temp ] = True NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def precompute ( k ) : NEW_LINE INDENT generateFibonacci ( ) NEW_LINE for i in range ( 1 , maxSize ) : NEW_LINE INDENT sum = digitSum ( i ) NEW_LINE if ( isFib [ sum ] == True and sum % k == 0 ) : NEW_LINE INDENT prefix [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , maxSize ) : NEW_LINE INDENT prefix [ i ] = prefix [ i ] + prefix [ i - 1 ] NEW_LINE DEDENT DEDENT def performQueries ( k , q , query ) : NEW_LINE INDENT precompute ( k ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l = query [ i ] [ 0 ] NEW_LINE r = query [ i ] [ 1 ] NEW_LINE cnt = prefix [ r ] - prefix [ l - 1 ] NEW_LINE print ( cnt ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT query = [ [ 1 , 11 ] , [ 5 , 15 ] , [ 2 , 24 ] ] NEW_LINE k = 2 NEW_LINE q = len ( query ) NEW_LINE performQueries ( k , q , query ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for j in range ( 3 ) : NEW_LINE INDENT if y <= x : NEW_LINE INDENT ans += x NEW_LINE DEDENT elif y >= x : NEW_LINE INDENT ans += x - y NEW_LINE DEDENT else : NEW_LINE INDENT ans += x + y NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def isPalindrome ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE for i in range ( l // 2 ) : NEW_LINE INDENT if ( str [ i ] != str [ l - 1 - i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def createStringAndCheckPalindrome ( N ) : NEW_LINE INDENT sub = " " + str ( N ) NEW_LINE res_str = " " NEW_LINE sum = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT digit = N % 10 NEW_LINE sum += digit NEW_LINE N = N // 10 NEW_LINE DEDENT while ( len ( res_str ) < sum ) : NEW_LINE INDENT res_str += sub NEW_LINE DEDENT if ( len ( res_str ) > sum ) : NEW_LINE INDENT res_str = res_str [ : sum ] NEW_LINE DEDENT if ( isPalindrome ( res_str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT N = 10101 NEW_LINE if ( createStringAndCheckPalindrome ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE lst = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE lst . append ( ( a , b ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if lst [ i ] [ j ] == " S " : NEW_LINE INDENT lst [ i ] [ j ] = 1 NEW_LINE DEDENT elif lst [ i ] [ j ] == " H " : NEW_LINE INDENT lst [ i ] [ j ] = 1 NEW_LINE DEDENT elif lst [ i ] [ j ] == " C " : NEW_LINE INDENT lst [ i ] [ j ] = 1 NEW_LINE DEDENT elif lst [ i ] [ j ] == " D " : NEW_LINE INDENT lst [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in lst : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
def sum_even_and_even_index ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 5 , 6 , 12 , 1 , 18 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Sum of even numbers at even indices is " , sum_even_and_even_index ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE s = input ( ) NEW_LINE k = 1 NEW_LINE flag = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if k > 1 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT k = k - 2 NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT fl = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] >= n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] < 2 * n ) : NEW_LINE INDENT print ( arr [ i ] % n , end = " " ) NEW_LINE fl = 1 NEW_LINE DEDENT DEDENT arr [ arr [ i ] % n ] += n NEW_LINE DEDENT if ( not ( fl ) ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT arr = [ 1 , 6 , 3 , 1 , 3 , 6 , 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printDuplicates ( arr , arr_size ) NEW_LINE
n = int ( input ( ) ) NEW_LINE print ( sum ( list ( map ( lambda x : ( x / ( n - i ) ) , range ( n ) , n ) ) ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) // 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE DEDENT
def maxhand ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( maxhand ( n ) ) NEW_LINE DEDENT
def grayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( grayCode ( n ) ) NEW_LINE DEDENT
def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE print ( Max_Sum ( n ) ) NEW_LINE DEDENT
def possibleways ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n % 4 == 0 ) : NEW_LINE INDENT return n // 4 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 20 NEW_LINE print ( possibleways ( n ) ) NEW_LINE DEDENT
def CountSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT return 1 + CountSetBits ( n >> 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return CountSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 21 NEW_LINE print ( CountSetBits ( n ) ) NEW_LINE DEDENT
def sum ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 3 NEW_LINE n = 2 NEW_LINE print ( sum ( m , n ) ) NEW_LINE DEDENT
def SUM ( n , m ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return ( sum * ( sum + 1 ) / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( " SUM ( " , n , " , " , m , " ) : " , SUM ( n , m ) ) NEW_LINE DEDENT
def maxLCM ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( maxLCM ( n ) ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) // 12 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
def cntWays ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) // 4 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 18 NEW_LINE print ( cntWays ( n ) ) NEW_LINE DEDENT
def find_composite_ nos ( n ) : NEW_LINE INDENT print ( 9 * n , 8 * n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE find_composite_ nos ( n ) NEW_LINE DEDENT
def findThirdDigit ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 6 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE print ( findThirdDigit ( n ) ) NEW_LINE DEDENT
def countMaxIntersect ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) / 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n + 1 ) + sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE DEDENT
def highestPowerOf2 ( n ) : NEW_LINE INDENT return ( n & ( ~ ( n - 1 ) ) ) NEW_LINE DEDENT n = 48 NEW_LINE print ( highestPowerOf2 ( n ) ) NEW_LINE
def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( countIntersections ( n ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE print ( ' None ' . join ( s . split ( ) ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE flag = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] % arr [ 0 ] != 0 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
import sys NEW_LINE import os NEW_LINE import math NEW_LINE from statistics import * NEW_LINE from collections import * NEW_LINE from operator import itemgetter NEW_LINE stdin = sys . stdin NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE ns = lambda : stdin . readline ( ) NEW_LINE n = ni ( ) NEW_LINE print ( ' ABC ' if n < 1200 else ' ARC ' ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ a [ 0 ] ] NEW_LINE c = [ a [ 0 ] ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT b . append ( c [ - 1 ] ) NEW_LINE c . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( c [ - 1 ] ) NEW_LINE c . append ( 1 ) NEW_LINE DEDENT DEDENT b . reverse ( ) NEW_LINE c . reverse ( ) NEW_LINE ans = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += str ( b [ i ] ) + " " NEW_LINE DEDENT ans += str ( c [ n - 1 ] ) NEW_LINE print ( ans ) NEW_LINE
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x != 0 and y != 0 and z != 0 ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 12 NEW_LINE y = 15 NEW_LINE z = 5 NEW_LINE print ( " Minimum of 3" , " numbers is " , smallest ( x , y , z ) ) NEW_LINE DEDENT
c = [ int ( input ( ) ) for i in range ( 5 ) ] NEW_LINE a = c [ 0 ] * c [ 1 ] + c [ 2 ] * c [ 3 ] + c [ 4 ] * c [ 5 ] + c [ 5 ] * c [ 4 ] + c [ 6 ] * c [ 6 ] NEW_LINE if a >= 1000 : print ( 1 ) NEW_LINE else : print ( 0 ) NEW_LINE
import math NEW_LINE def main ( ) : NEW_LINE INDENT txt = input ( ) NEW_LINE txt = txt . split ( ) NEW_LINE m = int ( txt [ 0 ] ) NEW_LINE r = int ( txt [ 1 ] ) NEW_LINE print ( round ( ( m * ( m - 1 ) / 3 ) * r , 2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT return ( floor ( cbrt ( b ) ) - ceil ( cbrt ( a ) ) + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 7 NEW_LINE b = 28 NEW_LINE print ( " Count of cubes is " , countCubes ( a , b ) ) NEW_LINE DEDENT
from heapq import heappop , heappush NEW_LINE def solve ( ) : NEW_LINE INDENT D , N = map ( int , input ( ) . split ( ) ) NEW_LINE if D == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT A = [ ] NEW_LINE for _ in range ( N ) : NEW_LINE INDENT a , e , r = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( ( e , r ) ) NEW_LINE DEDENT M = 100 ** 30 NEW_LINE INF = 10 ** 20 NEW_LINE que = [ ] NEW_LINE heappush ( que , ( 0 , 0 ) ) NEW_LINE while que : NEW_LINE INDENT cost , to , cnt = heappop ( que ) NEW_LINE if cost > INF : NEW_LINE INDENT continue NEW_LINE DEDENT for to , r in zip ( A , E [ 1 : ] ) : NEW_LINE INDENT tmp = heappop ( que ) NEW_LINE if to == INF : NEW_LINE INDENT continue NEW_LINE DEDENT tmp = min ( cost , tmp ) NEW_LINE heappush ( que , ( cost + 1 , to , cnt + 1 ) ) NEW_LINE DEDENT DEDENT return True if cnt == 10 else False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ans = [ ] NEW_LINE while True : NEW_LINE INDENT D , N = map ( int , input ( ) . split ( ) ) NEW_LINE if D == 0 and N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT triangle = 0 NEW_LINE for i in range ( 1 , 1000000 ) : NEW_LINE INDENT if eulerlib . sqrt ( i ) < i : NEW_LINE INDENT raise ValueError ( " Overflow " ) NEW_LINE DEDENT triangle += i NEW_LINE if count_Divisors ( triangle ) > 500 : NEW_LINE INDENT return str ( triangle ) NEW_LINE DEDENT DEDENT DEDENT def count_Divisors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE for i in range ( 1 , end ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT if end * end == n : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def find delta ( a , b , c , d ) : NEW_LINE INDENT return ( b * c - a * d ) // ( d - c ) NEW_LINE DEDENT a = 3 NEW_LINE b = 9 NEW_LINE c = 3 NEW_LINE d = 5 NEW_LINE print ( " \u0394 X = " , end = " " ) NEW_LINE for i in range ( delta ( a , b , c , d ) ) : NEW_LINE INDENT print ( int ( find delta ( a , b , c , d , i ) ) ) NEW_LINE DEDENT
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True ; NEW_LINE DEDENT p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def findPrimePair ( n ) : NEW_LINE INDENT isPrime = [ False ] * ( n + 1 ) ; NEW_LINE SieveOfEratosthenes ( n , isPrime ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPrime [ i ] and isPrime [ n - i ] ) : NEW_LINE INDENT print ( i , n - i ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 74 ; NEW_LINE findPrimePair ( n ) ; NEW_LINE DEDENT
def replaceDigit ( x , d1 , d2 ) : NEW_LINE INDENT result = 0 NEW_LINE multiply = 1 NEW_LINE while ( x % 10 > 0 ) : NEW_LINE INDENT remainder = x % 10 NEW_LINE if ( remainder == d1 ) : NEW_LINE INDENT result = result + d2 * multiply NEW_LINE DEDENT else : NEW_LINE INDENT result = result + remainder * multiply NEW_LINE DEDENT multiply *= 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return result NEW_LINE DEDENT x = 645 NEW_LINE d1 = 6 NEW_LINE d2 = 5 NEW_LINE print ( replaceDigit ( x , d1 , d2 ) ) NEW_LINE
def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT if ( i == n - 1 - j ) : NEW_LINE INDENT print ( " / " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " \ " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT if ( printPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT
def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT hm = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in hm : NEW_LINE INDENT hm [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hm [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT twice_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if sum - arr [ i ] in hm : NEW_LINE INDENT twice_count += hm [ sum - arr [ i ] ] NEW_LINE DEDENT if sum - arr [ i ] == arr [ i ] : NEW_LINE INDENT twice_count -= 1 NEW_LINE DEDENT DEDENT return twice_count // 2 NEW_LINE DEDENT sum = 6 NEW_LINE print ( " Count of pairs is " , getPairsCount ( arr , len ( arr ) , sum ) ) NEW_LINE
def Count_subarray ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT subarray_sum = 0 NEW_LINE remaining_sum = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT subarray_sum += arr [ k ] NEW_LINE DEDENT for l in range ( i ) : NEW_LINE INDENT remaining_sum += arr [ l ] NEW_LINE DEDENT for l in range ( j + 1 , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] NEW_LINE DEDENT if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 10 , 9 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( Count_subarray ( arr , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT if a + x <= b : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def main ( ) : NEW_LINE INDENT mod = 1000000007 NEW_LINE inf = float ( ' inf ' ) NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE def ii ( ) : return int ( input ( ) ) NEW_LINE def mi ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def mi_0 ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) NEW_LINE def lmi ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def lmi_0 ( ) : return list ( map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) ) NEW_LINE def li ( ) : return list ( input ( ) ) NEW_LINE n = ii ( ) NEW_LINE scores = [ ii ( ) for _ in range ( n ) ] NEW_LINE scores . sort ( ) NEW_LINE if sum ( scores ) % 10 != 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT res = sum ( scores ) NEW_LINE scores . sort ( ) NEW_LINE if res % 10 == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT res = res // 10 + 1 NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from collections import Counter NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 9999999999 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = i NEW_LINE while j < n and arr [ j ] == arr [ i ] : NEW_LINE INDENT j += k NEW_LINE DEDENT ans = min ( ans , j - i ) NEW_LINE i = j NEW_LINE DEDENT return ans NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def findRepeatingNumber ( arr , n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) NEW_LINE range = ( n // sq + 1 ) NEW_LINE count = [ 0 ] * ( sq + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT count [ ( arr [ i ] - 1 ) // sq ] += 1 NEW_LINE DEDENT selected_ block = range - 1 NEW_LINE for i in range ( sq - 1 ) : NEW_LINE INDENT if ( count [ i ] > sq ) : NEW_LINE INDENT selected_ block = i NEW_LINE break NEW_LINE DEDENT DEDENT m = dict ( ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( selected_ block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_ block + 1 ) * sq ) ) : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE if ( m [ arr [ i ] ] == 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 , 5 , 4 ] NEW_LINE n = 5 NEW_LINE print ( " One of the numbers repeated in the array is : " , findRepeatingNumber ( arr , n ) ) NEW_LINE
from math import sqrt NEW_LINE def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT maxPrime = 2 NEW_LINE n >>= 1 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT maxPrime = i NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT return maxPrime NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE n = 25698751364526 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE odd = 0 NEW_LINE even = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] % 2 == 0 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT print ( min ( odd , even ) ) NEW_LINE DEDENT
a = input ( ) NEW_LINE ans = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] == "1" : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT elif a [ i ] == "0" : NEW_LINE INDENT sum -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if sum == 0 : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def pythagoreanTriplet ( n ) : NEW_LINE INDENT for i in range ( 1 , n // 3 + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n // 2 + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT print ( i , " , " , j , " , " , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " No Triplet " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE pythagoreanTriplet ( n ) NEW_LINE DEDENT
from math import floor NEW_LINE def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 33 NEW_LINE b = - 24 NEW_LINE print ( countDigits ( a , b ) ) NEW_LINE DEDENT
def indexOfFirstOne ( arr , low , high ) : NEW_LINE INDENT mid = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] == 1 and ( mid == 0 or arr [ mid - 1 ] == 0 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( arr [ mid ] == 1 ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return mid NEW_LINE DEDENT def posOfFirstOne ( arr ) : NEW_LINE INDENT l = 0 NEW_LINE h = 1 NEW_LINE while ( arr [ h ] == 0 ) : NEW_LINE INDENT l = h NEW_LINE h = 2 * h NEW_LINE DEDENT return indexOfFirstOne ( arr , l , h ) NEW_LINE DEDENT arr = [ 0 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE print ( " Index = " , posOfFirstOne ( arr ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE z = 0 NEW_LINE while n > 0 : NEW_LINE INDENT z += 1 NEW_LINE if n & 1 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def solve ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 255 : NEW_LINE INDENT return True NEW_LINE DEDENT ans = ' NA ' NEW_LINE if n % 2 == 0 : NEW_LINE INDENT ans = '0000' NEW_LINE DEDENT n = int ( n / 2 ) NEW_LINE if n >= - 10 ** ( - 1 ) : NEW_LINE INDENT ans = '0000' NEW_LINE DEDENT c = 1 NEW_LINE while c < n : NEW_LINE INDENT c *= 2 NEW_LINE c += 1 NEW_LINE DEDENT if n >= - 10 ** ( - 1 ) : NEW_LINE INDENT ans = '0000' NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( n ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT sum = 0 ; rem = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 ; NEW_LINE sum += rem ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def findX ( n ) : NEW_LINE INDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( i + digSum ( i ) == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 43 ; NEW_LINE print ( " x = " , findX ( n ) ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 1 NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , cnt ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT ans = max ( ans , cnt ) NEW_LINE print ( ans ) NEW_LINE
import sys NEW_LINE f = sys . stdin NEW_LINE for line in f : NEW_LINE INDENT H , W = map ( int , line . split ( ) ) NEW_LINE print ( H - W ) NEW_LINE DEDENT
def performQueries ( A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in q : NEW_LINE INDENT L = i [ 0 ] NEW_LINE R = i [ 1 ] NEW_LINE if ( L > R ) : NEW_LINE INDENT temp = L NEW_LINE L = R NEW_LINE R = temp NEW_LINE DEDENT if ( L != R and pref_xor [ R ] == pref_xor [ L - 1 ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ [ 1 , 5 ] , [ 1 , 4 ] , [ 3 , 4 ] ] NEW_LINE performQueries ( Arr , q ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE res = 1 NEW_LINE i = 0 NEW_LINE k = 1 NEW_LINE while i < n : NEW_LINE INDENT while i < n and arr [ i ] < k : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT res += 1 NEW_LINE k -= 1 NEW_LINE DEDENT k += 1 NEW_LINE i += 1 NEW_LINE DEDENT print ( res ) NEW_LINE
from math import sqrt NEW_LINE n = int ( input ( ) ) NEW_LINE r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = sqrt ( max ( r ) * max ( b ) / ( min ( r ) * max ( b ) ) ) NEW_LINE print ( ' { : . 8f } ' . format ( d ) ) NEW_LINE
def trapeziumPattern ( num ) : NEW_LINE INDENT firsthalf = 1 NEW_LINE secondhalf = ( num * num ) + 1 NEW_LINE numOfSpace = 0 NEW_LINE for numOfLines in range ( num , 0 , - 1 ) : NEW_LINE INDENT for numOfSpaceCounter in range ( numOfSpace , 0 , - 1 ) : NEW_LINE INDENT print ( " " , end = " " ) NEW_LINE DEDENT for firstHalfCounter in range ( 1 , num + 1 ) : NEW_LINE INDENT if firstHalfCounter == numOf lines : NEW_LINE INDENT firsthalf += 1 NEW_LINE DEDENT else : NEW_LINE INDENT firsthalf += 1 NEW_LINE DEDENT print ( firsthalf , end = " " ) NEW_LINE DEDENT for secondHalfCounter in range ( 1 , num + 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE numOfSpace += 2 NEW_LINE secondhalf = ( secondhalf - 1 ) - ( ( numOfSpace - 1 ) * 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT trapeziumPattern ( 3 ) NEW_LINE DEDENT
def findPerm ( n , difference ) : NEW_LINE INDENT ans = [ ] NEW_LINE ans . sort ( ) NEW_LINE ans . append ( 0 ) NEW_LINE x = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT diff = difference [ i ] NEW_LINE x = x + diff NEW_LINE ans . append ( x ) NEW_LINE DEDENT anss = [ ] NEW_LINE for obj in ans : NEW_LINE INDENT anss . append ( obj ) NEW_LINE DEDENT anss . sort ( ) NEW_LINE flag = - 1 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT res = ans [ i ] - ans [ i - 1 ] NEW_LINE if ( res != 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT mpp = dict ( ) NEW_LINE j = 1 NEW_LINE value_at_index = [ ] NEW_LINE for x in ans : NEW_LINE INDENT mpp [ x ] = j NEW_LINE j += 1 NEW_LINE DEDENT for x in anss : NEW_LINE INDENT value_at_index . append ( mpp [ x ] ) NEW_LINE DEDENT for x3 in value_at_index : NEW_LINE INDENT print ( x3 , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT difference = [ ] NEW_LINE difference . append ( 2 ) NEW_LINE difference . append ( - 3 ) NEW_LINE difference . append ( 2 ) NEW_LINE n = len ( difference ) + 1 NEW_LINE findPerm ( n , difference ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return ( count ) NEW_LINE DEDENT def printK pimes ( k , n ) : NEW_LINE INDENT for i in range ( 1 , 2 , n + 1 ) : NEW_LINE INDENT if ( countPrimeFactors ( num ) == k ) : NEW_LINE INDENT print ( str ( num ) + " " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE k = 2 NEW_LINE print ( " First " , n , k , " - almost prime numbers : " ) NEW_LINE printK pimes ( k , n ) NEW_LINE DEDENT
def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 ] * 50 NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 29 NEW_LINE K = 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE solve ( N , K ) NEW_LINE DEDENT
def toNum ( lis ) : NEW_LINE INDENT ret = 0 NEW_LINE for i in range ( len ( lis ) ) : NEW_LINE INDENT ret += lis [ - i - 1 ] * 10 ** ( i - 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE print ( toNum ( n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def normal ( m , n ) : NEW_LINE INDENT N = ( ( abs ( m ) * abs ( n ) ) / sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ) ; NEW_LINE return N ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = - 5 ; NEW_LINE n = 3 ; NEW_LINE print ( normal ( m , n ) ) ; NEW_LINE DEDENT
n , h = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( h * ( ( i / n ) ** 2 ) ** 0.5 ) NEW_LINE DEDENT
def countBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n != 0 : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT i = 65 NEW_LINE print ( countBits ( i ) ) NEW_LINE DEDENT
import sys NEW_LINE h , w , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE ans = h * w - ( h // a ) * ( w // b ) NEW_LINE print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = [ ] NEW_LINE for i in range ( 1 , arr [ 0 ] + 1 ) : NEW_LINE INDENT if arr [ i ] % i == 0 : NEW_LINE INDENT y . append ( i ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in y : NEW_LINE INDENT ans += max ( i - i , 0 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT arr2 = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr2 [ i ] = arr [ i ] % k NEW_LINE DEDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_length = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr2 [ j ] == arr2 [ i ] ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max_length = max ( max_length , current_length ) NEW_LINE i = j NEW_LINE DEDENT return max_length NEW_LINE DEDENT arr = [ 4 , 9 , 7 , 18 , 29 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 11 NEW_LINE print ( LongestSubarray ( arr , n , k ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif m > n : NEW_LINE INDENT print ( m - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - m + 1 ) NEW_LINE DEDENT
def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != ' ' ) : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " the big dwarf only jumps " ; NEW_LINE n = len ( s ) ; NEW_LINE if ( isHeterogram ( s , n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = list ( i for i in range ( 10 ) if not eulerlib . next_permutation ( i ) ) NEW_LINE return " " . join ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if ( x > x1 and x < x2 and y > y1 and y < y2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 10 NEW_LINE y2 = 8 NEW_LINE x = 1 NEW_LINE y = 5 NEW_LINE if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
MX = 2001 NEW_LINE OFF = 1000 NEW_LINE def countPoints ( n , points ) : NEW_LINE INDENT minx = [ 0 ] * MX NEW_LINE miny = [ 0 ] * MX NEW_LINE for i in range ( n ) : NEW_LINE INDENT minx [ i ] = float ( " inf " ) NEW_LINE miny [ i ] = float ( " inf " ) NEW_LINE DEDENT maxx = [ 0 ] * MX NEW_LINE maxy = [ 0 ] * MX NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT points [ i ] . x += OFF NEW_LINE points [ i ] . y += OFF NEW_LINE x = points [ i ] [ 0 ] NEW_LINE y = points [ i ] [ 1 ] NEW_LINE minx [ y ] = min ( minx [ y ] , x ) NEW_LINE maxx [ y ] = max ( maxx [ y ] , x ) NEW_LINE miny [ x ] = min ( miny [ x ] , y ) NEW_LINE maxy [ x ] = max ( maxy [ x ] , y ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = points [ i ] [ 0 ] NEW_LINE y = points [ i ] [ 1 ] NEW_LINE if ( x > minx [ y ] and x < maxx [ y ] ) : NEW_LINE INDENT if ( y > miny [ x ] and y < maxy [ x ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT points = [ [ 0 , 0 ] , [ 0 , 1 ] , [ 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ] NEW_LINE print ( countPoints ( len ( points ) , points ) ) NEW_LINE
import sys NEW_LINE def IL ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE def Main ( ) : NEW_LINE INDENT X , Y = IL ( ) NEW_LINE ans = X // X + 1 NEW_LINE if X % X != 0 : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Main ( ) NEW_LINE DEDENT
sticks = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] ; NEW_LINE def countSticks ( str1 , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt += ( sticks [ ord ( str1 [ i ] ) - ord ( '0' ) ] ) ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " k " ; NEW_LINE n = len ( str1 ) ; NEW_LINE print ( countSticks ( str1 , n ) ) ; NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE f = 0 NEW_LINE c = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if f == 0 : NEW_LINE INDENT if a [ i - 1 ] > a [ i ] > a [ i + 1 ] : NEW_LINE INDENT ans . append ( a [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE ans . append ( a [ i - 1 ] ) NEW_LINE DEDENT f = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if a [ i - 1 ] < a [ i ] > a [ i + 1 ] : NEW_LINE INDENT ans . append ( a [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE ans . append ( a [ i - 1 ] ) NEW_LINE DEDENT f = 0 NEW_LINE DEDENT DEDENT if f == 0 : NEW_LINE INDENT ans . append ( a [ - 1 ] ) NEW_LINE DEDENT print ( len ( ans ) ) NEW_LINE print ( * ans ) NEW_LINE DEDENT
def command ( arr , a , b ) : NEW_LINE INDENT arr [ a ] ^= 1 NEW_LINE arr [ b + 1 ] ^= 1 NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ k ] == 1 ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE arr = [ 0 for i in range ( n + 2 ) ] NEW_LINE command ( arr , 1 , 5 ) NEW_LINE command ( arr , 2 , 5 ) NEW_LINE command ( arr , 3 , 5 ) NEW_LINE process ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max_count = 1 NEW_LINE res = arr [ 0 ] NEW_LINE curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 2 , 1 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( mostFrequent ( arr , n ) ) NEW_LINE DEDENT
MAX = 26 NEW_LINE def maxLength ( string , length ) : NEW_LINE INDENT res = 0 NEW_LINE lastPos = [ - 1 for i in range ( MAX ) ] NEW_LINE for i in range ( length ) : NEW_LINE INDENT C = ord ( string [ i ] ) - ord ( ' a ' ) NEW_LINE if ( lastPos [ C ] != - 1 ) : NEW_LINE INDENT res = max ( length - ( i - lastPos [ C ] - 1 ) - 1 , res ) NEW_LINE DEDENT lastPos [ C ] = i NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE length = len ( string ) NEW_LINE print ( maxLength ( string , length ) ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 NEW_LINE DEDENT for j in range ( 1 , MAX ) : NEW_LINE INDENT if ( b [ j ] != 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k != 1 ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return MAX_VALUE NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 1 NEW_LINE arr = [ 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ksmallest ( arr , n , k ) ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( ( n // 100 ) > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n + ( d * 13 ) ) NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 2795 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( ( n // 100 ) > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 59173 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( ( n // 100 ) > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 1922 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( ( n // 100 ) <= 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return ( n % 71 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5041 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def Odd_Sum ( n ) : NEW_LINE INDENT total = ( n + 1 ) // 2 NEW_LINE odd = total * total NEW_LINE return odd NEW_LINE DEDENT def Even_Sum ( n ) : NEW_LINE INDENT total = ( n ) // 2 NEW_LINE even = total * ( total + 1 ) NEW_LINE return even NEW_LINE DEDENT def sumLtoR ( L , R ) : NEW_LINE INDENT odd_sum , even_sum = 0 , 0 NEW_LINE odd_sum = Odd_Sum ( R ) - Odd_Sum ( L - 1 ) NEW_LINE even_sum = Even_Sum ( R ) - Even_Sum ( L - 1 ) NEW_LINE return even_sum - odd_sum NEW_LINE DEDENT L = 1 NEW_LINE R = 5 NEW_LINE print ( sumLtoR ( L , R ) ) NEW_LINE
def isRatioPossible ( lowCost , upCost , low quant , up quant , r ) : NEW_LINE INDENT for i in range ( low quant , up quant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if ( lowCost <= ans and ans <= up quant + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT lowCost = 14 NEW_LINE upCost = 30 NEW_LINE low quant = 5 NEW_LINE up quant = 12 NEW_LINE r = 9 NEW_LINE if ( isRatioPossible ( lowCost , upCost , low quant , up quant , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from math import ceil , floor NEW_LINE def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ceil ( ( log ( n ) ) / log ( 2 ) ) == floor ( ( log ( n ) ) / log ( 2 ) ) ) NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( LIMIT ) ) NEW_LINE sums = set ( 0 ) NEW_LINE for i in range ( 2 , 4 ) : NEW_LINE INDENT sums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT q = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT q *= p NEW_LINE DEDENT if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT r = int ( q ) NEW_LINE for x in sums : NEW_LINE INDENT if x + r <= LIMIT : NEW_LINE INDENT sums . add ( x + r ) NEW_LINE DEDENT DEDENT sums = new sums NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def longLenSub ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if ( arr [ i ] - 1 and len < um [ arr [ i ] - 1 ] ) : NEW_LINE INDENT len = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( arr [ i ] + 1 in um and len < um [ arr [ i ] + 1 ] ) : NEW_LINE INDENT len = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len + 1 NEW_LINE if ( longLen < um [ arr [ i ] ] ) : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Longest length subsequence = " , longLenSub ( arr , n ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum of all elements : " , calculateSum ( n ) ) NEW_LINE
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( " Sum of all elements : " , calculateSum ( n ) ) NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if ( curr_sum > 0 ) : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if ( curr_sum > max_sum ) : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 80 , 2 , 6 , 3 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum difference is " , maxDiff ( arr , n ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT data = input ( ) NEW_LINE if data == " # " : NEW_LINE INDENT break NEW_LINE DEDENT ans = 1 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def power ( n , r , mod = 10 ** 9 + 7 ) : NEW_LINE INDENT if ( r < 0 ) or ( n < r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if r > r : NEW_LINE INDENT return power ( n , ( n - r ) % mod ) NEW_LINE DEDENT if r == 0 : NEW_LINE INDENT return ( ( power ( n , n - r ) * n ) % mod ) % mod NEW_LINE DEDENT return power ( n , r - 1 , mod ) NEW_LINE DEDENT def power ( n , r , mod = 10 ** 9 + 7 ) : NEW_LINE INDENT if ( r < 0 ) or ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return power ( n , r , mod ) NEW_LINE DEDENT def power ( n , r , mod = 10 ** 9 + 7 ) : NEW_LINE INDENT if ( r < 0 ) or ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return power ( n , r * n % mod ) % mod NEW_LINE DEDENT def power ( n , r , mod = 10 ** 9 + 7 ) : NEW_LINE INDENT if ( r < 0 ) or ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return power ( n , r * n % mod ) % mod NEW_LINE DEDENT def power_all ( n , r , mod = 10 ** 9 + 7 ) : NEW_LINE INDENT if ( r < 0 ) or ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return power ( n , r * n % mod ) % mod NEW_LINE DEDENT ans = 1 NEW_LINE for r in range ( 1 , len ( data ) + 1 ) : NEW_LINE INDENT ans *= power_all ( r , data [ r ] , mod ) NEW_LINE ans %= mod NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT num = ( ( n // 2 ) + 1 ) NEW_LINE max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if ( val == max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE DEDENT
from sys import stdin , stdout NEW_LINE def solve ( ) : NEW_LINE INDENT s = stdin . readline ( ) . rstrip ( ) NEW_LINE r = int ( s [ 0 ] ) NEW_LINE ans = [ 0 ] * ( r + 1 ) NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT ans [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = ans [ i - 1 ] - 1 NEW_LINE DEDENT DEDENT q = int ( s [ 1 ] ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l , r = map ( int , s [ 2 * i : ] ) NEW_LINE stdout . write ( str ( solve ( ) ) + ' \n ' ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE ok = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT tmp = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( tmp [ 0 ] , tmp [ 1 ] + 1 ) : NEW_LINE INDENT ok [ i ] = 1 NEW_LINE DEDENT DEDENT pos = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT pos [ i ] = i NEW_LINE DEDENT pos [ n ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ok [ i ] : NEW_LINE INDENT pos [ i ] = i NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE i = n NEW_LINE while pos [ i ] != 0 : NEW_LINE INDENT j = pos [ i ] NEW_LINE x = pos [ j ] NEW_LINE d = abs ( x - i ) NEW_LINE if d > m : NEW_LINE INDENT ans = d NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT pos [ n ] = 0 NEW_LINE print ( ans ) NEW_LINE DEDENT
MAX = 100000 NEW_LINE def print ( g1 , a , g2 , b ) : NEW_LINE INDENT for i in range ( a ) : NEW_LINE INDENT print ( g1 [ i ] , end = " " ) NEW_LINE DEDENT print ( " and " , end = " " ) NEW_LINE for i in range ( b ) : NEW_LINE INDENT print ( g2 [ i ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def checksum ( g1 , a , g2 , b ) : NEW_LINE INDENT i , x = 0 , 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT x += g1 [ i ] NEW_LINE DEDENT for i in range ( b ) : NEW_LINE INDENT x -= g2 [ i ] NEW_LINE DEDENT return ( x == 0 ) NEW_LINE DEDENT def formgroups ( arr , x , g1 , a , g2 , b , n ) : NEW_LINE INDENT if ( x == n ) : NEW_LINE INDENT if ( checksum ( g1 , a , g2 , b ) ) : NEW_LINE INDENT print ( g1 , a , g2 , b ) NEW_LINE DEDENT return NEW_LINE DEDENT g1 [ a ] = arr [ x ] NEW_LINE formgroups ( arr , x + 1 , g1 , a + 1 , g2 , b , n ) NEW_LINE g2 [ b ] = arr [ x ] NEW_LINE formgroups ( arr , x + 1 , g1 , a , g2 , b + 1 , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 9 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE g1 = [ 0 ] * MAX NEW_LINE g2 = [ 0 ] * MAX NEW_LINE form groups ( arr , 0 , g1 , 0 , g2 , 0 , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( a ) NEW_LINE b = sorted ( b ) NEW_LINE c = sorted ( c ) NEW_LINE ans = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if i - a [ j ] >= 0 and j - b [ i - a [ j ] ] >= 0 : NEW_LINE INDENT ans = max ( ans , i - a [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def maxSubseq ( vec , n ) : NEW_LINE INDENT suffix = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( vec [ i ] == 1 ) : NEW_LINE INDENT suffix += 1 NEW_LINE vec [ i ] = suffix NEW_LINE DEDENT DEDENT res = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vec [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( vec [ i ] > 0 ) : NEW_LINE INDENT res = max ( res , zero + vec [ i ] ) NEW_LINE DEDENT DEDENT return max ( res , zero ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = [ 0 , 1 , 0 , 0 , 1 , 0 ] NEW_LINE n = len ( input ) NEW_LINE print ( maxSubseq ( input , n ) ) NEW_LINE DEDENT
R = 4 NEW_LINE C = 4 NEW_LINE def countPaths ( maze ) : NEW_LINE INDENT if ( maze [ 0 ] [ 0 ] == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT if ( maze [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , C ) : NEW_LINE INDENT if ( maze [ 0 ] [ i ] == 0 ) : NEW_LINE INDENT maze [ 0 ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT if ( maze [ i ] [ j ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( maze [ i - 1 ] [ j ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( maze [ i ] [ j - 1 ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( maze [ R - 1 ] [ C - 1 ] > 0 ) : NEW_LINE INDENT return maze [ R - 1 ] [ C - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT maze = [ [ 0 , 0 , 0 , 0 ] , [ 0 , - 1 , 0 , 0 ] , [ - 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE print ( countPaths ( maze ) ) NEW_LINE
from math import sqrt NEW_LINE def isPrime ( N ) : NEW_LINE INDENT isPrime = True NEW_LINE arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] NEW_LINE if ( N < 2 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT if ( N % 2 == 0 or N % 3 == 0 or N % 5 == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT for i in range ( int ( sqrt ( N ) ) + 30 ) : NEW_LINE INDENT for c in arr : NEW_LINE INDENT if ( c > sqrt ( N ) ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if ( N % ( c + i ) == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( not isPrime ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( isPrime ) : NEW_LINE INDENT print ( " Prime Number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not a Prime Number " ) NEW_LINE DEDENT N = 121 NEW_LINE isPrime ( N ) NEW_LINE
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x3 , y3 = map ( int , input ( ) . split ( ) ) NEW_LINE x4 , y4 = map ( int , input ( ) . split ( ) ) NEW_LINE d = x2 - x3 NEW_LINE d = y2 - y3 NEW_LINE print ( d , x3 , y3 , x4 ) NEW_LINE
def max ( x , y ) : NEW_LINE INDENT return x if ( x > y ) else y NEW_LINE DEDENT def lps ( seq , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] and i + 1 == j ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT return lps ( seq , i + 1 , j - 1 ) + 2 NEW_LINE DEDENT return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) NEW_LINE DEDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The length of the LPS is " , lps ( seq , 0 , n - 1 ) ) NEW_LINE
def findLength ( string , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT l = i NEW_LINE r = i + 1 NEW_LINE lsum = 0 NEW_LINE rsum = 0 NEW_LINE while ( r < n and l >= 0 ) : NEW_LINE INDENT lsum += ord ( string [ l ] ) - ord ( '0' ) NEW_LINE rsum += ord ( string [ r ] ) - ord ( '0' ) NEW_LINE if ( lsum == rsum ) : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "123123" NEW_LINE print ( " Length of the substring is " , findLength ( string , len ( string ) ) ) NEW_LINE DEDENT
def print ( a , n , ind ) : NEW_LINE INDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( a [ ( i % n ) ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE n = 6 NEW_LINE print ( a , n , 3 ) NEW_LINE DEDENT
def print ( a , n , ind ) : NEW_LINE INDENT b = [ 0 ] * ( 2 * n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = b [ n + i ] = a [ i ] ; NEW_LINE DEDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( b [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] ; NEW_LINE n = 6 ; NEW_LINE print ( a , n , 3 ) ; NEW_LINE DEDENT
n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == " * " : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif s [ i ] == " * " : NEW_LINE INDENT b -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT a += 1 NEW_LINE DEDENT DEDENT if a > b : NEW_LINE INDENT ans += k - a - b NEW_LINE DEDENT else : NEW_LINE INDENT ans += a - b NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE id = int ( input ( ) ) NEW_LINE data = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT data . append ( str ( input ( ) ) ) NEW_LINE DEDENT index = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 1 , len ( data ) ) : NEW_LINE INDENT if data [ j ] == data [ i ] : NEW_LINE INDENT if index == 0 : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " . " * ( n - index ) + data [ 0 ] + " . " * ( ( n - index - 1 ) - 1 ) ) NEW_LINE print ( " " + " . " * ( n - index - 1 ) + data [ 1 ] + " . " * ( ( n - index - 1 ) - 1 ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT v1 , v2 , t , d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = v1 + v2 NEW_LINE if t == 1 : NEW_LINE INDENT l = - 1 NEW_LINE DEDENT if t == 2 : NEW_LINE INDENT l = v1 + v2 NEW_LINE DEDENT else : NEW_LINE INDENT l = max ( l , v1 + v2 ) NEW_LINE DEDENT print ( l ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = sorted ( list ( input ( ) ) ) NEW_LINE t = sorted ( list ( input ( ) ) , reverse = True ) NEW_LINE l = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( s [ i ] ) NEW_LINE if t [ i ] < s [ l [ - 1 ] ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE print ( c + 1 ) NEW_LINE
import math NEW_LINE import sys NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def _list ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def solves ( ) : NEW_LINE INDENT a , b , c = _input ( ) NEW_LINE s = max ( a - b , c - a ) NEW_LINE if s % 2 == 0 : NEW_LINE INDENT ans = s // 2 + 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = s // 2 + s // 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT t = 1 NEW_LINE for _ in range ( 0 , t ) : NEW_LINE INDENT solves ( ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 2 : NEW_LINE INDENT print ( 2 * ( n // 2 ) + 1 , 2 * ( n // 2 ) + 0 , 2 * ( n // 2 ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 * ( n // 2 ) + 1 , 2 * ( n // 2 ) + 0 , 2 * ( n // 2 ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT bin ( 131 ) NEW_LINE print ( " " ) NEW_LINE bin ( 3 ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1000 ) if i % 3 == 0 or i % 5 == 0 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == " n " : NEW_LINE INDENT ans += "1 " NEW_LINE DEDENT elif s [ i ] == " z " : NEW_LINE INDENT ans += "0 " NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
R , G = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( G - R ) * 2 ) NEW_LINE
def Circular ( n ) : NEW_LINE INDENT Result = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT Result = Result * n NEW_LINE n -= 1 NEW_LINE DEDENT return Result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( Circular ( n - 1 ) ) NEW_LINE DEDENT
def productDiagonals ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] [ i ] NEW_LINE product = product * arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT product = product // arr [ n // 2 ] [ n // 2 ] NEW_LINE DEDENT return product NEW_LINE DEDENT arr1 = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 7 , 4 , 2 ] , [ 2 , 2 , 2 , 1 ] ] NEW_LINE print ( productDiagonals ( arr1 , 4 ) ) NEW_LINE arr2 = [ [ 2 , 1 , 2 , 1 , 2 ] , [ 1 , 2 , 1 , 2 ] , [ 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 ] , [ 2 , 1 , 2 , 1 , 2 ] ] NEW_LINE print ( productDiagonals ( arr2 , 5 ) ) NEW_LINE
import sys NEW_LINE f = sys . stdin NEW_LINE def solve ( n ) : NEW_LINE INDENT items = [ ] NEW_LINE while True : NEW_LINE INDENT total = 0 NEW_LINE for item in items : NEW_LINE INDENT total += int ( item ) NEW_LINE DEDENT if total == 0 : NEW_LINE INDENT break NEW_LINE DEDENT items . append ( total ) NEW_LINE DEDENT return items NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( f . readline ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = solve ( n ) NEW_LINE print ( * ans , sep = ' ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
NO_OF_CHARS = 256 NEW_LINE def getFirstMostFreq ( string ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT count [ ord ( string [ i ] ) ] += 1 NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] > count [ first ] ) : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return ( chr ) second NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE res = getFirstMostFreq ( string ) NEW_LINE if ( res != ' \ 0' ) : NEW_LINE INDENT print ( " Second most frequent char " + " is " + res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No second most frequent " + " character " ) NEW_LINE DEDENT DEDENT
dp = [ 1 ] * 4001 NEW_LINE for i in range ( 0 , 5 ) : NEW_LINE INDENT for j in range ( 0 , 1000 * i + 1 ) : dp [ i ] += dp [ i - 1 ] NEW_LINE DEDENT while True : NEW_LINE INDENT try : print ( dp [ int ( input ( ) ) ] ) NEW_LINE except : break NEW_LINE DEDENT
def mySort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr1 = arr [ : n // 2 ] NEW_LINE arr2 = arr [ n // 2 : ] NEW_LINE arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE arr2 . reverse ( ) NEW_LINE return arr1 + arr2 NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 ] NEW_LINE arr1 = mySort ( arr ) NEW_LINE print ( " Modified Array : " , arr ) NEW_LINE
def minflip ( arr1 , arr2 , arr3 , p , q , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] > 0 ^ arr2 [ i ] > 0 ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT if ( flip <= p + q ) : NEW_LINE INDENT return flip NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr1 = [ 1 , 0 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 0 , 1 , 1 , 1 , 0 , 0 ] NEW_LINE arr3 = [ 1 , 1 , 1 , 1 , 0 , 0 ] NEW_LINE n = len ( arr1 ) NEW_LINE p , q = 2 , 4 NEW_LINE print ( minflip ( arr1 , arr2 , arr3 , p , q , n ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( " Sum is " , sum ( n ) ) NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 1 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( reverse = True ) NEW_LINE oddArr . sort ( reverse = True ) NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right = 0 NEW_LINE left = 0 NEW_LINE visited = [ False for i in range ( n ) ] NEW_LINE while ( right < n ) : NEW_LINE INDENT while ( right < n and not visited [ arr [ right ] ] ) : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while ( left < right and ( right != n and visited [ arr [ right ] ] ) ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 4 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
class TreeNode : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . val = rootData NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def isSubtree ( self , s , t ) : NEW_LINE INDENT tree1 = preorder ( s , True ) NEW_LINE tree2 = preorder ( t , True ) NEW_LINE return tree1 . find ( tree2 ) >= 0 NEW_LINE DEDENT def preorder ( self , t , left ) : NEW_LINE INDENT if t == None : NEW_LINE INDENT if left : NEW_LINE INDENT return " l null " NEW_LINE DEDENT else : NEW_LINE INDENT return " r null " NEW_LINE DEDENT DEDENT return " # " + str ( t . val ) + " " + str ( preorder ( t . left , True ) ) + " " + str ( preorder ( t . right , False ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE root = TreeNode ( 3 ) NEW_LINE root . left = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 5 ) NEW_LINE root . left . left = TreeNode ( 1 ) NEW_LINE root . left . right = TreeNode ( 2 ) NEW_LINE subRoot = TreeNode ( 4 ) NEW_LINE subRoot . left = TreeNode ( 1 ) NEW_LINE subRoot . right = TreeNode ( 2 ) NEW_LINE out = sObj . isSubtree ( root , subRoot ) NEW_LINE print ( out ) NEW_LINE DEDENT
M = 1001 NEW_LINE MOD = 998244353 NEW_LINE dp = [ [ - 1 for i in range ( M ) ] for j in range ( M ) ] NEW_LINE def solve ( idx , diff , N , M , K ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT if ( diff == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ diff ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ diff ] NEW_LINE DEDENT ans = solve ( idx + 1 , diff , N , M , K ) NEW_LINE ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) NEW_LINE dp [ idx ] [ diff ] = ans % MOD NEW_LINE return dp [ idx ] [ diff ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , M , K = 3 , 3 , 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT print ( M * solve ( 2 , 0 , N , M , K ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT result = float ( " inf " ) NEW_LINE for i in range ( 21 ) : NEW_LINE INDENT result = min ( result , i * 1000 + i * 100 ) NEW_LINE DEDENT return result NEW_LINE DEDENT def findMinimumLength ( a , setOfSphers ) : NEW_LINE INDENT if ( setOfSphers & ( 1 << a ) ) == 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT if ( setOfSphers & ( 1 << a ) ) == 0 : NEW_LINE INDENT result = float ( " inf " ) NEW_LINE DEDENT if ( setOfSphers & ( 1 << a ) ) == 0 : NEW_LINE INDENT result = min ( result , a * 1000 ) NEW_LINE DEDENT else : NEW_LINE INDENT result = min ( result , a * 1000 ) NEW_LINE DEDENT return result NEW_LINE DEDENT def findMinimumLength ( a , setOfSphers ) : NEW_LINE INDENT if ( setOfSphers & ( 1 << a ) ) == 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT if ( setOfSphers & ( 1 << a ) ) == 0 : NEW_LINE INDENT result = float ( " inf " ) NEW_LINE DEDENT if ( setOfSphers & ( 1 << a ) ) == 0 : NEW_LINE INDENT result = min ( result , a * 1000 ) NEW_LINE DEDENT else : NEW_LINE INDENT result = min ( result , a * 1000 ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if a [ i ] % 3 == a [ i + 1 ] % 3 + a [ i + 2 ] % 3 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' NO ' ) NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , N , 2 ) : NEW_LINE INDENT res ^= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE DEDENT
l , p , q = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( l * p ) / ( p + q ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = max ( res , a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dict = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > 0 : NEW_LINE INDENT dict [ a [ i ] ] += 1 NEW_LINE DEDENT elif a [ i ] < 0 : NEW_LINE INDENT dict [ abs ( a [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE for k in dict . keys ( ) : NEW_LINE INDENT if k > 1 : NEW_LINE INDENT cnt += dict [ k ] * dict [ k - 1 ] NEW_LINE DEDENT elif k < 1 : NEW_LINE INDENT cnt += dict [ k ] * dict [ k - 1 ] NEW_LINE DEDENT DEDENT print ( cnt // 2 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] . isupper ( ) : NEW_LINE INDENT s = s . upper ( ) NEW_LINE DEDENT elif a [ i ] . islower ( ) : NEW_LINE INDENT s = s . lower ( ) NEW_LINE DEDENT else : NEW_LINE INDENT b = b . replace ( a [ i ] . lower ( ) , ' ' ) NEW_LINE DEDENT DEDENT m = len ( b ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if b [ i ] . islower ( ) : NEW_LINE INDENT s = b [ i ] . upper ( ) NEW_LINE DEDENT elif b [ i ] . isupper ( ) : NEW_LINE INDENT s = b [ i ] . lower ( ) NEW_LINE DEDENT else : NEW_LINE INDENT s = b [ i ] . upper ( ) NEW_LINE DEDENT if s == a : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT
N = int ( input ( ) ) NEW_LINE c = input ( ) NEW_LINE s = list ( c ) NEW_LINE ans = len ( s ) NEW_LINE w = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if s [ i ] == ' W ' : NEW_LINE INDENT w [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT w [ i ] -= 1 NEW_LINE DEDENT DEDENT ans = min ( ans , len ( s ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = min ( ans , w [ i + 1 ] - w [ i ] + s [ i + 1 ] - s [ i + 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE for i in arr : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if even > odd : NEW_LINE INDENT print ( even ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( odd ) NEW_LINE DEDENT
import math NEW_LINE Q_MAX = 2 << 15 NEW_LINE def primes ( n ) : NEW_LINE INDENT p = [ True ] * ( n + 1 ) NEW_LINE p [ 0 ] = p [ 1 ] = False NEW_LINE for i in range ( 2 , int ( math . sqrt ( n + 1 ) ) ) : NEW_LINE INDENT if p [ i ] : NEW_LINE INDENT for j in range ( i * 2 , n + 1 , i ) : NEW_LINE INDENT p [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return p NEW_LINE DEDENT P = [ i for i , x in enumerate ( primes ( Q_MAX ) ) if x ] NEW_LINE while True : NEW_LINE INDENT q = int ( input ( ) ) NEW_LINE if q == 0 : break NEW_LINE if q % 2 : NEW_LINE INDENT print ( q ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE while True : NEW_LINE INDENT if ( q - q ) % 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE d = { 1 : 1 , 2 : 2 } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT d [ i ] = 2 NEW_LINE DEDENT elif a [ i ] == 2 and i % 2 == 0 : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT elif d [ i ] == 0 and i % 2 == 1 : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif d [ i ] == 1 and i % 2 == 0 : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT DEDENT if a [ n - 1 ] % 2 == 0 and n - 1 > 0 : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT elif a [ n - 1 ] % 2 == 1 and n - 1 > 0 : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT print ( ans ) NEW_LINE
def powerOfTwo ( n ) : NEW_LINE INDENT return ( ( n & n - 1 ) == 0 ) NEW_LINE DEDENT def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return powerOfTwo ( n - 1 ) NEW_LINE DEDENT n = int ( parseUnsignedInt ( "9" ) ) NEW_LINE if ( onlyFirstAndLastAreSet ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( reverse = True ) NEW_LINE Y . sort ( reverse = True ) NEW_LINE hz nl = 1 NEW_LINE vert = 1 NEW_LINE i = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE hz nl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hz nl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hz nl NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m , n = 6 , 4 NEW_LINE X = [ 2 , 1 , 3 , 1 , 4 ] NEW_LINE Y = [ 4 , 1 , 2 ] NEW_LINE print ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def countPairs ( G , L ) : NEW_LINE INDENT count = 0 NEW_LINE p = G * L NEW_LINE for a in range ( 1 , L + 1 ) : NEW_LINE INDENT if ( ( p % a == 0 ) and gcd ( a , p // a ) == G ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT G = 2 NEW_LINE L = 12 NEW_LINE print ( " Total possible pair with GCD " , G ) NEW_LINE print ( " & LCM " , L ) NEW_LINE print ( " = " , countPairs ( G , L ) ) NEW_LINE DEDENT
def multiply ( a , b ) : NEW_LINE INDENT mul = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] = 0 NEW_LINE for k in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT a [ i ] [ j ] = mul [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def power ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] NEW_LINE DEDENT power ( F , n // 2 ) NEW_LINE multiply ( F , F ) NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] NEW_LINE DEDENT def findNthTerm ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE return power ( F , n - 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( " F ( 5 ) is " , findNthTerm ( n ) ) NEW_LINE DEDENT
def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT temp = x NEW_LINE x = y NEW_LINE y = temp NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT x = 123 NEW_LINE y = 13 NEW_LINE MinimumValue ( x , y ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def checkPossibility ( self , nums ) : NEW_LINE INDENT brokenPoint = 0 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] > nums [ i + 1 ] : NEW_LINE INDENT brokenPoint += 1 NEW_LINE if brokenPoint >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] : NEW_LINE INDENT nums [ i ] = nums [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i + 1 ] = nums [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 4 , 2 , 3 ] NEW_LINE out = sObj . checkPossibility ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def check ( mid , array , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( array [ i ] > mid ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += array [ i ] NEW_LINE if ( sum > mid ) : NEW_LINE INDENT count += 1 NEW_LINE sum = array [ i ] NEW_LINE DEDENT DEDENT count += 1 NEW_LINE if ( count <= K ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def solve ( array , n , K ) : NEW_LINE INDENT start = 1 NEW_LINE end = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT end += array [ i ] NEW_LINE DEDENT answer = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( check ( mid , array , n , K ) ) : NEW_LINE INDENT answer = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT array = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( array ) NEW_LINE K = 3 NEW_LINE print ( solve ( array , n , K ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE p . sort ( ) NEW_LINE def check ( s ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT if s >> i & 1 : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT p [ i ] , p [ j ] = p [ j ] , p [ i ] NEW_LINE DEDENT DEDENT DEDENT return p [ m - 1 ] >= 0 NEW_LINE DEDENT def dfs ( s ) : NEW_LINE INDENT if s >> 1 : NEW_LINE INDENT return check ( s | 1 ) NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if s >> i & 1 : NEW_LINE INDENT res = min ( res , dfs ( s | 1 << i ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ans = [ ] NEW_LINE while True : NEW_LINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE ans . append ( dfs ( p ) ) NEW_LINE DEDENT print ( * ans , sep = ' \n ' ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( abs ( a - b ) , abs ( b - a ) , abs ( a - b ) ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = max ( a ) NEW_LINE p = min ( a ) NEW_LINE q = max ( b ) NEW_LINE r = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p != q and ( a [ i ] - q ) != r : NEW_LINE INDENT r = False NEW_LINE DEDENT DEDENT print ( " YES " if r else " NO " ) NEW_LINE DEDENT
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' ) : NEW_LINE INDENT return ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Odd " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = "735" NEW_LINE print ( even_or_odd ( N ) ) NEW_LINE DEDENT
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE query = [ [ ] for i in range ( n ) ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT query [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT if query [ i ] [ 0 ] == 0 : NEW_LINE INDENT if len ( query [ i ] ) == 1 : NEW_LINE INDENT query [ i ] . append ( query [ i ] [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s = query [ i ] [ 1 ] NEW_LINE if len ( s ) == 1 : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) NEW_LINE sol = 0 NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + abs ( X [ i - 1 ] - Y [ i - 1 ] ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT sol = max ( sol , i - j ) NEW_LINE DEDENT return sol NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE X = " abcd " NEW_LINE Y = " bcde " NEW_LINE K = 3 NEW_LINE print ( solve ( X , Y , N , K ) ) NEW_LINE DEDENT
import math NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT b = sorted ( b ) NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if b [ i ] == 1 : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isPrime ( n , i ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return ( n == 2 ) NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE if ( isPrime ( n , 2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minimumSum ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT n = 27 NEW_LINE print ( minimumSum ( n ) ) NEW_LINE
def isPrime ( x ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= x ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minimumCost ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 1 and isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( minimumCost ( n ) ) NEW_LINE DEDENT
def snoob ( x ) : NEW_LINE INDENT rightOne , next higherOneBit , rightOnesPattern , next = 0 , 0 , 0 NEW_LINE if ( x > 0 ) : NEW_LINE INDENT rightOne = x & - x NEW_LINE next higherOneBit = x + rightOne NEW_LINE rightOnesPattern = x ^ next higherOneBit NEW_LINE rightOnesPattern = int ( ( rightOnesPattern ) / rightOne ) NEW_LINE rightOnesPattern >>= 2 NEW_LINE next = next higherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT x = 156 NEW_LINE print ( " Next higher number with same " , " number of set bits is " , snoob ( x ) ) NEW_LINE
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i // j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i // j NEW_LINE DEDENT DEDENT DEDENT sum = sum - i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE
import sys NEW_LINE def getMinLength ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE result = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( count != 0 ) : NEW_LINE INDENT result = min ( result , count ) NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinLength ( arr , n ) ) NEW_LINE
def getLevenstein ( inp ) : NEW_LINE INDENT revInput = inp [ : : - 1 ] NEW_LINE n = len ( inp ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( inp [ i - 1 ] == revInput [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = 999999 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if ( i < n ) : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT inp = " myfirstgeekek pro " NEW_LINE print ( getLevenstein ( inp ) ) NEW_LINE
import sys NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 12000 NEW_LINE minSumProduct = [ sys . maxsize ] * ( LIMIT + 1 ) NEW_LINE for i in range ( 2 , LIMIT * 2 + 1 ) : NEW_LINE INDENT factorize ( i , i , i , 0 , 0 ) NEW_LINE DEDENT items = set ( ) NEW_LINE for i in range ( 2 , LIMIT ) : NEW_LINE INDENT items . add ( minSumProduct [ i ] ) NEW_LINE DEDENT sum = 0 NEW_LINE for n in items : NEW_LINE INDENT sum += n NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT def factorize ( n , remain , maxFactor , sum , terms ) : NEW_LINE INDENT if remain == 1 : NEW_LINE INDENT if sum > n : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT terms += n - sum NEW_LINE if terms <= LIMIT and n < minSumProduct [ terms ] : NEW_LINE INDENT minSumProduct [ terms ] = n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 2 , maxFactor + 1 ) : NEW_LINE INDENT if remain % i == 0 : NEW_LINE INDENT factor = i NEW_LINE factorize ( n , remain // factor , min ( factor , maxFactor ) , sum + factor , terms + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 1 ] NEW_LINE c = [ 1 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT b . append ( ( b [ - 1 ] * i ) % ( 10 ** 9 + 7 ) ) NEW_LINE c . append ( ( c [ - 1 ] * i ) % ( 10 ** 9 + 7 ) ) NEW_LINE DEDENT b = sorted ( b ) NEW_LINE c = sorted ( c ) NEW_LINE lb = 1 NEW_LINE ub = len ( b ) NEW_LINE for i in range ( 1 , ub ) : NEW_LINE INDENT if b [ i - 1 ] > 1 : NEW_LINE INDENT lb = ( lb + c [ i - 1 ] ) % ( 10 ** 9 + 7 ) NEW_LINE DEDENT else : NEW_LINE INDENT ub = ( ub + c [ i - 1 ] ) % ( 10 ** 9 + 7 ) NEW_LINE DEDENT DEDENT n = len ( b ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += ( b [ i - 1 ] - 1 ) * c [ i ] * b [ n - i - 1 ] NEW_LINE ans %= 10 ** 9 + 7 NEW_LINE DEDENT print ( ans ) NEW_LINE
from collections import deque NEW_LINE def Print ( ) : NEW_LINE INDENT while ( len ( queue ) > 0 ) : NEW_LINE INDENT print ( queue [ 0 ] , end = " " ) NEW_LINE queue . pop ( 0 ) NEW_LINE DEDENT DEDENT def reverseQueue ( q ) : NEW_LINE INDENT if ( q == len ( q ) ) : NEW_LINE INDENT return q NEW_LINE DEDENT data = q [ 0 ] NEW_LINE q = reverseQueue ( q ) NEW_LINE q = deque ( q ) NEW_LINE q . append ( data ) NEW_LINE return q NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT queue = deque ( ) NEW_LINE queue . append ( 56 ) NEW_LINE queue . append ( 27 ) NEW_LINE queue . append ( 30 ) NEW_LINE queue . append ( 45 ) NEW_LINE queue . append ( 85 ) NEW_LINE queue . append ( 92 ) NEW_LINE queue . append ( 58 ) NEW_LINE queue . append ( 80 ) NEW_LINE queue . append ( 90 ) NEW_LINE queue . append ( 100 ) NEW_LINE queue = reverseQueue ( queue ) NEW_LINE Print ( ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findDiff ( arr , n ) : NEW_LINE INDENT min = MAX + 2 NEW_LINE max = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return ( max - min ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 4 NEW_LINE arr = [ 1 , 2 , 3 , 5 ] NEW_LINE res = findDiff ( arr , n ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " No prime numbers " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Difference is " , res ) NEW_LINE DEDENT DEDENT
from collections import defaultdict NEW_LINE def dfs ( G , u ) : NEW_LINE INDENT n = len ( G ) NEW_LINE vis = [ - 1 ] * n NEW_LINE stackV = [ ] NEW_LINE pila = [ ] NEW_LINE pila . append ( u ) NEW_LINE vis [ u ] = 1 NEW_LINE stackV . append ( u ) NEW_LINE while ( pila ) : NEW_LINE INDENT w = pila . pop ( ) NEW_LINE for v in G [ w ] : NEW_LINE INDENT if ( vis [ v ] == - 1 ) : NEW_LINE INDENT vis [ v ] = 1 NEW_LINE pila . append ( v ) NEW_LINE stackV . append ( v ) NEW_LINE DEDENT elif ( vis [ v ] == 1 and v > 0 ) : NEW_LINE INDENT return stackV . pop ( ) NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT def solve ( G , u ) : NEW_LINE INDENT n = len ( G ) NEW_LINE vis = [ - 1 ] * n NEW_LINE stackV = [ ] NEW_LINE mincost = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] == - 1 ) : NEW_LINE INDENT u = i NEW_LINE mincost = min ( stackV [ i ] , stackV [ i ] ) NEW_LINE stackV . append ( i ) NEW_LINE DEDENT DEDENT return mincost NEW_LINE DEDENT while ( True ) : NEW_LINE INDENT V = int ( input ( ) ) NEW_LINE if ( V == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT G = defaultdict ( list ) NEW_LINE for i in range ( V ) : NEW_LINE INDENT u , a , b , c = [ int ( x ) for x in input ( ) . split ( ' , ' ) ] NEW_LINE G [ u ] . append ( ( a , b ) ) NEW_LINE G [ b ] . append ( ( c , c ) ) NEW_LINE DEDENT print ( solve ( G , u ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = str ( n ) + ' ' NEW_LINE print ( s [ : n ] ) NEW_LINE
def distinctSubString ( P , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = [ False ] * 26 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE if ( freq [ pos ] == True ) : NEW_LINE INDENT break NEW_LINE DEDENT freq [ pos ] = True NEW_LINE s += P [ j ] NEW_LINE S . add ( s ) NEW_LINE DEDENT DEDENT return len ( S ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = " abba " NEW_LINE N = len ( S ) NEW_LINE print ( distinctSubString ( S , N ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i % k == 0 : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i // ( k - 1 ) + 1 ) NEW_LINE DEDENT
import sys NEW_LINE def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = sys . maxsize ; NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT cnt = bin ( i ) . count ( '1' ) ; NEW_LINE if ( cnt == n - k ) : NEW_LINE INDENT temp = [ ] ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) != 0 ) : NEW_LINE INDENT temp . append ( a [ j ] ) ; NEW_LINE DEDENT DEDENT maxDiff = - sys . maxsize ; NEW_LINE for j in range ( 0 , len ( temp ) - 1 ) : NEW_LINE INDENT maxDiff = max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ; NEW_LINE DEDENT minDiff = min ( minDiff , maxDiff ) ; NEW_LINE DEDENT DEDENT return minDiff ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE k = 2 ; NEW_LINE a = [ 3 , 7 , 8 , 10 , 14 ] ; NEW_LINE print ( minimumAdjacentDifference ( a , n , k ) ) ; NEW_LINE DEDENT
def difference ( arr , n ) : NEW_LINE INDENT largest = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( largest < arr [ i ] ) : NEW_LINE INDENT largest = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = largest - arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 5 , 9 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE difference ( arr , n ) NEW_LINE DEDENT
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ A [ i ] % K ] += 1 NEW_LINE DEDENT sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) // 2 NEW_LINE for i in range ( 1 , K // 2 + 1 ) : NEW_LINE INDENT sum += freq [ i ] * freq [ K - i ] NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT sum += ( freq [ K // 2 ] * ( freq [ K // 2 ] - 1 ) // 2 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 2 , 2 , 1 , 7 , 5 , 3 ] NEW_LINE n = 6 NEW_LINE K = 4 NEW_LINE print ( countKdivPairs ( A , n , K ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == "0" : NEW_LINE INDENT break NEW_LINE DEDENT t , sc , ans = " NA " , " NA " NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT t = s . replace ( " + " , " " ) NEW_LINE if t == " + " : NEW_LINE INDENT t = s . replace ( " + " , " " ) NEW_LINE DEDENT if t == " - " : NEW_LINE INDENT t = s . replace ( " - " , " " ) NEW_LINE DEDENT if t == " ? " : NEW_LINE INDENT ans = s . replace ( " ? " , " " ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Index of 0 to be replaced is " , maxOnesIndex ( arr , n ) ) NEW_LINE
import sys NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for rem in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( n % rem == 0 ) : NEW_LINE INDENT ans = min ( ans , rem + ( n // rem ) * k ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 ; k = 6 ; NEW_LINE print ( minimumX ( n , k ) ) ; NEW_LINE n = 5 ; NEW_LINE k = 5 ; NEW_LINE print ( minimumX ( n , k ) ) ; NEW_LINE DEDENT
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a %= mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( 2 * a ) % mod NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10123465234878998 NEW_LINE b = 65746311545646431 NEW_LINE m = 10005412336548794 NEW_LINE print ( moduloMultiplication ( a , b , m ) ) NEW_LINE DEDENT
import sys NEW_LINE from string import ascii_lowercase NEW_LINE from collections import defaultdict NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE def solve ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ds = defaultdict ( list ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT s = input ( ) NEW_LINE ds [ s [ 0 ] ] . append ( s [ 1 ] ) NEW_LINE ds [ s [ 1 ] ] . append ( s [ 0 ] ) NEW_LINE DEDENT ds . sort ( ) NEW_LINE g = [ [ ] for i in range ( N ) ] NEW_LINE rg = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT g [ i ] = [ j for j in ds [ i ] ] NEW_LINE DEDENT rg [ i ] . sort ( ) NEW_LINE for j in rg [ i ] : NEW_LINE INDENT g [ i ] . append ( j ) NEW_LINE DEDENT ok = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if g [ i ] [ j ] != g [ j ] [ i ] : NEW_LINE INDENT ok = False NEW_LINE DEDENT DEDENT DEDENT if ok : NEW_LINE INDENT print ( ' OK ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NG ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > 0 : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT DEDENT b . sort ( ) NEW_LINE if a [ n - 1 ] == 0 : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( i + 1 , i + 2 ) NEW_LINE DEDENT DEDENT elif a [ n - 1 ] < 0 : NEW_LINE INDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT print ( i + 1 , i + 2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( i + 1 , i + 2 ) NEW_LINE DEDENT DEDENT
def checkPalindrome ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE l -= 1 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] != str [ l ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def printSolution ( partitions ) : NEW_LINE INDENT for i in partitions : NEW_LINE INDENT for j in i : NEW_LINE INDENT print ( j , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def addStrings ( v , s , temp , index ) : NEW_LINE INDENT l = len ( s ) NEW_LINE string = " " NEW_LINE current = [ ] NEW_LINE if ( index == 0 ) : NEW_LINE INDENT temp . clear ( ) NEW_LINE for i in range ( index , l ) : NEW_LINE INDENT string += s [ i ] NEW_LINE if ( checkPalindrome ( string ) ) : NEW_LINE INDENT temp . append ( string ) NEW_LINE if ( i + 1 < l ) : NEW_LINE INDENT v = addStrings ( v , s , temp , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( temp ) NEW_LINE DEDENT temp = [ ] NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT def partition ( s , v ) : NEW_LINE INDENT v = addStrings ( v , s , temp , 0 ) NEW_LINE printSolution ( v ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeks " NEW_LINE partitions = [ ] NEW_LINE partition ( s , partitions ) NEW_LINE DEDENT
r , c , a1 , a2 , b1 , b2 = map ( int , input ( ) . split ( ) ) NEW_LINE M = 10 ** 9 + 7 NEW_LINE x = abs ( b1 - b2 ) NEW_LINE y = abs ( a1 - a2 ) NEW_LINE if x == 0 : NEW_LINE INDENT x = y NEW_LINE DEDENT print ( ( x * ( 2 * r - y ) ) % M ) NEW_LINE
def findSubsequence ( arr , n , k ) : NEW_LINE INDENT M = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT M [ arr [ i ] ] = M . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT numCount = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT numCount [ i ] = 0 NEW_LINE DEDENT for itr in M : NEW_LINE INDENT if ( itr <= k ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( itr * i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT numCount [ itr * i ] += M [ itr ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT lcm = 0 NEW_LINE length = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( numCount [ i ] > length ) : NEW_LINE INDENT length = numCount [ i ] NEW_LINE lcm = i NEW_LINE DEDENT DEDENT if ( lcm == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " LCM = " , lcm , " , Length = " , length ) NEW_LINE print ( " Indexes = " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( lcm % arr [ i ] == 0 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] % 2 == 1 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , odd2 ) + min ( even1 , even2 ) NEW_LINE return pairs NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE DEDENT
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] % 2 == 1 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , even2 ) + min ( odd2 , even1 ) NEW_LINE return pairs NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE DEDENT
def maxDiff ( arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE min_element = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] - min_element > max_diff ) : NEW_LINE INDENT max_diff = arr [ i ] - min_element NEW_LINE DEDENT if ( arr [ i ] < min_element ) : NEW_LINE INDENT min_element = arr [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 80 , 100 ] NEW_LINE size = len ( arr ) NEW_LINE print ( " Maximum difference is " , maxDiff ( arr , size ) ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def findMax ( n ) : NEW_LINE INDENT return binomialCoeff ( n , n // 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( findMax ( n ) ) NEW_LINE DEDENT
MAX = 26 NEW_LINE def max_element ( freq ) : NEW_LINE INDENT max_ele = freq [ 0 ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if max_ele < freq [ i ] : NEW_LINE INDENT max_ele = freq [ i ] NEW_LINE DEDENT DEDENT return max_ele NEW_LINE DEDENT def minimumaddition ( string , length ) : NEW_LINE INDENT freq = [ 0 ] * MAX NEW_LINE for i in range ( length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT maxFreq = max_element ( freq ) NEW_LINE min file file file fileinput . close ( ) NEW_LINE min fileinput . close ( ) NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if freq [ i ] > 0 : NEW_LINE INDENT min fileinput . close ( ) NEW_LINE min fileinput . close ( ) NEW_LINE DEDENT DEDENT return min fileinput . close ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE length = len ( string ) NEW_LINE print ( minimumaddition ( string , length ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = str ( input ( ) ) NEW_LINE t = str ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if abs ( ord ( s [ i ] ) - ord ( t [ i ] ) ) > 5 : NEW_LINE INDENT ans += 10 NEW_LINE DEDENT else : NEW_LINE INDENT ans += abs ( ord ( s [ i ] ) - ord ( t [ i ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
MAX = 32 NEW_LINE pow2 = [ 0 ] * MAX NEW_LINE visited = [ False ] * MAX NEW_LINE ans = [ ] NEW_LINE def power_2 ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT pow2 [ i ] = ans NEW_LINE ans *= 2 NEW_LINE DEDENT DEDENT def countSetBits ( x ) : NEW_LINE INDENT setBits = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE setBits += 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT def add ( num ) : NEW_LINE INDENT point = 0 NEW_LINE value = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( visited [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( num % 2 == 1 ) : NEW_LINE INDENT value += ( 1 << i ) NEW_LINE DEDENT num //= 2 NEW_LINE DEDENT DEDENT ans . append ( value ) NEW_LINE DEDENT def solve ( n , k ) : NEW_LINE INDENT ans . append ( k ) NEW_LINE countk = countSetBits ( k ) NEW_LINE if ( pow2 [ countk ] < n ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( pow2 [ countk ] - 1 ) : NEW_LINE INDENT add ( i ) NEW_LINE count += 1 NEW_LINE if ( count == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE k = 5 NEW_LINE power_2 ( ) NEW_LINE solve ( n , k ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = " " NEW_LINE for a in range ( - 1000 , 1000 + 1 ) : NEW_LINE INDENT for b in range ( - 1000 , 1000 + 1 ) : NEW_LINE INDENT num = numberOfConsecutivePrimes generate ( a , b ) NEW_LINE if num > bestNum : NEW_LINE INDENT bestNum , bestA , bestB = a , b NEW_LINE DEDENT DEDENT DEDENT return str ( bestA * bestB ) NEW_LINE DEDENT def numberOfConsecutivePrimes generate ( a , b ) : NEW_LINE INDENT for i in range ( 0 , 10000 ) : NEW_LINE INDENT n = i ** 2 + i ** 2 + b ** 2 NEW_LINE if n < 0 or eulerlib . is_prime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n > k : NEW_LINE INDENT print ( ( k * ( k + 1 ) ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( k * ( k + 1 ) ) // 2 - n ) NEW_LINE DEDENT DEDENT
MAX = 100001 NEW_LINE isPrime = [ 0 ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if isPrime [ p ] == 0 : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = 1 NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def findSubset ( a , n ) : NEW_LINE INDENT cnt1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT DEDENT if cnt1 > 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] != 1 ) and ( isPrime [ a [ i ] + 1 ] == 0 ) ) : NEW_LINE INDENT print ( cnt1 + 1 ) NEW_LINE for j in range ( cnt1 ) : NEW_LINE INDENT print ( 1 , end = " " ) NEW_LINE DEDENT print ( a [ i ] ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT DEDENT if cnt1 >= 2 : NEW_LINE INDENT print ( cnt1 ) NEW_LINE for i in range ( cnt1 ) : NEW_LINE INDENT print ( 1 , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if isPrime [ a [ i ] + a [ j ] ] == 0 : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( a [ i ] , end = " " ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) NEW_LINE A = [ 2 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE findSubset ( A , n ) NEW_LINE DEDENT
n , r , t = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT x = 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i * p [ j ] > 0 : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT if x > 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s . count ( " H " ) == 1 and s . count ( " o " ) == 2 : NEW_LINE INDENT print ( " a " * s . count ( " H " ) ) NEW_LINE DEDENT elif s . count ( " i " ) == 1 and s . count ( " n " ) == 2 : NEW_LINE INDENT print ( " o " * s . count ( " i " ) ) NEW_LINE DEDENT elif s . count ( " o " ) == 1 and s . count ( " n " ) == 2 : NEW_LINE INDENT print ( " a " * s . count ( " o " ) ) NEW_LINE DEDENT else : NEW_LINE INDENT t = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == " H " : NEW_LINE INDENT t += s [ i + 1 ] NEW_LINE DEDENT elif s [ i ] == " o " and s [ i + 1 ] == 2 : NEW_LINE INDENT t += " s " NEW_LINE DEDENT elif s [ i ] == " i " and s [ i + 1 ] == 3 : NEW_LINE INDENT t += " n " NEW_LINE DEDENT elif s [ i ] == " o " and s [ i + 1 ] == 2 : NEW_LINE INDENT t += " i " NEW_LINE DEDENT elif s [ i ] == " o " and s [ i + 1 ] == 3 : NEW_LINE INDENT t += " s " NEW_LINE DEDENT elif s [ i ] == " i " and s [ i + 2 ] == 3 : NEW_LINE INDENT t += " n " NEW_LINE DEDENT elif s [ i ] == " o " and s [ i + 1 ] == 2 : NEW_LINE INDENT t += " a " NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , 0 , n - 1 ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE i = 1 NEW_LINE x = 1 NEW_LINE while k > i : NEW_LINE INDENT k -= i NEW_LINE i += 1 NEW_LINE DEDENT print ( x ) NEW_LINE
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( temp [ j ] == True ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT arr = [ 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE m = 5 NEW_LINE if ( modularSum ( arr , n , m ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT b , e , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = 0 NEW_LINE if b == e : NEW_LINE INDENT s += 1 NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( b , e ) : NEW_LINE INDENT if a [ j ] == k : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT DEDENT
n , x = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr . sort ( ) NEW_LINE total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total += arr [ i ] NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT if total >= arr [ i ] : NEW_LINE INDENT total -= arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT total += arr [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if total >= arr [ i ] : NEW_LINE INDENT total -= arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT total += arr [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( total ) NEW_LINE
from collections import Counter NEW_LINE while 1 : NEW_LINE INDENT d , w = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 0 : break NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( d ) ] NEW_LINE b = [ [ 0 ] * w for _ in range ( d ) ] NEW_LINE for i in range ( d - 1 ) : NEW_LINE INDENT for j in range ( w - 1 ) : NEW_LINE INDENT b [ i ] [ j ] = min ( b [ i ] [ j ] , b [ i ] [ j + 1 ] + a [ i ] [ j ] ) NEW_LINE DEDENT DEDENT def f ( x , y , z ) : NEW_LINE INDENT return max ( [ sum ( a [ i ] [ j + 1 ] - a [ i ] [ j ] for i in range ( d ) ) for j in range ( w ) ] ) NEW_LINE DEDENT print ( max ( [ f ( x , y , z + 1 ) for i in range ( d ) ] ) ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < a [ s ] : NEW_LINE INDENT s += a [ s ] - a [ i ] NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE
def sum ( k , n ) : NEW_LINE INDENT sum = ( k ** ( k + 1 ) - k ** ( k - 1 ) ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( sum ( K , n ) ) NEW_LINE DEDENT
dp = [ [ [ - 1 for k in range ( 162 ) ] for j in range ( 18 ) ] for i in range ( 18 ) ] NEW_LINE def solve ( i , tight , sum_so_far , Sum , number , length ) : NEW_LINE INDENT if ( i == length ) : NEW_LINE INDENT if ( sum_so_far == Sum ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = dp [ i ] [ 1 ] [ sum_so_far ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = 0 NEW_LINE ntight = 0 NEW_LINE nsum_far = 0 NEW_LINE for currdigit in range ( ord ( '0' ) , ord ( '9' ) + 1 ) : NEW_LINE INDENT if ( tight and currdigit > number [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT ntight = tight or currdigit < number [ i ] NEW_LINE nsum_far = sum_so_far + ( currdigit - ord ( '0' ) ) NEW_LINE ans += solve ( i + 1 , ntight , nsum_sofar , Sum , number , length ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT count = 0 NEW_LINE sum = 4 NEW_LINE number = "100" NEW_LINE ans = solve ( 0 , 0 , sum , number , len ( number ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE l . append ( s ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in l : NEW_LINE INDENT if i == '1' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def evenOddLevelDifference ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE level = 0 NEW_LINE evenSum = 0 NEW_LINE oddSum = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT size = len ( q ) NEW_LINE level += 1 NEW_LINE while ( size > 0 ) : NEW_LINE INDENT temp = q [ 0 ] NEW_LINE if ( level % 2 == 0 ) : NEW_LINE INDENT evenSum += temp . data NEW_LINE DEDENT else : NEW_LINE INDENT oddSum += temp . data NEW_LINE DEDENT if ( temp . left ) : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE DEDENT if ( temp . right ) : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT size -= 1 NEW_LINE DEDENT DEDENT return ( oddSum - evenSum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 5 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 6 ) NEW_LINE root . left . left = Node ( 1 ) NEW_LINE root . left . right = Node ( 4 ) NEW_LINE root . left . right . left = Node ( 3 ) NEW_LINE root . left . right . right = Node ( 2 ) NEW_LINE root . right . right . right = Node ( 8 ) NEW_LINE root . right . right . right = Node ( 9 ) NEW_LINE root . right . right . left = Node ( 7 ) NEW_LINE print ( " Difference between sums is " , evenOddLevelDifference ( root ) ) NEW_LINE DEDENT
def countSubarrays ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE number = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number += ( count ) * ( count + 1 ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count != 0 ) : NEW_LINE INDENT number += ( count ) * ( count + 1 ) // 2 NEW_LINE DEDENT return number NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 ] NEW_LINE n = len ( a ) NEW_LINE k = 5 NEW_LINE print ( countSubarrays ( a , n , k ) ) NEW_LINE DEDENT
def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE DEDENT
def printLastOccurrence ( a , n ) : NEW_LINE INDENT map = dict . fromkeys ( a , i ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] = i ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] == i ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 5 , 5 , 1 , 6 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE printLastOccurrence ( a , n ) ; NEW_LINE DEDENT
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE m , cnt = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > 0 : NEW_LINE INDENT m += 1 NEW_LINE if a [ i ] >= 2 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT if cnt == 0 : print ( " NA " ) NEW_LINE else : print ( cnt ) NEW_LINE DEDENT
def countPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ) NEW_LINE DEDENT n = 5 NEW_LINE m = 5 NEW_LINE print ( countPaths ( n , m ) ) NEW_LINE
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
def coordinateCompression ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT index = 0 NEW_LINE mp = dict ( ) NEW_LINE for itr in s : NEW_LINE INDENT index += 1 NEW_LINE mp [ itr ] = index NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT def query ( BIT , index , n ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( index > 0 ) : NEW_LINE INDENT ans = max ( ans , BIT [ index ] ) NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def update ( BIT , index , n ) : NEW_LINE INDENT x = query ( BIT , index - 1 , n ) NEW_LINE value = x + 1 NEW_LINE while ( index <= n ) : NEW_LINE INDENT BIT [ index ] = max ( BIT [ index ] , value ) NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def findLISLength ( arr , n ) : NEW_LINE INDENT coordinateCompression ( arr , n ) NEW_LINE BIT = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT BIT [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT update ( BIT , arr [ i ] , n ) NEW_LINE DEDENT ans = query ( BIT , n , n ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 5 , 1 , 3 , 2 , 4 , 8 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE ans = findLISLength ( arr , n ) NEW_LINE print ( ans ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT t -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT ans = ' YES ' NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 5 ) : NEW_LINE INDENT for k in range ( 5 ) : NEW_LINE INDENT if arr [ i ] [ j ] == arr [ i ] [ k ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CON sec sec sec = 9 NEW_LINE ways = [ [ 0 ] * ( DIGITS + CON sec + 1 ) for i in range ( DIGITS + CON sec + 1 ) ] NEW_LINE ways [ 0 ] [ 0 ] = 1 NEW_LINE for digits in range ( 1 , len ( ways ) ) : NEW_LINE INDENT for prefix in range ( len ( ways [ digits ] ) ) : NEW_LINE INDENT sum = 0 NEW_LINE if digit_sum ( prefix ) <= sec : NEW_LINE INDENT for next_digit in range ( BASE ) : NEW_LINE INDENT sum = sum + ways [ digits - 1 ] [ prefix % eulerlib . pow ( BASE , CON sec - 1 ) * BASE + next_digit ] NEW_LINE DEDENT DEDENT ways [ digits ] [ prefix ] = sum NEW_LINE DEDENT DEDENT return ways [ DIGITS + CON sec ] [ 0 ] - ways [ DIGITS + CON sec ] [ 0 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
l = [ ] NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE c = input ( ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT l . append ( [ a , b , c ] ) NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if l [ i ] [ j ] == l [ i ] [ j + 1 ] and l [ i + 1 ] [ j ] == l [ i ] [ j + 1 ] and l [ i - 1 ] [ j ] == l [ i ] [ j + 1 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT elif l [ i ] [ j ] == l [ i - 1 ] [ j ] and l [ i - 1 ] [ j ] == l [ i ] [ j + 1 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT DEDENT print ( ' NO ' ) NEW_LINE
class Solution ( object ) : NEW_LINE INDENT def isToe splitzMatrix ( self , matrix ) : NEW_LINE INDENT return all ( matrix [ r ] [ c ] != matrix [ r ] [ c ] for c in range ( 1 , len ( matrix ) ) if matrix [ r - 1 ] [ c - 1 ] != matrix [ r ] [ c ] for r in range ( 1 , len ( matrix ) ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE matrix = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 1 , 2 , 3 ] , [ 9 , 5 , 1 , 2 ] ] NEW_LINE out = sObj . isToe splitzMatrix ( matrix ) NEW_LINE print ( out ) NEW_LINE DEDENT
import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE ans = 0 NEW_LINE for s in range ( 1 , eulerlib . sqrt ( LIMIT + 1 ) // 3 + 2 ) : NEW_LINE INDENT for t in range ( s - 2 , 0 , - 2 ) : NEW_LINE INDENT if fractions . gcd ( s , t ) == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * s - t * t ) // 2 NEW_LINE c = ( s * s + t * t ) // 2 NEW_LINE if a * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if a * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if b * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if b * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT N , T , L , B = map ( int , input ( ) . split ( ) ) NEW_LINE if N == 0 : break NEW_LINE fert = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( L ) ] NEW_LINE dp = [ [ 0.0 ] * ( T + 1 ) for _ in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1.0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , T + 1 ) : NEW_LINE INDENT if j < N : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( ' { : . 12f } ' . format ( dp [ N ] [ T ] ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE odd = sum ( arr ) NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i % 2 ) != ( odd % 2 ) ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( even % 2 == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( odd > 0 and even > 1 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
from math import ceil NEW_LINE def min insert insert insertions ( H , n , K ) : NEW_LINE INDENT inser = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT inser += ceil ( diff / K ) - 1 NEW_LINE DEDENT DEDENT return inser NEW_LINE DEDENT H = [ 2 , 4 , 8 , 16 ] NEW_LINE K = 3 NEW_LINE n = len ( H ) NEW_LINE print ( min insertions ( H , n , K ) ) NEW_LINE
def countWords ( str1 , len1 ) : NEW_LINE INDENT count = 1 NEW_LINE if ( len1 == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str1 [ 0 ] == str1 [ 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , len1 - 1 ) : NEW_LINE INDENT if ( str1 [ j ] == str1 [ j - 1 ] and str1 [ j ] == str1 [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str1 [ j ] == str1 [ j - 1 ] or str1 [ j ] == str1 [ j + 1 ] or str1 [ j - 1 ] == str1 [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str1 [ len1 - 1 ] == str1 [ len - 2 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " abc " NEW_LINE len1 = len ( str1 ) NEW_LINE print ( countWords ( str1 , len1 ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE evenlist = [ ] NEW_LINE oddlist = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT evenlist . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddlist . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenlist . sort ( ) NEW_LINE oddlist . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT ans += evenlist [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += oddlist [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] NEW_LINE current = 1 NEW_LINE i = 1 NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) NEW_LINE current = ( int ) ( pow ( i + 1 , 2 ) ) NEW_LINE i += 1 NEW_LINE DEDENT return perfectSquares NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE max , secondMax = 0 , 0 NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT max , secondMax = arr [ 0 ] , arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT max , secondMax = arr [ 1 ] , arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max NEW_LINE max = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT DEDENT return ( max + secondMax ) NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n NEW_LINE if ( temp > n and temp in nums ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def countPairs ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE max = maxPairSum ( arr ) NEW_LINE perfectSquares = getPerfectSquares ( max ) NEW_LINE nums = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT nums [ i ] = nums . get ( i , 0 ) + 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count += countPairsWith ( arr [ i ] , perfectSquares , nums ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3
import math NEW_LINE def findHypotenuse ( side1 , side2 ) : NEW_LINE INDENT h = math . sqrt ( ( side1 * side1 ) + ( side2 * side2 ) ) NEW_LINE return h NEW_LINE DEDENT side1 = 3 NEW_LINE side2 = 4 NEW_LINE print ( round ( findHypotenuse ( side1 , side2 ) , 2 ) ) NEW_LINE
def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE n = size - 2 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The two ODD elements are " , x , " & " , y ) NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printTwoOdd ( arr , arr_size ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE l . sort ( ) NEW_LINE d = l [ - 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if l [ i ] > d : NEW_LINE INDENT d = l [ i ] NEW_LINE DEDENT DEDENT ans += min ( l ) NEW_LINE l . sort ( ) NEW_LINE if l [ - 1 ] == l [ - 2 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
days = [ " m Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] NEW_LINE a , b = input ( ) . split ( ) NEW_LINE if days [ 1 ] == a : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE OO = [ ] NEW_LINE OO . append ( " - " ) NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " - " : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if OO [ i ] != s [ 0 ] : NEW_LINE INDENT OO . append ( s [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT DEDENT if flag == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE for i in OO : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printList ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE while ( temp != head ) : NEW_LINE INDENT print ( temp . data , end = " - > " ) NEW_LINE temp = temp . next NEW_LINE DEDENT while ( temp != head ) : NEW_LINE INDENT print ( head . data ) NEW_LINE temp = head NEW_LINE DEDENT DEDENT def deleteK ( head_ref , k ) : NEW_LINE INDENT head = head_ref NEW_LINE if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT curr = head NEW_LINE prev = None NEW_LINE while ( True ) : NEW_LINE INDENT if ( curr . next == head and curr == head ) : NEW_LINE INDENT break NEW_LINE DEDENT printList ( head ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE DEDENT if ( curr == head ) : NEW_LINE INDENT prev = head NEW_LINE while ( prev . next != head ) : NEW_LINE INDENT prev = prev . next NEW_LINE DEDENT head = curr . next NEW_LINE prev . next = head NEW_LINE head_ref = head NEW_LINE DEDENT elif ( curr . next == head ) : NEW_LINE INDENT prev . next = head NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = curr . next NEW_LINE DEDENT DEDENT return head NEW_LINE DEDENT def insertNode ( head_ref , x ) : NEW_LINE INDENT head = head_ref NEW_LINE temp = Node ( x ) NEW_LINE if ( head == None ) : NEW_LINE INDENT temp . next = temp NEW_LINE head_ref = temp NEW_LINE return head NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = head NEW_LINE while ( temp1 . next != head ) : NEW_LINE INDENT temp1 = temp1 . next NEW_LINE DEDENT temp . next = temp NEW_LINE temp . next = head NEW_LINE return head NEW_LINE DEDENT DEDENT if __name__ ==
def steps ( cur , x , n ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return - 2147483648 NEW_LINE DEDENT if ( x > 0 ) : NEW_LINE INDENT return abs ( ( n - cur ) // x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( ( cur - 1 ) // x ) NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT x , y = moves [ i ] [ 0 ] , moves [ i ] [ 1 ] NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT n = 4 NEW_LINE m = 5 NEW_LINE x = 1 NEW_LINE y = 1 NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] NEW_LINE print ( countSteps ( x , y , n , m , moves ) ) NEW_LINE
x1 , x2 , x3 = map ( int , input ( ) . split ( ) ) NEW_LINE a = min ( x1 , x2 ) NEW_LINE b = max ( x1 , x3 ) NEW_LINE c = min ( x2 , x3 ) NEW_LINE d = max ( x1 , x3 ) - min ( x1 , x3 ) NEW_LINE print ( min ( d , a ) + min ( d , b ) ) NEW_LINE
def cntSubArr ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_gcd = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_gcd = __gcd ( curr_gcd , arr [ j ] ) NEW_LINE ans += 1 if ( curr_gcd == 1 ) else 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cntSubArr ( arr , n ) ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isVowelPrime ( str1 , n ) : NEW_LINE INDENT prime = [ True ] * n NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) and not prime [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " geeksforgeeks " NEW_LINE n = len ( str1 ) NEW_LINE if ( isVowelPrime ( str1 , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def minStep p ( str1 ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for l in range ( 1 , N + 1 ) : NEW_LINE INDENT for i in range ( N + 1 ) : NEW_LINE INDENT j = l - 1 NEW_LINE while j < N : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if ( str1 [ i ] == str1 [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT for k in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if ( str1 [ i ] == str1 [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ k - 1 ] + dp [ k + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = "2553432' NEW_LINE print ( minStep p ( str1 ) ) NEW_LINE DEDENT
limit = 10000000 NEW_LINE position = [ 0 ] * ( limit + 1 ) NEW_LINE def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT position [ i ] = pos + 1 NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT sieve ( ) NEW_LINE n = 11 NEW_LINE print ( position [ n ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve ( ) NEW_LINE DEDENT
DP_s = 9 NEW_LINE def getNum monotone ( len ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( DP_s ) ] for i in range ( len ) ] NEW_LINE for i in range ( len ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , len ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = ( DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return DP [ len - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( getNum monotone ( 10 ) ) NEW_LINE DEDENT
DP_s = 9 NEW_LINE def getNum monotone ( len ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( DP_s ) ] for i in range ( len ) ] NEW_LINE for i in range ( len ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , len ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = ( DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return DP [ len - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( getNum monotone ( 10 ) ) NEW_LINE DEDENT
def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE lst = [ input ( ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if lst [ i ] [ j ] == ' R ' : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
PI = PI NEW_LINE def findArea ( r ) : NEW_LINE INDENT return PI * pow ( r , 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " Area is " , findArea ( 5 ) ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE y = [ ] NEW_LINE x = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT y . append ( [ ] ) NEW_LINE DEDENT y_m = defaultdict ( list ) NEW_LINE for i in range ( 2 * k ) : NEW_LINE INDENT y_m [ int ( input ( ) ) - 1 ] . append ( 1 ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT x_y [ int ( input ( ) ) - 1 ] . append ( y [ int ( input ( ) ) - 1 ] ) NEW_LINE y_m [ x_y [ int ( input ( ) ) - 1 ] ] . append ( y [ int ( input ( ) ) - 1 ] ) NEW_LINE DEDENT memo = defaultdict ( list ) NEW_LINE def dfs ( k ) : NEW_LINE INDENT memo [ k ] = 1 NEW_LINE for i in y_m [ k ] : NEW_LINE INDENT if memo [ i ] == - 1 : NEW_LINE INDENT dfs ( i ) NEW_LINE DEDENT DEDENT memo [ k ] = min ( memo [ k ] , 2 * k - memo [ k ] ) NEW_LINE DEDENT print ( sum ( memo [ 1 ] ) ) NEW_LINE
def nthTerm ( N ) : NEW_LINE INDENT return abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = 35 NEW_LINE print ( getHeight ( X ) ) NEW_LINE DEDENT
V = 4 NEW_LINE def countwalks ( graph , u , v , k ) : NEW_LINE INDENT if ( k == 0 and u == v ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 1 and graph [ u ] [ v ] == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] == 1 ) : NEW_LINE INDENT count += countwalks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT graph = [ [ 0 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE u , v , k = 0 , 3 , 2 NEW_LINE KPaths = [ ] NEW_LINE print ( countwalks ( graph , u , v , k ) ) NEW_LINE DEDENT
from math import floor NEW_LINE def findDigits ( n , b ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT M_ PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_ PI * n ) / 2.0 ) / ( log10 ( b ) ) ) NEW_LINE return floor ( x ) + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( findDigits ( 4 , 16 ) ) NEW_LINE print ( findDigits ( 5 , 8 ) ) NEW_LINE print ( findDigits ( 12 , 16 ) ) NEW_LINE print ( findDigits ( 19 , 13 ) ) NEW_LINE DEDENT
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE Q = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT if Q [ i ] [ 0 ] == 0 : NEW_LINE INDENT P = [ ] NEW_LINE c = 1 NEW_LINE while c < n : NEW_LINE INDENT P . append ( c ) NEW_LINE c += 1 NEW_LINE DEDENT P . append ( c ) NEW_LINE print ( sum ( P ) ) NEW_LINE DEDENT else : NEW_LINE INDENT c = 1 NEW_LINE while c < n : NEW_LINE INDENT P . append ( c ) NEW_LINE c += 1 NEW_LINE DEDENT print ( sum ( P ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE if n == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT ans = 1 NEW_LINE while n != 1 : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT ans *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans *= 1 NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT print ( ans % MOD ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from math import ceil NEW_LINE while 1 : NEW_LINE INDENT a , b , _ , n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if not a : break NEW_LINE ans = 0 NEW_LINE while n : NEW_LINE INDENT d = ceil ( n / d ) NEW_LINE x = d * x NEW_LINE if x <= m : NEW_LINE INDENT ans += x NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
s = " " NEW_LINE def ReverseString ( s ) : NEW_LINE INDENT arr = list ( s ) NEW_LINE for i in range ( int ( len ( arr ) / 2 ) ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ len ( arr ) - i - 1 ] NEW_LINE arr [ len ( arr ) - i - 1 ] = temp NEW_LINE DEDENT return arr NEW_LINE DEDENT def binary_ character ( m ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT tmp = m % 2 NEW_LINE s += str ( tmp ) NEW_LINE m = int ( m / 2 ) NEW_LINE DEDENT s = ReverseString ( s ) NEW_LINE DEDENT def find_ character ( n , m , i ) : NEW_LINE INDENT binary_ character ( m ) NEW_LINE s1 = " " NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ y ] == '1' ) : NEW_LINE INDENT s1 += "10" NEW_LINE DEDENT else : NEW_LINE INDENT s1 += "01" NEW_LINE DEDENT DEDENT s = s1 NEW_LINE s1 = " " NEW_LINE DEDENT return ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT m = 5 NEW_LINE n = 2 NEW_LINE i = 8 NEW_LINE print ( find_ character ( n , m , i ) ) NEW_LINE
def countSubsets ( arr , n ) : NEW_LINE INDENT us = dict ( ) NEW_LINE even_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT us [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT even_count = len ( us ) NEW_LINE return ( pow ( 2 , even_count ) - 1 ) NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 9 , 2 , 6 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Number of subsets = " , countSubsets ( arr , n ) ) NEW_LINE
MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return ( f [ n ] = 1 ) NEW_LINE DEDENT if ( f [ n ] != 0 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = 0 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT k = ( n + 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findLCMFibonacci ( a , b ) : NEW_LINE INDENT return ( ( fib ( a ) * fib ( b ) ) // fib ( gcd ( a , b ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE b = 12 NEW_LINE print ( findLCMFibonacci ( a , b ) ) NEW_LINE DEDENT
def findNumbers ( n , w ) : NEW_LINE INDENT x = 0 ; sum = 0 ; NEW_LINE if ( w >= 0 and w <= 8 ) : NEW_LINE INDENT x = 9 - w ; NEW_LINE DEDENT elif ( w >= - 9 and w <= - 1 ) : NEW_LINE INDENT x = 10 + w ; NEW_LINE DEDENT sum = ( 10 ** ( n - 2 ) ) * ( x * sum ) ; NEW_LINE return sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 ; NEW_LINE w = 4 ; NEW_LINE print ( findNumbers ( n , w ) ) ; NEW_LINE DEDENT
def findKthChar ( s , k ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < l ) : NEW_LINE INDENT if ( s [ i ] . isupper ( ) ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < l and ( s [ i ] . islower ( ) ) ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if ( k <= next_total_len ) : NEW_LINE INDENT pos = k % total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT DEDENT s = " ab2c3" NEW_LINE k = 5 NEW_LINE print ( findKthChar ( s , k ) ) NEW_LINE
def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE return n * ( n + 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abcde " NEW_LINE print ( countNonEmptySubstr ( s ) ) NEW_LINE DEDENT
