public static boolean [ ] sieveOfErastosthenes ( int num ) { final boolean [ ] inputArray = new boolean [ num ] ; for ( int i = 0 ; i < num ; i ++ ) { inputArray [ i ] = i % 2 == 0 || i % 3 == 0 || i % 5 == 0 ? false : true ; } inputArray [ 0 ] = inputArray [ 1 ] = false ; inputArray [ 2 ] = inputArray [ 3 ] = inputArray [ 5 ] = true ; final double sqrt = Math . sqrt ( num ) ; for ( int serial = 3 ; serial < num ; serial += 2 ) { if ( serial >= sqrt ) { return inputArray ; } for ( int s = serial * serial ; s < num ; s += serial ) { inputArray [ s ] = false ; } } final boolean [ ] primeTable = sieveOfErastosthenes ( 13 * ( 10 * 5 ) ) ; while ( true ) { final int k = Integer . parseInt ( input . nextLine ( ) ) ; if ( k == 0 ) { break ; } if ( primeTable [ k ] ) { System . out . println ( 0 ) ; } else { int i = k ; while ( primeTable [ i ] == false ) i ++ ; int j = i - 1 ; while ( primeTable [ j ] == false ) j -- ; System . out . println ( i - j ) ; } } return inputArray ; }
public static String findPalindromicString ( String str1 , int [ ] freq , int len1 ) { for ( int i = 0 ; i < len1 ; i ++ ) { freq [ ( str1 . charAt ( i ) - ' a ' ) ] ++ ; } /* ▁ Only ▁ make ▁ Palindrome ▁ */ int count_odd = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( ( freq [ i ] % 2 ) != 0 ) { count_odd ++ ; } } if ( ( len1 % 2 ) == 0 ) { if ( ( count_odd > 0 ) && ( count_odd < 1 ) ) { return false ; } else { return true ; } } if ( ( count_odd != 1 ) && ( count_odd < 1 ) ) { return false ; } /* ▁ find ▁ the ▁ OddAndRemoveItsFreq ▁ */ String odd_str = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( ( freq [ i ] % 2 ) != 0 ) { freq [ i ] -- ; odd_str += ( char ) ( i + ' a ' ) ; return odd_str ; } } /* ▁ find ▁ the ▁ Palindromic ▁ String ▁ */ int len1 = str1 . length ( ) ; int [ ] freq = new int [ MAX_CHAR ] ; countFreq ( str1 , freq , len1 ) ; if ( ( canMakePalindrome ( freq , len1 ) == false ) && ( canMakePalindrome ( freq , len1 ) == false ) ) { return " No ▁ Palindromic ▁ String " ; } String odd_str = findOddAndRemoveItsFreq ( freq ) ; String front_str = " " ; String rear_str = " ▁ " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { String temp = " " ; if ( ( freq [ i ] != 0 ) && ( freq [ i ] > 0 ) ) { char ch = ( char ) ( i + ' a ' ) ; for ( int j = 1 ; j <= ( int ) ( freq [ i ] / 2 ) ; j ++ ) { temp += ch ; } front_str += temp ; rear_str = temp + rear_str ; } } /* ▁ find ▁ the ▁ Palindromic ▁ String ▁ */ str1 = " malayalam " ; System . out . println ( find
static final double cross ( Complex a , Complex b ) { return a . real * b . imag - a . imag * b . real ; }
public static int count9s ( String number ) { int n = number . length ( ) ; int [ ] d = new int [ 9 ] ; for ( int i = 0 ; i < n ; i ++ ) { d [ i ] = 0 ; } d [ 0 ] = 1 ; int result = 0 ; int modSum = 0 ; int continuousZero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( int ) number . charAt ( i ) - '0' ) == 0 ) { continuousZero ++ ; } else { continuousZero = 0 ; } modSum += ( int ) number . charAt ( i ) - '0' ; modSum %= 9 ; result += d [ modSum ] ; d [ modSum ] ++ ; result -= continuousZero ; } return result ; }
public static int fastPow ( int N , int K ) { if ( ( K == 0 ) || ( N == 1 ) ) { return 1 ; } int temp = fastPow ( N , ( int ) ( K / 2 ) ) ; if ( K % 2 == 0 ) { return temp * temp ; } return N ; }
@ Test public static void NUM ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == - 1 ) break ; int current = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int num = NUM . get ( Integer . parseInt ( input . nextLine ( ) ) ) ; System . out . println ( format ( current ^ num , ' b ' ) . zfill ( 7 ) ) ; current = num ; } }
public static void SieveOfEratosthenes ( ) { int MAX = 10000 ; int arr [ ] = new int [ MAX ] ; { boolean [ ] prime = new boolean [ MAX ] ; int p = 2 ; while ( p * p < MAX ) { if ( ( prime [ p ] = true ) && ( prime [ p ] = false ) ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } p ++ ; } for ( p = 2 ; p < MAX ; p ++ ) { if ( ( prime [ p ] = true ) && ( prime [ p ] = false ) ) { arr [ p ] = true ; } } } int n ; int product = 1 ; int i = 0 ; while ( ( product = product * arr [ i ] ) != 0 ) { product = product * arr [ i ] ; if ( ( product + 1 == n ) && ( arr [ i ] == true ) ) { return true ; } i ++ ; } if ( __name__ == " java . util . concurrent . ConcurrentLinkedQueue " ) { SieveOfEratosthenes ( ) ; n = 31 ; if ( ( n = product * arr [ i ] ) != 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } n = 42 ; if ( ( n = product * arr [ i ] ) != 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
@ VisibleForTesting static void prime ( ) { final int MAX = 100000 ; final boolean [ ] prime = new boolean [ MAX ] ; final int [ ] arr = new int [ MAX ] ; { for ( int p = 2 ; p <= ( int ) Math . sqrt ( MAX ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { arr [ p ] = true ; } } } { if ( ! prime [ n ] ) { return ; } int product = 1 , i = 0 ; while ( product < n ) { product *= arr [ i ] ; if ( product + 1 == n || product - 1 == n ) { return ; } i ++ ; } return ; } if ( className == " java . lang . Math " ) { SieveOfEratosthenes ( ) ; final int n = 31 ; if ( ( n = isPrimorialPrime ( n ) ) && ( n > 0 ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public static void mulTable ( int N , int i ) { if ( ( i > 10 ) && ( i < 0 ) ) return ; System . out . println ( N + " * " + i + " = " + N * i ) ; }
static long closestNumber ( long n , long m ) { long q = ( long ) ( n / m ) ; long n1 = m * q ; long n2 ; if ( ( ( n * m ) > 0 ) && ( ( n * m ) > 0 ) ) n2 = ( m * ( q + 1 ) ) ; else n2 = ( m * ( q - 1 ) ) ; return n2 ; }
public static int solve ( int ang , int n ) { if ( ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) ) return 0 ; else if ( ( ( ang * n ) % 180 ) != 0 ) return 0 ; int ans = 1 ; int freq = ( ang * n ) / 180 ; ans = ans * ( n ) ; return ans ; }
private static int [ ] computeLps ( String s ) { int n = s . length ( ) ; int [ ] lps = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { lps [ i ] = 0 ; } int Len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( ( i < n ) && ( s . charAt ( i ) == s . charAt ( Len ) ) ) { Len ++ ; lps [ i ] = Len ; i ++ ; } else { if ( ( Len != 0 ) && ( lps [ Len - 1 ] != 0 ) ) Len = lps [ Len - 1 ] ; } return lps ; }
static void checkIfSortRotated ( int [ ] arr , int n ) { final int minEle = Integer . MAX_VALUE ; final int maxEle = - Integer . MAX_VALUE - 1 ; int minIndex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < minEle ) { minEle = arr [ i ] ; minIndex = i ; } } boolean flag1 = true ; for ( int i = 1 ; i < minIndex ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag1 = false ; break ; } } boolean flag2 = false ; for ( int i = minIndex + 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i ] ) { flag2 = true ; } } }
public static void input ( ) { String [ ] a = input . split ( " ▁ " ) ; int n = Integer . parseInt ( a [ 0 ] ) ; int d = Integer . parseInt ( a [ 1 ] ) ; int [ ] array = input . split ( " ▁ " ) ; a = 0 ; while ( a < n ) { array [ a ] = Integer . parseInt ( array [ a ] ) ; a ++ ; } a = 0 ; int i = 0 ; while ( i < n - 1 ) { if ( array [ i ] >= array [ i + 1 ] ) { a += ( array [ i ] - array [ i + 1 ] ) / d + 1 ; array [ i + 1 ] += ( ( array [ i ] - array [ i + 1 ] ) / d + 1 ) * d ; } i ++ ; } System . out . println ( a ) ; }
static void checkIfPowerIsolated ( int num ) { int input1 = num ; int count = 0 ; int [ ] factor = new int [ num + 1 ] ; int i ; if ( ( num % 2 ) == 0 ) { while ( ( num % 2 ) == 0 ) { count ++ ; num /= 2 ; } factor [ 2 ] = count ; } i = 3 ; while ( ( i * i <= num ) && ( i <= num ) ) { count = 0 ; while ( ( num % i ) == 0 ) { factor [ i ] = count ; } i ++ ; } }
static int a ( String s ) { int a = 1 , c = 0 ; for ( char x : s . toCharArray ( ) ) { if ( x == ' A ' && a ) a = 0 ; else if ( x == ' Z ' && ! a ) a = 1 ; c = c + 1 ; } return c > 0 ? a : - 1 ; }
@ VisibleForTesting static void main ( String input ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int [ ] a = new int [ n ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = input . nextInt ( ) ; } for ( int i = 0 ; i < indices . length ; i ++ ) { if ( indices [ i ] . length < 2 ) { continue ; } for ( int j = 0 ; j < indices [ i ] . length - 1 ; j ++ ) { int first = indices [ i ] [ j ] ; int second = indices [ i ] [ j + 1 ] ; ans = Math . max ( ans , n - second + first ) ; } } System . out . println ( ans > 0 ? ans : - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { n = Integer . parseInt ( input . nextLine ( ) ) ; a = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { a [ j ] = input . nextInt ( ) ; } } input . close ( ) ; }
public static String multiply ( String num1 , String num2 ) { int len1 = num1 . length ( ) ; int len2 = num2 . length ( ) ; if ( len1 == 0 || len2 == 0 ) { return "0" ; } int [ ] result = new int [ len1 + len2 ] ; int in1 = 0 ; int in2 = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = ( num1 . charAt ( i ) - 48 ) ; in2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int n2 = ( num2 . charAt ( j ) - 48 ) ; int summ = n1 * n2 + result [ in1 + in2 ] + carry ; carry = summ / 10 ; result [ in1 + in2 ] = summ % 10 ; in2 ++ ; } if ( ( carry > 0 ) && ( carry > 0 ) ) { result [ in1 + in2 ] += carry ; } in1 ++ ; } int i = result . length - 1 ; while ( ( i >= 0 ) && ( result [ i ] == 0 ) ) { i -- ; } if ( ( i == - 1 ) && ( result [ i ] == 0 ) ) { return "0" ; } String s = " " ; while ( ( i >= 0 ) && ( result [ i ] == 0 ) ) { s += ( char ) ( result [ i ] + 48 ) ; i -- ; } return s ; }
public static void n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; X = Arrays . asList ( n ) ; Y = Arrays . asList ( n ) ; System . out . println ( sum ( Y ) <= sum ( X ) ? " Yes " : " No " ) ; }
public static int nSquare ( ) { int nSquare = Integer . parseInt ( input ( ) ) ; int kth = Integer . parseInt ( input ( ) ) ; int [ ] slogan = input . split ( " ▁ " ) ; if ( kth - 1 < ( nSquare - 1 ) - ( kth - 1 ) ) { while ( kth - 1 > 0 ) { kth -- ; System . out . println ( " LEFT " ) ; } for ( int i = 0 ; i < nSquare ; i ++ ) { System . out . println ( f " PRINT ▁ { slogan [ i ] } " ) ; if ( i != nSquare - 1 ) System . out . println ( " RIGHT " ) ; } } else { int nRight = nSquare - kth ; while ( nRight > 0 ) { nRight -- ; System . out . println ( " RIGHT " ) ; } for ( int i = nSquare - 1 ; i >= 0 ; i -- ) { System . out . println ( f " PRINT ▁ { slogan [ i ] } " ) ; if ( i != 0 ) System . out . println ( " LEFT " ) ; } } return nSquare ; }
static void printDistSum ( int arr [ ] , int n ) { int Sum = sum ( arr ) ; boolean dp [ ] [ ] = new boolean [ Sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = true ; } for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= Sum ; j ++ ) { if ( ( dp [ i - 1 ] [ j ] == true ) && ( dp [ i ] [ j ] == true ) ) { System . out . print ( j + " ▁ " ) ; } } } arr = 2 ; arr = 3 ; arr = 4 ; arr = 5 ; arr = 6 ; }
public static int Subtract ( int a , int b ) { int c = a + ( ~ b + 1 ) ; return c ; }
@ CommandCommand public static void enter ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int l = 1 ; int r = n ; while ( ( l < r ) && ( r < n ) ) { int mid = l + ( r - l ) / 2 ; int idxcnt = mid * ( mid + 1 ) / 2 ; if ( ( idxcnt < n ) ) l = mid + 1 ; } l -- ; idxcnt = l * ( l + 1 ) / 2 ; System . out . println ( ( int ) ( n - idxcnt ) ) ; }
public static int getInt ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } /* ▁ if ▁ ( arr [ 0 ] ▁ = = ▁ arr [ 0 ] ) ▁ { STRNEWLINE ▁ if ▁ ( arr . length ▁ = = ▁ 3 ) ▁ { STRNEWLINE ▁ return ▁ i ; STRNEWLINE ▁ } STRNEWLINE ▁ return ▁ - 1 ; STRNEWLINE ▁ } */ boolean isTrue = false ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] == arr [ i ] ) { isTrue = true ; break ; } } if ( isTrue ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } return 0 ; }
static int nextZero ( int i , int [ ] occurrences ) { while ( i < 26 ) { if ( occurrences [ i ] == 0 ) { return i ; } i ++ ; } /* ▁ get ▁ modified ▁ string ▁ */ int n = str . length ( ) ; if ( n > 26 ) { return " - 1" ; } char [ ] ch = str ; StringBuilder sb = new StringBuilder ( ) ; int [ ] occurrences = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { occurrences [ ( ch [ i ] - ' a ' ) ] ++ ; } int index = nextZero ( 0 , occurrences ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( occurrences [ ( ch [ i ] - ' a ' ) ] > 1 ) { occurrences [ ( ch [ i ] - ' a ' ) ] -- ; ch [ i ] = ( char ) ( ' a ' + index ) ; occurrences [ index ] = 1 ; index = nextZero ( index + 1 , occurrences ) ; } } sb . append ( ch ) ; System . out . println ( sb ) ; }
public static String isCorrect ( int hourMax , int minuteMax , String time ) { String [ ] h = time . split ( " : " ) ; String [ ] m = time . split ( " : " ) ; String [ ] mirrored = { "0" , "0" , "1" , "2" , "5" , "3" , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " } ; String result
@ typing . Optional . Method ( __doc__ = " " ) public static int munimumNumberOfPiles ( @ Optional int n , @ Optional List < Integer > nValues ) { Collections . sort ( nValues ) ; int pile = - 1 ; for ( int idx = 0 ; idx < nValues . size ( ) ; idx ++ ) { int s = nValues . get ( idx ) ; int k = ( int ) Math . ceil ( ( idx + 1 ) / ( s + 1 ) ) ; pile = Math . max ( pile , k ) ; } return pile ; }
public static int x = Integer . parseInt ( input ) { int x = input . nextInt ( ) ; for ( int jj = 0 ; jj < x ; jj ++ ) { int n = input . nextInt ( ) ; if ( n == 1 ) System . out . println ( 3 ) ; else { if ( n % 2 == 1 ) System . out . println ( 1 ) ; else { int p = 0 ; int k = n ; while ( n % 2 == 0 ) { p ++ ; n /= 2 ; } int t = 2 * p ; if ( t == k ) System . out . println ( t + 1 ) ; else System . out . println ( t ) ; } } } return x ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int root = ( int ) ( n * ( 1 / 2 ) ) + 1 ; boolean [ ] isPrime = new boolean [ n + 3 ] ; for ( int i = 4 ; i < n + 3 ; i += 2 ) isPrime [ i ] = false ; int ans = 0 ; int prePrime = - 1 ; for ( int i = 3 ; i < n + 3 ; i += 2 ) { if ( isPrime [ i ] ) { if ( prePrime + 2 == i ) ans += 2 ; prePrime = i ; if ( i > root ) continue ; for ( int j = i * i ; j < n + 3 ; j += i ) isPrime [ j ] = false ; } } System . out . println ( ans ) ; }
public static int [ ] L = new int [ Integer . SIZE ] ; input . nextLine ( ) ; int r = 1 ; for ( String k : input . nextLine ( ) . split ( " ▁ " ) ) { L [ r ] = Integer . parseInt ( k ) ; r ++ ; } input . nextLine ( ) ; for ( String j : input . nextLine ( ) . split ( " ▁ " ) ) { System . out . println ( L [ Integer . parseInt ( j ) - 1 ] ) ; } return L ; }
public static void input ( ) { int n = Integer . parseInt ( input . readLine ( ) ) , m = Integer . parseInt ( input . readLine ( ) ) ; int [ ] sumL = new int [ n + 2 ] ; sumL [ n ] = 0 ; sumL [ n - 2 ] = 1 ; for ( int i = n - 1 ; i > 0 ; i -- ) { L = sumL [ i + 1 ] ; int j = 2 ; while ( i * j <= n ) { L += ( sumL [ i * j ] - sumL [ Math . min ( n , ( i + 1 ) * j - 1 ) + 1 ] ) ; L %= m ; j ++ ; } L %= m ; sumL [ i ] = ( sumL [ i + 1 ] + L ) ; sumL [ i ] %= m ; } System . out . println ( L ) ; }
@ java . lang . Deprecated public static void printMax ( int [ ] arr , int n , int k ) { LinkedList < Integer > Qi = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { while ( Qi . size ( ) > 0 && arr [ i ] >= arr [ Qi . size ( ) - 1 ] ) Qi . removeLast ( ) ; Qi . add ( i ) ; } for ( int i = k ; i < n ; i ++ ) { System . out . print ( Integer . toString ( arr [ Qi . get ( 0 ) ] ) + " ▁ " ) ; while ( Qi . size ( ) > 0 && Qi . get ( 0 ) <= i - k ) Qi . removeFirst ( ) ; while ( Qi . size ( ) > 0 && arr [ i ] >= arr [ Qi . size ( ) - 1 ] ) Qi . removeFirst ( ) ; Qi . add ( i ) ; } System . out . println ( Integer . toString ( arr [ Qi . get ( 0 ) ] ) ) ; if ( Class . isPrimitive ( ) ) { int [ ] arr = { 12 , 1 , 78 , 90 , 57 , 89 , 56 } ; int k = 3 ; printMax ( arr , arr . length , k ) ; } }
static int russianPeasant ( int a , int b ) { int res = 0 ; while ( ( b > 0 ) != 0 ) { if ( ( b & 1 ) != 0 ) res = res + a ; a = a << 1 ; b = b > > 1 ; } return res ; }
static boolean isValid ( String string , int length ) { for ( int i = 1 ; i < length ; i ++ ) { if ( string . charAt ( i ) == string . charAt ( i - 1 ) ) { return false ; } } return true ; }
static int lehmann ( int n , int t ) { final int a = Math . random ( 2 ) ; final int e = ( n - 1 ) / 2 ; while ( ( t > 0 ) && ( n > t ) ) { final int result = ( ( ( int ) ( a * e ) ) % n ) ; if ( ( ( result % n ) == 1 ) || ( ( result % n ) == ( n - 1 ) ) ) { a = Math . random ( 2 ) ; t -- ; } else { return - 1 ; } } return 1 ; }
public static void main ( String input ) { for ( ; ; ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; int i = 0 ; while ( true ) { if ( a <= 0 || b <= 0 ) { break ; } if ( a > b ) { i += a / b ; a -= a / b * b ; } else { i += b / a ; b -= b / a * a ; } } System . out . println ( i ) ; } }
public static String input ( ) { int k = Integer . parseInt ( input ( ) ) ; return s == null ? " impossible " : s . substring ( 0 , k - s . length ( ) ) ; }
static int MaxTraceSub ( int [ ] [ ] mat ) { int maxTrace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i ; int s = j ; int trace = 0 ; while ( ( r < N ) && ( s < N ) ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; maxTrace = Math . max ( trace , maxTrace ) ; } } } if ( className . equals ( " org . apache . commons . math . analysis . MaxTraceSub " ) ) { int [ ] [ ] mat = { { 10 , 2 , 5 } , { 6 , 10 , 4 } , { 2 , 7 , -10 } } } ; System . out . println ( MaxTraceSub ( mat ) ) ; return maxTrace ; }
public static void go ( ) { try { double xa1 , ya1 , xa2 , ya2 , xb1 , yb1 , xb2 , yb2 ; xa1 = Double . parseDouble ( input . readLine ( ) ) ; ya1 = Double . parseDouble ( input . readLine ( ) ) ; xa2 = Double . parseDouble ( input . readLine ( ) ) ; ya2 = Double . parseDouble ( input . readLine ( ) ) ; xb1 = Double . parseDouble ( input . readLine ( ) ) ; yb1 = Double . parseDouble ( input . readLine ( ) ) ; xb2 = Double . parseDouble ( input . readLine ( ) ) ; yb2 = Double . parseDouble ( input . readLine ( ) ) ; if ( xb2 < xa1 || xb1 > xa2 || yb2 < ya1 || yb1 > ya2 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
public static int [ ] convertToBinary ( int n ) { int [ ] listy = new int [ 31 ] ; while ( n > 0 ) { listy [ 0 ] = n % 2 ; n /= 2 ; } for ( int i = 0 ; i < 31 - listy . length ; i ++ ) { listy [ i ] = 0 ; } /* ▁ main ▁ program ▁ */ int [ ] testCases = new int [ Integer . parseInt ( input ) ] ; for ( int i = 0 ; i < testCases . length ; i ++ ) { int testCase = testCases [ i ] ; n = Integer . parseInt ( input ) ; int [ ] a = new int [ 31 ] ; for ( int u : input . split ( " \\s + " ) ) { a [ u ] = Integer . parseInt ( input ) ; } int [ ] realCounter = new int [ 31 ] ; for ( int j = 0 ; j < 31 ; j ++ ) { realCounter [ j ] = 0 ; } for ( int i = 0 ; i < a . length ; i ++ ) { int [ ] x = convertToBinary ( a [ i ] ) ; for ( int j = 0 ; j < realCounter . length ; j ++ ) { realCounter [ j ] += x [ j ] ; } } int [ ] collector = new int [ n + 1 ] ; for ( int j = 0 ; j < collector . length ; j ++ ) { if ( collector [ j ] > 0 ) { collector [ j ] ++ ; } } ArrayList < Integer > realCollector = new ArrayList < Integer > ( ) ; for ( int j = 0 ; j < collector . length ; j ++ ) { if ( collector [ j ] > 0 ) { realCollector . add ( j ) ; } } int [ ] finalAnswer = new int [ 1 ] ; if ( Arrays . binarySearch ( realCollector , 0 ) == 0 ) { System . out . println ( Arrays . toString ( finalAnswer ) ) ; } else { int minCollector = Collections . min ( realCollector ) ; realCollector = realCounter ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i > minCollector ) { break ; } else { boolean isGood = true ; for ( int j = 0 ; j < realCollector . length ; j ++ ) { if ( realCollector [ j ] % i != 0 ) { isGood = false ; break ; }
public static int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; i ++ ) { int divCount = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { if ( ( i % j ) == 0 ) { divCount ++ ; } } if ( ( divCount % 2 ) != 0 ) { res ++ ; } } if ( getClass ( ) . getName ( ) . equals ( " java . lang . Integer " ) ) { a = 1 ; b = 10 ; System . out . println ( OddDivCount ( a , b ) ) ; } return res ; }
static final int [ ] getStdOut ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } int [ ] li = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { li [ i ] = Math . ceil ( arr [ i ] / m ) ; } int maxi = Collections . max ( li ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( maxi == li [ i ] ) { System . out . println ( i + 1 ) ; break ; } } return li ; }
static void printArray ( int N , int [ ] arr ) { for ( int i = 0 ; i <= N ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; /* ▁ replacedArray ▁ */ int posSum = 0 ; int negSum = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int diff = Math . abs ( posSum ) - Math . abs ( negSum ) ; if ( ( diff > 0 ) ) posSum = posSum + arr [ i ] ; else negSum = negSum + arr [ i ] ; } }
static void printArray ( int N , int [ ] arr ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . print ( " \n " ) ; /* ▁ replacedArray ▁ */ for ( int i = 0 ; i < N ; i ++ ) { int posSum = 0 ; int negSum = 0 ; for ( int j = i + 1 ; j < N ; j += 1 ) { if ( ( arr [ j ] > 0 ) && ( arr [ j ] < 0 ) ) { posSum += arr [ j ] ; } else { negSum += arr [ j ] ; } } int diff = Math . abs ( posSum ) - Math . abs ( negSum ) ; arr [ i ] = Math . abs ( diff ) ; } if ( getClass ( ) . equals ( " java . lang . Integer " ) ) { N = 5 ; arr = new int [ N ] ; arr [ 0 ] = 1 ; arr [ 1 ] = - 1 ; arr [ 2 ] = 2 ; arr [ 3 ] = 3 ; arr [ 4 ] = - 2 ; arr [ 5 ] = 1 ; arr [ 6 ] = - 2 ; arr [ 7 ] = - 3 ; arr [ 8 ] = - 4 ; arr [ 9 ] = - 2 ; arr [ 10 ] = 5 ; arr [ 11 ] = 1 ; arr [ 12 ] = - 2 ; arr [ 13 ] = - 2 ; arr [ 14 ] = - 2 ; arr [ 15 ] = - 2 ; arr [ 16 ] = - 2 ; arr [ 17 ] = - 2 ; arr [ 18 ] = - 2 ; arr [ 19 ] = - 2 ; arr [ 19 ] = - 2 ; arr [ 20 ] = - 2 ; arr [ 21 ] = - 2 ; arr [ 21 ] = - 2 ; arr [ 22 ] = - 2 ; arr [ 23 ] = - 2 ; arr [ 22 ] = - 2 ; arr [ 23 ] = - 2 ; arr [ 23 ] = - 2 ; arr [ 23 ] = - 2 ; arr [ 24 ] = - 2 ; arr [ 23 ] = - 2 ; arr [ 24 ] = - 2 ; arr [ 26 ] = - 2 ; arr [ 26 ] = - 2 ; arr [ 26 ] = - 2 ; arr [ 26 ] = - 2 ; arr [ 27 ] = - 1
static int countDivisbleby4 ( String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( s . charAt ( i ) == '4' ) || ( s . charAt ( i ) == '8' ) || ( s . charAt ( i ) == '0' ) ) { count ++ ; } } for ( int i = 0 ; i < n - 1 ; i += 1 ) { int h = ( ( s . charAt ( i ) - '0' ) * 10 + ( ( s . charAt ( i + 1 ) - '0' ) ) ) ; if ( ( h % 4 == 0 ) && ( h % 4 == 0 ) ) { count = count + i + 1 ; } } return count ; }
public static String print ( int t = Integer . parseInt ( input ) ) { for ( int i = 0 ; i < t ; i ++ ) { int [ ] s = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; String res = max ( s , 0 , 2 ) + max ( s , 2 ) == Integer . valueOf ( s . length ) ? " YES " : " NO " ; System . out . println ( res ) ; } return " " ; }
static List < Integer > l = new ArrayList < Integer > ( ) { private final long limit = 10000000000 ; private void gen ( int number , int four , int seven ) { if ( ( number > limit ) && ( four == seven ) ) { l . add ( number ) ; } gen ( number * 10 + 4 , four + 1 , seven ) ; gen ( number * 10 + 7 , four , seven + 1 ) ; } public void main ( ) { gen ( 0 , 0 , 0 ) ; } }
public static void print ( int t = Integer . parseInt ( input ) ) { for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( input . readLine ( ) ) ; int k = Integer . parseInt ( input . readLine ( ) ) ; int [ ] a = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { a [ j ] = Integer . parseInt ( input . readLine ( ) ) ; } boolean has = false ; boolean prop = n == 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] == k ) has = true ; if ( a [ j ] >= k && j > 0 ) { if ( a [ j - 1 ] >= k ) prop = true ; if ( j > 1 && a [ j - 2 ] >= k ) prop = true ; } } System . out . println ( has && prop ? " yes " : " no " ) ; } }
public static int T = Integer . parseInt ( input ) { for ( int C = 1 ; C <= T ; C ++ ) { String D = input . next ( ) ; String I = input . next ( ) ; String M = input . next ( ) ; String N = input . next ( ) ; int [ ] x = input . split ( " \\s + " ) ; int [ ] r = new int [ 256 ] ; for ( int i = 0 ; i < x . length ; i ++ ) { int [ ] nr = new int [ 256 ] ; for ( int q = 0 ; q < x . length ; q ++ ) { nr [ i ] = Integer . parseInt ( x [ i ] ) + D ; q = Integer . parseInt ( x [ q ] ) ; if ( M == 0 ) { for ( int i = 0 ; i < 256 ; i ++ ) { nr [ i ] = Math . min ( nr [ i ] , r [ i ] + Math . abs ( q - i ) ) ; } } else { for ( int i = 0 ; i < 256 ; i ++ ) { for ( int j = 0 ; j < 256 ; j ++ ) { nr [ j ] = Math . min ( nr [ j ] , r [ i ] + Math . abs ( q - j ) + ( Math . max ( 0 , Math . abs ( i - j ) - 1 ) / M ) * I ) ; } } } } r = nr ; } System . out . println ( String . format ( " Case ▁ # % d : ▁ % s " , C , min ( r ) ) ) ; } return T ; }
public static void countIsland ( int [ ] [ ] ban ) { /* ▁ Remove ▁ the ▁ first ▁ 12 ▁ */ if ( 0 <= ban [ 0 ] . length && ban [ 0 ] [ ban . length - 1 ] == 1 ) { ban [ 0 ] [ ban . length - 1 ] = 0 ; for ( int dx = - 1 , dy = 0 ; dx < 12 ; dx ++ , dy ++ ) { ban [ 0 ] [ ban . length - 1 ] = 1 ; } } int count = 0 ; for ( int y = 0 ; y < 12 ; y ++ ) { for ( int x = 0 ; x < 12 ; x ++ ) { if ( ban [ y ] [ ban . length - 1 ] == 1 ) { count ++ ; } } } }
static boolean arraySortedOrNot ( int [ ] arr , int n ) { if ( ( n == 0 ) || ( n == 1 ) ) return true ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] > arr [ i ] ) && ( arr [ i ] > arr [ i ] ) ) return false ; } return true ; int [ ] arr = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = arr . length ; if ( ( arraySortedOrNot ( arr , n ) ) && ( n > 0 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; return false ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] arr = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = Integer . parseInt ( input ) ; } int k = Collections . min ( arr ) ; if ( n == 1 ) { System . out . println ( 0 ) ; } else { int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { res += ( arr [ i ] - k ) ; } System . out . println ( res ) ; } }
static int printKDistinct ( int [ ] arr , int size , int KthIndex ) { HashMap < Integer , Integer > dict = new HashMap < Integer , Integer > ( ) ; int [ ] vect = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( dict . containsKey ( arr [ i ] ) ) && ( dict . get ( arr [ i ] ) > 1 ) ) { dict . put ( arr [ i ] , dict . get ( arr [ i ] ) + 1 ) ; } else { dict . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < size ; i ++ ) { if ( dict . containsKey ( arr [ i ] ) ) { dict . put ( arr [ i ] , dict . get ( arr [ i ] ) + 1 ) ; } } return - 1 ; }
public static int fib ( int [ ] f , int n ) { f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 ; } return f [ n ] ; }
public static String ABC = FluentIterable < String > from ( input ) { if ( ABC . count ( 5 ) == 2 ) { System . out . println ( Arrays . stream ( ABC ) . filter ( x -> x . length ( ) == 17 ) . count ( ) == 17 ? " YES " : " NO " ) ; } else { System . out . println ( " NO " ) ; } return ABC ; }
private static int N = Integer . parseInt ( input ) { int Z = Integer . parseInt ( input . nextLine ( ) ) , W = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] A = new int [ N + 1 ] ; A [ 0 ] = W ; A [ 1 ] = W ; int [ ] X = new int [ N + 1 ] ; int [ ] Y = new int [ N + 1 ] ; for ( int i = N ; i > 0 ; i -- ) { X [ i ] = max ( Math . abs ( A [ i - 1 ] - A [ N ] ) , Y [ i ] ) ; Y [ i ] = min ( Math . abs ( A [ i - 1 ] - A [ N ] ) , X [ j ] ) ; } System . out . println ( X [ 1 ] ) ; return Z ; }
static void countEleLessThanOrEqual ( int [ ] arr1 , int [ ] arr2 , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr2 [ j ] <= arr1 [ i ] ) ) count ++ ; } System . out . print ( count + " ▁ " ) ; } }
public static final int getInt ( ) { final int k = Integer . parseInt ( input . nextLine ( ) ) ; final int [ ] arr = new int [ 3 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } switch ( k ) { case 1 : System . out . println ( min ( arr ) ) ; break ; case 2 : System . out . println ( max ( arr [ 0 ] , arr [ arr . length - 1 ] ) ) ; break ; default : System . out . println ( max ( arr ) ) ; break ; } return arr [ 0 ] ; }
public static String [ ] getStrings ( ) { String [ ] A = input . split ( " ▁ " ) ; System . out . println ( ( String [ ] ) A ) ; int S = Integer . parseInt ( input . split ( " ▁ " ) [ 0 ] ) ; for ( ; S -- > 0 ; ) { String B = input . split ( " ▁ " ) [ 0 ] ; String C = input . split ( " ▁ " ) [ 1 ] ; A [ A . indexOf ( B ) ] = C ; System . out . println ( ( String [ ] ) A ) ; } return A ; }
static final String getSortString ( ) { final Scanner scanner = new Scanner ( System . in ) ; return scanner . nextLine ( ) ; }
static final int [ ] getDigits ( ) { int k = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int p = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; int ans = 0 ; int ans2 = 0 ; int i = 1 ; while ( ans2 < k ) { String s = Integer . toString ( i ) ; ans += Integer . parseInt ( s + s . substring ( 0 , s . length ( ) - 1 ) ) ; ans2 ++ ; i ++ ; } System . out . println ( ans % p ) ; }
public static void main ( String input ) { int N = Integer . parseInt ( input ) ; List < Integer > A = Lists . newArrayList ( ) ; for ( int i = 0 ; i < N ; i ++ ) { A . add ( Integer . parseInt ( input ) ) ; } Map < Integer , Integer > aToI = new HashMap < > ( ) ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) { aToI . put ( A . get ( i ) , i ) ; } int [ ] L = new int [ N + 2 ] ; int [ ] R = new int [ N + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { L [ i ] = i - 1 ; } int ans = 0 ; for ( int a = N ; a > 0 ; a -- ) { int i = aToI . get ( a ) ; ans += a * ( R [ i ] - i ) * ( i - L [ i ] ) ; L [ R [ i ] ] = L [ i ] ; R [ L [ i ] ] = R [ i ] ; } System . out . println ( ans ) ; }
public static int lps ( String str ) { int n = str . length ( ) ; int [ ] [ ] L = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { L [ i ] [ i ] = 1 ; } for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) { L [ i ] [ j ] = 2 ; } else if ( str . charAt ( i ) == str . charAt ( j ) ) { L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; } else { L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } } return L [ 0 ] [ n - 1 ] ; }
static void printConsecutive ( int last , int first ) { System . out . print ( first ) ; first ++ ; for ( int x = first ; x <= last ; x ++ ) { System . out . print ( " ▁ + " + x ) ; } /* ▁ find ▁ the ▁ largest ▁ number ▁ of ▁ consecutive ▁ integers ▁ */ for ( ; last <= first ; last ++ ) { for ( int x = 0 ; x <= first ; x ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { System . out . print ( x ) ; return ; } } } }
public static String print ( String input ) { int a = Integer . parseInt ( input . split ( " ▁ " ) [ 0 ] ) ; int b = Integer . parseInt ( input . split ( " ▁ " ) [ 1 ] ) ; String ans = " YES " ; if ( Math . abs ( a - b ) > 1 || a + b == 0 ) { ans = " NO " ; } return ans ; }
private static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) { return 0 ; } if ( ( a == b ) ) { return a ; } if ( ( a > b ) && ( b > a ) ) { return gcd ( a - b , b ) ; } return gcd ( a , b - a ) ; }
static boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; char [ ] c = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s . charAt ( i ) ; } Arrays . sort ( c , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( c [ i ] != s . charAt ( i ) ) && ( c [ i ] != s . charAt ( i ) ) ) { return false ; } } return true ; }
static void printMax ( int [ ] arr , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { max = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] > max ) { max = arr [ i + j ] ; } } System . out . print ( Integer . toString ( max ) + " ▁ " ) ; } if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { int [ ] array = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; n = array . length ; k = 3 ; printMax ( array , n , k ) ; } }
static final long mod = 1000000007 ; final long eps = 10 * - 9 ; { final Scanner input = new Scanner ( System . in ) ; final int N = Integer . parseInt ( input . nextLine ( ) ) ; final int M = Integer . parseInt ( input . nextLine ( ) ) ; final int [ ] [ ] adj = new int [ N + 1 ] [ M + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) adj [ i ] = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) adj [ i ] [ 0 ] = i ; for ( int i = 0 ; i < M ; i ++ ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; adj [ a ] [ b ] = i ; adj [ b ] [ a ] = i ; } final int [ ] seen = new int [ N + 1 ] ; int single = 0 ; int bipartite = 0 ; int not_bipartite = 0 ; for ( int v0 = 1 ; v0 <= N ; v0 ++ ) { if ( seen [ v0 ] != 0 ) continue ; boolean flg = true ; Queue < Integer > que = new LinkedList < Integer > ( ) ; que . add ( v0 ) ; seen [ v0 ] = 1 ; int cnt = 0 ; while ( que . size ( ) > 0 ) { int v = que . poll ( ) ; cnt ++ ; for ( int u : adj [ v ] ) { if ( seen [ u ] == 0 ) { seen [ u ] = - seen [ v ] ; que . add ( u ) ; } else { if ( seen [ u ] == seen [ v ] ) flg = false ; } } } if ( cnt == 1 ) single ++ ; else { if ( flg ) bipartite ++ ; else not_bipartite ++ ; } } long ans = N * N - ( N - single ) * ( N - single ) ; ans += ( bipartite + not_bipartite ) * ( bipartite + not_bipartite ) ; ans += bipartite * bipartite ; System . out . println ( ans ) ; }
public static int ss ( int a , int b ) { int min = Math . min ( a , b ) ; return a * ( a + 1 ) / 2 + ( b - a ) * a ; }
@ VisibleForTesting static Iterable < Integer > combinations ( ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int K = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > [ ] P = new List [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { P [ i ] = new ArrayList < > ( ) ; } for ( int i = 0 ; i < N ; i ++ ) { P [ i ] . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } int ans = 10 * 18 * 5 ; for ( int x = 0 ; x < N ; x ++ ) { int u = Math . max ( P [ x ] . get ( 0 ) , P [ x ] . get ( 1 ) ) ; int d = Math . min ( P [ x ] . get ( 0 ) , P [ x ] . get ( 1 ) ) ; for ( int y = 0 ; y < N ; y ++ ) { int r = Math . max ( P [ y ] . get ( 0 ) , P [ y ] . get ( 1 ) ) ; int l = Math . min ( P [ y ] . get ( 1 ) , P [ y ] . get ( 1 ) ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( d <= P [ i ] . get ( 0 ) && P [ i ] . get ( 1 ) <= u && l <= P [ i ] . get ( 1 ) && P [ i ] . get ( 2 ) <= r ) { count ++ ; } } if ( count >= K ) { ans = Math . min ( ans , ( u - d ) * ( r - l ) ) ; } } } System . out . println ( ans ) ; return P ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; List < Integer > l = new ArrayList < Integer > ( ) ; Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { l . add ( input ) ; map . put ( l . get ( i ) , i ) ; } List < Integer > z = new ArrayList < Integer > ( l ) ; for ( int i = m - 1 ; i >= 0 ; i -- ) { if ( i % 2 == 0 ) { Collections . sort ( z , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return o2 . compareTo ( o1 ) ; } } ) ; } else { Collections . sort ( z , Collections . reverseOrder ( ) ) ; } } for ( int i : l ) { System . out . print ( map . get ( i ) + 1 ) ; } }
public static List < String > preProcess ( List < String > substrings , String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String dup = " " ; for ( int j = i ; j < n ; j ++ ) { dup += s . charAt ( j ) ; substrings . add ( dup ) ; } } Collections . sort ( substrings ) ; return substrings ; }
{ return f [ 0 ] [ 1 ] ; } int [ ] [ ] f = { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; int [ ] [ ] b = { { 0 , - 1 } , { - 1 , 0 } , { 0 , 1 } , { 1 , 0 } } ; int r2 , c2 ; int w = 0 ; int h = 0 ; if ( w == 0 ) break ; r = 1 , c = 1 , d = 0 ; do { String buf = input . next ( ) ; if ( buf . equals ( " STOP " ) ) break ; else if ( buf . equals ( " RIGHT " ) ) d = ( d + 1 ) % 4 ; else if ( buf . equals ( " LEFT " ) ) d = ( d + 3 ) % 4 ; else { if ( buf . equals ( " FORWARD " ) ) r2 = r + Integer . parseInt ( buf ) * f [ d ] [ 1 ] ; c2 = c + Integer . parseInt ( buf ) * f [ d ] [ 0 ] ; } } while ( r < 1 ) ; if ( r2 > h ) r2 = h ; if ( c2 < 1 ) c2 = 1 ; if ( c2 > w ) c2 = w ; r = r2 ; c = c2 ; }
public static int n ( ) { String s = input ; int i = 0 ; int x = 0 ; int ans = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( s . charAt ( j ) == s . charAt ( i ) == ' x ' ) x ++ ; else { if ( x > 1 ) ans += x - 1 ; x = 0 ; } } return ans ; }
public static void print ( ) { String x = input . readLine ( ) ; if ( x . equals ( "0" ) ) { break ; } int a = 0 ; int b = 0 ; for ( int i = 1 ; i < x . length ( ) ; i ++ ) { if ( x . charAt ( i ) == ' A ' ) { a ++ ; } else { b ++ ; } } if ( a > b ) { a ++ ; } else { b ++ ; } System . out . println ( a + " ▁ " + b ) ; }
public static int fact ( int N ) { int product = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = product * i ; } return product ; /* ▁ NthTerm ▁ = ▁ ( N * N ) * fact ( N ) ; ▁ */ if ( getClass ( ) . getName ( ) . equals ( " java . lang . Integer " ) ) { N = 4 ; System . out . println ( nthTerm ( N ) ) ; } return 0 ; }
static int longestSubArray ( int arr [ ] , int n ) { boolean isZeroPresent = false ; for ( int i = 0 ; ( i <= n ) && ( arr [ i ] == 0 ) ; ) { isZeroPresent = true ; break ; } if ( isZeroPresent ) return n ; return 0 ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { int k = Integer . parseInt ( input ) ; int x = Integer . parseInt ( input ) ; System . out . println ( ( k - 1 ) * 9 + x ) ; } }
static void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; }
public static int NO_OF_CHARS = 256 ; int maxDistinctChar = 0 ; for ( int i = 0 ; i < n ; i ++ ) { count [ ( int ) str . charAt ( i ) ] ++ ; } int maxDistinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] != 0 ) && ( maxDistinctChar == ( i + 1 ) ) ) { maxDistinct ++ ; } } /* ▁ smallesteSubstrMaxDistictChar ▁ */ int n = str . length ( ) ; maxDistinct = maxDistinctChar ( str , n ) ; int minl = n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { String subs = str . substring ( i , j ) ; int subs_lenght = subs . length ( ) ; int subs_lenght = maxDistinctChar ( subs , subs_lenght ) ; int sub_distinct_char = maxDistinctChar ( subs , subs_lenght ) ; if ( ( subs_lenght < minl ) && ( maxDistinct == sub_distinct_char ) ) { minl = subs_lenght ; } } } if ( className . equals ( " org . apache . commons . lang3 . StringUtils . MaxDistinctChar " ) ) { String str = " AABBBCBB " ; int l = smallesteSubstr_maxDistictChar ( str ) ; System . out . println ( " The ▁ length ▁ of ▁ the ▁ smallest ▁ substring ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ characters ▁ : " + l ) ; } return l ; }
public static String f ( int n , String s1 , String s2 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 . charAt ( i ) != s2 . charAt ( i ) ) ) { if ( ( s1 . charAt ( i ) == ' R ' || s2 . charAt ( i ) == ' R ' ) ) { return " NO " ; } } } return " YES " ; } int t = Integer . parseInt ( input ( ) ) ; for ( int i = 0 ; i < t ; i ++ ) { n = Integer . parseInt ( input ( ) ) ; s1 = input ( ) ; s2 = input ( ) ; System . out . println ( f ( n , s1 , s2 ) ) ; }
static int findNumberOfEvenCells ( int n , int [ ] [ ] q , int size ) { int [ ] row = new int [ n ] ; int [ ] col = new int [ n ] ; for ( int i = 0 ; i < size ; i ++ ) { int x = q [ i ] [ 0 ] ; int y = q [ i ] [ 1 ] ; row [ x - 1 ] ++ ; col [ y - 1 ] ++ ; } int r1 = 0 ; int r2 = 0 ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( row [ i ] % 2 ) == 0 ) { r1 ++ ; } if ( ( row [ i ] % 2 ) == 1 ) { r2 ++ ; } if ( ( col [ i ] % 2 ) == 0 ) { c1 ++ ; } if ( ( col [ i ] % 2 ) == 1 ) { c2 ++ ; } } int count = r1 * c1 + r2 * c2 ; return count ; }
static void checkType ( int [ ] arr , int n ) { if ( ( arr [ 0 ] <= arr [ 1 ] ) && ( arr [ n - 2 ] <= arr [ n - 1 ] ) ) { System . out . println ( " Increasing " ) ; } else if ( ( arr [ 0 ] >= arr [ 1 ] ) && ( arr [ n - 2 ] >= arr [ n - 1 ] ) ) { System . out . println ( " Decreasing " ) ; } else if ( ( arr [ 0 ] <= arr [ 1 ] ) && ( arr [ n - 2 ] >= arr [ n - 1 ] ) ) { System . out . println ( " Increasing ▁ then ▁ decreasing " ) ; } else { System . out . println ( " Decreasing ▁ then ▁ increasing " ) ; } if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { int [ ] array = { 1 , 2 , 3 , 4 } ; int n = array . length ; checkType ( array , n ) ; } }
public static void for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; String s = input . nextLine ( ) ; System . out . println ( n / 2 - Math . max ( s . indexOf ( '10' ) , s . indexOf ( '01' ) ) ) ; }
@ VisibleForTesting static String fractions ( ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; int c = Integer . parseInt ( input . nextLine ( ) ) ; int d = Integer . parseInt ( input . nextLine ( ) ) ; int p ; if ( c > a || d > b ) { if ( c > a && d > b ) p = Math . min ( b / d , c ) ; else if ( c > a ) p = Math . min ( a / c , b ) ; else p = Math . min ( b / d , c ) ; } else p = Math . min ( b , c ) ; c *= p ; d *= p ; c *= p ; d *= p ; c *= p ; c *= p ; d *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p ; c *= p *= p ; c *= p ; c *= p ; c *= p ; c *= p ;
static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) { return 1 ; } else { return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) ; } }
public static void rearrange ( int arr [ ] , int n ) { int j = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] < 0 ) && ( arr [ j ] > 0 ) ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; } } }
public static int centeredSquareNum ( int n ) { return n * n + ( ( n - 1 ) * ( n - 1 ) ) ; }
public static void main ( String input ) { int t = Integer . parseInt ( input ) ; for ( int test = 0 ; test < t ; test ++ ) { int n = Integer . parseInt ( input ) ; int k = Integer . parseInt ( input ) ; if ( k == 1 ) { if ( n % 2 == 1 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { if ( n <= k ) { System . out . println ( " NO " ) ; } else { if ( n % 2 == 0 && k % 2 == 1 ) { System . out . println ( " NO " ) ; } else if ( n % 2 == 1 && k % 2 == 0 ) { System . out . println ( " NO " ) ; } else { int x = 2 * k - 1 ; int minSum = ( ( 1 + x ) * x ) / 4 ; if ( minSum > n ) { System . out . println ( " NO " ) ; } else if ( minSum == n ) { System . out . println ( " YES " ) ; } else { if ( ( n - minSum ) % 2 == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } } } } }
public static void main ( ) { n = Integer . parseInt ( input ( ) ) / 2 ; s = new ArrayList ( map . get ( Integer . parseInt ( input ( ) ) ) ) ; System . out . println ( sum ( s . subList ( 0 , n ) ) * 2 + sum ( s . subList ( n , s . size ( ) ) ) * 2 ) ; }
static int maxSubArraySum ( int [ ] arr , int size ) { int maxSoFar = arr [ 0 ] ; int currMax = arr [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { currMax = Math . max ( arr [ i ] , currMax + arr [ i ] ) ; maxSoFar = Math . max ( maxSoFar , currMax ) ; } return maxSoFar ; /* ▁ lenOfLongSubarrWithGivenSum ▁ */ Map < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int Sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum += arr [ i ] ; if ( ( Sum == k ) && ( maxLen < ( i - um . get ( Sum - k ) ) ) ) { maxLen = i - um . get ( Sum - k ) ; } } return maxLen ; }
static final boolean check ( int x ) { final String s = Integer . toString ( x ) ; int prev = Character . MIN_VALUE ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( Character . getNumericValue ( s . charAt ( i ) ) != prev + 1 ) { return false ; } prev = Character . MIN_VALUE ; } return true ; }
public static int find ( int dividend , int divisor , int start , int end ) { if ( ( start > end ) && ( dividend < 0 ) ) { return ( 0 ) ; } int mid = start + ( end - start ) / 2 ; int n = dividend - divisor * mid ; if ( ( n > divisor ) && ( n < 0 ) ) { start = mid + 1 ; } else if ( ( n < 0 ) && ( n == divisor ) ) { end = mid - 1 ; } else { if ( ( n == divisor ) && ( n == 0 ) ) { mid ++ ; n = 0 ; } return ( mid ) ; } return find ( dividend , divisor , start , end ) ; }
public static void print ( int n ) { int [ ] cities = new int [ n ] ; for ( int i = 0 ; i < cities . length ; i ++ ) { cities [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } for ( int i = 0 ; i < cities . length ; i ++ ) { if ( i == 0 ) { System . out . println ( Math . abs ( cities [ 0 ] - cities [ 1 ] ) + " ▁ " + Math . abs ( cities [ 0 ] - cities [ cities . length - 1 ] ) ) ; } else if ( i == cities . length - 1 ) { System . out . println ( Math . abs ( cities [ cities . length - 1 ] - cities [ i - 1 ] ) + " ▁ " + Math . abs ( cities [ 0 ] - cities [ cities . length - 1 ] ) ) ; } else { int mn = Math . min ( Math . abs ( cities [ i ] - cities [ i - 1 ] ) , Math . abs ( cities [ i ] - cities [ i + 1 ] ) ) ; int mx = Math . max ( Math . abs ( cities [ i ] - cities [ 0 ] ) , Math . abs ( cities [ i ] - cities [ i - 1 ] ) ) ; System . out . println ( mn + " ▁ " + mx ) ; } } }
private static void solve ( ) { int n = Integer . parseInt ( input . readLine ( ) ) , i = Integer . parseInt ( input . readLine ( ) ) ; Set < Integer > ns = new TreeSet < > ( ) ; for ( i = 0 ; i < n ; ++ i ) ns . add ( i ) ; int k = 1 << ( i * 8 / n ) ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < lis . length - k ; ++ i ) lis [ i ] = n ; }
static void towerOfHanoi ( int n , int from , int to , int [ ] auxRod1 , int [ ] auxRod2 ) { if ( ( n == 0 ) || ( n == 1 ) ) { return ; } if ( ( n == 1 ) || ( n == 2 ) ) { System . out . println ( " Move ▁ disk " + n + " ▁ from ▁ rod " + from + " ▁ to ▁ rod " + to ) ; return ; } towerOfHanoi ( n - 2 , from , auxRod1 , auxRod2 , auxRod2 ) ; }
static final String getStream ( ) { return " I ▁ " + System . getProperty ( " line . separator " ) + " ▁ " + System . getProperty ( " line . separator " ) + " ▁ " + System . getProperty ( " line . separator " ) ; }
private static HashMap < String , Integer > M = new HashMap < String , Integer > ( ) { } ; for ( int i = 0 ; i < Integer . parseInt ( input . nextLine ( ) ) ; i ++ ) { String [ ] query = input . nextLine ( ) . split ( " ▁ " ) ; if ( query [ 0 ] . equals ( "0" ) ) M . put ( query [ 1 ] , query [ 2 ] ) ; else if ( query [ 0 ] . equals ( "1" ) ) { if ( M . containsKey ( query [ 1 ] ) ) System . out . println ( M . get ( query [ 1 ] ) ) ; else System . out . println ( 0 ) ; } else M . put ( query [ 1 ] , 0 ) ; }
static int minSum ( int [ ] arr , int n ) { int sum = arr [ 0 ] ; int prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
static int findN ( int k ) { int ans ; if ( ( k == 0 ) && ( k == 3 ) ) { ans = 3 ; } if ( ( k == 1 ) && ( k == 4 ) ) { ans = 1 ; } else if ( ( k % 4 == 0 ) && ( k == 4 ) ) { ans = k ; } else if ( ( k % 4 == 3 ) && ( k == 4 ) ) { ans = k - 1 ; } else { ans = - 1 ; } return ans ; }
@ VisibleForTesting static int subsetXOR ( int [ ] arr , int n , int K ) { int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] > maxEle ) && ( arr [ i ] > maxEle ) ) maxEle = arr [ i ] ; } int m = ( 1 << ( int ) ( log2 ( maxEle ) + 1 ) ) - 1 ; int [ ] [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { for ( int k = 0 ; k < n + 1 ; k ++ ) { dp [ i ] [ j ] [ k ] = 0 ; } } } for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { for ( int k = 0 ; k < n + 1 ; k ++ ) { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; if ( ( k != 0 ) && ( arr [ i ] != 0 ) ) { dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] ; } } } } int ans = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { ans += dp [ n ] [ K ] [ i ] ; } return ans ; }
public static int D = Integer . parseInt ( input ) { int G = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] [ ] PC = new int [ D ] [ D ] ; for ( int i = 0 ; i < D ; i ++ ) { PC [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } int ans = 10 * 9 ; for ( int i = 0 ; i < 2 * D ; i ++ ) { int score = 0 ; int problem = 0 ; for ( int j = 0 ; j < D ; j ++ ) { if ( ( i > > j ) & 1 != 0 ) { score += 100 * ( j + 1 ) * PC [ j ] [ 0 ] + PC [ j ] [ 1 ] ; problem += PC [ j ] [ 0 ] ; } } if ( score > G ) continue ; int left = G - score ; for ( int j = 0 ; j < D ; j ++ ) { if ( ( i > > j ) & 1 != 0 ) continue ; if ( left > 100 * ( j + 1 ) * PC [ j ] [ 0 ] + PC [ j ] [ 1 ] ) { } else { int tmp = ( left + ( 100 * ( j + 1 ) ) - 1 ) / ( 100 * ( j + 1 ) ) ; ans = Math . min ( ans , problem + Math . min ( tmp , PC [ j ] [ 0 ] ) ) ; } } } System . out . println ( ans ) ; return ans ; }
public static void print ( int t = Integer . parseInt ( input ) ) { for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( input . readLine ( ) ) ; int m = Integer . parseInt ( input . readLine ( ) ) ; int [ ] a = Integer . parseInt ( input . readLine ( ) ) ; int s = 0 ; if ( Arrays . stream ( a ) . mapToInt ( s -> s == m ) . sum ( ) == m ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public static void print ( int n ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > l = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { l . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } int maxi = l . stream ( ) . mapToInt ( Integer :: max ) . max ( ) . orElse ( 0 ) ; int mini = l . stream ( ) . mapToInt ( Integer :: min ) . min ( ) . orElse ( 0 ) ; if ( n == 1 || l . size ( ) == l . stream ( ) . mapToInt ( Integer :: intValue ) . max ( ) . orElse ( 0 ) ) { System . out . println ( 0 ) ; } else { System . out . println ( l . size ( ) - maxi - mini ) ; } }
@ VisibleForTesting static int minAbsDiff ( int n ) { int left = Math . pow ( 2 , floor ( log2 ( n ) ) ) ; int right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; }
public static int LCIS ( int [ ] arr1 , int n , int [ ] arr2 , int m ) { int [ ] table = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { table [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( arr1 [ i ] == arr2 [ j ] ) && ( arr1 [ j ] == arr2 [ j ] ) ) { if ( ( current + 1 ) > table [ j ] ) { table [ j ] = current + 1 ; } } if ( ( arr1 [ i ] > arr2 [ j ] ) && ( arr1 [ j ] == arr2 [ j ] ) ) { if ( ( table [ j ] > current ) && ( table [ j ] > current ) ) { current = table [ j ] ; } } } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( ( table [ i ] > result ) && ( table [ i ] > result ) ) { result = table [ i ] ; } } return result ; }
static int countSetBits ( int n ) { int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { bitCount += countSetBitsUtil ( i ) ; } /* ▁ if ▁ ( ( x ▁ <= ▁ 0 ) ▁ | | ▁ ( x ▁ > = ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ > = ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ > = ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ | | ▁ ( x ▁ < ▁ 0 ) ▁ |
public static int partition ( int [ ] arr , int low , int high ) { int pivot = arr [ low ] ; int i = low - 1 ; int j = high + 1 ; int pi ; while ( ( pi = arr [ i ] ) != 0 ) { i ++ ; while ( ( arr [ i ] < pivot ) && ( arr [ i ] > pivot ) ) { i ++ ; } j -- ; while ( ( arr [ j ] > pivot ) && ( arr [ j ] > pivot ) ) { j -- ; } if ( ( i >= j ) && ( arr [ j ] < arr [ i ] ) ) return j ; } return 0 ; }
public static int partition ( int [ ] arr , int low , int high ) { int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j < high ; j ++ ) { if ( ( arr [ j ] <= pivot ) && ( arr [ j ] <= pivot ) ) { i ++ ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } } arr [ i + 1 ] = arr [ high ] ; return ( i + 1 ) ; }
static int maxSubArraySum ( int [ ] a , int size ) { int maxSoFar = - 10 * 9 ; int maxEndingHere = 0 ; for ( int i = 0 ; i < size ; i ++ ) { maxEndingHere = maxEndingHere + a [ i ] ; if ( ( maxSoFar < maxEndingHere ) && ( maxSoFar > maxEndingHere ) ) { maxSoFar = maxEndingHere ; } if ( ( maxEndingHere < 0 ) && ( maxSoFar > maxEndingHere ) ) { maxEndingHere = 0 ; } } /* ▁ min ▁ possible ▁ sum ▁ */ int mxSum = maxSubArraySum ( a , n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } sum = sum - mxSum + mxSum / x ; System . out . println ( Math . round ( sum ) ) ; if ( Class . isAnnotationPresent ( int [ ] . class ) ) { int N = 3 ; int X = 2 ; int [ ] A = { 1 , - 2 , 3 } ; minPossibleSum ( A , N , X ) ; } return maxSoFar ; }
public static int fun ( int [ ] p ) { return p . indexOf ( max ( p ) ) ; for ( ; ; ) { int n = Integer . parseInt ( input ( ) ) ; int len = Integer . parseInt ( input ( ) ) ; int [ ] [ ] l = new int [ n ] [ ] ; int var = p [ 0 ] ; int [ ] ans = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { l [ j ] [ 0 ] = p [ j ] ; } Arrays . sort ( l , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { int temp = ( ( Integer ) o1 ) . intValue ( ) ; return temp > 0 ? 1 : - 1 ; } } ) ; Arrays . sort ( l , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { int temp = ( ( Integer ) o2 ) . intValue ( ) ; return temp > 0 ? 1 : - 1 ; } } ) ; for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( l [ j + 1 ] [ 1 ] > l [ j ] [ 1 ] ) { temp = l [ j + 1 ] ; l [ j + 1 ] = l [ j ] ; l [ j ] = temp ; } else { ans [ j ] = p [ l [ j + 1 ] [ 1 ] ] ; } } for ( int j = 0 ; j < ans . length ; j ++ ) { System . out . print ( ( ( Integer ) ans [ j ] ) . intValue ( ) + " ▁ " ) ; } System . out . println ( ) ; } }
static void printArray ( int N , int SUM , int K ) { int minSum = ( N * ( N + 1 ) ) / 2 ; int maxSum = ( N * K ) - ( N * ( N - 1 ) ) / 2 ; if ( ( minSum > SUM ) || ( maxSum < SUM ) ) { System . out . println ( " Not ▁ Possible " ) ; return ; } int [ ] arr = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i += 1 ) { arr [ i ] = i ; } int sum = minSum ; int i = N ; while ( ( i >= 1 ) && ( sum < N ) ) { int x = sum + ( K - i ) ; if ( ( x < SUM ) && ( x > maxSum ) ) { sum = sum + ( K - i ) ; arr [ i ] = K ; K -- ; } else { arr [ i ] += ( SUM - sum ) ; sum = SUM ; break ; } i -- ; } for ( int i = 1 ; i <= N ; i += 1 ) { System . out . print ( ( int ) arr [ i ] + " ▁ " ) ; } }
COST = 3 ; { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = Math . min ( x , Math . min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
@ VisibleForTesting static int runTasks ( Queue < Integer > A , Queue < Integer > B ) { int totalTime = 0 ; Integer x ; Integer y ; while ( ( x = A . poll ( ) ) != null ) { y = B . poll ( ) ; if ( ( x == y ) && ( x == 1 ) ) { totalTime ++ ; } else { B . appendFirst ( y ) ; A . add ( x ) ; totalTime += 2 ; } } if ( Class . isAnonymousClass ( ) ) { A = new ArrayDeque < Integer > ( 3 ) ; A . add ( 2 ) ; A . add ( 1 ) ; A . add ( 4 ) ; B = new ArrayDeque < Integer > ( 4 ) ; B . add ( 1 ) ; B . add ( 3 ) ; B . add ( 2 ) ; System . out . println ( runTasks ( A , B ) ) ; } return totalTime ; }
public static void line ( float x0 , float y0 ) { float c = 2 * y0 * x0 ; System . out . println ( y0 + " x " + " ▁ + ▁ " + x0 + " y ▁ = ▁ " + c ) ; }
) public static void input ( ) { System . out . println ( len ( set ( map ( frozenset , input ( ) . split ( ) ) ) ) ) ; }
static final double EPS = 1e-9 ; double cross = 0 ; double dot = 0 ; double [ ] lines = new double [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { cross = ( a * b ) - a * b ; } double [ ] a = new double [ 4 ] ; double [ ] b = new double [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { a [ i ] = a [ i ] - p0 ; b [ i ] = p2 - p0 ; int flag ; if ( cross > EPS ) flag = 1 ; else if ( cross < - 1 * EPS ) flag = - 1 ; else if ( dot < - 1 * EPS ) flag = 2 ; else if ( abs ( a ) < abs ( b ) ) flag = - 2 ; else flag = 0 ; } /* ▁ check ▁ intersection ▁ */ boolean intersected = ( checkCCW ( p0 , p1 , p2 ) * checkCCW ( p0 , p1 , p3 ) <= 0 ) && ( checkCCW ( p2 , p3 , p0 ) * checkCCW ( p2 , p3 , p1 ) <= 0 ) ; /* ▁ solve ▁ */ for ( int i = 0 ; i < 3 ; i ++ ) { lines [ i ] = Integer . parseInt ( lines [ i ] ) ; int [ ] p0 = new int [ 2 ] ; int [ ] p1 = new int [ 2 ] ; int [ ] p2 = new int [ 2 ] ; int [ ] p3 = new int [ 2 ] ; for ( int j = 0 ; j < 2 ; j ++ ) { p1 [ j ] = Integer . parseInt ( lines [ i ] ) ; p2 [ j ] = Integer . parseInt ( lines [ i ] ) ; p3 [ j ] = Integer . parseInt ( lines [ i ] ) ; } boolean intersected = checkIntersection ( p0 , p1 , p2 , p3 ) ; if ( intersected ) System . out . println ( "1" ) ; else System . out . println ( "0" ) ; } /* ▁ if ▁ ( Class . isAnnotationPresent ( String . class ) ) ▁ { STRNEWLINE ▁ BufferedReader ▁ _input ▁ = ▁ new ▁ BufferedReader ( new ▁ InputStreamReader ( System . in ) ) ; STRNEWLINE ▁ String ▁ line ; STRNEWLINE ▁ String ▁ line ; STRNEWLINE ▁ line ; STRNEWLINE ▁ line ▁ = ▁ _input . readLine ( ) ; STRNEWLINE ▁ } */ solve ( lines ) ; return lNum ; }
static boolean isAnyNotPalindrome ( String s ) { Set < String > unique = new HashSet < String > ( ) ; for ( int i = 0 ; ( s != null ) && ( unique . size ( ) > 1 ) ; i ++ ) { unique . add ( s . charAt ( i ) ) ; } if ( ( unique . size ( ) > 1 ) && ( unique . contains ( s ) ) ) { return true ; } else { return false ; } String s ; if ( getClass ( ) . getName ( ) . equals ( " java . lang . String " ) ) { s = " aaaaab " ; if ( ( isAnyNotPalindrome ( s ) ) && ( s . length ( ) > 1 ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } return false ; }
static int findMajority ( int [ ] arr , int n ) { return arr [ ( int ) ( n / 2 ) ] ; }
public static String x = input ( ) { int x = input . nextInt ( ) ; int N = 0 , S = 0 ; int po = 0 ; String c = " YES " ; for ( int i = 0 ; i < x ; i ++ ) { String [ ] p = input . split ( " ▁ " ) ; if ( N == 0 && S == 0 ) { if ( p [ 1 ] != " South " ) { c = " NO " ; break ; } } if ( S - N == 20000 ) { if ( p [ 1 ] != " North " ) { c = " NO " ; break ; } } if ( p [ 1 ] == " North " ) { po = po - Integer . parseInt ( p [ 0 ] ) ; } } if ( N != S ) c = " NO " ; System . out . println ( c ) ; return c ; }
static int countSubArrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwiseOr = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwiseOr = bitwiseOr | arr [ k ] ; } if ( ( bitwiseOr >= K ) && ( bitwiseOr >= n ) ) { count ++ ; } } } if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays $ ArrayList " ) ) { int [ ] array = { 3 , 4 , 5 } ; n = arr . length ; int k = 6 ; System . out . println ( countSubArrays ( array , n , k ) ) ; } return count ; }
static boolean canBeEqual ( int a , int b , int c , int k ) { int [ ] arr = new int [ 3 ] ; Arrays . fill ( arr , 0 ) ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; Arrays . sort ( arr ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( ( k < 0 ) || ( k % 3 != 0 ) ) { return false ; } return true ; }
static void adjacency [ ] = new int [ 100 ] ; for ( int i = 0 ; i < adjacency . length ; i ++ ) { adjacency [ i ] = new int [ 100 ] ; } { insert ( x , y ) ; adjacency [ x ] [ y ] = i ; } { dfs ( node , leaf , vis ) ; leaf [ node ] = 0 ; vis [ node ] = 1 ; for ( int it : adjacency [ node ] ) { if ( ( vis [ it ] == false ) ) { dfs ( it , leaf , vis ) ; } } }
static final String description = " Input ▁ a ▁ string ▁ of ▁ integer ▁ s " ; int k = 0 ; for ( char c : input . toCharArray ( ) ) { if ( c != '1' ) break ; ++ k ; } if ( k >= 10 ) return " " ; int i = 10 ; int inf = 10 ; double eps = 1.0 / 10 ; int mod = 10 ; int [ ] dd = { ( - 1 ) , ( 0 ) , ( 1 ) , ( 1 ) , ( 0 ) , ( 0 ) , ( - 1 ) } ; int [ ] ddn = { ( - 1 ) , ( - 1 ) , ( 1 ) , ( 0 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 0 ) , ( 1 ) , ( 1 ) , ( - 1 ) , ( 0 ) , ( - 1 ) , ( - 1 ) } ; /* ▁ LI ▁ */ /* ▁ LI_ ▁ */ /* ▁ LI_ ▁ */ /* ▁ LF ▁ */ /* ▁ LS ▁ */ /* ▁ LS ▁ */ /* ▁ LS ▁ */ /* ▁ LS ▁ */ /* ▁ LS ▁ */ /* ▁ LS ▁ */ /* ▁ I ▁ */ /* ▁ LS ▁ */ /* ▁ LS ▁ */ /* ▁ LS ▁ */ /* ▁ LS ▁ */ /* ▁ LS ▁ */ /* ▁ LS ▁ */ /* ▁ LS ▁ */ /* ▁ s ▁ */ /* ▁ s ▁ */ ; /* ▁ s ▁ */ }
@ ClassRule public static TestRule getSolutionRule ( ) { return new TestRule ( ) { @ Override protected void evaluate ( ) { hpop ( ) ; hpush ( ) ; } @ Override protected void solution ( ) { String line = input . nextLine ( ) ; Map < Integer , Integer > boughtCount = new HashMap < > ( ) ; line = input . nextLine ( ) ; madeScout = new HashMap < > ( ) ; } } ; }
static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ ] [ ] [ ] L = new int [ o + 1 ] [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { for ( int k = 0 ; k < o + 1 ; k ++ ) { if ( ( i == 0 ) || ( j == 0 ) || ( k == 0 ) ) { L [ i ] [ j ] [ k ] = 0 ; } else if ( ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) && ( X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) ) { L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] + 1 ; } else { L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } } return L [ m ] [ n ] [ o ] ; }
public static void print ( int n ) { int [ ] r = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } int ans = Math . abs ( r [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { ans += Math . abs ( r [ i ] - r [ i - 1 ] ) ; } System . out . println ( ans ) ; }
static boolean isSpiltPossible ( int n , int [ ] a ) { int Sum = 0 ; int c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum += a [ i ] ; if ( ( a [ i ] == 1 ) && ( a [ i ] == 0 ) ) { c1 ++ ; } } if ( ( Sum % 2 ) != 0 ) { return false ; } if ( ( ( Sum / 2 ) % 2 ) == 0 ) { return true ; } if ( ( c1 > 0 ) && ( a [ c1 ] == 1 ) ) { return true ; } else { return false ; } n = 3 ; a = new int [ ] { 1 , 1 , 2 } ; if ( ( isSpiltPossible ( n , a ) ) && ( isSpiltPossible ( n , a ) ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } return false ; }
public static int [ ] getDigits ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > l = Arrays . asList ( input . nextLine ( ) . split ( " ▁ " ) ) ; int [ ] f = new int [ 4 ] ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) { if ( l . get ( i ) == 1 ) { f [ 0 ] ++ ; f [ 1 ] = Math . max ( f [ 0 ] , f [ 1 ] ) ; f [ 2 ] = Math . max ( f [ 2 ] + 1 , f [ 2 ] ) ; f [ 3 ] = Math . max ( f [ 3 ] + 1 , f [ 2 ] ) ; } } return f ; }
public static void countEvenOdd ( int min , int max , int [ ] [ ] steps ) { boolean beven = true ; boolean aeven = false ; int n = 2 ; for ( int i = 0 ; ( ! ( aeven || ( a & 1 ) != 0 ) ) { aeven = true ; } int even ; int odd ; if ( ( beven ) && ( ( b & 1 ) != 0 ) ) { beven = false ; } else if ( ( ! ( a & 1 ) != 0 ) ) { if ( ( ! ( b & 1 ) != 0 ) ) { beven = true ; } } else { if ( ( b & 1 ) != 0 ) { beven = true ; } } if ( ( beven ) && ( odd ) ) { even = ( max - min + 1 - ( max / 2 ) + ( int ) ( ( min - 1 ) / 2 ) ) ; } }
public static void main ( String vamshi , int z ) { map = Integer . parseInt ( input ( ) . split ( " ▁ " ) ) ; System . out . println ( ( vamshi // z + 1 ) * z ) ; }
static void printKPFNums ( int A , int B , int K ) { boolean [ ] prime = new boolean [ B + 1 ] ; int [ ] pFactors = new int [ B + 1 ] ; for ( int p = 2 ; p <= B ; p ++ ) { if ( ( pFactors [ p ] == 0 ) && ( prime [ p ] ) ) { for ( int i = p ; i <= B ; i += p ) { pFactors [ i ] = pFactors [ i ] + 1 ; } } } for ( int i = 0 ; i < A ; i ++ ) { } }
public static void reverserWords ( String string ) { LinkedList < String > st = new LinkedList < String > ( ) ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( string . charAt ( i ) != ' ▁ ' ) { st . add ( string . charAt ( i ) ) ; } else { while ( st . size ( ) > 0 ) { System . out . print ( st . get ( st . size ( ) - 1 ) + " ▁ " ) ; st . removeLast ( ) ; } System . out . print ( " ▁ " ) ; } } while ( st . size ( ) > 0 ) { System . out . print ( st . get ( st . size ( ) - 1 ) + " ▁ " ) ; st . removeLast ( ) ; } if ( className . equals ( " java . lang . String " ) ) { string = " Geeks ▁ for ▁ Geeks " ; reverserWords ( string ) ; } }
public static void input ( ) { int a = 0 ; int b = 0 ; for ( int i = 0 ; i < input . length ; i ++ ) { a += input . length > i ; b += input . length < i ; } System . out . println ( a == 0 ? - 1 : b / a + 1 ) ; }
public static void sieve ( ) { int n = input . nextInt ( ) ; int N = n + 2 ; int [ ] isPrime = new int [ N ] ; isPrime [ 0 ] = 0 ; isPrime [ 1 ] = 0 ; { int i = 2 ; while ( i * i <= N ) { if ( isPrime [ i ] == 0 ) { i ++ ; continue ; } int j = 2 * i ; while ( j < N ) { isPrime [ j ] = 0 ; j += i ; } i ++ ; } } sieve ( ) ; int c = 0 ; if ( ( n < 5 ) && ( isPrime [ n ] == 1 ) ) { c = 1 ; String s = "1 ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( ( i + 1 ) != 4 ) && ( isPrime [ i ] == 1 ) ) { s += "1 ▁ " ; } else { s += "2 ▁ " ; c ++ ; } } System . out . println ( c ) ; System . out . println ( s ) ; } else { System . out . println ( "2" ) ; String s = " " ; int i = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = i + 1 ; if ( ( isPrime [ k ] == 1 ) && ( isPrime [ k ] == 1 ) ) { s += "1 ▁ " ; } else { s += "2 ▁ " ; } } System . out . println ( s ) ; } }
@ GwtIncompatible ( " java . util . regex . Pattern " ) private static void roundWithPattern ( String input ) { final Scanner scanner = new Scanner ( input ) ; final List < Double > stack = new ArrayList < > ( ) ; while ( scanner . hasNextDouble ( ) ) { final String s = scanner . nextLine ( ) ; if ( s . matches ( " [ - + ] ? \\ d + " ) ) { stack . add ( Double . parseDouble ( s ) ) ; } else if ( s . equals ( " + " ) ) { final double n = stack . remove ( ) ; stack . add ( n ) ; } else if ( s . equals ( " - " ) ) { final double n = stack . remove ( ) ; stack . add ( n ) ; } else if ( s . equals ( " * " ) ) { final double n = stack . remove ( ) ; stack . add ( n ) ; } else if ( s . equals ( " / " ) ) { final double n = stack . remove ( ) ; stack . add ( n ) ; } } System . out . println ( stack . get ( stack . size ( ) - 1 ) + " ▁ " + stack . get ( stack . size ( ) - 1 ) ) ; }
@ Function public static Integer numIn ( ) { return Integer . parseInt ( input ( ) ) ; }
static void findNthTerm ( int n ) { if ( n % 2 == 0 ) { n /= 2 ; System . out . println ( 3 * ( n - 1 ) ) ; } else { n = ( n / 2 ) + 1 ; System . out . println ( 2 * ( n - 1 ) ) ; } if ( Class . isAnonymousClass ( ) ) { int N = 4 ; findNthTerm ( N ) ; N = 11 ; findNthTerm ( N ) ; } }
static int countNonIncreasing ( int arr [ ] , int n ) { long cnt = 0 ; long len = 1 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( ( arr [ i + 1 ] >= arr [ i ] ) ) { len ++ ; } else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( ( len > 1 ) && ( ( arr [ i ] >= arr [ i + 1 ] ) ) ) { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; } return ( int ) cnt ; }
public static int maximize ( int [ ] A1 , int [ ] A2 , int n , int x , int y ) { int [ ] c = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = 0 ; } int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = A2 [ i ] - A1 [ i ] ; Sum += A1 [ i ] ; } Arrays . sort ( c ) ; Arrays . sort ( c ) ; int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { maxi = c [ i ] ; } return maxi ; }
public static int t = Integer . parseInt ( input ) { int x ; for ( int i = 0 ; i < t ; i ++ ) { x = Integer . parseInt ( input . readLine ( ) ) ; if ( x / 1000 > 0 ) { System . out . println ( 10 * ( x % 10 - 1 ) + 10 ) ; } else if ( x / 100 > 0 ) { System . out . println ( 10 * ( x % 10 - 1 ) + 6 ) ; } else if ( x / 10 > 0 ) { System . out . println ( 10 * ( x % 10 - 1 ) + 3 ) ; } else { System . out . println ( 10 * ( x % 10 - 1 ) + 1 ) ; } } return x ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; double [ ] [ ] cost = new double [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ 0 ] = Double . MAX_VALUE ; int m = Integer . parseInt ( input ) ; for ( int i = 0 ; i < m ; i ++ ) { int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; int c = Integer . parseInt ( input ) ; int d = Integer . parseInt ( input ) ; cost [ a - 1 ] [ b - 1 ] = c ; cost [ b - 1 ] [ a - 1 ] = d ; } int s = Integer . parseInt ( input ) ; int g = Integer . parseInt ( input ) ; int V = Integer . parseInt ( input ) ; int P = Integer . parseInt ( input ) ; for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( cost [ i ] [ j ] > cost [ i ] [ k ] + cost [ k ] [ j ] ) { cost [ i ] [ j ] = cost [ i ] [ k ] + cost [ k ] [ j ] ; } } } } System . out . println ( V - P - cost [ s - 1 ] [ g - 1 ] - cost [ g - 1 ] [ s - 1 ] ) ; }
public static int r1 = Integer . parseInt ( input ) { int r1 = Integer . parseInt ( input . nextLine ( ) ) ; int r2 = Integer . parseInt ( input . nextLine ( ) ) ; int c1 = Integer . parseInt ( input . nextLine ( ) ) ; int c2 = Integer . parseInt ( input . nextLine ( ) ) ; int d1 = Integer . parseInt ( input . nextLine ( ) ) ; int d2 = Integer . parseInt ( input . nextLine ( ) ) ; int x = ( d1 + c1 - r2 ) / 2 ; int y = r1 - x ; int z = c1 - x ; int w = d1 - x ; if ( 1 <= x && x <= 9 && 1 <= y && 1 <= z && 1 <= w && set . contains ( x , y , z , w ) ) { System . out . println ( x + " ▁ " + y ) ; System . out . println ( z + " ▁ " + w ) ; } else { System . out . println ( - 1 ) ; } return x ; }
@ VisibleForTesting static void binarySearch ( ) { while ( true ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == m == 0 ) { break ; } List < Integer > a = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a . add ( i ) ; } List < Integer > w = Lists . newArrayList ( ) ; for ( int i = 0 ; i < m ; i ++ ) { w . add ( i ) ; } Set < Integer > set = new HashSet < Integer > ( ) ; { if ( i == m ) { set . add ( i ) ; return ; } go ( i + 1 , w ) ; go ( i + 1 , w . get ( i ) ) ; go ( i + 1 , w . get ( i ) ) ; go ( i + 1 , w . get ( i ) - w . get ( i ) ) ; } go ( 0 , 0 ) ; boolean ans = false ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { if ( ! set . contains ( a . get ( i ) ) ) { if ( ans == false ) { set = Sets . newTreeSet ( ) ; for ( int s : Set . values ( ) ) { if ( set . contains ( a . get ( i + s ) ) || set . contains ( a . get ( i - s ) ) ) { ans = true ; } } } } } if ( ans == false ) { System . out . println ( 0 ) ; continue ; } else if ( ans . size ( ) == 0 ) { System . out . println ( - 1 ) ; continue ; } else { System . out . println ( Math . min ( ans , a . size ( ) ) ) ; } } }
public static double min ( String input ) { int n = Integer . parseInt ( input ) ; Map < String , Double > m = new HashMap < String , Double > ( ) ; m . put ( " A " , Double . MAX_VALUE ) ; m . put ( " B " , Double . MAX_VALUE ) ; m . put ( " C " , Double . MAX_VALUE ) ; m . put ( " AB " , Double . MAX_VALUE ) ; m . put ( " AC " , Double . MAX_VALUE ) ; m . put ( " BC " , Double . MAX_VALUE ) ; m . put ( " ABC " , Double . MAX_VALUE ) ; for ( int i = 0 ; i < n ; i ++ ) { String in = input . trim ( ) ; String [ ] item = in . split ( " \\s + " ) ; String l = Arrays . toString ( item ) ; m . put ( l , Math . min ( m . get ( l ) , Integer . parseInt ( item [ 0 ] ) ) ) ; } double res = Double . MAX_VALUE ; res = Math . min ( res , m . get ( " A " ) + m . get ( " B " ) + m . get ( " C " ) ) ; res = Math . min ( res , m . get ( " AB " ) + m . get ( " C " ) ) ; res = Math . min ( res , m . get ( " AB " ) + m . get ( " BC " ) ) ; return res ; }
static boolean startsWith ( String str , String pre ) { int strLen = str . length ( ) ; int preLen = pre . length ( ) ; int i = 0 ; int j = 0 ; while ( ( i < strLen ) && ( j < preLen ) ) { if ( ( str . charAt ( i ) != pre . charAt ( j ) ) && ( str . charAt ( j ) != ' ▁ ' ) ) { return false ; } i ++ ; j ++ ; } return true ; /* ▁ endsWith ▁ starts ▁ with ▁ a ▁ string ▁ */ }
static void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( ( i % 3 != 0 ) && ( i % 3 != 0 ) ) { for ( int j = 1 ; j < n ; j ++ ) { if ( ( j % 3 != 0 ) && ( i + j + k ) == n ) { System . out . println ( i + j + k ) ; return ; } } } } }
static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { for ( int k = 0 ; k < n + 1 ; k ++ ) { if ( i + j + k == n ) { result ++ ; } } } } return result ; }
public static int digitSum ( int n ) { int sum = 0 ; while ( ( n > 0 ) && ( n < 10 ) ) { sum += n % TEN ; n /= TEN ; } return sum ; }
public static int power ( int x , int a ) { int res = 1 ; while ( ( a != 0 ) && ( res > 0 ) ) { if ( ( a & 1 ) != 0 ) { res = res * x ; } x = x * x ; a >>>= 1 ; } /* ▁ Break ▁ integer ▁ into ▁ the ▁ power ▁ */ if ( ( N == 2 ) && ( N == 3 ) ) { return 1 ; } if ( ( N == 3 ) && ( N == 2 ) ) { return 2 ; } int maxProduct = 0 ; switch ( N ) { default : return maxProduct ; } }
@ VisibleForTesting static final Iterable < Integer > input = new Iterable < Integer > ( ) { @ Override public String toString ( ) { return System . console ( ) . readLine ( ) . trim ( ) ; } @ Override public List < Integer > list2d ( int a , int b , int c ) { return Arrays . asList ( new Integer [ ] [ ] { c } , new Integer [ ] { b } ) ; } @ Override public List < Integer > list3d ( int a , int b , int c , int d ) { return Arrays . asList ( new Integer [ ] [ ] { d } , new Integer [ ] { c } ) ; } @ Override public List < Integer > list4d ( int a , int b , int c , int d , int e ) { return Arrays . asList ( new Integer [ ] [ ] { e } , new Integer [ ] { d } ) ; } @ Override public Integer ceil ( int x , int y ) { return Integer . valueOf ( - ( - x / y ) ) ; } @ Override public Integer INT ( ) { return Integer . valueOf ( input . nextInt ( ) ) ; } @ Override public Integer [ ] MAP ( ) { return map ( Integer . valueOf ( input . nextInt ( ) ) ) ; } @ Override public Integer [ ] LIST ( Integer N ) { return N == null ? Collections . < Integer > emptyList ( ) : MAP ( N ) ; } @ Override public Integer [ ] YES ( ) { System . out . println ( " Yes " ) ; } @ Override public Integer [ ] NO ( ) { System . out . println ( " No " ) ; } @ Override public Integer [ ] YES ( ) { System . out . println ( " YES " ) ; } @ Override public Integer [ ] NO ( ) { System . out . println ( " NO " ) ; } } ; System . setIn ( 10 ** 9 ) ; INF = Double . POSITIVE_INFINITY ; MOD = 10 ** 9 + 7 ; N = 1000001 ; int [ ] table = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; i ++ ) { if ( table [ i ] == i ) { for ( int j = i ; j <= N ; j += i ) { table [ j ] *= 1 - 1 / i ; } } table [ 0 ] = 1 ; Integer [ ] ans = list ( accumulate ( table ) ) ; for ( int i = 0 ; i < INT ;
public static String input ( ) { String s = input ( ) ; return "2018" + s . substring ( 4 ) ; }
@ WorkerThread public static void firstnonrepeating ( String Str ) { int i ; Queue < String > q = new Queue < String > ( ) ; int [ ] charCount = new int [ MAX_CHAR ] ; for ( i = 0 ; i < Str . length ( ) ; i ++ ) { q . add ( Str . charAt ( i ) ) ; charCount [ ( i - ' a ' ) ] ++ ; while ( ( ! q . isEmpty ( ) ) ) { if ( ( charCount [ ( q . queue . get ( ) ) - ' a ' ] ) > 1 ) { q . poll ( ) ; } else { System . out . print ( q . queue . get ( ) + " ▁ " ) ; break ; } } } System . out . println ( ) ; }
@ VisibleForTesting static void dfs ( String input ) { int n = Integer . parseInt ( input ) ; Map < Integer , Integer > graph = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int i = Integer . parseInt ( input ) ; int j = Integer . parseInt ( input ) ; graph . put ( i , j ) ; graph . get ( j ) . add ( i ) ; } int left = 0 ; int right = 0 ; Map < Integer , Integer > color = new HashMap < > ( ) ; Set < Integer > visited = new HashSet < > ( ) ; dfs ( node ) ; }
public static int solve ( int n , int m , int obstacles , double [ ] rangee ) { double val = Math . min ( n , m ) ; Arrays . sort ( rangee ) ; int c = 1 ; for ( int i = obstacles - 1 ; i >= 0 ; i -- ) { rangee [ i ] = 2 * rangee [ i ] ; val -= rangee [ i ] ; if ( ( val <= 0 ) && ( val > 0 ) ) { return c ; } else { c ++ ; } } if ( val > 0 ) { return - 1 ; } return 0 ; }
public static int input ( ) { String s = input ; int t = Integer . parseInt ( input ) ; int e1 = new Integer ( s ) ; int e2 = Integer . MIN_VALUE ; int i = 1 ; while ( i < s . length ( ) ) { int x = Integer . parseInt ( s . substring ( i + 1 ) ) ; if ( s . charAt ( i ) == ' + ' ) e2 += x ; else e2 *= x ; i += 2 ; } if ( e1 == t && e2 == t ) { System . out . println ( " U " ) ; } else if ( e1 == t ) { System . out . println ( " M " ) ; } else if ( e2 == t ) { System . out . println ( " L " ) ; } else { System . out . println ( " I " ) ; } return e2 ; }
public static void minStack ( ) { Stack < Integer > stack = new Stack < Integer > ( ) ; Stack < Integer > minStack = new Stack < Integer > ( ) ; new Thread ( ) { public void run ( ) { stack . push ( 0 ) ; if ( minStack . size ( ) == 0 ) { minStack . push ( 0 ) ; return ; } if ( 0 <= minStack . peek ( ) ) { minStack . push ( 0 ) ; } else { minStack . push ( minStack . peek ( ) ) ; } } public void start ( ) { if ( stack . size ( ) > 0 ) { minStack . pop ( ) ; stack . pop ( ) ; } } public Integer getTop ( ) { return null ; } public Integer getMin ( ) { if ( minStack . size ( ) > 0 ) { return minStack . peek ( ) ; } return null ; } public void stop ( ) { if ( stack . size ( ) > 0 ) { minStack . pop ( ) ; stack . pop ( ) ; } } public void start ( ) { if ( stack . size ( ) > 0 ) { minStack . pop ( ) ; stack . pop ( ) ; } } } ; if ( getClassName ( ) . equals ( " org . apache . log4j . core . MinStack " ) ) { MinStack < Integer > m = new MinStack < Integer > ( ) ; m . push ( - 2 ) ; m . push ( 0 ) ; m . push ( - 3 ) ; System . out . println ( m . getMin ( ) ) ; m . pop ( ) ; System . out . println ( m . top ( ) ) ; System . out . println ( m . getMin ( ) ) ; } }
static String [ ] one = { " " , " one ▁ " , " two ▁ " , " three ▁ " , " four ▁ " , " five ▁ " , " six ▁ " , " seven ▁ " , " eight ▁ " , " nine ▁ " , " ten ▁ " , " eleven ▁ " , " twelve ▁ " , " thirteen ▁ " , " fourteen ▁ " , " fifteen ▁ " , " sixteen ▁ " , " seventeen ▁ " , " eighteen ▁ " , " nineteen ▁ " } ; String [ ] ten = { " " , " " , " twenty ▁ " , " thirty ▁ " , " forty ▁ " , " fifty ▁ " , " sixty ▁ " , " seventy ▁ " , " eighty ▁ " , " ninety ▁ " } ; /* ▁ number ▁ to ▁ words ▁ */ String str = " " ; if ( ( n > 19 ) && ( n < 19 ) ) str += ten [ n / 10 ] + one [ n % 10 ] ; else str += one [ n ] ; if ( ( n > 0 ) && ( n < 19 ) ) str += one [ n ] ; /* ▁ convert ▁ to ▁ words ▁ */ String [ ] out = { " " } ; out [ str . length ( ) ] = numToWords ( ( n / 10000000 ) , " crore ▁ " ) ; out [ str . length ( ) ] = numToWords ( ( ( n / 100000 ) % 100 ) , " lakh ▁ " ) ; out [ str . length ( ) ] = numToWords ( ( ( n / 1000 ) % 100 ) , " thousand ▁ " ) ; out [ str . length ( ) ] = numToWords ( ( ( n / 100 ) % 10 ) , " hundred ▁ " ) ; if ( ( n > 100 ) && ( n % 100 ) != 0 ) out [ str . length ( ) ] = " and ▁ " ; out [ str . length ( ) ] = numToWords ( ( n % 100 ) , " " ) ; /* ▁ convert ▁ to ▁ words ▁ */ n = 438237764 ; System . out . println ( convertToWords ( n ) ) ; return out ; }
static int flipSign ( int a ) { int neg = 0 ; int tmp = a < 0 ? 1 : - 1 ; while ( ( a = a - 1 ) != 0 ) { neg += tmp ; a += tmp ; } return neg ; }
public static int factorial ( int n ) { int i = n ; int fact = 1 ; while ( ( n / i ) != n ) { fact = fact * i ; i -- ; } return fact ; }
public static int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( ( number % x ) == 0 ) && ( ( ( int ) ( arr [ i ] ) ) % x == 0 ) ) { count ++ ; } } return count ; }
static final String main ( String [ ] args ) { final int n = Integer . parseInt ( input . nextLine ( ) ) ; final int [ ] a = Lists . newArrayList ( ) . stream ( ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; final Map < Integer , Integer > map = new LinkedHashMap < > ( ) ; for ( int x : a ) { int c = 0 ; while ( x > 0 ) { c += x % 2 ; x /= 2 ; } map . put ( c , 1 ) ; } int ans = 0 ; for ( int v : map . values ( ) ) { ans += v * ( v - 1 ) / 2 ; } System . out . println ( ans ) ; if ( args . length == 0 ) { int t = 1 ; while ( t > 0 ) { main ( ) ; t -- ; } } return ans ; }
public static int minNoOf_operation ( int [ ] arr , int n , int k ) { long res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int noOfSubtraction = 0 ; if ( ( arr [ i ] > arr [ i - 1 ] ) ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) ) { noOfSubtraction ++ ; } arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return ( int ) res ; }
public static int CountSubSet ( int arr [ ] , int n , int X ) { int N = 2 * n ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { if ( ( arr [ j ] == X ) && ( arr [ j ] != 0 ) ) { count ++ ; } } } } return count ; }
static int FindMaxProduct ( int arr [ ] [ ] , int n ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int result ; if ( ( ( j - 3 ) >= 0 ) && ( ( j - 3 ) >= 0 ) ) { result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) ; if ( ( max < result ) && ( ( max < result ) ) ) { max = result ; } } if ( ( ( i - 3 ) >= 0 ) && ( ( j - 3 ) >= 0 ) ) { result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) ; if ( ( max < result ) && ( ( max < result ) ) ) { max = result ; } } if ( ( ( i - 3 ) >= 0 ) && ( ( j - 3 ) >= 0 ) ) { result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) ; if ( ( max < result ) && ( ( max < result ) ) ) { max = result ; } } if ( ( ( i - 3 ) >= 0 ) && ( ( j - 1 ) <= 0 ) ) { result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ) ; if ( ( max < result ) && ( ( max < result ) ) ) { max = result ; } } } } if ( className . equals ( " java . lang . String " ) ) { int arr [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 1 } , { 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 1 , 0 } , { 9 , 6 , 4 , 2 , 3 } } ; System . out .
public static void sieve ( ) { int MAX = 50002 ; ArrayList < Integer > primes = new ArrayList < Integer > ( ) ; { boolean [ ] isPrime = new boolean [ MAX ] ; int p = 2 ; while ( p * p < MAX ) { if ( ( isPrime [ p ] = true ) == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { isPrime [ i ] = false ; } } p ++ ; } for ( ; p < 2 && isPrime [ p ] ; p ++ ) { if ( ( isPrime [ p ] = true ) == false ) { primes . add ( p ) ; } } } private int power ( int x , int y ) { int count = 0 ; int z = y ; while ( ( x = x / z ) >= 0 ) { count += ( x / z ) ; z *= y ; } return count ; } private int modMult ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; while ( ( b > 0 ) && ( a % b == 1 ) ) { if ( ( b % 2 == 1 ) && ( res == 0 ) ) { res = ( res + a ) % mod ; } a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; } private int countWays ( int n , int m ) { int ans = 1 ; for ( int i = 1 ; i < primes . size ( ) ; i ++ ) { int powers = power ( n , primes . get ( i ) ) ; if ( ( powers == 0 ) || ( ( ( ans - 1 ) % m ) < 0 ) ) { break ; } ans = modMult ( ans , powers + 1 , m ) % m ; } if ( ( ( ( ans - 1 ) % m ) < 0 ) && ( ( ( ans - 1 ) % m ) < 0 ) ) { return ( ans - 1 + m ) % m ; } else { return ( ans - 1 ) % m ; } } }
public static int smallestIndexsum ( int [ ] arr , int n ) { int i = n - 1 ; while ( ( i >= 0 ) && arr [ i ] % 2 == 1 ) { i -- ; } int sum = 0 ; for ( int j = 0 ; j <= i ; j ++ ) { sum += arr [ j ] ; } return sum ; }
public static void input ( ) { String y1 = input . nextLine ( ) ; String m1 = input . nextLine ( ) ; String d1 = input . nextLine ( ) ; String y2 = input . nextLine ( ) ; String m2 = input . nextLine ( ) ; String d2 = input . nextLine ( ) ; synchronized ( date1 ) { date1 . setTime ( Integer . parseInt ( y1 ) ) ; date2 . setTime ( Integer . parseInt ( m1 ) ) ; date2 . setTime ( Integer . parseInt ( d2 ) ) ; } }
public static void input ( ) { int S = input . nextInt ( ) ; int totalQ = S ; int CQ = 0 ; int CQAQ = 0 ; for ( int i = 0 ; i < S ; i ++ ) { switch ( S ) { case " Q " : CQ ++ ; break ; case " A " : CQAQ += CQ * ( totalQ - CQ ) ; break ; } } System . out . println ( CQAQ ) ; }
static final String [ ] getInputMethods ( ) { String [ ] inputMethods = { " clipboard " , " file " , " key " } ; int usingMethod = 0 ; String inputMethod = inputMethods [ usingMethod ++ ] ; Callable < Integer > tin = new Callable < Integer > ( ) { @ Override public Integer call ( ) throws Exception { return Integer . parseInt ( input ( ) ) ; } } ; Callable < Integer > lin = new Callable < Integer > ( ) { @ Override public Integer call ( ) throws Exception { return Collections . frequency ( tin . call ( ) , in ) ; } } ; final int mod = 1000000007 ; public int call ( ) throws Exception { int n = tin . call ( ) ; int k = tin . call ( ) ; int [ ] al = lin . call ( ) ; Arrays . sort ( al , Collections . reverseOrder ( ) ) ; int ss = Arrays . binarySearch ( al , n ) ; int [ ] arrive = new int [ k ] ; Arrays . fill ( arrive , n ) ; HashSet < Integer > usefulSet = new HashSet < Integer > ( ) ; for ( int v : al ) { ss -= v ; int uMax = 0 ; if ( v >= k ) { usefulSet . add ( v ) ; continue ; } for ( int i = 0 ; i < arrive . length ; i ++ ) { final int p = k - i - 1 ; final int isOn = arrive [ p ] ; if ( isOn == 1 && p + v >= k ) { usefulSet . add ( v ) ; uMax = k ; } else if ( isOn == 1 ) { arrive [ p + v ] = 1 ; uMax = Math . max ( uMax , p + v ) ; } } if ( uMax + ss >= k ) { usefulSet . add ( v ) ; } } int ret = 0 ; for ( int v : al ) { if ( ! usefulSet . contains ( v ) ) { ret ++ ; } } boolean isTest = false ; { pa . println ( v ) ; } return ret ; } public Object call ( ) throws Exception { final String inputText = clipboard . get ( ) ; final BufferedReader inputL = new BufferedReader ( new StringReader ( inputText ) ) ; String line ; while ( ( line = inputL . readLine ( ) ) != null ) { line = inputL . readLine ( ) ;
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; int s = Integer . parseInt ( input ) ; int m = s / n ; if ( s % n == 0 ) { print ( m ) ; } else { print ( m + 1 ) ; } }
static int multiply ( int [ ] v , int x ) { int carry = 0 ; int size = v . length ; for ( int i = 0 ; i < size ; i ++ ) { int res = carry + v [ i ] * x ; v [ i ] = res % 10 ; carry = res / 10 ; } while ( ( carry != 0 ) && ( v [ 0 ] > 0 ) ) { v [ 0 ] += carry % 10 ; carry /= 10 ; } /* ▁ find ▁ sum ▁ of ▁ digits ▁ */ int sum = 0 ; size = v . length ; for ( int i = 1 ; i <= size ; i ++ ) { multiply ( v , v [ i ] ) ; } int sum = 0 ; size = v . length ; for ( int i = 0 ; i < size ; i ++ ) { sum += v [ i ] ; } return sum ; }
public static void main ( String [ ] args ) { nSpidersToSeeIn ( new Object ( ) { @ Override public String toString ( ) { return " " ; } } ) ; nSpidersToSeeIn ( new Object [ ] { field } ) ; /* ▁ Iterate ▁ over ▁ each ▁ field ▁ in ▁ the ▁ array ▁ */ for ( int i = 1 ; i < field [ 0 ] . length ( ) ; i ++ ) { for ( int j = 0 ; j < field [ 0 ] . length ( ) ; j ++ ) { for ( int x = 0 ; x < field [ 0 ] . length ( ) ; x ++ ) { if ( i == j ) { break ; } } } } /* ▁ Iterate ▁ over ▁ each ▁ field ▁ */ int nSpiders = 0 ; int iRight = iRow - iCol , iLeft = iRow + iCol ; if ( iRight >= 0 && field [ iCol ] . charAt ( iRight ) == ' R ' ) { nSpiders ++ ; } if ( iLeft < field [ 0 ] . length ( ) && field [ iCol ] . charAt ( iLeft ) == ' L ' ) { nSpiders ++ ; } if ( ! iCol % 2 && field [ iCol ] . charAt ( iRow ) == ' U ' ) { nSpiders ++ ; } /* ▁ Print ▁ out ▁ the ▁ array ▁ */ System . out . println ( new String ( ) ) ; }
static void print ( int n , int m ) { int [ ] out = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) out [ i ] = 0 ; int [ ] comp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) comp [ i ] = i + 2 ; for ( int i = 0 ; i < m ; i ++ ) { int l = Integer . parseInt ( input . readLine ( ) . trim ( ) ) ; int r = Integer . parseInt ( input . readLine ( ) . trim ( ) ) ; int x = Integer . parseInt ( input . readLine ( ) ) ; int t = l ; while ( t <= r ) { int nextVal = comp [ t - 1 ] ; if ( out [ t - 1 ] == 0 && t != x ) out [ t - 1 ] = x ; comp [ t - 1 ] = t >= x ? r + 1 : x ; t = nextVal ; } } System . out . println ( out . length ) ; }
public static void print ( int n ) { int [ ] arr = Lists . newArrayList ( ) . stream ( ) . filter ( input -> input . nextLine ( ) . trim ( ) . equals ( " " ) ) . toArray ( ) ; int [ ] ans = new int [ n ] ; int mx = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { ans [ i ] = Math . max ( 0 , mx - arr [ i ] + 1 ) ; if ( arr [ i ] > mx ) mx = arr [ i ] ; } System . out . println ( ans ) ; }
public static int pell ( int n ) { if ( ( n <= 2 ) ) { return n ; } return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) ; }
public static int n ( ) { int i = 1 , j = n * n ; while ( i < j ) { System . out . println ( i ++ + " ▁ " + j ) ; j -- ; } return i ; }
public static int binarySearch ( int [ ] arr , int low , int high , int ele ) { while ( low < high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == ele ) { return mid ; } else if ( arr [ mid ] > ele ) { high = mid ; } else { low = mid + 1 ; } } /* ▁ print ▁ small ▁ array ▁ */ int [ ] copyArr = arr . clone ( ) ; Arrays . sort ( copyArr ) ; for ( int i = 0 ; i < asize ; i ++ ) { if ( binarySearch ( copyArr , low = 0 , high = n , ele = arr [ i ] ) > - 1 ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } if ( getClass ( ) . equals ( " java . util . Arrays " ) ) { arr = new int [ ] { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = arr . length ; int n = 5 ; printSmall ( arr , asize , n ) ; } return - 1 ; }
static int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( ( n > 0 ) ) { if ( ( ( n & 1 ) == 0 ) && ( k < 10 ) ) { count += Math . pow ( 2 , k ) ; } k ++ ; n >>= 1 ; } return count ; }
public static int getR ( ) { int R = Integer . parseInt ( input . nextLine ( ) . split ( " ▁ " ) [ - 1 ] ) ; int bestBuy = Math . min ( Integer . parseInt ( input . nextLine ( ) ) , 1 ) ; int bestSell = Math . max ( Integer . parseInt ( input . nextLine ( ) ) , 1 ) ; int numBuy = R / bestBuy ; System . out . println ( Math . max ( R , R + ( bestSell - bestBuy ) * numBuy ) ) ; return numBuy ; }
@ VisibleForTesting static void dfs ( int x , int y ) { int maximum = - Integer . MAX_VALUE , x = 0 , ans = Integer . MAX_VALUE ; int [ ] [ ] graph = new int [ 100 ] [ 100 ] ; int [ ] weight = new int [ 100 ] ; for ( int i = 0 ; i < 100 ; i ++ ) graph [ i ] = new int [ 100 ] ; for ( int i = 0 ; i < 100 ; i ++ ) { weight [ i ] = 0 ; } dfs ( node , parent ) ; int a = Integer . valueOf ( weight [ node ] + x ) . intValue ( ) ; if ( maximum < a ) { maximum = a ; ans = node ; } else if ( maximum == a ) { ans = Math . min ( ans , node ) ; } for ( int i = 0 ; i < graph [ node ] . length ; i ++ ) { int to = graph [ node ] [ i ] ; if ( to == parent ) continue ; dfs ( to , node ) ; } if ( Class . class . equals ( " java . util . HashMap " ) ) { x = 15 ; weight [ 1 ] = 5 ; weight [ 2 ] = 10 ; weight [ 3 ] = 11 ; weight [ 4 ] = 8 ; weight [ 5 ] = 6 ; graph [ 1 ] [ i ] = 2 ; graph [ 2 ] [ i ] = 3 ; graph [ 2 ] [ i ] = 4 ; graph [ 1 ] [ i ] = 5 ; dfs ( 1 , 1 ) ; System . out . println ( ans ) ; } }
MAX = 26 ; public static void updateFreq ( String strr , int [ ] freq ) { int lenn = strr . length ( ) ; for ( int i = 0 ; i < lenn ; i ++ ) { freq [ ( strr . charAt ( i ) - ' a ' ) ] ++ ; } }
public static void n ( int input ) { int a = eval ( input . replace ( " ▁ " , " | " ) ) ; int b = eval ( input . replace ( " ▁ " , " | " ) ) ; System . out . println ( a + b ) ; }
public static void input ( int n , int L , int R , int QL , int QR ) { int [ ] W = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) W [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] sumEl = new int [ n + 1 ] ; sumEl [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sumEl [ i ] = W [ i - 1 ] + sumEl [ i - 1 ] ; int answer = QR * ( n - 1 ) + sumEl [ n ] * R ; for ( int i = 1 ; i <= n ; i ++ ) { int energy = L * sumEl [ i ] + R * ( sumEl [ n ] - sumEl [ i ] ) ; if ( i > ( n - i ) ) energy = energy + ( i - ( n - i ) - 1 ) * QL ; else if ( ( n - i ) > i ) energy = energy + ( ( n - i ) - i - 1 ) * QR ; if ( energy < answer ) answer = energy ; } System . out . println ( answer ) ; }
public static double wastedWater ( int V , int M , int N ) { int amtPerMin = M - N ; double timeToFill = V / amtPerMin ; double wastedAmt = N * timeToFill ; return wastedAmt ; }
static int maxSubStr ( String str , int n ) { int count0 = 0 ; int count1 = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) { count0 ++ ; } else { count1 ++ ; } if ( count0 == count1 ) { cnt ++ ; } } if ( count0 != count1 ) { return - 1 ; } return cnt ; }
public static int a ( ) { int b = 0 ; int c = 0 ; return ( a < b ) ? a : ( b < c ) ? b : c ; }
static int findS ( int s ) { java . util . Scanner s = new java . util . Scanner ( System . in ) ; int n = 1 ; while ( ( s = s + n ) < s ) { s += n ; n ++ ; } n -- ; if ( s == s ) { return n ; } return - 1 ; } s = 15 ; n = findS ( s ) ; if ( n == - 1 ) { System . out . println ( " - 1" ) ; } else { System . out . println ( n ) ; }
static int maximumAbsolute ( int arr [ ] , int n ) { int mn = 10 * 9 ; int mx = - 10 * 9 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i > 0 ) && ( arr [ i ] == - 1 ) && ( arr [ i - 1 ] != - 1 ) ) { mn = Math . min ( mn , arr [ i - 1 ] ) ; mx = Math . max ( mx , arr [ i - 1 ] ) ; } if ( ( i < n - 1 ) && ( arr [ i ] == - 1 ) && ( arr [ i + 1 ] != - 1 ) ) { mn = Math . min ( mn , arr [ i + 1 ] ) ; mx = Math . max ( mx , arr [ i + 1 ] ) ; } } int commonInteger = ( mn + mx ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] == - 1 ) && ( arr [ i + 1 ] != - 1 ) ) { arr [ i ] = commonInteger ; } } int maxDiff = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; if ( ( diff > maxDiff ) && ( diff < maxDiff ) ) { maxDiff = diff ; } } return maxDiff ; }
public static int countStrings ( int N ) { int [ ] [ ] dp = new int [ N + 1 ] [ 3 ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = 1 ; dp [ i ] [ 1 ] = 1 ; dp [ i ] [ 2 ] = 0 ; } for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } int ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
public static int longestSubseq ( int n , int k , String s ) { int [ ] dp = new int [ n ] ; int [ ] maxLength = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int curr = ( s . charAt ( i ) - ' a ' ) ; int lower = Math . max ( 0 , curr - k ) ; int upper = Math . min ( 25 , curr + k ) ; for ( int j = lower ; j <= upper ; j ++ ) { dp [ i ] = Math . max ( dp [ i ] , maxLength [ j ] + 1 ) ; } maxLength [ curr ] = Math . max ( dp [ i ] , maxLength [ curr ] ) ; } return Math . max ( dp [ 0 ] , maxLength [ 0 ] ) ; }
static int longestFibonacciSubarray ( int n , int [ ] a ) { if ( ( n <= 2 ) && ( a [ n - 1 ] == 0 ) ) { return n ; } int Len = 2 ; int mx = - 10 * 9 ; for ( int i = 2 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) ) { Len ++ ; } else { Len = 2 ; } mx = Math . max ( mx , Len ) ; } return mx ; }
static int minimumSubarrays ( int [ ] ar , int n ) { TreeSet < Integer > se = new TreeSet < > ( ) ; int cnt = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( se . indexOf ( ar [ i ] ) == 0 ) { se . add ( ar [ i ] ) ; } else { cnt ++ ; se . clear ( ) ; se . add ( ar [ i ] ) ; } } return cnt ; }
public static boolean check ( int s ) { int [ ] freq = new int [ 10 ] ; while ( ( s != 0 ) && ( freq [ s ] != 0 ) ) { int r = s % 10 ; s = s / 10 ; freq [ r ] ++ ; } int xor = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { xor = xor ^ freq [ i ] ; } if ( ( xor == 0 ) && ( freq [ s ] == 0 ) ) { return true ; } else { return false ; } } int s = 122233 ; if ( ( check ( s ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; }
public static final int [ ] getDaysArr ( ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] days = Lists . parseDaysArr ( input . nextLine ( ) ) ; int names = 0 ; int lists = 0 ; for ( int i = 0 ; i < days . length ; i ++ ) { names += days [ i ] ; System . out . print ( names / a - lists ) ; lists += names / a - lists ; } return days ; }
public static void precompute ( int [ ] a , int n , int [ ] [ ] q , int m ) { int [ ] even = new int [ MAXN ] ; int [ ] odd = new int [ MAXN ] ; Arrays . fill ( even , 0 ) ; Arrays . fill ( odd , 0 ) ; /* ▁ precompute ▁ the ▁ array ▁ of ▁ integers ▁ */ for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 ) == 1 ) { odd [ i ] = 1 ; } if ( ( arr [ i ] % 2 ) == 0 ) { even [ i ] = 1 ; } } for ( int i = 1 ; i < n ; i ++ ) { even [ i ] = even [ i ] + even [ i - 1 ] ; odd [ i ] = odd [ i ] + odd [ i - 1 ] ; } /* ▁ isOdd ▁ */ int cnt = odd [ R ] ; if ( ( L > 0 ) && ( cnt > 0 ) ) { cnt -= odd [ L - 1 ] ; } if ( ( cnt == R - L + 1 ) && ( cnt > 0 ) ) { /* ▁ return ▁ true ; ▁ */ } /* ▁ performQueries ▁ the ▁ array ▁ of ▁ integers ▁ */ precompute ( a , n ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] [ 0 ] ; int R = q [ i ] [ 1 ] ; if ( ( isOdd ( L , R ) ) && ( isOdd ( L , R ) ) ) { System . out . println ( " Odd " ) ; } else { System . out . println ( " Even " ) ; } } /* ▁ performQueries ▁ the ▁ array ▁ of ▁ integers ▁ */ if ( __name__ == " test " ) { int [ ] a = { 2 , 1 , 5 , 7 , 6 , 8 , 9 } ; int n = a . length ; int [ ] [ ] q = { { 0 , 2 } , { 1 , 2 } , { 2 , 3 } , { 3 , 6 } } ; int m = q . length ; performQueries ( a , n , q , m ) ; } }
public static int tests = Integer . parseInt ( input ) { for ( int i = 0 ; i < tests ; i ++ ) { int windows = Integer . parseInt ( input . readLine ( ) ) ; boolean test = true ; for ( int k = 0 ; k < ( windows / 3 + 1 ) ; k ++ ) { if ( test ) { for ( int j = 0 ; j < ( windows / 5 + 1 ) ; j ++ ) { if ( test ) { for ( int i = 0 ; i < ( windows / 7 + 1 ) ; i ++ ) { if ( i * 7 + j * 5 + k * 3 == windows ) { System . out . println ( k + " ▁ " + j + " ▁ " + i ) ; test = false ; break ; } } } } } } if ( test ) System . out . println ( - 1 ) ; } return 0 ; }
public static int solve ( int m , int n , int o , int p , String hhmm ) { int h = Integer . parseInt ( hhmm . substring ( 0 , 1 ) + hhmm . substring ( 1 ) ) ; m = Integer . parseInt ( hhmm . substring ( 3 , 4 ) + hhmm . substring ( 4 ) ) ; int lft = h * 60 + m ; int rt = lft + n ; int i = 30 * 10 ; int ans = 0 ; while ( i < 1440 ) { if ( i < rt && i + p > lft ) ans ++ ; i += o ; } return ans ; }
i = input ; l = 3 ; for ( ; ; ) { int x = ( int ) i . nextInt ( ) ; if ( x == l ) System . out . println ( " NO " ) ; exit ( ) ; l ^= x ; }
public static int times ( int [ ] steps , int n ) { int currentLevel = 0 ; int previousLevel = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previousLevel = currentLevel ; currentLevel = currentLevel + steps [ i ] ; if ( ( ( previousLevel < 0 && currentLevel >= 0 ) || ( previousLevel > 0 && currentLevel <= 0 ) ) ) count ++ ; } return count ; }
public static int D = 360 ; int [ ] x = new int [ D ] ; for ( int i = 0 ; i < x . length ; i ++ ) x [ i ] = 0 ; int n = Integer . parseInt ( input . nextLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int m = Integer . parseInt ( input . nextLine ( ) ) ; int d = Integer . parseInt ( input . nextLine ( ) ) ; int v = Integer . parseInt ( input . nextLine ( ) ) ; int s = Integer . parseInt ( input . nextLine ( ) ) ; m -- ; d -- ; int start = 30 * m + d ; int end = ( start + v - 1 ) % D ; boolean [ ] h = new boolean [ D ] ; for ( int j = 0 ; j < D ; j ++ ) { h [ j ] = false ; for ( int j = 0 ; j < v ; j ++ ) { int y = ( start + j ) % D ; h [ y ] = true ; } for ( int j = 0 ; j < D ; j ++ ) { if ( h [ j ] ) x [ j ] = Math . max ( x [ j ] , s ) ; else { int A = Math . abs ( start - j ) ; if ( A > D / 2 ) A = D - A ; int B = Math . abs ( end - j ) ; if ( B > D / 2 ) B = D - B ; x [ j ] = Math . max ( x [ j ] , s - Math . min ( A , B ) ) ; } } } } System . out . println ( Math . min ( x , x . length ) ) ; return x ; }
public static void print ( ( String name , String value ) { System . out . println ( ( " Um _ nik " , " Petr " ) [ Integer . parseInt ( input ( ) ) / 1000 <= sum ( i == value ) ] ) ; }
public static String smallest ( String s ) { int l = s . length ( ) ; String ans = " " ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( s . charAt ( i ) > s . charAt ( i + 1 ) ) ) { for ( int j = 0 ; j < l ; j ++ ) { if ( ( i != j ) && ( s . charAt ( j ) != ' ▁ ' ) ) { ans += s . charAt ( j ) ; } } return ans ; } } ans = s . substring ( 0 , l - 1 ) ; return ans ; }
public static int x = Integer . parseInt ( input ) { int x = 0 , y = 0 ; int [ ] gr1 = { 2 } ; int [ ] gr2 = { 4 , 6 , 9 , 11 } ; int x_gr ; int y_gr ; if ( gr1 [ x ] == 1 ) x_gr = 1 ; else if ( gr2 [ x ] == 2 ) x_gr = 2 ; else x_gr = 3 ; if ( gr1 [ y ] == 1 ) y_gr = 1 ; else if ( gr2 [ y ] == 2 ) y_gr = 2 ; else y_gr = 3 ; if ( x_gr == y_gr ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; return x_gr ; }
private static int findMinNumber ( int [ ] arr , int n , int k ) { int i = 0 ; int j = 0 ; int minNum = 10 * 9 ; boolean found = false ; int Sum = 0 ; while ( ( i < n ) && ( ( Sum = arr [ i ] ) != 0 ) ) { Sum = Sum + arr [ i ] ; if ( ( Sum = arr [ i ] ) == k ) { minNum = Math . min ( minNum , ( ( n - ( i + 1 ) ) + j ) ) ; found = true ; } else if ( ( Sum = arr [ i ] ) > k ) { while ( ( Sum = arr [ j ] ) != 0 ) { j ++ ; } if ( ( Sum = arr [ j ] ) == k ) { minNum = Math . min ( minNum , ( ( n - ( i + 1 ) ) + j ) ) ; found = true ; } } i ++ ; } if ( ( found ) && ( i < n ) ) return minNum ; return - 1 ; }
public static void print ( String n ) { int b = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( n . charAt ( i ) == "1" ) { b ++ ; } } System . out . println ( b ) ; }
public static void nthPalindrome ( int n , int k ) { int temp ; if ( ( k & 1 ) != 0 ) { temp = k / 2 ; } else { temp = k / 2 - 1 ; } int palindrome = 10 * temp ; palindrome = palindrome + n - 1 ; System . out . print ( palindrome ) ; if ( ( k & 1 ) != 0 ) { palindrome = palindrome / 10 ; } while ( ( palindrome = palindrome ) != 0 ) { System . out . print ( palindrome % 10 ) ; palindrome = palindrome / 10 ; } if ( getClass ( ) . equals ( String . class ) ) { n = 6 ; k = 5 ; System . out . print ( Integer . toString ( n ) + " th ▁ palindrome ▁ of ▁ " + Integer . toString ( k ) + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; System . out . println ( ) ; n = 10 ; k = 6 ; System . out . print ( Integer . toString ( n ) + " th ▁ palindrome ▁ of ▁ " + Integer . toString ( k ) + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; System . out . println ( ) ; } }
@ VisibleForTesting static int [ ] getStdDev ( ) { final int N = Integer . parseInt ( input . nextLine ( ) ) ; final int X = Integer . parseInt ( input . nextLine ( ) ) ; final List < Integer > Xs = Lists . newArrayList ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Xs . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } final int [ ] Ys = Xs . toArray ( ) ; final int [ ] Y_sum = new int [ N ] ; Y_sum [ 0 ] = Ys [ 0 ] ; for ( int i = 1 ; i <= N ; i ++ ) { Y_sum [ i ] = Y_sum [ i - 1 ] + Ys [ i ] ; } int ans = 1e100 ; for ( int repNum = 1 ; repNum <= N ; repNum ++ ) { int localAns = X * repNum ; localAns += 5 * Y_sum [ repNum - 1 ] ; int i = 2 * repNum - 1 ; int n = 1 ; while ( i <= N - 1 ) { localAns += ( 2 * n + 3 ) * ( Y_sum [ i ] - Y_sum [ i - repNum ] ) ; n ++ ; i += repNum ; } localAns += ( 2 * n + 3 ) * ( Y_sum [ N - 1 ] - Y_sum [ i - repNum ] ) ; ans = Math . min ( ans , localAns ) ; } System . out . println ( ans + N * X ) ; return null ; }
MAX = 10000 ; int [ ] hashTable = new int [ MAX ] ; { Arrays . fill ( hashTable , 0 ) ; }
public static int p1 ( int p1 , int p2 , int p3 , int p4 , int a , int b ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; if ( min ( p1 , p2 , p3 , p4 ) > a && min ( p1 , p2 , p3 , p4 ) <= b ) { System . out . println ( min ( p1 , p2 , p3 , p4 ) - a ) ; } else if ( min ( p1 , p2 , p3 , p4 ) > b && min ( p1 , p2 , p3 , p4 ) > a && a != b ) { System . out . println ( b - a + 1 ) ; } else if ( a == b && min ( p1 , p2 , p3 , p4 ) > a ) { System . out . println ( min ( p1 , p2 , p3 , p4 ) - a ) ; } else { System . out . println ( 0 ) ; } return a ; }
static final String compute ( ) { int numer = 1 ; int denom = 1 ; for ( int d = 10 ; d < 100 ; d ++ ) { for ( int n = 10 ; n < d ; n ++ ) { int n0 = n % 10 ; int n1 = n / 10 ; int d0 = d % 10 ; int d1 = d / 10 ; if ( ( n1 == d0 && n0 * d == n * d1 ) || ( n0 == d1 && n1 * d == n * d0 ) ) { numer *= n ; denom *= d ; } } } return String . valueOf ( denom / MathUtils . gcd ( numer , denom ) ) ; }
static int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
for ( _ = 0 ; ; ) { a = Integer . parseInt ( input . nextLine ( ) ) ; b = Integer . parseInt ( input . nextLine ( ) ) ; x = Integer . parseInt ( input . nextLine ( ) ) ; y = Integer . parseInt ( input . nextLine ( ) ) ; }
static int minSwaps ( int [ ] arr ) { int n = arr . length ; IntArrayList arrpos = new IntArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arrpos . add ( arr [ i ] ) ; } Collections . sort ( arrpos , new Comparator < IntArrayList > ( ) { public int compare ( IntArrayList it , IntArrayList o1 ) { return it . get ( 1 ) . compareTo ( o1 . get ( 0 ) ) ; } } ) ; boolean [ ] vis = new boolean [ n ] ; for ( int k = 0 ; k < n ; k ++ ) { vis [ k ] = false ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrpos . get ( i ) == i ) { continue ; } int cycleSize = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrpos . get ( j ) ; cycleSize ++ ; } if ( cycleSize > 0 ) { ans += ( cycleSize - 1 ) ; } } return ans ; }
public static int N = 1000005 ; boolean [ ] prime = new boolean [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { prime [ i ] = true ; } /* ▁ sieve ▁ */ prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int i = 2 ; i < N ; i ++ ) { if ( ( prime [ i ] = true ) == false ) { for ( int j = i * 2 ; j < N ; j += i ) { prime [ j ] = false ; } } } /* ▁ sumTruncatablePrimes ▁ */ int sum = 0 ; for ( int i = 2 ; i < n ; i ++ ) { int num = i ; boolean flag = true ; while ( ( num = prime [ num ] ) != false ) { if ( ( prime [ num ] = false ) == false ) { flag = false ; break ; } num /= 10 ; } num = i ; int power = 10 ; while ( ( num = prime [ num ] / power ) != false ) { if ( ( prime [ num % power ] = false ) == false ) { flag = false ; break ; } power *= 10 ; } if ( ( flag == true ) == false ) { sum += i ; } } return sum ; }
static void findWeights ( int X ) { int sum = 0 ; int power = 0 ; while ( ( sum < X ) && ( power < X ) ) { sum = Math . pow ( 3 , power + 1 ) - 1 ; sum /= 2 ; power ++ ; } int ans = 1 ; for ( int i = 0 ; i < X ; i ++ ) { } }
static int [ ] addToArrayForm ( int A [ ] , int K ) { int v [ ] = new int [ A . length ] , ans = new int [ A . length ] ; int rem = 0 , i ; for ( i = A . length - 1 ; i >= 0 ; i -- ) { int my = A [ i ] + ( K % 10 ) + rem ; if ( my > 9 ) { rem = 1 ; v [ i ] = my % 10 ; } else { v [ i ] = my ; rem = 0 ; } K = K / 10 ; } while ( K > 0 ) { int my = ( K % 10 ) + rem ; v [ i ] = my % 10 ; if ( my / 10 > 0 ) { rem = 1 ; } else { rem = 0 ; } K = K / 10 ; } if ( rem > 0 ) { v [ i ] = rem ; } for ( i = v . length - 1 ; i >= 0 ; i -- ) { ans [ i ] = v [ i ] ; } return ans ; }
static void printPaths ( char [ ] [ ] inputchar , int R , int C ) { for ( int i = 0 ; i < C ; i ++ ) { dfs ( inputchar , " " , 0 , i , R , C ) ; System . out . println ( ) ; } { if ( ( i == R ) && ( i == 0 ) ) { System . out . print ( res + " ▁ " ) ; return ; } res = res + inputchar [ i ] [ j ] ; for ( int k = 0 ; k < C ; k ++ ) { dfs ( inputchar , res , i + 1 , k , R , C ) ; if ( ( i + 1 ) == R ) break ; } } if ( getClass ( ) . equals ( String . class ) ) { char [ ] [ ] inputchar = { { ' a ' , ' b ' } , { ' d ' , ' e ' } } ; R = inputchar . length ; C = inputchar [ 0 ] . length ; printPaths ( inputchar , R , C ) ; } }
public static int [ ] assignRoom ( String direction , int [ ] hotel ) { if ( direction . equals ( " L " ) ) { for ( int x = 0 ; x < 10 ; x ++ ) { if ( hotel [ x ] == 0 ) { hotel [ x ] = "1" ; return hotel ; } } } else if ( direction . equals ( " R " ) ) { for ( int x = 9 ; x >= 0 ; x -- ) { if ( hotel [ x ] == 0 ) { hotel [ x ] = "1" ; return hotel ; } } } else { hotel [ Integer . parseInt ( direction ) ] = 0 ; return hotel ; } int [ ] rooms = new int [ 10 ] ; int n = Integer . parseInt ( input . nextLine ( ) ) ; String instructions = input . nextLine ( ) ; for ( int x = 0 ; x < instructions . length ( ) ; x ++ ) { assignRoom ( instructions [ x ] , rooms ) ; } for ( int x = 0 ; x < rooms . length ; x ++ ) { System . out . print ( rooms [ x ] + " ▁ " ) ; } return rooms ; }
public static void main ( String input ) { for ( ; ; ) { int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; int a1 = Integer . parseInt ( input ) ; int b1 = Integer . parseInt ( input ) ; if ( Math . max ( a , b ) == Math . max ( a1 , b1 ) ) { if ( Math . min ( a , b ) + Math . min ( a1 , b1 ) == Math . max ( a , b ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } else System . out . println ( " NO " ) ; } }
static void precisionCompute ( int x , int y , int n ) { if ( y == 0 ) { System . out . println ( " Infinite " ) ; return ; } if ( x == 0 ) { System . out . println ( 0 ) ; return ; } if ( n <= 0 ) { System . out . println ( x / y ) ; return ; } if ( ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) ) { System . out . print ( " - " ) ; } }
public static int gcd ( int a , int b ) { if ( ( b == 0 ) || ( a == 1 ) ) { return a ; } else { return gcd ( b , a % b ) ; } int lcmOfArray [ ] = new int [ 3 ] ; if ( ( n < 1 ) || ( n > 2 ) ) { return 0 ; } int lcm = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; } return lcm ; /* ▁ min ▁ PerfectCube ▁ */ int lcm = lcmOfArray [ 0 ] ; int minPerfectCube = lcm ; int cnt = 0 ; while ( ( lcm > 1 ) && ( lcm % 2 == 0 ) ) { cnt ++ ; lcm /= 2 ; } if ( ( cnt % 3 == 2 ) || ( cnt % 3 == 1 ) ) { minPerfectCube *= 2 ; } else if ( ( cnt % 3 == 1 ) || ( cnt % 3 == 2 ) ) { minPerfectCube *= 4 ; } int i = 3 ; while ( ( lcm > 1 ) && ( lcm % i == 0 ) ) { cnt ++ ; lcm /= i ; } if ( ( cnt % 3 == 1 ) || ( cnt % 3 == 2 ) ) { minPerfectCube *= i * i ; } else if ( ( cnt % 3 == 2 ) || ( cnt % 3 == 1 ) ) { minPerfectCube *= i ; } i += 2 ; return minPerfectCube ; }
public static Node < Integer > createBinaryTree ( int key ) { Stack < Node < Integer > > s = new Stack < Node < Integer > > ( ) ; Stack < Node < Integer > > q = new Stack < Node < Integer > > ( ) ; int elements = 0 ; Node < Integer > root ; { this . data = key ; this . left = null ; this . right = null ; } void printSpecificLevelOrder ( Node < Integer > root ) { s . push ( root ) ; Node < Integer > prnt = s . pop ( ) ; q . push ( prnt . data ) ; if ( prnt . right != null ) s . push ( root . right ) ; if ( prnt . left != null ) s . push ( root . left ) ; } for ( elements ++ ; elements < q . size ( ) ; ) { System . out . print ( elements + " ▁ " ) ; } }
public static void hollowSquare ( int rows ) { for ( int i = 1 ; i <= rows ; i ++ ) { if ( ( i == 1 ) || i == rows ) { for ( int j = 1 ; j <= rows ; j ++ ) { System . out . print ( " * " ) ; } } else { for ( int j = 1 ; j <= rows ; j ++ ) { if ( ( j == 1 ) || j == rows ) { System . out . print ( " * " ) ; } else { System . out . print ( " ▁ " ) ; } } } System . out . println ( ) ; } }
@ ClassRule public static TestRule getRule ( ) { return new TestRule ( ) { @ Override protected void starting ( ) throws Throwable { } @ Override protected void teardown ( ) throws Throwable { } } ; }
static final PriorityQueue < Integer > SQRT_COMPARATOR = new PriorityQueue < Integer > ( ) { private static final long serialVersionUID = 1L ; @ Override public int [ ] values ( ) { return new int [ ] { Integer . MAX_VALUE } ; } @ Override public int [ ] inLSTs ( ) { return new int [ ] { Integer . MAX_VALUE } ; } @ Override public int [ ] inp ( ) { return new int [ ] { Integer . MAX_VALUE } ; } @ Override public int [ ] instr ( ) { return new int [ ] { Integer . MIN_VALUE } ; } @ Override public int [ ] words ( ) { return new int [ ] { Integer . MIN_VALUE } ; } @ Override public int [ ] words ( ) { return new int [ ] { Integer . MIN_VALUE } ; } @ Override public int [ ] chars ( ) { return new int [ ] { Integer . MIN_VALUE } ; } @ Override public void solve ( ) { int n = in ( ) ; int [ ] t = new int [ n ] ; int [ ] w = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = values ( ) [ i ] ; int b = values ( ) [ i ] ; t [ i ] = a ; w [ i ] = b ; } int sm = Arrays . binarySearch ( t , w ) ; int cnt = Arrays . binarySearch ( w , 0 , n , n - 1 ) ; int [ ] dp = new int [ sm + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = sm ; j > t [ i ] - 1 ; j -- ) { dp [ j ] = Math . max ( dp [ j ] , dp [ j - t [ i ] ] + w [ i ] ) ; } } for ( int i = 1 ; i < dp . length ; i ++ ) { int rem = cnt - dp [ i ] ; if ( dp [ i ] > 0 && rem <= i ) System . out . println ( i ) ; break ; } } }
static void main ( String [ ] args ) { final Scanner input = new Scanner ( System . in ) ; int a , b , x ; input . nextLine ( ) ; a = Integer . parseInt ( input . nextLine ( ) ) ; b = Integer . parseInt ( input . nextLine ( ) ) ; x = Integer . parseInt ( input . nextLine ( ) ) ; if ( a <= x && x <= a + b ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } }
@ java . lang . Deprecated public static int findLargest ( int [ ] arr , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { gcd = __gcd ( arr [ i ] , gcd ) ; } return gcd ; }
static void findWinner ( int n ) { if ( ( ( n - 1 ) % 6 ) == 0 ) { System . out . println ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) ; } else { System . out . println ( " First ▁ Player ▁ wins ▁ the ▁ game " ) ; } if ( getClass ( ) . getName ( ) . equals ( " java . lang . Object " ) ) { n = 7 ; findWinner ( n ) ; } }
@ Nonnull public static < T > Graph < T > create ( ) { class Graph { private final Map < T , List < T > > graph ; } @ Override public void addEdge ( T u , T v ) { graph . get ( u ) . add ( v ) ; } @ Override public void BFS ( T s ) { boolean [ ] visited = new boolean [ graph . size ( ) ] ; Queue < T > queue = new LinkedList < T > ( ) ; queue . add ( s ) ; visited [ s ] = true ; while ( queue . size ( ) > 0 ) { s = queue . remove ( ) ; } } }
@ Nonnull public static < T > Graph < T > create ( ) { class Graph { private final Map < T , List < T > > graph ; } @ Override public void addEdge ( T u , T v ) { graph . get ( u ) . add ( v ) ; } @ Override public void BFS ( T s ) { boolean [ ] visited = new boolean [ graph . size ( ) ] ; Queue < T > queue = new LinkedList < T > ( ) ; queue . add ( s ) ; visited [ s ] = true ; while ( queue . size ( ) > 0 ) { s = queue . remove ( ) ; } } }
static void getElements ( int a , int [ ] arr , int n ) { int [ ] elements = new int [ n + 1 ] ; elements [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } }
) " , description = " Tianren ▁ Liu " ) public static String solve ( int R , int P , int S ) { final int N = Integer . parseInt ( System . console ( ) . readLine ( ) ) ; if ( ( R < 0 ) || ( P < 0 ) || ( S < 0 ) ) { return " IMPOSSIBLE " ; } if ( R + P + S == 1 ) { return R > 0 ? " R " : P > 0 ? " P " : " S " ; } final int Rn = ( R + S - P ) / 2 , Pn = ( P - S + R ) / 2 , Sn = ( - R + S + P ) / 2 ; if ( ( Rn > R ) || ( Pn > P ) || ( Sn > S ) ) { return " IMPOSSIBLE " ; } final String res = solve ( Rn , Pn , Sn ) ; if ( res . equals ( " IMPOSSIBLE " ) ) { return " IMPOSSIBLE " ; } else { final StringBuffer nres = new StringBuffer ( ) ; final HashMap < Character , String > m = new HashMap < Character , String > ( ) ; m . put ( ' R ' , " RS " ) ; m . put ( ' S ' , " SP " ) ; m . put ( ' P ' , " PR " ) ; for ( final char c : res . toCharArray ( ) ) { nres . append ( m . get ( c ) ) ; } return nres . toString ( ) ; } }
input ; I = input ; n = Integer . parseInt ( input . nextLine ( ) ) ; m = Integer . parseInt ( input . nextLine ( ) ) ; b = new int [ n * 2 ] ; b [ 0 ] = b [ n - 1 ] = b [ n ] = b [ 2 * n - 1 ] = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int r = Integer . parseInt ( input . nextLine ( ) ) ; int c = Integer . parseInt ( input . nextLine ( ) ) ; b [ r - 1 ] = b [ n + c - 1 ] = 0 ; } if ( n % 2 > 0 && b [ n / 2 ] != 0 && b [ n + n / 2 ] != 0 ) { b [ n / 2 ] = 0 ; } System . out . println ( Arrays . toString ( b ) ) ; }
static void printRepeating ( int [ ] arr , int size ) { final int S = 0 ; int P = 1 ; int n = size - 2 ; for ( int i = 0 ; i <= size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; final double D = Math . sqrt ( S * S - 4 * P ) ; final int x = ( D + S ) / 2 ; final int y = ( S - D ) / 2 ; System . out . println ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : " + ( ( int ) x ) + " & " + ( ( int ) y ) ) ; }
public static int [ ] primes ( ) { final ArrayList < Integer > primes = new ArrayList < Integer > ( ) ; for ( int p = 2 ; p < 10001 ; p ++ ) { for ( int m = 2 ; m <= Math . floor ( Math . sqrt ( p ) ) ; m ++ ) { if ( p % m == 0 ) { break ; } } else { primes . add ( p ) ; } } int targ = Integer . parseInt ( input . nextLine ( ) ) ; while ( targ != 0 ) { int ans = 0 ; for ( int p = 0 ; p < primes . size ( ) ; p ++ ) { if ( primes . get ( p ) > targ ) { break ; } int tempsum = 0 ; for ( int l = p ; l < primes . size ( ) ; l ++ ) { tempsum += primes . get ( l ) ; if ( tempsum > targ ) { break ; } else if ( tempsum == targ ) { ans ++ ; break ; } } } System . out . println ( ans ) ; targ = Integer . parseInt ( input . nextLine ( ) ) ; } return primes . toArray ( new Integer [ primes . size ( ) ] ) ; }
@ SafeVarargs public static double atan2 ( double x , double y ) { int N = Integer . parseInt ( new Scanner ( System . in ) . nextLine ( ) ) ; int [ ] XY = new int [ N ] ; for ( int i = 0 ; i < XY . length ; i ++ ) { XY [ i ] = Integer . parseInt ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( new Scanner ( ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ; } Arrays . sort ( XY ) ; for ( int i = 0 ; i < N ; i ++ ) { final double x = XY [ i ] ; final double y = XY [ i ] ; final List < Double > D = new ArrayList < Double > ( ) ; for ( int j = 0 ; j < N ; j ++ ) { final double X = XY [ j ] ; final double Y = XY [ j ] ; if ( j != i ) { D . add ( Math . atan2 ( X - x , Y - y ) ) ; } } D . add ( D . get ( 0 ) + 2 * PI ) ; double ans = 0 ; for ( int a = 1 ; a < D . size ( ) ; a ++ ) { final double b = D . get ( a ) ; if ( b - a >= PI ) { ans = ( b - a ) - PI ; } } System . out . println ( ans / ( 2 * PI ) ) ; } return ans ; }
@ Alp public static void alp ( String alp ) { alp = " * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * "
, length = length , tour = input ( ) , length = input ( ) ; return tour . count ( ' SF ' ) > tour . count ( ' FS ' ) ? ' YES ' : ' NO ' ; }
public static List < BigInteger > bigres = new ArrayList < BigInteger > ( ) { private int t = Integer . parseInt ( input . nextLine ( ) ) ; for ( int m = 0 ; m < t ; m ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; BigInteger [ ] a = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = BigIntegerMath . parseInt ( input . nextLine ( ) . trim ( ) . split ( " ▁ " ) ) ; } BigInteger res = a [ 0 ] . multiply ( a [ 1 ] ) ; for ( int q = 0 ; q < a . length - 1 ; q ++ ) { res = Math . max ( res , ( a [ q ] . multiply ( a [ q + 1 ] ) ) ) ; } bigres . addAll ( Arrays . asList ( a ) ) ; } for ( int i = 0 ; i < bigres . size ( ) ; i ++ ) { System . out . println ( bigres . get ( i ) ) ; } return bigres ; }
private static int gcd ( int x , int y ) { int gcd ; int small = y ; for ( int i = 1 ; i <= small ; i ++ ) { if ( ( ( x % i ) == 0 ) && ( ( y % i ) == 0 ) ) { gcd = i ; } } return gcd ; /* ▁ Find ▁ LCM ▁ */ }
public static String input ( ) { String s = input ( ) ; String t = " , . ? ! " ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) s = s . replace ( t . charAt ( i ) , t + ' ▁ ' ) ; s = s . trim ( ) ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) s = s . replace ( ' ▁ ' + t . charAt ( i ) , t ) ; return s ; }
@ VisibleForTesting static int smallestKFreq ( int [ ] arr , int n , int k ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( arr [ i ] , 1 ) ; } int res = Integer . MAX_VALUE ; int res1 = Integer . MIN_VALUE ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( entry . getValue ( ) == k ) { res = Math . min ( res , entry . getKey ( ) ) ; } } return res != res1 ? res : - 1 ; }
static boolean areVowelsInOrder ( String s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == ' a ' ) || ( s . charAt ( i ) == ' e ' ) || ( s . charAt ( i ) == ' i ' ) || ( s . charAt ( i ) == ' o ' ) || ( s . charAt ( i ) == ' u ' ) ) { if ( s . charAt ( i ) < c ) { return false ; } else { c = s . charAt ( i ) ; } } } return true ; }
public static int INF = 10 ** 20 ; int MAX_INT = 10 ** 6 ; int [ ] a = new int [ MAX_INT ] ; int [ ] b = new int [ MAX_INT ] ; a [ 0 ] = INF ; b [ 0 ] = INF ; for ( int i = 1 ; i <= 200 ; i ++ ) { int t = i * ( i + 1 ) * ( i + 2 ) / 6 ; int mm = Math . min ( t * 5 , MAX_INT ) ; for ( int j = t ; j < mm ; j ++ ) { if ( a [ j ] > a [ j - t ] + 1 ) { a [ j ] = a [ j - t ] + 1 ; } } if ( t % 2 == 0 ) continue ; for ( int j = t ; j < MAX_INT ; j ++ ) { if ( b [ j ] > b [ j - t ] + 1 ) { b [ j ] = b [ j - t ] + 1 ; } } } int N ; do { N = Integer . parseInt ( input . readLine ( ) ) ; } while ( N == 0 ) ; exit ( ) ; System . out . println ( a [ N ] + " ▁ " + b [ N ] ) ; return N ; }
static int countOfLetters ( String string ) { int letter = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( ( ( string . charAt ( i ) >= ' A ' && string . charAt ( i ) <= ' Z ' ) || ( string . charAt ( i ) >= ' a ' && string . charAt ( i ) <= ' z ' ) ) { letter ++ ; } } /* ▁ Count ▁ of ▁ numbers ▁ */ int number = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( ( string . charAt ( i ) >= '0' && string . charAt ( i ) <= '9' ) ) { number ++ ; } } /* ▁ Check ▁ if ▁ ( ( countOfLetters ( string ) ▁ = = ▁ countOfNumbers ( string ) ) ▁ = = ▁ 0 ) ▁ */ if ( ( countOfLetters ( string ) == countOfNumbers ( string ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } if ( getClass ( ) . getName ( ) . equals ( " GeeKs01324" ) ) { string = " GeeKs01324" ; } /* ▁ Check ▁ if ▁ ( ( countOfLetters ( string ) ▁ = = ▁ countOfNumbers ( string ) ) ▁ = = ▁ 0 ) ▁ */ if ( ( countOfLetters ( string ) == countOfNumbers ( string ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return letter ; }
public static List < Integer > lis = new ArrayList < Integer > ( ) { int cnt = 0 ; while ( true ) { try { int n = Integer . parseInt ( input . nextLine ( ) ) ; if ( n > 0 ) { cnt ++ ; lis . add ( n ) ; } else { System . out . println ( lis . remove ( cnt - 1 ) ) ; cnt -- ; } } catch ( Exception e ) { break ; } } }
public static int N ( int x ) { int N = Integer . parseInt ( input . nextLine ( ) ) , x = Integer . parseInt ( input . nextLine ( ) ) ; if ( x == 1 || x == 2 * N - 1 ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; List < Integer > l = new ArrayList < > ( ) ; for ( int i = 1 ; i < 2 * N ; i ++ ) { l . add ( i ) ; } l . remove ( x - 1 ) ; l . remove ( x ) ; l . remove ( x + 1 ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) { System . out . println ( l . get ( i ) ) ; } System . out . println ( x - 1 ) ; System . out . println ( x ) ; System . out . println ( x + 1 ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) { System . out . println ( l . get ( N - 2 + i ) ) ; } } return N ; }
public static void precomputeCounts ( ) { final int MAX = 100001 ; final int [ ] perfectDiv = new int [ MAX ] ; { precomputeCounts ( ) ; int i = 1 ; while ( i * i < MAX ) { for ( int j = i * i ; j < MAX ; j += i * i ) { perfectDiv [ j ] ++ ; } i ++ ; } } { precomputeCounts ( ) ; int n = 16 ; System . out . println ( " Total ▁ perfect ▁ divisors ▁ of " + n + " = " + perfectDiv [ n ] ) ; n = 12 ; System . out . println ( " Total ▁ perfect ▁ divisors ▁ of " + n + " = " + perfectDiv [ n ] ) ; } }
public static int N ( ) { int M = Integer . parseInt ( input . nextLine ( ) ) ; int A = Integer . parseInt ( input . nextLine ( ) ) ; int B = Integer . parseInt ( input . nextLine ( ) ) ; return N ; }
public static int n ( int t , int e ) { int i ; int n = Integer . parseInt ( input . nextLine ( ) ) ; int t = t ; int e = e ; List < Integer > xlst = new LinkedList < Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) { xlst . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } for ( i = 0 ; i < xlst . size ( ) ; i ++ ) { int x = xlst . get ( i ) ; int a = ( t - e - 1 ) / x ; if ( ( a + 1 ) * x <= t + e ) { System . out . println ( i + 1 ) ; break ; } } return i ; }
@ Implementation public static void calIST ( int h , int r ) { long IST = Math . round ( ( h * r * 1.0 ) / 360 ) ; int intIST = ( int ) IST ; float floatIST = Math . ceil ( ( IST - intIST ) * 60 ) ; System . out . println ( Integer . toString ( intIST ) + " : " + Float . toString ( floatIST ) ) ; }
static void printRoots ( int n ) { final double theta = Math . PI * 2 / n ; for ( int k = 0 ; k <= n ; k ++ ) { final double real = Math . cos ( k * theta ) ; final double img = Math . sin ( k * theta ) ; System . out . print ( real + " ▁ " ) ; if ( ( img >= 0 ) && ( img <= 1 ) ) { System . out . print ( " ▁ + ▁ i ▁ " ) ; } else { System . out . print ( " ▁ - ▁ i ▁ " ) ; } System . out . println ( Math . abs ( img ) ) ; } if ( Class . isPrimitive ( ) ) { printRoots ( 1 ) ; printRoots ( 2 ) ; printRoots ( 3 ) ; } }
static void findCart ( int [ ] arr1 , int [ ] arr2 , int n , int n1 ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n1 ; j ++ ) { System . out . print ( " { " + arr1 [ i ] + " , ▁ " + arr2 [ j ] + " } , ▁ " ) ; } } }
public static int noOfWays ( String s ) { int n = s . length ( ) ; int countLeft = 0 ; int countRight = 0 ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( s . charAt ( i ) == s . charAt ( 0 ) ) ) { countLeft ++ ; } else { break ; } } int i = n - 1 ; while ( ( i >= 0 ) && ( s . charAt ( i ) == s . charAt ( n - 1 ) ) ) { countRight ++ ; } else { break ; } i -- ; if ( ( s . charAt ( 0 ) == s . charAt ( n - 1 ) ) ) { return ( ( countLeft + 1 ) * ( countRight + 1 ) ) ; } else { return ( countLeft + countRight + 1 ) ; } }
static void SumOfKthPrimes ( int [ ] arr , int n , int k ) { MAX = 100000 ; boolean [ ] prime = new boolean [ MAX + 1 ] ; Arrays . fill ( prime , true ) ; { prime [ 1 ] = false ; prime [ 0 ] = false ; int p = 2 ; while ( ( p * p <= MAX ) && ( prime [ p ] ) ) { int i = p * 2 ; while ( ( i <= MAX ) && ( prime [ i ] ) ) { prime [ i ] = false ; i += p ; } } p ++ ; } }
private static void SieveOfEratosthenes ( ) { prime [ 1 ] = false ; prime [ 0 ] = false ; int p = 2 ; while ( p * p <= MAX ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) { prime [ i ] = false ; } } p ++ ; } { int c = 0 ; int Sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { Sum += arr [ i ] ; c = 0 ; } } } System . out . println ( Sum ) ; } if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { int MAX = 1000000 ; prime = new boolean [ MAX + 1 ] ; prime [ 0 ] = true ; SieveOfEratosthenes ( ) ; int n = 5 , k = 2 ; int [ ] arr = { 2 , 3 , 5 , 7 , 11 } ; solve ( arr , n , k ) ; } }
public static void productOfKthPrimes ( int [ ] arr , int n , int k ) { int MAX = 1000000 ; boolean [ ] prime = new boolean [ MAX + 1 ] ; { prime [ 1 ] = false ; prime [ 0 ] = false ; int p = 2 ; while ( p * p <= MAX ) { if ( ( prime [ p ] = true ) == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) { prime [ i ] = false ; } } p ++ ; } } { int c = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( prime [ arr [ i ] ] = true ) == false ) { c ++ ; if ( ( c % k ) == 0 ) { product *= arr [ i ] ; c = 0 ; } } } System . out . println ( product ) ; } if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { SieveOfEratosthenes ( ) ; int n = 5 ; int k = 2 ; int [ ] arr = { 2 , 3 , 5 , 7 , 11 } ; productOfKthPrimes ( arr , n , k ) ; } }
static void findAllSequences ( int diff , char [ ] out , int start , int end ) { if ( ( Math . abs ( diff ) > ( end - start + 1 ) / 2 ) ) return ; if ( ( start > end ) && ( diff == 0 ) ) { System . out . print ( new String ( Arrays . copyOf ( out , start + 1 ) ) + " ▁ " ) ; return ; } out [ start ] = '0' ; out [ end ] = '1' ; findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '0' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; }
public static boolean check ( int [ ] h , int high ) { Arrays . sort ( h ) ; int summ = 0 ; for ( int i = h . length - 1 ; i >= 0 ; i -= 2 ) { summ += h [ i ] ; } return summ <= high ; } int n = Integer . parseInt ( input ( ) ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = i ; }
static class newNode ( ) { private int data ; private Node next ; public void printList ( Node node ) { while ( ( node = node . next ) != null ) { System . out . print ( node . data + " - > " ) ; node = node . next ; } System . out . println ( " NULL " ) ; } private int cntNodes ( Node node ) { if ( ( node == null ) || ( node . data == null ) ) { return 0 ; } return ( 1 + cntNodes ( node . next ) ) ; } private void updateList ( Node head , int m ) { int cnt = cntNodes ( head ) ; if ( ( cnt != m ) && m < cnt ) { int skip = cnt - m ; Node prev = null ; Node curr = head ; while ( ( prev = curr ) != null ) { curr = prev ; } curr . next = tempHead ; } } }
static int maxSubStrings ( String s , int k ) { int maxSubStr = 0 ; int n = s . length ( ) ; for ( int c = 0 ; c < 27 ; c ++ ) { char ch = ( char ) ( ' a ' + c ) ; int curr = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { if ( ( s . charAt ( i ) != ch ) ) continue ; int cnt = 0 ; while ( ( i < n ) && ( s . charAt ( i ) == ch ) && ( cnt != k ) ) { i ++ ; cnt ++ ; } i -- ; if ( ( cnt == k ) && ( s . charAt ( i ) == ch ) ) { curr ++ ; } } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; }
static void ansQueries ( int [ ] prefeven , int [ ] prefodd , int [ ] l , int [ ] r ) { if ( ( ( r - l + 1 ) % 2 ) == 0 ) System . out . println ( "0" ) ; else { if ( ( l % 2 ) == 0 ) System . out . println ( prefeven [ r ] ^ prefeven [ l - 1 ] ) ; else System . out . println ( prefodd [ r ] ^ prefodd [ l - 1 ] ) ; } { int [ ] prefodd = new int [ N ] ; prefeven = new int [ N ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( ( i ) % 2 ) == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } int i = 0 ; while ( ( i != q ) && ( i < n ) ) { ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) ; i ++ ; } } if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int [ ] l = { 1 , 1 , 2 } ; int [ ] r = { 2 , 3 , 4 } ; int q = l . length ; ansQueries ( arr , n , l , r , q ) ; } }
public static void print ( int n ) { int [ ] l = new int [ n ] ; for ( String i : input . split ( " ▁ " ) ) l [ 0 ] = Integer . parseInt ( i ) ; Arrays . sort ( l , Collections . reverseOrder ( ) ) ; for ( int i = 1 ; i < n ; i ++ ) { } }
public static void main ( String input ) { for ( int p = 0 ; p < Integer . parseInt ( input ) ; p ++ ) { int n = Integer . parseInt ( input . substring ( 0 , p ) ) ; int k = Integer . parseInt ( input . substring ( p + 1 ) ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( input . substring ( i + 1 , n ) ) ; } int x , y ; if ( n % 2 != 0 ) { x = n / 2 ; y = n / 2 + 1 ; } else { x = n / 2 - 1 ; y = n / 2 + 1 ; } if ( n == 2 ) { int s = 0 ; for ( int i = 0 ; i < n * k ; i += 2 ) { s += a [ i ] ; } System . out . println ( s ) ; } else { int d = x * k , s = 0 ; while ( d < ( n * k ) ) { s += a [ d ] ; d += y ; } System . out . println ( s ) ; } } }
public static void input ( int n , int r ) { Stack < List < Integer > > stack = new Stack < > ( ) ; for ( int i = 0 ; i < Integer . parseInt ( n ) ; i ++ ) { stack . add ( new ArrayList < > ( ) ) ; } for ( int i = 0 ; i < Integer . parseInt ( r ) ; i ++ ) { List < Integer > row = new LinkedList < > ( ) ; for ( int j = 0 ; j < r ; j ++ ) { row . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } int c = row . get ( 0 ) ; int i = row . get ( 1 ) ; if ( c == 0 ) { stack . get ( i ) . add ( row . get ( 2 ) ) ; } if ( stack . get ( i ) . size ( ) > 0 ) { if ( c == 1 ) { System . out . println ( stack . get ( i ) . get ( stack . get ( stack . get ( i ) . size ( ) - 1 ) ) ) ; } if ( c == 2 ) { stack . get ( i ) . remove ( stack . get ( i ) . size ( ) - 1 ) ; } } } }
public static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } { int minVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minVal = Math . min ( minVal , arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] - minVal ; } } { int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxVal = Math . max ( maxVal , arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = maxVal - arr [ i ] ; } } { int [ ] arr = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] ; } } { int [ ] arr = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] - arr [ i ] ; } } { int [ ] arr = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] - arr [ i ] ; } } { int [ ] arr = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] - arr [ i
public static double [ ] findCentroid ( double [ ] [ ] v ) { double ans [ ] = { 0 , 0 } ; int n = v . length ; double signedArea = 0 ; for ( int i = 0 ; i < v . length ; i ++ ) { double x0 = v [ i ] [ 0 ] ; double y0 = v [ i ] [ 1 ] ; double x1 = v [ ( i + 1 ) % n ] [ 0 ] ; double y1 = v [ ( i + 1 ) % n ] [ 1 ] ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; return ans ; }
public static void print ( int n ) { int color = Color . blue ; int block = 0 ; int i = 0 ; while ( i != n ) { String command = String . valueOf ( input . nextInt ( ) ) ; if ( command . equals ( " lock " ) ) { block = 1 ; } else if ( command . equals ( " unlock " ) ) { block = 0 ; } else if ( block == 0 ) { color = command ; } i ++ ; } System . out . println ( color ) ; }
static int minOperations ( int [ ] ar , int k ) { Arrays . sort ( ar ) ; int opsNeeded = 0 ; for ( int i = 0 ; i < k ; i ++ ) opsNeeded += ar [ k - 1 ] - ar [ i ] ; int ans = opsNeeded ; for ( int i = k ; i < ar . length ; i ++ ) { opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) ; opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = Math . min ( ans , opsNeeded ) ; } return ans ; }
static void charCheck ( char inputChar ) { if ( ( ( ( int ) ( inputChar >= 65 && inputChar <= 90 ) ) || ( ( int ) ( inputChar >= 97 && inputChar <= 122 ) ) ) ) { System . out . println ( " ▁ Alphabet ▁ " ) ; } else if ( ( ( int ) ( inputChar >= 48 && inputChar <= 57 ) ) ) { } }
public static String print ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; String [ ] [ ] mat = new String [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { mat [ i ] = new String [ n ] ; } int [ ] b = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { b [ j ] = Integer . parseInt ( input . nextLine ( ) ) - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { mat [ i ] [ i ] = b [ i ] ; } int i = 0 ; String h = " " ; i = 0 ; while ( i < n ) { int [ ] l = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { l [ j ] = 0 ; } int a = i ; do { l [ a ] ++ ; if ( l [ a ] > 1 ) break ; a = mat [ a ] [ a ] ; } while ( a > 0 ) ; } int m = 0 ; int j = 0 ; while ( j < n ) { if ( l [ j ] > m ) { m = l [ j ] ; x = j + 1 ; } j = j + 1 ; } h = h + x + " ▁ " ; i = i + 1 ; }
public static int [ ] [ ] readInput ( ) { final String input = System . getProperty ( " line . separator " ) ; final int n = Integer . parseInt ( input ) ; final int m = Integer . parseInt ( input ) ; final int [ ] w = new int [ n ] ; final int [ ] [ ] d = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; d [ a - 1 ] [ i ] = b ; d [ b - 1 ] [ i ] = a ; } final List < Integer [ ] > x = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] . length > 1 ) { for ( int i1 = 0 ; i1 < d [ i ] . length ; i1 ++ ) { for ( int i2 = i1 + 1 ; i2 < d [ i ] . length ; i2 ++ ) { if ( ( d [ i ] [ i1 ] - 1 ) != ( d [ i ] [ i2 ] - 1 ) && ( d [ i ] [ i2 ] - 1 ) != ( d [ i ] [ i1 ] - 1 ) && ( d [ i ] [ i2 ] - 1 ) != ( d [ i ] [ i2 ] - 1 ) ) { final int z = new int [ ] { i + 1 , d [ i ] [ i1 ] , d [ i ] [ i2 ] } ; x . add ( z ) ; } } } } } double c1 = 1e9 ; for ( int a = 0 ; a < x . size ( ) ; a ++ ) { c1 = Math . min ( c1 , w [ a - 1 ] + w [ b - 1 ] + w [ c - 1 ] ) ; } System . out . println ( c1 != 1e9 ? c1 : - 1 ) ; return x . toArray ( ) ; }
input ; int n = Integer . parseInt ( u . readLine ( ) ) ; int k = Integer . parseInt ( u . readLine ( ) ) ; int [ ] M = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) M [ i ] = Integer . parseInt ( u . readLine ( ) ) ; int m = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int p = 0 ; p < n ; p ++ ) { if ( ( 0 == M [ p ] ) && ( 0 == M [ p ] ) ) { System . out . print ( p + 1 ) ; break ; } } for ( int l = p + 1 - k ; l < M . length ; l ++ ) M [ l ] -- ; M [ p ] -- ; } return m ; }
static void solve ( ) { final int n = Integer . parseInt ( input . nextLine ( ) ) ; final int rows = Integer . parseInt ( input . nextLine ( ) ) ; final int [ ] [ ] r = new int [ n ] [ rows ] ; final int [ ] [ ] cords = new int [ n ] [ rows ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = new int [ rows ] ; for ( int j = 0 ; j < rows [ i ] ; j ++ ) { cords [ r [ i ] [ j ] ] = new int [ ] { i , j } ; } } int it = 1 ; final List < int [ ] > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < rows [ i ] ; j ++ ) { if ( r [ i ] [ j ] != it ) { final int [ ] tmp = new int [ ] { cords [ it ] [ 0 ] , cords [ it ] [ 1 ] } ; r [ i ] [ j ] = r [ cords [ it ] [ 0 ] ] [ cords [ it ] [ 1 ] ] , r [ i ] [ j ] } ; cords [ it ] [ 0 ] ] [ cords [ it ] [ 1 ] ] = tmp * 1 ; ans . add ( new int [ ] { i , j , cords [ it ] [ 0 ] , cords [ it ] [ 1 ] } ) ; } it ++ ; } System . out . println ( ans . size ( ) ) ; for ( int [ ] i : ans ) { for ( int j : i ) { System . out . print ( j + 1 ) ; } System . out . println ( ) ; } }
static int sameOccurrence ( int arr [ ] , int n , int x , int y ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ctX = 0 ; int ctY = 0 ; for ( int j = i ; j < n ; j += 1 ) { if ( ( arr [ j ] == x ) && ( arr [ j + 1 ] == y ) ) ctX ++ ; else if ( ( arr [ j + 1 ] == y ) && ( arr [ j + 2 ] == 1 ) ) ctY ++ ; if ( ( ctX == ctY ) && ( arr [ j + 3 ] == 1 ) ) result ++ ; } } if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { arr = new int [ ] { 1 , 2 , 2 , 3 , 4 , 1 } ; n = arr . length ; x = 2 ; y = 3 ; System . out . println ( sameOccurrence ( arr , n , x , y ) ) ; } return ( result ) ; }
public static int t = Integer . parseInt ( input ) { int t ; while ( ( t = input . nextInt ( ) ) != 0 ) { t -- ; String s = input . next ( ) ; int n = s . length ( ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == '0' ) && ( s . charAt ( i ) == ' ▁ ' ) ) ct ++ ; } if ( ( ct < n - ct ) && ( ct < n - ct ) ) System . out . println ( ct ) ; else if ( ( ct > n - ct ) && ( ct < n - ct ) ) System . out . println ( n - ct ) ; else { if ( ( n != 2 ) && ( ct < n - 1 ) ) System . out . println ( ct - 1 ) ; else System . out . println ( 0 ) ; } } return t ; }
public static void input ( ) { int c = 0 ; HashMap < String , Integer > f = new HashMap < String , Integer > ( ) ; for ( String s : input ( ) . split ( " ▁ " ) ) f . put ( s , d = f . getOrDefault ( s , 0 ) + 1 ) ; c += d % 2 * 2 - 1 ; System . out . println ( Arrays . asList ( " Agasa " , " Conan " ) [ c > 0 ] ) ; }
[ ] a = { 1 , 2 , 3 , 4 , 5 } ; for ( int i = 0 ; i < 5 ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; }
private static int target = 93 ; int [ ] arr = { 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 } ; int length = arr . length ; int totalCount = 0 ; for ( int i = 0 ; i < length - 2 ; i ++ ) { if ( target % arr [ i ] == 0 ) { for ( int j = i + 1 ; j < length - 1 ; j ++ ) { if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) { toFind = target / ( arr [ j ] * arr [ j ] ) ; } } } } return totalCount ; }
public static void print ( int n ) { int [ ] l = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) l [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == 1 ) { System . out . println ( * Arrays . toString ( l ) ) ; System . out . println ( - l [ 0 ] ) ; System . out . println ( * Arrays . toString ( l ) ) ; System . out . println ( 0 ) ; System . out . println ( * Arrays . toString ( l ) ) ; System . out . println ( 0 ) ; } else { System . out . println ( * Arrays . toString ( l ) ) ; System . out . println ( - l [ 0 ] ) ; System . out . println ( * Arrays . toString ( l ) ) ; int [ ] x = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) x [ i ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) x [ i ] = - l [ i ] * n ; System . out . println ( x ) ; System . out . println ( * Arrays . toString ( l ) ) ; for ( int i = 2 ; i < n ; i ++ ) x [ i ] = ( n - 1 ) * l [ i ] ; System . out . println ( x [ 1 ] ) ; } }
@ Implementation public static int finalNum ( int [ ] arr , int n ) { int result = arr [ 0 ] ; for ( int i : arr ) { result = __gcd ( result , i ) ; } return result ; }
static int lastElement ( int [ ] a , int n ) { int steps = 1 ; int [ ] [ ] v = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i += 2 ) { v [ steps ] [ i ] = a [ i ] | a [ i + 1 ] ; } while ( v [ steps ] . length > 1 ) { steps ++ ; for ( int i = 0 ; i < v [ steps - 1 ] . length ; i += 2 ) { if ( ( steps & 1 ) != 0 ) v [ steps ] [ i ] = v [ steps - 1 ] [ i ] | v [ steps - 1 ] [ i + 1 ] ; else v [ steps ] [ i ] = v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ; } } return v [ steps ] [ 0 ] ; }
public static int numberCake ( int n ) { return ( n * n * n + 5 * n + 6 ) / 6 ; }
static final Scanner < String > input = new Scanner ( System . in ) { @ Override public String next ( ) { return System . in . nextLine ( ) . replaceAll ( " \\s + " , " ▁ " ) ; } }
public static void pattern ( int N ) { int k = 0 , space = 1 , rows = N ; for ( int i = rows ; i > 0 ; i -- ) { for ( int j = 1 ; j <= i ; j ++ ) { System . out . print ( ' * ' ) ; } if ( i != rows ) { for ( k = 1 ; k <= space ; k ++ ) { System . out . print ( ' ▁ ' ) ; } space += 2 ; } for ( int j = i ; j > 0 ; j -- ) { if ( j != rows ) { System . out . print ( ' * ' ) ; } } System . out . println ( ) ; } N = 6 ; pattern ( N ) ; }
public static int maximumMiddleValue ( int n , int k , int [ ] arr ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = Math . max ( ans , arr [ i - 1 ] ) ; } return ans ; }
public static TreeNode < Integer > createTreeNode ( int rootData ) { { this . val = rootData ; this . left = null ; this . right = null ; } class Solution { int result ; public Solution ( TreeNode < Integer > root , int target , int soFar , int [ ] cache ) { if ( root != null ) { int complement = soFar + root . val - target ; if ( cache [ complement ] != 0 ) result += cache [ complement ] ; cache [ soFar + root . val ] = cache [ soFar + root . val ] + 1 ; pathSumHelper ( root . left , target , soFar + root . val , cache ) ; pathSumHelper ( root . right , target , soFar + root . val , cache ) ; cache [ soFar + root . val ] -- ; } return null ; } public int pathSum ( TreeNode < Integer > root , int sum ) { result = 0 ; pathSumHelper ( root , sum , 0 , new Integer ( 0 ) ) ; return result ; } } if ( __name__ . equals ( " Solution " ) ) { Solution sObj = new Solution ( ) ; TreeNode < Integer > tree = new TreeNode < Integer > ( 10 ) ; tree . left = new TreeNode < Integer > ( 5 ) ; tree . right = new TreeNode < Integer > ( - 3 ) ; tree . left . left = new TreeNode < Integer > ( 3 ) ; tree . left . right = new TreeNode < Integer > ( 2 ) ; tree . right . right = new TreeNode < Integer > ( 11 ) ; tree . left . left . left = new TreeNode < Integer > ( 3 ) ; tree . left . left . right = new TreeNode < Integer > ( - 2 ) ; tree . left . right . right = new TreeNode < Integer > ( 1 ) ; int s = 8 ; int out = sObj . pathSum ( tree , s ) ; System . out . println ( out ) ; } return null ; }
public static void getmax ( int [ ] arr , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } System . out . println ( Math . min ( s , x ) ) ; } if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int x = 5 ; int arrSize = arr . length ; getmax ( arr , arrSize , x ) ; }
public static void setNumber ( String input , int n ) { int i ; n = input . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { System . out . println ( " Case ▁ " + ( i + 1 ) + " : " ) ; long num = Long . parseLong ( input ) ; for ( int j = 0 ; num <= 10 ; j ++ ) { num *= num ; String sn = Long . toString ( num ) ; if ( sn . length ( ) < 8 ) { int d = 8 - sn . length ( ) ; for ( int k = 0 ; k < d ; k ++ ) { sn = "0" + sn ; } } num = Long . parseLong ( sn . substring ( 2 , 6 ) ) ; System . out . println ( num ) ; } } }
public static void sieve ( ) { int MAX = 250000 ; int SQRT = 500 ; boolean [ ] prime = new boolean [ MAX ] ; { for ( int i = 2 ; i < MAX ; i += 2 ) prime [ i ] = false ; for ( int i = 3 ; i < SQRT ; i += 2 ) { if ( prime [ i ] ) { for ( int j = i * i ; j < MAX ; j += i ) prime [ j ] = false ; } } } sieve ( ) ; while ( true ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == 0 ) break ; int ans = 0 , m = n << 1 ; if ( n == 1 ) ans ++ ; int i = n + 1 ; if ( ( i & 1 ) == 0 ) i ++ ; while ( i <= m ) { if ( prime [ i ] ) ans ++ ; i += 2 ; } System . out . println ( ans ) ; } }
public static int maxOR ( int [ ] arr , int n ) { int maxVal = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxVal = Math . max ( maxVal , arr [ i ] | arr [ j ] ) ; } } return maxVal ; }
public static int createSolution ( ) { class Solution { public int numJewelsInStones ( String J , String S ) { if ( J . length ( ) == 0 || S . length ( ) == 0 ) { return 0 ; } Set < Character > jSet = new HashSet < Character > ( Arrays . asList ( J ) ) ; int ans = 0 ; for ( char c : S . toCharArray ( ) ) { if ( jSet . contains ( c ) ) { ans ++ ; } } return ans ; } } if ( getClassName ( ) . equals ( " org . apache . commons . analysis . japanese " ) ) { Solution sObj = new Solution ( ) ; String J = " aA " ; String S = " aAAbbbb " ; int out = sObj . numJewelsInStones ( J , S ) ; System . out . println ( out ) ; } return 0 ; }
public static int MAX = 100 ; int n = 0 ; int [ ] store = new int [ MAX ] ; int [ ] [ ] graph = new int [ MAX ] [ MAX ] ; int [ ] [ ] d = new int [ MAX ] [ MAX ] ; /* ▁ for ▁ loop ▁ */ for ( int b = 1 ; b < b ; b ++ ) { for ( int j = i + 1 ; j < b ; j ++ ) { if ( ( graph [ store [ i ] ] [ store [ j ] ] ) == 0 ) { return false ; } } /* ▁ for ▁ loop ▁ */ int maxCliques = 0 ; for ( int i = i + 1 ; i <= n ; i ++ ) { store [ l ] = j ; if ( ( isClique ( l + 1 ) ) && ( isClique ( l + 1 ) ) ) { maxCliques = Math . max ( maxCliques , l ) ; maxCliques = Math . max ( maxCliques , maxCliques ) ; } } return maxCliques ; } if ( Class . forName ( " java . util . Vector " ) . getMethod ( " size " ) . invoke ( new Object [ ] { int [ ] edges = { { 1 , 2 } , { 2 , 3 } , { 3 , 1 } , { 4 , 3 } , { 4 , 1 } , { 4 , 2 } } } ) ) ; int size = edges . length ; n = 4 ; for ( int i = 0 ; i < size ; i ++ ) { graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 ; graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 ; d [ edges [ i ] [ 0 ] ] ++ ; d [ edges [ i ] [ 1 ] ] ++ ; } System . out . println ( maxCliques ( 0 , 1 ) ) ; return n ; }
static int setBitNumber ( int n ) { final int k = ( int ) ( Math . log ( n ) ) ; return 2 * k ; }
public static String R = lambda ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int s = Integer . parseInt ( input . nextLine ( ) ) ; int f = Integer . parseInt ( input . nextLine ( ) ) ; int d ; char c ; if ( s < f ) { d = 1 ; c = ' R ' ; } else { d = - 1 ; c = ' L ' ; } String res = " " ; int i = 1 ; int j = s ; int t = R . nextInt ( ) ; int l = R . nextInt ( ) ; int r = R . nextInt ( ) ; int k = 1 ; while ( j != f ) { if ( i > t && k < m ) { t = R . nextInt ( ) ; k ++ ; } if ( i == t && ( l <= j && j <= r || l <= j + d && r <= r ) ) { res += ' X ' ; } else { res += c ; j += d ; } i ++ ; } System . out . println ( res ) ; return res ; }
static int subsetPairNotDivisibleByK ( int [ ] arr , int N , int K ) { int [ ] f = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) { f [ arr [ i ] % K ] ++ ; } if ( ( K % 2 ) == 0 ) { f [ K / 2 ] = Math . min ( f [ K / 2 ] , 1 ) ; } int res = Math . min ( f [ 0 ] , 1 ) ; for ( int i = 1 ; i <= ( K / 2 ) ; i ++ ) { res += Math . max ( f [ i ] , f [ K - i ] ) ; } return res ; }
public static void main ( String [ ] lines ) { final int w = Integer . parseInt ( lines [ 0 ] ) ; final int m = Integer . parseInt ( lines [ 1 ] ) ; final int k = Integer . parseInt ( lines [ 2 ] ) ; int maxLength = 0 ; int availableDigits = ( int ) ( w / k ) ; while ( availableDigits > 0 ) { final int currentCostPerN = Integer . toString ( m ) . length ( ) ; final int sameCostUntil = 10 * ( currentCostPerN ) ; final int usableNumbers = sameCostUntil - m ; final int useDigits = usableNumbers * currentCostPerN ; m = sameCostUntil ; if ( availableDigits >= useDigits ) { maxLength += usableNumbers ; availableDigits -= useDigits ; } else { maxLength += ( int ) ( availableDigits / currentCostPerN ) ; availableDigits = 0 ; } } System . out . println ( maxLength ) ; }
static void printRoots ( int a , int b , int c ) { System . out . println ( Integer . toString ( 1 ) + " , ▁ " + c / ( a * 1.0 ) ) ; }
public static int [ ] [ ] [ ] memo = new int [ 32 ] [ 32 ] [ 32 ] ; int pos , fl , pr , bin ; if ( ( pos = 0 ) == bin . length ) return 1 ; if ( ( memo [ pos ] [ fl ] [ pr ] != - 1 ) && ( memo [ pos ] [ fl ] [ pr ] != - 1 ) ) return memo [ pos ] [ fl ] [ pr ] ; int val = 0 ; if ( ( bin = memo [ pos ] [ fl ] [ pr ] ) != - 1 ) { val = val + dp ( pos + 1 , fl , 0 , bin ) ; } else if ( ( bin = memo [ pos ] [ fl ] [ pr ] ) != - 1 ) { val = val + dp ( pos + 1 , 1 , 0 , bin ) ; } if ( ( pr == 0 ) && ( memo [ pos ] [ fl ] [ pr ] == - 1 ) ) { if ( ( fl == 1 ) && ( memo [ pos ] [ fl ] [ pr ] == - 1 ) ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } else if ( ( bin = memo [ pos ] [ fl ] [ pr ] ) != - 1 ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } } memo [ pos ] [ fl ] [ pr ] = val ; return val ; /* ▁ find ▁ Integers ▁ */ String bin = " " ; while ( ( num > 0 ) && ( num < 32 ) ) { if ( ( num % 2 ) != 0 ) bin += "1" ; else bin += "0" ; num /= 2 ; } bin = bin . substring ( 0 , bin . length ( ) - 1 ) ; /* ▁ find ▁ Integers ▁ */ if ( __name__ . equals ( " java " ) ) { int N = 12 ; System . out . println ( findIntegers ( N ) ) ; } return memo ; }
static int MaximumDecimalValue ( int [ ] [ ] mat , int n ) { int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = 0 ; } if ( ( mat [ 0 ] [ 0 ] == 1 ) && ( mat [ 0 ] [ 1 ] == 1 ) ) { dp [ 0 ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { if ( ( mat [ 0 ] [ i ] == 1 ) && ( mat [ 0 ] [ i ] == 1 ) ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 * i ; } else { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( ( mat [ i ] [ 0 ] == 1 ) && ( mat [ i ] [ 1 ] == 1 ) ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 * i ; } } else { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( ( mat [ i ] [ j ] == 1 ) && ( mat [ i ] [ j ] == 1 ) ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 * ( i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; }
static void createHash ( HashSet < Integer > hash1 , int maxElement ) { int prev = 0 , curr = 1 ; hash1 . add ( prev ) ; hash1 . add ( curr ) ; while ( ( curr = hash1 . indexOf ( ' ▁ ' , curr ) ) != - 1 ) { int temp = curr + prev ; hash1 . add ( temp ) ; prev = curr ; curr = temp ; } /* ▁ Find ▁ the ▁ FibonacciPair ▁ */ hash1 . clear ( ) ; createHash ( hash1 , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i >= 0 ) && ( ( i < maxElement ) || ( i < n ) ) ) { System . out . println ( i + " , ▁ " + ( n - i ) ) ; return ; } } System . out . println ( " - 1" ) ; if ( Class . isPrimitive ( ) ) { int N = 90 ; findFibonacciPair ( N ) ; } }
public static int countGroup ( int [ ] a , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xs = xs ^ a [ i ] ; } if ( xs == 0 ) return 0 ; return 0 ; }
static int maxLength ( String s , int n ) { int ans = - ( Integer . MAX_VALUE + 1 ) ; int [ ] A = new int [ n + 5 ] , L = new int [ n + 5 ] , R = new int [ n + 5 ] ; int [ ] freq = new int [ n + 5 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( int ) s . charAt ( j ) - ( int ) ' a ' ) == i ) count ++ ; freq [ j ] = count ; } for ( int j = 0 ; j < n ; j ++ ) { L [ j ] = ( 2 * freq [ j - 1 ] ) - j ; R [ j ] = ( 2 * freq [ j ] ) - j ; } int maxLen = - ( Integer . MAX_VALUE + 1 ) ; int minVal = Integer . MIN_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { minVal = Math . min ( minVal , L [ j ] ) ; A [ j ] = minVal ; int l = 0 ; int r = j ; int mid ; while ( ( l <= r ) && ( r <= maxLen ) ) { mid = ( l + r ) > > 1 ; if ( ( A [ mid ] <= R [ j ] ) && ( A [ mid ] <= R [ j ] ) ) { maxLen = Math . max ( maxLen , j - mid + 1 ) ; r = mid - 1 ; } else { l = mid + 1 ; } } } ans = Math . max ( ans , maxLen ) ; A [ 0 ] = 0 ; R [ 0 ] = 0 ; L [ 0 ] = 0 ; } return ans ; }
public static void main ( int N ) { int [ ] [ ] gr = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) gr [ i ] [ 0 ] = new int [ N ] ; int [ ] colour = new int [ N ] ; int [ ] [ ] edges = new int [ N ] [ N ] ; boolean bip = true ; /* ▁ Edge ▁ edge ▁ */ for ( int i = 0 ; i < gr [ 0 ] . length ; i ++ ) { gr [ 0 ] [ i ] = gr [ i ] [ 0 ] ; gr [ 1 ] [ i ] = gr [ i ] [ 1 ] ; edges [ i ] = new int [ N ] ; bip = false ; } /* ▁ Edge ▁ edge ▁ */ for ( int i = 0 ; i < gr [ 0 ] . length ; i ++ ) { if ( colour [ i ] == - 1 ) { /* ▁ Edge ▁ edge ▁ */ if ( colour [ i ] == col ^ 1 ) { /* ▁ Edge ▁ edge ▁ */ bip = false ; } } } /* ▁ Edge ▁ edge ▁ */ dfs ( 1 , 1 ) ; if ( ! bip ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i <= m ; i ++ ) { if ( colour [ edges [ i ] [ 0 ] ] == 0 ) { edges [ i ] [ 0 ] = edges [ i ] [ 1 ] ; edges [ i ] [ 1 ] = edges [ i ] [ 0 ] ; } System . out . println ( edges [ i ] [ 0 ] + " ▁ " + edges [ i ] [ 1 ] ) ; } }
input ; }
public static void main ( String input ) { int k = Integer . parseInt ( input . trim ( ) ) ; int n = Integer . parseInt ( input . trim ( ) ) ; int w = Integer . parseInt ( input . trim ( ) ) ; int sum = 0 ; for ( int i = 1 ; i <= w ; i ++ ) { sum += k * i ; } if ( sum <= n ) { System . out . println ( 0 ) ; } else { System . out . println ( sum - n ) ; } }
static boolean isPrime ( int k ) { int a , b , ans ; if ( ( k <= 1 ) && ( k % ( k - 1 ) == 0 ) ) { return false ; } for ( int i = 2 ; i < k ; i ++ ) { if ( ( k % i ) == 0 ) { return false ; } } /* ▁ check ▁ if ▁ ( num ▁ > = ▁ k ) ▁ */ { flag = 1 ; for ( int i = 2 ; i < k ; i ++ ) { if ( ( num % i ) == 0 ) { flag = 0 ; } } if ( ( flag == 1 ) && ( ( num % k ) == 0 ) ) { if ( ( num % k ) == 0 ) { return true ; } else { return false ; } } else { return false ; } } /* ▁ find ▁ count ▁ */ int count = 0 ; if ( ( ! isPrime ( k ) ) && ( count == 1 ) ) { return false ; } else { for ( int i = a ; i <= b ; i ++ ) { ans = check ( i , k ) ; if ( ( ans == 1 ) && ( k % ( k - 1 ) == 0 ) ) { count ++ ; } else { continue ; } } } /* ▁ find ▁ count ▁ */ if ( Class . isPrimitive ( ) ) { a = 2020 ; b = 6300 ; k = 29 ; System . out . println ( findCount ( a , b , k ) ) ; } return true ; }
private static String a = " abcdefghijklmnopqrstuvwxyz " ; int n , k ; n = Integer . parseInt ( input . nextLine ( ) ) ; t = a . substring ( 0 , 2 ) * n ; if ( k > n || ( k == 1 && n != 1 ) ) System . out . println ( - 1 ) ; else if ( n == 1 ) System . out . println ( " a " ) ; else return t . substring ( 0 , n - k + 2 ) + a . substring ( 2 , k ) ; }
public static int [ ] getNegativeInstances ( ) { int maxn = 16 ; int [ ] dp = new int [ maxn ] ; for ( int i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; int [ ] v = { 4 , 6 , 9 } ; for ( int i = 1 ; i < maxn ; i += 1 ) { for ( int k = 0 ; k < 3 ; k ++ ) { int j = v [ k ] ; if ( ( i >= j ) && ( dp [ i - j ] != - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } return dp ; }
static int countSquares ( int n ) { return ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) ; }
@ VisibleForTesting static int from ( String input ) { int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; List < Integer > al = Lists . newArrayList ( ) ; for ( int a : al ) { s += a ; s %= m ; modd . add ( s ) ; } int ans = 0 ; for ( int i : modd . values ( ) ) { ans += i * ( i - 1 ) / 2 ; } ans += modd . get ( 0 ) ; return ans ; }
static final int FindSubarray ( int [ ] arr , int n , int k ) { int [ ] countOne = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { countOne [ i ] = Integer . toBinaryString ( arr [ i ] ) . indexOf ( '1' ) ; } int sum = countOne [ 0 ] ; if ( ( n == 1 ) && ( ( k == 1 ) || ( ( k == 1 ) && ( ( k == 1 ) && ( ( k == 2 ) && ( ( k == 3 ) && ( ( k == 4 ) && ( k == 5 ) ) ) ) ) ) ) { if ( ( k == 1 ) || ( ( k == 2 ) && ( ( k == 3 ) && ( k == 4 ) ) ) ) { return 1 ; } else { return - 1 ; } } int ans = Integer . MAX_VALUE ; int i = 1 ; int j = 0 ; while ( ( i < n ) && ( ( k == 1 ) || ( ( k == 2 ) && ( ( k == 3 ) && ( k == 4 ) ) ) ) ) { if ( ( k == 1 ) || ( ( k == 2 ) && ( k == 3 ) ) ) { ans = 1 ; break ; } else if ( ( k == 1 ) || ( ( k == 2 ) && ( k == 3 ) ) ) { ans = 1 ; break ; } else if ( ( k == 1 ) || ( ( k == 2 ) && ( k == 3 ) ) ) { sum += countOne [ i ] ; i ++ ; } else if ( ( k == 1 ) && ( ( k == 2 ) && ( k == 3 ) ) ) { ans = Math . min ( ans , ( i - j ) + 1 ) ; sum -= countOne [ j ] ; j ++ ; } else if ( ( k == 1 ) && ( ( k == 2 ) && ( k == 3 ) ) ) { ans = Math . min ( ans , ( i - j ) + 1 ) ; sum += countOne [ i ] ; i ++ ; } } if ( ( ans != Integer . MAX_VALUE ) && ( k == 3 ) ) { return ans ; } else { return - 1 ; } }
public static void Loss ( int SP , int P ) { float loss = 0 ; loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) ; System . out . println ( " Loss ▁ = " + loss + " ▁ " ) ; }
public static int N ( ) { int M = Integer . parseInt ( input . nextLine ( ) ) ; int A = Integer . parseInt ( input . nextLine ( ) ) ; return A ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] sushi = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { sushi [ i ] = Integer . parseInt ( input ) ; } int res = 0 ; int before = 0 , after = 0 ; int cur = sushi [ 0 ] ; int i = 0 ; while ( i < n ) { if ( sushi [ i ] == cur ) { before ++ ; i ++ ; } else { int j = i ; int jS = sushi [ j ] ; cur = sushi [ j ] ; while ( j < n && sushi [ j ] == jS ) { after ++ ; j ++ ; } i = j ; res = Math . max ( res , Math . min ( before , after ) ) ; before = after ; after = 0 ; } } System . out . println ( res * 2 ) ; }
public static String compute ( ) { BigInteger ans = BigInteger . ONE ; for ( int i = 1 ; i < 10000000 ; i ++ ) { if ( getTerminal ( i ) . compareTo ( 89 ) == 0 ) { return ans . toString ( ) ; } } final Set < Integer > TERMINALS = new HashSet < Integer > ( ) ; { private static final long serialVersionUID = 1L ; @ Override public BigInteger getTerminal ( BigInteger n ) { while ( ! TERMINALS . contains ( n ) ) { n = squareDigitSum ( n ) ; } return n ; } private BigInteger squareDigitSum ( BigInteger n ) { BigInteger result = BigInteger . ZERO ; while ( n . compareTo ( BigInteger . ZERO ) > 0 ) { result += SQUARE_DIGITS_SUM . get ( n . mod ( 1000 ) ) ; n /= 1000 ; } return result ; } } ; SQUARE_DIGITS_SUM = new BigInteger [ 1000 ] ; for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { result += Integer . valueOf ( String . valueOf ( i ) ) ; } } if ( getClass ( ) . equals ( String . class ) ) { System . out . println ( compute ( ) ) ; } return " " ; }
public static int fact ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; } return fact ; /* ▁ Count ▁ the ▁ number ▁ of ▁ strings ▁ in ▁ the ▁ string ▁ */ { HashSet < String > distincChar = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { distincChar . add ( string . charAt ( i ) ) ; } return fact ( distincChar . size ( ) ) ; } if ( getClass ( ) . getName ( ) . equals ( " java . lang . String " ) ) { String string = " geeksforgeeks " ; int n = string . length ( ) ; System . out . println ( countStrings ( string , n ) ) ; } return fact ; }
public static void printCommonElements ( int M , int N ) { Map < Integer , Integer > mp = Maps . newHashMap ( ) ; for ( int j = 0 ; j < N ; j ++ ) { mp . put ( mat [ 0 ] [ j ] , 1 ) ; } for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( mp . containsKey ( mat [ i ] [ j ] ) ) && ( mp . get ( mat [ i ] [ j ] ) == i ) ) { mp . put ( mat [ i ] [ j ] , i + 1 ) ; if ( i == M - 1 ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } } } } }
static final String getUsage ( ) { final int INF = 10 * 18 + 3 ; final double EPS = 1e-10 ; final int MAX_CACHE = 10 * 9 ; return new String ( ) { @ Override public < R > R accept ( Function < R , R > function , PrintStream output ) { return function . apply ( ) ; } @ Override public R apply ( R input ) { long start = System . currentTimeMillis ( ) ; R res = function . apply ( input ) ; long elapsedTime = System . currentTimeMillis ( ) - start ; System . out . println ( String . format ( " \ " % s\ " ▁ took ▁ % f ▁ ms " , function . getName ( ) , elapsedTime * 1000 ) ) ; return res ; } } ; }
static public int [ ] line2int ( String linea ) { final int [ ] out = new int [ 2 ] ; String temp = " " ; for ( int i = 0 ; i < linea . length ( ) ; i ++ ) { if ( linea . charAt ( i ) == ' ▁ ' ) { if ( temp . length ( ) != 0 ) { final int val1 = Integer . parseInt ( temp ) ; temp = " " ; } } else { temp = temp + linea . charAt ( i ) ; } } final int val2 = Integer . parseInt ( temp ) ; return out ; }
static int sumOfAP ( int a , int d , int n ) { int sum = 0 ; int i = 0 ; while ( i < n ) { sum = sum + a ; a = a + d ; i = i + 1 ; } return sum ; }
static void find3Numbers ( int arr [ ] , int n ) { int small = + 2147483647 ; int large = + 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] <= small ) && ( arr [ i ] <= large ) ) { small = arr [ i ] ; } else if ( ( arr [ i ] <= large ) && ( arr [ i ] <= large ) ) { large = arr [ i ] ; } else { break ; } } if ( i == n ) { System . out . println ( " No ▁ such ▁ triplet ▁ found " ) ; } }
static void numbersWith3Divisors ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; prime [ 0 ] = prime [ 1 ] = false ; int p = 2 ; while ( ( p * p <= n ) && ( prime [ p ] ) ) { if ( ( prime [ p ] ) == true ) { for ( int i = p * 2 ; i <= n ; i += p ) { prime [ i ] = false ; } } p ++ ; } System . out . println ( " Numbers ▁ with ▁ 3 ▁ divisors " ) ; }
static int findPairCount ( int N , int K ) { int count = 0 ; int [ ] rem = new int [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) { rem [ i ] = ( N - i ) / K + 1 ; } if ( ( K % 2 ) == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) { count += rem [ i ] * rem [ K - i ] ; } count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = rage ( 1 , K / 2 + 1 ) ; i < K ; i ++ ) { count += rem [ i ] * rem [ K - i ] ; } } return count ; }
static final Scanner input = new Scanner ( System . in ) { @ Override public void close ( ) { Scanner input = new Scanner ( System . in ) ; while ( true ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == 0 && m == 0 ) break ; if ( n > 0 ) a = new LinkedList < > ( ) ; if ( m > 0 ) b = new LinkedList < > ( ) ; int ans = 0 ; int i = 0 , j = 0 ; int s = 0 , t = - 1 ; while ( i < n || j < m ) { if ( i < n ) { if ( s == a [ i ] ) i ++ ; if ( i < n ) t = a [ i ] ; } if ( j < m ) { if ( s == b [ j ] ) j ++ ; if ( j < m && ( t < 0 || b [ j ] < t ) ) t = b [ j ] ; } if ( t >= 0 ) { if ( i < n && t == a [ i ] ) i ++ ; if ( j < m && t == b [ j ] ) j ++ ; ans = Math . max ( ans , t - s ) ; s = t ; t = - 1 ; } } if ( t >= 0 ) ans = Math . max ( ans , t - s ) ; System . out . println ( ans ) ; } } }
public static int n ( ) { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = i ; return arr [ i ] ; }
public static double PHI = 1.6180339 ; int [ ] f = { 0 , 1 , 1 , 2 , 3 , 5 } ; /* ▁ fib ( int ▁ n ) ▁ */ if ( n < 6 ) return f [ n ] ; int t = 5 ; double fn = 5 ; while ( t < n ) { fn = Math . round ( fn * PHI ) ; }
static int kthSmallest ( int n , int k ) { return 2 * k ; } n = 8 ; k = 4 ; System . out . println ( kthSmallest ( n , k ) ) ; }
static void printSumTricky ( int [ ] [ ] mat , int k ) { int Sum ; int i , j ; if ( k > n ) return ; int [ ] [ ] stripSum = new int [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) { stripSum [ i ] [ j ] = null ; } for ( j = 0 ; j < n ; j ++ ) { Sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { Sum += mat [ i ] [ j ] ; } stripSum [ 0 ] [ j ] = Sum ; for ( i = 1 ; i <= n - k ; i ++ ) { Sum += ( mat [ i + k - 1 ] [ j ] - stripSum [ i ] [ j - 1 ] ) ; System . out . print ( Sum ) ; } } }
public static LinkedList < Integer > M = new LinkedList < Integer > ( ) { { for ( int i = 0 ; i < input . length ( ) ; i ++ ) { int a = input . nextInt ( ) ; int b = input . nextInt ( ) ; int n = input . nextInt ( ) ; if ( a != 0 ) { if ( b % a != 0 ) { System . out . println ( " No ▁ solution " ) ; } else { b = b / a ; int x = 0 , y = - 2000 ; if ( b >= 0 ) { while ( y < b ) { y = Math . pow ( x , n ) ; x = x + 1 ; } if ( y > b ) { System . out . println ( " No ▁ solution " ) ; } else { System . out . println ( x - 1 ) ; } } else { if ( n % 2 == 0 ) { System . out . println ( " No ▁ solution " ) ; } else { x = - 1 ; y = 2000 ; while ( y > b ) { y = Math . pow ( x , n ) ; x = x - 1 ; } if ( y < b ) { System . out . println ( " No ▁ solution " ) ; } else { System . out . println ( x + 1 ) ; } } } } } else { if ( b == 0 ) { System . out . println ( 5 ) ; } else { System . out . println ( " No ▁ solution " ) ; } } } } }
public static long ncr ( long n , long r ) { long ans = 1 ; for ( long i = 1 ; i <= r ; i ++ ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
static int nextPowerOf2 ( int n ) { int count = 0 ; if ( ( n > 0 ) && ! ( n > 0 ) && ( n > 0 ) ) { return n ; } while ( n != 0 ) { n >>= 1 ; count ++ ; } return 1 << count ; /* ▁ remove ▁ the ▁ first ▁ element ▁ from ▁ the ▁ last ▁ 2 ▁ */ }
public static int N = Integer . parseInt ( input ) { int P = Integer . parseInt ( input . nextLine ( ) ) ; /* ▁ combi ▁ */ int a = 1 ; for ( int i = 0 ; i < K ; i ++ ) { a *= N - i ; } for ( int j = 0 ; j < K ; j ++ ) { a /= j + 1 ; } /* ▁ ans ▁ */ int ans = 0 ; LinkedList < Integer > lis = new LinkedList < Integer > ( ) ; for ( int a : lis ) { ls . add ( a % 2 ) ; } int one = ls . size ( ) ; int zero = ls . size ( ) ; double pattern_a = 0 ; double pattern_b = 0 ; for ( int j = 0 ; j < zero + 1 ; j ++ ) { pattern_b += combi ( zero , j ) ; } int time = 0 ; while ( time <= one ) { if ( time % 2 == P ) { pattern_a += combi ( one , time ) ; } time ++ ; } System . out . println ( ( int ) ( pattern_a * pattern_b ) ) ; return ans ; }
static int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) { if ( ( ( a * x ) % m ) == 1 ) { return x ; } } return 1 ; }
static int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; /* ▁ Count ▁ numbers ▁ */ }
static void findGreater ( int a , int b ) { final int x = a * ( Math . log ( b ) ) ; final int y = b * ( Math . log ( a ) ) ; if ( ( y > x ) && ( y < x ) ) { System . out . println ( " a ^ b ▁ is ▁ greater " ) ; } else { } }
static final int findAnswer ( String str1 , String str2 , int n ) { int l = 0 , r = 0 ; int ans = 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( str1 . charAt ( i ) != str2 . charAt ( i ) ) ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ( str1 . charAt ( i ) != str2 . charAt ( i ) ) ) { r = i ; break ; } } if ( ( r < l ) && ( l == r ) ) return 26 * ( n + 1 ) ; else if ( l == r ) return ans ; else return ans ; }
public static int t = Integer . parseInt ( input ) { for ( int p = 0 ; p < t ; p ++ ) { int n = Integer . parseInt ( input . readLine ( ) ) ; int x = Integer . parseInt ( input . readLine ( ) ) ; int m = Integer . parseInt ( input . readLine ( ) ) ; int L = x ; int R = x ; for ( int i = 0 ; i < m ; i ++ ) { int l = ( Integer . parseInt ( input . readLine ( ) ) ) ; int r = ( Integer . parseInt ( input . readLine ( ) ) ) ; if ( l <= R && r >= L ) { L = Math . min ( L , l ) ; R = Math . max ( R , r ) ; } } System . out . println ( R - L + 1 ) ; } return t ; }
static boolean bitsAreInAltPatrnInGivenTRange ( int n , int l , int r ) { int num = n > > ( l - 1 ) ; int prev = num & 1 ; num = num > > 1 ; for ( int i = 1 ; i < ( r - l ) ; i ++ ) { int curr = num & 1 ; if ( ( curr == prev ) && ( prev != 0 ) ) { return false ; } prev = curr ; num = num > > 1 ; } return true ; }
static final Scanner in = new Scanner ( System . in ) { public int next ( ) { return Integer . parseInt ( in . nextLine ( ) ) ; } }
public static int nthGroup ( int n ) { return n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; }
public static int [ ] [ ] [ ] a ( ) { int a = 0 ; int r = 0 , c = - 1 ; int [ ] [ ] dl = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] tl = new int [ n ] ; for ( int j = 0 ; j < tl . length ; j ++ ) tl [ j ] = Integer . parseInt ( input . nextLine ( ) ) ; if ( c < 0 && tl [ j ] [ 0 ] == 0 ) { r = i ; c = tl [ j ] [ 0 ] ; } dl [ i ] = tl ; } int s = Integer . parseInt ( dl [ ( r + 1 ) % n ] [ 0 ] ) ; a = s - 1 ; return dl ; }
static final Scheduler in = new Scheduler ( ) { @ Override public int nextInt ( ) { return ( Integer . parseInt ( input . nextLine ( ) ) ) ; } @ Override public List < Integer > inlt ( ) { return ( Collections . singletonList ( Integer . parseInt ( input . nextLine ( ) ) ) ) ; } @ Override public List < Integer > insr ( ) { String s = input . nextLine ( ) ; return ( Collections . singletonList ( s . substring ( 0 , s . length ( ) - 1 ) ) ) ; } @ Override public List < Integer > invr ( ) { return ( Collections . singletonList ( Integer . parseInt ( input . nextLine ( ) ) ) ) ; } }
static int maximumOccurredElement ( int L [ ] , int R [ ] , int n ) { int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { arr [ L [ i ] ] ++ ; arr [ R [ i ] + 1 ] -- ; } int msum = arr [ 0 ] ; for ( int i = 1 ; i < MAX ; i += 1 ) { arr [ i ] += arr [ i - 1 ] ; if ( ( msum < arr [ i ] ) && ( arr [ i ] > msum ) ) { msum = arr [ i ] ; ind = i ; } } return ind ; }
public static void print ( int n ) { int back = input . nextInt ( ) ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int p = input . nextInt ( ) ; if ( p > 0 && p == back ) count ++ ; back = p ; } System . out . println ( count + 1 ) ; }
public static void print ( int n , int m ) { int min , max ; n = Integer . parseInt ( input . nextLine ( ) ) ; m = Integer . parseInt ( input . nextLine ( ) ) ; if ( n < 1 ) { if ( m < 1 ) { print ( n , m ) ; quit ( ) ; } print ( " Impossible " ) ; quit ( ) ; } if ( m > n ) { min = m ; max = n + m - 1 ; print ( min , max ) ; } if ( m <= n ) { min = n ; max = n + m - 1 ; if ( m == 0 ) { max = n ; } print ( min , max ) ; } }
public static double func ( int x ) { return ( ( double ) 1 ) / ( 1 + x * x ) ; /* calculate ▁ the ▁ sum ▁ of ▁ the ▁ lower ▁ limit ▁ */ double intervalSize = ( ( double ) ( upperLimit - lowerLimit ) ) / intervalSize ; double sum = func ( lowerLimit ) + func ( upperLimit ) ; for ( int i = 1 ; i < intervalSize ; i ++ ) { if ( ( i % 3 ) == 0 ) sum = sum + 2 * func ( lowerLimit + i * intervalSize ) ; else sum = sum + 3 * func ( lowerLimit + i * intervalSize ) ; } return ( ( ( double ) 3 * intervalSize ) / 8 ) * sum ; }
public static void print ( int N ) { int K = Integer . parseInt ( input . nextLine ( ) ) ; int X = Integer . parseInt ( input . nextLine ( ) ) ; int Y = Integer . parseInt ( input . nextLine ( ) ) ; if ( N <= K ) { print ( ( int ) ( N * X ) ) ; } else { print ( ( int ) ( K * X + ( N - K ) * Y ) ) ; } }
static final double solve ( ) { double x ; double h ; double l ; do { x = Double . parseDouble ( input . nextLine ( ) ) ; if ( x == 0 ) { break ; } h = Double . parseDouble ( input . nextLine ( ) ) ; l = Math . sqrt ( 0.25 * x * x + h * h ) ; System . out . println ( x * x + 2 * x * l ) ; } while ( true ) ; return x ; }
public static int k ( ) { int i = 10 ; while ( k > 0 ) { i += 9 ; if ( Integer . parseInt ( String . valueOf ( i ) ) == 10 ) { k -- ; } } return i ; }
@ VisibleForTesting static void sieve ( ) { final int MAX = 100000 ; final boolean [ ] prime = new boolean [ MAX ] ; new Thread ( ) { @ Override public void run ( ) { for ( int p = 2 ; p <= ( int ) Math . sqrt ( MAX ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } } } . start ( ) ; new Thread ( ) { @ Override public void run ( ) { for ( int n = 0 ; n < MAX - 7 ; n ++ ) { for ( int i = 0 ; i < n - 7 ; i ++ ) { if ( ( prime [ i ] && prime [ i + 2 ] ) && ( prime [ i + 6 ] && prime [ i + 8 ] ) ) { System . out . println ( i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + i + " ▁ " + i + " ▁ " + i + i + " ▁ " + i + i + " ▁
static int maxSubsequenceSubstring ( String x , String y , int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { dp [ i ] [ i ] = 0 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( ( x . charAt ( j - 1 ) == y . charAt ( i - 1 ) ) && ( x . charAt ( j ) == y . charAt ( i ) ) ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans = Math . max ( ans , dp [ i ] [ n ] ) ; } return ans ; }
static int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( i % a == 0 ) || ( i % b == 0 ) ) { sum += i ; } } if ( getClass ( ) . getName ( ) . equals ( " java . lang . Integer " ) ) { n = 10 ; a = 3 ; b = 5 ; System . out . println ( findSum ( n , a , b ) ) ; } return sum ; }
@ Implementation public static void main ( String [ ] args ) { int [ ] st = new int [ Integer . MAX_VALUE ] ; int [ ] av = new int [ Integer . MIN_VALUE ] ; String s = input ( args ) ; String t = input ( args ) ; Set < String > se = new HashSet < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) se . add ( s . toLowerCase ( ) ) ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) av [ t . charAt ( i ) ] ++ ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) st [ i ] ++ ; int y = 0 , w = 0 ; for ( String i : se ) { String j = i . toUpperCase ( ) ; int a = Math . min ( st [ i ] , av [ i ] ) , b = Math . min ( st [ j ] , av [ j ] ) ; y += a + b ; st [ i ] -= a ; st [ j ] -= b ; av [ i ] -= a ; av [ j ] -= b ; int c = Math . min ( st [ i ] , av [ j ] ) , d = Math . min ( st [ j ] , av [ i ] ) ; w += c + d ; } System . out . println ( y + " ▁ " + w ) ; }
static int MAX = 1000 ; int [ ] sequence = new int [ MAX + 1 ] ; /* vanEckSequence */ for ( int i = 0 ; i < MAX ; i ++ ) { sequence [ i ] = 0 ; } for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( ( sequence [ j ] == sequence [ i ] ) && ( sequence [ j ] == sequence [ i ] ) ) { sequence [ i + 1 ] = i - j ; break ; } } } /* getNthTerm */ int n = sequence [ n ] ; if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { /* vanEckSequence */ n = 6 ; System . out . println ( getNthTerm ( n ) ) ; n = 100 ; System . out . println ( getNthTerm ( n ) ) ; } return n ; }
static int MAX = 10000 ; int [ ] sequence = new int [ MAX + 1 ] ; int i ; int n ; /* vanEckSequence */ for ( i = 0 ; i < MAX ; i ++ ) { for ( j = i - 1 ; j >= 0 ; j -- ) { if ( ( sequence [ j ] = sequence [ i ] ) == 0 ) { sequence [ i + 1 ] = i - j ; break ; } } } /* count */ int count = 1 ; i = n - 1 ; while ( ( sequence [ i + 1 ] = sequence [ i ] ) != 0 ) { count ++ ; i = i - sequence [ i + 1 ] ; } /* count */ if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { /* vanEckSequence */ int n = 5 ; System . out . println ( getCount ( n ) ) ; n = 11 ; System . out . println ( getCount ( n ) ) ; } /* count */ if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { /* vanEckSequence */ int n = 10 ; System . out . println ( getCount ( n ) ) ; n = 11 ; System . out . println ( getCount ( n ) ) ; } return n ; }
static int MAX = 10000 ; int [ ] sequence = new int [ MAX + 1 ] ; { int i ; int n ; int nthTerm ; int count ; { for ( i = 0 ; i < MAX ; i ++ ) { for ( j = i - 1 ; j >= 0 ; j -- ) { if ( ( sequence [ j ] = sequence [ i ] ) == 0 ) { sequence [ i + 1 ] = i - j ; break ; } } } } { int nthTerm ; nthTerm = sequence [ n - 1 ] ; count = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( sequence [ i ] = nthTerm ) == 0 ) { count ++ ; } } return count ; } }
static int nthElement ( int a , int b , int n ) { final int lcm = ( a * b ) / ( int ) Math . gcd ( a , b ) ; int l = 1 ; int r = Math . min ( a , b ) * n ; while ( ( l <= r ) && ( r <= lcm ) ) { final int mid = ( l + r ) > > > 1 ; final int val = ( ( int ) ( mid / a ) + ( int ) ( mid / b ) - ( int ) ( mid / lcm ) ) ; if ( ( val == n ) ) { return ( int ) Math . max ( val , n ) ; } } }
static final int getDayOfYear ( ) { int y = Integer . parseInt ( input . nextLine ( ) ) ; boolean isRun = CalendarUtils . isLeapYear ( y ) ; int week = CalendarUtils . getWeekOfDayOfYear ( y , 1 , 1 ) ; do { y = y + 1 ; } while ( CalendarUtils . isLeapYear ( y ) == isRun && CalendarUtils . getWeekOfDayOfYear ( y , 1 , 1 ) == week ) ; System . out . println ( y ) ; return y ; }
public static int N = Integer . parseInt ( input ) { int [ ] base = new int [ 3 ] ; int out = 0 ; int point = 0 ; int inning = 0 ; while ( true ) { String event = input . next ( ) ; if ( event . equals ( " HIT " ) ) { if ( base [ 2 ] == 1 ) { point ++ ; } base [ 2 ] = base [ 1 ] ; base [ 1 ] = base [ 0 ] ; base [ 0 ] = 1 ; } else if ( event . equals ( " HOMERUN " ) ) { point += Arrays . stream ( base ) . mapToInt ( Integer :: intValue ) . sum ( ) + 1 ; base = new int [ 3 ] ; } else if ( event . equals ( " OUT " ) ) { out ++ ; if ( out == 3 ) { System . out . println ( point ) ; inning ++ ; if ( inning == N ) { break ; } base = new int [ 3 ] ; out = 0 ; point = 0 ; } } } return point ; }
private static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) { return 0 ; } if ( ( a == b ) ) { return a ; } if ( ( a > b ) && ( b > a ) ) { return gcd ( a - b , b ) ; } return gcd ( a , b - a ) ; }
public static void foot ( int a , int b , int c , int d , int x1 , int y1 , int z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; System . out . print ( " x2 ▁ = " + x2 + " , ▁ " ) ; System . out . print ( " y2 ▁ = " + y2 + " , ▁ " ) ; System . out . print ( " z2 ▁ = " + z2 + " , ▁ " ) ; }
c = new int [ 2 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { c [ i ] = input . nextInt ( ) ; } if ( c [ 0 ] [ 0 ] == c [ 1 ] [ 2 ] && c [ 0 ] [ 1 ] == c [ 1 ] [ 1 ] && c [ 0 ] [ 2 ] == c [ 1 ] [ 0 ] ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } return c [ 0 ] [ 1 ] ; }
static int getMinimumOps ( int [ ] ar ) { int n = ar . length ; int small = min ( ar ) ; int large = max ( ar ) ; int [ ] [ ] dp = new int [ large + 1 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int j = small ; j <= large ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( ar [ 0 ] - j ) ; for ( int i = 1 ; i < n ; i ++ ) { int minimum = 10 * 9 ; for ( int j = small ; j <= large ; j ++ ) { minimum = Math . min ( minimum , dp [ i - 1 ] [ j ] ) ; dp [ i ] [ j ] = minimum + Math . abs ( ar [ i ] - j ) ; } } int ans = 10 * 9 ; for ( int j = small ; j <= large ; j ++ ) ans = Math . min ( ans , dp [ n - 1 ] [ j ] ) ; return ans ; }
PI = 3.14159265 ; public static double areaLeaf ( double a ) { return ( a * a * ( PI / 2 - 1 ) ) ; }
static int removeAlternate ( int n ) { if ( ( n == 1 ) && ( n == 2 ) ) { return 1 ; } if ( ( n % 2 ) == 0 ) { return 2 * removeAlternate ( n / 2 ) - 1 ; } return 1 ; }
static void check ( int n , int m ) { if ( ( n == 2 ) || ( m == 2 ) || ( n % m == 0 ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
public static boolean solve ( int [ ] a , int n , int m ) { int [ ] b = new int [ a . length ] ; boolean flag = false ; for ( int i = 0 ; i < a . length ; i ++ ) { int curr = a [ i ] / n ; if ( curr >= 3 ) { flag = true ; } if ( curr >= 2 ) { b [ i ] = curr ; } } if ( m % 2 == 1 ) { if ( ! flag ) { return false ; } } return Arrays . binarySearch ( b , b ) >= m ; } for ( int t = 0 ; t < Integer . parseInt ( input ( ) ) ; t ++ ) { n = Integer . parseInt ( input ( ) ) ; m = Integer . parseInt ( input ( ) ) ; int k = Integer . parseInt ( input ( ) ) ; List < Integer > list = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { list . add ( i ) ; } Collections . sort ( list ) ; if ( solve ( list . toArray ( ) , n , m ) || solve ( list . toArray ( ) , m , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
static int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 ; int negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] > 0 ) && ( arr [ i ] < 0 ) ) { arr [ i ] = 1 ; } else { arr [ i ] = - 1 ; } if ( ( arr [ i ] > 0 ) && ( arr [ i ] < 0 ) ) { arr [ i ] *= arr [ i ] - 1 ; } if ( ( arr [ i ] > 0 ) && ( arr [ i ] < 0 ) ) { arr [ i ] *= arr [ i ] ; } } return ( positive * negative ) ; }
static int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 ; int negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] > 0 ) && ( arr [ i ] < 0 ) ) { arr [ i ] = 1 ; } else { arr [ i ] = - 1 ; } if ( ( arr [ i ] > 0 ) && ( arr [ i ] < 0 ) ) { arr [ i ] *= arr [ i - 1 ] ; } if ( ( arr [ i ] == 1 ) && ( arr [ i ] == 0 ) ) { positive ++ ; } else { negative ++ ; } } return ( positive * negative ) ; }
static int solve ( ) { final Scanner input = new Scanner ( System . in ) ; final int n = input . nextInt ( ) ; final int k = input . nextInt ( ) ; int cnt = 1 ; int ans = 0 ; while ( cnt <= k && cnt < n ) { cnt *= 2 ; ans ++ ; } if ( cnt >= n ) { return ans ; } else { ans += ( n - cnt ) / k ; ans += ( n - cnt ) % k > 0 ? 1 : 0 ; return ans ; } }
public static int GCD ( int a , int b ) { while ( a % b != 0 ) { a = b ; b = a % b ; } /* ▁ LCM ▁ */ String [ ] l = input . split ( " \\s + " ) ; int x = Integer . parseInt ( l [ 0 ] ) , y = Integer . parseInt ( l [ 1 ] ) , a = Integer . parseInt ( l [ 2 ] ) , b = Integer . parseInt ( l [ 3 ] ) ; int lcm = LCM ( x , y ) ; System . out . println ( b / lcm - ( a - 1 ) / lcm ) ; }
static int minRemove ( int [ ] arr , int n ) { int [ ] LIS = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 0 ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] > arr [ j ] ) && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return ( n - len ) ; }
public static void printMax ( int [ ] a , int n , int k ) { int [ ] maxUpto = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) maxUpto [ i ] = 0 ; int [ ] s = new int [ n ] ; s [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ( s . length > 0 ) && a [ s [ s . length - 1 ] ] < a [ i ] ) { maxUpto [ s . length - 1 ] = i - 1 ; -- s [ s . length - 1 ] ; } s [ s . length - 1 ] = i ; } while ( s . length > 0 ) { maxUpto [ s . length - 1 ] = n - 1 ; -- s [ s . length - 1 ] ; } }
public static String compute ( ) { int ans = Math . max ( Integer . valueOf ( String . valueOf ( a * b ) ) , Integer . valueOf ( String . valueOf ( a * b ) ) ) ; return String . valueOf ( ans ) ; }
static final long countWindowDistinct ( int [ ] win , int k ) { long distCount = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int j = 0 ; while ( j < i ) { if ( ( win [ i ] == win [ j ] ) && ( j < i ) ) break ; else j ++ ; } if ( ( j == i ) && ( distCount == 0 ) ) distCount ++ ; } return distCount ; }
public static int evenNumSubstring ( String str ) { int length = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < length ; i += 1 ) { int temp = ( str . charAt ( i ) - '0' ) ; if ( ( temp % 2 ) == 0 ) { count += ( i + 1 ) ; } } return count ; }
public static int countWays ( int index , int cnt , int [ ] [ ] dp , int n , int m , int k ) { if ( ( index == n ) && ( ( cnt == k ) && ( index == n ) ) ) { if ( ( ( index == n ) && ( ( index == m ) && ( index == k ) ) ) { return 1 ; } else { return 0 ; } } if ( ( dp [ index ] [ cnt ] != - 1 ) && ( index == n ) ) { return dp [ index ] [ cnt ] ; } int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; dp [ index ] [ cnt ] = ans ; return dp [ index ] [ cnt ] ; }
@ VisibleForTesting static int getSum ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { summ += i ; } else { summ += i ; summ += n / i ; } } } return summ - n ; /* ▁ print ▁ Aliquot ▁ */ System . out . print ( n + " ▁ " ) ; Set < Integer > s = new HashSet < Integer > ( ) ; s . add ( n ) ; int nextt = 0 ; while ( n > 0 ) { n = getSum ( n ) ; if ( s . contains ( n ) ) { System . out . println ( " Repeats ▁ with " + n ) ; break ; } System . out . print ( n + " ▁ " ) ; s . add ( n ) ; } if ( className . equals ( " java . lang . String " ) ) { printAliquot ( 12 ) ; } return s . size ( ) ; }
public static int [ ] getThemes ( int n , int a , int b ) { int [ ] lista = new int [ n ] ; int [ ] listb = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lista [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; for ( int k = 0 ; k < n ; k ++ ) { if ( lista [ k + 1 ] >= listb [ k ] ) System . out . print ( 1 + " ▁ " ) ; else System . out . print ( 2 + " ▁ " ) ; } return lista ; }
static void reverseArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { arr [ i ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] ; } arr [ 0 ] = 5 ; arr [ 1 ] = 3 ; arr [ 2 ] = 7 ; arr [ 3 ] = 2 ; arr [ 4 ] = 1 ; arr [ 5 ] = 6 ; int len = arr . length ; reverseArray ( arr , n ) ; for ( int i = 0 ; i < len ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
static void printSeriesSum ( int N ) { int sum = 0 ; int a = 1 ; int cnt = 0 ; boolean flag = true ; sum += a ; while ( ( cnt < N ) && ( a = a * 2 ) != 0 ) { int nextElement = 0 ; if ( ( flag ) && ( a = a * 2 ) != 0 ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * ( 3 / 2 ) ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } System . out . println ( sum ) ; }
public static long gcd ( long a , long b ) { if ( a == 0 ) { return b ; } else { return gcd ( b % a , a ) ; } int t = Integer . parseInt ( input . nextLine ( ) ) ; while ( t > 0 ) { t -- ; a = Integer . parseInt ( input . nextLine ( ) ) ; b = Integer . parseInt ( input . nextLine ( ) ) ; long c = gcd ( a , b ) ; a = a / c ; b = b / c ; long ans1 ; long ans2 ; if ( a == b ) { ans1 = 1 ; ans2 = 0 ; } else if ( a % 2 == 0 || b % 2 == 0 ) { ans1 = 1 ; ans2 = 1 ; } else { ans1 = a * b / 2 + 1 ; ans2 = a * b / 2 ; } System . out . println ( ans1 + " ▁ " + ans2 ) ; } return a ; }
@ VisibleForTesting static int minDifference ( int L , int R ) { int sz = ( int ) 1e5 ; boolean [ ] isPrime = new boolean [ sz + 1 ] ; { sieve ( ) ; } private void sieve ( ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= ( int ) Math . sqrt ( sz ) ; i ++ ) { if ( ( isPrime [ i ] = true ) && ( isPrime [ i ] ) ) { for ( int j = i * i ; j <= sz ; j += i ) { isPrime [ j ] = false ; } } } } private int minDifference ( int L , int R ) { int fst = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( ( isPrime [ i ] = true ) && ( isPrime [ i ] ) ) { fst = i ; break ; } } int snd = 0 ; for ( int i = fst + 1 ; i <= R ; i ++ ) { if ( ( isPrime [ i ] = true ) && ( isPrime [ i ] ) ) { snd = i ; break ; } } if ( ( snd == 0 ) && ( isPrime [ 0 ] ) ) { return - 1 ; } int diff = snd - fst ; int left = snd + 1 ; int right = R ; for ( int i = left ; i <= right ; i ++ ) { if ( ( isPrime [ i ] = true ) && ( isPrime [ i ] ) ) { if ( ( i - snd ) <= diff ) { fst = snd ; snd = i ; diff = snd - fst ; } } } return diff ; } if ( className == " java . lang . Object " ) { sieve ( ) ; int L = 21 ; int R = 50 ; System . out . println ( minDifference ( L , R ) ) ; } return - 1 ; }
static int getMaxLength ( int [ ] arr , int n ) { int start = 0 ; int preCnt = 0 ; while ( ( start < n ) && arr [ start ] == 1 ) { preCnt = preCnt + 1 ; start = start + 1 ; } int end = n - 1 ; int suffCnt = 0 ; while ( ( end >= 0 ) && arr [ end ] == 1 ) { suffCnt = suffCnt + 1 ; end = end - 1 ; } if ( ( start > end ) && ( arr [ start ] == 1 ) ) { return n ; } int midCnt = 0 ; int i = start ; int result = 0 ; while ( ( i <= end ) && ( arr [ i ] == 1 ) ) { midCnt = midCnt + 1 ; result = Math . max ( result , midCnt ) ; } else { midCnt = 0 ; } return Math . max ( result , preCnt + suffCnt ) ; }
public static int INF = 10 ** 20 ; int d = Integer . parseInt ( input . readLine ( ) ) ; int n = Integer . parseInt ( input . readLine ( ) ) ; int [ ] temp = new int [ d ] ; for ( int i = 0 ; i < d ; i ++ ) temp [ i ] = Integer . parseInt ( input . readLine ( ) ) ; temp [ 0 ] = 0 ; int [ ] alst = new int [ n ] ; int [ ] blst = new int [ n ] ; int [ ] clst = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = Integer . parseInt ( input . readLine ( ) ) ; int b = Integer . parseInt ( input . readLine ( ) ) ; int c = Integer . parseInt ( input . readLine ( ) ) ; alst [ i ] = a ; blst [ i ] = b ; clst [ i ] = c ; } int [ ] [ ] dp = new int [ d + 1 ] [ n ] ; for ( int i = 0 ; i < d ; i ++ ) dp [ i ] [ i ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int t = temp [ j ] ; for ( int x = 0 ; x < n ; x ++ ) if ( alst [ j ] <= t && t <= blst [ j ] ) dp [ i ] [ x ] = Math . max ( dp [ i - 1 ] [ x ] + Math . abs ( clst [ j ] - clst [ x ] ) ) ; } System . out . println ( Math . max ( dp [ d ] ) ) ; return d ; }
public static void f ( String s ) { for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) < s . charAt ( i - 1 ) ) { System . out . println ( " YES " ) ; System . out . println ( i + 1 ) ; return ; } } System . out . println ( " NO " ) ; }
public static double sqroot ( double s ) { double pSq = 0 ; double N = 0 ; for ( int i = ( int ) s ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( ( j * j == i ) && ( j > 0 ) ) { pSq = i ; N = j ; break ; } } if ( ( pSq > 0 ) && ( i > 0 ) ) break ; } double d = s - pSq ; double P = d / ( 2.0 * N ) ; double A = N + P ; double sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] arr = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = Integer . parseInt ( input ) ; } int ans = - 1 ; int temp = 0 ; Set < Integer > set = new HashSet < Integer > ( ) ; int p = 0 ; while ( set . size ( ) != n ) { ans ++ ; if ( p % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ! set . contains ( i ) && arr [ i ] <= temp ) { set . add ( i ) ; temp ++ ; } } p ++ ; } else { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ! set . contains ( i ) && arr [ i ] <= temp ) { set . add ( i ) ; temp ++ ; } } p ++ ; } } System . out . println ( ans ) ; }
public static void loop ( ) { int R = Integer . parseInt ( input . readLine ( ) ) ; int N = Integer . parseInt ( input . readLine ( ) ) ; if ( R == 0 | N == 0 ) break ; int geta = 20 ; int [ ] buildings = new int [ geta * 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { int xl = Integer . parseInt ( input . readLine ( ) ) ; int xr = Integer . parseInt ( input . readLine ( ) ) ; int h = Integer . parseInt ( input . readLine ( ) ) ; for ( int j = xl + geta ; j <= xr ; j ++ ) { buildings [ j ] = Math . max ( buildings [ j ] , h ) ; } } int left = 0 , right = 20 ; for ( int i = 0 ; i < 100 ; i ++ ) { int mid = ( left + right ) / 2 ; boolean flag = true ; for ( int j = - R + geta ; j <= R + geta ; j ++ ) { if ( j < geta ) { double y = Math . pow ( R * R - ( j - geta + 1 ) * ( j - geta + 1 ) , 0.5 ) ; flag &= buildings [ j ] >= y - R + mid ; } else { double y = Math . pow ( R * R - ( j - geta ) * ( j - geta ) , 0.5 ) ; flag &= buildings [ j ] >= y - R + mid ; } } if ( flag ) left = mid ; else right = mid ; } System . out . println ( left + " { : . 20f } " ) ; }
public static void for ( String s : Arrays . asList ( new String [ ] { " " } , new String [ ] { " " } , new String [ ] { " " } ) ) { int i = 0 ; int r = 0 ; for ( String x : new ArrayList < String > ( Arrays . asList ( s . split ( " ▁ " ) ) ) ) i ++ ; r = ( i == 0 ) ? r : ( x > i ) ? i : r ; System . out . println ( r + 1 ) ; }
public static void print ( ) { int n ; do { n = Integer . parseInt ( input . nextLine ( ) ) ; } while ( n == 0 ) ; System . out . println ( Integer . toString ( n ) . replaceAll ( "4567" , "5789" ) ) ; }
static double maxAlternateSum ( double [ ] arr , int n ) { if ( ( n == 1 ) && ( arr [ 0 ] == 0 ) ) return arr [ 0 ] ; double [ ] dec = new double [ n + 1 ] ; double [ ] inc = new double [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) dec [ i ] = inc [ i ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] > arr [ i ] ) && ( flag == 1 ) ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] ) ; flag = 1 ; } } } double result = Double . NEGATIVE_INFINITY ; for ( int i = 0 ; i < n ; i ++ ) result = arr [ i ] ; return result ; }
static void generateArr ( int [ ] arr , int n ) { if ( ( n == 1 ) && ( arr [ 0 ] == 0 ) ) { System . out . println ( arr [ 0 ] ) ; return ; } int [ ] barr = new int [ n ] ; barr [ 0 ] = arr [ 0 ] & arr [ 1 ] ; barr [ n - 1 ] = arr [ n - 1 ] & arr [ n - 2 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { barr [ i ] = arr [ i - 1 ] & arr [ i + 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( barr [ i ] + " ▁ " ) ; } if ( getClass ( ) . isAnonymousClass ( ) ) { arr = Arrays . copyOf ( arr , n ) ; n = arr . length ; generateArr ( arr , n ) ; } }
private static void ReplaceElements ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; arr = Arrays . copyOf ( arr , n ) ; arr [ n - 1 ] = 2 ; arr [ n - 1 ] = 3 ; arr [ n - 1 ] = 4 ; arr [ n - 1 ] = 5 ; arr [ n - 1 ] = 6 ; n = arr . length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
private static void replaceElements ( int [ ] arr , int n ) { if ( ( n <= 1 ) || ( n == 0 ) ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev + arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev + arr [ n - 1 ] ; } if ( getClass ( ) . isArray ( ) ) { int [ ] array = { 2 , 3 , 4 , 5 , 6 } ; int len = arr . length ; replaceElements ( arr , n ) ; for ( int i = 0 ; i < len ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
static int countTriplets ( int A , int B , int C ) { int ans = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( ( i * k > j * j ) ) ans ++ ; } } } return ans ; }
@ VisibleForTesting static void prime ( ) { final int MAX = 100000 ; final boolean [ ] prime = new boolean [ MAX + 1 ] ; new Thread ( ) { @ Override public void run ( ) { for ( int p = 2 ; p <= ( int ) Math . sqrt ( MAX ) ; p ++ ) { if ( ( prime [ p ] = true ) == false ) { for ( int i = p * p ; i <= MAX ; i += p ) { prime [ i ] = false ; } } } } } . start ( ) ; /* ▁ We ▁ need ▁ to ▁ make ▁ sure ▁ that ▁ the ▁ prime ▁ is ▁ not ▁ prime ▁ */ int smallestPrime = 10 ; int l = 10 * ( d - 1 ) ; int r = ( 10 * d ) - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( prime [ i ] = true ) == false ) { return i ; } } /* ▁ We ▁ need ▁ to ▁ make ▁ sure ▁ that ▁ the ▁ prime ▁ is ▁ prime ▁ */ int largestPrime = 10 ; int l = 10 * ( d - 1 ) ; int r = ( 10 * d ) - 1 ; for ( int i = r ; i > l ; i -- ) { if ( ( prime [ i ] = true ) == false ) { return i ; } } /* ▁ We ▁ need ▁ to ▁ make ▁ sure ▁ that ▁ the ▁ prime ▁ is ▁ prime ▁ */ if ( __name__ == " _ _ main _ _ " ) { SieveOfEratosthenes ( ) ; int queries [ ] = { 2 , 5 } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( smallestPrime + " ▁ " + queries [ i ] + " ▁ " + largestPrime + " ▁ " + queries [ i ] ) ; } } }
public static int INF = 10 ** 20 ; int n = Integer . parseInt ( input . readLine ( ) ) , m = Integer . parseInt ( input . readLine ( ) ) ; int [ ] dist = new int [ n ] ; int [ ] weth = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { dist [ i ] = Integer . parseInt ( input . readLine ( ) ) ; } for ( int i = 0 ; i < m ; i ++ ) { weth [ i ] = Integer . parseInt ( input . readLine ( ) ) ; } return INF ; }
static void print ( int n , int k , int x ) { int [ ] ls = new int [ n ] ; for ( int m = 1 ; m <= k ; m ++ ) ls [ ls . length - m ] = x ; System . out . println ( Arrays . toString ( ls ) ) ; }
@ VisibleForTesting static final String [ ] solve ( String inputPath ) throws IOException { final Scanner in = new Scanner ( System . in ) ; final int n1 ; final int n2 ; final int m ; final int a ; final int d ; final List < Integer > t ; if ( inputPath == null ) { in = new Scanner ( System . in ) ; } else { in = new Scanner ( in ) ; } final int n ; final int m ; final int a ; final int d ; final List < Integer > t ; { insort ( t , a * n1 ) ; int pred ; int k ; int n ; final int step = d / a + 1 ; int answer = 0 ; int fl = 0 ; for ( int i = 0 ; i < t . size ( ) ; i ++ ) { if ( t . get ( i ) > pred ) { if ( fl == 0 ) { n = ( t . get ( i ) - pred + ( pred % a ) ) / a ; if ( n != 0 ) { k += ( n / step ) * step - step * ( n % step == 0 ) + 1 ; if ( k > n1 ) { k = n1 ; fl = 1 ; } } if ( ( k * a + d >= t . get ( i ) ) && ( n != 0 ) ) { pred = k * a + d ; } else { pred = t . get ( i ) + d ; k = floor ( pred / a ) ; answer ++ ; } k = min ( floor ( pred / a ) , n1 ) ; answer += n / step + ( n % step != 0 ) ; } else { answer ++ ; pred = t . get ( i ) + d ; } } if ( t . get ( i ) == a * n1 ) fl = 1 ; } return new String [ ] { f " { answer } " } ; } }
static final int solve ( int testCase ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; while ( testCase -- > 0 ) { n = Integer . parseInt ( input . nextLine ( ) ) ; long sum = n * ( n + 1 ) / 2 ; int i = 1 ; while ( i <= n ) { sum -= i * 2 ; i *= 2 ; } System . out . println ( ( int ) sum ) ; testCase -- ; } return n ; }
public static void print ( String s ) { s = input . nextLine ( ) ; boolean x = true ; HashMap < Integer , Integer > dt = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( dt . containsKey ( s . charAt ( i ) ) ) dt . put ( s . charAt ( i ) , 1 ) ; else dt . put ( s . charAt ( i ) , 1 ) ; } int cnt = 0 ; x = true ; for ( Map . Entry < Integer , Integer > entry : dt . entrySet ( ) ) { if ( entry . getValue ( ) % 2 != 0 && cnt < 1 ) { cnt ++ ; } else if ( entry . getValue ( ) % 2 != 0 && cnt >= 1 ) { x = false ; break ; } } if ( x ) { System . out . println ( " First " ) ; } else if ( ! x && s . length ( ) % 2 == 0 ) { System . out . println ( " Second " ) ; } else if ( ! x && s . length ( ) % 2 != 0 ) { System . out . println ( " First " ) ; } }
public static int reverse ( int n ) { int rev = 0 ; while ( ( n != 0 ) && ( n % 10 != 0 ) ) { rev = ( rev * 10 ) + ( n % 10 ) ; n /= 10 ; } /* ▁ Sum ▁ of ▁ the ▁ digits ▁ */ n = reverse ( n ) ; int sumOdd = 0 ; int sumEven = 0 ; int c = 1 ; return sumOdd ; }
public static void disp ( int rowNo , int block ) { System . out . println ( rowNo * block ) ; int rowNo ; int rowNo ; int rowNo ; rowNo = block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo ; rowNo = rowNo / block ; rowNo = rowNo / block ; rowNo = rowNo ; rowNo = rowNo / block ; rowNo = rowNo ; rowNo = rowNo / block ; rowNo = rowNo
[ ] ; bin = new String [ ] { "000" , "001" , "010" , "011" , "100" , "101" , "110" , "111" } ; /* ▁ max ▁ freq ▁ */ String binary = " " ; for ( int i = 0 ; i < binary . length ( ) ; i ++ ) { binary += bin [ ( int ) ( binary . charAt ( i ) - '0' ) ] ; } binary = binary . substring ( 0 , binary . length ( ) - 1 ) ; int count = 1 ; int prev = - 1 ; int j = 0 ; for ( int i = binary . length ( ) - 1 ; i >= 0 ; i -- ) { if ( ( binary . charAt ( i ) == '1' ) && ( binary . charAt ( i ) == '2' ) ) { count = Math . max ( count , j - prev ) ; prev = j ; } j ++ ; } /* ▁ if ▁ ( Class . isPrimitive ( ) ) ▁ { STRNEWLINE ▁ String ▁ octal ▁ = ▁ "13" ; STRNEWLINE ▁ System . out . println ( maxFreq ( octal ) ) ; STRNEWLINE ▁ } */ /* ▁ max ▁ freq ▁ */ int max = 0 ; for ( int i = 0 ; i < binary . length ( ) ; i ++ ) { binary = binary . charAt ( i ) ; } /* ▁ max ▁ freq ▁ */ for ( int i = binary . length ( ) - 1 ; i >= 0 ; i -- ) { binary = binary . charAt ( i ) ; } /* ▁ max ▁ freq ▁ */ for ( int i = binary . length ( ) - 1 ; i >= 0 ; i -- ) { binary = binary . charAt ( i ) ; } /* ▁ max ▁ freq ▁ */ for ( int i = binary . length ( ) - 1 ; i >= 0 ; i -- ) { binary = binary . charAt ( i ) ; } /* ▁ max ▁ freq ▁ */ for ( int i = binary . length ( ) - 1 ; i >= 0 ; i -- ) { binary = binary . charAt ( i ) ; } /* ▁ max ▁ freq ▁ */ for ( int i = binary . length ( ) - 1 ; i >= 0 ; i -- ) { binary = binary . charAt ( i ) ; } /* ▁ max ▁ freq ▁ */ for ( int i = binary . length ( ) - 1 ; i >= 0 ; i -- ) { binary = binary . charAt ( i ) ; } return max ; }
private static String isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ? " " : " " ; }
public static int harmonicMean ( int [ ] arr , int [ ] freq , int n ) { double sm = 0 ; double frequencySum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sm = sm + freq [ i ] / arr [ i ] ; frequencySum = frequencySum + freq [ i ] ; } return ( Math . round ( frequencySum / sm ) ) ; }
static double polyArea ( int n , double a ) { final double A ; if ( ( a < 0 ) && ( n < 0 ) ) { return - 1 ; } A = ( a * a * n ) / ( 4 * Math . tan ( ( 180 / n ) * Math . PI / 180 ) ) ; return A ; }
static int $gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) { return b ; } if ( ( a == b ) || ( a == a ) ) { return a ; } if ( ( a > b ) || ( b > b ) ) { return $gcd ( a - b , b ) ; } return $gcd ( a , b - a ) ; }
public static void main ( Scanner in ) { int M = in . nextInt ( ) , Nmin = in . nextInt ( ) , Nmax = in . nextInt ( ) ; if ( M + Nmin + Nmax == 0 ) { break ; } int [ ] P = new int [ M ] ; for ( int i = 0 ; i < M ; i ++ ) { P [ i ] = in . nextInt ( ) ; } int [ ] dif = new int [ M ] ; for ( int i = 0 ; i < P . length - 1 ; i ++ ) { dif [ i + 1 ] = P [ i ] - P [ i + 1 ] ; } int ans = Nmin ; int tmp = dif [ Nmin ] ; for ( int i = Nmin + 1 ; i <= Nmax ; i ++ ) { if ( dif [ i ] >= tmp ) { ans = i ; tmp = dif [ i ] ; } } System . out . println ( ans ) ; }
R = lambda : Lists . newArrayList ( ) ; int b = R . nextInt ( ) ; int q = R . nextInt ( ) ; int i = R . nextInt ( ) ; int m = R . nextInt ( ) ; Set < Integer > a = new HashSet < Integer > ( ) ; int c = 0 ; for ( ; ; ; ) { if ( Math . abs ( b ) > i ) break ; if ( ! a . contains ( b ) ) c ++ ; b *= q ; }
public static void main ( String input ) { int n , m ; for ( n = Integer . parseInt ( input ) ; n < n ; n ++ ) { m = new HashMap < > ( ) ; } int [ ] x = map . get ( input ) ; for ( int i = 0 ; i < x . length ; i ++ ) m . put ( x [ i ] , i + 1 ) ; m = new HashMap < > ( ) ; m . putAll ( m ) ; System . out . println ( m . get ( Collections . reverseOrder ( ) ) . get ( 0 ) + " ▁ " + m . get ( m . size ( ) - 1 ) ) ; }
static int findIndex ( int n ) { final double fibo = 2.078087 * Math . log ( n ) + 1.672276 ; return Math . round ( fibo ) ; }
public static boolean isSmaller ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( ( n1 < n2 ) || ( n1 < n2 ) ) { return true ; } if ( ( n2 < n1 ) || ( n2 < n2 ) ) { return false ; } for ( int i = 0 ; i < n1 ; i ++ ) { if ( ( str1 . charAt ( i ) < str2 . charAt ( i ) ) ) { return true ; } else if ( ( str1 . charAt ( i ) > str2 . charAt ( i ) ) ) { return false ; } } return false ; /* ▁ find ▁ difference ▁ between ▁ two ▁ strings ▁ */ if ( ( isSmaller ( str1 , str2 ) ) && ( isSmaller ( str2 , str1 ) ) ) { String temp = str1 ; str1 = str2 ; str2 = temp ; } String str3 = " " ; n1 = str1 . length ( ) ; n2 = str2 . length ( ) ; str1 = str1 . substring ( 0 , n1 ) ; str2 = str2 . substring ( 0 , n2 ) ; int carry = 0 ; for ( int i = 0 ; i < n2 ; i ++ ) { int sub = ( ( ( int ) str1 . charAt ( i ) ) - ( ( int ) str2 . charAt ( i ) ) - carry ) ; if ( ( sub < 0 ) || ( ( int ) str2 . charAt ( i ) < '0' ) ) { sub = sub + 10 ; carry = 1 ; } else { carry = 0 ; } str3 = str3 + sub ; } for ( int i = n2 ; i < n1 ; i ++ ) { int sub = ( ( ( int ) str1 . charAt ( i ) ) - ( ( int ) str2 . charAt ( i ) ) - carry ) ; if ( ( sub < 0 ) || ( ( int ) str1 . charAt ( i ) < '0' ) ) { sub = sub + 10 ; carry = 1 ; } else { carry = 0 ; } str3 = str3 + sub ; } str3 = str3 . substring ( 0 , str3 . length ( ) - 1 ) ; return str3 . equals ( " " ) ; }
static int minSwaps ( String s1 , String s2 ) { int c0 = 0 ; int c1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ( s1 . charAt ( i ) == '0' ) && ( s2 . charAt ( i ) == '1' ) ) { c0 ++ ; } else if ( ( s1 . charAt ( i ) == '1' ) && ( s2 . charAt ( i ) == '0' ) ) { c1 ++ ; } } int ans = c0 / 2 + c1 / 2 ; if ( ( c0 % 2 == 0 ) && ( c1 % 2 == 0 ) ) { return ans ; } else if ( ( ( c0 + c1 ) % 2 == 0 ) && ( ( c1 + c0 ) % 2 == 0 ) ) { return ans + 2 ; } else { return - 1 ; } }
public static final class SegmentTree { int max ; int a , b ; int N ; int [ ] X ; int i ; int k ; int [ ] seg ; { int N = 1 ; while ( ( N < n ) && ( a < b ) ) N *= 2 ; seg = new int [ N * 2 - 1 ] ; } public void maxUpdate ( int k , int a ) { k += N - 1 ; seg [ k ] = a ; while ( ( 0 < k ) && ( a < b ) ) { k = ( k - 1 ) / 2 ; seg [ k ] = max ( seg [ 2 * k + 1 ] , seg [ 2 * k + 2 ] ) ; } } public int maxQuery ( int a , int b , int k , int l , int r ) { if ( r <= a || b <= l ) return 0 ; if ( a <= l && r <= b ) return seg [ k ] ; else { int vl = maxQuery ( a , b , k * 2 + 1 , l , ( l + r ) / 2 ) ; int vr = maxQuery ( a , b , k * 2 + 2 , ( l + r ) / 2 , r ) ; return max ( vl , vr ) ; } } public int maxQuery ( int a , int b ) { return max ( a , b , 0 , 0 , N ) ; } }
public static int [ ] [ ] a ( ) { int p = a . indexOf ( ' ^ ' ) ; int c = Integer . valueOf ( a . substring ( 0 , p ) ) ; return Arrays . copyOf ( a , p + 1 ) ; }
static void normalSieve ( int n ) { int [ ] prime = new int [ Integer . highestOneBit ( n ) << 1 ] ; int i = 3 ; while ( ( i * i < n ) && ( prime [ ( int ) i / 2 ] == 0 ) ) { int j = i * i ; while ( ( j < n ) && ( prime [ ( int ) j / 2 ] == 0 ) ) { prime [ ( int ) j / 2 ] = 1 ; j += i * 2 ; } i += 2 ; } System . out . print ( 2 ) ; i = 3 ; while ( ( i < n ) && ( prime [ ( int ) i / 2 ] == 0 ) ) { System . out . print ( i ) ; } i += 2 ; if ( Class . forName ( " java . lang . Integer " ) . equals ( " java . lang . Integer " ) ) { n = 100 ; normalSieve ( n ) ; } }
public static String input ( ) { String txt = input ; String out = " " ; int cap = 0 ; int small = 0 ; for ( char t : txt . toCharArray ( ) ) { if ( Character . isLowerCase ( t ) ) { small ++ ; } else { cap ++ ; } } if ( small >= cap ) { for ( char t : txt . toCharArray ( ) ) { out += t . toLowerCase ( ) ; } } else { for ( char t : txt . toCharArray ( ) ) { out += t . toUpperCase ( ) ; } } return out ; }
public static int frequencyOfSmallest ( int n , int [ ] arr ) { int mn = arr [ 0 ] ; int freq = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] < mn ) && ( arr [ i ] > mn ) ) { mn = arr [ i ] ; freq = 1 ; } else if ( ( arr [ i ] == mn ) && ( arr [ i ] > mn ) ) { freq ++ ; } } return freq ; }
static boolean isSubArray ( int A [ ] , int B [ ] , int n , int m ) { int i = 0 ; int j = 0 ; while ( ( i < n ) && ( j < m ) ) { if ( ( A [ i ] == B [ j ] ) && ( i < n ) && ( j < m ) ) { i ++ ; j ++ ; if ( ( j == m ) && ( i == n ) ) { return true ; } } else { i = i - j + 1 ; j = 0 ; } } return false ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] l = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { l [ i ] = Integer . parseInt ( input ) ; } int ans = n - 1 ; int last = 0 ; for ( int i : l ) { ans += Math . abs ( last - i ) + 1 ; last = i ; } System . out . println ( ans ) ; }
static long calculateSum ( int n , int k ) { long res = 1 ; final long MOD = 1000000007 ; for ( int i = 0 ; i <= k ; i ++ ) { res = ( res * n ) % MOD ; } return res ; }
public static boolean ok ( String last4 ) { for ( int i = 0 ; i < 4 ; i ++ ) { StringBuilder t = new StringBuilder ( last4 ) ; if ( i >= 1 ) { t . setCharAt ( i , ' a ' ) ; } if ( t . toString ( ) . indexOf ( " AGC " ) >= 1 ) { return false ; } } return true ; }
public static int i = 0 ; double sumsell = 0 ; double sumn = 0 ; while ( true ) { try { int at = Integer . parseInt ( input . readLine ( ) ) ; int n = Integer . parseInt ( input . readLine ( ) ) ; sumsell += at * n ; sumn += n ; i ++ ; } catch ( IOException e ) { break ; } }
MAX = 100 ; }
public static void main ( String [ ] args ) { if ( args . length == 0 ) { String string1 = input . nextLine ( ) ; System . out . print ( string1 + " \n " ) ; String string2 = input . nextLine ( ) ; System . out . print ( string2 + " \n " ) ; System . out . print ( " Are ▁ both ▁ strings ▁ same : " ) ; if ( ( string1 . equals ( string2 ) ) && ( string1 . equals ( string2 ) ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
@ GwtIncompatible ( " java . util . Arrays " ) public static int pairCount ( int [ ] arr , int n ) { int maxVal = arr [ 0 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] > maxVal ) && ( arr [ i ] > maxVal ) ) { maxVal = arr [ i ] ; } } boolean [ ] prime = new boolean [ maxVal + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = false ; prime [ 1 ] = false ; int k = ( int ) Math . sqrt ( maxVal ) + 1 ; for ( int p = 2 ; p <= k ; p += 1 ) { if ( ( prime [ p ] = true ) == true ) { for ( int i = p * 2 ; i <= maxVal ; i += p ) { prime [ i ] = false ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( prime [ arr [ i ] ] = true ) == true ) { count ++ ; } } return ( count * ( count - 1 ) ) / 2 ; }
@ VisibleForTesting static int getPrime ( int [ ] arr , int n ) { int maxVal = arr [ 0 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] > maxVal ) && ( arr [ i ] > maxVal ) ) { maxVal = arr [ i ] ; } } boolean [ ] prime = new boolean [ maxVal + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; ( p = ( int ) Math . sqrt ( maxVal ) ) + 1 ; p <= 1 ; p ++ ) { if ( ( prime [ p ] = true ) && ( arr [ p ] == true ) ) { for ( int i = p * 2 ; i <= maxVal ; i += p ) { prime [ i ] = false ; } } } int maximum = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( prime [ arr [ i ] ] = arr [ i ] ) && ( arr [ i ] > maxVal ) ) { maximum = Math . max ( maximum , arr [ i ] ) ; } } return maximum ; }
public static String compute ( ) { return Integer . toString ( NUMBERS . length ) . substring ( 0 , 10 ) ; }
static void findElements ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
static void printDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i < n - 1 ) && arr [ i ] == arr [ i + 1 ] ) { while ( ( i < n - 1 ) && ( arr [ i ] == arr [ i + 1 ] ) ) i ++ ; } else System . out . print ( arr [ i ] + " ▁ " ) ; } }
if __name__ . equals ( " java . util . Scanner " ) ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; System . out . println ( a * b ) ; }
public static int nthTerm ( int a , int b , int n ) { int z = 0 ; if ( ( n % 6 ) == 1 ) { z = a ; } else if ( ( n % 6 ) == 2 ) { z = b ; } else if ( ( n % 6 ) == 3 ) { z = b - a ; } else if ( ( n % 6 ) == 4 ) { z = - a ; } else if ( ( n % 6 ) == 5 ) { z = - b ; } if ( ( n % 6 ) == 0 ) { z = - ( b - a ) ; } return z ; }
static long findSubSequence ( String s , int num ) { long res = 0 ; int i = 0 ; while ( ( num != 0 ) && ( i < s . length ( ) ) ) { if ( ( num & 1 ) != 0 ) { res += ( s . charAt ( i ) - '0' ) ; } i ++ ; num = num > > 1 ; } /* ▁ combined ▁ sum ▁ */ int n = s . length ( ) ; long cSum = 0 ; int ran = ( 1 << n ) - 1 ; for ( int i = ran + 1 ; i < n ; i ++ ) { cSum += findSubSequence ( s , i ) ; } /* ▁ if ▁ ( getClass ( ) . getName ( ) . equals ( " java . lang . String " ) ) ▁ { STRNEWLINE ▁ s = "123" ; STRNEWLINE ▁ System . out . println ( combinedSum ( s ) ) ; STRNEWLINE ▁ } */ long cSum = 0 ; if ( getClass ( ) . getName ( ) . equals ( " java . lang . String " ) ) { s = "123" ; System . out . println ( combinedSum ( s ) ) ; } return cSum ; }
static int minimumCost ( int [ ] cost , int n ) { int dp1 = 0 ; int dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
static int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
static final int SIZE = 26 ; int len = 0 ; int len = 0 ; int k ; int [ ] freq = new int [ 26 ] ; int start = 0 ; int maxLen = 0 ; int n = len ; for ( int i = 0 ; i <= n ; i ++ ) { char ch = str . charAt ( i ) ; freq [ ( int ) ch - ' a ' ] ++ ; if ( ( freq [ ( int ) ch - ' a ' ] > k ) && ( len > i ) ) { if ( ( maxLen < ( i - start ) ) && ( len > i ) ) maxLen = i - start ; while ( ( len > start ) && ( len > i ) ) { freq [ len - start ] -- ; start = len ; } } }
@ Sys public static void main ( String [ ] args ) throws IOException { BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( input . readLine ( ) ) ; int sa = 0 ; int sg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int a = Integer . parseInt ( input . readLine ( ) ) ; int g = Integer . parseInt ( input . readLine ( ) ) ; if ( a <= g ) { if ( sa + a - sg <= 500 ) { sa += a ; System . out . print ( " A " ) ; } else { sg += g ; System . out . print ( " G " ) ; } } else { if ( sg + g - sa <= 500 ) { sg += g ; System . out . print ( " G " ) ; } else { sa += a ; System . out . print ( " A " ) ; } } } }
public static String toHex ( ) { class Solution { int num ; String out ; String mp ; int n ; String ans ; int i ; int n ; int i ; int j ; String c ; String ans ; n = 8 ; i = i & 15 ; ans = c ; ans = ans . concat ( "0" ) ; i = i + j ; j = i + 1 ; n = i + 1 ; ans = ans . concat ( " " ) ; i = i + j ; j = i + 1 ; ans = ans . concat ( " " ) ; i = i + j ; j = i + 1 ; ans = ans . concat ( " " ) ; i = i + j ; ans = ans . concat ( " " ) ; i = i + j ; ans = ans . concat ( " " ) ; i = i + j ; ans = ans . concat ( " " ) ; i = i + j ; ans = ans . concat ( " " ) ; i = i + j ; ans = ans . concat ( " " ) ; i = i + j ; ans = ans . concat ( " " ) ; i = i + j ; ans = ans . concat ( " " ) ; } if ( getClassName ( ) . equals ( Solution . class . getName ( ) ) ) { Solution sObj = new Solution ( ) ; num = 26 ; out = sObj . toHex ( num ) ; System . out . println ( out ) ; } return out ; }
public static List < String > numbers = Lists . newArrayList ( ) ; for ( String s : input . split ( " ▁ " ) ) { int start = 0 ; List < String > arr = new ArrayList < String > ( ) ; int count = 0 ; for ( int i = 0 ; i <= numbers . get ( 0 ) ; i ++ ) { String string = " " ; int next = start ; for ( int j = 0 ; j <= numbers . get ( 0 ) ; j ++ ) { if ( count < numbers . get ( 1 ) ) { if ( j == next ) { string += ' L ' ; count ++ ; next += 2 ; if ( next >= numbers . get ( 0 ) ) { start = start == 0 ? 1 : 0 ; } } else { string += " S " ; } } else { string += " S " ; } } arr . add ( string ) ; } if ( count < numbers . get ( 1 ) ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { System . out . println ( arr . get ( i ) ) ; } } return arr ; }
public static void longestString ( String str1 , String str2 ) { int [ ] count1 = new int [ 26 ] ; int [ ] count2 = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { count1 [ ( str1 . charAt ( i ) - ' a ' ) ] ++ ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { count2 [ ( str2 . charAt ( i ) - ' a ' ) ] ++ ; } String result = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result = result + ( char ) ( ' a ' + i ) ; } } System . out . println ( result ) ; }
public static int msb ( int x ) { int ret = 0 ; while ( ( ( x > > ( ret + 1 ) ) != 0 ) && ( ( x > > ( ret + 1 ) ) != 0 ) ) { ret = ret + 1 ; } /* ▁ xorRange ▁ */ int max_bit = msb ( r ) ; int mul = 2 ; int ans = 0 ; for ( int i = 1 ; i <= max_bit ; i ++ ) { if ( ( ( l / mul ) * mul == ( r / mul ) * mul ) ) { if ( ( ( ( ( l & ( 1 << i ) ) != 0 ) && ( ( r - l + 1 ) % 2 == 1 ) ) ) ) { ans = ans + mul ; } mul = mul * 2 ; continue ; } int odd_c = 0 ; if ( ( ( ( l & ( 1 << i ) ) != 0 ) && ( l % 2 == 1 ) ) ) odd_c = ( odd_c ^ 1 ) ; if ( ( odd_c != 0 ) ) ans = ans + mul ; mul = mul * 2 ; } int zero_bit_cnt = ( r - l + 1 ) / 2 ; if ( ( ( l % 2 == 1 ) && ( r % 2 == 1 ) ) ) zero_bit_cnt = zero_bit_cnt + 1 ; if ( ( zero_bit_cnt % 2 == 1 ) ) ans = ans + 1 ; return ans ; }
static void q1 ( String s , int i ) { if ( ( i == s . length ( ) ) && ( s . charAt ( i ) == ' a ' ) ) { System . out . println ( " Yes " ) ; return ; } if ( ( s . charAt ( i ) == ' a ' ) && ( s . charAt ( i + 1 ) == ' b ' ) ) { q1 ( s , i + 1 ) ; } else { q2 ( s , i + 1 ) ; } }
static final String [ ] read ( InputStream in ) throws IOException { BufferedReader readline = new BufferedReader ( new InputStreamReader ( in ) ) ; BufferedWriter write = new BufferedWriter ( new OutputStreamWriter ( out ) ) ; ArrayList < String > ans = new ArrayList < > ( ) ; while ( true ) { int M = Integer . parseInt ( readline . readLine ( ) ) ; if ( M == 0 ) break ; List < Integer > P = new ArrayList < > ( ) ; for ( int i = 0 ; i < M ; i ++ ) P . add ( Collections . singletonList ( Integer . parseInt ( readline . readLine ( ) ) ) ) ; memo . clear ( ) ; /* dfs */ } }
static void findTime ( String T , int K ) { long minutes = ( ( ( ( int ) T . charAt ( 0 ) - '0' ) * 10 + ( ( int ) T . charAt ( 1 ) - '0' ) * 60 + ( ( ( int ) T . charAt ( 3 ) - '0' ) * 10 + ( ( int ) T . charAt ( 4 ) - '0' ) ) ) ; minutes += K ; int hour = ( ( int ) ( minutes / 60 ) ) % 24 ; long min = minutes % 60 ; if ( ( hour < 10 ) && ( hour > 0 ) ) System . out . print ( " 0 " + hour + " : " ) ; else System . out . print ( Integer . toString ( hour ) + " : " ) ; if ( ( min < 10 ) && ( min > 0 ) ) System . out . println ( " 0 " + min ) ; else System . out . println ( Integer . toString ( minVal ) ) ; if ( className . equals ( " java . lang . String " ) ) { T = "21:39" ; K = 43 ; findTime ( T , K ) ; } }
static void maxProductSum ( String string , int m ) { final int n = string . length ( ) ; int maxProd = ( - ( Integer . MAX_VALUE - 1 ) ) , maxSum = ( - ( Integer . MIN_VALUE - 1 ) ) ; for ( int i = 0 ; i < n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( ( int ) string . charAt ( j ) - '0' ) ; sum = sum + ( ( int ) string . charAt ( j ) - '0' ) ; } maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } System . out . println ( " Maximum ▁ Product ▁ = " + maxProd ) ; System . out . println ( " Maximum ▁ Sum ▁ = " + maxSum ) ; if ( className . equals ( " java . lang . String " ) ) { string = "3675356291" ; m = 5 ; maxProductSum ( string , m ) ; } }
R = 3 ; C = 3 ; final int [ ] [ ] cost = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 5 , 3 , 3 } } ; if ( ( n < 0 ) || ( m < 0 ) ) { return cost [ m ] [ n ] ; } else if ( ( m == 0 ) && ( n == 0 ) ) { return cost [ m ] [ n ] ; } else { return cost [ m ] [ n ] ; } }
public static void main ( ) { n = Integer . parseInt ( input ( ) ) ; p = new ArrayList < > ( map . get ( Integer . parseInt ( input ( ) ) ) ) ; }
public static int [ ] [ ] split ( int MAX ) { int [ ] ws = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) ws [ i ] = 0 ; int [ ] par = new int [ MAX * 2 ] ; for ( int i = 0 ; i < MAX ; i ++ ) par [ i ] = - 1 ; { root ( ws [ i ] ) ; return ws [ i ] ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } } { root ( par [ 0 ] ) ; } { root ( par [ 0 ] ) ; } } { int ans = 0 ; int [ ] [ ] =
static int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) { if ( ( i % M ) == 0 ) { sum += i ; } } if ( Class . isEnum ( ) ) { A = 6 ; B = 15 ; M = 3 ; System . out . println ( sumDivisibles ( A , B , M ) ) ; } return sum ; }
static int countNumbersWith4 ( int n ) { final int d = ( int ) Math . log10 ( n ) ; int [ ] a = new int [ d + 1 ] ; for ( int i = 0 ; i < a . length ; i ++ ) a [ i ] = 1 ; a [ 0 ] = 0 ; if ( a . length > 1 ) a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + Math . ceil ( Math . pow ( 10 , i - 1 ) ) ; return ( d ) ; }
public static void wah ( String input ) { int x = wah [ 0 ] , y = wah [ 1 ] , n = Integer . parseInt ( input ) ; int [ ] all = { x , y , y - x , - x , - y , x - y } ; int res = ( n - 1 ) % 6 ; System . out . println ( all [ res ] % 1000000007 ) ; }
public static void findPostOrderUtil ( int [ ] pre , int n , int minval , int maxval , int [ ] preIndex ) { if ( ( preIndex [ 0 ] == n ) || ( preIndex [ 0 ] < minval ) || ( preIndex [ 0 ] > maxval ) ) { return ; } int val = pre [ preIndex [ 0 ] ++ ] ; findPostOrderUtil ( pre , n , minval , val , preIndex ) ; findPostOrderUtil ( pre , n , val , maxval , preIndex ) ; System . out . print ( val + " ▁ " ) ; }
static int countWays ( int n , int [ ] arr , int k ) { if ( ( k <= 0 ) || ( k >= n ) ) { return 0 ; } HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int element : arr ) { s . add ( element ) ; } if ( ( s . size ( ) <= k ) && ( k < n ) ) { return 0 ; } return s . size ( ) - k ; }
public static String input ( int cnt ) { String ip ; for ( int k = 0 ; k < Integer . parseInt ( cnt ) ; k ++ ) { ip = input . nextLine ( ) ; if ( ip . equals ( " " ) ) { System . out . println ( "0000:0000:0000:0000:0000:0000:0000:0000" ) ; continue ; } String [ ] array = ip . split ( " : " ) ; String ret = " " ; if ( array [ 0 ] . equals ( " " ) ) { array = new String [ 8 - array . length + 2 ] ; Arrays . fill ( array , "0000" ) ; } else if ( array [ array . length - 1 ] . equals ( " " ) ) { array = Arrays . copyOf ( array , array . length - 2 ) ; Arrays . fill ( array , "0000" ) ; } for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] . equals ( " " ) ) { array = Arrays . copyOf ( array , i ) ; Arrays . fill ( array , "0000" ) ; } } for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] . length ( ) != 4 ) { array [ i ] = "0" ; } } System . out . println ( Arrays . toString ( array ) ) ; } return ret ; }
static boolean isPrime ( int n ) { final int flag = 1 ; int i = 2 ; while ( ( i * i <= n ) && ( n % i == 0 ) ) { if ( ( n % i == 0 ) && ( n % i == 0 ) ) { flag = 0 ; break ; } i ++ ; } return ( flag == 1 ) ? true : false ; }
public static void main ( String input ) { int N = Integer . parseInt ( input ) ; List < List < Integer > > W = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { W . add ( Collections . singletonList ( input ) ) ; } int cnt = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( W . get ( i ) . get ( 0 ) != W . get ( i - 1 ) . get ( W . size ( ) - 1 ) ) { cnt = 1 ; } } Collections . sort ( W ) ; for ( int i = 1 ; i < N ; i ++ ) { if ( W . get ( i ) . equals ( W . get ( i - 1 ) ) ) { cnt = 1 ; } } if ( cnt == 1 ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; } }
static int findNum ( int [ ] div , int [ ] rem , int N ) { int num = rem [ N - 1 ] ; int i = N - 2 ; while ( ( i >= 0 ) && ( i < div . length ) ) { num = num * div [ i ] + rem [ i ] ; i -- ; } return num ; }
public static void segregate0and1 ( int [ ] arr , int size ) { int type0 = 0 ; int type1 = size - 1 ; while ( ( type0 < type1 ) && ( arr [ type0 ] == 1 ) ) { ( arr [ type0 ] ) ; type1 -- ; } else { type0 ++ ; } int [ ] arr = { 0 , 1 , 0 , 1 , 1 , 1 } ; int arrSize = arr . length ; segregate0and1 ( arr , arrSize ) ; System . out . print ( " Array ▁ after ▁ segregation ▁ is " ) ; for ( int i = 0 ; i <= arrSize ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
public static void main ( ) { n = Integer . parseInt ( input ( ) ) ; d = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) d [ i ] = Integer . parseInt ( input ( ) ) ; System . out . println ( new HashSet ( d ) . size ( ) ) ; }
public static void input ( Scanner s ) { String t = s . next ( ) ; int a = ( t . charAt ( 0 ) - s . charAt ( 0 ) ) ; int b = ( int ) ( t . charAt ( 1 ) - s . charAt ( 1 ) ) ; int x = Math . abs ( a ) ; int y = Math . abs ( b ) ; char [ ] c = { ' R ' , ' U ' , ' L ' , ' D ' } ; int i = 0 ; int j = 1 ; if ( a < 0 ) { i = 2 ; } if ( b < 0 ) { j = 3 ; } int k = j ; if ( x > y ) { k = i ; x = y ; y = x ; } char m = c [ i ] + c [ j ] ; char n = c [ k ] ; System . out . println ( y ) ; for ( int l = 0 ; l < x ; l ++ ) { System . out . println ( m ) ; } for ( int l = 0 ; l < y - x ; l ++ ) { System . out . println ( n ) ; } }
public static int f ( ) { return map . get ( input ( ) ) ; int h = f ( ) ; int w = f ( ) ; return h ; }
public static int n = Integer . parseInt ( input ) { List < List < Integer > > L = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { L . add ( Collections . singletonList ( Integer . parseInt ( input ) ) ) ; } for ( int i = 0 ; i < L . size ( ) ; i ++ ) { int X = L . get ( i ) ; for ( int j = 0 ; j < X ; j ++ ) { int Y = X + j ; if ( Y == 1 || ArrayUtils . contains ( Y , X ) ) continue ; System . out . println ( " NO " ) ; exit ( ) ; } } System . out . println ( " YES " ) ; return 0 ; }
public static int a ( ) { int b = ( int ) ( input . nextInt ( ) ) ; return MAX - 1 ; }
public static int x ( ) { x = Integer . parseInt ( input ( ) ) ; return x ; }
static final Iterable < Integer > i , collections = new Iterable < Integer > ( ) { public Iterator < Integer > iterator ( ) { return new Iterator < Integer > ( ) { } ; } }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( input ) ; } int [ ] a = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { a [ i ] = Integer . parseInt ( input ) ; } int ans = 0 ; int s1 = a [ 0 ] ; int s2 = b [ 0 ] ; int i = 0 ; int j = 0 ; while ( i < a . length || j < b . length ) { if ( s1 == s2 ) { ans ++ ; i ++ ; j ++ ; if ( i < a . length && j < b . length ) { s1 = a [ i ] ; s2 = b [ j ] ; } } else if ( s1 < s2 ) { i ++ ; s1 += a [ i ] ; } else if ( s2 < s1 ) { j ++ ; s2 += b [ j ] ; } } System . out . println ( ans ) ; }
public static void print ( ) { String a , en , b ; a = input . nextToken ( ) ; en = input . nextToken ( ) ; b = input . nextToken ( ) ; if ( en . equals ( " ? " ) ) { break ; } else { a = Integer . parseInt ( a ) ; b = Integer . parseInt ( b ) ; if ( en . equals ( " + " ) ) { System . out . println ( a + b ) ; } else if ( en . equals ( " - " ) ) { System . out . println ( a - b ) ; } else if ( en . equals ( " * " ) ) { System . out . println ( a * b ) ; } else if ( en . equals ( " / " ) ) { System . out . println ( ( int ) ( a / b ) ) ; } } }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] a = Integer . parseInt ( input ) ; int [ ] d = new int [ n - 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { d [ i ] = 0 ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { d [ i ] = a [ i + 1 ] - a [ i ] ; } int cnt = 1 ; int l = 0 ; int r = 0 ; int cur = 0 ; while ( l < n - 1 ) { while ( r < n - 1 && cur * d [ r ] >= 0 ) { if ( cur == 0 ) cur = d [ r ] ; r ++ ; } if ( r < n - 1 && cur * d [ r ] < 0 ) cnt ++ ; r ++ ; l = r ; cur = 0 ; } System . out . println ( cnt ) ; }
public static int countPairs ( String s ) { int [ ] cnt = new int [ MAX ] ; for ( int i = 0 ; i <= MAX ; i ++ ) cnt [ ( s . charAt ( i ) - 97 ) ] ++ ; int ans = 0 ; for ( int i = 0 ; i <= MAX ; i ++ ) ans += cnt [ i ] * cnt [ i ] ; return ans ; }
@ VisibleForTesting static void sieveOfEratosthenes ( int n ) { prime = new boolean [ 100005 ] ; { for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; } { prime [ 1 ] = false ; for ( int p = 2 ; p <= ( int ) Math . sqrt ( n ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < n ; i += p ) prime [ i ] = false ; } } } { sortedArray ( arr , n ) ; } { SieveOfEratosthenes ( 100005 ) ; int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 0 ) v [ i ] = arr [ i ] ; } Arrays . sort ( v ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == true ) System . out . print ( arr [ i ] + " ▁ " ) ; else System . out . print ( v [ j ++ ] + " ▁ " ) ; } } }
@ VisibleForTesting static int createHash ( int [ ] arr , int maxElement ) { /* ▁ create ▁ hash ▁ */ int prev = 0 , curr = 1 ; /* ▁ create ▁ hash ▁ */ int temp ; /* ▁ create ▁ hash ▁ */ while ( ( curr <= maxElement ) && ( arr [ curr ] <= maxElement ) ) { temp = curr + prev ; if ( temp <= maxElement ) { /* ▁ add ▁ */ } prev = curr ; curr = temp ; } /* ▁ gcdFibonacciFreq ▁ */ { HashSet < Integer > hash1 = new HashSet < Integer > ( ) ; /* ▁ create ▁ hash ▁ */ createHash ( hash1 , Math . max ( arr , 0 ) ) ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { m . put ( arr [ i ] , i ++ ) ; } int gcd = 0 ; for ( Integer it : m . keySet ( ) ) { if ( ( hash1 . contains ( it ) ) && ( hash1 . contains ( it ) ) ) { gcd = Math . gcd ( gcd , it ) ; } } return gcd ; } /* ▁ if ▁ ( args . length ▁ > = ▁ 0 ) ▁ { STRNEWLINE ▁ int [ ] ▁ arr ▁ = ▁ { 5 , ▁ 3 , ▁ 6 , ▁ 5 , ▁ 6 , ▁ 6 , ▁ 5 , ▁ 5 } ; STRNEWLINE ▁ int ▁ n ▁ = ▁ arr . length ; STRNEWLINE ▁ System . out . println ( gcdFibonacciFreq ( arr , ▁ n ) ) ; STRNEWLINE ▁ } */ }
@ GwtIncompatible ( " java . lang . Double " ) public static double findArea ( double a ) { double R = a * ( 2.0 - Math . sqrt ( 2 ) ) ; double area = 3.14 * R * R / 2.0 ; return area ; }
static int findQuadruples ( int [ ] a , int [ ] b , int [ ] c , int [ ] d , int x , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int l = 0 ; l < n ; l ++ ) { if ( ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) ) { count ++ ; } } } } } return count ; }
static void findSmallest ( String s , int [ ] [ ] q , int m ) { int N = s . length ( ) ; int [ ] [ ] H = new int [ N + 1 ] [ 26 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) { H [ i ] [ ( s . charAt ( i - 1 ) - ' a ' ) ] ++ ; for ( int j = 0 ; j < 26 ; j ++ ) { H [ i ] [ j ] += H [ i - 1 ] [ j ] ; } } for ( int j = 0 ; j < m ; j ++ ) { int l = q [ j ] [ 0 ] ; int r = q [ j ] [ 1 ] ; int n = q [ j ] [ 2 ] ; int sum = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { sum += H [ r ] [ i ] - H [ l - 1 ] [ i ] ; if ( ( sum >= n ) && ( sum <= n ) ) { System . out . println ( ( char ) ( ' a ' + i ) ) ; break ; } } } if ( Class . forName ( " java . lang . String " ) . equals ( s ) ) { s = " afbccdeb " ; q = new int [ ] [ ] { { 2 , 4 , 1 } , { 1 , 6 , 4 } , { 1 , 8 , 7 } } ; int x = q . length ; findSmallest ( s , q , x ) ; } }
public static int miner ( int a , int b , String mines ) { int s = 0 ; int j = 0 ; while ( j < mines . length ( ) && mines . charAt ( j ) != '1' ) { j ++ ; } if ( j == mines . length ( ) ) { return 0 ; } for ( int i = j + 1 ; i < mines . length ( ) ; i ++ ) { if ( mines . charAt ( i ) == '0' && mines . charAt ( i - 1 ) == '1' ) { int r1 = i - 1 ; } else if ( mines . charAt ( i ) == '1' && mines . charAt ( i - 1 ) == '0' ) { s += Math . min ( b * ( i - r1 - 1 ) , a ) ; } } s += a ; return s ; } int t = Integer . parseInt ( input ( ) ) ; for ( int i = 0 ; i < t ; i ++ ) { a = Integer . parseInt ( input ( ) ) ; b = Integer . parseInt ( input ( ) ) ; mines = input ( ) ; System . out . println ( miner ( a , b , mines ) ) ; }
public static int t = Integer . parseInt ( input ) { for ( int i = 0 ; i <= t ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int startPoint = 0 ; int numbMoves = 0 ; if ( n == 1 ) { System . out . println ( 2 ) ; } else if ( n % 3 == 0 ) { System . out . println ( ( int ) ( n / 3 ) ) ; continue ; } else if ( n == 2 || n == 3 ) { System . out . println ( 1 ) ; } else { int x = n % 3 ; System . out . println ( ( int ) ( ( n - x ) / 3 + 1 ) ) ; } } return t ; }
public static void print ( String s ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; StringBuilder sb = new StringBuilder ( ) ; int [ ] q = new int [ n ] ; for ( int i = n ; i > 0 ; i -- ) { if ( n % i == 0 ) { q [ i ] = i ; } } for ( int j : q ) { int w = n / j ; sb . append ( s ) ; } System . out . println ( sb . toString ( ) ) ; }
static void printPairs ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) && ( Math . abs ( arr [ j ] ) == Math . abs ( arr [ j ] ) ) ) { v . add ( Math . abs ( arr [ i ] ) ) ; } } } if ( ( v . size ( ) == 0 ) ) { return ; } Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { System . out . print ( - v . get ( i ) + " ▁ " + v . get ( i ) + " ▁ " ) ; } }
public static double doublefactorial ( int n ) { if ( ( n == 0 ) || ( n == 1 ) ) { return 1 ; } return n * doublefactorial ( n - 2 ) ; }
static int isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( ( h > l ) && ( l < h ) ) { if ( ( str . charAt ( l ) != str . charAt ( h ) ) ) { return 0 ; } l = l + 1 ; h = h - 1 ; } return 1 ; }
static int sumOfSubstrings ( String num ) { int n = num . length ( ) ; int [ ] sumofdigit = new int [ n ] ; sumofdigit [ 0 ] = Integer . parseInt ( num . substring ( 0 , 1 ) ) ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = Integer . parseInt ( num . substring ( i , i + 1 ) ) ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; }
static int findCountOfPairs ( double a , double b , int n ) { int ans = 0 ; ans += n * ( int ) ( a / n ) * ( int ) ( b / n ) ; ans += ( int ) ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( int ) ( b / n ) ; ans += ( int ) ( ( ( a % n ) + ( b % n ) ) / n ) ; return ans ; }
public static String compute ( ) { final int LIMIT = 1000000 ; long maxnumer = 0 ; long maxdenom = 1 ; for ( long d = 1 ; d <= LIMIT ; d ++ ) { long n = d * 3 / 7 ; if ( d % 7 == 0 ) { n -- ; } if ( n * maxdenom > d * maxnumer ) { maxnumer = n ; maxdenom = d ; } } return Long . toString ( maxnumer ) ; }
static int [ ] c = new int [ 100 ] ; int n ; int i ; c [ 0 ] = 1 ; for ( i = 0 ; i < n ; i ++ ) { c [ 1 + i ] = 1 ; for ( j = i ; j > 0 ; j -- ) c [ j ] = c [ j - 1 ] - c [ j ] ; c [ 0 ] = - c [ 0 ] ; } /* ▁ Prime ▁ n ▁ */ coef ( n ) ; c [ 0 ] = c [ 0 ] + 1 ; c [ n ] = c [ n ] - 1 ; i = n ; while ( ( i > - 1 ) && ( c [ i ] % n == 0 ) ) { i = i - 1 ; } return i < 0 ? true : false ; }
static final int count_greater ( int [ ] arr , int n ) { int min = Integer . MAX_VALUE ; int counter = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ( arr [ i ] > min ) && ( arr [ i ] <= min ) ) { counter ++ ; } if ( ( arr [ i ] <= min ) && ( arr [ i ] <= min ) ) { min = arr [ i ] ; } } return counter ; }
public static int n ( int input , int x ) { int [ ] aArray = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aArray [ i ] = input ; Arrays . sort ( aArray ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = x - aArray [ i ] ; count ++ ; if ( x <= 0 ) break ; } if ( x == 0 ) System . out . println ( count ) ; else System . out . println ( count - 1 ) ; return count ; }
public static void print ( int n ) { int left = 0 ; int right = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int a = Integer . parseInt ( input . readLine ( ) ) ; int b = Integer . parseInt ( input . readLine ( ) ) ; if ( a > 0 ) right ++ ; else if ( a < 0 ) left ++ ; } if ( left == 0 || right == 0 || left == 1 || right == 1 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } }
public static void main ( ) { int T = Integer . parseInt ( input . readLine ( ) ) ; int D = Integer . parseInt ( input . readLine ( ) ) ; int L = Integer . parseInt ( input . readLine ( ) ) ; if ( T == 0 ) break ; int [ ] a = new int [ T ] ; for ( int i = 0 ; i < T ; i ++ ) { int x = Integer . parseInt ( input . readLine ( ) ) ; if ( x >= L ) a [ i ] = i ; } T = T - 1 ; int ans = 0 ; for ( int i = 1 ; i < a . length ; i ++ ) { int x = D ; if ( T - a [ i - 1 ] < D ) x = T - a [ i - 1 ] ; if ( a [ i ] - a [ i - 1 ] < x ) ans += a [ i ] - a [ i - 1 ] ; else ans += x ; } if ( a . length > 0 ) ans += T - a [ a . length - 1 ] + D > T ? T - a [ a . length - 1 ] : D ; System . out . println ( ans ) ; }
static int minimumSwaps ( int [ ] arr ) { int count = 0 ; int i = 0 ; int temp ; while ( ( i < arr . length ) && ( arr [ i ] != i + 1 ) ) { while ( ( temp = arr [ arr . length - 1 ] ) != 0 ) { arr [ i ] = temp ; temp = arr [ arr . length - 1 ] ; arr [ arr . length - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } i ++ ; } return count ; }
static final String compute ( ) { final int TARGET = 500500 ; final int MODULUS = 500500507 ; final List < Integer > isprime = eulerJNI . listPrimality ( 7376507 ) ; final List < Integer > queue = new ArrayList < > ( ) ; int nextprime = 2 ; heapq . add ( queue ) ; long ans = 1 ; for ( int i = 0 ; i < TARGET ; i ++ ) { final int item = heapq . get ( ) ; ans *= item ; ans %= MODULUS ; heapq . add ( queue . size ( ) * item ) ; if ( item == nextprime ) { nextprime ++ ; while ( ! isprime . get ( nextprime ) ) { nextprime ++ ; } heapq . add ( queue . size ( ) * item ) ; } } return Long . toString ( ans ) ; }
static void findUniquePair ( int [ ] arr , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; int setBitNo = XOR & ~ ( XOR - 1 ) ; int x = 0 ; int y = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] & setBitNo ) != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ unique ▁ pair ▁ is ▁ ( " + x + " , ▁ " + y + " ) " ) ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = input . nextInt ( ) ; s [ i ] = k ; } int flag = 0 ; int [ ] d1 = new int [ n ] ; int [ ] d2 = new int [ n ] ; Set < String > rem = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i == j ) && ( s [ i ] == s [ j ] ) ) { d1 [ flag ++ ] = s [ i ] ; } if ( ( i == n - j - 1 ) && ( s [ i ] == s [ j ] ) ) { d2 [ flag ++ ] = s [ i ] ; } if ( ( i != j ) && ( i != n - j - 1 ) ) { rem . add ( s [ i ] ) ; } } } if ( ( rem . size ( ) != 1 ) && ( ! rem . contains ( s [ i ] ) ) ) { System . out . println ( " NO " ) ; } else if ( ( d1 != d2 ) && ( ! d1 . contains ( s [ i ] ) ) ) { System . out . println ( " NO " ) ; } else if ( ( new HashSet < String > ( d1 ) . contains ( s [ i ] ) ) && ( ! rem . contains ( s [ i ] ) ) ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } }
static final Scanner scanner = new Scanner ( System . in ) { final Scanner scanner = new Scanner ( System . in ) ; for ( final String s : scanner ) { System . out . println ( s . replaceAll ( " @ ( \\ d ) ( . ) " , " @ ( \\ d ) ( . ) " ) ) ; } return scanner ; }
static boolean isMajority ( int [ ] a ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i : a ) { if ( mp . containsKey ( i ) ) mp . put ( i , 1 ) ; else mp . put ( i , 1 ) ; } for ( int x : mp . keySet ( ) ) { } return false ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; int w = Integer . parseInt ( input ) ; int [ ] [ ] vw_l = new int [ n ] [ n ] ; for ( int y = 0 ; y < n ; y ++ ) vw_l [ y ] [ w ] = Integer . parseInt ( input ) ; int [ ] [ ] dp = new int [ n + 1 ] [ w ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ i ] = 0 ; } }
@ GwtIncompatible ( " java . util . Scanner " ) public static void main ( String [ ] args ) { final double PI2 = PI / 2 ; final double [ ] L = { null , new Double ( 1.0 ) , new Double ( 0.0 ) } ; for ( int i = 2 ; i < 1001 ; i ++ ) { final double x = L [ i - 1 ] ; final double y = L [ i ] ; final double rad = atan2 ( y , x ) + PI2 ; L [ i - 1 ] = new Double ( x + cos ( rad ) , y + sin ( rad ) ) ; } for ( ; ; ) { final int n = Integer . parseInt ( args [ i ] ) ; if ( n == - 1 ) break ; System . out . println ( " { :0.2f } \n { :0.2f } " , ( double ) L [ n ] ) ; } }
static void printKMissing ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( ( i < n ) && ( arr [ i ] <= 0 ) ) { i = i + 1 ; } int count = 0 ; int curr = 1 ; while ( ( count < k ) && ( i < n ) ) { if ( ( arr [ i ] != curr ) ) { System . out . print ( Integer . toString ( curr ) + " ▁ " ) ; curr = curr + 1 ; count = count + 1 ; } } }
static void printNumbers ( int [ ] a , int n ) { Map < Integer , Integer > mpp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; for ( int j = 1 ; j <= num ; j ++ ) { if ( j * j > num ) break ; if ( ( num % j ) == 0 ) { if ( ( j != 1 ) && ( j != 0 ) ) mpp . put ( j , mpp . get ( j ) + 1 ) ; if ( ( ( num / j ) != 0 ) && ( j != 0 ) ) mpp . put ( num / j , mpp . get ( j ) + 1 ) ; } } } }
public static void input ( Scanner s ) { String ts = s . nextLine ( ) ; int ls = ts . length ( ) / 2 ; String ans = s . substring ( 0 , s . length ( ) - ls ) ; if ( ts . length ( ) % 2 != 0 || ans . replace ( " a " , " " ) . length ( ) != ts . length ( ) ) { System . out . println ( " : ( " ) ; } else { System . out . println ( ans ) ; } }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; List < Integer > a = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a . add ( Integer . parseInt ( input ) ) ; } int K = Math . max ( a . size ( ) , Integer . parseInt ( input ) ) ; int i = 0 ; do { if ( a . indexOf ( a . get ( i ) ) < K ) { int C = a . indexOf ( a . get ( i ) ) ; n -= C ; int Val = a . get ( i ) ; for ( int k = 0 ; k < C ; k ++ ) { a . remove ( Val ) ; } } else { i ++ ; } } while ( i == n ) ; int MinI = 1000001 ; int ID = - 1 ; int [ ] A = Lists . newArrayList ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { int j = n - 1 ; while ( j >= 0 && a . get ( j ) != A [ i ] ) { j -- ; } if ( j < MinI ) { MinI = j ; ID = A [ i ] ; } } System . out . println ( ID ) ; }
static void checkIfStartsWithCapital ( String string ) { if ( ( string . charAt ( 0 ) >= ' A ' ) && ( string . charAt ( 0 ) <= ' Z ' ) ) { return ; } else { return ; } /* if ▁ ( ( checkIfStartsWithCapital ( string ) ) ) ▁ { STRNEWLINE ▁ System . out . println ( " Accepted " ) ; STRNEWLINE ▁ } */ /* if ▁ ( ( checkIfStartsWithCapital ( string ) ) ) ▁ { STRNEWLINE ▁ System . out . println ( " Not ▁ Accepted " ) ; STRNEWLINE ▁ } */ if ( className . equals ( " org . geeksforGeeks " ) ) { string = " GeeksforGeeks " ; check ( string ) ; string = " geeksforgeeks " ; check ( string ) ; } }
static double getAvg ( double prevAvg , double x , int n ) { return ( ( prevAvg * n + x ) / ( n + 1 ) ) ; /* ▁ stream ▁ avg ▁ */ double avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( avg , arr , i ) ; } }
static String compute ( ) { final int ans = 0 ; final boolean [ ] isprime = EulerLibrary . listPrimality ( 999999 ) ; final int [ ] primes = EulerLibrary . listPrimes ( 999999 ) ; int consecutive = 0 ; for ( int i = 0 ; i < primes . length ; i ++ ) { int sum = primes [ i ] ; int consec = 1 ; for ( int j = i + 1 ; j < primes . length ; j ++ ) { sum += primes [ j ] ; consec ++ ; if ( sum >= isprime . length ) break ; if ( isprime [ sum ] && consec > consecutive ) { ans = sum ; consecutive = consec ; } } } return String . valueOf ( ans ) ; }
public static int lis ( int arr [ ] , int n ) { int i , j , maxm = 0 ; int [ ] list = new int [ n ] ; for ( int s = 0 ; s < n ; s ++ ) list [ s ] = 1 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( ( arr [ i ] > arr [ j ] ) && ( lst [ i ] < lst [ j ] + 1 ) ) list [ i ] = lst [ j ] + 1 ; } } for ( ; i < n ; i ++ ) if ( maxm < list [ i ] ) maxm = list [ i ] ; return maxm ; }
public static int calc ( String input ) { int a = ( i = input . indexOf ( " ▁ " ) ) ; int b = ( i = input . indexOf ( " ▁ " ) ) ; int z = ( int ) ( a + b ) ; final int i = ( int ) ( a + b ) ; if ( i == z * ( 1 / 2 ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return i ; }
public static int [ ] fix ( int [ ] A ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) s . add ( A [ i ] ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( s . contains ( i ) ) A [ i ] = i ; else A [ i ] = - 1 ; } return A ; }
public static void main ( String [ ] args ) { int [ ] A = new int [ 4 ] ; for ( int i = 0 ; i < A . length ; i ++ ) A [ i ] = Integer . parseInt ( input ( ) . nextLine ( ) ) ; int ans = Math . abs ( A [ 0 ] + A [ 1 ] - A [ 2 ] - A [ 3 ] ) ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( i == j ) continue ; int now = 0 ; for ( int t = 0 ; t < 4 ; t ++ ) { if ( t == i || t == j ) now += A [ t ] ; else now -= A [ t ] ; } if ( Math . abs ( now ) < ans ) ans = Math . abs ( now ) ; } } System . out . println ( ans ) ; if ( getClass ( ) . isClassPresent ) Main . main ( args ) ; }
public static Node < Integer > __init__ ( int data ) { Node < Integer > head ; Node < Integer > data ; head = null ; head . prev = null ; head . next = null ; /* push ▁ head ▁ */ head = new Node < Integer > ( data ) ; /* push ▁ head ▁ */ head . next = head ; /* makeOddNode ( head ) ; */ Node < Integer > newNode ; /* makeOddNode ( head ) ; */ head . prev = newNode ; /* printList ( head ) ; */ head . next = null ; int [ ] A = { 3 , 5 , 23 , 17 , 1 } ; head = push ( head , 4 ) ; head = push ( head , 7 ) ; head = push ( head , 8 ) ; head = push ( head , 9 ) ; head = push ( head , 6 ) ; int n = Arr . length ; System . out . print ( " Original ▁ List : " ) ; /* printList ( head ) ; */ System . out . println ( ) ; /* makeOddNode ( head , Arr , n ) ; */ System . out . print ( " New ▁ odd ▁ List : " ) ; /* printList ( head ) ; */ }
public static int [ ] s_max = new int [ 11 ] ; s_max [ 0 ] = 0 ; for ( int i = 1 ; i < 11 ; i ++ ) { int s = 0 ; for ( int j = 0 ; j < i ; j ++ ) s += ( 10 - j - 1 ) * ( i - j ) ; s_max [ i ] = s ; } { boolean [ ] u = new boolean [ 10 ] ; int r = 0 ; int s = 0 ; int [ ] m = new int [ 10 ] ; if ( r == 0 ) { return s == 0 ; } int n = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { n *= 2 ; if ( u [ i ] ) n ++ ; } if ( ( n = m [ n ] ) != 0 ) return m [ ( n = n ) ] ; if ( s < 0 || s > s_max [ r ] ) return 0 ; int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( ! u [ i ] ) { u [ i ] = true ; ans += check ( u , r - 1 , s - i * r , m ) ; u [ i ] = false ; } } m [ ( n = n ) ] = ans ; return m [ ( n = n ) ] ; } HashMap < Integer , Integer > memo = new HashMap < Integer , Integer > ( ) ; while ( true ) { try { int n = Integer . parseInt ( input . readLine ( ) ) ; int s = Integer . parseInt ( input . readLine ( ) ) ; boolean [ ] used = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { used [ i ] = false ; } int ans = check ( used , n , s , memo ) ; System . out . println ( ans ) ; } catch ( Exception e ) { break ; } }
static long mod = 1000000007 ; long res = 1 ; for ( long i = 2 ; i <= n ; i ++ ) { res = res * i ; } /* ▁ nCr ▁ */ long n = ( long ) ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) ; /* ▁ powMod ▁ */ if ( ( n == 0 ) || ( n == 1 ) ) { return 1 ; } long pt = powMod ( a , ( int ) ( n / 2 ) ) ; pt = ( pt * pt ) % mod ; if ( ( n % 2 ) != 0 ) { return ( pt * a ) % mod ; } else { return pt ; } /* ▁ CountSubset ▁ */ long ans = powMod ( 2 , n - 1 ) ; Arrays . sort ( arr , false ) ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( ( j < n ) && arr [ j ] == arr [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } /* ▁ CountSubset ▁ */ if ( __name__ == " main " ) { int arr [ ] = { 2 , 3 , 2 } ; int n = arr . length ; System . out . println ( CountSubset ( arr , n ) ) ; } return ans ; }
public static int [ ] countOfNumbers ( int N , int K ) { int MAX = 1000001 ; int MAX_sqrt = MAX * ( 0.5 ) ; int [ ] primeUpto = new int [ MAX ] ; { int [ ] isPrime = new int [ MAX ] ; isPrime [ 0 ] = 0 , isPrime [ 1 ] = 0 ; for ( int i = 2 ; i < Integer . MAX_VALUE ; i ++ ) { if ( isPrime [ i ] == 1 ) { for ( int j = i * 2 ; j < MAX ; j += i ) { isPrime [ j ] = 0 ; } } } for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] == 1 ) { primeUpto [ i ] ++ ; } } } { SieveOfEratosthenes ( ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) > > 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else { low = mid + 1 ; } } return ans != 0 ? ( N - ans + 1 ) : 0 ; } }
static int countOperations ( int n ) { int i = 2 ; while ( ( ( i * i ) < n ) && ( n % i ) != 0 ) { i ++ ; } if ( ( ( i * i ) > n ) ) { i = n ; } return ( 1 + ( n - i ) / 2 ) ; }
private static int [ ] [ ] scan ( String input ) { int n = Integer . parseInt ( input ) ; int q = Integer . parseInt ( input ) ; char [ ] s = input . toCharArray ( ) ; int [ ] ac = new int [ n - 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == ' A ' && s [ i + 1 ] == ' C ' ) { ac [ i ] = 1 ; } } int [ ] acc = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { acc [ i + 1 ] = acc [ i ] + ac [ i ] ; } int [ ] [ ] lr = new int [ q ] [ n ] ; for ( int i = 0 ; i < lr . length ; i ++ ) { lr [ i ] = Integer . parseInt ( input . toCharArray ( ) ) ; } for ( int i = 0 ; i < q ; i ++ ) { int l = lr [ i ] [ 0 ] - 1 ; int r = lr [ i ] [ 1 ] - 1 ; System . out . println ( acc [ r ] - acc [ l ] ) ; } return lr ; }
public static int T = Integer . parseInt ( input ) { for ( int i = 0 ; i < T ; i ++ ) { int l = Integer . parseInt ( input . readLine ( ) ) ; int r = Integer . parseInt ( input . readLine ( ) ) ; System . out . println ( l + " ▁ " + l * 2 ) ; } return T ; }
static String compute ( ) { final int LIMIT = 5000 ; final int MODULUS = 10 * 16 ; final int [ ] count = new int [ LIMIT * 2 / 2 ] ; Arrays . fill ( count , 1 ) ; int s = 0 ; for ( int p : EulerLibrary . listPrimes ( LIMIT ) ) { for ( int i = 0 ; i < s + 1 ; i ++ ) { count [ i + p ] = ( count [ i + p ] + count [ i ] ) % MODULUS ; } s += p ; } final List < Integer > isprime = EulerLibrary . listPrimality ( s + 1 ) ; final int ans = Integer . valueOf ( isprime . get ( s ) ) % MODULUS ; return String . valueOf ( ans ) ; }
static int countOddNumber ( int rowNum ) { int count = 0 ; while ( rowNum != 0 ) { count += rowNum & 1 ; rowNum >>= 1 ; } return ( 1 << count ) ; /* ▁ gouldSequence ▁ n ▁ */ for ( rowNum = 0 ; rowNum != 0 ; rowNum ++ ) { System . out . print ( countOddNumber ( rowNum ) + " ▁ " ) ; } if ( className . equals ( " java . lang . String " ) ) { int n = 16 ; gouldSequence ( n ) ; } return n ; }
static void findMin ( int V ) { int [ ] deno = { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 } ; int n = deno . length ; ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; int i = n - 1 ; while ( ( i >= 0 ) && ( V >= deno [ i ] ) ) { V -= deno [ i ] ; ans . add ( deno [ i ] ) ; } i -- ; for ( i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + " ▁ " ) ; } } if ( Class . isEnum ( ) ) { n = 93 ; System . out . print ( " Following ▁ is ▁ minimal ▁ number " + " ▁ of ▁ change ▁ for " + n + " : ▁ " ) ; findMin ( n ) ; }
static String compute ( ) { final Predicate < Integer > cond = i -> Arrays . stream ( String . valueOf ( i ) ) . allMatch ( j -> j * j == 7 ) ; Integer ans = ( Integer ) i ; if ( cond . test ( i ) ) System . out . println ( compute ( ) ) ; return ans . toString ( ) ; }
public static int count ( int arr [ ] , int n , int x ) { if ( ( x == 1 ) && ( arr [ 0 ] == arr [ 1 ] ) ) { int ans = Math . pow ( 2 , n ) - 1 ; return ans ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % x == 0 ) && ( arr [ i ] == arr [ i ] ) ) { count ++ ; } } int ans = Math . pow ( 2 , count ) - 1 ; return ans ; }
static int findEle ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == sum - arr [ i ] ) { return arr [ i ] ; } } return - 1 ; }
static char findExtraCharacter ( String strA , String strB ) { HashMap < Character , Integer > m1 = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < strB . length ( ) ; i ++ ) { if ( m1 . containsKey ( strB . charAt ( i ) ) ) { m1 . put ( strB . charAt ( i ) , 1 ) ; } else { m1 . put ( strB . charAt ( i ) , 1 ) ; } } for ( int i = 0 ; i < strA . length ( ) ; i ++ ) { m1 . put ( strA . charAt ( i ) , -- 1 ) ; } for ( char h1 : m1 . keySet ( ) ) { if ( m1 . get ( h1 ) == 1 ) { return h1 ; } } if ( getClass ( ) . equals ( " java . lang . String " ) ) { strA = " abcd " ; strB = " cbdad " ; System . out . println ( findExtraCharacter ( strA , strB ) ) ; } return 0 ; }
public static void solve ( ) { int balls = Integer . parseInt ( input . nextLine ( ) ) ; int ans = 0 ; if ( balls == 0 ) { break ; } for ( int cs = 0 ; cs < 54 ; cs ++ ) { for ( int ts = 0 ; ts < 96 ; ts ++ ) { if ( Math . pow ( cs , 3 ) <= balls ) { ans = Math . max ( ans , Math . pow ( cs , 3 ) ) ; } if ( ts * ( ts + 1 ) * ( ts + 2 ) / 6 <= balls ) { ans = Math . max ( ans , ts * ( ts + 1 ) * ( ts + 2 ) / 6 ) ; } if ( Math . pow ( cs , 3 ) + ts * ( ts + 1 ) * ( ts + 2 ) / 6 <= balls ) { ans = Math . max ( ans , Math . pow ( cs , 3 ) + ts * ( ts + 1 ) * ( ts + 2 ) / 6 ) ; } } } System . out . println ( ans ) ; }
public static String substitute ( String text , String a , String b ) { int pos = 0 ; String newText = text ; int L1 = a . length ( ) ; int L2 = b . length ( ) ; do { int idx = newText . indexOf ( a , pos ) ; if ( idx < 0 ) { return newText ; } newText = newText . substring ( 0 , idx ) + b + newText . substring ( idx + L1 ) ; pos = idx + L2 ; } while ( pos < text . length ( ) ) ; /* ▁ transform ▁ each ▁ string ▁ to ▁ a ▁ string ▁ */ if ( text . length ( ) > goal . length ( ) ) { return text ; } if ( text . equals ( goal ) ) { minCount = Math . min ( minCount , text . length ( ) ) ; return text ; } for ( String key : subs . keySet ( ) ) { String newStr = substitute ( orig , key , subs . get ( key ) ) ; if ( newStr != orig ) { transform ( newStr , goal , count + 1 ) ; } } if ( getClass ( ) . isEnum ( ) ) { int N ; do { N = Integer . parseInt ( input ( ) ) ; } while ( N == 0 ) ; subs = new HashMap < String , String > ( ) ; for ( ; ; ) { a = input ( ) ; b = input ( ) ; subs . put ( a , b ) ; } String orig = input ( ) ; String goal = input ( ) ; minCount = 999999999 ; transform ( orig , goal , 0 ) ; if ( minCount == 999999999 ) { System . out . println ( - 1 ) ; } else { System . out . println ( minCount ) ; } } return newText ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; List < String > ls = Lists . newArrayList ( ) ; for ( String s : input . split ( " ▁ " ) ) ls . add ( s ) ; Map < String , Integer > cnt = Maps . newHashMap ( ) ; boolean ans = true ; for ( String el : ls ) { if ( ! cnt . containsKey ( el ) ) cnt . put ( el , 1 ) ; else cnt . put ( el , 1 ) ; if ( cnt . get ( el ) > ( n + 1 ) / 2 ) ans = false ; } if ( ans ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
static final int maxSumPair ( int [ ] arr1 , int n1 , int [ ] arr2 , int n2 ) { int max1 = - Integer . MAX_VALUE - 1 ; int max2 = - Integer . MAX_VALUE - 1 ; for ( int i = 0 ; i <= n1 ; i ++ ) { if ( ( arr1 [ i ] > max1 ) && ( arr1 [ i ] > max2 ) ) max1 = arr1 [ i ] ; } for ( int i = 0 ; i <= n2 ; i ++ ) max2 = arr2 [ i ] ; return max1 + max2 ; }
public static int operations ( int [ ] op , int n , int k ) { int i , count ; int nVal = 0 ; int minimum = 10 * 9 ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; minimum = Math . min ( minimum , nVal ) ; if ( ( ( k + nVal ) <= 0 ) && ( ( k + nVal ) <= 0 ) ) { return ( i + 1 ) ; } } if ( ( nVal >= 0 ) && ( ( k + nVal ) <= 0 ) ) { return - 1 ; } int times = ( k - Math . abs ( minimum ) ) / Math . abs ( nVal ) ; k = ( k - ( times * Math . abs ( nVal ) ) ) ; count = ( times * n ) ; while ( ( k > 0 ) && ( ( k + nVal ) <= 0 ) ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( ( k <= 0 ) && ( ( k + nVal ) <= 0 ) ) { break ; } } } return count ; }
static int [ ] [ ] pref = new int [ 100010 ] [ ] ; { int i ; int R ; int R ; int R ; int R ; { R = Math . round ( R * ( 1 / 3 ) ) ; R = R ; R = ( R * cr * cr == R ) ? R : 0 ; } { int R ; R = R ; } { compute ( ) ; for ( i = 1 ; i < 100001 ; i ++ ) { pref [ i ] = pref [ i - 1 ] + isPerfectCube ( i ) ; } } { int sum = pref [ R ] - pref [ L - 1 ] ; System . out . print ( sum + " ▁ " ) ; } if ( getClass ( ) . getName ( ) . equals ( " java . lang . Integer " ) ) { compute ( ) ; } Q = 4 ; int [ ] [ ] arr = { { 1 , 10 } , { 1 , 100 } , { 2 , 25 } , { 4 , 50 } } ; for ( i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } }
static final Scanner in = new Scanner ( System . in ) { int n , r , l ; int [ ] appearance = new int [ n ] ; int [ ] point = new int [ n ] ; int top = 0 ; int preT = 0 ; while ( r > 0 ) { int d = Integer . parseInt ( in . nextLine ( ) ) ; int t = Integer . parseInt ( in . nextLine ( ) ) ; int x = Integer . parseInt ( in . nextLine ( ) ) ; d -- ; appearance [ top ] += t - preT ; preT = t ; point [ d ] += x ; if ( 0 < x && top != d ) { if ( point [ top ] < point [ d ] ) { top = d ; } else if ( point [ top ] == point [ d ] && d < top ) { top = d ; } } else if ( x < 0 && top == d ) { top = point [ d ] ; } } appearance [ top ] += l - preT ; System . out . println ( 1 + appearance . length ) ; return new Scanner ( appearance ) ; }
public static int centeredCube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; if ( getClass ( ) . equals ( int . class ) ) { n = 3 ; System . out . println ( Integer . toString ( n ) + " th ▁ Centered ▁ cube ▁ number : ▁ " + centeredCube ( n ) ) ; n = 10 ; System . out . println ( Integer . toString ( n ) + " th ▁ Centered ▁ cube ▁ number : ▁ " + centeredCube ( n ) ) ; } return 0 ; }
public static int t = Integer . parseInt ( input ) { for ( int testcase = 0 ; testcase < t ; testcase ++ ) { int n = Integer . parseInt ( input . readLine ( ) ) ; String s = input . readLine ( ) ; int lef = 1 , rig = 1 , sw = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( s . charAt ( i ) > s . charAt ( i + 1 ) ) && ( sw == 0 ) ) { sw = 1 ; break ; } } if ( ( sw == 0 ) && ( s . charAt ( i ) == '1' ) ) { System . out . println ( s ) ; continue ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == '1' ) && ( sw == 0 ) ) { lef = i ; break ; } } for ( int i = n - 1 ; i > 0 ; i -- ) { if ( ( s . charAt ( i ) == '0' ) && ( sw == 0 ) ) { rig = i ; break ; } } String st = s . substring ( 0 , lef ) + "0" + s . substring ( rig + 1 ) ; System . out . println ( st ) ; } return t ; }
public static int nthTerm ( int N ) { int nth = 0 ; for ( int i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }
static boolean isPower ( int x , int y ) { if ( ( x == 1 ) && ( y == 1 ) ) return ( y == 1 ) ; int pow = 1 ; while ( ( pow < y ) && ( pow < x ) ) pow = pow * x ; return ( pow == y ) ; }
static boolean isPower ( int x , int y ) { if ( ( x == 1 ) && ( y == 1 ) ) { return ( y == 1 ) ; } int pow = 1 ; while ( ( pow < y ) && ( pow < x ) ) { pow = pow * x ; } return ( pow == y ) ; if ( ( isPower ( 10 , 1 ) ) ) { System . out . println ( 1 ) ; } else { System . out . println ( 0 ) ; } if ( ( isPower ( 1 , 20 ) ) ) { System . out . println ( 1 ) ; } else { System . out . println ( 0 ) ; } if ( ( isPower ( 2 , 128 ) ) ) { System . out . println ( 1 ) ; } else { System . out . println ( 0 ) ; } if ( ( isPower ( 2 , 30 ) ) ) { System . out . println ( 1 ) ; } else { System . out . println ( 0 ) ; } return ( isPower ( 2 , 30 ) ) ; }
static int minimumValue ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) { answer += arr [ i ] * arr [ i ] ; } return answer * ( 2 * k - 2 ) ; }
public static void bfs ( int x , boolean [ ] visited , List < Integer > order ) { if ( visited [ x ] ) return ; visited [ x ] = true ; for ( int to : edges [ x ] ) bfs ( to , visited , order ) ; order . add ( x ) ; /* ▁ if ▁ ( visited [ x ] ) ▁ return ; ▁ visited [ x ] ▁ = ▁ true ; ▁ */ List < Integer > ret = new ArrayList < > ( ) ; ret . add ( x ) ; for ( int to : revEdges [ x ] ) ret . addAll ( bffs ( to ) ) ; /* ▁ order ▁ is ▁ sorted ▁ by ▁ the ▁ reverse ▁ order ▁ */ int n = Integer . parseInt ( input ( ) ) ; edges = new ArrayList < > ( 200 ) ; revEdges = new ArrayList < > ( 200 ) ; for ( int to : revEdges [ x ] ) { for ( int to : revEdges [ to ] ) ret . addAll ( bffs ( to ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { int u = input ( ) ; String s = input ( ) ; int d = input ( ) ; u = Integer . parseInt ( u ) - 1 ; d = Integer . parseInt ( d ) - 1 + 100 ; if ( s . equals ( " lock " ) ) { edges . get ( d ) . add ( u ) ; revEdges . get ( u ) . add ( d ) ; } else { edges . get ( u ) . add ( d ) ; revEdges . get ( d ) . add ( u ) ; } } order . clear ( ) ; visited = new boolean [ 200 ] ; for ( int i = 0 ; i < 200 ; i ++ ) if ( ! visited [ i ] ) bfs ( i , visited , order ) ; Collections . reverse ( order ) ; visited = new boolean [ 200 ] ; for ( int i = 0 ; i < order . size ( ) ; i ++ ) if ( ! visited [ i ] ) { if ( bffs ( order . get ( i ) ) . size ( ) >= 2 ) { System . out . println ( 1 ) ; break ; } } else System . out . println ( 0 ) ; }
static int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( ( N == 1 ) || ( N == 2 ) ) { return 0 ; } return ( int ) Math . pow ( 2 , E - 1 ) ; }
static int findLCM ( int [ ] arr , int n ) { final int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { lcm = ( lcm * arr [ i ] ) / Math . gcd ( arr [ i ] , lcm ) ; } return lcm ; }
public static int getN ( ) { return Integer . parseInt ( input . nextLine ( ) ) ; /* ▁ Get ▁ the ▁ number ▁ of ▁ ns ▁ */ final int n = input . nextInt ( ) ; final Set < Integer > ns = new TreeSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ns . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } final int [ ] top3 = { 9999999999 , 9999999999 , 9999999999 } ; for ( int i = 0 ; i < n ; i ++ ) { final int a = ns . iterator ( ) . next ( ) ; for ( int j = 0 ; j < n ; j ++ ) { final int b = ns . iterator ( ) . next ( ) ; if ( i == j ) { continue ; } final int keta = ( int ) Math . log10 ( b ) + 1 ; final int c = a * Math . pow ( 10 , keta ) + b ; if ( c < top3 [ 2 ] ) { top3 = new ArrayList < > ( top3 ) ; top3 . add ( c ) ; } } } System . out . println ( top3 [ 2 ] ) ; if ( getClass ( ) . equals ( Main . class ) ) { Main . main ( ) ; } return n ; }
private static void solve ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; n = n * 4 ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Integer . parseInt ( input . nextLine ( ) . trim ( ) ) ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; Arrays . sort ( a ) ; int i = 0 ; int j = n - 1 ; int area = a [ i ] * a [ j ] ; i ++ ; j -- ; while ( ( i < j ) && ( ( area = a [ i ] * a [ j ] ) != 0 ) ) { int x = a [ i ] * a [ j ] ; if ( ( x != area ) && ( x != 0 ) ) { System . out . println ( " NO " ) ; return ; } i ++ ; j -- ; } for ( ; i <= n ; i ++ ) { if ( mp . containsKey ( a [ i ] ) ) mp . put ( a [ i ] , 1 ) ; else mp . put ( a [ i ] , 1 ) ; } for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( ( entry . getValue ( ) % 2 != 0 ) && ( entry . getValue ( ) % 2 != 0 ) ) { System . out . println ( " NO " ) ; return ; } } System . out . println ( " YES " ) ; int test = Integer . parseInt ( input . nextLine ( ) ) ; for ( int t = 0 ; t <= test ; t ++ ) { solve ( ) ; } }
public static int MinDeletion ( int [ ] a , int n ) { Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; map . put ( a , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { map . put ( a [ i ] , 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { int x = entry . getKey ( ) ; int frequency = entry . getValue ( ) ; if ( ( x <= frequency ) && ( frequency > 0 ) ) { ans += ( frequency - x ) ; } else { ans += frequency ; } } return ans ; }
static int fromStart ( String in , int del11 ) { int inp1 = in . charAt ( 0 ) - del11 ; int inp2 = in . charAt ( del1 ) ; return inp1 + inp2 ; }
public static int nondecDigits ( int n ) { int x = 0 ; for ( x = n ; x > 0 ; x -- ) { int no = x ; int prevDig = 11 ; boolean flag = true ; while ( ( no = ( int ) ( Math . log ( x ) ) ) != 0 ) { if ( ( prevDig < no % 10 ) && ( prevDig > 0 ) ) { flag = false ; break ; } prevDig = no % 10 ; no /= 10 ; } if ( ( flag == true ) && ( x > 0 ) ) { break ; } } return x ; }
public static int anti = Integer . parseInt ( input ) { int b = Integer . parseInt ( input . nextLine ( ) ) ; int c = Integer . parseInt ( input . nextLine ( ) ) ; int d = Integer . parseInt ( input . nextLine ( ) ) ; return c ; }
public static int x = Integer . parseInt ( input ) , y = Integer . parseInt ( input ) ; boolean CielWon = false ; while ( ( y > 1 && x * 10 + y > 21 ) ) { int t = Math . min ( x , 2 ) ; x -= t ; y -= ( 2 - t ) * 10 + 2 ; if ( ( y < 2 ) || ( 10 * x + y < 22 ) ) { CielWon = true ; break ; } y -= 2 ; t = Math . min ( 2 , y / 10 ) ; y -= 10 * t ; x -= 2 - t ; } return y ; }
public static List < String > input ( ) { int n = Integer . parseInt ( input . readLine ( ) ) ; int m = Integer . parseInt ( input . readLine ( ) ) ; List < String > l = new ArrayList < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { l . add ( s ) ; } return l ; }
static public int indexOf ( String s , char ch ) { return indexOf ( s , ch , 0 ) ; }
static int countDistictSubarray ( int [ ] arr , int n ) { Map < Integer , Integer > vis = Maps . newHashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { vis . put ( arr [ i ] , 1 ) ; } int k = vis . size ( ) ; Map < Integer , Integer > vid = Maps . newHashMap ( ) ; int ans = 0 ; int right = 0 ; int window = 0 ; for ( int left = 0 ; left < n ; left ++ ) { while ( ( right < n ) && window < k ) { if ( vid . keySet ( ) . contains ( arr [ right ] ) ) { vid . put ( arr [ right ] , ++ window ) ; } else { vid . put ( arr [ right ] , 1 ) ; } if ( ( vid . get ( arr [ right ] ) == 1 ) && ( window < k ) ) { window ++ ; } right ++ ; } if ( ( window == k ) && ( arr [ left ] == 1 ) ) { ans += ( n - right + 1 ) ; } vid . put ( arr [ left ] , -- window ) ; if ( ( vid . get ( arr [ left ] ) == 0 ) && ( window < k ) ) { window -- ; } } return ans ; }
static int n ( int s ) { int ans = s ; for ( int i = 0 ; i < n ; i ++ ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; ans = Math . max ( ans , a + b ) ; } System . out . println ( ans ) ; return ans ; }
static boolean isPrime ( int n ) { if ( ( n <= 1 ) && ( n <= 3 ) ) return false ; if ( ( n % 2 == 0 ) || ( n % 3 == 0 ) ) return false ; int i = 5 ; while ( ( i * i <= n ) && ( n % i == 0 ) ) { if ( ( n % i == 0 ) || ( n % ( i + 2 ) == 0 ) ) return false ; i = i + 6 ; } return true ; }
static int countSetBits ( int n ) { int count = 0 ; while ( ( n &= ( n - 1 ) ) != 0 ) { count ++ ; } return count ; }
@ SuppressWarnings ( " unchecked " ) public static void reverseQueueFirstKElements ( int k , Queue queue ) { if ( ( queue . isEmpty ( ) == true ) || ( k > queue . qSize ( ) ) ) { return ; } if ( ( k <= 0 ) || ( k > queue . qSize ( ) ) ) { return ; } Stack < Integer > Stack = new Stack < Integer > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { Stack . push ( queue . peek ( ) ) ; queue . poll ( ) ; } while ( ( stack . size ( ) != 0 ) ) { queue . offer ( stack . peek ( ) ) ; stack . poll ( ) ; } for ( int i = 0 ; i < queue . qSize ( ) - k ; i ++ ) { queue . offer ( queue . peek ( ) ) ; queue . poll ( ) ; } /* ▁ Print ▁ the ▁ queue ▁ */ while ( ( ! queue . isEmpty ( ) ) ) { System . out . print ( queue . peek ( ) + " ▁ " ) ; queue . poll ( ) ; } if ( getClass ( ) . equals ( LinkedList . class ) ) { LinkedList < Integer > queue = new LinkedList < Integer > ( ) ; queue . offer ( 10 ) ; queue . offer ( 20 ) ; queue . offer ( 30 ) ; queue . offer ( 40 ) ; queue . offer ( 50 ) ; queue . offer ( 60 ) ; queue . offer ( 70 ) ; queue . offer ( 80 ) ; queue . offer ( 90 ) ; queue . offer ( 100 ) ; k = 5 ; reverseQueueFirstKElements ( k , queue ) ; print ( queue ) ; } }
public static int a = Integer . parseInt ( input ) { for ( int i = 0 ; i < a ; i ++ ) { int b = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] arr = new int [ b ] ; for ( int j = 0 ; j < b ; j ++ ) { arr [ j ] = Integer . parseInt ( input . nextLine ( ) ) ; } int tmp = b ; int win1 = 0 ; int win2 = 0 ; int cnt = 0 ; for ( int j = 0 ; j < b ; j ++ ) { if ( arr [ j ] % 2 == 0 ) { cnt ++ ; } } if ( cnt % 2 == 1 ) { System . out . println ( " errorgorn " ) ; } else { System . out . println ( " maomao90" ) ; } } return a ; }
static int xorCalc ( int k ) { if ( ( k == 1 ) && ( k == 2 ) ) { return 2 ; } if ( ( ( ( k + 1 ) & k ) == 0 ) && ( k == 1 ) ) { return k / 2 ; } return 1 ; }
public static boolean isPerfectSquare ( int num ) { int low = 1 , high = num ; int mid ; int midSquare ; if ( getClassName ( ) . equals ( " java . util . BitSet " ) ) { BitSet sBitSet = new BitSet ( ) ; num = 16 ; out = sBitSet . nextSetBit ( 0 ) ; System . out . println ( out ) ; } else { low = low ; high = high ; while ( low <= high ) { mid = ( low + high ) / 2 ; midSquare = mid * mid ; if ( midSquare == num ) return true ; else if ( midSquare < num ) low = mid + 1 ; else high = mid - 1 ; } } return false ; }
public static int [ ] [ ] a , int [ ] b , int [ ] c = new int [ 3 ] [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { a [ i ] = Integer . parseInt ( input . readLine ( ) ) ; b [ i ] = Integer . parseInt ( input . readLine ( ) ) ; c [ i ] = Integer . parseInt ( input . readLine ( ) ) ; if ( ( 2 * Math . max ( a , b , c ) - ( a + b + c ) ) == 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
static final String print ( ) { int i = 0 ; int [ ] [ ] array = new int [ n ] [ ] ; I = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) { array [ i ] = Integer . parseInt ( System . in . readLine ( ) ) ; } IS = new IS ( ) ; IN = new IN ( ) ; IF = new IF ( ) ; int n = IN . nextInt ( ) ; l = array [ i ] ; c = 0 ; r = new int [ n ] ; s = 0 ; for ( ; i < n ; i ++ ) { if ( ( s - l [ i ] ) / ( n - 1 ) == l [ i ] ) { c ++ ; r [ s ] = i + 1 ; } } System . out . println ( c ) ; System . out . println ( r ) ; }
public static void main ( String [ ] args ) { nq = new LinkedList < String > ( ) ; queue = new LinkedList < String > ( ) ; for ( int i = 0 ; i < nq [ 0 ] ; i ++ ) { queue . add ( input . split ( " ▁ " ) ) ; } int ti = 0 ; int cur = 0 ; while ( Integer . parseInt ( queue . get ( cur ) . substring ( 1 ) ) > 0 ) { String [ ] num = queue . get ( cur ) ; int syori = Integer . parseInt ( num [ 1 ] ) - nq [ 1 ] ; if ( syori > 0 ) { num [ 1 ] = syori ; queue . add ( num ) ; ti += nq [ 1 ] ; } else { ti += Integer . parseInt ( num [ 1 ] ) ; System . out . println ( num [ 0 ] + " ▁ " + ti ) ; } cur ++ ; if ( queue . size ( ) <= cur ) { break ; } } }
static int findElement ( int [ ] arr , int [ ] [ ] ranges , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( ( left <= index ) && ( right >= index ) ) { if ( ( index == left ) ) { index = right ; } else { index = index - 1 ; } } } return arr [ index ] ; }
static int MAXN = 1000001 ; int spf [ ] = new int [ MAXN ] ; int hash1 [ ] = new int [ MAXN ] ; for ( int i = 0 ; i < MAXN ; i += 2 ) { spf [ i ] = 2 ; } for ( int i = 3 ; i < MAXN ; i += 2 ) { spf [ i ] = 1 ; } for ( int i = 0 ; i < 3 ; i ++ ) { if ( i * i < MAXN ) break ; if ( ( spf [ i ] == i ) && ( i < MAXN ) ) { for ( int j = i * i ; j < MAXN ; j += i ) { if ( ( spf [ j ] == j ) && ( j < MAXN ) ) spf [ j ] = i ; } } } /* ▁ get ▁ factorization ▁ */ int temp ; int check ( temp = 1 ) ; while ( ( temp = 1 ) != 0 ) { temp = spf [ temp ] ; if ( ( temp % temp == 0 ) && ( hash1 [ temp ] > 1 ) ) return false ; while ( ( temp % temp == 0 ) && ( i < MAXN ) ) return false ; } /* ▁ check ▁ */ while ( ( temp = 1 ) != 0 ) { temp = spf [ temp ] ; if ( ( temp % temp == 0 ) && ( hash1 [ temp ] > 1 ) ) return false ; while ( ( temp % temp == 0 ) && ( i < MAXN ) ) return false ; } int arr [ ] = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = arr . length ; if ( ( arr [ n ] = 1 ) != 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return arr [ n ] ; }
static boolean isExists ( int [ ] a , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { freq . put ( a [ i ] , 0 ) ; } int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( a [ i ] , 1 ) ; Sum += a [ i ] ; } if ( Sum % 2 == 0 ) { if ( freq . get ( Sum / 2 ) ) { return true ; } } return false ; } int [ ] a = { 5 , 1 , 2 , 2 } ; int len = a . length ; if ( isExists ( a , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; }
public static int areaOfKite ( int d1 , int d2 ) { int area = ( d1 * d2 ) / 2 ; return area ; }
public static String [ ] seats = new String [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { seats [ i ] = new char [ 11 ] ; } int n = Integer . parseInt ( input ) ; String [ ] endl = { " | D | ) " , " | . | " , " | . | ) " } String P = " " ; if ( ( n == 0 ) && ( n == 1 ) ) { P = /* + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; while ( n % 2 == 0 ) { n /= 2 ; } if ( n == 1 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } }
static boolean productEqual ( int n ) { int digit ; int prodOdd = 1 ; int prodEven = 1 ; while ( n > 0 ) { digit = n % 10 ; prodOdd *= digit ; n = n / 10 ; if ( n == 0 ) { break ; } digit = n % 10 ; prodEven *= digit ; n = n / 10 ; } if ( prodOdd == prodEven ) { return true ; } return false ; n = 4324 ; if ( productEqual ( n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
private static void charArrayAppend ( StringBuilder sbuf , char [ ] a ) { sbuf . append ( ' [ ' ) ; int len = a . length ; for ( int i = 0 ; i < len ; i ++ ) { sbuf . append ( a [ i ] ) ; } sbuf . append ( ' ] ' ) ; while ( true ) { int n = Integer . parseInt ( in . nextLine ( ) ) ; if ( n == 0 ) { break ; } int [ ] keys = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { keys [ i ] = Integer . parseInt ( in . nextLine ( ) ) ; } String sentence = new String ( a ) ; for ( int i = 0 ; i < sentence . length ( ) ; i ++ ) { int j ; if ( Character . isUpperCase ( sentence . charAt ( i ) ) ) { j = ( sentence . charAt ( i ) - ' A ' ) + 26 ; } else { j = ( sentence . charAt ( i ) - ' a ' ) ; } sbuf . append ( charArray [ j - keys [ i % keys . length ] ] ) ; } System . out . println ( ) ; } }
static void checkEVENodd ( int arr [ ] , int n , int l , int r ) { if ( ( arr [ r ] == 1 ) && ( arr [ l ] == 3 ) ) { } }
input ; i = scanner . next ( ) ; int W = scanner . nextInt ( ) ; int H = scanner . nextInt ( ) ; int x = scanner . nextInt ( ) ; int y = scanner . nextInt ( ) ; int r = scanner . nextInt ( ) ; if ( x - r < 0 || y - r < 0 || x + r > W || y + r > H ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; } return x ; }
static boolean isPrime ( int n ) { if ( n <= 1 ) { return false ; } for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
static int compositeProduct ( int [ ] arr , int n ) { final int maxVal = max ( arr ) ; final boolean [ ] prime = new boolean [ maxVal + 1 ] ; prime [ 0 ] = true ; prime [ 1 ] = true ; for ( int p = 2 ; p < Math . ceil ( Math . sqrt ( maxVal ) ) ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= maxVal ; i += p ) { prime [ i ] = false ; } } } int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == false ) { product *= arr [ i ] ; } } return product ; }
public static void main ( String input ) { int x , y ; do { x = Integer . parseInt ( input . substring ( 0 , 2 ) ) ; y = Integer . parseInt ( input . substring ( 2 , 3 ) ) ; } while ( x == 0 && y == 0 ) ; List < Integer > liste = new ArrayList < Integer > ( ) ; liste . add ( x ) ; liste . add ( y ) ; Collections . sort ( liste ) ; System . out . println ( liste . get ( 0 ) + " ▁ " + liste . get ( 1 ) ) ; }
public static void for ( int i = 0 ; i < Integer . parseInt ( input ) ; ) { String n = input . substring ( 0 , input . length ( ) - 1 ) ; switch ( n . length ( ) > 2 ? n . substring ( 0 , 2 ) : n ) { case " op " : System . out . println ( " FILIPINO " ) ; break ; case " adinm " : System . out . println ( " KOREAN " ) ; break ; default : System . out . println ( " JAPANESE " ) ; break ; } }
static int findSum ( int arr [ ] , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }
@ VisibleForTesting static int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) { for ( int j = 0 ; j <= n - i ; j += b ) { double z = ( n - ( i + j ) ) / c ; if ( ( floor ( z ) == ceil ( z ) ) ) { int x = i / a ; int y = j / b ; maxVal = Math . max ( maxVal , x + y + ( int ) z ) ; } } } return maxVal ; }
[ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } Collections . sort ( a ) ; for ( int i = 1 ; i < 4 ; i ++ ) { System . out . println ( " " + a [ a . length - i ] ) ; } return a ; }
static final long fact ( int n ) { long ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { ans = ans * i ; } return ( ans ) ; /* ▁ number ▁ of ▁ possible ▁ pallindrome ▁ */ Map < String , Integer > mp = Maps . newHashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . keySet ( ) . contains ( string . charAt ( i ) ) ) { mp . put ( string . charAt ( i ) , ++ i ) ; } else { mp . put ( string . charAt ( i ) , 1 ) ; } } int k = 0 ; long num = 0 ; long den = 1 ; int fi = 0 ; for ( int it : mp . keySet ( ) ) { if ( ( mp . get ( it ) % 2 ) == 0 ) { fi = mp . get ( it ) / 2 ; } else { fi = ( mp . get ( it ) - 1 ) / 2 ; k ++ ; } num = num + fi ; den = den * fi ; } return ( ans ) ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; List < Integer > l = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { l . add ( Integer . parseInt ( input . substring ( i , i + 1 ) ) ) ; } if ( ( n == 1 ) && ( l . isEmpty ( ) ) ) { System . out . println ( "1" ) ; } else { while ( ( n > 1 ) && ( l . size ( ) > 1 ) ) { if ( ( l . isEmpty ( ) ) && ( l . size ( ) > 1 ) ) { System . out . println ( "1" ) ; break ; } else if ( ( l . isEmpty ( ) ) && ( l . size ( ) > 1 ) ) { System . out . println ( n ) ; break ; } else if ( ( l . size ( ) > 1 ) && ( l . size ( ) > 1 ) ) { l . remove ( n / 2 ) ; n /= 2 ; } else { l . remove ( 0 ) ; n /= 2 ; } } } }
static int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
public static int t = Integer . parseInt ( input ) { while ( t > 0 ) { String s = input . nextLine ( ) ; boolean flag = s . charAt ( s . length ( ) - 1 ) != ' B ' ? false : true ; if ( flag ) { int summ = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' A ' ) { summ ++ ; } else { summ -- ; } if ( summ < 0 ) { flag = false ; break ; } } } if ( flag ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } t -- ; } return t ; }
public static String firstSubstring ( String s ) { int n = s . length ( ) ; int c = 0 ; Map < String , Integer > mpp = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == ' ▁ ' ) || ( s . charAt ( i ) == ' # ' ) ) { String s1 = s . substring ( c , i ) ; mpp . put ( s1 , 1 ) ; c = i + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == ' ▁ ' ) ) continue ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( s . charAt ( j ) == ' ▁ ' ) ) break ; String s1 = s . substring ( i , j + 1 ) ; String s2 = s1 ; s1 = s1 . substring ( 0 , s1 . length ( ) - 1 ) ; if ( mpp . containsKey ( s1 ) ) { if ( mpp . get ( s1 ) ) return s2 ; } } } return " - 1" ; }
static int countConsecutive ( int n ) { String s = Integer . toString ( n ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( ( s . charAt ( i ) == s . charAt ( i + 1 ) ) ) { count ++ ; } } return count ; }
static void findAngle ( int n ) { int interiorAngle = ( int ) ( ( n - 2 ) * 180 / n ) ; int exteriorAngle = ( int ) 360 / n ; System . out . println ( ) ; }
static void nDigitPerfectSquares ( int n ) { final int n = 4 ; nDigitPerfectSquares ( n ) ; }
public static void print ( String s ) { int t = Integer . parseInt ( input . readLine ( ) ) ; for ( int l = 0 ; l < t ; l ++ ) { input . nextLine ( ) ; String strm = input . readLine ( ) ; int ls = strm . length ( ) ; strm = strm . replaceAll ( " \\ ) " , " " ) ; if ( ls - strm . length ( ) > s . length ( ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public static String n ( int input ) { String x = input ; String s = " " ; int count = 0 ; for ( int i = 0 ; i < x . length ( ) - 1 ; i += 2 ) { String k = x . substring ( i , i + 2 ) ; if ( k . indexOf ( " a " ) == 2 || k . indexOf ( " b " ) == 2 ) { k = " ab " ; count = count + 1 ; } s = s + k ; } System . out . println ( count ) ; System . out . println ( s ) ; return s ; }
@ VisibleForTesting static int power ( int a , int n ) { int discardCount = 0 ; int sum ; int k ; if ( ( n == 0 ) || ( a == 1 ) ) { return 1 ; } int p = power ( a , n / 2 ) ; p = p * p ; if ( ( n & 1 ) != 0 ) { p = p * a ; } return p ; }
public static void newNode ( ) { Node root ; Node root2 ; /* ▁ inorder ▁ */ if ( ( root = root . left ) == null ) { return ; } /* ▁ inorder ▁ */ inorder ( root . left ) ; System . out . print ( root . data + " ▁ " ) ; /* ▁ inorder ▁ */ /* ▁ isIdentical ▁ */ Node root1 = root . left ; Node root2 = root . right ; /* ▁ inorder ▁ */ if ( ( root1 == null ) && ( root2 == null ) ) { return ; } /* ▁ inorder ▁ */ inorder ( root2 . left ) ; System . out . print ( root2 . data + " ▁ " ) ; /* ▁ inorder ▁ */ if ( ( root1 != null ) && ( root2 != null ) ) { /* ▁ inorder ▁ */ } /* ▁ inorder ▁ */ if ( ( root1 . data == root2 . data ) && ( isIdentical ( root1 . left , root2 . left ) ) && ( isIdentical ( root1 . right , root2 . right ) ) ) { /* ▁ inorder ▁ */ } /* ▁ inorder ▁ */ if ( ( root1 != null ) && ( root2 != null ) ) { /* ▁ inorder ▁ */ } /* ▁ inorder ▁ */ inorder ( root2 != null ) ; /* ▁ inorder ▁ */ if ( ( root1 != null ) && ( root2 != null ) ) { /* ▁ inorder ▁ */ } /* ▁ inorder ▁ */ inorder ( root2 != null ) { /* ▁ inorder ▁ */ } /* ▁ inorder ▁ */ inorder ( root2 != null ) ; /* ▁ inorder ▁ */ if ( ( root1 != null ) && ( root2 != null ) ) { /* ▁ inorder ▁ */ } /* ▁ inorder ▁ */ inorder ( root2 != null ) ; /* ▁ inorder ▁ */ if ( ( root1 != null ) && ( root2 != null ) ) { /* ▁ inorder ▁ */ } /* ▁ inorder ▁ */ inorder ( root2 != null ) ; /* ▁ inorder ▁ */ if ( ( root1 != null ) && ( root2 != null ) && ( root1 . data == root2 . data ) ) { /* ▁ inorder ▁ */ } /* ▁ inorder ▁ */ inorder ( root2 != null ) ; /* ▁ inorder ▁ */ }
static final Scanner input = new Scanner ( System . in ) { @ Override public void close ( ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int [ ] si = new int [ n + 1 ] , sj = new int [ n + 1 ] ; char [ ] s = input . toCharArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sj [ i + 1 ] = sj [ i ] + ( s [ i ] == ' J ' ? 1 : 0 ) ; si [ i + 1 ] = si [ i ] + ( s [ i ] == ' I ' ? 1 : 0 ) ; } int ans = 0 ; int a = 0 ; int b = 0 ; int c = 0 ; for ( int i = 1 ; i < n ; i ++ ) a = Math . max ( a , sj [ i ] * ( si [ n ] - si [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' O ' ) { b += si [ n ] - si [ i + 1 ] ; c += sj [ i ] ; ans += ( si [ n ] - si [ i + 1 ] ) * sj [ i ] ; } } System . out . println ( ans + Math . max ( a , b , c ) ) ; } }
public static Dice getDice ( ) { { Eyes eyes = new Eyes ( " dummy " ) . add ( eyes ) ; @ SuppressWarnings ( " unchecked " ) List < String > eye = eyes . get ( 1 ) ; switch ( eyes . get ( 0 ) ) { case " N " : eyes = new Eyes ( " dummy " , a . get ( 2 ) , a . get ( 6 ) , a . get ( 3 ) , a . get ( 4 ) , a . get ( 1 ) , a . get ( 5 ) ) ; break ; case " S " : eyes = new Eyes ( " dummy " , a . get ( 5 ) , a . get ( 1 ) , a . get ( 3 ) , a . get ( 4 ) , a . get ( 6 ) , a . get ( 2 ) ) ; break ; case " W " : eyes = new Eyes ( " dummy " , a . get ( 3 ) , a . get ( 2 ) , a . get ( 1 ) , a . get ( 6 ) , a . get ( 5 ) , a . get ( 3 ) ) ; break ; default : throw new IllegalArgumentException ( " NEWS箱推し " ) ; } } String eyes = input . nextLine ( ) ; Dice dice = new Dice ( eyes ) ; String direction_text = input . nextLine ( ) ; for ( String d : direction_text ) { dice . roll ( d ) ; } System . out . println ( dice . eye ) ; return dice ; }
public static < T > Node < T > node ( final T data ) { Node < T > newNode ; Node < T > newNode ; newNode = new Node < T > ( 0 ) ; newNode . data = data ; newNode . next = null ; return newNode ; }
static int nonDecNums ( int n ) { final int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ 0 ] [ i ] = 1 ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { a [ i ] [ 9 ] = 1 ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 8 ; j >= 0 ; j -- ) { a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; } } return ( int ) a [ n ] [ 0 ] ; }
public static void for ( int i = 0 ; i < Integer . parseInt ( input ) ; ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > l = Lists . newArrayList ( ) ; for ( int j = 0 ; j < n ; j ++ ) { l . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } Map < Integer , Integer > map = new HashMap < > ( ) ; int f = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int x = ( j + l . get ( j ) ) % n ; if ( map . containsKey ( x ) ) { f = 1 ; break ; } else { map . put ( x , 1 ) ; } } if ( f == 1 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } }
public static Solution < Integer > createSolution ( ) { int [ ] minMoves = new int [ ] { 1 , 2 , 3 } ; if ( getClass ( ) . equals ( Solution . class ) ) { Solution < Integer > sObj = new Solution < Integer > ( ) ; int [ ] nums = { 1 , 2 , 3 } ; int out = sObj . minMoves ( nums ) ; System . out . println ( out ) ; } return new Solution < Integer > ( ) { @ Override public int minMoves ( Integer [ ] nums ) { if ( nums == null || nums . length == 0 ) { return 0 ; } int minNum = Math . min ( nums , minNum ) ; return Integer . MAX_VALUE ; } } ; }
public static void print ( String input ) { int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; if ( a <= 0 && 0 <= b ) { System . out . println ( " Zero " ) ; } else if ( a < 0 && Math . min ( b - a , - a ) % 2 == 0 ) { System . out . println ( " Negative " ) ; } else { System . out . println ( " Positive " ) ; } }
static int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; }
public static int maximumChars ( String str1 ) { int n = str1 . length ( ) ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { firstInd [ ( str1 . charAt ( i ) ) ] = i ; } for ( int i = 0 ; i < n ; i ++ ) { firstInd [ ( str1 . charAt ( i ) ) ] = i ; } return res ; }
public static int [ ] [ ] convert ( String input ) { int n = Integer . parseInt ( input ) ; int d = Integer . parseInt ( input ) ; int [ ] [ ] z = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) z [ i ] = new int [ n ] ; Arrays . sort ( z ) ; int L = 0 ; int R = 0 ; int ans = 0 ; int ans1 = 0 ; while ( L < n && R < n ) { ans = Math . max ( z [ R ] [ 1 ] , ans ) ; if ( Math . abs ( z [ L ] [ 0 ] - z [ R ] [ 0 ] ) < d ) { ans1 += z [ R ] [ 1 ] ; R ++ ; } else { ans = Math . max ( ans1 , ans ) ; ans1 -= z [ L ] [ 1 ] ; L ++ ; } } return z ; }
@ VisibleForTesting static double findArea ( double a ) { double area = 5 * Math . sqrt ( 3 ) * a * a ; return area ; /* ▁ find ▁ volume ▁ */ double volume = ( ( 5 / 12 ) * ( 3 + Math . sqrt ( 5 ) ) * a * a ) ; }
public static String compute ( ) { double [ ] ninePyramidalPdf = { 1 } ; double [ ] PYRAMIDAL_DIE_PDF = { 0 , 1 , 1 , 1 , 1 } ; for ( int i = 0 ; i < 9 ; i ++ ) { ninePyramidalPdf = ConvolveUtils . compute ( ninePyramidalPdf , PYRAMIDAL_DIE_PDF ) ; } double [ ] six_cubicPdf = { 1 } ; double [ ] CUBIC_DIE_PDF = { 0 , 1 , 1 , 1 , 1 , 1 , 1 } ; for ( int i = 0 ; i < 6 ; i ++ ) { six_cubicPdf = ConvolveUtils . compute ( six_cubicPdf , CUBIC_DIE_PDF ) ; } int ans = 0 ; for ( int i = 0 ; i < ninePyramidalPdf . length ; i ++ ) { ans += ninePyramidalPdf [ i ] * Arrays . copyOfRange ( six_cubicPdf , 0 , i ) ; } ans = ( double ) ans / ( Arrays . copyOfRange ( ninePyramidalPdf , 0 , ninePyramidalPdf . length ) * Arrays . copyOfRange ( six_cubicPdf , 0 , six_cubicPdf . length ) ) ; return f . concat ( " { ans : .7f } " ) ; }
public static int N = 6 ; int Even = N // 2 ; int Odd = N - Even ; System . out . println ( Even * Odd ) ; return Odd ; }
public static int solve ( int M , int N , int s ) { if ( ( N % s ) == 0 ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( ( M % s ) == 0 ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return M * N ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) { return b ; } return gcd ( b % a , a ) ; } public static int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } public static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) ) { ans ++ ; } } } return ans ; }
public static List < Integer > scoresOfTheParticipants = Lists . newArrayList ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) { for ( int j = i + 1 ; j < 6 ; j ++ ) { for ( int k = j + 1 ; k < 6 ; k ++ ) { if ( scoresOfTheParticipants . get ( i ) + scoresOfTheParticipants . get ( j ) + scoresOfTheParticipants . get ( k ) == totalScores - ( scoresOfTheParticipants . get ( i ) + scoresOfTheParticipants . get ( j ) + scoresOfTheParticipants . get ( k ) ) ) { chosenTeams ++ ; } } } } if ( chosenTeams == 0 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } return Collections . singletonList ( new Integer ( chosenTeams ) ) ; }
private static int popcnt32 ( int number ) { int counter = 0 ; while ( ( number > 0 ) && ( number < 32 ) ) { if ( ( number % 2 ) == 1 ) { counter = counter + 1 ; } number = ( int ) ( number / 2 ) ; } return counter ; }
public static void print ( int t = Integer . parseInt ( input ) ) { for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int k = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] list = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) list [ j ] = Integer . parseInt ( input . nextLine ( ) ) ; int cnt = 0 ; for ( int j = 0 ; j < k ; j ++ ) if ( list [ j ] > k ) cnt ++ ; System . out . println ( cnt ) ; } }
public static int a1 = Integer . parseInt ( input ) { int a2 = Integer . parseInt ( input . nextLine ( ) ) ; int t = 0 ; if ( a1 == 1 && a2 == 1 ) { System . out . println ( 0 ) ; } else { while ( a1 > 0 && a2 > 0 ) { if ( a1 > a2 ) { a2 ++ ; a1 -= 2 ; } else { a2 -= 2 ; a1 ++ ; } t ++ ; } } System . out . println ( t ) ; return t ; }
public static Solution class Solution { public int [ ] xorQueries ( int [ ] arr , int [ ] [ ] queries ) { int [ ] pref = new int [ arr . length ] ; Arrays . fill ( pref , 0 ) ; for ( int e : arr ) { pref [ e ] = e ^ pref [ arr . length - 1 ] ; } int [ ] ans = new int [ queries . length ] ; for ( int l = 0 ; l < queries . length ; l ++ ) { int r = queries [ l ] [ r ] ; ans [ l ] = pref [ r + 1 ] ^ pref [ l ] ; } return ans ; } if ( __name__ . equals ( " Solution " ) ) { Solution sObj = new Solution ( ) ; int [ ] arr = { 1 , 3 , 4 , 8 } ; int [ ] [ ] queries = { { 0 , 1 } , { 1 , 2 } , { 0 , 3 } , { 3 , 3 } } ; int [ ] out = sObj . xorQueries ( arr , queries ) ; System . out . println ( out ) ; } return null ; }
static char encodedChar ( String str , int k ) { String expand = " " ; int freq = 0 ; int i = 0 ; while ( ( i < str . length ( ) ) && ( str . charAt ( i ) == ' a ' ) && ( str . charAt ( i ) == ' z ' ) ) { temp += str . charAt ( i ) ; i ++ ; } while ( ( i < str . length ( ) ) && ( str . charAt ( i ) == '1' ) && ( str . charAt ( i ) == '9' ) ) { freq = freq * 10 + ( str . charAt ( i ) - '0' ) ; i ++ ; } for ( int j = 1 ; j <= freq ; j += 1 ) { expand += temp ; } if ( ( freq == 0 ) && ( str . charAt ( k ) == ' ▁ ' ) ) { expand += temp ; } return expand . charAt ( k - 1 ) ; }
static void printPossible ( int a , int b , int c ) { if ( ( ( a + b + c ) % 2 != 0 ) || a + b < c ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } if ( getClass ( ) . equals ( " java . lang . Integer " ) ) { a = 2 ; b = 4 ; c = 2 ; printPossible ( a , b , c ) ; } }
public static int summation ( int n ) { int absSum = n * ( n + 1 ) / 2 ; int sign = ( ( n + 1 ) % 2 == 0 ) ? 1 : - 1 ; int resultSum = sign * absSum ; return resultSum ; }
static void sortSquare ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] * arr [ i ] ; } Arrays . sort ( arr ) ; arr = new int [ ] { - 6 , - 3 , - 1 , 2 , 4 , 5 } ; n = arr . length ; System . out . println ( " Before ▁ sort " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( " " ) ; sortSquare ( arr , n ) ; System . out . println ( " After ▁ sort " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int t = Integer . parseInt ( input ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( input ) ; } boolean f = false ; int c = 1 ; int i = 0 ; while ( true ) { c = ( i + 1 ) + a [ i ] ; if ( ( c - 1 ) < i ) break ; if ( c == t ) { f = true ; break ; } if ( c > t ) break ; i = c - 1 ; } if ( f ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
public static int n = Integer . parseInt ( input ) { * A = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] l = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( l [ i ] == 0 ) { Set < Integer > s = new HashSet < Integer > ( ) ; int p = i ; boolean can = true ; while ( ! s . contains ( p ) ) { if ( l [ p ] == 1 ) { can = false ; break ; } s . add ( p ) ; } } } return l [ i ] ; }
static boolean isTriangular ( int num ) { final double c = ( - 2 * num ) ; double b = 1 , a = 1 ; double d = ( b * b ) - ( 4 * a * c ) ; if ( ( d < 0 ) || ( d > 0 ) ) { return false ; } double root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; double root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( ( root1 > 0 ) && ( Math . floor ( root1 ) == root1 ) ) { return true ; } if ( ( root2 > 0 ) && ( Math . floor ( root2 ) == root2 ) ) { return true ; } return false ; int n = 55 ; if ( ( isTriangular ( n ) ) ) { System . out . println ( " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ) ; } else { System . out . println ( " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ) ; } return false ; }
static void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) { System . out . print ( - 1 ) ; } else { System . out . print ( d ) ; k -- ; while ( k -- > 0 ) { System . out . print ( 0 ) ; k -- ; } } if ( getClass ( ) . equals ( Integer . class ) ) { k = 4 ; d = 4 ; printNumberWithDR ( k , d ) ; } }
static int N = 3 ; { int i = N - 1 ; int j ; while ( ( i >= 0 ) && ( j >= 0 ) ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; j = j - 1 ; } System . out . println ( ) ; }
public static void print ( int n ) { n = Integer . parseInt ( input . nextLine ( ) ) ; if ( n % 500 == 0 ) { print ( n ) ; } else { print ( ( n / 500 ) * 500 ) ; } }
static long getProduct ( long n ) { long product = 1 ; while ( ( n != 0 ) && ( n != 1 ) ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
public static void solve ( ) { int b , r , g , c , s , t ; int cnt ; int coins ; b = Integer . parseInt ( input . readLine ( ) ) ; r = Integer . parseInt ( input . readLine ( ) ) ; g = Integer . parseInt ( input . readLine ( ) ) ; c = Integer . parseInt ( input . readLine ( ) ) ; s = Integer . parseInt ( input . readLine ( ) ) ; t = Integer . parseInt ( input . readLine ( ) ) ; if ( t == 0 ) break ; cnt = b * 5 + r * 3 + s ; coins = ( b * 5 + r * 3 ) * ( 15 - 2 ) ; coins += b * 15 ; coins += r * 15 ; coins += 7 * g ; coins += 2 * c ; coins += 100 - ( t - cnt ) * 3 ; System . out . println ( coins ) ; }
public static int maxn = 1010 ; long mod = 1000000007 ; int [ ] [ ] comb = new int [ maxn ] [ maxn ] ; for ( int i = 0 ; i < maxn ; i ++ ) comb [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < maxn ; i ++ ) { comb [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) comb [ i ] [ j ] = comb [ i - 1 ] [ j ] + comb [ i - 1 ] [ j - 1 ] % mod ; } int k = Integer . parseInt ( input ( ) ) ; int [ ] color = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) color [ i ] = Integer . parseInt ( input ( ) ) ; long res = 1 ; long total = 0 ; for ( int i = 0 ; i < k ; i ++ ) { res = ( res * comb [ total + color [ i ] - 1 ] [ color [ i ] - 1 ] ) % mod ; total += color [ i ] % mod ; } System . out . println ( res % mod ) ; return comb [ k ] ; }
PI = 3.14159265 ; return ( ( 2 * PI * r ) + 6 * r ) ; }
static int reverseDigits ( int num ) { int revNum = 0 ; while ( ( num > 0 ) && ( ( revNum = reverseDigits ( num ) ) != 0 ) ) { revNum = revNum * 10 + num % 10 ; num = num / 10 ; } return revNum ; /* ▁ Is ▁ a ▁ palindrome ▁ number ? ▁ */ int revN = reverseDigits ( num ) ; if ( ( revN == n ) && ( revN == n ) ) { return 1 ; } else { return 0 ; } /* ▁ Is ▁ a ▁ palindrome ▁ number ? ▁ */ int n = 4562 ; if ( isPalindrome ( n ) == 1 ) { System . out . println ( " Is " + n + " a ▁ Palindrome ▁ number ? ▁ - > " + true ) ; } else { System . out . println ( " Is " + n + " a ▁ Palindrome ▁ number ? ▁ - > " + false ) ; } n = 2002 ; if ( isPalindrome ( n ) == 1 ) { System . out . println ( " Is " + n + " a ▁ Palindrome ▁ number ? ▁ - > " + true ) ; } else { System . out . println ( " Is " + n + " a ▁ Palindrome ▁ number ? ▁ - > " + false ) ; } return n ; }
public static String Solution ( ) { class Solution { public String addStrings ( String num1 , String num2 ) { StringBuilder res = new StringBuilder ( ) ; int pos1 = num1 . length ( ) - 1 ; int pos2 = num2 . length ( ) - 1 ; int carry = 0 ; while ( pos1 >= 0 || pos2 >= 0 || carry == 1 ) { int digit1 = 0 ; int digit2 = 0 ; if ( pos1 >= 0 ) digit1 = ( num1 . charAt ( pos1 ) - '0' ) ; if ( pos2 >= 0 ) digit2 = ( num2 . charAt ( pos2 ) - '0' ) ; res . append ( Integer . toString ( ( digit1 + digit2 + carry ) % 10 ) ) ; carry = ( digit1 + digit2 + carry ) / 10 ; pos1 -- ; pos2 -- ; } return res . toString ( ) ; } } if ( getClassName ( ) . equals ( Solution . class ) ) { Solution sObj = new Solution ( ) ; String num1 = "11" ; String num2 = "123" ; String out = sObj . addStrings ( num1 , num2 ) ; System . out . println ( out ) ; } return null ; }
static boolean isPerfect ( int n ) { int sum = 1 ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) sum = sum + i + n / i ; i ++ ; } return ( sum == n && n != 1 ) ? true : false ; }
static boolean isPower ( int n ) { final int i ; if ( ( n <= 1 ) && ( n <= 1 ) ) { return true ; } for ( i = 2 ; ( i < ( int ) Math . sqrt ( n ) ) ; i ++ ) { int p = i ; while ( ( p <= n ) && ( p == n ) ) { p = p * i ; if ( ( p == n ) && ( p == n ) ) { return true ; } } } return false ; }
static boolean isPower ( int n ) { final int y ; if ( ( n == 1 ) || ( n == 0 ) ) { return true ; } for ( x = 2 ; ( x < ( int ) Math . sqrt ( n ) ) ; x ++ ) { y = 2 ; int p = ( int ) Math . pow ( x , y ) ; while ( ( p <= n ) && ( p > 0 ) ) { if ( ( p == n ) || ( p == 0 ) ) { return true ; } y = y + 1 ; p = Math . pow ( x , y ) ; } } return false ; }
@ java . lang . Deprecated public static void findTwoNumbers ( int sum , int gcd ) { if ( ( __gcd = gcd ) == gcd && sum != gcd ) { System . out . println ( " a ▁ = ▁ " + Math . min ( gcd , sum - gcd ) + " , ▁ b ▁ = ▁ " + ( sum - Math . min ( gcd , sum - gcd ) ) ) ; } else { System . out . println ( - 1 ) ; } if ( Class . isEnum ( ) ) { int sum = 8 ; int gcd = 2 ; findTwoNumbers ( sum , gcd ) ; } }
public static void for ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int rb = Integer . parseInt ( input . nextLine ( ) ) ; int cb = Integer . parseInt ( input . nextLine ( ) ) ; int rd = Integer . parseInt ( input . nextLine ( ) ) ; int cd = Integer . parseInt ( input . nextLine ( ) ) ; int t = 0 ; int df = 1 , dp = 1 ; while ( true ) { if ( rb == n ) { df = - 1 * df ; } if ( cb == m ) { dp = - 1 * dp ; } if ( rb == rd || cb == cd ) { break ; } rb += df ; cb += dp ; t ++ ; } System . out . println ( t ) ; }
public static int N = Integer . parseInt ( input ) { int X , A , B , C , D ; if ( ( A <= N ) || ( C <= N ) ) { if ( N % A == 0 ) X = ( int ) ( N / A ) * B ; else X = ( int ) ( N / A + 1 ) * B ; if ( N % C == 0 ) Y = ( int ) ( N / C ) * D ; else Y = ( int ) ( N / C + 1 ) * D ; } else { X = B ; Y = D ; } if ( X <= Y ) System . out . println ( ( int ) X ) ; else System . out . println ( ( int ) Y ) ; return X ; }
static int totalPairs ( int [ ] arr , int n ) { Map < Integer , Integer > m = Maps . newHashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = Integer . toBinaryString ( arr [ i ] ) . indexOf ( '1' ) ; m . put ( x , m . getOrDefault ( x , 0 ) + 1 ) ; } int result = 0 ; for ( int it : m . keySet ( ) ) { result += ( m . get ( it ) * ( m . get ( it ) - 1 ) ) ; } return result ; }
public static int centerHigDecagonalNum ( int n ) { return 8 * n * n - 8 * n + 1 ; }
public static void input ( ) { int q = Integer . parseInt ( input . readLine ( ) ) ; int h = Integer . parseInt ( input . readLine ( ) ) ; int s = Integer . parseInt ( input . readLine ( ) ) ; int d = Integer . parseInt ( input . readLine ( ) ) ; int n = Integer . parseInt ( input . readLine ( ) ) ; int [ ] pricesfor2 = { q * 8 , h * 4 , s * 2 , d } ; Arrays . sort ( pricesfor2 ) ; boolean nep = n % 2 == 1 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n ; n /= 2 ; n /= 2 ; n ; n /= 2 ; n /= 2 ; n ; n /= 2 ; n /= 2 ; n ; n /= 2 ; n /= 2 ; n ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n /= 2 ; n
static int countNumbers ( int L , int R , int K ) { if ( ( K == 9 ) && ( K == 9 ) ) { K = 0 ; } int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i >= R - rem ; i -- ) { int rem1 = i % 9 ; if ( ( rem1 == K ) && ( ans == 0 ) ) { ans ++ ; } } return ans ; }
@ Sys public static int from ( ) { String input = System . getProperty ( " input " ) ; Integer in = new Integer ( input ) ; /* ▁ Enter ▁ the ▁ minimum ▁ of ▁ the ▁ numbers ▁ in ▁ the ▁ range ▁ [ 0 , ▁ 1 ] ▁ */ int ans ; /* ▁ Enter ▁ the ▁ maximum ▁ of ▁ the ▁ numbers ▁ in ▁ the ▁ range ▁ [ 0 , ▁ 1 ] ▁ */ if ( ( e > f ) && ( c < f ) ) { int m = Math . min ( a , d ) ; ans = e * m ; d -= m ; ans += f * Math . min ( b , c , d ) ; } else { int m = Math . min ( b , c , d ) ; ans = f * m ; d -= m ; ans += e * Math . min ( a , d ) ; } return ans ; }
public static int Solution ( int [ ] A ) { int ans = 2 ; int n = A . length ; if ( n <= 2 ) return n ; int [ ] llap = new int [ n ] ; Arrays . fill ( llap , 2 ) ; Arrays . sort ( A ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 ; int k = j + 1 ; while ( ( i >= 0 ) && ( k < n ) ) { if ( A [ i ] + A [ k ] == 2 * A [ j ] ) { llap [ j ] = Math . max ( llap [ k ] + 1 , llap [ j ] ) ; ans = Math . max ( ans , llap [ j ] ) ; i -- ; k ++ ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) { k ++ ; } else { i -- ; } } } Solution obj = new Solution ( ) ; int [ ] a = { 9 , 4 , 7 , 2 , 10 } ; System . out . println ( obj . Solve ( a ) ) ; return ans ; }
static int minimumChanges ( int [ ] arr , int n , int d ) { int maxFreq = - 2147483648 ; HashMap < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a0 = arr [ i ] - i * d ; if ( freq . containsKey ( a0 ) ) { freq . put ( a0 , ++ i ) ; } else { freq . put ( a0 , 1 ) ; } if ( freq . get ( a0 ) > maxFreq ) { maxFreq = freq . get ( a0 ) ; } } return ( n - maxFreq ) ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] [ ] a = new int [ n ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Integer . parseInt ( input ) ; }
static int countPoints ( int n , int m , int [ ] a , int [ ] b , int x , int y ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int j = 0 , count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) { break ; } if ( ( b [ j ] >= a [ i ] - x ) && ( b [ j ] <= a [ i ] + y ) ) { count ++ ; j ++ ; break ; } else { j ++ ; } } } if ( getClass ( ) . getName ( ) . equals ( " com . google . android . gms . maps . Point " ) ) { x = 1 ; y = 4 ; a = new int [ ] { 1 , 5 } ; n = a . length ; b = new int [ ] { 1 , 1 , 2 } ; m = b . length ; System . out . println ( countPoints ( n , m , a , b , x , y ) ) ; } return count ; }
static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x > > 1 ) ; }
public static boolean check ( int x ) { int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sum += v [ i ] - x ; } if ( sum >= s ) { return true ; } else { return false ; } int t = 1 ; while ( t > 0 ) { t -- ; int n = ( Integer . parseInt ( input . nextLine ( ) ) ) ; int s = ( Integer . parseInt ( input . nextLine ( ) ) ) ; int [ ] v = new int [ n ] ; for ( int i = 0 ; i <= n ; i ++ ) { v [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } sum = 0 ; int l = 0 ; int r = 0x3f3f3f3f ; for ( int i = 0 ; i <= n ; i ++ ) { sum += v [ i ] ; r = Math . min ( v [ i ] , r ) ; } if ( sum < s ) { System . out . println ( - 1 ) ; } else { while ( l < r ) { int mid = ( l + r + 1 ) > > 1 ; if ( check ( mid ) == true ) { l = mid ; } else { r = mid - 1 ; } } System . out . println ( l ) ; } } return false ; }
static int longestSubstring ( String s ) { int cnt = 1 ; int maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) != s . charAt ( i - 1 ) ) ) { cnt ++ ; } else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
public static int [ ] readIntArray ( ) { int k = readInt ( ) ; int [ ] ans = new int [ 50 ] ; for ( int i = 0 ; i < 50 ; i ++ ) ans [ ans . length - 1 - i ] += k / 50 ; for ( int i = 0 ; i < k % 50 ; i ++ ) ans [ ans . length - 1 - i ] ++ ; System . out . println ( 50 ) ; return ans ; }
static int zeroUpto ( int digits ) { int first = ( int ) ( ( Math . pow ( 10 , digits ) - 1 ) / 9 ) ; int second = ( int ) ( ( Math . pow ( 9 , digits ) - 1 ) / 8 ) ; return 9 * ( first - second ) ; }
static double cone ( double a ) { if ( ( a < 0 ) || ( a > 1 ) ) { return - 1 ; } double r = ( a * Math . sqrt ( 2 ) ) / 3 ; double h = ( 2 * a ) / 3 ; return V ; }
static boolean Prime ( int n ) { final int [ ] string ; if ( n == 1 ) return false ; for ( int i = 2 ; i < mt . ceil ( mt . sqrt ( n + 1 ) ) ; i ++ ) { if ( n % i == 0 ) return false ; } /* ▁ check ▁ sum ▁ prime ▁ */ int summ = 0 ; for ( int i = 1 ; i < string . length ; i ++ ) { summ += Math . abs ( Integer . parseInt ( string [ i - 1 ] ) - Integer . parseInt ( string [ i ] ) ) ; } if ( Prime ( summ ) ) return true ; else return false ; int num = 142 ; String string = Integer . toString ( num ) ; int [ ] s = new int [ string . length ] ; for ( int i = 0 ; i < s . length ; i ++ ) { s [ i ] = string . charAt ( i ) ; } if ( checkSumPrime ( s ) ) System . out . println ( " Prime " ) ; else System . out . println ( " Not ▁ Prime \n " ) ; return false ; }
public static float sum ( int n ) { if ( n < 2 ) { return 1 ; } else { return 1 / n + ( sum ( n - 1 ) ) ; } }
static int countElements ( int [ ] p , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( p [ i - 1 ] > p [ i ] ) && ( p [ i ] > p [ i + 1 ] ) ) { ans ++ ; } else if ( ( p [ i - 1 ] < p [ i ] ) && ( p [ i ] < p [ i + 1 ] ) ) { ans ++ ; } } return ans ; }
public static int x , int y ; x = input ( ) . split ( ) ; return ( x == y ? ' = ' : ' > ' ) ? x : y : ' < ' ; }
static double findVolume ( int l , int b , int h ) { return ( ( l * b * h ) / 2 ) ; }
public static int n ( ) { int k = Integer . parseInt ( input . nextLine ( ) ) , s = input . nextLine ( ) ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) count [ ( int ) s . charAt ( i ) - ' A ' ] ++ ; Arrays . sort ( count , reverse ) ; int res = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] >= k ) { res += k * k ; System . out . println ( res ) ; exit ( ) ; } k -= count [ i ] ; res += count [ i ] * k ; } return res ; }
private static String compute ( ) { int i = 286 ; int j = 166 ; int k = 144 ; int triangle ; int pentagon ; int hexagon ; int minimum ; triangle = i * ( i + 1 ) / 2 ; pentagon = j * ( j * 3 - 1 ) / 2 ; hexagon = k * ( k * 2 - 1 ) ; minimum = Math . min ( triangle , pentagon , hexagon ) ; if ( minimum == Math . max ( triangle , pentagon , hexagon ) ) return Integer . toString ( triangle ) ; if ( minimum == triangle ) i ++ ; if ( minimum == pentagon ) j ++ ; if ( minimum == hexagon ) k ++ ; } if ( getClass ( ) . equals ( String . class ) ) System . out . println ( compute ( ) ) ; return null ; }
static int maxPrimefactorNum ( int N ) { if ( ( N < 2 ) || ( N > 3 ) ) return 0 ; boolean [ ] arr = new boolean [ N + 1 ] ; arr [ 0 ] = true ; int prod = 1 ; int res = 0 ; int p = 2 ; while ( ( p * p <= N ) && ( arr [ p ] ) ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = false ; prod *= p ; if ( ( prod > N ) && ( res < 0 ) ) return res ; } return res ; }
@ GwtIncompatible ( " java . util . Arrays " ) static boolean checkDivisors ( int [ ] a , int n ) { int X = max ( a ) ; List < Integer > b = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( X ) ; i ++ ) { if ( ( X % i ) == 0 ) { b . add ( i ) ; if ( ( X / i ) != i ) b . add ( X / i ) ; } } if ( ( b . size ( ) != n ) && ( b . size ( ) != n ) ) return false ; Arrays . sort ( a , false ) ; Arrays . sort ( b , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( b . get ( i ) != a [ i ] ) && ( b . get ( i ) != a [ i ] ) ) return false ; } return true ; }
static void subArray ( int arr [ ] , int n ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) { System . out . print ( arr [ k ] + " ▁ " ) ; } System . out . print ( arr [ k ] ) ; } } }
private static void for ( int n : Arrays . stream ( Integer . decode ( open ( 0 ) ) ) . limit ( 1 ) ) System . out . println ( ( ) -> ( ( 0 - - n ) / 6 , n / 4 ) . equals ( [ n - 1 ] ) || n % 2 < 3 ) ; }
static int maxSum ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * i ; } return sum ; }
static int maxSum ( int [ ] a , int n ) { Arrays . sort ( a ) ; int sum = 0 ; for ( int i = 0 ; i <= n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; }
static int findAnswer ( int n , int [ ] arr ) { Arrays . sort ( arr , false ) ; int sum = 0 ; for ( int i = 0 ; i < ( int ) ( n / 2 ) ; i ++ ) { sum += ( ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ) ; } return sum ; }
static int findSum ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int sum = arr [ 0 ] ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( ( arr [ i ] != arr [ i + 1 ] ) && ( arr [ i + 1 ] != arr [ i + 1 ] ) ) { sum = sum + arr [ i + 1 ] ; } } /* ▁ main ▁ loop ▁ */ arr = Arrays . asList ( 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ) ; n = arr . length ; System . out . println ( findSum ( arr , n ) ) ; }
private static final int MIN = - 2147483648 ; int MAX = 2147483648 ; class newnode { int data ; int left ; int right ; } public Node getDeepestLeftLeafNode ( Node root ) { if ( ( root == null ) || ( root . data == 0 ) ) return null ; Queue < Node > q = new LinkedList < Node > ( ) ; q . add ( root ) ; Node result = null ; while ( ( left = q . poll ( ) ) != null ) { Node temp = q . poll ( ) ; q . remove ( 0 ) ; if ( ( temp . left != null ) && ( ! temp . left . left . left . equals ( " " ) ) && ( ! temp . left . right . equals ( " " ) ) ) result = temp . left ; } if ( ( right = q . poll ( ) ) != null ) q . add ( temp . right ) ; return result ; } if ( className . equals ( " java . util . concurrent . LinkedListWithLessMemory " ) ) { Node root = newnode ( 1 ) ; root . left = newnode ( 2 ) ; root . right = newnode ( 3 ) ; root . left . Left = newnode ( 4 ) ; root . right . left = newnode ( 5 ) ; root . right . right = newnode ( 6 ) ; root . right . left . right = newnode ( 7 ) ; root . right . right . right = newnode ( 8 ) ; root . right . left . right . left = newnode ( 9 ) ; root . right . right . right = newnode ( 10 ) ; Node result = getDeepestLeftLeafNode ( root ) ; if ( result != null ) System . out . println ( " Deepest ▁ Left ▁ Leaf ▁ Node ▁ : : " + result . data ) ; else System . out . println ( " No ▁ result , ▁ Left ▁ leaf ▁ not ▁ found " ) ; } return null ; }
private static final int MIN = - 2147483648 ; int MAX = 2147483648 ; class newnode { int data ; int left ; int right ; } public Node getDeepestRightLeafNode ( Node root ) { if ( ( root == null ) || ( root . data == 0 ) ) return null ; Queue < Node > q = new LinkedList < Node > ( ) ; q . add ( root ) ; Node result = null ; while ( ( result = ( Node ) q . poll ( ) ) != null ) { Node temp = q . poll ( ) ; q . remove ( 0 ) ; if ( ( temp . left != null ) && ( temp . left . data == 0 ) ) q . add ( temp . left ) ; if ( ( temp . right != null ) && ( ! temp . right . data . equals ( " " ) ) ) result = temp . right ; if ( ( ! temp . right . left . isEmpty ( ) ) && ( ! temp . right . data . equals ( " " ) ) ) result = temp . right ; } return result ; } if ( className . equals ( " java . util . concurrent . LinkedQueue " ) ) { Node root = newnode . get ( 1 ) ; root . left = newnode . get ( 2 ) ; root . right = newnode . get ( 3 ) ; root . left . right = newnode . get ( 4 ) ; root . right . left = newnode . get ( 5 ) ; root . right . right = newnode . get ( 6 ) ; root . right . left . right = newnode . get ( 7 ) ; root . right . left . right = newnode . get ( 8 ) ; root . right . left . right . left = newnode . get ( 9 ) ; root . right . right . right . right = newnode . get ( 10 ) ; Node result = getDeepestRightLeafNode ( root ) ; if ( result != null ) System . out . println ( " Deepest ▁ Right ▁ Leaf ▁ Node ▁ : : " + result . data ) ; else System . out . println ( " No ▁ result , ▁ right ▁ leaf ▁ not ▁ found " ) ; } return null ; }
public static void print ( int n ) { int a = 2 ; int b = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int old_a = a ; a = b ; b = old_a + b ; } System . out . println ( b ) ; }
static void printRatio ( int a , int b , int c , int d ) { final int x ; if ( ( b * c > a * d ) && ( c * d > b ) ) { swap ( c , d ) ; swap ( a , b ) ; } final double lcm = ( a * c ) / Math . gcd ( a , c ) ; x = lcm / a ; b = ( int ) ( b * x ) ; y = lcm / c ; d = ( int ) ( d * y ) ; final double k = Math . gcd ( b , d ) ; b = ( int ) ( b / k ) ; d = ( int ) ( d / k ) ; System . out . println ( b + " : " + d ) ; }
public static int maxSum_SIS ( int [ ] arr , int n ) { int maxSum = 0 ; int currentSum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] < arr [ i ] ) && ( arr [ i ] > 0 ) ) { currentSum = currentSum + arr [ i ] ; } else { maxSum = Math . max ( maxSum , currentSum ) ; currentSum = arr [ i ] ; } } return Math . max ( maxSum , currentSum ) ; }
public static int GCD ( int a , int b ) { if ( ( b == 0 ) || ( a == 0 ) ) return a ; return GCD ( b , a % b ) ; /* ▁ find ▁ max ▁ sum ▁ */ int finalGCD = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { finalGCD = GCD ( arr [ i ] , finalGCD ) ; } return finalGCD ; }
static final long gcd ( long a , long b ) { long t ; while ( ( b = a ) != 0 ) { t = b ; b = a % b ; a = t ; } return a ; }
public static void print ( int t ) { int x , y , w , h ; int n ; for ( int i = 0 ; i < t ; i ++ ) { x = Integer . parseInt ( input . readLine ( ) ) ; y = Integer . parseInt ( input . readLine ( ) ) ; w = Integer . parseInt ( input . readLine ( ) ) ; h = Integer . parseInt ( input . readLine ( ) ) ; n = Integer . parseInt ( input . readLine ( ) ) ; int ans = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int cx = Integer . parseInt ( input . readLine ( ) ) ; int cy = Integer . parseInt ( input . readLine ( ) ) ; if ( x <= cx && x <= cx + w && y <= cy && y <= cy + h ) { ans ++ ; } } System . out . println ( ans ) ; } }
public static boolean divisibleBy37 ( String n ) { int l = n . length ( ) ; if ( ( n == null ) || ( l == 0 ) ) { return true ; } if ( ( l % 3 ) == 1 ) { n = "00" + n ; l += 2 ; } else if ( ( l % 3 ) == 2 ) { n = "0" + n ; l ++ ; } long gSum = 0 ; while ( ( l != 0 ) && ( l < 1000 ) ) { long group = Long . parseLong ( n . substring ( l - 3 , l ) ) ; l = l - 3 ; gSum = gSum + group ; } if ( ( gSum >= 1000 ) && ( gSum < 37 ) ) { return true ; } return false ; }
static final String print ( ) { final String input = System . console ( ) . readLine ( ) ; final int n = Integer . parseInt ( input ) ; final int x = input . charAt ( 0 ) ; return ans ; }
public static int lcs ( String X , String Y , int m , int n ) { int [ ] [ ] L = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 || j == 0 ) { L [ i ] [ j ] = 0 ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; } else { L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } } return L [ m ] [ n ] ; }
static int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = base / 2 ; return ( int ) ( base * ( base + 1 ) / 2 ) ; }
static double rmsValue ( double [ ] arr , int n ) { final double square = 0 ; double mean = 0.0 ; double root = 0.0 ; for ( int i = 0 ; i <= n ; i ++ ) { square += ( arr [ i ] * arr [ i ] ) ; } mean = ( square / ( ( double ) n ) ) ; root = Math . sqrt ( mean ) ; return root ; }
public static int [ ] [ ] parse ( String input ) { int m = Integer . parseInt ( input ) ; int n = Integer . parseInt ( input ) ; int [ ] p = new int [ m ] ; List < Integer > [ ] ce = new List [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ce [ i ] = Integer . parseInt ( input ) ; } double [ ] [ ] dp = new double [ m + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( j < ce [ i ] [ 0 ] ) { dp [ i + 1 ] [ j ] = Math . min ( dp [ i ] [ j ] , ce [ i ] [ 1 ] ) ; continue ; } dp [ i + 1 ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ j - ce [ i ] [ 0 ] ] + ce [ i ] [ 1 ] ) ; } } Arrays . sort ( p ) ; Arrays . reverse ( dp ) ; int [ ] sump = new int [ m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) sump [ i + 1 ] += sump [ i ] + p [ i ] ; int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = Math . max ( ans , sump [ i ] - dp [ n ] [ i ] ) ; System . out . println ( ans ) ; return dp ; }
public static final class Heap extends Heap { private final List < Node > _nodes = new ArrayList < Node > ( ) ; @ SuppressWarnings ( " unchecked " ) final List < Node > li = new ArrayList < Node > ( ) ; @ SuppressWarnings ( " unchecked " ) final Heap < Node > heap = new Heap < Node > ( ) { private int cur = 0 ; @ Override public Node create ( final List < Node > li ) { heap . nodes = li ; return heap ; } @ Override public Iterator < Node > iterator ( ) { return new Iterator < Node > ( ) { private int cur = 0 ; @ Override public boolean hasNext ( ) { return cur < 0 ; } @ Override public Node next ( ) { if ( cur >= li . nodes . size ( ) ) { throw new NoSuchElementException ( ) ; } cur ++ ; Node node = li . nodes . get ( cur - 1 ) ; if ( cur / 2 - 1 >= 0 ) { Node parent = li . nodes . get ( cur / 2 - 1 ) ; if ( parent != null ) { Node left = li . nodes . get ( cur * 2 - 1 ) ; if ( left != null ) { Node right = li . nodes . get ( cur * 2 ) ; if ( right != null ) { return new Node ( node , parent , left , right ) ; } } } } return super . hasNext ( ) ; } @ Override public Node next ( ) { if ( cur >= li . nodes . size ( ) ) { return null ; } cur ++ ; Node node = li . nodes . get ( cur - 1 ) ; if ( cur / 2 >= 0 ) { Node parent = li . nodes . get ( cur / 2 - 1 ) ; if ( parent != null ) { Node left = li . nodes . get ( cur * 2 - 1 ) ; if ( left != null ) { Node right = li . nodes . get ( cur * 2 ) ; if ( right != null ) { Node right = li . nodes . get ( cur * 2 ) ; if ( right != null ) { right = right ; } } } } return super . next ( ) ; } return node ; } } ; } @ Override public void run ( ) { final int n = Integer . parseInt ( input . readLine ( ) ) ; final Node [ ] nodes = new Node [ n ] ; for ( int i = 0 ; i < nodes . length ; i ++ ) { nodes [ i ] = Integer . parseInt ( input
static final int [ ] [ ] maxSum ( int [ ] [ ] arr ) { int n = 6 ; int m = 6 ; int [ ] [ ] dp = new int [ n + 1 ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { int m1 = 0 ; int m2 = 0 ; int m3 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( ( j / ( m / 3 ) ) == 0 ) && ( ( j / ( m / 3 ) ) == 0 ) ) { m1 = Math . max ( m1 , arr [ i ] [ j ] ) ; } else if ( ( ( j / ( m / 3 ) ) == 1 ) && ( ( j / ( m / 3 ) ) == 0 ) ) { m2 = Math . max ( m2 , arr [ i ] [ j ] ) ; } else if ( ( ( j / ( m / 3 ) ) == 2 ) && ( ( j / ( m / 3 ) ) == 0 ) ) { m3 = Math . max ( m3 , arr [ i ] [ j ] ) ; } } dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; dp [ i + 1 ] [ 2 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; } System . out . println ( ( int ) Math . max ( Math . max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) ; if ( __name__ == null ) { arr = new int [ ] [ ] { { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } } ; maxSum ( arr ) ; } return dp ; }
private static void findPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . max ( x1 , x3 ) ; int y5 = Math . max ( y1 , y3 ) ; int x6 = Math . min ( x2 , x4 ) ; int y6 = Math . min ( y2 , y4 ) ; if ( ( x5 > x6 ) || ( y5 > y6 ) ) { System . out . println ( " No ▁ intersection " ) ; return ; } System . out . print ( " ( " + x5 + " , ▁ " + y5 + " ) ▁ " ) ; System . out . print ( " ( " + x6 + " , ▁ " + y6 + " ) ▁ " ) ; int x7 = x5 ; int y7 = y6 ; System . out . print ( " ( " + x7 + " , ▁ " + y7 + " ) ▁ " ) ; int x8 = x6 ; int y8 = y5 ; System . out . print ( " ( " + x8 + " , ▁ " + y8 + " ) ▁ " ) ; } if ( getClass ( ) . equals ( String . class ) ) { x1 = 0 ; y1 = 0 ; x2 = 10 ; y2 = 8 ; x3 = 2 ; y3 = 3 ; x4 = 7 ; y4 = 9 ; findPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; }
@ InputFunction public static void input ( @ InputPosition Position Position Position position ) { int nHamsters = Integer . parseInt ( input . nextLine ( ) ) ; String [ ] hamsters = input . split ( " ▁ " ) ; int hamstersStanding = Arrays . stream ( hamsters ) . filter ( ham -> ham . equals ( " X " ) ) . count ( ) ; int hamstersSitting = nHamsters - hamstersStanding ; if ( hamstersStanding == hamstersSitting ) { System . out . println ( 0 ) ; System . out . println ( hamsters ) ; } else if ( hamstersStanding > hamstersSitting ) { int numChange = ( hamstersStanding - hamstersSitting ) / 2 ; System . out . println ( numChange ) ; String result = " " ; for ( String hamster : hamsters ) { if ( hamster . equals ( " X " ) && numChange > 0 ) { result += " x " ; numChange -- ; } else { result += hamster ; } } System . out . println ( result ) ; } else { int numChange = ( hamstersSitting - hamstersStanding ) / 2 ; System . out . println ( numChange ) ; String result = " " ; for ( String hamster : hamsters ) { if ( hamster . equals ( " X " ) && numChange > 0 ) { result += " X " ; numChange -- ; } else { result += hamster ; } } System . out . println ( result ) ; } }
public static void input ( ) { int n = Integer . parseInt ( input ( ) ) ; int d = Integer . parseInt ( input ( ) ) ; int e = Integer . parseInt ( input ( ) ) ; int dm = d ; int em = e * 5 ; int max = Math . max ( dm , em ) ; int min = Math . min ( dm , em ) ; int rem = n % max ; int div = ( int ) ( ( n - rem ) / max ) ; int i = div ; int ans = rem ; while ( i > - 1 ) { int dum = 0 ; dum += n ; int rl = dum - ( i * max ) ; int fin = rl % min ; if ( fin < ans ) { if ( fin == 0 ) { ans = 0 ; i = - 1 ; } else { ans = fin ; } } i -- ; } System . out . println ( ans ) ; }
static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) { double maxratio = - Integer . MAX_VALUE - 1 ; int maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( val [ i ] / wt [ i ] ) > maxratio ) ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; }
private static void alternateRearrange ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; LinkedList < Integer > v1 = new LinkedList < Integer > ( ) ; LinkedList < Integer > v2 = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 ) == 0 ) { v1 . add ( arr [ i ] ) ; } else { v2 . add ( arr [ i ] ) ; } } int index = 0 ; int i = 0 ; int j = 0 ; boolean flag = false ; if ( ( arr [ 0 ] % 2 ) == 0 ) { flag = true ; } while ( ( index < n ) ) { if ( ( flag ) == true ) { arr [ index ] = v1 . get ( i ) ; } } }
public static int A , int B , int C ; int A = Integer . parseInt ( input . nextLine ( ) ) ; int B = Integer . parseInt ( input . nextLine ( ) ) ; int C = Integer . parseInt ( input . nextLine ( ) ) ; if ( A <= C && B >= C ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return A ; }
static String decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; for ( int i = 0 ; i < 32 ; i ++ ) { binaryNum [ i ] = 0 ; } int i = 0 ; while ( ( n > 0 ) && ( n < binaryNum . length ) ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } String binary = " " ; for ( int j = i - 1 ; j >= 0 ; j -- ) { binary += Integer . toString ( binaryNum [ j ] ) ; } return binary ; }
static void makeArrayEqual ( int arr [ ] , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += arr [ i ] & 1 ; } System . out . println ( Math . min ( x , n - x ) ) ; } if ( getClass ( ) . isArray ( ) ) { int arr [ ] = { 4 , 3 , 2 , 1 } ; int n = arr . length ; makeArrayEqual ( arr , n ) ; }
public static final Solution < Integer > getSolution ( ) { final Solution < Integer > sObj = new Solution < Integer > ( ) { @ Override public int [ ] findKthLargest ( final int [ ] nums , final int k ) { Collections . shuffle ( nums ) ; return quickSelection ( nums , 0 , nums . length - 1 , nums . length - k ) ; } @ Override public int quickSelection ( final int [ ] nums , final int start , final int end , final int k ) { if ( start > end ) { return Integer . MAX_VALUE ; } final int pivot = nums [ end ] ; int left = start ; for ( int i = start ; i < end ; i ++ ) { if ( nums [ i ] <= pivot ) { nums [ left ] = nums [ i ] ; left ++ ; } } nums [ left ] = nums [ end ] ; if ( left == k ) { return nums [ left ] ; } else if ( left < k ) { return quickSelection ( nums , left + 1 , end , k ) ; } else { return quickSelection ( nums , start , left - 1 , k ) ; } } } ; if ( getClassName ( ) . equals ( " org . apache . commons . analysis . Solution " ) ) { sObj . setSolution ( sObj ) ; final int [ ] nums = { 3 , 2 , 1 , 5 , 6 , 4 } ; final int k = 2 ; final int out = sObj . findKthLargest ( nums , k ) ; System . out . println ( out ) ; } return sObj ; }
static String isDivisible ( int n ) { int temp = n ; while ( ( n = n % 10 ) != 0 ) { int k = n % 10 ; if ( ( temp % k ) == 0 ) { return " YES " ; } n /= 10 ; } return " NO " ; }
static String isDivisible ( int n ) { int temp = n ; int sum = 0 ; while ( ( n = n % 10 ) != 0 ) { int k = n % 10 ; sum += k ; n /= 10 ; } if ( ( temp % sum ) == 0 ) return " YES " ; return " NO " ; }
public static int a ( ) { int a = Integer . parseInt ( input ( ) ) ; int b = Integer . parseInt ( input ( ) ) ; return ( a > b ? " GREATER " : " LESS " ) ; }
static long calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . min ( l , b ) ; long totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { long totalSquares = ( ( l - size + 1 ) * ( b - size + 1 ) ) ; long area = ( totalSquares * size * size ) ; totalArea += area ; size ++ ; } return totalArea ; }
public static void arrange ( int N ) { if ( ( N == 1 ) && ( N == 3 ) ) { System . out . println ( "1" ) ; return ; } if ( ( N == 2 ) || ( N == 3 ) ) { System . out . println ( " - 1" ) ; return ; } int even = - 1 ; int odd = - 1 ; if ( ( N % 2 ) == 0 ) { even = N ; odd = N - 1 ; } else { odd = N ; even = N - 1 ; } while ( ( odd >= 1 ) && ( odd <= 2 ) ) { System . out . print ( odd + " ▁ " ) ; odd = odd - 2 ; } while ( ( even >= 2 ) && ( even <= 2 ) ) { System . out . print ( even + " ▁ " ) ; even = even - 2 ; } if ( getClass ( ) . equals ( " java . lang . Integer " ) ) { N = 5 ; arrange ( N ) ; } }
static int findMinEqualSums ( int [ ] a , int N ) { int sum = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { sum = sum + a [ i ] ; } int sum1 = 0 ; int sum2 = 0 ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i <= N - 1 ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( ( Math . abs ( sum1 - sum2 ) < min ) && ( Math . abs ( sum1 - sum2 ) < min ) ) { min = Math . abs ( sum1 - sum2 ) ; } if ( ( min == 0 ) && ( Math . abs ( sum1 - sum2 ) < min ) ) { break ; } } return min ; }
public static void input ( ) { for ( int i = 0 ; i < Integer . parseInt ( input . readLine ( ) ) ; i ++ ) { int n = Integer . parseInt ( input . readLine ( ) ) ; if ( n == 1 || n == 2 ) { System . out . println ( n ) ; } else { String u = String . valueOf ( ) ; int v = n / 3 ; int w = n % 3 ; u += "21" ; if ( w == 1 ) { u = "1" + u ; } else if ( w == 2 ) { u += "2" ; } System . out . println ( u ) ; } } }
static int findOptimalSolution ( int [ ] a , int N ) { Arrays . sort ( a ) ; int points = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { points += a [ i ] * i ; } return points ; }
public static void print ( int n , int b ) { int time = 0 ; Queue < Integer > queue = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int t = Integer . parseInt ( input . readLine ( ) ) ; int d = Integer . parseInt ( input . readLine ( ) ) ; while ( queue . size ( ) != 0 && t >= queue . peek ( ) ) { queue . poll ( ) ; } if ( queue . size ( ) <= b ) { time = Math . max ( t , time ) + d ; queue . add ( time ) ; System . out . print ( time + " ▁ " ) ; } else System . out . print ( - 1 ) ; } }
public static void main ( String input ) { for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { String nm = input . nextLine ( ) ; int len = nm . length ( ) ; StringBuilder in = new StringBuilder ( ) ; for ( int j = 0 ; j < len ; j ++ ) { in . append ( Integer . parseInt ( in . toString ( ) ) ) ; in . delete ( 0 , j ) ; } in . trimToSize ( ) ; int sum1 = 0 ; for ( int j = 0 ; j < len ; j ++ ) { sum1 += Math . max ( in . length ( ) - j , in . length ( ) ) ; } if ( ( sum1 + Integer . parseInt ( nm ) ) <= Integer . parseInt ( nm ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
static int getPairs ( int [ ] a ) { int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < a . length ; j ++ ) { if ( ( a [ i ] < a [ j ] ) && ( a [ j ] < a [ i ] ) ) { count ++ ; } } } return count ; }
public static void print ( String s ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int k = Integer . parseInt ( s ) ; String s = input . nextLine ( ) ; if ( k == 0 ) { System . out . println ( s ) ; } else if ( Integer . parseInt ( s ) <= 9 ) { System . out . println ( 0 ) ; } else { int c = 0 ; int condition = 0 ; StringBuffer ans = new StringBuffer ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i == 0 && condition == 0 ) { ans . append ( '1' ) ; if ( s . charAt ( i ) == '1' ) { c ++ ; } else { c ++ ; } } else if ( condition == 0 ) { ans . append ( '0' ) ; if ( s . charAt ( i ) == '0' ) { c ++ ; } else { c ++ ; } } if ( c == k ) { condition = 1 ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { ans . append ( s . charAt ( j ) ) ; if ( j == s . length ( ) - 1 ) { c = - 1 ; break ; } } } } System . out . println ( ans ) ; } }
public static int [ ] [ ] a ( ) { for ( int i = 0 ; i < 4 ; i ++ ) { String [ ] str = input . nextLine ( ) . split ( " ▁ " ) ; a [ i ] = new int [ 4 ] ; for ( int j = 0 ; j < 4 ; j ++ ) { a [ i ] [ j ] = Integer . parseInt ( str [ j ] ) ; } } return a ; }
static int N = 10000 ; final int MOD = 1000000007 ; int [ ] F = new int [ N ] ; { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; if ( n == 0 ) { break ; } int num = 2 ; int cnt = 0 ; do { int ini = num * ( num + 1 ) / 2 ; if ( n < ini ) { break ; } while ( ini <= n ) { if ( ini == n ) { cnt ++ ; break ; } ini += num ; } num ++ ; } while ( true ) ; System . out . println ( cnt ) ; }
private static int CeilIndex ( int [ ] A , int l , int r , int key ) { while ( ( r - l ) > 1 ) { int m = l + ( r - l ) / 2 ; if ( ( A [ m ] >= key ) && ( A [ m ] <= key ) ) { r = m ; } else { l = m ; } } /* ▁ Longest ▁ Increasing ▁ Subsequence ▁ length ▁ */ int [ ] tailTable = new int [ size + 1 ] ; int len = 0 ; tailTable [ 0 ] = A [ 0 ] ; len = 1 ; for ( int i = 1 ; i < size ; i ++ ) { tailTable [ i ] = A [ i ] ; } return len ; }
public static int [ ] readIntList ( ) { N = Integer . parseInt ( input ( ) ) ; int [ ] X = Lists . newArrayList ( ) ; for ( int i = 0 ; i < N ; i ++ ) X [ i ] = Integer . parseInt ( input ( ) ) ; int Xmn = min ( X ) , Xmx = max ( X ) ; int [ ] temp = new int [ N ] ; int res = Xmx - Xmn ; for ( int x = Xmn ; x <= Xmx ; x ++ ) { for ( int n = 0 ; n < N ; n ++ ) temp [ n ] = Math . abs ( X [ n ] - x ) ; if ( max ( temp ) < res ) res = max ( temp ) ; temp = new int [ N ] ; } System . out . println ( res ) ; return temp ; }
static final String compute ( ) { final int LIMIT = 10 * 6 ; long ans = Long . valueOf ( 1 ) . longValue ( ) ; for ( int i = 0 ; i < LIMIT ; i ++ ) { if ( getChainLength ( i ) == 60 ) { return String . valueOf ( ans ) ; } } { Set < Long > set = new HashSet < > ( ) ; do { set . add ( n ) ; n = factorialize ( n ) ; } while ( n != 0 ) ; } { long result = 0 ; while ( n != 0 ) { result += FACTORIAL [ n % 10 ] ; n /= 10 ; } return result ; } }
public static int colourVisible ( int [ ] height , int [ ] colour , int K ) { int [ ] arr = new int [ K + 1 ] ; for ( int i = 0 ; i < K + 1 ; i ++ ) { arr [ i ] = 0 ; } int visible = 0 ; int max = height [ K - 1 ] ; arr [ colour [ K - 1 ] ] = 1 ; int i = K - 2 ; while ( ( i >= 0 ) && ( ( height [ i ] > max ) && ( arr [ i ] > 0 ) ) ) { max = height [ i ] ; arr [ colour [ i ] ] = 1 ; } i -- ; for ( int i = 1 ; i <= K ; i += 1 ) { if ( ( arr [ i ] == 1 ) && ( arr [ i ] == 0 ) ) { visible ++ ; } } return visible ; }
@ GwtIncompatible ( " java . lang . Math " ) public static double checkPowerof8 ( double n ) { double i = Math . log ( n , 8 ) ; return ( i - trunc ( i ) < 0.000001 ) ? i : i ; }
public static void main ( String input ) { for ( ; ; ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; if ( a == b ) { System . out . println ( ( a + b ) / 4 ) ; } else { System . out . println ( Math . min ( Math . min ( a , b ) , ( a + b ) / 4 ) ) ; } } }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == m == 0 ) { break ; } int [ ] students = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { students [ i ] = 0 ; } for ( int i = 0 ; i < m ; i ++ ) { List < Integer > scores = new LinkedList < Integer > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { scores . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } for ( int j = 0 ; j < n ; j ++ ) { students [ j ] += scores . get ( j ) ; } } System . out . println ( Collections . max ( students ) ) ; }
public static void for ( final int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { final int n = Integer . parseInt ( input . nextLine ( ) ) ; int now = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { final int l = Integer . parseInt ( input . nextLine ( ) ) ; final int r = Integer . parseInt ( input . nextLine ( ) ) ; if ( now <= l ) { System . out . print ( l ) ; now = l + 1 ; } else if ( now <= r ) { System . out . print ( now ) ; now ++ ; } else { System . out . print ( 0 ) ; } } System . out . println ( ) ; }
static int countWays ( int n , int m ) { int [ ] count = new int [ n + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ i ] = 0 ; } count [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i > m ) && ( count [ i - 1 ] == 0 ) ) count [ i ] = 1 ; } return count [ n ] ; }
public static void bombRequired ( int n ) { System . out . println ( n + n / 2 ) ; for ( int i = 2 ; i <= n ; i += 2 ) { System . out . print ( i + " ▁ " ) ; } }
public static int n ( ) { n = ( int ) input . nextInt ( ) ; return ( ( n + 1 ) & - ( n + 1 ) ) ; }
public static String input ( ) { String s = String . valueOf ( input ( ) ) ; StringBuffer myStr = new StringBuffer ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '0' || c == '1' ) { myStr . append ( c ) ; } else if ( c == ' B ' && myStr . length ( ) != 0 ) { myStr . deleteCharAt ( i ) ; } } return myStr . toString ( ) ; }
static final Scanner in = new Scanner ( System . in ) { int n , x ; do { n = Integer . parseInt ( in . nextLine ( ) ) ; x = Integer . parseInt ( in . nextLine ( ) ) ; } while ( ( n == 0 ) & ( x == 0 ) ) ; int ret = 0 ; for ( int v : new int [ n + 1 ] ) { if ( Integer . parseInt ( in . nextLine ( ) ) == x ) { ret ++ ; } } System . out . println ( ret ) ; return new Scanner ( System . in ) ; }
@ VisibleForTesting static int recur ( int ind , int cnt , int last , int [ ] a , int n , int k , int [ ] [ ] dp ) { int MAX = 100 ; int ans ; if ( ( cnt == k ) && ( last == 0 ) ) { return 0 ; } if ( ( ind == n ) && ( last == 0 ) ) { return - 10 * 9 ; } if ( ( dp [ ind ] [ cnt ] != - 1 ) && ( dp [ ind ] [ cnt ] != - 1 ) ) { return dp [ ind ] [ cnt ] ; } ans = 0 ; for ( int i = ind ; i < n ; i ++ ) { if ( ( cnt % 2 == 0 ) && ( a [ i ] == 0 ) ) { ans = i ; } } return ans ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; List < Double > arr = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arr . add ( Double . parseDouble ( input ) ) ; } arr = new ArrayList < Double > ( ) ; arr . sort ( ) ; arr . stream ( ) . filter ( x -> x - Integer . MIN_VALUE != 0 ) . forEach ( x -> { } ) ; int o = 2 * n - arr . size ( ) ; double arr_sum = sum / o ; int res = ( int ) 2e9 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + o >= n ) { res = Math . min ( res , Math . abs ( i - arr_sum ) ) ; } } System . out . printf ( " % .3f " , res ) ; }
public static String equivalentBase4 ( String bin ) { if ( ( bin . equals ( "00" ) ) && ( bin . equals ( "01" ) ) ) { return 0 ; } if ( ( bin . equals ( "10" ) ) && ( bin . equals ( "11" ) ) ) { return 2 ; } if ( ( bin . equals ( "11" ) ) && ( bin . equals ( "11" ) ) ) { return 3 ; } /* ▁ isDivisibleBy5 ▁ */ int l = bin . length ( ) ; if ( ( ( l % 2 ) == 1 ) && ( bin . charAt ( 0 ) != '0' ) ) { bin = "0" + bin ; } int odd_sum = 0 ; int evend_sum = 0 ; boolean is_odd_digit = true ; for ( int i = 0 ; i < bin . length ( ) ; i += 2 ) { if ( ( is_odd_digit ) && ( bin . charAt ( i ) != '0' ) ) { odd_sum += equivalentBase4 ( bin . substring ( i , i + 2 ) ) ; } else { evend_sum += equivalentBase4 ( bin . substring ( i , i + 2 ) ) ; } is_odd_digit = is_odd_digit ^ 1 ; } if ( ( Math . abs ( odd_sum - evend_sum ) % 5 ) == 0 ) { return " Yes " ; } else { return " No " ; } }
@ VisibleForTesting static LinkedHashMap < List < Integer > , Integer > score = new LinkedHashMap < > ( ) { private static final long serialVersionUID = - 2561302937926L ; @ Override public int [ ] get ( int index ) { return new int [ 8 ] ; } }
@ VisibleForTesting static Iterable < Integer > permutations ( ) { List < Integer > nums = Lists . newArrayList ( ) ; return nums ; }
@ VisibleForTesting static int minimumSquareFreeDivisors ( int N ) { final int MAX = 1005 ; /* ▁ SieveOfEratosthenes ▁ primes ▁ = ▁ new ▁ int [ MAX ] ; ▁ for ▁ ( int ▁ i = 0 ; ▁ i < MAX ; ▁ i + + ) ▁ { STRNEWLINE ▁ prime [ i ] ▁ = ▁ true ; STRNEWLINE ▁ } */ for ( int p = 2 ; ( p < Integer . MAX_VALUE ) && ( prime [ p ] == true ) ; p ++ ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p += 1 ) { if ( ( prime [ p ] == false ) && ( prime [ p ] == true ) ) { primes [ p ] = true ; } } /* ▁ Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ */ final int [ ] prime = new int [ MAX ] ; final int [ ] primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes = new int [ MAX ] ; primes [ 0 ] = primes ; return primes
@ VisibleForTesting static void sleep ( ) { int x = Integer . parseInt ( input . nextLine ( ) ) ; int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; int ans = ( x - a ) % b ; sleep ( a * 0.001 ) ; System . out . println ( ans ) ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int k = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > elems = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { elems . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } Predicate < Integer > allSame = arr -> Arrays . stream ( arr ) . allMatch ( arr -> arr . equals ( arr . get ( 0 ) ) ) ; if ( allSame . apply ( elems ) ) { System . out . println ( 0 ) ; return ; } if ( k == 1 ) { System . out . println ( - 1 ) ; return ; } if ( ! allSame . apply ( elems . subList ( k - 1 , elems . size ( ) ) ) ) { System . out . println ( - 1 ) ; return ; } int target = elems . get ( elems . size ( ) - 1 ) ; List < Integer > toDelete = new ArrayList < > ( elems ) ; toDelete . subList ( 0 , k - 1 ) . clear ( ) ; while ( toDelete . size ( ) > 0 && toDelete . get ( toDelete . size ( ) - 1 ) == target ) { toDelete . remove ( toDelete . size ( ) - 1 ) ; } System . out . println ( toDelete . size ( ) ) ; }
public static int fun ( int n ) { return n & ( n - 1 ) ; }
private static int longestFibSubseq ( int [ ] A , int n ) { Set < Integer > S = new HashSet < > ( Arrays . asList ( A ) ) ; int maxLen = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { int x = A [ j ] ; int y = A [ i ] + A [ j ] ; int length = 2 ; while ( S . contains ( y ) ) { int z = x + y ; x = y ; y = z ; length ++ ; maxLen = Math . max ( maxLen , length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; }
static int countPairs ( int [ ] a , int [ ] b , int n , int m ) { int cnt = 0 ; Map < Integer , Integer > s = Maps . newHashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int sum = a [ i ] + b [ j ] ; if ( ( sum != 0 ) && ( sum != 0 ) ) { cnt ++ ; s . put ( sum , 1 ) ; } } } return cnt ; }
static boolean check ( int [ ] a , int y ) { final double sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { final double x = Math . sqrt ( a [ i ] ) ; if ( ( Math . floor ( x ) == Math . ceil ( x ) ) && ( y == 0 ) ) { sum = sum + a [ i ] ; } } if ( ( sum % y ) == 0 ) { return true ; } else { return false ; } int [ ] a = { 2 , 3 , 4 , 9 , 10 } ; int x = 13 ; if ( check ( a , x ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
static final int [ ] [ ] getQueries ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int q = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] [ ] Q = new int [ n ] [ ] ; for ( int i = 0 ; i < q ; i ++ ) Q [ i ] = new int [ n ] ; List < List < Integer > > queries = new LinkedList < > ( ) ; for ( int i = 0 ; i < q ; i ++ ) queries . add ( Collections . singletonList ( input . nextLine ( ) ) ) ; for ( List < Integer > query : queries ) { switch ( query . get ( 0 ) ) { case 0 : heapSort ( Q [ query . get ( 1 ) ] , - query . get ( 2 ) ) ; break ; case 1 : if ( Q [ query . get ( 1 ) ] != null ) System . out . println ( - Q [ query . get ( 1 ) ] [ 0 ] ) ; break ; case 2 : if ( Q [ query . get ( 1 ) ] != null ) heapSort ( Q [ query . get ( 1 ) ] , - Q [ query . get ( 2 ) ] [ 0 ] ) ; break ; } } return Q ; }
public static int calculateMinSum ( int [ ] a , int n ) { Arrays . sort ( a ) ; int minSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) { minSum += Math . abs ( a [ i ] - a [ i - 1 ] ) ; } return minSum ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] A = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int m = Integer . parseInt ( input ) ; int [ ] B = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int ans = 0 ; for ( int i = 0 ; i < Math . min ( A . length , B . length ) ; i ++ ) { if ( A [ i ] < B [ i ] ) { ans = 1 ; break ; } else if ( A [ i ] > B [ i ] ) { break ; } } System . out . println ( ans ) ; }
public static void main ( String input ) { int N = Integer . parseInt ( input ) ; int [ ] a = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { a [ i ] = Integer . parseInt ( input ) ; } int odd = 0 ; int m2 = 0 ; int m4 = 0 ; for ( int n : a ) { if ( n % 2 == 1 ) { odd ++ ; } else if ( n % 4 != 0 ) { m2 ++ ; } else { m4 ++ ; } } if ( m4 >= odd || ( m2 == 0 && m4 >= odd - 1 ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
static boolean isPalindrome ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) ) { return false ; } } return true ; }
public static int countNumbers ( int k , int n ) { int [ ] [ ] dp = new int [ 2 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ i ] [ 1 ] = k - 1 ; } for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
static int minCost ( int n , int [ ] arr , int cost ) { int Sum = 0 , totalCost = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { Sum += arr [ i ] ; } totalCost += cost * Sum ; arr [ n - 1 ] += Sum ; totalCost += ( 2 * cost * arr [ n - 1 ] ) ; return totalCost ; }
@ GwtIncompatible ( " java . lang . System " ) public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int C , CC , CAN ; CC = 0 ; CC = 0 ; CAN = Math . min ( c , a , n ) ; c -= CAN ; a -= CAN ; if ( a > 0 && c > 0 ) { CCA = Math . min ( a , c / 2 ) ; c -= ( CCA * 2 ) ; } if ( c > 2 ) { CCC = c / 3 ; } /* ▁ main ( ) ▁ */ Q = Integer . parseInt ( input . nextLine ( ) ) ; for ( ; ; ) { c = Integer . parseInt ( input . nextLine ( ) ) ; a = Integer . parseInt ( input . nextLine ( ) ) ; n = Integer . parseInt ( input . nextLine ( ) ) ; int ans = solve ( c , a , n ) ; System . out . println ( ans ) ; } }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; if ( n == 0 ) break ; int m = Integer . parseInt ( input ) ; String s = input ; int [ ] ar = new int [ m ] ; int ans = 0 ; if ( m >= 3 ) { for ( int i = 2 ; i < m ; i ++ ) { if ( s . substring ( i - 2 , i + 1 ) . equals ( " IOI " ) ) { ar [ i ] = ar [ i - 2 ] + 1 ; if ( ar [ i ] >= n ) ans ++ ; } } } System . out . println ( ans ) ; }
public static void print ( int t = Integer . parseInt ( input ) ) { for ( int i = 0 ; i < t ; i ++ ) { String n = input . nextLine ( ) ; int length = n . length ( ) ; int minval = 10000 ; for ( int i = 0 ; i < length - 1 ; i ++ ) { char n1 = n . charAt ( i ) ; for ( int j = i + 1 ; j < length ; j ++ ) { char n2 = n . charAt ( j ) ; if ( ( int ) ( n1 + n2 ) % 25 == 0 ) { int val = length - i - 2 ; if ( val < minval ) { minval = val ; } } } } System . out . println ( minval ) ; } }
static Node newNode ( int data ) { Node root ; Node root ; Node root ; root = null ; root = null ; root = null ; root = null ; root = null ; root = null ; root . data = data ; root . left = null ; root . right = null ; root . left = null ; root . right = null ; root . left = null ; root . right = null ; root . left = null ; root . right = null ; root . left = null ; root . right = null ; root . left = null ; root . right = null ; root . right = null ; if ( ( root == null ) || ( root . left == null ) ) { return newNode ( data ) ; } else { if ( ( data < root . data ) || ( root . left == null ) ) { root . left = insert ( root . left , data ) ; } if ( ( data > root . data ) || ( root . right == null ) ) { root . right = insert ( root . right , data ) ; } return root ; } inOrder ( root ) ; if ( className == Node . class ) { int arr [ ] = { 1 , 2 , 3 , 2 , 5 , 4 , 4 } ; int n = arr . length ; root = null ; for ( int i = 0 ; i < n ; i ++ ) { root = insert ( root , arr [ i ] ) ; } inOrder ( root ) ; } return root ; }
public static String removeChars ( String str , int k ) { int [ ] hash = new int [ MAX_CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hash [ ( str . charAt ( i ) - ' a ' ) ] ++ ; } String res = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( hash [ ( str . charAt ( i ) - ' a ' ) ] >= k ) && ( str . charAt ( i ) != ' ▁ ' ) ) { res += str . charAt ( i ) ; } } return res ; }
public static int LCSubStr ( String X , String Y , int m , int n ) { int [ ] [ ] LCSuff = new int [ n + 1 ] [ m + 1 ] ; for ( int k = 0 ; k < n + 1 ; k ++ ) { for ( int l = 0 ; l < m + 1 ; l ++ ) { LCSuff [ k ] [ l ] = 0 ; } } int result = 0 ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( ( i == 0 ) || ( j == 0 ) ) { LCSuff [ i ] [ j ] = 0 ; } else if ( ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) ) { LCSuff [ i ] [ j ] = 0 ; } } } return result ; }
static int countOccurrences ( int x , int d ) { int count = 0 ; while ( ( x = ( int ) ( x / 10 ) ) != 0 ) { if ( ( x % 10 ) == d ) { count ++ ; } x = ( int ) ( x / 10 ) ; } return count ; }
static void printLogestIncSubArr ( int arr [ ] , int n ) { int m = 1 ; int l = 1 ; int maxIndex = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] > arr [ i - 1 ] ) && ( arr [ i ] < l ) ) { l = l + 1 ; } else { if ( ( m < l ) && ( l < maxIndex ) ) { m = l ; maxIndex = i - m ; } l = 1 ; } } if ( m < l ) { m = l ; maxIndex = n - m ; } }
public static int a = Integer . parseInt ( input ) { for ( int i = a ; i > 0 ; i -- ) { if ( a % i == 0 ) { System . out . print ( i + " ▁ " ) ; a = i ; } } return a ; }
static final Scanner input = new Scanner ( System . in ) { @ Override public void close ( ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int m = input . nextInt ( ) ; int [ ] w = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { w [ i ] = input . nextInt ( ) ; } for ( ; ; ) { int l = input . nextInt ( ) ; int r = input . nextInt ( ) ; int x = input . nextInt ( ) ; int d = 0 ; for ( int i = l - 1 ; i < r ; i ++ ) { if ( w [ x - 1 ] > w [ i ] ) { d ++ ; } } if ( d == x - l ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } } }
public static int Max_Sum ( int [ ] a , int n ) { int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = 0 ; int S = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = res ; res += a [ i ] ; S += a [ i ] ; res = Math . max ( res , - S ) ; } int ans = S ; ans = Math . max ( ans , res ) ; int g = 0 ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = - 6 ; return g ; }
; if ( __name__ == " _ _ main _ _ " ) { for ( ; ; ) { int x = Integer . parseInt ( input . nextLine ( ) ) ; int y = Integer . parseInt ( input . nextLine ( ) ) ; int i = 0 , j = 0 ; boolean turn = false ; int commands = 0 ; do { if ( i == x && j == y ) break ; if ( turn ) { if ( i == x ) { } if ( i < x ) i ++ ; else i -- ; commands ++ ; } else { if ( j == y ) { } else if ( j < y ) j ++ ; else j -- ; commands ++ ; } turn = ! turn ; } while ( turn ) ; System . out . println ( x == y ? commands : commands - 1 ) ; } }
public static void reverse ( String str1 , int x ) { int n = ( str1 . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( str1 . charAt ( i ) ) ; for ( int i = n + x ; i < str1 . length ( ) ; i ++ ) { } }
public static int lps ( String str ) { int n = str . length ( ) ; int [ ] [ ] L = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { L [ i ] [ i ] = 0 ; } for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl ; i ++ ) { int j = i + cl - 1 ; if ( ( str . charAt ( i ) == str . charAt ( j ) ) && ( cl == 2 ) ) { L [ i ] [ j ] = 2 ; } else if ( ( str . charAt ( i ) == str . charAt ( j ) ) ) { L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; } else { L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } } return L [ 0 ] [ n - 1 ] ; }
public static boolean bitCheck ( int n ) { if ( ( ( n & ( n - 1 ) ) == 0 ) && ( ( n & ( n - 1 ) ) == 0 ) ) { return true ; } return false ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] a = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] minprice = new int [ n ] ; minprice [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minprice [ i ] = Math . min ( minprice [ i - 1 ] , a [ i ] ) ; } int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { c += a [ i ] > minprice [ i ] ? 1 : 0 ; } System . out . println ( c ) ; }
static final String compute ( ) { final int LIMIT = 10 * 8 - 1 ; long ans = 0 ; List < Integer > primes = EulerUtil . listPrimes ( LIMIT / 2 ) ; final long sqrt = EulerUtil . sqrt ( LIMIT ) ; Iterator < Integer > it = primes . iterator ( ) ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( it . next ( ) > sqrt ) break ; int end = binarySearch ( primes , LIMIT / i ) ; ans += ( end >= 0 ? end + 1 : - end - 1 ) - i ; } return Long . toString ( ans ) ; /* ▁ binary ▁ search ▁ */ int start = 0 ; int end = primes . size ( ) ; while ( start < end ) { int mid = ( start + end ) / 2 ; if ( it . next ( ) < it . next ( ) ) end = mid ; else if ( it . next ( ) > it . next ( ) ) start = mid + 1 ; else if ( it . next ( ) == it . next ( ) ) return mid ; else throw new AssertionError ( ) ; } /* ▁ binary ▁ search ▁ */ if ( __name__ . equals ( " java . util . List " ) ) System . out . println ( compute ( ) ) ; return null ; }
public static int M = 20 ; int dp [ ] [ ] [ ] = new int [ M ] [ M ] ; int d = 0 , K = 0 ; int count ; int pos = 0 ; int cnt = 0 ; int tight = 0 ; int nonz = 0 ; int [ ] [ ] num = new int [ M ] [ M ] ; int currTight = 0 ; int cnt = 0 ; int currCnt = 0 ; int nonz = 0 ; int [ ] [ ] num = new int [ N ] [ N ] ; if ( pos == num . length ) { if ( cnt == K ) return 1 ; return 0 ; } if ( dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 ) return dp [ pos ] [ cnt ] [ tight ] [ nonz ] ; ans = 0 ; int limit = tight ? 9 : num [ pos ] ; for ( int dig = 0 ; dig < limit + 1 ; dig ++ ) { currCnt = cnt ; if ( dig == d ) { if ( d != 0 || ! d && nonz != 0 ) currCnt ++ ; } currTight = tight ; if ( dig < num [ pos ] ) currTight = 1 ; ans += count ( pos + 1 , currCnt , currTight , ( nonz == 0 || dig != 0 ) , num ) ; } dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans ; return dp [ pos ] [ cnt ] [ tight ] [ nonz ] ; }
public static int input ( ) { String ip = input ( ) ; String st = " " ; if ( ip . length ( ) != 1 ) { if ( ip . charAt ( 0 ) == '9' ) { st = "9" ; ip = ip . substring ( 1 ) ; } for ( int i = 0 ; i < ip . length ( ) ; i ++ ) { if ( Integer . parseInt ( ip ) > 4 ) { } } } return st . length ( ) ; }
static boolean isPeak ( int arr [ ] , int n , int num , int i , int j ) { if ( ( i >= 0 ) && ( arr [ i ] > num ) ) return false ; if ( ( j < n ) && ( arr [ j ] > num ) ) return false ; return true ; }
static int index ( int i ) { return 1 + ( i > > 31 ) - ( - i > > 31 ) ; }
public static int frequency ( int [ ] a , int x ) { int count = 0 ; for ( int i : a ) { if ( i == x ) count ++ ; } return count ; }
static boolean isNumBalanced ( int N ) { String st = Integer . toString ( N ) ; boolean isBalanced = true ; int [ ] freq = new int [ 10 ] ; int n = st . length ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { freq [ Integer . parseInt ( st . substring ( i , i + 1 ) ) ] ++ ; } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( freq [ i ] != freq [ i + 1 ] ) { isBalanced = false ; } } if ( isBalanced ) { return true ; } else { return false ; } }
@ VisibleForTesting static boolean isPrime ( int n ) { if ( ( n <= 1 ) && ( n <= 3 ) ) { return false ; } if ( ( n % 2 == 0 ) || ( n % 3 == 0 ) ) { return false ; } int k = ( int ) ( Math . sqrt ( n ) ) + 1 ; for ( int i = 5 ; i <= k ; i += 6 ) { if ( ( n % i == 0 ) || ( n % ( i + 2 ) == 0 ) ) { return false ; } } return true ; }
public static String compute ( ) { long numer = 1 ; long denom = 0 ; for ( int i = 0 ; i < 100 ; i ++ ) { numer = eContFracTerm ( i ) * numer + denom ; denom = numer ; } long ans = Long . parseLong ( String . valueOf ( numer ) ) ; return String . valueOf ( ans ) ; /* ▁ eContFracTerm ( i ) ▁ = ▁ 2 ; STRNEWLINE ▁ if ▁ ( i ▁ % ▁ 3 ▁ = = ▁ 2 ) ▁ { STRNEWLINE ▁ return ▁ i / 3 * 2 + 2 ; STRNEWLINE ▁ } ▁ else ▁ { STRNEWLINE ▁ return ▁ 1 ; STRNEWLINE ▁ } */ }
@ VisibleForTesting static int findDivisible ( int n , int x , int y , int z ) { final int ans = ( int ) ( ( x * y ) / ( gcd ( x , y ) ) ) ; return ( int ) ( ( z * ans ) / ( gcd ( ans , z ) ) ) ; /* ▁ find ▁ the ▁ divisible ▁ number ▁ */ final int lcm = gcd ( x , y , z ) ; double ndigitnumber = Math . pow ( 10 , n - 1 ) ; final double reminder = ndigitnumber % lcm ; if ( reminder == 0 ) { return ndigitnumber ; } ndigitnumber += lcm - reminder ; if ( ndigitnumber < Math . pow ( 10 , n ) ) { return ( int ) ndigitnumber ; } else { return 0 ; } }
@ VisibleForTesting static void setPrime ( int a , int b ) { boolean prime [ ] = new boolean [ 100001 ] ; { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p <= ( int ) Math . sqrt ( 100001 ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 100001 ; i += p ) { prime [ i ] = false ; } } } } private static void commonPrime ( int a , int b ) { int __gcd = gcd ( a , b ) ; for ( int i = 2 ; i <= __gcd ; i ++ ) { if ( prime [ i ] && __gcd % i == 0 ) { System . out . print ( i + " ▁ " ) ; } } } if ( Class . isPrimitive ( ) ) { SieveOfEratosthenes ( ) ; int a = 6 , b = 12 ; commonPrime ( a , b ) ; } }
@ VisibleForTesting static void from ( Operator operator ) { double mInf = Double . NEGATIVE_INFINITY ; int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] phrase = new int [ 394 ] ; for ( int s = 0 , l = 0 , p = 0 ; l < n ; ++ s ) phrase [ s ] = 0 ; for ( int i = 0 , p = 0 ; i < l ; ++ i , ++ p ) phrase [ i ] = phrase [ s ] > p ? phrase [ p ] : p ; int [ ] dp = new int [ 393 ] ; dp [ 0 ] = mInf ; for ( int length = 0 , p = 0 ; length < phrase . length ; ++ length ) dp [ length ] = phrase [ length ] ; for ( int from = 0 , to = 0 , to = length ; to < dp . length ; ++ to ) dp [ to ] = to >= from + p ? to : from + p ; int [ ] result = new int [ length ] ; for ( int i = 0 ; i < result . length ; ++ i ) result [ i ] = dp [ i ] ; System . out . println ( ( result [ m_inf ] != mInf ? result [ - 1 ] : result [ 0 ] ) + " \n " ) ; }
@ VisibleForTesting static void print ( Scanner scanner ) { final String input = scanner . nextLine ( ) ; final int N = Integer . parseInt ( input ) ; final List < Integer > [ ] adj = new ArrayList [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) adj [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = Integer . parseInt ( scanner . nextLine ( ) ) ; int b = Integer . parseInt ( scanner . nextLine ( ) ) ; adj [ a ] . add ( b ) ; adj [ b ] . add ( a ) ; } Queue < Integer > que = new LinkedList < > ( ) ; que . add ( 1 ) ; final int [ ] seen = new int [ N + 1 ] ; seen [ 1 ] = 1 ; seen [ 2 ] = 1 ; int [ ] par = new int [ N + 1 ] ; par [ 0 ] = 0 ; int [ ] childNum = new int [ N + 1 ] ; while ( que . size ( ) > 0 ) { int v = que . poll ( ) ; for ( int i = 0 ; i < adj [ v ] ; i ++ ) { int u = adj [ v ] ; if ( seen [ u ] == 0 ) { seen [ u ] = 1 ; par [ u ] = v ; childNum [ v ] ++ ] -- ; que . add ( u ) ; } } } System . out . println ( " Second " ) ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; int [ ] [ ] arr = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] temp = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { temp [ j ] = Integer . parseInt ( input ) ; } arr [ i ] = temp ; } String res = " YES " ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { try { int count = arr [ i + 1 ] [ j ] + arr [ i ] [ j + 1 ] + arr [ i + 1 ] [ j + 1 ] + arr [ i ] [ j ] ; if ( count == 3 ) { res = " NO " ; } } catch ( Exception e ) { } } } System . out . println ( res ) ; }
public static int n ( ) { int k = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > pwList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) pwList . add ( input . nextLine ( ) ) ; int pw = input . length ( ) ; List < Integer > p = new ArrayList < Integer > ( pwList ) ; int head = p . indexOf ( pw ) ; int tail = n - 1 ; int worstCase = head + ( ( head ) / k ) * 5 + 1 ; int bestCase = tail + ( tail / k ) * 5 + 1 ; return worstCase ; }
public static String input ( ) { String n = input . replace ( " ; " , " " ) . replace ( " - " , " " ) . replace ( " _ " , " " ) . toLowerCase ( ) ; String p = input . replace ( " ; " , " " ) . replace ( " - " , " " ) . replace ( " _ " , " " ) . toLowerCase ( ) ; String c = input . replace ( " ; " , " " ) . replace ( " - " , " " ) . replace ( " _ " , " " ) . toLowerCase ( ) ; String [ ] z = { n + p + c , n + c + p , c + n + p , c + p + n , p + c + n , p + n + c } ; for ( int i = 0 ; i < Integer . parseInt ( input . replace ( " ; " , " " ) . replace ( " - " , " " ) . replace ( " _ " , " " ) . toLowerCase ( ) ) ; i ++ ) { String q = input . replace ( " ; " , " " ) . replace ( " - " , " " ) . replace ( " _ " , " " ) . toLowerCase ( ) ; if ( z [ i ] . contains ( q ) ) System . out . println ( " ACC " ) ; else System . out . println ( " WA " ) ; } return n ; }
public static int T = Integer . parseInt ( input ) { for ( int testCase = 1 ; testCase <= T ; testCase ++ ) { int N = ( Integer . parseInt ( input . nextLine ( ) ) ) ; int L = ( Integer . parseInt ( input . nextLine ( ) ) ) ; Set < Integer > a = new TreeSet < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { a . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } Set < Integer > b = new TreeSet < > ( ) ; for ( int i = 0 ; i < L ; i ++ ) { b . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } int ans = L + 1 ; for ( int i = 0 ; i < b . size ( ) ; i ++ ) { if ( new TreeSet < > ( a . get ( 0 ) ^ b . get ( i ) ) . equals ( b ) ) { ans = Math . min ( ans , Integer . valueOf ( a . get ( 0 ) ^ b . get ( i ) ) . intValue ( ) ) ; } } if ( ans == L + 1 ) { ans = " NOT ▁ POSSIBLE " ; } System . out . println ( " Case ▁ # " + testCase + " : ▁ " + ans ) ; } return T ; }
public static Solution < Integer > createSolution ( ) { /* ▁ max ▁ area ▁ of ▁ land ▁ */ int ans = 0 ; for ( int i = 0 ; i < grid . length ; i ++ ) { for ( int j = 0 ; j < grid [ 0 ] . length ; j ++ ) { if ( grid [ i ] [ j ] == 1 ) { grid [ i ] [ j ] = 0 ; ans = Math . max ( dfs ( grid , i , j ) , ans ) ; } } } /* ▁ dfs ▁ the ▁ grid ▁ */ List < Integer > stack = new ArrayList < Integer > ( ) ; stack . add ( new Integer ( i ) ) ; stack . add ( new Integer ( j ) ) ; int area = 0 ; while ( stack . size ( ) > 0 ) { int r = stack . remove ( stack . size ( ) - 1 ) ; int c = stack . remove ( stack . size ( ) - 1 ) ; area ++ ; for ( int nr = ( r - 1 ) , nc = ( r + 1 ) ; nc > 0 ; nc -- ) { if ( ( 0 <= nr && nr < grid . length ) && ( 0 <= nc && nc < grid [ 0 ] . length ) && grid [ nr ] [ nc ] != 0 ) { stack . add ( new Integer ( nr ) ) ; grid [ nr ] [ nc ] = 0 ; } } } /* ▁ if ▁ ( Class . isCompatible ( Solution . class ) ) ▁ { STRNEWLINE ▁ Solution ▁ sObj ▁ = ▁ new ▁ Solution ( ) ; STRNEWLINE ▁ int [ ] ▁ grid ▁ = ▁ { 0 , ▁ 1 , ▁ 0 , ▁ 0 , ▁ 0 , ▁ 1 , ▁ 0 , ▁ 0 , ▁ 0 , ▁ 0 } ; STRNEWLINE ▁ int [ ] ▁ out ▁ = ▁ sObj . maxAreaOfIsland ( grid ) ; STRNEWLINE ▁ System . out . println ( out ) ; STRNEWLINE ▁ } */ int out = 0 ; for ( int i = 0 ; i < grid . length ; i ++ ) { out = out ; } return new Solution < Integer > ( ) ; }
public static int sum ( int x , int y , int n ) { int sum1 = ( ( x * x ) * ( x * ( 2 * n ) - 1 ) ) / ( x * x - 1 ) ; int sum2 = ( x * y * ( x * n * y * n - 1 ) ) / ( x * y - 1 ) ; return ( sum1 + sum2 ) ; }
static int findSum ( int n ) { n -- ; long sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return ( int ) sum ; }
static int getSum ( int n ) { int sum = 0 ; while ( ( n != 0 ) && ( n != 0 ) ) { sum = sum + ( int ) ( n % 10 ) ; n = ( int ) ( n / 10 ) ; } return sum ; }
static int getSum ( int n ) { int sum = 0 ; while ( ( n > 0 ) && ( n < 10 ) ) { sum += ( int ) ( n % 10 ) ; n = ( int ) ( n / 10 ) ; } return sum ; }
static final Node < Integer > EMPTY = new Node < Integer > ( ) { private int data ; private int next ; public Node < Integer > next ( ) { this . data = data ; this . next = null ; } public Node < Integer > push ( Node < Integer > headRef , Integer newData ) { Node < Integer > newNode = new Node < Integer > ( newData ) ; newNode . data = newData ; newNode . next = headRef ; headRef = newNode ; return headRef ; } public boolean isPrime ( int n ) { if ( ( n <= 1 ) && ( n <= 3 ) ) return false ; if ( ( n % 2 == 0 ) || ( n % 3 == 0 ) ) return false ; for ( int i = 5 ; i <= n ; i += 6 ) { if ( ( i * i < n + 2 ) && ( ( n % i == 0 ) || ( n % ( i + 2 ) == 0 ) ) ) return false ; } return true ; } public Node < Integer > deleteNonPrimeNodes ( Node < Integer > headRef ) { Node < Integer > ptr = headRef ; while ( ( ptr != null ) && isPrime ( ptr . data ) != true ) { Node < Integer > temp = ptr ; ptr = ptr . next ; } headRef = ptr ; if ( ( ptr == null ) || ( ptr . data == null ) ) return null ; Node < Integer > curr = ptr . next ; while ( ( curr != null ) && ( isPrime ( curr . data ) != true ) ) { ptr . next = curr . next ; curr = ptr . next ; } else { ptr = curr ; curr = curr . next ; } return headRef ; } public void printList ( Node < Integer > head ) { while ( ( head != null ) && ( head . data != null ) ) { System . out . print ( head . data + " ▁ " ) ; head = head . next ; } } public String toString ( ) { if ( className == " java . util . LinkedList " ) { head = null ; head = push ( head , 17 ) ; head = push ( head , 7 ) ; head = push ( head , 6 ) ; head = push ( head , 16 ) ; head = push ( head , 15 ) ; System . out . println ( " Original ▁ List : ▁ " ) ; printList ( head ) ; head = deleteNonPrimeNodes ( head ) ; System . out
public static int [ ] [ ] [ ] createdp ( ) { int N = Integer . parseInt ( input . readLine ( ) ) ; int M = Integer . parseInt ( input . readLine ( ) ) ; int L = Integer . parseInt ( input . readLine ( ) ) ; ArrayList < ArrayList < Integer > > [ ] tbl = new ArrayList [ 45 ] ; for ( int i = 0 ; i < M ; i ++ ) { int d = Integer . parseInt ( input . readLine ( ) ) ; int a = Integer . parseInt ( input . readLine ( ) ) ; int k = Integer . parseInt ( input . readLine ( ) ) ; int t = Integer . parseInt ( input . readLine ( ) ) ; tbl [ d * N + a - 1 ] [ i ] = new ArrayList < Integer > ( ) ; tbl [ d ] [ a ] = new ArrayList < Integer > ( ) ; tbl [ d ] [ a ] . add ( new Integer ( k ) ) ; tbl [ d ] [ a ] . add ( t ) ; } int [ ] [ ] [ ] dp = new int [ 5 * N ] [ L ] ; for ( int da = 0 ; da < 5 * N ; da ++ ) { for ( int i = 0 ; i < L ; i ++ ) { dp [ da ] [ i ] [ j ] = tbl [ da ] [ i ] ; } } for ( int da = 0 ; da < 5 * N ; da ++ ) { for ( int i = 0 ; i < L ; i ++ ) { dp [ da ] [ i ] [ j ] = tbl [ da ] [ i ] ; } } return dp ; }
private static void print ( String input ) { int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; char [ ] [ ] b = new char [ n ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] [ 0 ] = new char [ ] { ' W ' , 1 } ; } b [ 0 ] [ 0 ] = new char [ ] { ' R ' , 1 } ; for ( int i = 0 ; i < m ; i ++ ) { int x = Integer . parseInt ( input ) ; int y = Integer . parseInt ( input ) ; b [ x - 1 ] [ 1 ] -- ; if ( b [ x - 1 ] [ 0 ] == ' R ' ) { b [ y - 1 ] [ 0 ] = ' R ' ; if ( b [ y - 1 ] [ 1 ] == 0 ) b [ x - 1 ] [ 0 ] = ' W ' ; } else b [ y - 1 ] [ 1 ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] [ 0 ] == ' R ' ) cnt ++ ; } System . out . println ( cnt ) ; }
public static int H = Integer . parseInt ( input ) { int W = Integer . parseInt ( input . nextLine ( ) ) ; String s [ ] [ ] = new String [ H ] [ W ] ; for ( int k = 0 ; k < H ; k ++ ) { s [ k ] [ l ] = input . nextLine ( ) ; } ArrayList < int [ ] > B = new ArrayList < int [ ] > ( ) ; for ( int k = 0 ; k < H ; k ++ ) { for ( int l = 0 ; l < W ; l ++ ) { if ( s [ k ] [ l ] . equals ( " B " ) ) B . add ( new int [ ] { k , l } ) ; } } int ans = 0 ; for ( int [ ] e : B ) { for ( int [ ] f : B ) ans = Math . max ( ans , Math . abs ( e [ 0 ] - f [ 0 ] ) + Math . abs ( e [ 1 ] - f [ 1 ] ) ) ; } System . out . println ( ans ) ; return ans ; }
static void minReplacement ( String string ) { if ( string . length ( ) > 26 ) { System . out . println ( " IMPOSSIBLE " ) ; } else { int [ ] Hash = new int [ 26 ] ; for ( int i = 0 ; i != string . length ( ) ; ++ i ) { Hash [ ( string . charAt ( i ) - ' a ' ) ] ++ ; } int count = 0 ; for ( int i = 0 ; i != string . length ( ) ; ++ i ) { if ( Hash [ ( string . charAt ( i ) - ' a ' ) ] > 1 ) { for ( int j = 0 ; j != 26 ; ++ j ) { if ( Hash [ j ] == 0 ) { Hash [ ( string . charAt ( i ) - ' a ' ) ] -- ; string . charAt ( i ) = ( char ) ( j + ' a ' ) ; ++ Hash [ j ] ; break ; } } } } System . out . println ( new String ( string ) ) ; } if ( getClass ( ) . equals ( " java . lang . String " ) ) { string = " xxxxyyyy " ; minReplacement ( new LinkedList < String > ( string ) ) ; } }
public static int longestSubseq ( String s ) { int n = s . length ( ) ; int [ ] preCount0 = new int [ n + 2 ] ; int [ ] preCount1 = new int [ n + 1 ] ; int [ ] postCount0 = new int [ n + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { preCount0 [ i ] = 0 ; preCount1 [ i ] = 0 ; } for ( int i = 0 ; i < n + 1 ; i ++ ) { preCount0 [ i ] = 0 ; postCount0 [ i + 1 ] = 0 ; preCount1 [ i ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { preCount0 [ j ] = preCount0 [ j - 1 ] ; preCount1 [ j ] = preCount1 [ j - 1 ] ; postCount0 [ n - j + 1 ] = postCount0 [ n - j + 2 ] ; if ( ( s . charAt ( j - 1 ) == '0' ) && ( s . charAt ( j ) == '0' ) ) { preCount0 [ j ] ++ ; } else { preCount1 [ j ] ++ ; } if ( ( s . charAt ( n - j ) == '0' ) && ( s . charAt ( j ) == '0' ) ) { postCount0 [ n - j + 1 ] ++ ; } } if ( ( preCount0 [ n ] == n ) || ( preCount0 [ n ] == 0 ) ) { return n ; } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j += 1 ) { ans = Math . max ( preCount0 [ i - 1 ] + preCount1 [ j ] - preCount1 [ i - 1 ] + postCount0 [ j + 1 ] , ans ) ; } } return ans ; } if ( className . equals ( " java . lang . String " ) ) { s = "000011100000" ; System . out . println ( longestSubseq ( s ) ) ; } return 0 ; }
public static void sieveOfEratosthenes ( int N , int [ ] s ) { boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 2 ; i <= N ; i += 2 ) { s [ i ] = 2 ; } for ( int i = 3 ; i <= N ; i += 2 ) { if ( ( prime [ i ] = false ) == false ) { s [ i ] = i ; for ( int j = i ; j <= ( int ) ( N / i ) ; j += 2 ) { if ( ( prime [ i * j ] = false ) == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
static int longestSubarray ( int [ ] a , int n ) { final int [ ] [ ] hash = new int [ 10 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ i ] [ 0 ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( ( num = a [ i ] ) != 0 ) { hash [ i ] [ num % 10 ] = 1 ; num = ( int ) ( num / 10 ) ; } } int longest = - Integer . MAX_VALUE - 1 ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( ( hash [ i ] [ j ] != 0 ) && ( hash [ i + 1 ] [ j ] != 0 ) ) { count ++ ; break ; } } if ( ( j == 10 ) && ( hash [ i ] [ j ] != 0 ) ) { longest = Math . max ( longest , count + 1 ) ; count = 0 ; } } longest = Math . max ( longest , count + 1 ) ; return longest ; }
public static int t = Integer . parseInt ( input ) { for ( int i = 0 ; i < t ; i ++ ) { int a = Integer . parseInt ( input . readLine ( ) ) ; int b = Integer . parseInt ( input . readLine ( ) ) ; int c = Integer . parseInt ( input . readLine ( ) ) ; System . out . println ( ( a + b + c ) / 2 ) ; } return t ; }
public static Vector < Integer > Divisors ( int x ) { int c = 0 ; Vector < Integer > v = new Vector < Integer > ( ) ; while ( ( x % 2 ) == 0 ) { c ++ ; x /= 2 ; } v . add ( c ) ; c = 0 ; while ( ( x % 3 ) == 0 ) { c ++ ; x /= 3 ; } v . add ( c ) ; c = 0 ; while ( ( x % 7 ) == 0 ) { c ++ ; x /= 7 ; } v . add ( c ) ; v . add ( x ) ; return v ; }
public static void N = 1000001 ; int c = 0 ; int n = 0 ; int m = 0 ; int a = 0 ; int b = 0 ; { int i ; int ans1 ; int [ ] edges ; int [ ] edges ; int [ ] edges ; int [ ] v ; int i ; int a = 0 ; int b = 0 ; { int [ ] edges ; vis = new int [ n + 1 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( ( vis [ i ] == 0 ) && ( i != b ) ) { dfs ( i , b , v , vis ) ; } } } { int [ ] v ; vis = new int [ n + 1 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( ( vis [ i ] == 0 ) && ( i != b ) ) { dfs ( i , b , v , vis ) ; } } } { int [ ] v ; int [ ] [ ] = new int [ n + 1 ] ; for ( i = 0 ; i < n ; i ++ ) { v = new int [ n + 1 ] [ i ] ; } c = 0 ; dfs ( a , b , v , vis ) ; int ans1 = n - c - 1 ; vis = new int [ vis . length ] ; for ( i = 0 ; i < vis . length ; i ++ ) { vis [ i ] = 0 ; } c = 0 ; dfs ( b , a , v , vis ) ; int ans2 = n - c - 1 ; System . out . println ( ans1 * ans2 ) ; } if ( __name__ == null ) { n = 7 ; m = 7 ; a = 3 ; b = 5 ; edges = new int [ n + 1 ] ; edges [ 0 ] = new int [ m + 1 ] ; edges [ 1 ] = new int [ n + 1 ] ; edges [ 2 ] = new int [ n + 1 ] ; edges [ 3 ] = new int [ n + 1 ] ; edges [ 4 ] = new int [ n + 1 ] ; edges [ 5 ] = new int [ n + 1 ] ; edges [ 6 ] = new int [ n + 1 ] ; edges [ 5 ] = new int [ n + 1 ] ; edges [ 6 ] = new int [ n + 1 ] ; edges [ 7 ] = new int [ n + 1 ] ; v = new
public static int l ( int n ) { return Integer . toString ( n ) . length ( ) ; /* ▁ el ▁ */ int el = Integer . parseInt ( Integer . toString ( n ) . substring ( 1 ) ) ; /* ▁ first ▁ */ int first = Integer . parseInt ( Integer . toString ( n ) . substring ( 0 ) ) ; /* ▁ maxima ▁ */ if ( l == 1 ) { return n ; } else { return max ( 9 * ( l - 1 ) , first ) ; } }
public static void main ( String input ) { int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; int x = a ; int h = 0 ; int s = 0 ; while ( x > 0 ) { x -- ; h ++ ; s ++ ; } while ( s / b != 0 ) { h ++ ; s = s - b + 1 ; } System . out . println ( h ) ; }
static int getSum ( int n ) { final int sm = 0 ; while ( ( n != 0 ) && ( n % 10 != 0 ) ) { sm = sm + n % 10 ; n = n / 10 ; } return sm ; }
public static int [ ] getDigits ( ) { int l = Integer . parseInt ( input . nextLine ( ) ) , r = Integer . parseInt ( input . nextLine ( ) ) ; int curr = r ; int s = 0 ; while ( curr > 0 ) { s ++ ; curr /= 10 ; } int first = 10 * s ; int second = first / 2 ; int ans = - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( i >= l && i <= r ) { curr = i ; String rev = " " ; for ( int k = Integer . parseInt ( curr ) ; k < 10 ; k ++ ) { rev += Integer . toString ( 9 - Integer . parseInt ( curr ) ) ; } ans = Math . max ( ans , Integer . parseInt ( rev ) * curr ) ; } } return ans ; }
public static int N = Integer . parseInt ( input ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] l = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { l [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } for ( int i = 0 ; i < N ; i ++ ) { int t = l [ i ] ; int j = i - 1 ; while ( j >= 0 && l [ j ] > t ) { l [ j + 1 ] = l [ j ] ; j -- ; } System . out . println ( ( int ) l [ i ] ) ; } return N ; }
static public boolean isPerfectSquare ( double x ) { final double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
public static String data = """ \ STRNEWLINE 111111101010101111100101001111111 STRNEWLINE 100000100000000001010110001000001 STRNEWLINE 101110100110110000011010001011101 STRNEWLINE 101110101011001001111101001011101 STRNEWLINE 10111010110001100011000111100101011101 STRNEWLINE 1000001010101010101011010000101000001 STRNEWLINE 111111101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
@ VisibleForTesting static Iterable < Integer > iterable ( ) { for ( int i = 0 ; i < Integer . parseInt ( input . nextLine ( ) ) ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int count = 0 ; int start = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { start = i ; while ( ( start <= n ) && ( start <= n ) ) { count ++ ; start = start * 10 + i ; } } System . out . println ( count ) ; } return new Iterable < > ( ) ; }
static final public int divSum ( int n ) { int sum = 1 ; int i = 2 ; while ( ( i * i <= n ) && ( n % i == 0 ) ) { sum = ( sum + i + Math . floor ( n / i ) ) ; } i ++ ; return sum ; }
static int findY ( int x ) { if ( ( x > 2 ) && ( x < 2 ) ) { return x - 2 ; } return x + 2 ; }
static final long MOD = 1000000007 ; long modFact ( long n , long m ) { long result = 1 ; for ( long i = 1 ; i <= m ; i ++ ) { result = ( result * i ) % MOD ; } return result ; }
public static void print ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int m = i ; for ( int j = i ; j < n ; j ++ ) if ( a [ m ] > a [ j ] ) m = j ; if ( i != m ) a [ m ] = a [ i ] ; c ++ ; } System . arraycopy ( a , 0 , a , 0 , n ) ; System . out . println ( c ) ; }
static final int [ ] [ ] resize ( int W , int H ) { System . setSecurityManager ( new SecurityManager ( ) ) ; int W = Integer . parseInt ( input . nextLine ( ) ) ; int H = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] [ ] m = new int [ H ] [ W ] ; for ( int i = 0 ; i < H ; i ++ ) m [ i ] = new int [ H ] [ ] ; for ( int i = 0 ; i < H ; i ++ ) m [ i ] [ 0 ] = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] [ ] dx = { { 1 , 1 , 1 , 0 , - 1 , 0 } , { 0 , 1 , 0 , - 1 , - 1 , - 1 } } ; int [ ] dy = { - 1 , 0 , 1 , 1 , 0 , - 1 } ; /* ▁ do ▁ nothing ▁ */ if ( m [ y ] [ x ] != 0 ) return null ; m [ y ] [ x ] = 2 ; for ( int xx = 0 , yy = dx [ y % 2 ] ; xx < W ; xx ++ ) { int tx = x + xx ; int ty = y + yy ; if ( 0 <= tx && tx < W && 0 <= ty && ty < H ) { /* ▁ do ▁ nothing ▁ */ } } for ( int x = 0 ; x < W ; x ++ ) { /* ▁ do ▁ nothing ▁ */ } for ( int y = 0 ; y < H ; y ++ ) { /* ▁ do ▁ nothing ▁ */ } /* ▁ do ▁ nothing ▁ */ for ( int x = 0 ; x < W ; x ++ ) { if ( m [ y ] [ x ] != 1 ) continue ; int fn = n ; for ( int xx = 0 , yy = dx [ y % 2 ] ; xx < H ; yy ++ ) { int tx = x + xx ; int ty = y + yy ; if ( 0 <= tx && ty < W && 0 <= ty && ty < H ) { if ( m [ ty ] [ tx ] == 2 ) n ++ ; } else n ++ ; } } System . out . println ( n ) ; return m ; }
@ Sys public static void main ( String [ ] args ) { int n = Integer . parseInt ( stdin . readLine ( ) ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( stdin . readLine ( ) ) ; } int [ ] [ ] ans = new int [ n ] [ n ] ; ans [ 0 ] = new int [ n ] ; ans [ 0 ] [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int l = 0 ; int r = ans . length - 1 ; while ( r > l ) { r = r + 1 ; } ans [ i ] [ i ] = ans [ i ] ; } }
public static double circleArea ( int a , int b ) { if ( ( a < 0 ) || ( b < 0 ) ) { return - 1 ; } double A = ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; }
@ Produces static String find ( List < Integer > list , int n ) { return list . stream ( ) . filter ( list :: contains ) . map ( list :: get ) . collect ( toList ( ) ) ; }
public static String K_String ( String s , int k ) { int n = s . length ( ) ; int [ ] fre = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { fre [ ( s . charAt ( i ) - ' a ' ) ] ++ ; } String str = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( ( fre [ i ] % k ) == 0 ) { int x = fre [ i ] / k ; while ( ( x > 0 ) && ( str . charAt ( x ) == ' a ' ) ) { str += ( char ) ( i + ' a ' ) ; x -- ; } } else { return " - 1" ; } } if ( getClass ( ) . equals ( " java . lang . String " ) ) { s = " aabb " ; k = 2 ; System . out . println ( K_String ( s , k ) ) ; } return str ; }
static double [ ] dp = new double [ 100001 ] ; dp [ 1 ] = 1. ; for ( int i = 2 ; i < 100001 ; i ++ ) { double a = .5 , b = 1 , j = 1 ; while ( j < i && b > 1e-15 ) { dp [ i ] += b * ( 1 - a ) * ( j + dp [ i - j - 1 ] ) ; b *= a ; a /= 2 ; j ++ ; } dp [ i ] += i * b ; } while ( true ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == 0 ) break ; System . out . println ( dp [ n ] ) ; }
static final Scanner scanner = new Scanner ( System . in ) { for ( String l : System . in ) { int a = Integer . parseInt ( l ) ; int b = Integer . parseInt ( l ) ; int n = Integer . parseInt ( l ) ; System . out . println ( Arrays . stream ( Lists . newArrayList ( String . valueOf ( ( a % b ) * 10 ** n / b ) ) ) . collect ( Collectors . joining ( ) ) ) ; } return new Scanner ( System . in ) ; }
public static int N = Integer . parseInt ( input ) { int [ ] A = new int [ N ] ; for ( String a : input . split ( " ▁ " ) ) { A [ i ] = Integer . parseInt ( a ) ; } /* ▁ if ▁ k ▁ = = ▁ 1 ▁ */ if ( k == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] <= A [ i - 1 ] ) return 0 ; } return 1 ; } ArrayList < Integer > X = new ArrayList < Integer > ( ) ; X . add ( new Integer ( 0 ) ) ; /* ▁ add ▁ the ▁ first ▁ element ▁ to ▁ the ▁ list ▁ */ if ( X . size ( ) <= 0 ) return 0 ; if ( X . get ( X . size ( ) - 1 ) . intValue ( ) > 0 ) X . add ( new Integer ( X . get ( X . size ( ) - 1 ) . intValue ( ) ) ) ; else if ( X . get ( X . size ( ) - 1 ) . intValue ( ) == 0 ) { if ( X . get ( X . size ( ) - 1 ) . intValue ( ) + 1 < k ) X . set ( X . get ( X . size ( ) - 1 ) . intValue ( ) , X . get ( X . size ( ) - 1 ) . intValue ( ) + 1 ) ; else if ( add ( X . get ( X . size ( ) - 1 ) . intValue ( ) , X . get ( X . size ( ) - 1 ) . intValue ( ) ) == 0 ) return 0 ; } else { while ( X . get ( X . size ( ) - 1 ) . intValue ( ) > X . size ( ) ) X . remove ( X . size ( ) - 1 ) ; if ( X . get ( X . size ( ) - 1 ) . intValue ( ) > 0 ) X . add ( new Integer ( X . get ( X . size ( ) - 1 ) . intValue ( ) ) ) ; return 1 ; } for ( int a : A ) { if ( add ( a , a ) == 0 ) return 0 ; } int l = 0 , r = 1 << 18 ; while ( r - l > 1 ) { int m = ( l + r ) / 2 ; if ( chk ( m ) ) r = m ; else l = m ; } System . out . println (
public static void main ( ) { int n = Integer . parseInt ( input . readLine ( ) ) ; int k = Integer . parseInt ( input . readLine ( ) ) ; if ( n == k == 0 ) { break ; } int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = Integer . parseInt ( input . readLine ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { int [ ] b = new int [ k ] ; for ( int j = 0 ; j < k ; j ++ ) { b [ j ] = Integer . parseInt ( input . readLine ( ) ) ; } for ( int j = 0 ; j < k ; j ++ ) { s [ j ] -= b [ j ] ; } } System . out . println ( min ( s ) >= 0 ? " Yes " : " No " ) ; }
static int maxFreq ( String s , int a , int b ) { int [ ] fre = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { fre [ i ] = 0 ; } int n = s . length ( ) ; if ( ( a > b ) && ( a < b ) ) { swap ( a , b ) ; } for ( int i = 0 ; i < n ; i += 1 ) { a = ( s . charAt ( i ) - '0' ) ; fre [ a ] ++ ; } if ( ( fre [ a ] == 0 ) && ( fre [ b ] == 0 ) ) { return - 1 ; } else if ( ( fre [ a ] >= fre [ b ] ) && ( fre [ b ] <= 0 ) ) { return a ; } else { return b ; } if ( getClass ( ) . getName ( ) . equals ( " java . lang . String " ) ) { a = 4 ; b = 7 ; s = "47744" ; System . out . println ( maxFreq ( s , a , b ) ) ; } return 0 ; }
static int maxZeros ( int n ) { if ( ( n == 0 ) || ( ( n & ( n - 1 ) ) == 0 ) ) { return - 1 ; } int setBit = 1 ; int prev = 0 ; int i = 1 ; while ( ( i < 33 ) && ( prev < n ) ) { prev ++ ; if ( ( ( n & setBit ) == setBit ) ) { setBit = setBit << 1 ; break ; } setBit = setBit << 1 ; } int max0 = - 10 * 9 ; int cur = prev ; for ( int j = i + 1 ; j < 33 ; j ++ ) { cur ++ ; if ( ( ( n & setBit ) == setBit ) ) { if ( ( max0 < ( cur - prev - 1 ) ) && ( max0 < ( cur - prev ) ) ) { max0 = cur - prev - 1 ; } prev = cur ; } setBit = setBit << 1 ; } return max0 ; }
static int sumPowersK ( int n , int k ) { int sum = 0 ; int num = 1 ; while ( ( num = sumPowersK ( n , k ) ) <= n ) { sum += num ; num *= k ; } return sum ; /* ▁ Sum ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the ▁ numbers ▁ of ▁ the
public static double [ ] XandYandZintercept ( double A , double B , double C , double D ) { double x = - D / A ; double y = - D / B ; double z = - D / C ; return new double [ ] { x , y , z } ; }
static void maxSum ( int [ ] arr , int n ) { int s = 0 ; ArrayList < Integer > l = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { s += Math . abs ( a [ i ] ) ; if ( ( i >= 0 ) && ( i < n ) ) continue ; if ( ( i == 0 ) ) l . add ( i + 1 ) ; } }
static int replaceSpaces ( String string ) { string = string . trim ( ) ; int i = string . length ( ) ; int spaceCount = string . indexOf ( ' ▁ ' ) ; int newLength = i + spaceCount * 2 ; if ( newLength > MAX ) { return - 1 ; } int index = newLength - 1 ; StringBuilder sb = new StringBuilder ( string ) ; for ( int f = i - 2 ; f <= newLength - 2 ; f ++ ) { sb . append ( '0' ) ; } for ( int j = i - 1 ; j > 0 ; j -- ) { if ( sb . charAt ( j ) == ' ▁ ' ) { sb . setCharAt ( index , '0' ) ; sb . setCharAt ( index - 1 , '2' ) ; sb . setCharAt ( index - 2 , ' % ' ) ; index = index - 3 ; } else { sb . setCharAt ( index , sb . charAt ( j ) ) ; index -- ; } } return sb . toString ( ) ; }
public static void print ( String input ) { int N = Integer . parseInt ( input ) ; String X = input ; int D = Integer . parseInt ( input ) ; StringBuilder ans = new StringBuilder ( X ) ; boolean [ ] done = new boolean [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( D == 0 ) break ; if ( ans . charAt ( i ) == '1' && ! done [ i ] ) { ans . setCharAt ( i , '0' ) ; D -- ; } } System . out . println ( ans . toString ( ) ) ; }
public static boolean check ( int n ) { int m = n ; int r ; while ( ( n = n % 10 ) != 0 ) { r = n % 10 ; if ( ( r > 0 ) && ( ( m % r ) != 0 ) ) { return false ; } n = n / 10 ; } return true ; }
public static List < Integer > convert ( String input ) { List < Integer > a = Lists . newArrayList ( ) ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { a . add ( Integer . parseInt ( input . substring ( i , i + 1 ) ) ) ; } int da = a . get ( 0 ) ; int db = a . get ( 1 ) ; if ( da > db ) { if ( da == 9 && db == 1 ) { System . out . println ( 9 + " ▁ " + 10 ) ; } else { System . out . println ( - 1 ) ; } } else if ( da == db ) { System . out . println ( Integer . toString ( da ) + 0 + " ▁ " + Integer . toString ( db ) + 1 ) ; } else { if ( db - da != 1 ) { System . out . println ( - 1 ) ; } else { System . out . println ( da + " ▁ " + db ) ; } } return a ; }
public static int max ( ) { n = Integer . parseInt ( input ( ) ) ; a = list ( Integer . parseInt ( input ( ) ) ) ; return max ( a ) ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; if ( n % 4 == 0 ) { System . out . println ( "4" ) ; } else { System . out . println ( "0" ) ; } }
public static void main ( String input ) { int k = Integer . parseInt ( input ) ; String num = new String ( input ) ; Arrays . sort ( num ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { sum += ( num . charAt ( i ) - '0' ) ; } if ( sum >= k ) { System . out . println ( 0 ) ; } else { int count = 0 ; int i = 0 ; while ( sum < k ) { sum += 9 - ( ( num . charAt ( i ) - '0' ) ) ; i ++ ; count ++ ; } System . out . println ( count ) ; } }
public static int calc ( int n , int k ) { int A = Integer . parseInt ( input ( ) ) ; int B = Integer . parseInt ( input ( ) ) ; int x = n ; int i = 0 ; { if ( x == 1 ) { return i ; } else if ( x % k == 0 && B <= ( x - x / k ) * A ) { return i + B ; } else if ( x % k == 0 ) { return 1 ; } else { return i + A * ( x % k ) ; } } }
static final int digSum ( int n ) { int sum = 0 ; while ( ( n > 0 ) || ( sum > 9 ) ) { if ( ( n == 0 ) ) { n = sum ; sum = 0 ; } sum += n % 10 ; n = n / 10 ; } return sum ; }
public static void input ( ) { int n = Integer . parseInt ( input . readLine ( ) ) ; int m = Integer . parseInt ( input . readLine ( ) ) ; String s = input . readLine ( ) ; String t = input . readLine ( ) ; int [ ] [ ] dp = new int [ m + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] [ 0 ] = 0 ; int ans = 0 ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i < n ) dp [ i + 1 ] [ j ] = Math . max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] - 1 ) ; if ( j < m ) dp [ i ] [ j + 1 ] = Math . max ( dp [ i ] [ j + 1 ] , dp [ i ] [ j ] - 1 ) ; if ( i < n && j < m && s . charAt ( i ) == t . charAt ( j ) ) dp [ i + 1 ] [ j + 1 ] = Math . max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] + 2 ) ; ans = Math . max ( ans , dp [ i ] [ j ] ) ; } } System . out . println ( ans ) ; }
public static int centeredHeptagonalNum ( int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
static int missingNum ( int [ ] arr , int n ) { int minvalue = Math . min ( arr . length , n ) ; int xornum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue = minvalue + 1 ; } return xornum ^ minvalue ; }
public static String smallestPermute ( int n ) { StringBuilder buf = new StringBuilder ( n + 1 ) ; buf . append ( " " ) ; if ( ( n % 2 ) == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( i % 2 ) == 0 ) { buf . append ( ( char ) ( 48 + i + 2 ) ) ; } else { buf . append ( ( char ) ( 48 + i ) ) ; } } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ( i % 2 ) == 0 ) { buf . append ( ( char ) ( 48 + i + 2 ) ) ; } else { buf . append ( ( char ) ( 48 + i ) ) ; } } buf . append ( ( char ) ( 48 + n - 2 ) ) ; buf . append ( ( char ) ( 48 + n ) ) ; buf . append ( ( char ) ( 48 + n - 1 ) ) ; } String str = buf . toString ( ) ; return str ; }
@ VisibleForTesting static int minOperations ( int [ ] a , int n , int K ) { Map < Integer , Boolean > map = new HashMap < > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( map . put ( a [ i ] , true ) == null ) return 0 ; map . put ( a [ i ] , true ) ; } int [ ] b = new int [ n ] ; for ( int i = 0 ; i <= n ; i ++ ) { b [ i ] = a [ i ] & K ; } map . clear ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( a [ i ] != b [ i ] ) { map . put ( b [ i ] , true ) ; } } for ( int i = 0 ; i <= n ; i ++ ) { if ( map . get ( a [ i ] ) == null ) return 1 ; } map . clear ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( map . get ( b [ i ] ) == null ) return 2 ; map . put ( b [ i ] , true ) ; } return - 1 ; }
public static int bfs ( int i , int j ) { if ( a [ i ] [ j ] == " . " ) a [ i ] [ j ] = " # " ; int res = 1 ; int wc = 0 ; int bc = 0 ; for ( int dy = - 1 ; dy < 2 ; dy ++ ) { for ( int dx = - 1 ; dx < 2 ; dx ++ ) { if ( ( dx == 0 && dy != 0 ) || ( dx != 0 && dy == 0 ) ) { } else continue ; int ny = i + dy ; int nx = j + dx ; if ( 0 <= nx && nx <= w - 1 && 0 <= ny && ny <= h - 1 && a [ ny ] [ nx ] != " # " ) { switch ( a [ ny ] [ nx ] ) { case " . " : int wct = bfs ( ny , nx ) ; int bct = bfs ( ny , nx ) ; wc += wct ; bc += bct ; res += rest ; break ; case " W " : wc ++ ; break ; case " B " : bc ++ ; break ; } } } } final Scanner input = new Scanner ( System . in ) ; while ( true ) { int w = input . nextInt ( ) ; int h = input . nextInt ( ) ; int wans = 0 ; int bans = 0 ; if ( w == 0 && h == 0 ) break ; a = new ArrayList < > ( ) ; for ( int i = 0 ; i < h ; i ++ ) a . add ( new LinkedList < > ( ) ) ; for ( int i = 0 ; i < w ; i ++ ) for ( int j = 0 ; j < h ; j ++ ) { if ( a . get ( j ) [ i ] == " . " ) { int wc = bfs ( j , i ) ; int bc = a . get ( j ) ; int res = a . get ( i ) ; if ( wc > 0 && bc == 0 ) wans += res ; else if ( wc == 0 && bc > 0 ) bans += res ; } } System . out . println ( bans + " ▁ " + wans ) ; } }
public static void main ( String input ) { for ( int x = 0 ; x < Integer . parseInt ( input ) ; x ++ ) { int a = Integer . parseInt ( input ) ; if ( a > 59 && 360 % ( 180 - a ) == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
static final String compute ( ) { final int NUM_COLORS = 7 ; final int BALLS_PER_COLOR = 10 ; final int NUM_PICKED = 20 ; final int DECIMALS = 9 ; final AtomicInteger numerator = new AtomicInteger ( 0 ) ; final int [ ] counts = new int [ NUM_COLORS ] ; { explore ( remain , limit , history ) ; } { if ( remain == 0 ) { LinkedList < Integer > hist = new LinkedList < Integer > ( ) ; while ( hist . size ( ) < NUM_COLORS ) hist . add ( 0 ) ; int [ ] histogram = new int [ BALLS_PER_COLOR + 1 ] ; for ( int x : hist ) histogram [ x ] ++ ; int count = Math . factorial ( NUM_COLORS ) ; for ( int x : histogram ) count = divideExactly ( count , Math . factorial ( x ) ) ; for ( int x : hist ) count *= eulerMath . binomial ( BALLS_PER_COLOR , x ) ; int distinctColors = counts . size ( ) ; numerator . set ( 0 , count * distinctColors ) ; } else if ( counts . length < NUM_COLORS ) { for ( int i = Math . min ( limit , remain ) ; i > 0 ; i -- ) { history . add ( i ) ; explore ( remain - i , i , history ) ; history . remove ( history . size ( ) - 1 ) ; } } } explore ( NUM_PICKED , BALLS_PER_COLOR , new int [ 0 ] ) ; final int [ ] denominator = eulerMath . binomial ( NUM_COLORS * BALLS_PER_COLOR , NUM_PICKED ) ; final int ans = new Fraction ( numerator [ 0 ] , denominator ) ; return formatFraction ( ans , DECIMALS ) ; }
public static int f = 1 ; int n = Integer . parseInt ( input ) ; int s = Integer . parseInt ( input ) ; int h = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; int h1 = h , m1 = m ; if ( h * 60 + m - s > 0 ) { System . out . println ( 0 + " ▁ " + 0 ) ; f = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int g1 = h1 * 60 + m1 ; int g2 = h * 60 + m ; if ( g2 - g1 > 2 * s + 1 && f == 1 ) { System . out . println ( ( g1 + s + 1 ) / 60 + " ▁ " + ( g1 + s + 1 ) % 60 ) ; f = 0 ; } h1 = h ; m1 = m ; if ( i != n - 1 ) { h = Integer . parseInt ( input ) ; m = Integer . parseInt ( input ) ; } } if ( f == 1 ) { int g1 = h1 * 60 + m1 ; System . out . println ( ( g1 + s + 1 ) / 60 + " ▁ " + ( g1 + s + 1 ) % 60 ) ; } return f ; }
public static int t = Integer . parseInt ( input ) { for ( int i = 0 ; i < t ; i ++ ) { int a = Integer . parseInt ( input . readLine ( ) ) ; int b = Integer . parseInt ( input . readLine ( ) ) ; if ( b == 1 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; System . out . println ( a + " ▁ " + a * b + " ▁ " + a * b + a ) ; } } return t ; }
public static void input ( ) { String r = input . readLine ( ) ; String a = input . readLine ( ) ; if ( r . equals ( "0" ) ) { break ; } int h = 0 ; for ( int i = 0 ; i < r . length ( ) ; i ++ ) { if ( r . equals ( a ) ) { h ++ ; } } int b = - h ; for ( int i = 0 ; i < r . length ( ) ; i ++ ) { if ( r . contains ( a . substring ( i , i + 1 ) ) ) { b ++ ; } } System . out . println ( h + " ▁ " + b ) ; }
static int findMaxValue ( int [ ] arr , int n ) { if ( n < 4 ) { System . out . println ( " The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements " ) ; return MIN ; } int [ ] table1 = new int [ n + 1 ] , table2 = new int [ n ] ; int [ ] table3 = new int [ n - 1 ] , table4 = new int [ n - 2 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; } for ( int i = n - 3 ; i >= 0 ; i -- ) { table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ; } for ( int i = n - 4 ; i >= 0 ; i -- ) { table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ; } return table4 [ 0 ] ; }
public static void centeredHexagonalSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( 3 * i * ( i - 1 ) + 1 ) ; } if ( getClass ( ) . equals ( " java . lang . Integer " ) ) { n = 10 ; centeredHexagonalSeries ( n ) ; } }
public static void input ( ) { String target = input . nextLine ( ) ; String [ ] list_abc = { " A " , " B " , " C " } ; ArrayList < String [ ] > old = new ArrayList < String [ ] > ( ) ; ArrayList < String [ ] > new = new ArrayList < String [ ] > ( ) ; ArrayList < String [ ] > check = new ArrayList < String [ ] > ( ) ; boolean flag = false ; if ( target . contains ( " ABC " ) ) { old . add ( new String [ ] { target , new String [ 0 ] } ) ; } while ( old . size ( ) != 0 && flag == false ) { for ( int i = 0 ; i < old . size ( ) ; i ++ ) { String [ ] i = old . get ( i ) ; if ( i [ 0 ] . equals ( " ABC " ) ) { check . add ( i [ 1 ] ) ; } } } flag = false ; for ( int i = 0 ; i < check . size ( ) ; i ++ ) { String abc = " ABC " ; ListIterator < String > li = check . listIterator ( ) ; li . reverse ( ) ; while ( li . hasNext ( ) ) { abc = abc . replace ( li . next ( ) , " ABC " ) ; } if ( abc . equals ( target ) ) { flag = true ; } } System . out . println ( flag == true ? " Yes " : " No " ) ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( args [ 0 ] ) , m = Integer . parseInt ( args [ 1 ] ) ; String [ ] lists = new String [ n ] ; int sq = 0 ; int l = 0 ; int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { lists [ i ] = input . substring ( i , i + 1 ) ; } for ( int i = 0 ; i < m ; i ++ ) { lists [ i ] = input . substring ( i + 1 ) ; } }
static void diagonalsMinMax ( int [ ] [ ] mat ) { int n = mat . length ; if ( ( n == 0 ) || ( n == 1 ) ) return ; int principalMin = mat [ 0 ] [ 0 ] ; int principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] ; int secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( ( i == j ) ) { if ( ( mat [ i ] [ j ] < principalMin ) && ( mat [ i ] [ j ] > principalMax ) ) principalMin = mat [ i ] [ j ] ; if ( ( mat [ i ] [ j ] > principalMax ) && ( mat [ i ] [ j ] > secondaryMin ) ) secondaryMax = mat [ i ] [ j ] ; } } if ( ( ( i + j ) == ( n - 1 ) ) && ( mat [ i ] [ j ] < secondaryMin ) ) secondaryMin = mat [ i ] [ j ] ; if ( ( mat [ i ] [ j ] > secondaryMax ) && ( mat [ i ] [ j ] > secondaryMax ) ) secondaryMax = mat [ i ] [ j ] ; } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) ; }
static void diagonalsMinMax ( int [ ] [ ] mat ) { if ( ( n == 0 ) || ( n == 1 ) ) return ; int principalMin = mat [ 0 ] [ 0 ] ; int principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] ; int secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( mat [ i ] [ i ] < principalMin ) && ( mat [ i ] [ i ] > principalMax ) ) principalMin = mat [ i ] [ i ] ; if ( ( mat [ i ] [ i ] < secondaryMin ) && ( mat [ i ] [ i ] > secondaryMax ) ) secondaryMax = mat [ i ] [ i ] ; } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) ; }
static int averageOdd ( int n ) { if ( ( n % 2 ) == 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } int sm = 0 ; int count = 0 ; while ( ( n >= 1 ) && ( n <= 2 ) ) { count = count + 1 ; sm = sm + n ; n = n - 2 ; } return sm / count ; }
static int averageOdd ( int n ) { if ( ( n % 2 ) == 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } return ( n + 1 ) / 2 ; }
static boolean areElementsContiguous ( int [ ] arr ) { Set < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) us . add ( arr [ i ] ) ; int count = 1 ; int currEle = arr [ 0 ] - 1 ; while ( us . contains ( currEle ) ) { count ++ ; currEle ++ ; } return ( count == us . size ( ) ) ; }
@ VisibleForTesting static void main ( @ Nonnull final LinkedList < Integer > zero , @ Nonnull final LinkedList < Integer > one ) { final LinkedList < Integer > zero = new LinkedList < Integer > ( ) ; final LinkedList < Integer > zero = new LinkedList < Integer > ( ) ; final LinkedList < Integer > one = new LinkedList < Integer > ( ) ; { final int leftMostZero = zero . size ( ) ; if ( zero . size ( ) == 0 ) return - 1 ; zero . removeFirst ( ) ; return 0 ; } final int leftMostOne = one . size ( ) ; if ( one . size ( ) == 0 ) return - 1 ; one . removeFirst ( ) ; final int leftMostElement = one . size ( ) ; if ( zero . size ( ) == 0 && one . size ( ) == 0 ) return - 1 ; else if ( zero . size ( ) == 0 ) { one . removeFirst ( ) ; return 1 ; } else if ( one . size ( ) == 0 ) { zero . removeFirst ( ) ; return 0 ; } final int res = zero . get ( 0 ) < one . get ( 0 ) ? 0 : 1 ; if ( res == 0 ) zero . removeFirst ( ) ; else one . removeFirst ( ) ; }
private static void vertices ( int x , int y ) { int val = Math . abs ( x ) + Math . abs ( y ) ; if ( x < 0 ) x = - 1 ; else x = 1 ; System . out . print ( val * x + " ▁ " ) ; System . out . print ( "0" ) ; if ( y < 0 ) y = - 1 ; else y = 1 ; System . out . print ( "0" ) ; System . out . print ( val * y ) ; }
@ GwtIncompatible ( " java . util . Arrays " ) public static void getSum ( int [ ] a , int n ) { int [ ] P = new int [ n ] ; P [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { P [ i ] = a [ i ] + P [ i - 1 ] ; } int S = P [ n - 1 ] ; HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hash . put ( P [ i ] , 1 ) ; } Set < Integer > res = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( S ) ; i ++ ) { if ( ( S % i ) == 0 ) { boolean pres = true ; int div1 = i ; int div2 = S / i ; for ( int j = div1 ; j <= S ; j += div1 ) { if ( ! hash . keySet ( ) . contains ( j ) ) { pres = false ; break ; } } if ( ( pres && div1 != S ) ) { res . add ( div1 ) ; } pres = true ; for ( int j = S / i ; j <= S ; j += div2 ) { if ( ! hash . keySet ( ) . contains ( j ) ) { pres = false ; break ; } } if ( ( pres && div2 != S ) ) { res . add ( div2 ) ; } } } if ( ( res . size ( ) == 0 ) ) { System . out . println ( " - 1" ) ; return ; } for ( int i : res ) { System . out . print ( i + " ▁ " ) ; } }
static void originalArray ( int [ ] greater , int n ) { int [ ] temp = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = i ; } int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = 0 ; } }
public static int input ( ) { String s = input ( ) ; int n = Integer . parseInt ( input ( ) ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String x = input ( ) ; int a = 0 , b = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == x . charAt ( 0 ) ) { a ++ ; } else if ( s . charAt ( j ) == x . charAt ( 1 ) ) { b ++ ; } else { ans = ans + Math . min ( a , b ) ; a = 0 ; b = 0 ; } } ans = ans + Math . min ( a , b ) ; } System . out . println ( ans ) ; return ans ; }
public static int Solution ( ) { /* ▁ find ▁ the ▁ radius ▁ of ▁ the ▁ houses ▁ and ▁ heaters ▁ */ Arrays . sort ( heaters ) ; int i = 0 ; int r = 0 ; for ( int x : new ArrayList < Integer > ( houses ) ) { while ( x >= Integer . MAX_VALUE / 2.0f ) { i ++ ; } r = Math . max ( r , Math . abs ( heaters [ i ] - x ) ) ; } return r ; }
static final String compute ( ) { final Predicate < Integer > cond = i -> ( i % 5 != 0 ) && ( ! EulerUtil . isPrime ( i ) ) && ( ( i - 1 ) % findLeastDivisibleRepunit ( i ) == 0 ) ; final long ans = Long . parseLong ( Iterables . getOnlyElement ( new Predicate < Integer > ( ) { @ Override public boolean apply ( Integer input ) { return input . intValue ( ) == input . intValue ( ) && cond . apply ( input ) && ( input . intValue ( ) % input . intValue ( ) == input . intValue ( ) ) ; } } ) ) ; return Long . toString ( ans ) ; }
@ GwtIncompatible ( " java . lang . Integer " ) public static int checkRecursive ( int num , int x , int k , int n ) { int a ; int i ; int r ; if ( ( x = Math . floor ( num ) ) == 0 ) { res ++ ; } r = Math . floor ( Math . pow ( num , ( 1 / n ) ) ) ; for ( i = k + 1 ; i <= r ; i += 1 ) { a = x - ( int ) Math . pow ( i , n ) ; if ( ( a >= 0 ) && ( a <= n ) ) { checkRecursive ( num , x - ( int ) Math . pow ( i , n ) , i , n ) ; } } return res ; }
private static List < Integer > S = Lists . newArrayList ( ) ; for ( int i = 0 ; i < input . length ; i ++ ) { S . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } int length = S . size ( ) - 1 ; for ( int bit = 0 ; bit < 2 * length ; bit ++ ) { int ans = S . get ( 0 ) ; char [ ] ope = new char [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { ope [ i ] = bit & ( 2 * i ) ; } for ( int i = 1 ; i <= length ; i ++ ) { if ( ope [ i - 1 ] == ' + ' ) { ans += S . get ( i ) ; } else { ans -= S . get ( i ) ; } } if ( ans == 7 ) { System . out . println ( S . get ( 0 ) + ope [ 0 ] + S . get ( 1 ) + ope [ 1 ] + S . get ( 2 ) + ope [ 2 ] + S . get ( 3 ) + ' = 7' ) ; break ; } } return S ; }
public static int [ ] [ ] getN ( ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; List < Tuple < Integer , Integer > > ABs = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { ABs . add ( new Tuple < > ( Integer . parseInt ( input . nextLine ( ) ) ) ) ; } int bsum = 0 ; for ( Tuple < Integer , Integer > A : ABs ) { int B = A . get ( i ) ; bsum += B . get ( i ) ; } int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { final int A = ABs . get ( i ) . get ( i ) ; for ( int j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < bsum + 1 ; k ++ ) { if ( dp [ j ] [ k ] == - 1 ) continue ; dp [ j + 1 ] [ k ] = Math . max ( dp [ j - 1 ] [ k ] , dp [ j ] [ k ] + k ) ; } } } return dp ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; if ( ( n < 10 ) && ( n > 9 ) ) { System . out . println ( n ) ; } else { int l = String . valueOf ( n ) . length ( ) - 1 ; int p = Integer . parseInt ( '9' * l ) ; int t = n - p ; int s = 0 ; while ( ( t > 0 ) && ( t < 10 ) ) { s += t % 10 ; t /= 10 ; } System . out . println ( s + 9 * l ) ; } }
public static boolean prime ( int n ) { for ( int i = 2 ; i <= n ; i ++ ) { if ( i * i > n + 1 ) { break ; } if ( ( n % i ) == 0 ) { return false ; } } /* ▁ thirdNumber ▁ */ int summ = 0 ; int temp = 0 ; summ = a + b ; temp = 1 ; if ( ( summ & 1 ) == 0 ) { temp = 2 ; } return true ; }
private static int squares ( int n , int m , int a ) { return ( ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ) ; }
public static void for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; if ( n >= 6 && n % m == 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
static int countCubes ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) { for ( int j = 0 ; j < i + 1 ; j ++ ) { if ( j * j * j > i ) { break ; } if ( j * j * j == i ) { cnt ++ ; } } } return cnt ; }
@ GwtIncompatible ( " java . util . Collections " ) public static void main ( String [ ] args ) { int n = Integer . parseInt ( input ( ) ) ; List < String > aa = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { aa . add ( input ( ) ) ; } Map < String , Integer > cs_a0 = new LinkedHashMap < > ( ) ; for ( int i = 0 ; i < aa . size ( ) ; i ++ ) { if ( i % 2 == 0 ) cs_a0 . put ( aa . get ( i ) , i ) ; } Map < String , Integer > cs_a1 = new LinkedHashMap < > ( ) ; for ( int i = 0 ; i < aa . size ( ) ; i ++ ) { if ( aa . get ( i ) % 2 == 1 ) cs_a1 . put ( aa . get ( i ) , i ) ; } TreeSet < Integer > vs_a0 = new TreeSet < > ( ( Comparator < String > ) cs_a0 . entrySet ( ) ) ; TreeSet < Integer > vs_a1 = new TreeSet < > ( ( Comparator < String > ) cs_a1 . entrySet ( ) ) ; for ( Map . Entry < String , Integer > entry : cs_a1 . entrySet ( ) ) { if ( vs_a0 . first ( ) . getValue ( ) != vs_a1 . first ( ) . getValue ( ) ) { System . out . println ( n - vs_a0 . first ( ) . getValue ( ) - vs_a1 . first ( ) . getValue ( ) ) ; } else { int res = 1 << 30 ; if ( vs_a0 . size ( ) == 1 && vs_a1 . size ( ) == 1 ) { res = n / 2 ; } if ( vs_a0 . size ( ) > 1 ) { res = Math . min ( res , n - vs_a0 . second ( ) . getValue ( ) - vs_a1 . second ( ) . getValue ( ) ) ; } if ( vs_a1 . size ( ) > 1 ) { res = Math . min ( res , n - vs_a0 . first ( ) . getValue ( ) - vs_a1 . second ( ) . getValue ( ) ) ; } System . out . println ( res ) ; } } if ( args . length > 0 ) { System . out . println ( " java . util . Collections . sort " ) ; } }
public static void subString ( String s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int len = i + 1 ; len <= n ; len ++ ) { System . out . println ( s . substring ( i , len ) ) ; } } s = " abcd " ; }
static boolean isPrime ( int n ) { if ( ( n <= 1 ) && ( n % 2 == 0 ) ) { return false ; } for ( int i = 2 ; i < n ; i ++ ) { if ( ( n % i == 0 ) && ( n % i == 0 ) ) { return false ; } } return true ; }
static void angleextcycquad ( int z ) { System . out . print ( " The ▁ exterior ▁ angle ▁ of ▁ the " ) ; System . out . print ( " cyclic ▁ quadrilateral ▁ is ▁ " ) ; }
public static void printMinIndexChar ( String Str , String patt ) { int minIndex = 10 * 9 ; int m = Str . length ( ) ; int n = patt . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( patt . charAt ( i ) == Str . charAt ( j ) ) && j < minIndex ) { minIndex = j ; break ; } } } if ( minIndex != 10 * 9 ) { } }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; for ( ; ; ) { int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; if ( a != b ) { System . out . println ( " Happy ▁ Alex " ) ; break ; } } }
public static long maxNumber ( long n , int k ) { for ( int i = 0 ; i <= k ; i ++ ) { long ans = 0 ; int i = 1 ; while ( n / i > 0 ) { long temp = ( n / ( i * 10 ) ) * i + ( n % i ) ; i *= 10 ; } ans ++ ; } return ans ; }
public static int [ ] [ ] createArray ( int N , int M ) { int [ ] L = new int [ N * 2 ] ; for ( int i = 0 ; i < M ; i ++ ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int l = Integer . parseInt ( input . nextLine ( ) ) ; for ( int ll = a ; ll < a + l ; ll ++ ) { L [ ll ] = 1 ; } } for ( int i = N ; i < 2 * N ; i ++ ) { L [ i - N ] = Math . max ( L [ i - N ] , L [ i ] ) ; } int left = 0 ; int i = 0 ; while ( L [ i ] == 1 ) { left ++ ; i ++ ; if ( i == N ) { System . out . println ( N ) ; } } return A ; }
public static void main ( String input ) { int N = Integer . parseInt ( input ) ; List < Integer > A = Lists . newArrayList ( ) ; for ( int i = 0 ; i < N ; i ++ ) { A . add ( Integer . parseInt ( input ) ) ; } int cntA = 0 , sumA = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumA += A . get ( i ) ; if ( i % 2 == 0 ) { if ( sumA <= 0 ) { cntA += Math . abs ( sumA ) + 1 ; sumA += Math . abs ( sumA ) + 1 ; } } else { if ( sumA >= 0 ) { cntA += Math . abs ( sumA ) + 1 ; sumA -= Math . abs ( sumA ) + 1 ; } } } int cntB = 0 , sumB = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumB += A . get ( i ) ; if ( i % 2 != 0 ) { if ( sumB <= 0 ) { cntB += Math . abs ( sumB ) + 1 ; sumB += Math . abs ( sumB ) + 1 ; } } else { if ( sumB >= 0 ) { cntB += Math . abs ( sumB ) + 1 ; sumB -= Math . abs ( sumB ) + 1 ; } } } System . out . println ( Math . min ( cntA , cntB ) ) ; }
public static int getLastTwoDigit ( int N ) { if ( N <= 10 ) { int ans = 0 ; int fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } ans = ans % 100 ; return ans ; } else { return 13 ; } }
public static void binaryNumber ( String binaryNumber ) { String s = "1001" ; s = Integer . toString ( binaryNumber , 2 ) ; System . out . println ( s ) ; }
@ GwtIncompatible ( " java . lang . Double " ) public static boolean isPossible ( double x , double y , double z ) { double a = x * x + y * y + z * z ; a = Math . round ( a ) ; if ( ( ceil ( a ) == 1 & floor ( a ) == 1 ) ) { return true ; } return false ; }
public static void performQueries ( int [ ] q , int n ) { int MOD = 10 * 9 + 7 ; int [ ] result = new int [ MAX + 1 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = 0 ; } int [ ] fact = new int [ MAX + 1 ] ; for ( int i = 0 ; i < fact . length ; i ++ ) { fact [ i ] = 1 ; } }
public static void main ( Scanner in ) { int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } int sum = a [ a . length - 1 ] ; int neg = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int val = neg + i * ( a [ i ] - a [ i - 1 ] ) ; sum -= val ; neg = val ; } System . out . println ( sum ) ; }
public static int segregate ( int [ ] arr , int size ) { int j = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] <= 0 ) && ( arr [ i ] > 0 ) ) { arr [ i ] = arr [ j ] ; j ++ ; } } /* ▁ find ▁ missing ▁ positive ▁ number ▁ */ for ( int i = 0 ; i < size ; i ++ ) { if ( ( Math . abs ( arr [ i ] ) - 1 < size ) && arr [ Math . abs ( arr [ i ] - 1 ) ] > 0 ) { arr [ i ] = - 1 ; } } return size + 1 ; }
static long digitNumber ( long n ) { long temp ; if ( ( n == 0 ) && ( n == 1 ) ) { return 1 ; } if ( ( n == 1 ) && ( n == 9 ) ) { temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( input ) ; } if ( a [ 0 ] + a [ 1 ] > a [ a . length - 1 ] ) { System . out . println ( - 1 ) ; } else { System . out . println ( 1 + 2 + n ) ; } }
public static void convert12 ( String str ) { int h1 = ( str . charAt ( 0 ) - '0' ) ; int h2 = ( str . charAt ( 1 ) - '0' ) ; int hh = h1 * 10 + h2 ; String Meridien = " " ; if ( ( hh < 12 ) || ( hh > 12 ) ) { Meridien = " AM " ; } else { Meridien = " PM " ; } hh %= 12 ; if ( ( hh == 0 ) || ( hh > 12 ) ) { System . out . print ( "12" ) ; for ( int i = 2 ; i < 8 ; i ++ ) { System . out . print ( str . charAt ( i ) ) ; } } else { System . out . print ( hh ) ; for ( int i = 2 ; i < 8 ; i ++ ) { System . out . print ( str . charAt ( i ) ) ; } } System . out . println ( " ▁ " + Meridien ) ; } if ( Class . forName ( " java . lang . String " ) . equals ( " java . lang . String " ) ) { str = "17:35:20" ; convert12 ( str ) ; }
private static boolean check ( String s , int k ) { for ( int i = 0 ; ( s != null ) && ( i < s . length ( ) ) ; i ++ ) { if ( ( s . charAt ( i ) != s . charAt ( i % k ) ) ) { return false ; } } return true ; }
static void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int [ ] [ ] K = new int [ W + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int w = 0 ; w < W + 1 ; w ++ ) { if ( i == 0 || w == 0 ) { K [ i ] [ w ] = 0 ; } else if ( wt [ i - 1 ] <= w ) { K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; } else { K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } } int res = K [ n ] ; System . out . println ( res ) ; }
public static void print ( int n ) { int [ ] [ ] q = new int [ n ] [ ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] a = input . split ( ) ; q [ i ] = a ; } for ( int j = 0 ; j < q . length ; j ++ ) { for ( int k = 0 ; k < q . length ; k ++ ) { if ( q [ k ] == j ) { count ++ ; } else { continue ; } } } System . out . println ( count ) ; }
static void indexedSequentialSearch ( int [ ] arr , int n , int k ) { int [ ] elements = new int [ 20 ] ; int [ ] indices = new int [ 20 ] ; int j = 0 , ind = 0 ; for ( int i = 0 ; i < n ; i += 3 ) { elements [ ind ] = arr [ i ] ; indices [ ind ] = i ; ind ++ ; } if ( k < elements [ 0 ] ) { System . out . println ( " Not ▁ found " ) ; exit ( 0 ) ; } else { for ( int i = 1 ; i <= ind ; i ++ ) { if ( k < elements [ i ] ) { start = indices [ i - 1 ] ; end = indices [ i ] ; break ; } } } for ( int i = start ; i <= end ; i ++ ) { if ( k == arr [ i ] ) { j = 1 ; break ; } } if ( j == 1 ) { System . out . println ( " Found ▁ at ▁ index " + i ) ; } else { System . out . println ( " Not ▁ found " ) ; } if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { arr = new int [ ] { 6 , 7 , 8 , 9 , 10 } ; n = arr . length ; k = 8 ; indexedSequentialSearch ( arr , n , k ) ; } }
public static int largestPalindrome ( int n ) { int upperLimit = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { upperLimit = upperLimit * 10 ; upperLimit = upperLimit + 9 ; } int lowerLimit = 1 + upperLimit / 10 ; int maxProduct = 0 ; for ( int i = upperLimit ; i >= lowerLimit ; i -- ) { for ( int j = i ; j >= lowerLimit ; j -- ) { int product = i * j ; if ( ( product < maxProduct ) && ( product > maxProduct ) ) break ; int number = product ; int reverse = 0 ; while ( ( number != 0 ) && ( product > maxProduct ) ) { reverse = reverse * 10 + number % 10 ; number = number / 10 ; } if ( ( product == reverse ) && ( product > maxProduct ) ) maxProduct = product ; } } return maxProduct ; }
static final int [ ] binarySearch ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] seq = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) seq [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; dp = new int [ seq . length ] ; }
public static void main ( String input ) { int t = Integer . parseInt ( input ) ; for ( ; ; ) { int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; int c = Integer . parseInt ( input ) ; int ans = 0 ; if ( a > 0 ) { a -- ; ans ++ ; } if ( b > 0 ) { b -- ; ans ++ ; } if ( c > 0 ) { c -- ; ans ++ ; } boolean cDown = false ; if ( c > 1 ) { if ( c > 0 && b > 0 ) { c -- ; b -- ; ans ++ ; cDown = true ; } } if ( a > 0 && b > 0 ) { a -- ; b -- ; ans ++ ; } if ( c > 0 && b > 0 && ! cDown ) { c -- ; b -- ; ans ++ ; } if ( a > 0 && c > 0 ) { a -- ; c -- ; ans ++ ; } if ( a > 0 && b > 0 && c > 0 ) { ans ++ ; } System . out . println ( String . valueOf ( Math . min ( 7 , ans ) ) ) ; } }
public static void print ( int n ) { int [ ] arr = Integer . parseInt ( input ( ) ) ; int [ ] diff = new int [ n - 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff [ i ] = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; } int [ ] [ ] dp = new int [ n - 1 ] [ ] ; dp [ 0 ] [ 1 ] = diff [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 2 ] + diff [ i ] , diff [ i ] ) ; } System . out . println ( Math . max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] , dp [ n - 2 ] [ 2 ] ) ) ; }
static int maximumXor ( @ Nonnull int [ ] arr , int n ) { int [ ] sForward = new int [ n ] , sBackward = new int [ n ] ; int ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { while ( sForward . length > 0 && arr [ i ] < arr [ sForward [ sForward . length - 1 ] ] ) { ans = Math . max ( ans , arr [ i ] ^ arr [ sForward [ sForward . length - 1 ] ] ) ; sForward [ sForward . length - 1 ] = i ; } sForward [ i ] = i ; while ( sBackward . length > 0 && arr [ n - i - 1 ] < arr [ sBackward [ sBackward . length - 1 ] ] ) { ans = Math . max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward [ sBackward . length - 1 ] ] ) ; sBackward [ sBackward . length - 1 ] = i ; } sBackward [ sBackward . length - 1 ] = n - i - 1 ; } if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { arr = new int [ ] { 8 , 1 , 2 } ; n = arr . length ; System . out . println ( maximumXor ( arr , n ) ) ; } return ans ; }
static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( ( n != 0 ) && ( i < n ) ) { int temp = 0 ; temp = n % 16 ; if ( ( temp < 10 ) && ( temp < 10 ) ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i = i + 1 ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; } n = 2545 ; } decToHexa ( n ) ; }
public static int N = Integer . parseInt ( input ) { int [ ] A = Lists . newArrayList ( ) . stream ( ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] C = new int [ 10 * 5 ] ; for ( int ai : A ) { C [ ai ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < 10 * 5 - 2 ; i ++ ) { ans = Math . max ( C [ i ] + C [ i + 1 ] + C [ i + 2 ] , ans ) ; } System . out . println ( ans ) ; return ans ; }
public static void solve ( ) { int h = Integer . parseInt ( input . readLine ( ) ) ; int w = Integer . parseInt ( input . readLine ( ) ) ; if ( h == w == 0 ) { break ; } Map < String , int [ ] > mp = new HashMap < String , int [ ] > ( ) ; for ( int r = 0 ; r < h ; r ++ ) { String s = input . readLine ( ) ; for ( int c = 0 ; c < w ; c ++ ) { mp . put ( s . charAt ( c ) , new int [ ] { r , c } ) ; } } String s = input . readLine ( ) ; int [ ] now = { 0 , 0 } ; int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int [ ] to = mp . get ( s . charAt ( i ) ) ; ans += Math . abs ( now [ 0 ] - to [ 0 ] ) + Math . abs ( now [ 1 ] - to [ 1 ] ) + 1 ; now = to ; } System . out . println ( ans ) ; }
static final Scanner getScanner ( ) { final Scanner scanner = new Scanner ( System . in ) ; final int n = scanner . nextInt ( ) ; if ( n == 1 ) { System . out . println ( " Hello ▁ World " ) ; } else { final int a = scanner . nextInt ( ) ; final int b = scanner . nextInt ( ) ; System . out . println ( a + b ) ; } return scanner ; }
static int extractMaximum ( String ss ) { int num = 0 , res = 0 ; for ( int i = 0 ; i < ss . length ( ) ; i ++ ) { if ( ss . charAt ( i ) >= '0' && ss . charAt ( i ) <= '9' ) { num = num * 10 + ( int ) Integer . parseInt ( ss . substring ( i ) ) - 0 ; } else { res = num ; } } return res ; }
public static void findIndices ( int [ ] arr , int n ) { int [ ] sum = new int [ max ] ; for ( int i = 0 ; i < max ; i ++ ) sum [ i ] = 0 ; int k = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum [ i ] = sum [ i - 1 ] + arr [ k ] ; k ++ ; } double ans = - ( 1e15 ) ; int index_1 = 0 ; int index_2 = 0 ; int index_3 = - 1 ; for ( int l = 0 ; l < n + 1 ; l ++ ) { int index = 0 ; double vmin = ( 1e15 ) ; for ( int r = l ; r <= n ; r ++ ) { if ( ( sum [ r ] < vmin ) && ( sum [ r ] > ans ) ) { vmin = sum [ r ] ; index = r ; } if ( ( sum [ l ] + sum [ r ] - vmin ) > ans ) { ans = sum [ l ] + sum [ r ] - vmin ; index_1 = l ; index_2 = index ; index_3 = r ; } } } System . out . println ( index_1 + " ▁ " + index_2 + " ▁ " + index_3 ) ; }
static void printElements ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i += 1 ) { if ( ( arr [ i ] > arr [ i - 1 ] ) && ( arr [ i ] > arr [ i + 1 ] ) ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } if ( getClass ( ) . isArray ( ) ) { arr = new int [ ] { 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 } ; n = arr . length ; printElements ( arr , n ) ; } }
public static int valueofX ( int [ ] ar , int n ) { int summ = sum ( ar ) ; if ( ( summ % n ) == 0 ) { return summ / n ; } else { int A = summ / n ; int B = summ / n + 1 ; int ValueA = 0 ; int ValueB = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ; ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) ; } if ( ( ValueA < ValueB ) ) { return A ; } else { return B ; } } }
public static void main ( String input ) { for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { int x = Integer . parseInt ( input . substring ( 0 , input . indexOf ( ' ▁ ' ) ) ) ; int y = Integer . parseInt ( input . substring ( input . indexOf ( ' ▁ ' ) + 1 , input . indexOf ( ' ▁ ' ) ) ) ; int [ ] z = new int [ input . length ( ) ] ; for ( int j = 0 ; j < z . length ; j ++ ) { z [ j ] = Integer . parseInt ( input . substring ( i , j + 1 ) ) ; } int a = 0 ; for ( int i = 0 ; i < y ; i ++ ) { int c = 0 ; for ( int j = 0 ; j < z . length ; j ++ ) { if ( z [ j ] & ( 1 << i ) != 0 ) { c ++ ; } } if ( c > ( x - c ) ) { a += 1 << i ; } } System . out . println ( a ) ; } }
public static void print ( String s ) { s = new LinkedList < String > ( ) ; s . add ( input ( ) ) ; s . remove ( s . length ( ) - 1 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . length ( ) % 2 == 1 ) { s . remove ( s . length ( ) - 1 ) ; } else { if ( s . substring ( 0 , ( int ) s . length ( ) / 2 ) . equals ( s . substring ( ( int ) s . length ( ) / 2 ) ) ) { System . out . println ( s . length ( ) ) ; exit ( ) ; } else { s . remove ( s . length ( ) - 1 ) ; } } } }
static int findNth ( int n ) { int count = 0 ; int curr = 19 ; int sum ; while ( ( sum = 0 ) != 0 ) { x = curr ; while ( ( x > 0 ) && ( sum == 10 ) ) { count ++ ; } if ( ( count == n ) ) { return curr ; } curr += 9 ; } return - 1 ; }
static int findNth ( int n ) { final int count = 0 ; for ( int curr = 0 ; curr < n ; curr ++ ) { int sum = 0 ; int x = curr ; while ( ( x = findNth ( x ) ) != 0 ) { sum = sum + x % 10 ; x = x / 10 ; } if ( ( sum == 10 ) && ( x != 0 ) ) { count = count + 1 ; } if ( ( count == n ) && ( curr == 0 ) ) { return curr ; } } return - 1 ; }
static int countNumber ( int N , int S ) { int countElements = 0 ; int currentSum = 0 ; int currSum = 0 ; while ( ( currSum <= S ) && ( currentSum <= N ) ) { currSum += N ; N = N - 1 ; countElements = countElements + 1 ; } return countElements ; }
public static boolean strrmatch ( String strr , String pattern , int n , int m ) { if ( ( m == 0 ) && ( pattern . length ( ) == 0 ) ) return ( n == 0 ) ; boolean [ ] [ ] lookup = new boolean [ m + 1 ] [ n + 1 ] ; lookup [ 0 ] [ 0 ] = true ; for ( int j = 1 ; j <= m ; j ++ ) { if ( ( pattern . charAt ( j - 1 ) == ' * ' ) && ( strr . charAt ( j - 1 ) == pattern . charAt ( j - 1 ) ) ) lookup [ 0 ] [ j ] = lookup [ 0 ] [ j - 1 ] ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( ( pattern . charAt ( j - 1 ) == ' * ' ) && ( strr . charAt ( j - 1 ) == pattern . charAt ( j - 1 ) ) ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] || lookup [ i - 1 ] [ j ] ; else if ( ( pattern . charAt ( j - 1 ) == ' ? ' ) || strr . charAt ( j - 1 ) == pattern . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] ; else lookup [ i ] [ j ] = false ; } } return lookup [ n ] [ m ] ; }
public static Set < Integer > f ( int n ) { Set < Integer > a = new HashSet < > ( ) ; int i = 2 ; while ( i * i <= n ) { while ( n % i == 0 ) { a . add ( i ) ; n /= i ; } i ++ ; } if ( n > 1 ) a . add ( n ) ; while ( true ) { a = Integer . parseInt ( input . nextLine ( ) ) ; if ( ( a | b ) == 0 ) break ; a = f ( a ) ; b = f ( b ) ; System . out . println ( 2 * Math . max ( a . size ( ) - Math . pow ( a . size ( ) , 2 ) ) > 2 * Math . max ( b . size ( ) - Math . pow ( b . size ( ) , 2 ) ) ? " a " : " b " ) ; } }
public static int nCr ( int n , int r ) { int [ ] fac = new int [ n + r ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fac [ i ] = fac [ i - 1 ] * i ; } int ans = fac [ n ] / ( fac [ n - r ] * fac [ r ] ) ; return ans ; }
public static void print ( int n ) { int [ ] a = Integer . parseInt ( input ( ) ) ; int mx = max ( a ) ; int hf = 0 ; for ( int x : a ) { if ( Math . abs ( mx - 2 * hf ) > Math . abs ( mx - 2 * x ) ) { hf = x ; } } System . out . println ( mx + " ▁ " + hf ) ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) { return b ; } return gcd ( b % a , a ) ; /* ▁ for ▁ ( int ▁ i = 0 ; ▁ i < n ; ▁ i + + ) ▁ { STRNEWLINE ▁ a ▁ = ▁ a * a ; STRNEWLINE ▁ } */ /* ▁ if ▁ ( getClass ( ) . equals ( int ) ) ▁ { STRNEWLINE ▁ a ▁ = ▁ 10 ; STRNEWLINE ▁ b ▁ = ▁ 5 ; STRNEWLINE ▁ n ▁ = ▁ 2 ; STRNEWLINE ▁ System . out . println ( powGCD ( a , ▁ n , ▁ b ) ) ; STRNEWLINE ▁ } */ }
public static int [ ] countingSort ( int [ ] A , int n ) { int k = max ( A ) ; int [ ] B = new int [ n ] ; int [ ] C = new int [ k + 1 ] ; for ( int j = 0 ; j < n ; j ++ ) C [ A [ j ] ] ++ ; for ( int i = 1 ; i <= k ; i ++ ) C [ i ] = C [ i ] + C [ i - 1 ] ; for ( int j = n - 1 ; j >= 0 ; j -- ) B [ C [ A [ j ] ] - 1 ] = A [ j ] ; return B ; }
public static void print ( int n ) { int i = input ( ) ; String s = input ( ) ; System . out . println ( min ( n / 11 , s . indexOf ( '8' ) ) ) ; }
static int sumOfDigit ( int n , int b ) { int unitDigit = 0 ; int sum = 0 ; while ( ( n > 0 ) && ( b > 0 ) ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; }
@ SafeVarargs public static void printLargestDivisible ( int n , int [ ] a ) { int c0 = 0 , c5 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { c0 ++ ; } else { c5 ++ ; } } c5 = floor ( c5 / 9 ) * 9 ; if ( c0 == 0 ) { System . out . print ( - 1 ) ; } else if ( c5 == 0 ) { System . out . print ( 0 ) ; } else { for ( int i = 0 ; i < c5 ; i ++ ) { System . out . print ( 5 ) ; } for ( int i = 0 ; i < c0 ; i ++ ) { System . out . print ( 0 ) ; } } if ( getClass ( ) . equals ( int [ ] . class ) ) { int [ ] a = { 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 0 , 5 , 5 } ; int n = a . length ; printLargestDivisible ( n , a ) ; } }
static int countWays ( int n ) { int counter = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { for ( int l = k ; l < n ; l ++ ) { if ( ( i + j + k + l ) == n ) { counter ++ ; } } } } } if ( getClass ( ) . equals ( int . class ) ) { n = 8 ; System . out . println ( countWays ( n ) ) ; } return counter ; }
static int numberOfMinutes ( int S , int S1 ) { double Min = 0 ; Min = ( ( S - S1 ) / Math . floor ( S ) ) * 60 ; return ( int ) Min ; }
public static int fn ( int n , int m , int k , int [ ] L ) { int g = Math . min ( L . length , m ) ; Arrays . sort ( L ) ; int [ ] op = new int [ n ] ; for ( int i = 0 ; i < L . length - 1 ; i ++ ) op [ i ] = L [ i + 1 ] - L [ i ] - 1 ; Arrays . sort ( op ) ; int dist = n ; for ( int gt = 0 ; gt < n ; gt ++ ) { dist += op [ gt ] ; } return dist ; }
static int onesComplement ( int n ) { final int numberOfBits = ( int ) Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << numberOfBits ) - 1 ) ^ n ; }
public static void main ( String input ) { int t = Integer . parseInt ( input ) ; for ( int test = 0 ; test < t ; test ++ ) { int w = Integer . parseInt ( input ) ; int h = Integer . parseInt ( input ) ; int n = Integer . parseInt ( input ) ; int wFirst = w ; int hFirst = h ; int num ; if ( n == 1 ) { System . out . println ( " YES " ) ; } else if ( w % 2 == 1 && h % 2 == 1 ) { System . out . println ( " NO " ) ; } else { if ( w % 2 == 0 && h % 2 == 1 ) { int count = 0 ; while ( w % 2 == 0 ) { w /= 2 ; count ++ ; } if ( w == 1 ) { num = wFirst ; } else { num = 2 * count ; } } else if ( h % 2 == 0 && w % 2 == 1 ) { int count = 0 ; while ( h % 2 == 0 ) { h /= 2 ; count ++ ; } if ( h == 1 ) { num = hFirst ; } else { num = 2 * count ; } } else if ( h % 2 == 0 && w % 2 == 0 ) { int num = 0 ; int count = 0 ; while ( w % 2 == 0 ) { w /= 2 ; count ++ ; } if ( w == 1 ) { num1 = wFirst ; } else { num1 = 2 * count ; } count = 0 ; while ( h % 2 == 0 ) { h /= 2 ; count ++ ; } if ( h == 1 ) { num2 = hFirst ; } else { num2 = 2 * count ; } num = num1 * num2 ; } if ( num >= n ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } }
static void findPoint ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( " ( " + 2 * x2 - x1 + " , " + 2 * y2 - y1 + " ) " ) ; }
public static int n = Integer . parseInt ( input ) { n ++ ; for ( ; ; ) { int a = Integer . parseInt ( input . readLine ( ) ) ; int b = Integer . parseInt ( input . readLine ( ) ) ; System . out . println ( ( Math . min ( Math . min ( a , n - a ) , Math . min ( b , n - b ) ) - 1 ) % 3 + 1 ) ; } }
static final void alter ( int x , int y ) { int x , y ; while ( ( x = x ) != 0 ) { if ( ( x == 0 ) || ( y == 0 ) ) break ; if ( ( x >= 2 * y ) ) x = x % ( 2 * y ) ; } }
static final String [ ] readInts ( ) { final int N = readInt ( ) ; final int [ ] V = readInts ( ) ; System . out . println ( solve ( N , V ) ) ; return new String [ ] { " " } ; }
public static void print ( String text ) { num = Integer . parseInt ( input . nextLine ( ) ) ; for ( int i = 0 ; i < num ; i ++ ) { lenz = Integer . parseInt ( input . nextLine ( ) ) ; String text = input . nextLine ( ) ; boolean isExist = false ; for ( int j = 0 ; j < lenz - 1 ; j ++ ) { for ( int k = j + 1 ; k < lenz ; k ++ ) { int a = text . substring ( j , k + 1 ) . indexOf ( ' a ' ) ; int b = text . substring ( j , k + 1 ) . indexOf ( ' b ' ) ; if ( ( a == b ) && ( a != - 1 ) ) { System . out . println ( f " { j + 1 } ▁ { k + 1 } " ) ; isExist = true ; break ; } } if ( isExist ) break ; } if ( ! isExist ) System . out . println ( " - 1 ▁ - 1" ) ; } }
static int mod = 1000000007 ; int inv2 = 500000004 ; int res ; int ret ; int L , R ; int a , b , r ; int a , r ; int a , r ; int b ; a = modulo ( L ) ; b = modulo ( R ) ; l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; ret = ( r % mod - l % mod ) ; if ( ( ret < 0 ) || ( ret > mod ) ) ret = ret + mod ; else ret = ret % mod ; return ret ; }
public static void unsort ( int l , int r , int [ ] a , int k ) { if ( ( k < 1 ) || ( l + 1 == r ) ) return ; k -= 2 ; int mid = ( l + r ) / 2 ; int temp = a [ mid - 1 ] ; a [ mid - 1 ] = a [ mid ] ; a [ mid ] = temp ; unsort ( l , mid , a , k ) ; unsort ( mid , r , a , k ) ; }
static final double mean ( int [ ] mid , int [ ] freq , int n ) { double sum = 0 ; double freqSum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; }
public static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }
public static int rectangleArea ( int a , int b ) { if ( a < 0 || b < 0 ) { return - 1 ; } return 2 * a * b ; }
public static int t = Integer . parseInt ( input ) { while ( t > 0 ) { t -- ; int n = Integer . parseInt ( input . readLine ( ) ) ; int l = Integer . parseInt ( input . readLine ( ) ) ; int r = Integer . parseInt ( input . readLine ( ) ) ; int k = n / l ; if ( r * k >= n ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } return t ; }
public static int getsum ( int x ) { return ( int ) ( ( x * ( x + 1 ) ) / 2 ) ; /* ▁ countJumps ▁ */ int n = Math . abs ( x ) ; int ans = 0 ; while ( ( getsum ( ans ) < n ) || ( ( getsum ( ans ) - n ) & 1 ) != 0 ) { ans ++ ; } /* ▁ if ▁ ( Class . isInstance ( Class . forName ( " java . lang . Integer " ) ) ) ▁ { STRNEWLINE ▁ int ▁ n = 9 ; STRNEWLINE ▁ System . out . println ( countJumps ( n ) ) ; STRNEWLINE ▁ } */ return ans ; }
MAX = 10 ; int lcs ( dp , arr1 , n , arr2 , m , k ) { if ( k < 0 ) return - ( 10 * 7 ) ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp . get ( n ) . get ( m ) . get ( k ) ; if ( ans != - 1 ) return ans ; ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 . get ( n - 1 ) == arr2 . get ( m - 1 ) ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = Math . max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; return ans ; } if ( Class . isPrimitive ) { k = 1 ; arr1 = new int [ ] { 1 , 2 , 3 , 4 , 5 } ; arr2 = new int [ ] { 5 , 3 , 1 , 4 , 2 } ; n = arr1 . length ; m = arr2 . length ; dp = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) dp [ i ] [ j ] [ k ] = - 1 ; System . out . println ( lcs ( dp , arr1 , n , arr2 , m , k ) ) ; }
@ VisibleForTesting static void decimal ( int n , int d , int x ) { getcontext ( ) . prec = 200 ; n = Integer . parseInt ( input . nextLine ( ) ) ; d = Integer . parseInt ( input . nextLine ( ) ) ; x = Integer . parseInt ( input . nextLine ( ) ) ; long ans = 0 ; for ( int i = 1 ; i <= Integer . MAX_VALUE ; i ++ ) { BigDecimal bd = new BigDecimal ( String . valueOf ( i ) ) ; ans += bd . setScale ( 1 , BigDecimal . ROUND_HALF_UP ) . doubleValue ( ) / ( bd . doubleValue ( ) * ( d + x * BigDecimal . valueOf ( String . valueOf ( n * 2 - 1 ) ) ) / BigDecimal . valueOf ( "2" ) ) ; } System . out . println ( ans ) ; }
public static void Reverseorder ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; int p = 2 ; while ( ( p * p <= n ) && ( prime [ p ] ) ) { if ( ( prime [ p ] ) == true ) { for ( int i = ( p * 2 ) ; i <= ( n + 1 ) ; i += p ) { prime [ i ] = false ; } } p ++ ; } for ( p = n ; p >= 1 ; p -- ) { if ( ( prime [ p ] ) == false ) { System . out . print ( p + " ▁ " ) ; } } int N = 25 ; System . out . println ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) ; if ( ( N == 1 ) && ( prime [ 0 ] ) ) { System . out . println ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) ; } else { Reverseorder ( N ) ; } }
public static void pattern ( int minStars , int pHeight ) { int pSpace = pHeight - 1 ; int x = 1 ; for ( int i = 0 ; i <= pHeight ; i ++ ) { for ( int j = pSpace ; j > i ; j -- ) { System . out . print ( " ▁ " ) ; } for ( int k = 0 ; k <= minStars ; k ++ ) { System . out . print ( " * " ) ; } for ( int n = ( pHeight + pHeight - 2 ) ; n > x - 1 ; n -- ) { System . out . print ( " ▁ " ) ; } for ( int k = 0 ; k <= minStars ; k ++ ) { System . out . print ( " * " ) ; } minStars = minStars + 2 ; x = x + 2 ; System . out . println ( " " ) ; } if ( className == null ) { minStars = 1 ; pHeight = 5 ; pattern ( minStars , pHeight ) ; } }
public static void main ( String [ ] args ) { int visitorsCount = Integer . parseInt ( input . nextLine ( ) ) ; int minDay = 0 ; int maxDay = 366 ; String [ ] users = new String [ visitorsCount ] ; for ( int i = 0 ; i < visitorsCount ; i ++ ) { users [ i ] = input . nextLine ( ) ; } minDay = Integer . parseInt ( users [ 0 ] . split ( " ▁ " ) [ 1 ] ) ; maxDay = Integer . parseInt ( users [ 0 ] . split ( " ▁ " ) [ 2 ] ) ; List < String [ ] > allUsers : list = new ArrayList < String [ ] > ( ) ; for ( String user : users ) { String [ ] array = user . split ( " ▁ " ) ; allUsers . add ( array [ 0 ] , Integer . parseInt ( array [ 1 ] ) , Integer . parseInt ( array [ 2 ] ) ) ; if ( minDay > Integer . parseInt ( array [ 1 ] ) ) { minDay = Integer . parseInt ( array [ 1 ] ) ; } if ( maxDay < Integer . parseInt ( array [ 2 ] ) ) { maxDay = Integer . parseInt ( array [ 2 ] ) ; } } Map < Integer , List < String > > mapCunts = new HashMap < Integer , List < String > > ( ) ; for ( int i = minDay ; i <= maxDay ; i ++ ) { for ( String [ ] array : allUsers ) { if ( i >= array [ 1 ] && i <= array [ 2 ] ) { mapCunts . computeIfAbsent ( i , k -> new ArrayList < String > ( ) ) ; mapCunts . get ( i ) . add ( array ) ; } } } int bestMatch = 0 ; for ( List < String [ ] > users : mapCunts . values ( ) ) { int malesLen = Collections . frequency ( users , " M " ) ; int malesLenX2 = malesLen * 2 ; int femalesLen = users . size ( ) - malesLen ; int femalesLenX2 = femalesLen * 2 ; if ( ( malesLen > femalesLen || malesLen == femalesLen ) && bestMatch < femalesLenX2 ) { bestMatch = femalesLenX2 ; } else if ( ( femalesLen > males
public static int distanceSum ( int [ ] x , int [ ] y , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; } } return sum ; }
static final int MAX = 1000000 ; { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; }
public static long fib ( int n ) { double phi = ( ( 1 + ( 5 * ( 1 / 2 ) ) ) / 2 ) ; return Math . round ( ( phi * n ) / ( 5 * ( 1 / 2 ) ) ) ; }
static int fib ( int n ) { final double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; }
public static void m ( int n , String input ) { int [ ] k = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String a1 = input . substring ( 0 , i ) ; String a2 = input . substring ( i ) ; int c = input . substring ( i ) ; int d = input . substring ( i ) ; } }
static int compareStrings ( String str1 , String str2 ) { int i = 0 ; while ( i < str1 . length ( ) - 1 && str1 . charAt ( i ) == str2 . charAt ( i ) ) { i ++ ; } if ( str1 . charAt ( i ) > str2 . charAt ( i ) ) { return - 1 ; } return str1 . compareTo ( str2 ) ; /* ▁ search ▁ string ▁ */ int mid = ( last + first ) / 2 ; if ( arr [ mid ] . length ( ) == 0 ) { int left = mid - 1 , right = mid + 1 ; while ( true ) { if ( left < first && right > last ) { return - 1 ; } if ( right <= last && arr [ right ] . length ( ) != 0 ) { mid = right ; break ; } if ( left >= first && arr [ left ] . length ( ) != 0 ) { mid = left ; break ; } right ++ ; left -- ; } } /* ▁ compare ▁ string ▁ */ if ( compareStrings ( string , arr [ mid ] ) == 0 ) { return mid ; } if ( compareStrings ( string , arr [ mid ] ) < 0 ) { /* ▁ search ▁ string ▁ */ return searchStr ( arr , string , mid + 1 , last ) ; } /* ▁ compare ▁ string ▁ */ if ( getClass ( ) . getName ( ) . equals ( " java . lang . String " ) ) { String [ ] arr = { " for " , " " , " " , " geeks " , " ide " , " practice " , " " , " quiz " , " " , " " } ; String string = " quiz " ; int n = arr . length ; System . out . println ( searchStr ( arr , string , 0 , n - 1 ) ) ; } return - 1 ; }
; a , b = input . split ( " ; " ) ; b = Integer . parseInt ( b [ 0 : b . length - 1 ] ) ; System . out . println ( ( int ) a + b ) ; }
public static int [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]
public static int solve ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; String a = input . nextLine ( ) ; String b = new String ( a ) ; return solve ( n , b ) ; }
static int sumAP ( int n , int d ) { n = ( int ) ( n / d ) ; return ( n ) * ( 1 + n ) * ( d / 2 ) ; }
public static void solve ( ) { int t = Integer . parseInt ( input . readLine ( ) ) ; if ( t == 0 ) break ; int n = Integer . parseInt ( input . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int s = Integer . parseInt ( input . readLine ( ) ) ; int f = Integer . parseInt ( input . readLine ( ) ) ; t -= f - s ; } if ( t < 1 ) { System . out . println ( " OK " ) ; } else { System . out . println ( t ) ; } }
public static int fact ( int num ) { int fact = 1 ; while ( ( num > 1 ) && ( num < 2 ) ) { fact = fact * num ; num = num - 1 ; } /* catalan ( n ) */ int n = 5 ; int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; for ( int k = 0 ; k < n ; k ++ ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ k ] ) { s ++ ; } } int catalanLeftBST = catalan ( s ) ; int catalanRightBST = catalan ( n - s - 1 ) ; int totalBST = catalanRightBST * catalanLeftBST ; System . out . print ( totalBST ) ; } return fact ; }
public static int get ( ) { return Collections . parseInt ( input . nextLine ( ) ) ; /* ▁ intput ▁ */ int intput = Integer . parseInt ( input . nextLine ( ) ) ; /* ▁ main ▁ */ }
public static int get ( ) { return Collections . parseInt ( input . nextLine ( ) ) ; /* ▁ intput ▁ */ int intput = Integer . parseInt ( input . nextLine ( ) ) ; /* ▁ main ▁ loop ▁ */ for ( ; ; ) { int a = get ( ) ; if ( ( a > 1 ) && ( a >= a ) ) { System . out . println ( a - a ) ; } else { System . out . println ( 1 ) ; } } }
static int countWays ( int n , int [ ] arr ) { int [ ] count = new int [ n + 1 ] ; Arrays . fill ( count , 1 ) ; if ( ( n == 0 ) || ( arr . length == 0 ) ) { return 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { int no_ways = 0 ; for ( int j : arr ) { if ( ( i - j >= 0 ) && ( i < n ) ) no_ways += count [ i - j ] ; count [ i ] = no_ways ; } } return count [ n ] ; }
public static void main ( ) { int L = Integer . parseInt ( input . readLine ( ) ) ; if ( L == 0 ) break ; int a = 0 ; int b = 0 ; int c = 0 ; for ( ; ; ) { a ++ ; int M = Integer . parseInt ( input . readLine ( ) ) ; int N = Integer . parseInt ( input . readLine ( ) ) ; b += M - N ; if ( c == 0 && b >= L ) c = a ; } System . out . println ( c > 0 ? c : " NA " ) ; }
public static void for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { int a , b , c ; a = Integer . parseInt ( input . nextLine ( ) ) ; b = Integer . parseInt ( input . nextLine ( ) ) ; c = Integer . parseInt ( input . nextLine ( ) ) ; a = new Integer ( a ) ; b = new Integer ( b ) ; c = new Integer ( c ) ; if ( c - a <= 2 ) { System . out . println ( 0 ) ; } else { System . out . println ( 2 * ( c - a - 2 ) ) ; } }
public static void n ( int b , int d ) { int [ ] a = new int [ ] { n } ; int waste = 0 ; int num = 0 ; for ( int i : a ) { if ( i <= b ) { waste += i ; } if ( waste > d ) { num ++ ; waste = 0 ; } } System . out . println ( num ) ; }
static int binarySearch ( int [ ] arr , int low , int high , int key ) { if ( ( high < low ) || ( low > high ) ) return - 1 ; long mid = ( low + high ) / 2 ; if ( ( key == arr [ ( int ) mid ] ) ) return mid ; if ( ( key > arr [ ( int ) mid ] ) ) return binarySearch ( arr , low , ( int ) mid - 1 , key ) ; return - 1 ; }
public static void equalXorSum ( int [ ] arr , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( ( Sum == Xor ) && ( arr . length == n ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } if ( getClass ( ) . isArray ( ) ) { arr = new int [ ] { 6 , 3 , 7 , 10 } ; n = arr . length ; equalXorSum ( arr , n ) ; } }
private static Function < String , Integer > inl = new Function < String , Integer > ( ) { @ Override public Integer apply ( String input ) { return Integer . parseInt ( input ) ; } }
static void findPairs ( int arr [ ] , int n ) { int cntEven = 0 ; int cntOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 ) == 0 ) { cntEven ++ ; } else { cntOdd ++ ; } } int evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; int oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; System . out . println ( " Odd ▁ pairs ▁ = ▁ " + oddPairs ) ; System . out . println ( " Even ▁ pairs ▁ = ▁ " + evenPairs ) ; } if ( getClass ( ) . getClassLoader ( ) == null ) { arr = Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ; n = arr . length ; findPairs ( arr , n ) ; }
static final int minBroadcastRange ( int [ ] houses , int [ ] towers , int n , int m ) { int leftTower = - Integer . MAX_VALUE - 1 ; int rightTower = towers [ 0 ] ; int j = 0 , k = 0 ; int minRange = 0 ; while ( ( j < n ) && ( k < maxRange ) ) { int localMax ; if ( ( houses [ j ] < rightTower ) && ( k < maxRange ) ) { left = houses [ j ] - leftTower ; right = rightTower - houses [ j ] ; if ( left < right ) { localMax = left ; } else { localMax = right ; } if ( ( localMax > minRange ) && ( minRange > maxRange ) ) { minRange = maxRange ; } j ++ ; } else { leftTower = towers [ k ] ; if ( ( k < m - 1 ) && ( k < maxRange ) ) { k ++ ; rightTower = towers [ k ] ; } else { rightTower = Integer . MAX_VALUE ; } } } if ( className == null ) { int [ ] a = { 12 , 13 , 11 , 80 } ; int [ ] b = { 4 , 6 , 15 , 60 } ; n = a . length ; m = b . length ; int max = minBroadcastRange ( a , b , n , m ) ; System . out . println ( max ) ; } return minRange ; }
static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
public static int n , int m , int z ; n = input . nextInt ( ) ; m = input . nextInt ( ) ; z = input . nextInt ( ) ; n1 = n ; m1 = m ; kill = 0 ; calls = new ArrayList < > ( ) ; artists = new ArrayList < > ( ) ; return kill ; }
static public int solve ( int [ ] list , int m ) { _allinput = new int [ list . length ] ; for ( int in = 0 ; in < list . length ; in ++ ) { _allinput += list [ in ] ; } return _allinput . length ; }
public static int n ( int n , int wmax ) { int [ ] [ ] U = new int [ n ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { int v = Integer . parseInt ( input . nextLine ( ) ) ; int w = Integer . parseInt ( input . nextLine ( ) ) ; int u = v / w ; U [ i ] = new int [ ] { - u , v , w } ; } Arrays . sort ( U ) ; int remains = wmax ; int i = 0 ; int ans = 0 ; while ( true ) { try { if ( remains > U [ i ] [ 2 ] ) { remains -= U [ i ] [ 2 ] ; ans += U [ i ] [ 1 ] ; i ++ ; } else { ans += U [ i ] [ 1 ] * remains / U [ i ] [ 2 ] ; break ; } } catch ( Exception e ) { break ; } } System . out . println ( ans ) ; return ans ; }
static long getSingle ( int [ ] arr , int n ) { long ones = 0 ; long twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; } return ones ; }
@ VisibleForTesting static int maxdiff ( int [ ] arr , int n ) { int [ ] freq = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) { ans = Math . max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ; } else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) { ans = Math . max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ; } } } arr = new int [ ] { 3 , 1 , 3 , 2 , 3 , 2 } ; n = arr . length ; System . out . println ( maxdiff ( arr , n ) ) ; }
static final int [ ] [ ] getNegativeInstances ( ) { final int n = Integer . parseInt ( input . nextLine ( ) ) ; final int m = Integer . parseInt ( input . nextLine ( ) ) ; final List < List < Integer > > l = new ArrayList < > ( ) ; for ( int a = 0 ; a < n ; a ++ ) { final List < Integer > l1 = new LinkedList < > ( ) ; l1 . add ( input . nextLine ( ) ) ; l . add ( l1 ) ; } int ans = 0 ; final int [ ] [ ] m1 = new int [ n ] [ m ] ; int count = 0 ; int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( l [ i ] [ j ] < 0 ) || ( l [ i ] [ j ] > 0 ) ) { count ++ ; mini = Math . min ( mini , - l [ i ] [ j ] ) ; ans += - l [ i ] [ j ] ; } else { mini = Math . min ( mini , Math . abs ( l [ i ] [ j ] ) ) ; ans += Math . abs ( l [ i ] [ j ] ) ; } } } if ( ( count % 2 ) == 0 ) System . out . println ( ans ) ; else System . out . println ( ans - 2 * mini ) ; return m1 ; }
static void makeAP ( int [ ] arr , int n ) { int initial_term = 0 , common_difference ; if ( ( n == 3 ) && ( arr [ 2 ] == arr [ 1 ] ) ) { common_difference = arr [ 2 ] - arr [ 1 ] ; initial_term = arr [ 1 ] - common_difference ; } else if ( ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) && ( arr [ 3 ] == arr [ 2 ] ) ) { common_difference = arr [ 2 ] - arr [ 1 ] ; initial_term = arr [ 1 ] - common_difference ; } else { common_difference = ( arr [ 3 ] - arr [ 0 ] ) / 3 ; initial_term = arr [ 0 ] ; } }
static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( ( y + x ) % ( y ^ x ) ) == 0 ) { count ++ ; } } } return count ; }
static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( ( y * x ) % ( y + x ) ) == 0 ) { count ++ ; } } } return count ; }
public static int longestPalindrome ( String s ) { int ans = 0 ; Map < Character , Integer > charMap = new HashMap < > ( ) ; for ( char c : s . toCharArray ( ) ) { charMap . put ( c , charMap . get ( c ) + 1 ) ; } for ( Character c : Collections . list ( charMap . keySet ( ) ) ) { if ( charMap . get ( c ) % 2 == 0 ) { ans += charMap . remove ( c ) ; } else { ans += charMap . get ( c ) / 2 * 2 ; } } if ( charMap . size ( ) != 0 ) { ans ++ ; } return ans ; }
static int binomialCoeff ( int n , int k ) { long res = 1 ; if ( ( k > n - k ) && ( n < k ) ) { k = n - k ; } for ( int i = 0 ; i < k ; i ++ ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return ( int ) res ; }
static final PriorityQueue < Integer > infinite = new PriorityQueue < Integer > ( ) { private static final long serialVersionUID = 1L ; @ Override public Integer getValue ( ) { return Integer . valueOf ( input . nextLine ( ) ) ; } @ Override public Iterable < Integer > getValues ( ) { return ImmutableList . copyOf ( input . nextLine ( ) . split ( " ▁ " ) ) ; } @ Override public Iterable < Integer > inlst ( ) { return Arrays . asList ( input . nextInt ( ) ) ; } @ Override public Iterable < Integer > inlsts ( ) { return Arrays . asList ( input . nextInt ( ) ) ; } @ Override public Integer in ( ) { return Integer . valueOf ( input . nextInt ( ) ) ; } @ Override public Integer inps ( ) { return Integer . valueOf ( input . nextInt ( ) ) ; } @ Override public Iterable < Integer > instr ( ) { return input ; } @ Override public Iterable < Integer > stlst ( ) { return Arrays . asList ( input . nextInt ( ) ) ; } @ Override public boolean help ( int a , int b , List < Integer > l ) { List < Integer > tot = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < b ; ++ i ) tot . add ( l . subList ( i * a , i * a + a ) ) ; for ( int i : zip ( tot ) ) if ( Integer . valueOf ( ( i ) ) == b ) return true ; return false ; } @ Override public void solve ( ) { List < Integer > tot = new ArrayList < Integer > ( ) ; List < Integer > x = instr ( ) ; int [ ] s = new int [ x . size ( ) ] ; for ( int i = 0 ; i < x . size ( ) ; ++ i ) { if ( x . get ( i ) == ' O ' ) s [ i ] = 0 ; else s [ i ] = 1 ; } for ( int i = 1 ; i < 13 ; ++ i ) if ( 12 % i == 0 ) if ( help ( i , 12 / i , s ) ) tot . add ( new Integer ( 12 / i ) ) ; System . out . print ( tot . size ( ) ) ; for ( int a = 0 ; a < tot . size ( ) ; ++ a ) { int b = tot . get ( a ) ; System . out . print ( f " { a } x { b } " ) ;
static final String input ( ) { final String input = System . getProperty ( " line . separator " ) ; final Function < Integer , Integer > ii = new Function < Integer , Integer > ( ) { @ Override public Integer apply ( Integer input ) { return Integer . parseInt ( input ) ; } } ; final Function < Integer , List < Integer > > mi = new Function < Integer , List < Integer > > ( ) { @ Override public List < Integer > apply ( Integer input ) { return Lists . newArrayList ( ) ; } } ; @ Override public String toString ( ) { return input ; } }
static boolean isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) { return false ; } else { return true ; } n = 10 ; if ( isSumOfPowersOfTwo ( n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return true ; }
static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { Stack < Integer > s = new Stack < Integer > ( ) ; if ( ( i <= n ) && ( n <= s . peek ( ) ) ) { s . push ( i ) ; result ++ ; } while ( s . size ( ) != 0 ) { int tp = s . peek ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j <= 10 ; j ++ ) { int x = tp * 10 + j ; if ( ( x <= n ) && ( n <= x ) ) { s . push ( x ) ; result ++ ; } } } } return result ; }
public static int maxAverageOfPath ( int [ ] [ ] cost , int N ) { int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; } for ( int j = 1 ; j < N ; j ++ ) { dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; } } return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
public static void formSieve ( ) { int MAX = 1000000 ; int [ ] sieve_Prime = new int [ MAX + 4 ] ; int [ ] sieve_Count = new int [ MAX + 4 ] ; for ( int i = 0 ; i < sieve_Count . length ; i ++ ) { sieve_Prime [ i ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_Count [ i ] ++ ; } } } }
public static int N = Integer . parseInt ( input ) { int N = Integer . parseInt ( input . readLine ( ) ) ; int K = Integer . parseInt ( input . readLine ( ) ) ; int T = Integer . parseInt ( input . readLine ( ) ) ; int U = Integer . parseInt ( input . readLine ( ) ) ; int V = Integer . parseInt ( input . readLine ( ) ) ; int L = Integer . parseInt ( input . readLine ( ) ) ; int ans = 0 ; int l = 0 ; int t = 0 ; int k = 0 ; for ( ; ; ) { int d = 0 ; if ( N == L ) { d = L ; } else { d = Integer . parseInt ( input . readLine ( ) ) ; } int length = d - l ; l = d ; while ( t > 0 || k > 0 ) { if ( t > 0 ) { if ( t * V >= length ) { int tmp = ( t * V - length ) / V ; ans += t - tmp ; t = tmp ; if ( K > k ) { k ++ ; } else { t = T ; } length = 0 ; break ; } else { length = length - t * V ; ans += t ; t = 0 ; if ( k > 0 ) { k -- ; t = T ; } } } else { k -- ; t = T ; } } if ( length > 0 ) { ans += length / U ; if ( K > k ) { k ++ ; } else { t = T ; } } } System . out . println ( ans ) ; return ans ; }
static int waysToSplit ( String s ) { int n = s . length ( ) ; int answer = 0 ; int [ ] prefix = new int [ n ] ; int [ ] suffix = new int [ n ] ; int [ ] seen = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int prev = ( i - 1 >= 0 ) ? prefix [ i - 1 ] : 0 ; if ( ( seen [ ( int ) s . charAt ( i ) - ( int ) ' a ' ) ] == 0 ) { prefix [ i ] += ( prev + 1 ) ; } else { prefix [ i ] = prev ; } seen [ ( int ) s . charAt ( i ) - ( int ) ' a ' ] = 1 ; } seen [ n ] = 0 ; suffix [ n - 1 ] = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { int prev = suffix [ i ] ; if ( ( seen [ ( int ) s . charAt ( i ) - ( int ) ' a ' ) ] == 0 ) { suffix [ i - 1 ] += ( prev + 1 ) ; } else { suffix [ i - 1 ] = prev ; } seen [ ( int ) s . charAt ( i ) - ( int ) ' a ' ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( prefix [ i ] == suffix [ i ] ) && ( ( i < n - 1 ) || ( ( i > n - 1 ) && ( ( int ) s . charAt ( i ) - ( int ) ' a ' ) ) ) ) { answer ++ ; } } return answer ; }
public static String compute ( ) { final int TURNS = 15 ; final int [ ] [ ] ways = new int [ TURNS + 1 ] [ ] ; ways [ 0 ] = new int [ TURNS + 1 ] ; ways [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= TURNS ; i ++ ) { int [ ] row = new int [ i + 1 ] ; for ( int j = 0 ; j < i + 1 ; j ++ ) { int temp = 0 ; if ( j < i ) { temp = ways [ i - 1 ] [ j ] * i ; } if ( j > 0 ) { temp += ways [ i - 1 ] [ j - 1 ] ; } row [ j ] = temp ; } ways [ i ] = row ; } int numer = ways [ TURNS / 2 + 1 ] [ 0 ] ; for ( int i = TURNS / 2 + 1 ; i <= TURNS ; i ++ ) { int denom = Math . factorial ( TURNS + 1 ) ; return String . valueOf ( denom / numer ) ; } if ( __name__ . equals ( " java . util . concurrent . ThreadPoolExecutor " ) ) { System . out . println ( compute ( ) ) ; } return null ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] t = new int [ n + 1 ] ; for ( int i = 0 ; i < t . length ; i ++ ) t [ i ] = i ; int [ ] a = new int [ n + 1 ] ; for ( int i = 0 ; i < a . length ; i ++ ) a [ i ] = i ; for ( int i = 1 ; i <= n ; i ++ ) { if ( t [ i ] == 1 ) { ArrayList < Integer > crt = new ArrayList < Integer > ( ) ; crt . add ( i ) ; int x = a [ i ] ; while ( cnt [ x ] == 1 ) { crt . add ( x ) ; x = a [ x ] ; } if ( crt . size ( ) > ans . size ( ) ) ans = crt . toArray ( ) ; } } }
public static void merge ( int [ ] ar1 , int [ ] ar2 , int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int last = ar1 [ m - 1 ] ; int j = m - 2 ; while ( ( j >= 0 ) && ar1 [ j ] > ar2 [ i ] ) { ar1 [ j + 1 ] = ar1 [ j ] ; j -- ; } if ( ( j != m - 2 ) || last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } int [ ] ar1 = { 1 , 5 , 9 , 10 , 15 , 20 } ; int [ ] ar2 = { 2 , 3 , 8 , 13 } ; m = ar1 . length ; n = ar2 . length ; merge ( ar1 , ar2 , m , n ) ; System . out . print ( " After ▁ Merging ▁ \n First ▁ Array : ▁ " ) ; System . out . println ( ar1 ) ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) { return b ; } return gcd ( b % a , a ) ; /* ▁ same ▁ remainder ▁ */ }
public static int aa ( ) { int b = Integer . parseInt ( input . readLine ( ) ) ; int c = Integer . parseInt ( input . readLine ( ) ) ; int [ ] ls = { aa , b , c } , sum = 0 ; Arrays . sort ( ls ) ; if ( ls [ 1 ] - ls [ 0 ] < d ) sum += ( d - ls [ 1 ] + ls [ 0 ] ) ; return sum ; }
public static int [ ] [ ] [ ] dp = new int [ 5 ] [ 501 ] [ 501 ] ; /* ▁ Count ▁ the ▁ number ▁ of ▁ ways ▁ */ int n = 0 ; for ( int i = 0 ; i < 501 ; i ++ ) { if ( ( parts == 0 ) && ( n == 0 ) ) { return 1 ; } if ( ( n <= 0 ) || ( parts <= 0 ) ) { return 0 ; } if ( ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) ) { return dp [ n ] [ nextPart ] [ parts ] ; } int ans = 0 ; for ( int i = nextPart ; i <= n ; i ++ ) { ans += countWaysUtil ( n , parts - 1 , i ) ; } }
public static int findK ( int a , int b ) { if ( ( ( a + b ) % 2 ) == 0 ) { return ( ( a + b ) / 2 ) ; } return - 1 ; }
static final int [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [
public static boolean isValidString ( String str ) { int [ ] freq = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ ( int ) str . charAt ( i ) - ' a ' ] ++ ; } int freq1 = 0 ; int countFreq1 = 0 ; for ( int i = 0 ; i < CHARS ; i ++ ) { if ( ( freq [ i ] != 0 ) && ( ( freq [ i ] == ' a ' ) || ( freq [ i ] == ' b ' ) || ( freq [ i ] == ' a ' ) || ( freq [ i ] == ' b ' ) || ( freq [ i ] == ' c ' ) || ( freq [ i ] == ' d ' ) || ( freq [ i ] == ' e ' ) || ( freq [ i ] == ' f ' ) || ( freq [ i ] == ' f ' ) || ( freq [ i ] == ' f ' ) || ( freq [ i ] == ' e ' ) || ( freq [ i ] == ' f ' ) || ( freq [ i ] == ' e ' ) || ( freq [ i ] == ' f ' ) || ( freq [ i ] == ' e ' ) || ( freq [ i ] == ' f ' ) || ( freq [ i ] == ' e ' ) || ( freq [ i ] == ' f ' ) || ( freq [ i ] == ' e ' ) || ( freq [ i ] == ' f ' ) || ( freq [ i ] == ' e ' ) ) { ++ countFreq1 ; } else { ++ countFreq2 ; ++ freq2 ; } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( ( freq [ k ] != 0 ) && ( ( freq [ k ] == freq1 ) || ( freq [ k ] == freq2 ) ) ) { ++ countFreq2 ; } else { return false ; } } if ( ( countFreq1 > 1 ) && ( countFreq2 > 1 ) ) { return false ; } return true ; }
public static int t = Integer . parseInt ( input ) { while ( t > 0 ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { if ( i % 2 == 0 ) { if ( sb . charAt ( i ) == ' a ' ) { sb . append ( ' b ' ) ; } else { sb . append ( ' a ' ) ; } } else { if ( sb . charAt ( i ) == ' z ' ) { sb . append ( ' y ' ) ; } else { sb . append ( ' z ' ) ; } } } System . out . println ( sb . toString ( ) ) ; t -- ; } return t ; }
static int findMinimumSubsequences ( String A , String B ) { int numberOfSubsequences = 1 ; int sizeOfB = B . length ( ) ; int sizeOfA = A . length ( ) ; int inf = 1000000 ; int [ ] [ ] next = new int [ sizeOfB ] [ 26 ] ; for ( int i = 0 ; i < sizeOfB ; i ++ ) { next [ ( B . charAt ( i ) - ' a ' ) ] [ i ] = i ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = sizeOfB - 2 ; j >= 0 ; j -- ) { if ( ( next [ i ] [ j ] == inf ) && ( next [ i ] [ j ] == inf ) ) { next [ i ] [ j ] = next [ i ] [ j + 1 ] ; } } } int pos = 0 ; int i = 0 ; while ( ( i < sizeOfA ) && ( pos < sizeOfA ) ) { if ( ( pos == 0 ) && ( next [ ( A . charAt ( i ) - ' a ' ) ] [ pos ] == inf ) ) { numberOfSubsequences = - 1 ; break ; } else if ( ( pos < sizeOfB ) && ( next [ ( A . charAt ( i ) - ' a ' ) ] [ pos ] < inf ) ) { int nextIndex = next [ ( A . charAt ( i ) - ' a ' ) ] [ pos ] + 1 ; pos = nextIndex ; i ++ ; } else { numberOfSubsequences ++ ; pos = 0 ; } } return numberOfSubsequences ; }
static void print ( String input ) { final Scanner scanner = new Scanner ( System . in ) ; for ( ; ; ) { final int n = Integer . parseInt ( scanner . nextLine ( ) ) ; final int m = Integer . parseInt ( scanner . nextLine ( ) ) ; final int [ ] d = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { d [ i ] = Math . max ( i , n - 1 - i ) + Math . max ( j , m - 1 - j ) ; } } Arrays . sort ( d ) ; System . out . println ( Arrays . toString ( d ) ) ; } }
private static void findRank ( int [ ] arr , int length ) { System . out . print ( 1 ) ; for ( int i = 1 ; i < length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j <= i ; j ++ ) { if ( ( arr [ j ] > arr [ i ] ) && ( arr [ i ] > arr [ j ] ) ) { rank = rank + 1 ; } } System . out . print ( rank ) ; } if ( className . equals ( " java . util . Arrays " ) ) { arr = new int [ ] { 88 , 14 , 69 , 30 , 29 , 89 } ; length = arr . length ; findRank ( arr , length ) ; } }
static final void main ( String [ ] args ) { final int N = args . length ; final int H = args . length ; System . out . println ( " chkprint " ) ; final Map < Integer , String > names = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { names . put ( Integer . valueOf ( i ) , args [ i ] ) ; } System . out . println ( Arrays . toString ( names . get ( Integer . valueOf ( i ) ) ) + " ▁ = ▁ " + args [ N ] ) ; }
public static int firstkdigits ( int n , int k ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product *= n ; } while ( ( product / Math . pow ( 10 , k ) ) != 0 ) { product = product / 10 ; } return product ; }
static final int gcd ( int a , int b ) { int m ; try { do { a = input . nextInt ( ) ; b = input . nextInt ( ) ; } while ( a < b ) ; System . out . println ( Math . gcd ( Integer . parseInt ( a ) , Integer . parseInt ( b ) ) ) ; } catch ( NoSuchElementException e ) { m = 0 ; } return m ; }
static void dic = new HashMap < String , Integer > ( ) { List < String > S = new LinkedList < String > ( ) ; input ( ) ; for ( String s : S ) { if ( ! dic . containsKey ( s ) ) dic . put ( s , 1 ) ; else ++ ans ; } }
static int complement ( int num ) { int i = 0 ; int len = 0 ; double comp = 0 ; int temp = num ; while ( ( ++ i ) < num ) { num = ( int ) ( num / 10 ) ; } comp = Math . pow ( 10 , len ) - num ; return ( int ) comp ; }
static final int countUnsetBits ( int n ) { final int x = n ; n |= n > > 1 ; n |= n > > 2 ; n |= n > > 4 ; n |= n > > 8 ; n |= n > > 16 ; final double t = Math . log ( x ^ n ) ; return Math . floor ( t ) ; }
static int minOperations ( int [ ] arr , int n ) { int result = 0 ; int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i <= n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int maxi = max ( arr ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j += i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; }
static int totalWays ( int N , int M , int X ) { int [ ] [ ] dp = new int [ 2 ] [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } if ( ( X == 1 ) && ( j == 1 ) ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 1 ] = 0 ; } if ( ( X == 1 ) && ( j == 2 ) ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; } if ( className . equals ( " java . lang . String " ) ) { N = 4 ; M = 3 ; X = 2 ; System . out . println ( totalWays ( N , M , X ) ) ; } return 0 ; }
static int getMinNum ( int a , int b , int c ) { if ( ( c < a ) || ( c > b ) ) { return c ; } int x = ( ( b / c ) * c ) + c ; return x ; }
public static int N = Integer . parseInt ( input ) { String S = input ; int x = 0 ; int maxNum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == ' I ' ) x ++ ; else x -- ; if ( x > maxNum ) maxNum = x ; } return maxNum ; }
@ Operator ( OperatorType . EQUAL ) @ SuppressWarnings ( " unused " ) public static void protect ( int N , int M ) { List < List < Integer > > DP = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { DP . add ( Collections . singletonList ( Integer . parseInt ( input . nextLine ( ) ) ) ) ; } Collections . sort ( DP , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return Integer . compare ( o1 , o2 ) ; } } ) ; int nokori = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( M > DP . get ( N - i - 1 ) . get ( ) ) { M -= DP . get ( N - i - 1 ) . get ( ) ; DP . remove ( N - i - 1 ) ; } else if ( M <= DP . get ( N - i - 1 ) . get ( ) ) { nokori = ( DP . get ( N - i - 1 ) . get ( ) - M ) * DP . get ( N - i - 1 ) . get ( ) ; M = 0 ; DP . remove ( N - i - 1 ) ; break ; } } for ( int i = 0 ; i < DP . size ( ) ; i ++ ) { nokori += DP . get ( i ) . get ( ) * DP . get ( i ) . get ( ) ; } System . out . println ( nokori ) ; while ( true ) { String [ ] NM = input . nextLine ( ) . split ( " ▁ " ) ; N = Integer . parseInt ( NM [ 0 ] ) ; M = Integer . parseInt ( NM [ 1 ] ) ; if ( N == 0 ) { break ; } protect ( N , M ) ; } }
@ SafeVarargs public static < T > void heapify ( T [ ] array ) { int N = Integer . parseInt ( new String ( array [ 0 ] ) ) ; int ... A = array . length ; T [ ] L = A [ 0 ] , C = A [ N ] , R = A [ 2 * N ] ; int [ ] F = Arrays . copyOf ( L , L . length ) ; heapify ( L ) ; for ( T c : C ) F [ N ] = c - heapify ( L ) ; }
static int countWays ( int arr [ ] , int m , int N ) { int [ ] count = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) count [ i ] = 0 ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( arr [ j ] >= arr [ j ] ) ) count [ i ] += count [ i - arr [ j ] ] ; } } return count [ N ] ; }
static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) { return 1 ; } else { return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) ; } }
static void countFreq ( int [ ] a , int n ) { Map < Integer , Integer > hm = Maps . newHashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ; } int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { } }
static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 ; int possibleB = 0 ; int possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ; if ( ( numbersInRange < 3 ) || ( numbersInRange > 3 ) ) { flag = false ; } else if ( ( numbersInRange > 3 ) ) { flag = true ; if ( ( ( L % 2 ) > 0 ) && ( ( L % 2 ) == 0 ) ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } }
public static String conversion ( String charSet , String str1 ) { String s2 = " " ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { s2 += alphabets . charAt ( charSet . indexOf ( str1 . charAt ( i ) ) ) ; } return s2 ; }
static HashSet < Integer > s = new HashSet < Integer > ( ) { private static final long serialVersionUID = 1L ; { if ( k == count ) { s . add ( num ) ; return ; } for ( int i = 0 ; i <= n ; i ++ ) { generateNumber ( count + 1 , a , n , num + a [ i ] , k ) ; } } private static void printDistinctIntegers ( int k , int [ ] a , int n ) { generateNumber ( 0 , a , n , 0 , k ) ; System . out . println ( " The " + s . size ( ) + " ▁ distinct ▁ integers ▁ are : " ) ; for ( int i : new ArrayList < Integer > ( s ) ) { System . out . print ( i + " ▁ " ) ; } } }
public static int product ( int x ) { int prod = 1 ; while ( ( x = x / 10 ) > 0 ) { prod *= ( x % 10 ) ; x /= 10 ; } return prod ; /* ▁ find ▁ number ▁ */ String a = Integer . toString ( l ) ; String b = Integer . toString ( r ) ; int ans = r ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) { if ( ( b . charAt ( i ) == '0' ) || ( b . charAt ( i ) == '9' ) ) continue ; char [ ] curr = new char [ b . length ( ) ] ; b . getChars ( i , i , curr . length ) ; curr [ i ] = Integer . toString ( ( ( ( int ) curr [ i ] ) - 1 ) - 1 ) + '0' ; for ( int j = i + 1 ; j < curr . length ; j ++ ) { curr [ j ] = Integer . toString ( '9' ) ; } int num = 0 ; for ( char c : curr ) { num = num * 10 + ( Integer . parseInt ( c ) - '0' ) ; } if ( ( num >= l ) && ( product ( ans ) < product ( num ) ) ) ans = num ; } return ans ; }
public static int [ ] isPrime = new int [ 100005 ] ; { isPrime [ 1 ] = false ; int i = 2 ; while ( i * i < 100005 ) { if ( ( isPrime [ i ] = true ) && ( isPrime [ i ] = false ) ) { int j = 2 * i ; while ( j < 100005 ) { isPrime [ j ] = false ; j += i ; } } i ++ ; } return null ; }
MAX = 25 ; { int [ ] arr = { 3 , 5 , 7 , 11 , 15 } ; int n = arr . length ; System . out . println ( getMinSum ( arr , n ) ) ; int [ ] bitsCount = new int [ MAX ] ; int maxBit = 0 ; int sum = 0 ; int ans = 0 ; for ( int d = 0 ; d < n ; d ++ ) { int e = arr [ d ] ; int f = 0 ; while ( ( e > 0 ) && ( e < arr [ d ] ) ) { int rem = e % 2 ; e = e / 2 ; if ( ( rem == 1 ) && ( bitsCount [ f ] == rem ) ) { bitsCount [ f ] += rem ; } f ++ ; } maxBit = Math . max ( maxBit , f ) ; } for ( int d = 0 ; d < maxBit ; d ++ ) { int temp = Math . pow ( 2 , d ) ; if ( ( bitsCount [ d ] > n / 2 ) && ( bitsCount [ d ] == 1 ) ) { ans = ans + temp ; } } for ( int d = 0 ; d < n ; d ++ ) { arr [ d ] = arr [ d ] ^ ans ; sum = sum + arr [ d ] ; } return sum ; } if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { int [ ] arr = { 3 , 5 , 7 , 11 , 15 } ; int n = arr . length ; System . out . println ( getMinSum ( arr , n ) ) ; }
public static int n ( ) { String s = input . nextLine ( ) ; ArrayList < String > a = new ArrayList < String > ( ) ; a . add ( " " ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( a . get ( a . size ( ) - 1 ) . equals ( " " ) && c == ' ▁ ' ) { continue ; } a . get ( a . size ( ) - 1 ) += c ; if ( c == ' ? ' || c == ' ! ' || c == ' . ' ) { a . add ( " " ) ; } } int ans = 0 ; int last = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { if ( a . get ( i ) . length ( ) > n ) { System . out . println ( " Impossible " ) ; exit ( 0 ) ; } int add = i + 1 != a . get ( i ) . length ( ) ? a . get ( i ) . length ( ) + 1 : a . get ( i ) . length ( ) ; if ( i == 0 || ( last + add ) > n ) { ans ++ ; last = a . get ( i ) . length ( ) ; } else { last += add ; } } System . out . println ( ans ) ; return ans ; }
private static int [ ] getMinimumEnergySpent ( int n , int [ ] shortcuts ) { final int [ ] energySpent = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) energySpent [ i ] = i ; final Queue < Integer > queue = new LinkedList < Integer > ( ) ; while ( queue . size ( ) > 0 ) { final int idx = queue . poll ( ) ; if ( idx < n - 1 && energySpent [ idx + 1 ] > energySpent [ idx ] + 1 ) { energySpent [ idx + 1 ] = energySpent [ idx ] + 1 ; queue . add ( idx + 1 ) ; } if ( idx > 0 && energySpent [ idx - 1 ] > energySpent [ idx ] + 1 ) { energySpent [ idx - 1 ] = energySpent [ idx ] + 1 ; queue . add ( idx - 1 ) ; } if ( energySpent [ idx ] + 1 < energySpent [ shortcuts [ idx ] ] ) { energySpent [ shortcuts [ idx ] ] = energySpent [ idx ] + 1 ; queue . add ( shortcuts [ idx ] ) ; } } return energySpent ; }
public static int strangeBDParty ( @ IntRange ( from = 0 , to = 100 ) int n , @ IntRange ( from = 1 , to = 100 ) int [ ] k , @ IntRange ( from = 1 , to = 100 ) int [ ] c ) { Arrays . sort ( k , Collections . reverseOrder ( ) ) ; int cost = 0 ; int l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( l < m && c [ l ] < c [ k [ i ] - 1 ] ) { cost += c [ l ] ; l ++ ; } else { cost += c [ k [ i ] - 1 ] ; } } return cost ; } int rep = Integer . parseInt ( input ( ) ) ; for ( int i = 0 ; i < rep ; i ++ ) { n = Integer . parseInt ( input ( ) ) ; m = Integer . parseInt ( input ( ) ) ; k = Integer . parseInt ( input ( ) ) ; c = Integer . parseInt ( input ( ) ) ; System . out . println ( strangeBDParty ( n , m , k , c ) ) ; }
static int findMaximumNum ( int arr [ ] , int n ) { int i = n ; while ( ( i >= 1 ) && ( arr [ i ] <= arr [ n - 1 ] ) ) { int count = 0 ; for ( int j = 0 ; j <= n ; j += 1 ) { if ( ( i <= arr [ j ] ) && ( arr [ j ] <= arr [ n - 1 ] ) ) { count ++ ; } } if ( ( count >= i ) && ( arr [ j ] <= arr [ n - 1 ] ) ) { return i ; } i -- ; } return 1 ; }
private static String [ ] s ( ) { s = new String [ Integer . parseInt ( input . nextLine ( ) ) ] ; for ( int i = 0 ; i < s . length ; i ++ ) { String [ ] l = input . nextLine ( ) . split ( " ▁ " ) ; int a = Integer . parseInt ( l [ 1 ] ) ; int b = Integer . parseInt ( l [ 2 ] ) + 1 ; switch ( l [ 0 ] ) { case " print " : System . out . print ( ( String ) s . substring ( a , b ) ) ; break ; case " reverse " : s [ a ] = new String [ b ] ; s [ a ] = new String ( s . substring ( a , b ) ) ; break ; case " replace " : s [ a ] = s [ b ] ; break ; } } return s ; }
public static int solve ( int [ ] A , int n ) { int [ ] [ ] dp = new int [ 2000 ] [ 2000 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ i ] = 0 ; } int flag = 1 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += A [ i ] ; } for ( int i = - sum ; i <= sum ; i ++ ) { dp [ 0 ] [ i ] = 10 * 9 ; } dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = - sum ; j <= sum ; j ++ ) { dp [ flag ] [ j ] = 10 * 9 ; if ( ( j - A [ i - 1 ] <= sum ) && ( j - A [ i - 1 ] >= - sum ) ) { dp [ flag ] [ j ] = dp [ flag ^ 1 ] [ j - A [ i - 1 ] ] ; } if ( ( j + A [ i - 1 ] <= sum ) && ( j + A [ i - 1 ] >= - sum ) && ( dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] != 10 * 9 ) ) { dp [ flag ] [ j ] = Math . min ( dp [ flag ] [ j ] , dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] + 1 ) ; } } flag = flag ^ 1 ; } for ( int i = 0 ; i < sum + 1 ; i ++ ) { if ( ( dp [ flag ^ 1 ] [ i ] != 10 * 9 ) && ( dp [ flag ^ 1 ] [ i ] != 0 ) ) { return dp [ flag ^ 1 ] [ i ] ; } } return n - 1 ; }
public static String getInput ( ) { StringBuilder sb = new StringBuilder ( ) ; while ( true ) { try { sb . append ( input . readLine ( ) ) ; } catch ( IOException e ) { break ; } } LinkedList < String > N = new LinkedList < > ( ) ; for ( int l = 0 ; l < N . size ( ) ; l ++ ) { double [ ] Points = new double [ N . get ( l ) . length ( ) ] ; for ( int i = 0 ; i < N . get ( l ) . length ( ) ; i ++ ) { Points [ i ] = Double . parseDouble ( N . get ( l ) . substring ( i , i + 1 ) ) ; } int [ ] P = new int [ 8 ] ; for ( int i = 0 ; i < P . length ; i ++ ) { P [ i ] = ( int ) ( Points [ i ] * 10 * 5 ) ; } int [ ] AB = { P [ 2 ] - P [ 0 ] , P [ 3 ] - P [ 1 ] } ; int [ ] CD = { P [ 6 ] - P [ 4 ] , P [ 7 ] - P [ 5 ] } ; if ( AB [ 0 ] * CD [ 0 ] + AB [ 1 ] * CD [ 1 ] == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } return sb . toString ( ) ; }
public static void fizzBuzz ( ) { int c = 1 ; StringBuilder sb = new StringBuilder ( ) ; do { String res = " " ; if ( c % 3 == 0 ) { res = res + " Fizz " ; } if ( c % 5 == 0 ) { res = res + " Buzz " ; } if ( res . isEmpty ( ) ) { sb . append ( c ) ; } else { sb . append ( res ) ; } c ++ ; } while ( true ) ; int m = Integer . parseInt ( input . readLine ( ) ) ; int n = Integer . parseInt ( input . readLine ( ) ) ; if ( m == 0 ) break ; LinkedList < Integer > player = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { player . add ( i ) ; } int p = 0 ; Fizz fb = fizzBuzz ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int in = input . nextInt ( ) ; if ( player . size ( ) > 1 ) { if ( in != ( ( Fizz ) fb ) . next ( ) ) { player . remove ( p ) ; p = p % player . size ( ) ; } else { p = ( p + 1 ) % player . size ( ) ; } } } String result = String . valueOf ( player . get ( 0 ) + 1 ) ; if ( player . size ( ) > 1 ) { for ( int pi = 1 ; pi < player . size ( ) ; pi ++ ) { result += " ▁ " + String . valueOf ( pi + 1 ) ; } } System . out . println ( result ) ; }
public static int [ ] [ ] l = new int [ 1001 ] [ 1001 ] ; for ( int i = 0 ; i < 1001 ; i ++ ) { for ( int j = 0 ; j < 1001 ; j ++ ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } }
public static int a ( ) { int b = 0 ; int c = 0 ; int d = 0 ; return ( max ( 0 , min ( b , d ) - max ( a , c ) ) ) ; }
static final void calculate ( int [ ] a , int [ ] b , int n , int m ) { double mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) { if ( ( b [ i ] != 0 ) ) mul = mul * b [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { } }
public static int n = Integer . parseInt ( input ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; int c = Integer . parseInt ( input . nextLine ( ) ) ; return a - b + b - c ; }
@ VisibleForTesting static void input ( ) { final Scanner input = new Scanner ( System . in ) ; for ( ; ; ) { final int n = input . nextInt ( ) ; final String s = input . next ( ) ; int ans = 0 ; int left = 0 , right = 0 ; int i = 0 ; while ( i < n && s . charAt ( i ) != ' > ' ) { i ++ ; } int j = n - 1 ; while ( j >= 0 && s . charAt ( j ) != ' < ' ) { j -- ; } System . out . println ( Math . min ( i , n - j - 1 ) ) ; } }
static final int log2 ( ) { int n = Integer . parseInt ( input ( ) ) ; int x = 1 ; while ( Math . log2 ( n ) % 1 != 0 ) { x ++ ; n -= 2 * ( ( int ) Math . log2 ( n ) ) ; } return x ; }
public static void pSpeed ( ) { int pSpeed = Integer . parseInt ( input ( ) ) ; int dSpeed = Integer . parseInt ( input ( ) ) ; int time = Integer . parseInt ( input ( ) ) ; int wait = Integer . parseInt ( input ( ) ) ; int distence = Integer . parseInt ( input ( ) ) ; int positionP = time * pSpeed ; float positionD = 0 ; int counter = 0 ; int timeCounter = 0 ; while ( positionP < distence && dSpeed > pSpeed ) { timeD = positionP / ( dSpeed - pSpeed ) ; positionP += ( timeD * pSpeed ) ; if ( positionP >= distence ) { break ; } float tBack = positionP / dSpeed + wait ; positionP += ( tBack * pSpeed ) ; counter ++ ; } System . out . println ( counter ) ; }
public static void input ( ) { String currentTime = input ( ) ; String timeDuration = input ( ) ; int currentTimeMin = Integer . parseInt ( currentTime . substring ( 0 , 2 ) ) * 60 + Integer . parseInt ( currentTime . substring ( 3 ) ) ; int timeDurationMin = Integer . parseInt ( timeDuration . substring ( 0 , 2 ) ) * 60 + Integer . parseInt ( timeDuration . substring ( 3 ) ) ; int tMin = currentTimeMin - timeDurationMin ; if ( currentTimeMin < timeDurationMin ) { tMin = 24 * 60 - Math . abs ( tMin ) ; } String hour = tMin / 60 < 10 ? "0" + Integer . toString ( tMin / 60 ) : Integer . toString ( tMin / 60 ) ; String minute = "0" + Integer . toString ( tMin % 60 < 10 ? "0" + Integer . toString ( tMin % 60 ) : Integer . toString ( tMin % 60 ) ) ; System . out . println ( f " { hour } : { minute } " ) ; }
static int longestAlternatingSubarray ( int [ ] a , int n ) { int longest = 1 ; int cnt = 1 ; int i = 1 ; while ( i < n ) { if ( ( a [ i ] * a [ i - 1 ] ) < 0 ) { cnt = cnt + 1 ; longest = Math . max ( longest , cnt ) ; } else { cnt = 1 ; } i = i + 1 ; } return longest ; }
static void checkTypeOfTriangle ( int a , int b , int c ) { double sqa = Math . pow ( a , 2 ) ; double sqb = Math . pow ( b , 2 ) ; double sqc = Math . pow ( c , 2 ) ; if ( ( sqa == sqa + sqb ) || ( sqb == sqa + sqc ) || ( sqc == sqa + sqb ) ) { System . out . println ( " Right - angled ▁ Triangle " ) ; } else if ( ( sqa > sqc + sqb ) || ( sqb > sqa + sqc ) || ( sqc > sqa + sqb ) ) { System . out . println ( " Obtuse - angled ▁ Triangle " ) ; } else { System . out . println ( " Acute - angled ▁ Triangle " ) ; } if ( getClass ( ) . equals ( int . class ) ) { a = 2 ; b = 2 ; c = 2 ; checkTypeOfTriangle ( a , b , c ) ; } }
MAX = 100 ; String s = " GFGFG " ; int n = s . length ( ) ; countSubsequence ( s , n ) ; }
public static int N = Integer . parseInt ( input ) { List < List < Integer > > edges = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { edges . add ( Collections . singletonList ( Integer . parseInt ( input . nextLine ( ) ) ) ) ; } for ( int cx = 0 ; cx < 101 ; cx ++ ) { for ( int cy = 0 ; cy < 101 ; cy ++ ) { for ( int i = 0 ; i < N ; i ++ ) { int x = Integer . parseInt ( edges . get ( i ) . get ( 0 ) ) ; int y = Integer . parseInt ( edges . get ( i ) . get ( 1 ) ) ; int h = Integer . parseInt ( edges . get ( i ) . get ( 2 ) ) ; if ( h > 0 ) { htop = Math . abs ( x - cx ) + Math . abs ( y - cy ) + h ; } } for ( int i = 0 ; i < N ; i ++ ) { int x = Integer . parseInt ( edges . get ( i ) . get ( 0 ) ) ; int y = Integer . parseInt ( edges . get ( i ) . get ( 1 ) ) ; int h = Integer . parseInt ( edges . get ( i ) . get ( 2 ) ) ; if ( h == 0 ) { if ( htop - ( Math . abs ( x - cx ) + Math . abs ( y - cy ) ) > 0 ) break ; } if ( h > 0 ) { if ( htop - ( Math . abs ( x - cx ) + Math . abs ( y - cy ) ) != h ) break ; } } } } else { System . out . println ( cx + " ▁ " + cy + " ▁ " + htop ) ; exit ( ) ; } return 0 ; }
@ VisibleForTesting static int countSteps ( int n ) { int steps = 0 ; while ( ( n = floor ( n * ( 1 / 3 ) ) ) > 0 ) { int largest = n * ( 1 / 3 ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; }
@ VisibleForTesting static void solve ( String [ ] args ) { final Scanner input = new Scanner ( System . in ) ; final int [ ] top2 = new int [ 2 ] ; final int [ ] others = new int [ 2 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { Arrays . sort ( top2 , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { int id = input . nextInt ( ) ; double time = input . nextDouble ( ) ; return id - time ; } } ) ; top2 [ i ] = input . nextInt ( ) ; others [ i ] = input . nextInt ( ) ; } final List < Integer > othersResults = new ArrayList < > ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { final List < Integer > roundResults = new ArrayList < > ( ) ; for ( int j = 0 ; j < 8 ; j ++ ) { final String id = input . next ( ) ; final String time = input . next ( ) ; roundResults . add ( new Integer ( id ) ) ; roundResults . add ( new Double ( time ) ) ; } top2 [ 0 ] = input . nextInt ( ) ; final int [ ] othersResults . addAll ( Arrays . asList ( othersResults ) ) ; for ( int j = 0 ; j < top2 . length ; j ++ ) { System . out . println ( top2 [ j ] + " ▁ " + time ) ; } } final List < Integer > top2 = solve ( othersResults ) ; for ( int j = 0 ; j < top2 . length ; j ++ ) { final int id = top2 [ j ] ; final double time = top2 [ j ] ; System . out . println ( id + " ▁ " + time ) ; } }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = i ; return a [ i ] - a [ 0 ] ; }
public static int bitsonCount ( int x ) { return Integer . bitCount ( x ) + "1" ; /* ▁ find ▁ count ▁ */ int ans = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { x = bitsonCount ( arr [ i ] ) ; if ( ( i % x ) == 0 ) ans ++ ; } return ans ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] a = Integer . parseInt ( input . nextLine ( ) ) ; int s = Arrays . stream ( a ) . mapToInt ( Integer :: parseInt ) . sum ( ) ; if ( s % ( ( n + 1 ) * n / 2 ) != 0 ) { System . out . println ( " NO " ) ; return ; } s /= ( ( n + 1 ) * n / 2 ) ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = a [ ( i + 1 ) % n ] - a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] -= s ; } }
static int maxProd ( int N ) { if ( ( N == 0 ) || ( N == 1 ) ) { return 1 ; } if ( ( N < 10 ) || ( N > 9 ) ) { return N ; } N = 390 ; System . out . println ( maxProd ( N ) ) ; return 0 ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] s = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == 1 ) { int count = 2 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] == 1 ) { count ++ ; continue ; } else { break ; } } if ( count > max ) { max = count ; } } } System . out . println ( max ) ; }
@ Sys public static void Sys ( ) throws IOException { String input = System . getProperty ( " input " ) ; for ( int tt = 0 ; tt < Integer . parseInt ( input ) ; tt ++ ) { int n = Integer . parseInt ( input ) ; int [ ] A = new int [ 2 * n ] , B = new int [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = Integer . parseInt ( input ) ; int y = Integer . parseInt ( input ) ; if ( x == 0 ) B [ i ] = Math . abs ( y ) ; else A [ i ] = Math . abs ( x ) ; } Arrays . sort ( A ) ; Arrays . sort ( B ) ; double ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( ( B [ i ] ) * ( B [ i ] ) + ( A [ i ] ) * ( A [ i ] ) ) * ( 0.5 ) ; } System . out . println ( ans ) ; } }
static int countNonDecreasing ( int n ) { int N = 10 ; int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count = ( int ) ( count * ( N + i - 1 ) ) ; count = ( int ) ( count / i ) ; } return count ; }
static int reduceString ( String s , int l ) { int count = 1 ; int steps = 0 ; for ( int i = 1 ; i < l ; i ++ ) { if ( ( s . charAt ( i ) == s . charAt ( i - 1 ) ) ) { count ++ ; } else { steps += ( int ) ( count / 2 ) ; } } return steps ; }
public static int A = Integer . parseInt ( input ) { int B = Integer . parseInt ( input . nextLine ( ) ) ; if ( A <= B ) { System . out . println ( " Impossible " ) ; exit ( 0 ) ; } Stack < Integer > chain = new Stack < > ( ) ; int N = A + B ; /* ▁ print ▁ " ? ▁ " ▁ + ▁ i ▁ + ▁ " ▁ " ▁ + ▁ j ▁ */ return input . charAt ( 0 ) == ' Y ' ? 1 : 0 ; }
public static int [ ] [ ] x , int y , int a , int b ) { return Arrays . stream ( input . split ( ) ) . mapToInt ( Integer :: parseInt ) ; }
@ VisibleForTesting static int mult ( int a , int b ) { int mod = 1000000007 ; int ans ; /* ▁ Calculate ▁ the ▁ factors ▁ of ▁ the ▁ sum ▁ */ int cnt = 0 ; ans = 1 ; while ( ( n % 2 ) == 0 ) { cnt ++ ; n = n / 2 ; } if ( ( cnt = 1 ) != 0 ) ans = mult ( ans , ( cnt + 1 ) ) ; for ( int i = 3 ; ( i = ( int ) Math . sqrt ( n ) ) < 2 ; i += 2 ) { cnt = 0 ; while ( ( n % i ) == 0 ) { cnt ++ ; n = n / i ; } if ( ( cnt = 1 ) != 0 ) ans = mult ( ans , ( cnt + 1 ) ) ; } if ( ( n > 2 ) != 0 ) ans = mult ( ans , 2 ) ; /* ▁ Calculate ▁ the ▁ factors ▁ of ▁ the ▁ sum ▁ */ ans = ans % mod ; if ( __name__ == " java . lang . Math " ) { n = 19374857 ; mod = 17 ; System . out . println ( calculateFactors ( n ) ) ; } return ans ; }
public static String input ( ) { String s = input ( ) ; String result = " " ; int i = 0 ; while ( i < s . length ( ) ) { if ( s . charAt ( i ) == ' . ' ) { result += "0" ; } else { i ++ ; if ( s . charAt ( i ) == ' . ' ) { result += "1" ; } else { result += "2" ; } } i ++ ; } return result ; }
static int maxAbsDiff ( int [ ] arr , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } }
@ VisibleForTesting static void heapGarbage ( ) { final int BIG_NUM = 2000000000 ; final int HUGE_NUM = 99999999999999999 ; final int MOD = 1000000007 ; final double EPS = 0.000000001 ; System . setSecurityManager ( new SecurityManager ( ) ) ; final int BIG_NUM = 2000000000 ; final int HUGE_NUM = 99999999999999999 ; final int MOD = 1000000007 ; final double EPS = 0.000000001 ; System . setSecurityManager ( new SecurityManager ( ) ) ; final Class < ? extends Enum > type = Enum . class ; final int UNKOWN = 0 ; final int OK = 1 ; final int NOT = 2 ; class Info : { int [ ] work = new int [ ] { argA , argB , argC } ; } while ( true ) { final int A = Integer . parseInt ( input . readLine ( ) ) ; final int B = Integer . parseInt ( input . readLine ( ) ) ; final int C = Integer . parseInt ( input . readLine ( ) ) ; if ( A == 0 && B == 0 && C == 0 ) { break ; } final int [ ] table = new int [ ( A + B + C ) + 1 ] ; final int N = Integer . parseInt ( input . readLine ( ) ) ; Info [ ] info = new Info [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { final int a = Integer . parseInt ( input . readLine ( ) ) ; final int b = Integer . parseInt ( input . readLine ( ) ) ; final int c = Integer . parseInt ( input . readLine ( ) ) ; final int result = result > 0 ? 1 : 0 ; if ( result == 1 ) { table [ a ] = Type . OK ; table [ b ] = Type . OK ; table [ c ] = Type . OK ; } else { info [ i ] = new Info ( a , b , c ) ; } } for ( int i = 0 ; i < info . length ; i ++ ) { int count = 0 ; int tmp = - 1 ; for ( int k = 0 ; k < 3 ; k ++ ) { if ( table [ info [ i ] . work [ k ] ] == Type . OK ) { count ++ ; } else if ( table [ info [ i ] . work [ k ] ] == Type . UNKOWN ) { tmp = info [ i ] . work [ k ] ; } } if ( count != 2 || tmp == - 1
static int minRemove ( int [ ] a , int [ ] b , int n , int m ) { Map < Integer , Integer > countA = Maps . newHashMap ( ) ; Map < Integer , Integer > countB = Maps . newHashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { countA . put ( a [ i ] , countA . getOrDefault ( a [ i ] , 0 ) + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { countB . put ( b [ i ] , countB . getOrDefault ( b [ i ] , 0 ) + 1 ) ; } int res = 0 ; for ( int x : countA . keySet ( ) ) { if ( x >= 0 ) res += x ; } return res ; }
public static int count ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i < r ; i ++ ) { if ( ( i < 10 ) && ( cnt < 10 ) ) { cnt ++ ; } else { int n = i % 10 ; } } return ( cnt ) ; }
public static void print ( String input ) { int number = Integer . parseInt ( input ) ; List < String > arr = Lists . newArrayList ( ) ; for ( String s : input . split ( " ▁ " ) ) { arr . add ( s ) ; } int counter = 0 ; Data data = new Data ( " found " , " NO " , 0 ) ; for ( int i = 0 ; i <= number ; i ++ ) { int x = Integer . parseInt ( arr . get ( i ) ) ; if ( x == 1 ) { if ( counter == 0 ) counter = 1 ; if ( data . found == Data . YES ) { int y = i - data . first ; counter = counter * y ; data . first = i ; } else { data . found = Data . YES ; data . first = i ; } } } System . out . println ( counter ) ; }
static int bit ( int x ) { final int ans = 0 ; while ( ( x = bit ( x ) ) > 0 ) { x /= 2 ; ans = ans + 1 ; } return ans ; /* ▁ check ▁ for ▁ d ▁ */ if ( ( bit ( x / d ) <= bit ( d ) ) && ( x <= 1 ) ) { return true ; } /* ▁ bs ▁ */ int l = 1 ; int r = ( int ) Math . sqrt ( n ) ; while ( ( l < r ) && ( x <= 1 ) ) { final int m = ( int ) ( ( l + r ) / 2 ) ; if ( ( m > 0 ) && ( m < 1 ) ) r = m ; else l = m + 1 ; } /* ▁ count ▁ divisor ▁ */ return n - bs ( n ) + 1 ; }
public static int INT_MAX = 100000000 ; int [ ] minimalSteps ( String s , int n ) { int [ ] dp = new int [ n ] ; String s1 = " " ; String s2 = " " ; dp [ 0 ] = 1 ; s1 += s . charAt ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s . charAt ( i ) ; s2 = s . substring ( i + 1 , i + 1 + i + 1 ) ; dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( ( s1 . equals ( s2 ) ) && ( s2 . equals ( s1 ) ) ) { dp [ i * 2 + 1 ] = Math . min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } } return dp [ n - 1 ] ; }
static boolean checkUtil ( int num , int dig , int base ) { if ( ( dig == 1 ) && ( num < base ) ) return true ; if ( ( dig > 1 ) && ( num >= base ) ) return checkUtil ( num / base , - - dig , base ) ; /* ▁ Check ▁ for ▁ digits ▁ */ for ( base = 2 ; base < 33 ; base ++ ) { if ( ( checkUtil ( num , dig , base ) ) == true ) return true ; } /* ▁ Check ▁ for ▁ digits ▁ */ num = 8 ; dig = 3 ; if ( ( check ( num , dig ) == true ) && ( check ( num , dig ) == false ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; return false ; }
public static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } { int minVal = arr [ i ++ ] ; while ( ( minVal <= arr [ i ] ) && ( minVal <= arr [ i ] ) ) { minVal = Math . min ( minVal , arr [ i ++ ] ) ; } return minVal ; } { int maxVal = arr [ i ++ ] ; while ( ( maxVal <= arr [ i ] ) && ( maxVal <= arr [ i ] ) ) { maxVal = Math . max ( maxVal , arr [ i ++ ] ) ; } return ; } }
static final void print ( ) { final BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; final Accumulator g = new Accumulator ( ) ; final int n = Integer . parseInt ( br . readLine ( ) ) ; final List < Integer > p = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { p . add ( i ) ; } }
for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { double a = Double . parseDouble ( input . nextLine ( ) ) ; double b = Double . parseDouble ( input . nextLine ( ) ) ; double c = Double . parseDouble ( input . nextLine ( ) ) ; double d = Double . parseDouble ( input . nextLine ( ) ) ; double e = Double . parseDouble ( input . nextLine ( ) ) ; double f = Double . parseDouble ( input . nextLine ( ) ) ; double g = Double . parseDouble ( input . nextLine ( ) ) ; double h = Double . parseDouble ( input . nextLine ( ) ) ; System . out . println ( Arrays . toString ( " NO " ) + Arrays . toString ( " YES " ) [ Math . abs ( ( a - c ) * ( f - h ) - ( e - g ) * ( b - d ) ) < 1e-10 ] ) ; }
public static int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) { return a ; } if ( n == 1 ) { return b ; } if ( n == 2 ) { return a ^ b ; } return n ; }
public static void main ( String [ ] args ) { final int n = Integer . parseInt ( args [ 0 ] ) ; int taroScore = 0 ; int hanakoScore = 0 ; for ( int turn = 0 ; turn < n ; turn ++ ) { final List < Animal > animals = Arrays . asList ( args [ turn ] . split ( " \\s + " ) ) ; if ( animals . get ( 0 ) . equals ( animals . get ( 1 ) ) ) { taroScore ++ ; hanakoScore ++ ; } else if ( Math . max ( animals . get ( 0 ) , animals . get ( 1 ) ) == animals . get ( 0 ) ) { taroScore += 3 ; } else if ( Math . max ( animals . get ( 0 ) , animals . get ( 1 ) ) == animals . get ( 1 ) ) { hanakoScore += 3 ; } } System . out . println ( taroScore + " ▁ " + hanakoScore ) ; }
static double Area ( double a ) { if ( ( a < 0 ) || ( a > 1 ) ) return - 1 ; double h = 1.268 * a ; double A = 0.70477 * Math . pow ( h , 2 ) ; return A ; }
public static String compute ( ) { int ans = 0 ; Stack < Integer > stack = new Stack < Integer > ( ) ; stack . push ( new Integer ( 1 ) ) ; stack . push ( new Integer ( 3 ) ) ; stack . push ( new Integer ( 1 ) ) ; stack . push ( new Integer ( 2 ) ) ; while ( stack . size ( ) > 0 ) { int leftn = stack . pop ( ) ; int leftd = stack . pop ( ) ; int rightn = stack . pop ( ) ; int rightd = stack . pop ( ) ; int d = leftd + rightd ; if ( d <= 12000 ) { int n = leftn + rightn ; ans ++ ; stack . push ( new Integer ( n ) ) ; stack . push ( new Integer ( d ) ) ; stack . push ( new Integer ( rightn ) ) ; stack . push ( new Integer ( rightd ) ) ; stack . push ( new Integer ( leftn ) ) ; stack . push ( new Integer ( leftd ) ) ; stack . push ( new Integer ( n ) ) ; stack . push ( new Integer ( d ) ) ; } } return Integer . toString ( ans ) ; }
public static void print ( int n ) { int ans ; ans = Integer . parseInt ( input ( ) ) ; if ( n % 2 == 0 ) { ans = 2 * ( n / 2 ) ; } else { ans = 0 ; } System . out . println ( ans ) ; }
@ VisibleForTesting static void sieve ( boolean [ ] prime , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; ( p <= ( int ) Math . sqrt ( n ) ) ; p ++ ) { if ( ( prime [ p ] = true ) == false ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } /* ▁ Sum ▁ prime ▁ */ int maxVal = ( 10 * d ) - 1 ; prime = new boolean [ maxVal + 1 ] ; prime [ 0 ] = true ; sieve ( prime , maxVal ) ; int sum = 0 ; for ( int i = 2 ; i <= maxVal ; i ++ ) { if ( ( prime [ i ] = true ) == false ) { sum += i ; } } /* ▁ Sum ▁ prime ▁ */ if ( Class . isPrimitiveSupported ( ) ) { int d = 3 ; System . out . println ( sumPrime ( d ) ) ; } }
@ VisibleForTesting static void sieve ( boolean [ ] prime , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; ( p = ( int ) Math . sqrt ( n ) ) + 1 <= 1 ; p ++ ) { if ( ( prime [ p ] = true ) == false ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } /* ▁ Sum ▁ prime ▁ */ int maxVal = ( int ) Math . pow ( 2 , d ) - 1 ; prime = new boolean [ maxVal + 1 ] ; for ( int i = 0 ; i < maxVal ; i ++ ) { prime [ i ] = true ; } sieve ( prime , maxVal ) ; int sum = 0 ; for ( int i = 2 ; i <= maxVal ; i += 1 ) { if ( ( prime [ i ] = true ) == false ) { sum += i ; } } /* ▁ If ▁ prime ▁ is ▁ not ▁ true ▁ then ▁ sum ▁ is ▁ prime ▁ */ if ( __name__ == " _ _ main _ _ " ) { int d = 8 ; System . out . println ( sumPrime ( d ) ) ; } }
public static void main ( String input ) { for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { int a = Integer . parseInt ( input . substring ( 0 , input . indexOf ( " ▁ " ) ) ) ; int b = Integer . parseInt ( input . substring ( input . indexOf ( " ▁ " ) + 1 , input . indexOf ( " ▁ " ) ) ) ; int [ ] z = new int [ input . length ( ) ] ; for ( int j = 0 ; j < a ; j ++ ) z [ j ] = Integer . parseInt ( input . substring ( i , j + 1 ) ) ; Arrays . sort ( z ) ; int q = 0 , w = 0 ; for ( int j = 0 ; j < a ; j ++ ) { q += z [ j ] ; if ( q / ( j + 1 ) >= b ) w ++ ; } System . out . println ( w ) ; } }
public static void sort ( int [ ] [ ] a ) { a = new ArrayList < > ( Arrays . asList ( input . split ( " ▁ " ) ) ) ; System . out . println ( a [ 1 ] [ 0 ] - a [ 0 ] [ 0 ] + ( a [ 1 ] [ 1 ] > a [ 0 ] [ 1 ] ? 1 : 0 ) ) ; }
static int maxPartitions ( int [ ] arr , int n ) { int ans = 0 ; int maxSoFar = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { maxSoFar = Math . max ( maxSoFar , arr [ i ] ) ; if ( ( maxSoFar == i ) ) ans ++ ; } return ans ; }
static int countMaxContiguous ( int arr [ ] , int n ) { int currentMax = 0 ; int maxSoFar = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 ) != 0 ) { currentMax = 0 ; } else { currentMax ++ ; maxSoFar = Math . max ( currentMax , maxSoFar ) ; } } return maxSoFar ; }
static double cubeSide ( double h , double r ) { if ( ( h < 0 ) && ( r < 0 ) ) return - 1 ; double a = ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) ; return a ; }
public static void pattern ( int rowsNo ) { for ( int i = 1 ; i <= rowsNo ; i ++ ) { for ( int k = 1 ; k <= i ; k ++ ) System . out . print ( " ▁ " ) ; for ( int j = i ; j <= rowsNo ; j ++ ) System . out . print ( j + " ▁ " ) ; System . out . println ( ) ; } for ( int i = rowsNo - 1 ; i <= rowsNo ; i ++ ) { for ( int k = 1 ; k <= i ; k ++ ) System . out . print ( " ▁ " ) ; } }
@ VisibleForTesting static void addToMap ( Map < String , Double > map ) { final double INF = Double . MAX_VALUE ; final int mod = 10 * 9 + 7 ; { final List < Integer > inpl = Lists . newArrayList ( ) ; for ( String s : input . split ( " ▁ " ) ) { inpl . add ( Integer . parseInt ( s ) ) ; } final List < Integer > inpls = Lists . newArrayList ( ) ; final int N = Integer . parseInt ( input . nextLine ( ) ) ; final double dsum = Double . parseDouble ( input . nextLine ( ) ) ; double ans = INF ; for ( int a = 1 ; a < N ; a ++ ) { final int b = N - a ; ans = Math . min ( ans , dsum ( a ) + dsum ( b ) ) ; } System . out . println ( ans ) ; } }
public static void checkDigits ( int n ) { int i ; while ( ( i = n / 10 ) > 0 ) { if ( ( ( i % 10 ) % 2 ) == 0 ) { return ; } i = ( int ) ( i / 10 ) ; } /* ▁ smallestNumber ▁ */ i = n ; while ( ( i = 1 ) != 0 ) { if ( ( checkDigits ( i ) ) ) { return ; } i ++ ; } if ( className . equals ( " java . lang . Integer " ) ) { int N = 2397 ; System . out . println ( smallestNumber ( N ) ) ; } }
public static int checkDigits ( int n ) { while ( ( n != 0 ) && ( n > 0 ) ) { if ( ( ( n % 10 ) % 2 ) != 0 ) return 0 ; n = ( int ) ( n / 10 ) ; } return 1 ; }
public static void triangularSeries ( int n ) { int j = 1 ; int k = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( k + " ▁ " ) ; j = j + 1 ; k = k + j ; } }
private static int input ( ) { return Integer . parseInt ( input ( ) ) ; int n = input . nextInt ( ) ; int m = input . nextInt ( ) ; int [ ] list = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { list [ i ] = i ; } HashMap < Integer , Integer > l = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! l . containsKey ( list [ i ] ) ) { l . put ( list [ i ] , 1 ) ; } else l . put ( list [ i ] , 1 ) ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( l . get ( list [ i ] ) > 1 ) { res += n - i - l . get ( list [ i ] ) ; l . remove ( list [ i ] ) ; } else res += n - i - 1 ; } System . out . println ( res ) ; return res ; }
static int findPosition ( int k , int n ) { int f1 = 0 ; int f2 = 1 ; int i = 2 ; while ( i != 0 ) { int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) return n * i ; } return 0 ; }
public static void main ( String [ ] args ) { String s = input ( ) ; System . out . println ( Arrays . asList ( " First " , " Second " ) . charAt ( ( s . charAt ( 0 ) == s . charAt ( s . length ( ) - 1 ) ) ^ ( s . length ( ) % 2 == 0 ) ) ) ; }
static int countMinimumMoves ( int [ ] arr , int n , int k ) { for ( int i = k - 1 ; i < n ; i ++ ) { if ( ( arr [ i ] != arr [ k - 1 ] ) && ( arr [ i ] != arr [ k - 1 ] ) ) { return - 1 ; } } for ( int i = k - 1 ; i >= 0 ; i -- ) { if ( ( arr [ i ] != arr [ k - 1 ] ) && ( arr [ i ] != arr [ k - 1 ] ) ) { return i + 1 ; } } return 0 ; }
public static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( ( y > 0 ) != 0 ) { if ( ( y & 1 ) != 0 ) { res = ( res * x ) % p ; } y = y > > 1 ; x = ( x * x ) % p ; } return res ; /* ▁ gcd ▁ */ int a = x ; int b = y ; if ( ( a == 0 ) || ( b == 0 ) ) { return b ; } /* ▁ power ▁ */ int e = power ( a , n , b ) ; /* ▁ gcd ▁ */ if ( getClass ( ) . getName ( ) . equals ( " java . lang . Math " ) ) { a = 5 ; b = 4 ; n = 2 ; System . out . println ( powerGCD ( a , b , n ) ) ; } return e ; }
public static double T ( ) { double s = Integer . parseInt ( input . nextLine ( ) ) ; double q = Integer . parseInt ( input . nextLine ( ) ) ; double v = ( q - 1 ) / q ; int tm = 1 ; double t = s / ( 1 - v ) ; while ( ( T - s ) / v - t > 0 ) { if ( ( T - s ) / v - t < 1e-10 ) break ; tm ++ ; s += v * t ; t = s / ( 1 - v ) ; } return tm ; }
public static int a ( ) { int a = ( int ) input ( ) ; return ( ( a - 2 ) * a * 2 ) ; }
static int countIdenticalRows ( int [ ] [ ] mat ) { int count = 0 ; for ( int i = 0 ; i < mat . length ; i ++ ) { Map < Integer , Integer > hs = Maps . newHashMap ( ) ; for ( int j = 0 ; j < mat [ i ] . length ; j ++ ) hs . put ( mat [ i ] [ j ] , 1 ) ; if ( ( hs . size ( ) == 1 ) ) count ++ ; } return count ; }
static void createSorted ( @ Nonnull int [ ] a , int n ) { ArrayList < Integer > b = new ArrayList < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( b . size ( ) == 0 ) { b . add ( a [ j ] ) ; } else { int start = 0 ; int end = b . size ( ) - 1 ; int pos = 0 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( b . get ( mid ) == a [ j ] ) { b . add ( Math . max ( 0 , mid + 1 ) , a [ j ] ) ; break ; } else if ( b . get ( mid ) > a [ j ] ) { pos = end = mid - 1 ; } else { pos = start = mid + 1 ; } if ( start > end ) { pos = start ; b . add ( Math . max ( 0 , pos ) , a [ j ] ) ; break ; } } } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( b . get ( i ) + " ▁ " ) ; } if ( getClass ( ) . equals ( " java . util . Arrays " ) ) { int [ ] a = { 2 , 5 , 4 , 9 , 8 } ; n = a . length ; createSorted ( a , n ) ; } }
static int countTotalDistinct ( String string ) { int cnt = 0 ; Set < String > items = new HashSet < String > ( ) ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { String temp = " " ; Set < String > ans = new HashSet < String > ( ) ; for ( int j = i ; j < string . length ( ) ; j ++ ) { temp = temp + string . charAt ( j ) ; ans . add ( string . charAt ( j ) ) ; if ( ! items . contains ( temp ) ) { items . add ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; }
static int firstDigit ( int n ) { final int digits = ( int ) ( Math . log10 ( n ) ) ; n = ( int ) ( n / Math . pow ( 10 , digits ) ) ; return n ; }
static void removeZeros ( int [ ] a , int n ) { int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] != 0 ) && ( a [ i ] != 0 ) ) { ind = i ; break ; } } if ( ( ind == - 1 ) && ( a . length == n ) ) { System . out . println ( " Array ▁ has ▁ leading ▁ zeros " ) ; } }
public static int findMaxM ( int [ ] arr , int n ) { HashMap < Integer , Integer > mpp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] >= 0 ) && ( arr [ i ] <= n ) ) { mpp . putAll ( arr [ i ] , mpp . get ( arr [ i ] ) + 1 ) ; } else { mpp . put ( arr [ i ] , 1 ) ; } } int ans = 0 ; for ( Map . Entry < Integer , Integer > entry : mpp . entrySet ( ) ) { ans = entry . getValue ( ) ; } return ans ; }
public static int [ ] parse ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] a = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; } /* ▁ Check ▁ the ▁ input ▁ */ int b = n ; int r = 0 ; int y = 0 ; int [ ] D = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { D [ b ] ++ ; if ( a [ i ] < x ) { r += D [ b ] ; b ++ ; } else { b -- ; r -= D [ b ] ; } y += r ; } return D ; }
static int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x > 0 ) { ans += x % 10 ; x /= 10 ; } /* closest ▁ */ int ans = 0 ; while ( ( ans * 10 + 9 ) <= x ) { ans = ans * 10 + 9 ; } /* sum ▁ of ▁ two ▁ parts */ int A = closest ( N ) ; /* sum ▁ of ▁ three ▁ parts */ if ( Class . isPrimitive ( " java . lang . Integer " ) ) { int N = 35 ; System . out . println ( sumOfDigitsTwoParts ( N ) ) ; } return ans ; }
@ sys . stdin . isatty ( ) public static void readLines ( ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] badge = { " AAA " , " AA " , " A " , " B " , " C " , " D " , " E " , " NA " } ; double [ ] limit = { 500 , 35.50 , 37.50 , 40.00 , 43.00 , 50.00 , 55.00 , 70.00 , Double . MAX_VALUE } , 1000 , 71.00 , 77.00 , 83.00 , 89.00 , 105.00 , 116.00 , 148.00 , Double . MAX_VALUE } ; /* ▁ for ▁ ( int ▁ i ▁ = ▁ 0 ; ▁ i ▁ < ▁ limit . length ; ▁ i + + ) ▁ { STRNEWLINE ▁ if ▁ ( time ▁ < ▁ limit [ i ] ) ▁ { STRNEWLINE ▁ return ; STRNEWLINE ▁ } */ for ( int i = 0 ; i < limit . length ; i ++ ) { if ( limit [ i ] < limit [ i ] ) { return ; } } reader . readLine ( ) ; }
public static void for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int r = Integer . parseInt ( input . nextLine ( ) ) ; int c = Integer . parseInt ( input . nextLine ( ) ) ; System . out . println ( Math . max ( Math . abs ( n - r ) , r - 1 ) + Math . max ( Math . abs ( m - c ) , c - 1 ) ) ; }
public static void print ( int t ) { int n ; for ( int i = 0 ; i < t ; i ++ ) { n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] a = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { a [ j ] = Integer . parseInt ( input . nextLine ( ) ) ; } Arrays . sort ( a ) ; boolean flag = true ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( a [ i ] - a [ i - 1 ] ) > 1 ) { flag = false ; break ; } } if ( flag == true ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
static public void calSin ( double n ) { final double accuracy = 0.0001 ; n = n * ( 3.142 / 180.0 ) ; double x1 = n ; double sinx = n ; double sinval = Math . sin ( n ) ; int i = 1 ; while ( ( i = 0 ) != i ) { final double denominator = 2 * i * ( 2 * i + 1 ) ; x1 = - x1 * n * n / denominator ; sinx = sinx + x1 ; i = i + 1 ; } System . out . println ( round ( sinx ) ) ; }
public static int multiply ( int [ ] array , int n ) { int pro = 1 ; for ( int i = 0 ; i < n ; i ++ ) { pro = pro * array [ i ] ; } return pro ; }
public static int [ ] l = new int [ 64 ] ; for ( int i = 0 ; i < l . length ; i ++ ) { l [ i ] = 0 ; } for ( int i = 0 ; i < Integer . parseInt ( input . nextLine ( ) ) ; i ++ ) { List < String > query = new LinkedList < > ( ) ; query . add ( input . nextLine ( ) ) ; String order = query . get ( 0 ) ; switch ( order ) { case "0" : System . out . println ( l [ Integer . parseInt ( query . get ( 1 ) ) ] != 0 ? 1 : 0 ) ; break ; case "1" : l [ Integer . parseInt ( query . get ( 1 ) ) ] = 1 ; break ; case "2" : l [ Integer . parseInt ( query . get ( 1 ) ) ] = 0 ; break ; case "3" : l [ Integer . parseInt ( query . get ( 1 ) ) ] ^= 1 ; break ; case "4" : System . out . println ( Arrays . toString ( l ) ) ; break ; case "5" : System . out . println ( ArrayUtils . toString ( l ) ) ; break ; case "6" : System . out . println ( ArrayUtils . toString ( l ) ) ; break ; case "7" : System . out . println ( ArrayUtils . toString ( l ) ) ; break ; case "8" : long tmp = 0 ; for ( int j = 0 ; j < 64 ; j ++ ) tmp += l [ j ] * 2 * l [ j ] ; System . out . println ( tmp ) ; break ; } } return l ; }
public static int bit ( int n ) { int count = 0 ; while ( ( n = bitSum ( n ) ) != 0 ) { count ++ ; n = n & ( n - 1 ) ; } /* ▁ max ▁ sum ▁ of ▁ bits ▁ */ for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = bit ( arr [ i ] ) ; } int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( incl > excl ) { int exclNew = incl ; if ( exclNew > 0 ) { exclNew = excl ; } incl = excl + arr [ i ] ; excl = exclNew ; } if ( incl > excl ) { return incl ; } else { return excl ; } } if ( className . equals ( " java . util . Arrays " ) ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 } ; int n = arr . length ; System . out . println ( maxSumOfBits ( arr , n ) ) ; } return 0 ; }
public static int getPares ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int pares = 0 ; char [ ] bolo = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { char camada = input . charAt ( i ) ; bolo [ i ] = camada ; } for ( int i = 0 ; i < n ; i ++ ) { int contador = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( bolo [ i ] [ j ] == ' C ' ) { contador ++ ; } } pares += ( ( contador * ( contador - 1 ) ) / 2 ) ; } System . out . println ( pares ) ; return pares ; }
static int findMinIndex ( int arr [ ] , int low , int high ) { if ( ( high < low ) || ( high == low ) ) return 0 ; if ( ( high == low ) || ( low == high ) ) return low ; int mid = ( low + high ) / 2 ; if ( ( mid < high ) && ( arr [ mid + 1 ] < arr [ mid ] ) ) return ( mid + 1 ) ; if ( ( mid > low ) && ( arr [ mid ] < arr [ mid - 1 ] ) ) return mid ; if ( ( arr [ high ] > arr [ mid ] ) ) return findMinIndex ( arr , low , mid - 1 ) ; return findMinIndex ( arr , mid + 1 , high ) ; /* ▁ binary ▁ search ▁ */ int l , h , x ; while ( ( l <= h ) && ( x <= arr [ l ] ) ) { mid = ( l + h ) / 2 ; if ( ( arr [ mid ] <= x ) && ( x <= arr [ l ] ) ) l = mid + 1 ; else h = mid - 1 ; } /* ▁ count ▁ eleLessThanOrEqual ▁ */ int min_index = findMinIndex ( arr , 0 , n - 1 ) ; if ( ( x <= arr [ n - 1 ] ) && ( x <= arr [ min_index ] ) ) return ( min_index + 1 ) ; return n ; }
public static double f ( double x , double y ) { double v = y - 2 * x * x + 1 ; return v ; } { double y1p = y + h * f ( x , y ) ; return y1p ; } { double y1c ; double x1 , y1 , h ; double e = 0.00001 ; double y1p = y1 ; while ( ( Math . abs ( y1c - y1 ) > e ) && ( y1p < y1c ) ) { y1 = y1c ; y1c = y + 0.5 * h * ( f ( x , y ) + f ( x1 , y1 ) ) ; } return y1c ; } { double x , y , xn ; double x1 , y1 , h ; double e = 0.00001 ; double y1p , y1c ; while ( ( x = x + h ) > x1 ) { x1 = x + h ; y1p = predict ( x , y , h ) ; y1c = correct ( x , y , x1 , y1p , h ) ; x = x1 ; y = y1c ; } System . out . println ( " The ▁ final ▁ value ▁ of ▁ y ▁ at ▁ x ▁ = " + ( int ) x + " ▁ is ▁ : " + y + " . 4 ( ) " ) ; }
public static String D_Pattern ( String string , int n ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ( j == 1 || ( ( i == 0 || i == n - 1 ) && ( j > 1 && j < n - 2 ) ) ) || ( j == n - 2 && i != 0 && i != n - 1 ) ) string = string + " * " ; } string = string + " \n " ; } return ( string ) ; }
public static void kthString ( int n , int k ) { int total = 0 ; int i = 1 ; while ( ( total < k ) && ( n < n ) ) { total = total + n - i ; i ++ ; } int firstYPosition = i - 1 ; int secondYPosition = k - ( total - n + firstYPosition ) ; for ( int j = 1 ; firstYPosition < firstYPosition ; secondYPosition += 1 ) { System . out . print ( " x " ) ; } System . out . println ( " y " ) ; int j = firstYPosition + 1 ; while ( ( secondYPosition > 1 ) && ( n < secondYPosition ) ) { System . out . print ( " x " ) ; secondYPosition -- ; j ++ ; } System . out . println ( " y " ) ; while ( ( j < n ) && ( n < k ) ) { System . out . println ( " x " ) ; j ++ ; } if ( className . equals ( " java . lang . String " ) ) { n = 5 ; k = 7 ; kthString ( n , k ) ; } }
static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) { C [ j ] = C [ j ] + C [ j - 1 ] ; } } return C [ k ] ; }
public static Solution < Integer > createSolution ( ) { class Solution < Integer > { public Integer [ ] productExceptSelf ( int [ ] nums ) { int [ ] ans = new int [ nums . length ] ; ans [ 0 ] = 1 ; for ( int i = 1 ; i < nums . length ; i ++ ) { ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] ; } int right = 1 ; for ( int i = nums . length - 1 ; i >= 0 ; i -- ) { ans [ i ] *= right ; right *= nums [ i ] ; } return ans ; } } if ( getClassName ( ) . equals ( " org . apache . commons . math . analysis . Solution " ) ) { Solution < Integer > sObj = new Solution < Integer > ( ) ; int [ ] nums = { 1 , 2 , 3 , 4 } ; Integer out = sObj . productExceptSelf ( nums ) ; System . out . println ( out ) ; } return null ; }
static void getSmallestAndLargest ( String s , int k ) { String currStr = s . substring ( 0 , k ) ; String lexMin = currStr ; String lexMax = currStr ; for ( int i = k ; i < s . length ( ) ; i ++ ) { currStr = currStr . substring ( 1 , k ) + s . charAt ( i ) ; if ( ( lexMax = currStr . compareTo ( lexMax ) ) < 0 ) { lexMax = currStr ; } if ( ( lexMin = currStr . compareTo ( lexMin ) ) > 0 ) { lexMin = currStr ; } } System . out . println ( lexMin ) ; System . out . println ( lexMax ) ; String str1 ; if ( getClass ( ) . getName ( ) . equals ( " GeeksForGeeks " ) ) { k = 3 ; getSmallestAndLargest ( str1 , k ) ; } }
public static void print ( int m ) { int [ ] a = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > b = Lists . newArrayList ( ) ; int [ ] d = new int [ m ] ; class struct { int value ; int idx ; public struct ( int value , int idx ) { this . value = value ; this . idx = idx ; } } for ( int i = 0 ; i < m ; i ++ ) { b [ i ] = struct ( b [ i ] , i ) ; } Arrays . sort ( a , Collections . reverseOrder ( ) ) ; Arrays . sort ( b , new Comparator < Integer > ( ) { public int compare ( Integer o1 , Integer o2 ) { return o2 . value - o1 . value ; } } ) ; for ( int i = 0 ; i < m ; i ++ ) { d [ b [ i ] . idx ] = a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { System . out . print ( d [ i ] + " " ) ; } }
static int maxSubarrayXOR ( int [ ] set , int n ) { int index = 0 ; for ( int i = INT_BITS - 1 ; i >= 0 ; i -- ) { int maxInd = index ; int maxEle = - 2147483648 ; for ( int j = index ; j < n ; j ++ ) { if ( ( ( set [ j ] & ( 1 << i ) ) != 0 ) && ( set [ j ] > maxEle ) ) { maxEle = set [ j ] ; maxInd = j ; } } if ( ( maxEle == - 2147483648 ) && ( maxInd == 0 ) ) { continue ; } int temp = set [ index ] ; set [ index ] = set [ maxInd ] ; set [ maxInd ] = temp ; } return 0 ; }
public static void input ( ) { String [ ] b = input ( ) . split ( " ▁ " ) ; System . out . println ( max ( map ( b ) ) + " ▁ " + len ( set ( b ) ) ) ; }
public static int partition ( int [ ] arr , int si , int ei ) { int x = arr [ ei ] ; int i = ( si - 1 ) ; for ( int j = si ; j < ei ; j ++ ) { if ( ( arr [ j ] <= x ) && ( arr [ i ] <= arr [ j ] ) ) { i ++ ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } } arr [ i + 1 ] = arr [ ei ] ; arr [ ei ] = arr [ i + 1 ] ; return ( i + 1 ) ; }
public static int Solution ( ) { int i ; String s ; int out ; int countMap = new int [ s . length ( ) ] ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { countMap [ i ] = countMap ; } for ( i = 0 ; i < s . length ( ) ; i ++ ) { s = s . substring ( i , i + 1 ) ; if ( countMap == 1 ) { return i ; } } return - 1 ; }
@ GwtIncompatible ( " java . util . concurrent . atomic . LinkedList " ) public static boolean checkStackPermutation ( int [ ] ip , int [ ] op , int n ) { Queue < Integer > Input = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) Input . add ( ip [ i ] ) ; Queue < Integer > output = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) output . add ( op [ i ] ) ; Stack < Integer > tempStack = new Stack < Integer > ( ) ; int ele ; while ( ( ele = Input . queue . peek ( ) ) == null ) { Input . poll ( ) ; if ( ( ele = output . queue . peek ( ) ) == null ) { output . poll ( ) ; while ( ( tempStack . size ( ) != 0 ) && ( tempStack . peek ( ) == output . queue . peek ( ) ) ) { tempStack . pop ( ) ; output . poll ( ) ; } else break ; } else tempStack . push ( ele ) ; } return ( Input . isEmpty ( ) && tempStack . size ( ) == 0 ) ; }
@ Nullable public static Map < String , String > readInput ( ) { Map < String , String > s = new HashMap < > ( ) ; Map < String , String > t = new HashMap < > ( ) ; List < String > S = new LinkedList < > ( ) ; List < String > T = new LinkedList < > ( ) ; for ( int i = 0 ; i < S . size ( ) ; i ++ ) { if ( ! s . get ( S . get ( i ) ) . contains ( T . get ( i ) ) ) { s . put ( S . get ( i ) , T . get ( i ) ) ; if ( s . get ( S . get ( i ) ) . size ( ) >= 2 ) { System . out . println ( " No " ) ; break ; } } if ( ! t . get ( T . get ( i ) ) . contains ( T . get ( i ) ) ) { t . put ( T . get ( i ) , S . get ( i ) ) ; if ( t . get ( T . get ( i ) ) . size ( ) >= 2 ) { System . out . println ( " No " ) ; break ; } } } if ( i == S . size ( ) - 1 ) { System . out . println ( " Yes " ) ; } return s ; }
static int getSum ( int n , int d ) { int sum = 0 ; for ( int i = 0 ; i < n + 1 ; i ++ ) { if ( ( i % 10 ) == d ) { sum += i ; } } if ( Class . isAnonymousClass ( ) ) { n = 30 ; d = 3 ; System . out . println ( getSum ( n , d ) ) ; } return sum ; }
static final Scanner input = new Scanner ( System . in ) { @ Override public int next ( ) { int t = Integer . parseInt ( input . nextLine ( ) ) ; for ( int testcases = 0 ; testcases < t ; testcases ++ ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; int c = Integer . parseInt ( input . nextLine ( ) ) ; int r = Integer . parseInt ( input . nextLine ( ) ) ; int MINC = c - r ; int MAXC = c + r ; if ( a == b ) { System . out . println ( 0 ) ; } else if ( a < b ) { if ( a <= c && c <= b ) { System . out . println ( Math . max ( 0 , MINC - a ) + Math . max ( 0 , b - MAXC ) ) ; } else if ( c < a ) { System . out . println ( Math . min ( b - a , Math . max ( 0 , b - MAXC ) ) ) ; } else if ( c > b ) { System . out . println ( Math . min ( b - a , Math . max ( 0 , MINC - a ) ) ) ; } } else { if ( a >= c && b >= c ) { System . out . println ( Math . max ( 0 , MINC - b ) + Math . max ( 0 , a - MAXC ) ) ; } else if ( c < b ) { System . out . println ( Math . min ( a - b , Math . max ( 0 , a - MAXC ) ) ) ; } else if ( c > a ) { System . out . println ( Math . min ( a - b , Math . max ( 0 , MINC - b ) ) ) ; } } } return t ; } }
public static void main ( String input ) { for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { int n = Integer . parseInt ( input ) ; int s = Integer . parseInt ( input ) ; int t = Integer . parseInt ( input ) ; System . out . println ( n - Math . min ( s , t ) + 1 ) ; } }
static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ans += ( i % K ) ; } return ans ; }
static final int input ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } for ( int i = 0 ; i < a . length ; i ++ ) { System . out . println ( 1 + ( ( 4 * a [ i ] * ( i + 1 ) ) / Math . gcd ( 4 * a [ i ] , a [ i + 1 ] ) ) / ( a [ i + 1 ] ) ) ; } return a [ 0 ] ; }
@ GwtIncompatible ( " java . lang . Math " ) private static double PI = 3.14 ; { double R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; double area = PI * Math . pow ( R , 2 ) ; return area ; }
public static int minimumNumbers ( int n , int s ) { if ( ( s % n ) != 0 ) { return s / n + 1 ; } else { return s / n ; } }
static int countTriplets ( int [ ] arr , int n , int m ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int end = n - 1 ; end >= 1 ; end -- ) { int start = 0 ; int mid = end - 1 ; while ( ( start < mid ) && ( arr [ end ] > arr [ start ] ) ) { int prod = ( arr [ end ] * arr [ start ] * arr [ mid ] ) ; if ( ( prod > m ) && ( prod < m ) ) { mid -- ; } else if ( ( prod < m ) && ( start < m ) ) { start ++ ; } else if ( ( prod == m ) && ( arr [ start ] == 1 ) ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
static int findIndex ( int n ) { if ( ( n <= 1 ) || ( n > 1 ) ) { return n ; } int a = 0 ; int b = 1 ; int c = 1 ; int res = 1 ; while ( ( c = a + b ) < n ) { c = a + b ; res = res + 1 ; a = b ; b = c ; } return res ; }
private static boolean isVowel ( char ch ) { switch ( ch ) { case ' i ' : case ' a ' : case ' e ' : case ' o ' : case ' u ' : return true ; default : return false ; } /* ▁ Is ▁ it ▁ a ▁ word ? ▁ */ for ( int i = 1 ; i < n ; i ++ ) { if ( ( isVowel ( st . charAt ( i ) ) == false ) && ( isVowel ( st . charAt ( i - 1 ) ) == false ) ) { return false ; } } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( isVowel ( st . charAt ( i ) ) == false ) && ( isVowel ( st . charAt ( i - 1 ) ) == false ) && ( isVowel ( st . charAt ( i + 1 ) ) == false ) ) { return false ; } } String st = " acaba " ; int n = st . length ( ) ; if ( ( isSatisfied ( st , n ) ) && ( isSatisfied ( st , n ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return true ; }
static int countWays ( int n ) { int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
public static double expect ( int m , int n ) { double ans = 0.0 ; int i = m ; while ( ( i = Math . pow ( i / m , n ) - Math . pow ( ( i - 1 ) / m , n ) ) * i ) { ans += ( Math . pow ( i , n ) - Math . pow ( ( i - 1 ) / m , n ) ) * i ; i -- ; } return ans ; }
private static int prodOfPrimes ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { prime [ i ] = true ; } int p = 2 ; while ( ( p * p <= n ) && ( prime [ p ] ) ) { int i = p * 2 ; while ( ( i <= n ) && ( prime [ i ] ) ) { prime [ i ] = false ; i += p ; } } p ++ ; int prod = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] ) { prod *= i ; } } return prod ; }
static private String compute ( ) { final int ans = Integer . valueOf ( 1 ) ; for ( int y = 1901 ; y < 2001 ; y ++ ) for ( int m = 1 ; m < 13 ; m ++ ) if ( new LocalDate ( y , m , 1 ) . isWeekday ( ) ) return ans ; if ( __name__ . equals ( " java . util . Date " ) ) System . out . println ( compute ( ) ) ; return null ; }
public static final Date getDifference ( Date d , int m , int y ) { Date dt2 ; int monthDays [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int years ; /* ▁ Count ▁ leap ▁ years ▁ */ years = d . y ; if ( ( d . m <= 2 ) && ( d . m <= 3 ) ) { years -- ; } /* ▁ Get ▁ difference ▁ between ▁ two ▁ dates ▁ */ int n1 = dt1 . y * 365 + dt1 . d ; for ( int i = 0 ; i <= dt1 . m - 1 ; i ++ ) { n1 += monthDays [ i ] ; } n1 += countLeapYears ( dt1 ) ; int n2 = dt2 . y * 365 + dt2 . d ; for ( int i = 0 ; i <= dt2 . m - 1 ; i ++ ) { n2 += monthDays [ i ] ; } n2 += countLeapYears ( dt2 ) ; return ( n2 - n1 ) ; }
static HashSet < Integer > st = new HashSet < Integer > ( ) { private void generateNumbers ( int n , int num , int a , int b ) { if ( ( num > 0 ) && ( num < n ) ) { st . add ( num ) ; } if ( ( num >= n ) && ( num < 10 ) ) { return ; } if ( ( num * 10 + a > num ) && ( num * 10 + a > num ) ) { generateNumbers ( n , num * 10 + a , a , b ) ; } generateNumbers ( n , num * 10 + b , a , b ) ; } private void printNumbers ( int n ) { for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = i + 1 ; j < 10 ; j += 1 ) { generateNumbers ( n , 0 , i , j ) ; } } System . out . print ( " The ▁ numbers ▁ are : " ) ; LinkedList < Integer > l = new LinkedList < Integer > ( st ) ; System . out . println ( l ) ; } }
static int n ( ) { int k = Integer . parseInt ( input . nextLine ( ) ) ; t = ( n * k * t ) / 100 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( min ( max ( 0 , t - i * k ) , k ) ) ; return k ; }
@ VisibleForTesting static void main ( int n , int m ) { Map < Integer , Integer > map = new LinkedHashMap < > ( ) ; for ( ; ; ) { List < Integer > M = Collections . list ( Integer . parseInt ( input . nextLine ( ) ) ) ; for ( int num = 0 ; num < M . size ( ) ; num ++ ) { int i = M . get ( num ) ; if ( i == 0 ) continue ; map . put ( i , i ) ; } int ans = 10 * 20 ; for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > m ) { ans = entry . getKey ( ) ; m = entry . getValue ( ) ; } else if ( entry . getValue ( ) == m ) { ans = Math . min ( ans , entry . getKey ( ) ) ; } } if ( ans == 10 * 20 ) ans = 0 ; System . out . println ( ans ) ; } while ( true ) { n = Integer . parseInt ( input . nextLine ( ) ) ; m = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == m ) break ; main ( n , m ) ; } }
static int getOddOccurrence ( int [ ] arr ) { int res = 0 ; for ( int element : arr ) { res = res ^ element ; } return res ; }
static final boolean isKthBitSet ( int x , int k ) { if ( ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) ) { return true ; } else { return false ; } }
@ Test public static void SieveOfEratosthenes ( int n , boolean [ ] isPrime ) { isPrime [ 0 ] = false , isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) { isPrime [ i ] = true ; } for ( int p = 2 ; ( int ) ( sqrt ( n ) + 1 ) <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) { isPrime [ i ] = false ; } } } /* ▁ Find ▁ prime ▁ pair ▁ */ boolean flag = 0 ; isPrime = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 2 ; i < n ; i ++ ) { int x = ( int ) ( n / i ) ; if ( ( isPrime [ i ] & isPrime [ x ] ) != 0 && x != i && x * i == n ) { System . out . println ( i + " ▁ " + x ) ; flag = 1 ; break ; } } if ( ! flag ) System . out . println ( " No ▁ such ▁ pair ▁ found " ) ; }
public static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }
public static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }
public static String compute ( ) { final int SIZE_LIMIT = 1000000 ; final int TYPE_LIMIT = 10 ; int [ ] type = new int [ SIZE_LIMIT + 1 ] ; for ( int n = 3 ; n <= SIZE_LIMIT / 4 ; n ++ ) { for ( int m = n - 2 ; m > 0 ; m -- ) { int tiles = n * n - m * m ; if ( tiles > SIZE_LIMIT ) break ; type [ tiles ] ++ ; } } int ans = Integer . valueOf ( type [ 0 ] ) ; for ( int t : type ) { if ( 1 <= t && t <= TYPE_LIMIT ) { System . out . println ( compute ( ) ) ; } } return String . valueOf ( ans ) ; }
public static int t = Integer . parseInt ( input ) { while ( t > 0 ) { t -- ; String S = input . nextLine ( ) ; String s = new String ( S ) ; Stack < int [ ] > stack = new Stack < > ( ) ; List < Integer > pos = new ArrayList < > ( ) ; int check0 = 0 ; for ( int i = 0 ; s . length ( ) > 0 ; i ++ ) { int j = s . length ( ) - i - 1 ; stack . add ( new int [ ] { j , Integer . parseInt ( s . substring ( j , j + 1 ) ) } ) ; if ( s . substring ( j , j + 1 ) . equals ( "0" ) ) { if ( check0 == 0 ) { if ( pos . isEmpty ( ) ) { stack . pop ( ) ; pos . add ( j ) ; } else { if ( pos . get ( pos . size ( ) - 1 ) - j > 1 ) { stack . pop ( ) ; pos . add ( j ) ; } } if ( stack . size ( ) > 0 ) { if ( stack . peek ( ) [ 1 ] == 0 ) { check0 = 1 ; } } } } if ( check0 == 1 ) { if ( s . substring ( j , j + 1 ) . equals ( "1" ) ) { if ( pos . get ( pos . size ( ) - 1 ) - j > 1 ) { stack . pop ( ) ; pos . add ( j ) ; } } } } int [ ] stack2 = new int [ stack . size ( ) ] ; int check = 0 ; for ( int i = 0 ; i <= stack . size ( ) - 1 ; i ++ ) { if ( stack . peek ( ) [ 1 ] < stack . peek ( ) [ 1 ] ) { check = 1 ; } } if ( check == 1 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } } return t ; }
static int maxZeros ( int N ) { int maxm = - 1 ; int cnt = 0 ; while ( ( N != 0 ) ) { if ( ( ! ( N & 1 ) ) != 0 ) { cnt ++ ; N >>= 1 ; maxm = Math . max ( maxm , cnt ) ; } else { maxm = 0 ; } } return maxm ; }
static void getLongestSeq ( int [ ] a , int n ) { int maxIdx = 0 ; int maxLen = 0 ; int currLen = 0 ; int currIdx = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( a [ k ] > 0 ) { currLen ++ ; if ( currLen == 1 ) { currIdx = k ; } } else { if ( currLen > maxLen ) { maxLen = currLen ; maxIdx = currIdx ; } currLen = 0 ; } } if ( maxLen > 0 ) { System . out . println ( " Index ▁ : " + maxIdx + " ▁ , Length ▁ : " + maxLen ) ; } }
static final Class < ? extends Node > class = Node . class ; { private int data ; private int right ; private int down ; public Node ( int [ ] arr , int i , int j , int m , int n ) { if ( ( i > n - 1 ) || ( j > m - 1 ) ) return null ; Node temp = new Node ( arr [ i ] , j ) ; temp . data = arr [ i ] ; temp . right = construct ( arr , i , j + 1 , m , n ) ; temp . down = construct ( arr , i + 1 , j , m , n ) ; return temp ; } private void display ( Node head ) { Node Dp = head ; while ( ( Dp = Dp . right ) != null ) { Node Rp = Dp ; while ( ( Rp = Rp . right ) != null ) { System . out . print ( Rp . data + " ▁ " ) ; Rp = Rp . right ; } System . out . println ( ) ; Dp = Dp . down ; } } } if ( Class . isPrimitive ( ) ) { int arr [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int m = 3 , n = 3 ; Node head = construct ( arr , 0 , 0 , m , n ) ; display ( head ) ; } return null ; }
static final int [ ] getPrime ( ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] nums = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { nums [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } return nums ; }
static void findNthTerm ( int N ) { int ans = 0 ; if ( ( N % 2 ) == 0 ) { ans = ( N / 2 ) * 6 + ( N / 2 ) * 2 ; } else { ans = ( N / 2 + 1 ) * 6 + ( N / 2 ) * 2 ; } System . out . println ( ans ) ; } if ( Class . forName ( " java . lang . Integer " ) . equals ( " java . lang . Integer " ) ) { N = 3 ; findNthTerm ( N ) ; }
static boolean isRectangle ( int a , int b , int c , int d ) { if ( a == b == c == d ) { return true ; } else if ( a == b && c == d ) { return true ; } else if ( a == c && d == b ) { return true ; } return false ; }
static int discreteLogarithm ( int a , int b , int m ) { final int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; i ++ ) { an = ( an * a ) % m ; } final int [ ] value = new int [ m ] ; int cur = an ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( value [ cur ] = 0 ) == 0 ) { value [ cur ] = i ; } cur = ( cur * an ) % m ; } return - 1 ; }
static int FindMinimumCost ( int ind , int [ ] a , int n , int k , int [ ] dp ) { final int ans ; if ( ( ind == ( n - 1 ) ) && ( a [ ind ] == 0 ) ) { return 0 ; } else if ( ( dp [ ind ] != - 1 ) && ( dp [ ind ] != - 1 ) ) { return dp [ ind ] ; } else { ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( ind + i ) < n ) { ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; } else { break ; } } dp [ ind ] = ans ; return ans ; } if ( Class . isPrimitive ( ) ) { final int [ ] a = { 10 , 30 , 40 , 50 , 20 } ; k = 3 ; n = a . length ; dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = - 1 ; } System . out . println ( FindMinimumCost ( 0 , a , n , k , dp ) ) ; } return 0 ; }
@ Function public static int Probability ( double sum , int times ) { double favorable = 0.0 , total = 36.0 , probability = 0 ; for ( int i = 0 ; i < 7 ; i ++ ) { for ( int j = 0 ; j < 7 ; j ++ ) { if ( ( ( i + j ) == sum ) && ( ( i + j ) == sum ) ) { favorable ++ ; } } } long gcd1 = gcd ( ( int ) favorable , ( int ) total ) ; favorable = favorable / gcd1 ; total = total / gcd1 ; probability = Math . pow ( total , times ) ; return ( int ) probability ; }
public static int K = Integer . parseInt ( input ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int mod = 998244353 ; /* ▁ inved ▁ a ▁ = ▁ 1 ▁ */ int x = 1 , y = 0 , u = 0 , v = 1 , k = a , l = mod ; while ( l != 0 ) { x = u = x ; y = y ; u = v ; v = x - u * ( k / l ) ; k = l ; l = k % l ; } /* ▁ X ▁ = ▁ [ 2 * K - 1 ] ▁ */ int [ ] X = new int [ 2 * K - 1 ] ; int [ ] frac = new int [ N + K ] ; for ( int i = 0 ; i < N + K ; i ++ ) { frac [ i ] = 1 ; } for ( int i = 0 ; i < N + K ; i ++ ) { frac [ i ] = ( ( ( i + 1 ) * frac [ i ] ) % mod ) ; } int [ ] invf = new int [ N + K + 1 ] ; for ( int i = 0 ; i < N + K ; i ++ ) { invf [ i ] = inved ( frac [ i ] ) ; } for ( int k = 2 ; k <= K ; k ++ ) { int S = 0 ; int sign = 1 ; int l = k / 2 ; for ( int m = 0 ; m < Math . min ( l + 1 , N / 2 + 1 ) ; m ++ ) { int prod = ( sign * ( frac [ l ] * frac [ N + K - 2 * m - 1 ] ) ) % mod ; prod *= ( invf [ m ] * invf [ l - m ] ) % mod ; prod %= mod ; prod *= ( invf [ N - 2 * m ] * invf [ K - 1 ] ) % mod ; prod %= mod ; S += prod ; S %= mod ; sign *= - 1 ; } X [ k - 2 ] = S ; } for ( int i = 0 ; i < 2 * K - 1 ; i ++ ) { System . out . println ( X [ i ] ) ; } return X [ 2 * K - 1 ] ; }
public static double getCoin ( ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; double c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { String [ ] a = new String ( input . nextLine ( ) . split ( " ▁ " ) ) ; if ( a [ 1 ] . equals ( " BTC " ) ) { c += Double . parseDouble ( a [ 0 ] ) * 380000.0 ; } else { c += Double . parseDouble ( a [ 0 ] ) ; } } System . out . println ( c ) ; return c ; }
static int getCount ( int [ ] arr , int n , int num1 , int num2 ) { int i ; for ( i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] == num1 ) && ( arr [ i + 1 ] == num2 ) ) { break ; } } if ( ( i >= n - 1 ) && ( arr [ i ] == 0 ) ) { return 0 ; } for ( int j = n - 1 ; j > i ; j -- ) { } return 0 ; }
public static void main ( String input ) { int n ; n = Integer . parseInt ( input ) ; if ( n == 0 ) break ; a = new ArrayList < Integer > ( Collections . nCopies ( n , Integer . parseInt ( input ) ) ) ; System . out . println ( Math . min ( a . get ( i + 1 ) - a . get ( i ) , n ) ) ; }
static int countSetBits ( int n ) { int cnt = 0 ; int [ ] setBits = new int [ n + 1 ] ; for ( int x = 0 ; x < n ; x ++ ) { setBits [ x ] = 0 ; } setBits [ 0 ] = 0 ; setBits [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i % 2 ) == 0 ) { setBits [ i ] = setBits [ i / 2 ] ; } else { setBits [ i ] = setBits [ i - 1 ] + 1 ; } } for ( int i = 0 ; i <= n ; i ++ ) { cnt = cnt + setBits [ i ] ; } return cnt ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) { return b ; } return gcd ( b % a , a ) ; /* ▁ largestGCD1Subset ▁ */ int currentGCD = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { currentGCD = gcd ( currentGCD , A [ i ] ) ; } }
public static String compute ( ) { int [ ] divisors = new int [ 10 * 7 + 1 ] ; for ( int i = 2 ; i < ( divisors . length + 1 ) / 2 ; i ++ ) { for ( int j = i * 2 ; j < divisors . length ; j += i ) { divisors [ j ] ++ ; } } int ans = Integer . valueOf ( ( divisors [ i ] == divisors [ i + 1 ] ) ? 1 : 0 ) ; for ( int i = 2 ; i < divisors . length - 1 ; i ++ ) { ans = Integer . valueOf ( ( divisors [ i ] == divisors [ i + 1 ] ) ? 1 : 0 ) ; } return String . valueOf ( ans ) ; }
static void updateArray ( int arr [ ] , int n ) { int i = n - 1 ; while ( ( i > 0 ) && ( arr [ i ] == arr [ i - 1 ] ) ) { arr [ i ] = arr [ i - 1 ] ; i -- ; } arr [ 0 ] = - 1 ; for ( i = 0 ; i < n ; i += 1 ) { System . out . print ( arr [ i ] + " ▁ " ) ; } if ( getClass ( ) . isArray ( ) ) { arr = new int [ ] { 5 , 1 , 3 , 2 , 4 } ; int N = arr . length ; updateArray ( arr , N ) ; } }
static void findEncryptedArray ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( sum - arr [ i ] + " ▁ " ) ; } if ( getClass ( ) . equals ( " java . util . Arrays " ) ) { int arr [ ] = { 5 , 1 , 3 , 2 , 4 } ; int N = arr . length ; findEncryptedArray ( arr , N ) ; } }
static void updateArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { arr [ i ] = arr [ i + 1 ] ; } arr [ n - 1 ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } if ( getClass ( ) . isAnonymousClass ( ) ) { arr = new int [ ] { 5 , 1 , 3 , 2 , 4 } ; int N = arr . length ; updateArray ( arr , N ) ; } }
static int findMinDifference ( int [ ] arr , int n ) { int min__ ; int secondMax ; int max__ ; int secondMin ; if ( ( arr [ 0 ] < arr [ 1 ] ) && ( arr [ 1 ] < arr [ 2 ] ) ) { min__ = secondMax = arr [ 0 ] ; } else { min__ = secondMax ; } if ( ( arr [ 0 ] < arr [ 1 ] ) && ( arr [ 1 ] < arr [ 2 ] ) ) { max__ = secondMin ; } else { max__ = secondMin ; } for ( int i = 2 ; i < n ; i ++ ) { if ( ( arr [ i ] > max__ ) && ( arr [ i ] > max__ ) ) { secondMax = max__ ; max__ = arr [ i ] ; } else if ( ( arr [ i ] > secondMax ) && ( arr [ i ] < secondMax ) ) { secondMax = arr [ i ] ; } else if ( ( arr [ i ] < min__ ) && ( arr [ i ] < min__ ) ) { secondMin = min__ ; min__ = arr [ i ] ; } else if ( ( arr [ i ] < secondMin ) && ( arr [ i ] < secondMin ) ) { secondMin = arr [ i ] ; } } int diff = Math . min ( max__ - secondMin , secondMax - min__ ) ; return diff ; }
static final String read ( ) { final BufferedReader read = new BufferedReader ( new InputStreamReader ( System . in ) ) ; final PrintWriter write = new PrintWriter ( System . out ) ; return read . readLine ( ) . split ( " ▁ " ) . stream ( ) . map ( s -> { Set < Integer > ret = new HashSet < > ( ) ; int i = 2 ; while ( i <= Math . sqrt ( Math . max ( a , b ) ) ) { while ( a % i == 0 ) { ret . add ( i ) ; a /= i ; } while ( b % i == 0 ) { ret . add ( i ) ; b /= i ; } i ++ ; } if ( a >= 2 ) { ret . add ( a ) ; } if ( b >= 2 ) { ret . add ( b ) ; } return ret ; } ) . collect ( Collectors . toSet ( ) ) ; }
@ Function public static void main ( String [ ] args ) { int n ; do { n = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == 0 ) break ; Map < String , Integer > stars = new HashMap < > ( ) ; for ( String s : map . get ( args [ n ] ) . split ( " ▁ " ) ) stars . put ( s , 1 ) ; int halfN = n / 2 ; for ( Map . Entry < String , Integer > i : stars . entrySet ( ) ) { if ( i . getValue ( ) > halfN ) { System . out . println ( i . getKey ( ) ) ; break ; } } } while ( n > 0 ) ; System . out . println ( " NO ▁ COLOR " ) ; }
public static int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
public static int [ ] [ ] createInput ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int d = Integer . parseInt ( input . nextLine ( ) ) ; int x = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] [ ] weights = new int [ d ] [ n ] ; for ( int i = 0 ; i < d ; i ++ ) weights [ i ] = new int [ n ] ; for ( int i = 0 ; i < d ; i ++ ) prices [ i ] = new int [ n ] ; for ( int i = 0 ; i < d - 1 ; i ++ ) prices [ i ] [ 0 ] = weights [ i + 1 ] [ j ] - weights [ i ] [ j ] ; int bag = x ; for ( int i = 0 ; i < d - 1 ; i ++ ) { boolean [ ] dp = new boolean [ bag + 1 ] ; dp [ 0 ] = true ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < bag ; k ++ ) { if ( weights [ i ] [ j ] + k < bag + 1 && dp [ k ] != false ) dp [ k + weights [ i ] [ j ] ] = Math . max ( dp [ k + weights [ i ] [ j ] ] , dp [ k ] + prices [ i ] [ j ] ) ; } } bag += Math . max ( dp , 0 , bag + 1 ) ; } System . out . println ( bag ) ; return weights ; }
private static void solve ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > stones = Arrays . stream ( input . split ( " \\s + " , n ) ) . map ( x -> Integer . parseInt ( x ) ) . collect ( Collectors . toList ( ) ) ; int [ ] total1 = new int [ stones . size ( ) + 1 ] ; for ( int i = 1 ; i <= stones . size ( ) ; i ++ ) { total1 [ i ] = stones . get ( i - 1 ) + total1 [ i - 1 ] ; } int [ ] total2 = new int [ stones . size ( ) + 1 ] ; stones . forEach ( x -> { total2 [ x - 1 ] = x ; } ) ; solve ( ) ; }
static int findMinimumX ( int [ ] a , int n ) { Set < Integer > st = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { st . add ( a [ i ] ) ; } int el1 ; int el2 ; if ( ( st . size ( ) == 1 ) && ( a [ 0 ] == 0 ) ) { return 0 ; } if ( ( st . size ( ) == 2 ) && ( a [ 0 ] == 0 ) ) { st . clear ( ) ; el1 = st . iterator ( ) . next ( ) ; el2 = st . iterator ( ) . next ( ) ; if ( ( ( el2 - el1 ) % 2 ) == 0 ) { return ( int ) ( ( el2 - el1 ) / 2 ) ; } else { return ( el2 - el1 ) ; } } if ( ( st . size ( ) == 3 ) && ( a [ 0 ] == 0 ) ) { st . clear ( ) ; el1 = st . iterator ( ) . next ( ) ; el2 = st . iterator ( ) . next ( ) ; el3 = st . iterator ( ) . next ( ) ; if ( ( ( el2 - el1 ) == ( el3 - el2 ) ) && ( a [ 1 ] == 0 ) ) { return el2 - el1 ; } else { return - 1 ; } } return - 1 ; }
static int findX ( int n , int k ) { final int r = n ; final int m = ( int ) Math . sqrt ( k ) + 1 ; int i = 2 ; while ( i <= m && k > 1 ) { if ( ( i == m ) && ( k > 0 ) ) { i = k ; } int u = 0 ; int v = 0 ; while ( k % i == 0 ) { k /= i ; v ++ ; } if ( ( v > 0 ) && ( k < n ) ) { int t = n ; while ( ( t > 0 ) && ( k < t ) ) { t /= i ; u += t ; } r = Math . min ( r , u / v ) ; } i ++ ; } return r ; }
private static boolean liesInsieRectangle ( int a , int b , int x , int y ) { if ( ( x - y - b <= 0 ) && ( x - y + b >= 0 ) && ( x + y - 2 * a + b <= 0 ) && ( x + y - b >= 0 ) ) { return true ; } return false ; }
static int countPairs ( int arr [ ] , int n ) { int size = ( 2 * N ) + 1 ; int freq [ ] = new int [ size ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( freq [ i ] > 0 ) && ( freq [ i ] > 0 ) ) { ans += ( int ) ( ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ) ; for ( int j = i + 2 ; j <= 2001 ; j += 2 ) { if ( ( freq [ j ] > 0 ) && ( ( freq [ ( int ) ( ( i + j ) / 2 ) ] > 0 ) ) && ( freq [ ( int ) ( ( i + j ) / 2 ) ] > 0 ) ) ans += ( freq [ i ] * freq [ j ] ) ; } } } return ans ; }
static double getAvg ( int x , int n , int sum ) { sum = sum + x ; return ( double ) sum / n ; }
public static void SieveOfEratosthenes ( ) { int MAX = 10000 ; Set < Integer > s = new HashSet < Integer > ( ) ; { boolean [ ] prime = new boolean [ MAX ] ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p < 100 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] == true ) { product = product * p ; s . add ( product + 1 ) ; } } } int n ; if ( getClass ( ) . getName ( ) . equals ( " java . util . concurrent . ConcurrentLinkedQueue " ) ) { SieveOfEratosthenes ( ) ; n = 31 ; if ( isEuclid ( n ) == true ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; n = 42 ; if ( isEuclid ( n ) == true ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public static void input ( ) { String [ ] line1 = input . nextLine ( ) . split ( " ▁ " ) ; String [ ] line2 = input . nextLine ( ) . split ( " ▁ " ) ; int n = Integer . parseInt ( line1 [ 0 ] ) ; int b = Integer . parseInt ( line1 [ 1 ] ) ; int [ ] l1 = new int [ n ] ; for ( int i = 0 ; i < line2 . length ; i ++ ) { l1 [ i ] = Integer . parseInt ( line2 [ i ] ) ; } int [ ] l2 = new int [ l1 . length ] ; int numOfCuts = 0 ; for ( int i = 0 ; i < l1 . length ; i ++ ) { if ( i != 0 ) { int numOfOds = 0 ; int numOfEvens = 0 ; for ( int j = 0 ; j < l1 [ i ] ; j ++ ) { if ( l1 [ j ] % 2 == 0 ) { numOfEvens ++ ; } else { numOfOds ++ ; } } if ( numOfEvens == numOfOds ) { l2 [ i ] = Math . abs ( l1 [ i ] - l1 [ i - 1 ] ) ; } } } Arrays . sort ( l2 ) ; for ( int i : l2 ) { if ( i <= b ) { numOfCuts ++ ; b -= i ; } } System . out . println ( numOfCuts ) ; }
static int maxOperations ( String str ) { int i , g = 0 , gk = 0 , gks = 0 ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( ( str . charAt ( i ) == ' g ' ) && ( str . charAt ( i ) == ' k ' ) ) { g ++ ; } else if ( ( str . charAt ( i ) == ' s ' ) && ( str . charAt ( i ) == ' s ' ) ) { if ( ( g > 0 ) && ( str . charAt ( i ) == ' k ' ) ) { g -- ; gk ++ ; } } else if ( ( str . charAt ( i ) == ' s ' ) && ( str . charAt ( i ) == ' s ' ) ) { if ( ( gk > 0 ) && ( str . charAt ( i ) == ' k ' ) ) { gk -- ; gks ++ ; } } } return gks ; }
public static void print ( int a ) { int [ ] arr = new int [ a ] ; for ( int i = 0 ; i < a ; i ++ ) { arr [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } Arrays . sort ( arr ) ; int c = 0 ; for ( int i = 0 ; i < a - 1 ; i ++ ) { if ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) > 1 ) { c += Math . abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ; } } System . out . println ( c ) ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; ArrayList < ArrayList < Integer > > students = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { students . add ( new ArrayList < > ( ) ) ; } for ( int i = 0 ; i < m ; i ++ ) { int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; students . get ( a - 1 ) . add ( b - 1 ) ; students . get ( b - 1 ) . add ( a - 1 ) ; } ArrayList < Integer > set = new ArrayList < > ( ) ; int bench = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! set . contains ( i ) ) { set . add ( i ) ; if ( students . get ( i ) . size ( ) == 0 || students . get ( i ) . size ( ) == 1 ) { continue ; } else { int root = i ; int prev = - 1 ; int curr = i ; boolean Finished = false ; int clen = 1 ; while ( ! Finished ) { set . add ( curr ) ; if ( students . get ( curr ) . size ( ) == 1 ) { Finished = true ; } else { if ( students . get ( curr ) . contains ( root ) && root != prev ) { Finished = true ; if ( clen % 2 == 1 ) { bench ++ ; } } else { if ( students . get ( curr ) . get ( 0 ) != prev ) { prev = curr ; clen ++ ; curr = students . get ( curr ) . get ( 0 ) ; } else { prev = curr ; curr = students . get ( curr ) . get ( 1 ) ; clen ++ ; } } } } } } } if ( ( n - bench ) % 2 == 1 ) { System . out . println ( bench + 1 ) ; } else { System . out . println ( bench ) ; } }
public static int kthSmallest ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; } if ( getClass ( ) . getName ( ) . equals ( " java . util . Arrays " ) ) { arr = new int [ ] { 12 , 3 , 5 , 7 , 19 } ; n = arr . length ; k = 2 ; System . out . println ( " K ' th ▁ smallest ▁ element ▁ is " + kthSmallest ( arr , n , k ) ) ; }
public static void for ( String d : " ▁ " ) { int n = Integer . parseInt ( input ) ; int * a , b ; a = Integer . parseInt ( input ) ; b = new TreeSet < > ( a ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( b . get ( i ) == a . get ( i ) ) b . set ( i , b . get ( i + 1 ) ) ; } if ( n == 1 ) b = new TreeSet < > ( ) ; else if ( b . get ( b . size ( ) - 1 ) == a . get ( b . size ( ) - 1 ) ) b . set ( b . size ( ) - 2 , b . get ( b . size ( ) - 2 ) ) ; System . out . println ( ( String ) b ) ; }
static final String compute ( ) { final int START_NUM = 1 ; final int END_NUM = 500 ; final String CROAK_SEQ = " PPPPNNPPPNPPNPN " ; assert 0 <= START_NUM && START_NUM < END_NUM ; assert 1 <= CROAK_SEQ . length ( ) ; final int NUM_JUMPS = CROAK_SEQ . length ( ) - 1 ; final int NUM_TRIALS = 2 * NUM_JUMPS ; int globalnumerator = 0 ; final EulerLibrary . List isprime = EulerLibrary . listPrimality ( END_NUM ) ; for ( int i = START_NUM ; i <= END_NUM ; i ++ ) { for ( int j = 0 ; j < NUM_TRIALS ; j ++ ) { int pos = i ; int trialnumerator = 1 ; if ( isprime . get ( pos ) == ( CROAK_SEQ . charAt ( 0 ) == ' P ' ) ) { trialnumerator *= 2 ; } for ( int k = 0 ; k < NUM_JUMPS ; k ++ ) { if ( pos <= START_NUM ) { pos ++ ; } else if ( pos >= END_NUM ) { pos -- ; } else if ( ( j > > k ) & 1 == 0 ) { pos ++ ; } else { pos -- ; } if ( isprime . get ( pos ) == ( CROAK_SEQ . charAt ( k + 1 ) == ' P ' ) ) { trialnumerator *= 2 ; } } globalnumerator += trialnumerator ; } } final int globaldenominator = ( END_NUM + 1 - START_NUM ) * 2 * NUM_JUMPS * 3 * CROAK_SEQ . length ( ) ; final Fraction ans = new Fraction ( globalnumerator , globaldenominator ) ; return ans . toString ( ) ; }
@ GwtIncompatible ( " java . lang . String " ) static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) { lon1 = Math . toRadians ( lon1 ) ; lon2 = Math . toRadians ( lon2 ) ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; double dlon = lon2 - lon1 ; double dlat = lat2 - lat1 ; double a = sin ( dlat / 2 ) * sin ( dlat / 2 ) + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) * sin ( dlon / 2 ) ; double c = 2 * asin ( Math . sqrt ( a ) ) ; int r = 6371 ; return ( c * r ) ; }
public static int centeredOctahedral ( int n ) { return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) / 3 ; }
static class measure { private int init ; private int stationCount ; public void init ( int init , int stationCount ) { this . init = init ; this . stationCount = stationCount ; } public int clockwise ( int pos ) { return ( stationCount - init + pos ) % stationCount ; } public int anticlockwise ( int pos ) { return ( stationCount + init - pos ) % stationCount ; } final Scanner in = new Scanner ( System . in ) ; final int n = in . nextInt ( ) ; final int init = in . nextInt ( ) ; final int [ ] d = new int [ n ] ; Arrays . sort ( d ) ; final measure m = new measure ( init , n ) ; final int [ ] dist = new int [ d . length ] ; final int nPos = d [ 0 ] < init && init < d [ d . length - 1 ] ? d [ nPos ] : 0 ; dist [ nPos ] = m . anticlockwise ( d [ nPos ] ) ; final int pPos = nPos - 1 ; dist [ pPos ] = m . clockwise ( d [ pPos ] ) ; for ( int di = d . length - 1 , dj = d [ pPos ] ; di < pPos + d . length ; di ++ ) { dist [ di ] = m . anticlockwise ( di ) * 2 + m . clockwise ( dj ) ; dist [ dj ] = m . anticlockwise ( di ) + 2 * m . clockwise ( dj ) ; } System . out . println ( min ( dist ) * 100 ) ; }
static void SumDivPrime ( int [ ] A , int n ) { int max_val = max ( A ) + 1 ; boolean [ ] prime = new boolean [ max_val + 1 ] ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p <= ( int ) Math . sqrt ( max_val ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = 2 * p ; i <= max_val ; i += p ) { prime [ i ] = false ; } } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( prime [ A [ i ] ] ) { sum += A [ i ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { } }
static void leftRotate ( int [ ] arr , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) { System . out . print ( Integer . toString ( arr [ i % n ] ) + " ▁ " ) ; } }
static int closestMultiple ( int n , int x ) { if ( x > n ) { return x ; } int z = ( ( int ) ( x / 2 ) ) ; n = n + z ; n = n - ( n % x ) ; return n ; }
for static final int [ ] range ( int i = 0 , int j = 0 ) { y = input . nextInt ( ) ; System . out . println ( " cryeadn " [ ( int ) y % 3 < 1 && ( ! { * y } & { * '2468' } ) < y . indexOf ( '0' ) : : 2 ] ) ; }
public static int [ ] [ ] dp = new int [ 8101 ] [ 901 ] ; int a , b ; int k ; int ans ; if ( ( a > b ) || ( a < 0 ) || ( b < 0 ) || ( a > 900 ) || ( b > 8100 ) ) return - 1 ; if ( ( a == 0 ) && ( b == 0 ) ) return 0 ; if ( ( dp [ a ] [ b ] != - 1 ) && ( dp [ a ] [ b ] != - 1 ) ) return dp [ a ] [ b ] ; ans = 101 ; for ( int i = 9 ; i > 0 ; i -- ) { k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) ; if ( ( k != - 1 ) && ( ans > 0 ) ) ans = Math . min ( ans , k + 1 ) ; } dp [ a ] [ b ] = ans ; /* ▁ print ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ of ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ of ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ of ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ largest ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ of ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ largest ▁ of ▁ the ▁ number ▁ of ▁ largest ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ largest ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ of ▁ largest ▁ the ▁ number ▁ of ▁ largest ▁ largest ▁ of ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ largest ▁ of ▁ the ▁ number ▁ of ▁ largest ▁ the ▁ largest ▁ number ▁ of ▁ the ▁ largest ▁ largest ▁ of ▁ the ▁ number ▁ of ▁ the ▁ largest ▁ number ▁ of
static void N ( int N ) { int n , k ; int [ ] [ ] gr = new int [ N ] [ N ] ; int [ ] [ ] d = new int [ 505 ] [ N ] ; int ans = 0 ; /* ▁ Add_edge ▁ */ gr [ 0 ] = new int [ N ] ; gr [ 1 ] = new int [ N ] ; gr [ 2 ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { d [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < gr [ v ] . length ; j ++ ) { if ( ( gr [ v ] [ j ] != par ) && ( gr [ v ] [ j ] != par ) ) { /* ▁ dfs ▁ */ d [ v ] [ j ] = 1 ; for ( int j = 1 ; j <= k ; j ++ ) { d [ v ] [ j ] += d [ i ] [ j - 1 ] ; } } } } n = 5 ; k = 2 ; /* ▁ dfs ▁ */ }
static int findSubsequence ( int [ ] arr , int n ) { int length = 1 ; int [ ] dp = new int [ 10 ] ; int tmp = arr [ 0 ] ; while ( ( tmp > 0 ) && ( dp [ tmp ] < 10 ) ) { dp [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( int i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; int locMax = 1 ; int [ ] cnt = new int [ 10 ] ; while ( ( tmp > 0 ) && ( dp [ tmp ] < 10 ) ) { cnt [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( int d = 0 ; d < 10 ; d ++ ) { if ( ( cnt [ d ] > 0 ) && ( dp [ d ] < locMax ) ) { dp [ d ] ++ ; locMax = Math . max ( locMax , dp [ d ] ) ; } } for ( int d = 0 ; d < 10 ; d ++ ) { if ( ( cnt [ d ] > 0 ) && ( dp [ d ] < locMax ) ) { dp [ d ] = locMax ; } } length = Math . max ( length , locMax ) ; } return length ; }
public static void for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { input . nextLine ( ) ; System . out . println ( new HashSet < > ( Collections . reverseOrder ( ) ) . stream ( ) . filter ( x -> x . startsWith ( " ▁ " ) ) . collect ( Collectors . joining ( ) ) ) ; }
static int totalPrimeFactors ( int n ) { int count = 0 ; if ( ( ( n % 2 ) == 0 ) && ( ( n % 2 ) == 0 ) ) { count ++ ; while ( ( ( n % 2 ) == 0 ) && ( ( n % 2 ) == 0 ) ) { n /= 2 ; } } int i = 3 ; while ( ( i * i <= n ) && ( ( n % i ) == 0 ) ) { count ++ ; while ( ( ( n % i ) == 0 ) && ( ( n % i ) == 0 ) ) { n /= i ; } } return count ; }
public static void calculateSum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; System . out . println ( " Sum ▁ of ▁ multiples ▁ of ▁ " + a + " ▁ up ▁ to ▁ " + N + " ▁ = ▁ " + ans ) ; }
public static void main ( String [ ] args ) { String [ ] line ; int n = Integer . parseInt ( args [ 0 ] ) ; int m = Integer . parseInt ( args [ 1 ] ) ; int k = Integer . parseInt ( args [ 2 ] . substring ( 2 ) ) ; HashMap < String , Integer > skills = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { line = input . nextLine ( ) ; skills . put ( line [ 0 ] , Integer . parseInt ( line [ 1 ] ) ) ; } ArrayList < String > newSkills = new ArrayList < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { newSkills . add ( input . nextLine ( ) ) ; } int count = 0 ; ArrayList < String > delete = new ArrayList < > ( ) ; for ( Map . Entry < String , Integer > entry : skills . entrySet ( ) ) { int value = ( int ) ( k * value / 100 ) ; if ( value < 100 ) { delete . add ( entry . getKey ( ) ) ; } else { skills . put ( entry . getKey ( ) , value ) ; count ++ ; } } for ( String key : delete ) { skills . remove ( key ) ; } for ( String skill : newSkills ) { if ( ! skills . keySet ( ) . contains ( skill ) ) { skills . put ( skill , 0 ) ; count ++ ; } } Map < String , Integer > map = new HashMap < > ( ) ; map . putAll ( skills ) ; System . out . println ( count ) ; for ( Map . Entry < String , Integer > entry : map . entrySet ( ) ) { System . out . print ( entry . getKey ( ) + " ▁ " + entry . getValue ( ) + " ▁ " ) ; } }
static int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i < a + 1 ; i ++ ) { if ( ( a == ( i + ( a ^ i ) ) ) && ( i != 0 ) ) { count ++ ; } } if ( getClass ( ) . getName ( ) . equals ( " java . lang . Integer " ) ) { a = 3 ; System . out . println ( countSolutions ( a ) ) ; } return count ; }
public static int next ( int [ ] arr , int target ) { int start = 0 ; int end = arr . length - 1 ; int ans = - 1 ; while ( ( start <= end ) && ( ans < arr . length ) ) { int mid = ( start + end ) / 2 ; if ( ( arr [ mid ] <= target ) && ( arr [ mid ] <= target ) ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; }
@ DataPoints public static String [ ] word ( ) { int [ ] digits = new int [ 10 ] ; for ( int i = 0 ; i < digits . length ; i ++ ) { digits [ i ] = 0 ; } int dc = 0 ; do { digits [ dc ] = n % 10 ; n = n / 10 ; dc ++ ; } while ( ( n == 0 ) && ( digits [ dc ] == 0 ) ) ; return digits ; }
@ GwtIncompatible ( " java . util . Scanner " ) public static int [ ] [ ] solve ( int n , int k , int m , int [ ] a ) { IntFunction < Integer > intIn = new IntFunction < Integer > ( ) { @ Override public Integer apply ( Integer in ) { return in . nextInt ( ) ; } } ; IntFunction < List < Integer > > arrIn = new IntFunction < List < Integer > > ( ) { @ Override public List < Integer > apply ( List < Integer > input ) { return Arrays . asList ( in . toArray ( ) ) ; } } ; MatFunction < Integer , List < Integer > > matIn = new MatFunction < Integer , List < Integer > > ( ) { @ Override public List < Integer > apply ( int rows ) { return Arrays . asList ( arrIn . apply ( rows ) ) ; } } ; StrFunction < Integer , String > strIn = new StrFunction < Integer , String > ( ) { @ Override public String apply ( Integer o ) { return in . toString ( ) ; } } ; IntFunction < List < Integer > > out = new IntFunction < List < Integer > > ( ) { @ Override public List < Integer > apply ( Integer o ) { return matIn . apply ( o ) ; } } ; IntFunction < List < Integer > > arrOut = new IntFunction < List < Integer > > ( ) { @ Override public List < Integer > apply ( List < Integer > o ) { return out . apply ( Arrays . asList ( o ) ) ; } } ; IntFunction < List < Integer > > boolOut = new IntFunction < List < Integer > > ( ) { @ Override public List < Integer > apply ( Integer o ) { return out . apply ( o . equals ( intIn ) ? " YES " : " NO " ) ; } } ; IntFunction < List < Integer > > tests = new IntFunction < List < Integer > > ( ) { @ Override public int apply ( Integer i , Integer o ) { return 1 ; } } ; IntFunction < List < Integer > > caseOut = new IntFunction < List < Integer > > ( ) { @ Override public int apply ( Integer i , Integer o ) { List < Integer > sa = new ArrayList < Integer > ( a ) ; int [ ] prefixSum = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { prefixSum [ j
public static void solve ( String a , String b ) { int l = a . length ( ) ; int min = 0 ; int max = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( a . charAt ( i ) == ' + ' || b . charAt ( i ) == ' + ' || a . charAt ( i ) != b . charAt ( i ) ) ) { max ++ ; } if ( ( a . charAt ( i ) != ' + ' && b . charAt ( i ) != ' + ' && a . charAt ( i ) != b . charAt ( i ) ) ) { min ++ ; } } System . out . println ( min + max ) ; } if ( className . equals ( " java . lang . String " ) ) { String s1 = " a + c " ; String s2 = " + + b " ; solve ( s1 , s2 ) ; }
private static int totalWays ( int n , int s , int k ) { int [ ] dp = new int [ n ] ; Arrays . fill ( dp , 0 ) ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = Math . max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
static int countEvenOdd ( int n ) { int evenCount = 0 ; int odCount = 0 ; while ( ( n > 0 ) && ( n < 10 ) ) { int rem = n % 10 ; if ( ( rem % 2 == 0 ) && ( odCount == 0 ) ) { evenCount ++ ; } else { odCount ++ ; } n = ( int ) ( n / 10 ) ; } System . out . println ( " Even ▁ count ▁ : ▁ " + evenCount ) ; System . out . println ( " \n Odd ▁ count ▁ : ▁ " + odCount ) ; if ( ( evenCount % 2 == 0 ) && ( odCount % 2 != 0 ) ) { return 1 ; } else { return 0 ; } n = 2335453 ; int t = countEvenOdd ( n ) ; if ( ( t == 1 ) && ( t == 0 ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } return t ; }
@ VisibleForTesting static Iterable < Integer > accumulate ( int g , int remain ) { int n = Integer . parseInt ( input ( ) ) ; int k = Integer . parseInt ( input ( ) ) ; List < List < Integer > > books = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) books . add ( new ArrayList < > ( ) ) ; while ( n > 0 ) { int c = Integer . parseInt ( input ( ) ) ; int g = Integer . parseInt ( input ( ) ) ; books . get ( g - 1 ) . add ( c ) ; n -- ; } List < List < Integer > > booksAcc = books . stream ( ) . map ( q -> new ArrayList < > ( ) ) . collect ( toList ( ) ) ; return new Memoizer < > ( ) { @ Override public int next ( ) { int [ ] memo = new int [ k + 1 ] ; for ( int i = 0 ; i < books . size ( ) ; i ++ ) books . get ( i ) . add ( books . get ( i ) ) ; return 0 ; } } ; }
static int findmin ( int [ ] [ ] p , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( p [ i ] [ 0 ] <= 0 ) && ( p [ i ] [ 0 ] >= 0 ) ) { a ++ ; } else if ( ( p [ i ] [ 0 ] >= 0 ) && ( p [ i ] [ 0 ] <= 0 ) ) { b ++ ; } if ( ( p [ i ] [ 1 ] >= 0 ) && ( p [ i ] [ 1 ] <= 0 ) ) { c ++ ; } if ( ( p [ i ] [ 1 ] <= 0 ) && ( p [ i ] [ 1 ] <= 0 ) ) { d ++ ; } } return Math . min ( a , b , c , d ) ; }
@ GwtIncompatible ( " java . lang . Long " ) public static long maxGCD ( long N , long P ) { long ans = 1 ; HashMap < Long , Long > primeFactors = new HashMap < > ( ) ; for ( int i = 2 ; i <= ( int ) ( Math . sqrt ( P ) + 1 ) ; i ++ ) { while ( ( P % i ) == 0 ) { if ( ! primeFactors . containsKey ( i ) ) { primeFactors . put ( i , 0L ) ; } primeFactors . get ( i ) ++ ; P /= i ; } } if ( ( P != 1 ) && ( primeFactors . containsKey ( P ) ) ) { primeFactors . put ( P , 1L ) ; } for ( Map . Entry < Long , Long > entry : primeFactors . entrySet ( ) ) { ans *= Math . pow ( entry . getKey ( ) , entry . getValue ( ) / N ) ; } return ans ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int k = Integer . parseInt ( input ) ; int ... b = Integer . parseInt ( input ) ; int t = Integer . MIN_VALUE ; for ( int i = 0 ; i < 1 << k ; i ++ ) { int tmp = 0 ; int [ ] rs = new int [ k ] ; for ( int j = 0 ; j < k ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { tmp |= 1 << b [ j ] ; rs [ j ] = b [ j ] ; } } System . out . println ( Integer . toString ( tmp ) + " : " + Arrays . toString ( rs ) ) ; } }
static void generateDivisors ( int curIndex , int curDivisor , int [ ] [ ] arr ) { if ( ( curIndex == arr . length ) || ( curIndex == arr . length ) ) { System . out . print ( curDivisor + " ▁ " ) ; return ; } for ( int i = 0 ; i < arr [ curIndex ] [ 0 ] + 1 ; i ++ ) { generateDivisors ( curIndex + 1 , curDivisor , arr ) ; curDivisor *= arr [ curIndex ] [ 1 ] ; } }
public static int n = Integer . parseInt ( input ) { int [ ] l = new int [ 1000010 ] ; int [ ] dp = new int [ 1000010 ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = Integer . parseInt ( input . readLine ( ) ) ; int b = Integer . parseInt ( input . readLine ( ) ) ; l [ a ] = b ; } if ( l [ 0 ] > 0 ) { dp [ 0 ] = 1 ; } int mx = 0 ; for ( int i = 1 ; i < 1000010 ; i ++ ) { if ( ( l [ i ] == 0 ) && ( dp [ i ] >= i ) ) { dp [ i ] = 1 ; } else { dp [ i ] = dp [ i - l [ i ] - 1 ] + 1 ; } } if ( ( dp [ i ] > mx ) && ( mx > 0 ) ) { mx = dp [ i ] ; } return mx ; }
public static String largestPalinSub ( String s ) { String res = " " ; int mx = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { mx = Math . max ( mx , s . charAt ( i ) ) ; } for ( int i = 0 ; i <= s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == mx ) { res += s . charAt ( i ) ; } } return res ; }
public static String convert ( String s ) { String convertStr = " " ; int l = s . length ( ) ; int i = 0 ; while ( i < l ) { if ( i + 1 < l ) { String word = s . substring ( i , i + 1 ) ; int sequenceNum = 1 ; int j = i + 1 ; while ( j < l ) { if ( ( word . equals ( s . substring ( j , j + 1 ) ) ) && ( sequenceNum < l ) ) { sequenceNum ++ ; } else { break ; } j ++ ; } convertStr += Integer . toString ( sequenceNum ) + word ; i = i + sequenceNum - 1 ; } else { convertStr += "1" + Integer . toString ( s . charAt ( i ) ) ; } i ++ ; } return convertStr ; }
static final int [ ] getDigits ( ) { final String input = System . getProperty ( " input " ) ; final int n = Integer . parseInt ( input ) ; final int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( input . substring ( 0 , i ) ) ; } final int [ ] d = new int [ 100007 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { d [ i ] = 0 ; } int ans = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 2 ; j <= i ; j ++ ) { if ( j * j > i ) break ; if ( i % j == 0 ) { d [ i / j ] = d [ i ] ; d [ j ] = d [ i ] ; } } ans = Math . max ( ans , d [ i ] ) ; } System . out . println ( ans ) ; return d ; }
static int [ ] initializeDiffArray ( int [ ] A ) { int n = A . length ; int [ ] D = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { D [ i ] = 0 ; } D [ 0 ] = A [ 0 ] ; D [ n ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { D [ i ] = A [ i ] - A [ i - 1 ] ; } return D ; }
static void findMaxGuests ( int [ ] arrl , int [ ] exit , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guests_in = 1 ; int max_guests = 1 ; int time = arrl [ 0 ] ; int i = 1 ; int j = 0 ; while ( ( i < n ) && ( j < n ) ) { if ( ( arrl [ i ] <= exit [ j ] ) && ( time > max_guests ) ) { max_guests = guests_in ; time = arrl [ i ] ; } i = i + 1 ; } System . out . println ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = " + max_guests + " at ▁ time " + time ) ; }
public static String lcs ( String x , String y , int preLCS , int preLCSLen ) { Map < Character , Integer > pm = new EnumMap < Character , Integer > ( Character . getDigit ( 0 ) ) ; for ( char c : pm . keySet ( ) ) { for ( int i = 0 ; i < x . length ( ) ; i ++ ) { char xc = x . charAt ( i ) ; if ( c == xc ) { pm . put ( c , ( 1 << i ) ) ; } } } int V = ( 1 << x . length ( ) ) - 1 ; String [ ] rec = new String [ y . length ( ) ] ; for ( int i = 0 ; i < y . length ( ) ; i ++ ) { char yc = y . charAt ( i ) ; V = ( ( V + ( V & pm . get ( yc ) ) ) | ( V & ~ pm . get ( yc ) ) ) ; rec [ i ] = Integer . toBinaryString ( V ) ; } int lcsLen = Integer . toBinaryString ( V ) . length ( ) ; if ( lcsLen > preLCSLen ) { String rx = x . substring ( 0 , x . length ( ) - 1 ) ; StringBuffer sb = new StringBuffer ( ) ; int idx = 0 ; for ( int i = rec . length - 1 ; i >= 0 ; i -- ) { String v = rec [ i ] ; char yc = y . charAt ( i ) ; idx = v . indexOf ( '0' , idx ) ; if ( yc == rx . charAt ( idx ) ) { sb . append ( yc ) ; if ( sb . length ( ) == lcsLen ) { return ( sb . toString ( ) ) ; } idx ++ ; } } } else { return ( preLCS ) ; } @ SuppressWarnings ( " unused " ) Scanner fileInput = new Scanner ( System . in ) ; StringBuilder ansOut = new StringBuilder ( ) ; while ( fileInput . hasNextLine ( ) ) { String s = fileInput . nextLine ( ) ; if ( s . charAt ( 0 ) == ' # ' ) { break ; } int sLen = s . length ( ) ; int sep = sLen / 2 ; String ans = lcs ( s . substring ( 0 , sep ) , s . substring ( sep ) , " " , 0 ) ; while ( sep > ansLen ) { ans =
static long calcFunction ( int n , int r ) { long finalDenominator = 1 ; int mx = Math . max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { long denominator = Math . pow ( i , i ) ; long numerator = Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
@ GwtIncompatible ( " java . lang . String " ) public static void isPerfectSquare ( double x ) { int sr = ( int ) Math . sqrt ( x ) ; if ( ( sr * sr ) == x ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
public static void print ( int N ) { int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = Integer . parseInt ( input . nextLine ( ) ) * N + i ; } Arrays . sort ( A ) ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int d = ( A [ i ] % N ) % 2 ; if ( d % 2 != i % 2 ) { cnt ++ ; } } System . out . println ( cnt / 2 ) ; }
public static String get ( @ Nonnull List < Integer > l ) { Collections . sort ( l ) ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) { if ( l . contains ( i + 1 ) && l . contains ( i + 2 ) ) { return " YES " ; } } return " NO " ; } if ( getClass ( ) . isEnum ( ) ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; String [ ] list = input . nextLine ( ) . split ( " ▁ " ) ; int [ ] array = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { array [ i ] = Integer . parseInt ( list [ i ] ) ; } System . out . println ( get ( array ) ) ; }
static boolean isSankaku ( int v ) { final double x = ( Math . sqrt ( 8 * v + 1 ) - 1 ) / 2 ; return x == ( int ) x ; /* ▁ Check ▁ for ▁ list ▁ of ▁ integers ▁ */ for ( int i = 0 ; i < list . length ; i ++ ) { if ( list [ i ] != i + 1 ) { return false ; } else if ( i == list . length - 1 ) { return true ; } } while ( true ) { final int N = Integer . parseInt ( input . nextLine ( ) ) ; if ( N == 0 ) break ; final List < Integer > list = Lists . newArrayList ( ) ; for ( int i = 0 ; i < N ; i ++ ) { list . add ( i ) ; } if ( ! isSankaku ( Integer . parseInt ( input . nextLine ( ) ) ) ) { System . out . println ( - 1 ) ; continue ; } int result = - 1 ; for ( int count = 0 ; count < 10000 ; count ++ ) { if ( list . size ( ) > 0 ) { result = count ; break ; } final int spam = list . size ( ) ; list . clear ( ) ; list . add ( spam ) ; } System . out . println ( result ) ; } }
public static boolean accumulate ( String s ) { int acc = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { acc += ( s . charAt ( i ) - 48 ) ; } return acc > 0 ; /* ▁ Is ▁ this ▁ a ▁ divisible ? ▁ */ int n = s . length ( ) ; if ( ( s . charAt ( n - 1 ) != '5' ) && ( s . charAt ( n - 1 ) != '0' ) ) { return false ; } int sum = accumulate ( s ) ; /* ▁ Is ▁ this ▁ a ▁ divisible ? ▁ */ String s = "15645746327462384723984023940239" ; if ( s . length ( ) > 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } s = "15645746327462384723984023940235" ; if ( s . length ( ) > 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } s = "15645746327462384723984023940235" ; if ( s . length ( ) > 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return true ; }
static final long compute ( ) { return new long [ EulerLibrary . getSumLimit ( ) ] { @ Override public String compute ( ) { return " " ; } @ Override public long findSum ( long limit ) { for ( int a = 1 ; ; a ++ ) { if ( a * a >= limit ) { break ; } for ( int b = 1 ; b < a ; b ++ ) { if ( ( a + b ) % 2 != 0 ) { continue ; } long x = ( a * a + b * b ) / 2 ; long y = ( a * a - b * b ) / 2 ; if ( x + y + 1 >= limit ) { continue ; } long zlimit = Math . min ( y , limit - x - y ) ; for ( int c = 0 ; c < EulerLibrary . sqrt ( y ) + 1 ; c ++ ) { long z = c * c - y ; if ( z >= zlimit ) { break ; } if ( isSquare [ x + z ] && isSquare [ x - z ] && isSquare [ y - z ] ) { return x + y + z ; } } } return 0 ; } } } ; long sumlimit = 10 ; long sum ; do { isSquare = new boolean [ sumlimit ] ; for ( int i = 0 ; i < EulerLibrary . sqrt ( isSquare . length - 1 ) + 1 ; i ++ ) { isSquare [ i * i ] = true ; } sum = findSum ( sumlimit ) ; if ( sum != 0 ) { sum = sumlimit ; break ; } sumlimit *= 10 ; } while ( true ) ; do { sum = findSum ( sumlimit ) ; if ( sum == 0 ) { return Long . toString ( sumlimit ) ; } sumlimit = sum ; } while ( true ) ; if ( __name__ . equals ( " java . util . concurrent . atomic . AtomicLong " ) ) { System . out . println ( compute ( ) ) ; } return sum ; }
private static String isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ? " " : " " ; }
static final int gcd ( int a , int b ) { if ( b == 0 ) { return Math . abs ( a ) ; } else { return gcd ( b , a % b ) ; } int N = Integer . parseInt ( input . nextLine ( ) ) ; int M = Integer . parseInt ( input . nextLine ( ) ) ; String S = input . nextLine ( ) ; String T = input . nextLine ( ) ; if ( S . charAt ( 0 ) != T . charAt ( 0 ) ) { System . out . println ( - 1 ) ; exit ( ) ; } if ( S . length ( ) == T . length ( ) ) { if ( S . equals ( T ) ) { System . out . println ( S . length ( ) ) ; } else { System . out . println ( - 1 ) ; } exit ( ) ; } int gcd1 = gcd ( S . length ( ) , T . length ( ) ) ; int lcm = S . length ( ) * T . length ( ) / gcd1 ; int [ ] SS = new int [ gcd1 ] ; int [ ] TT = new int [ gcd1 ] ; int i = 0 ; int j = 0 ; while ( i < N ) { SS [ i ++ ] = TT [ i ++ ] ; } while ( j < M ) { int ind = Integer . parseInt ( input . nextLine ( ) ) ; if ( ind == j ) { break ; } if ( TT [ ind ] == v ) { if ( S . charAt ( i ) == T . charAt ( ind ) ) { continue ; } else { System . out . println ( - 1 ) ; exit ( ) ; } } } System . out . println ( lcm ) ; return lcm ; }
@ Sys public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; boolean [ ] [ ] black = new boolean [ n + 10 ] [ n + 10 ] ; for ( int i = 1 ; i <= m ; i ++ ) { int x = Integer . parseInt ( input . nextLine ( ) ) + 5 ; int y = Integer . parseInt ( input . nextLine ( ) ) ; black [ x ] [ y ] = true ; for ( int lx = x - 2 ; lx <= x ; lx ++ ) { for ( int ly = y - 2 ; ly <= y ; ly ++ ) { int cnt = 0 ; for ( int dx = 0 ; dx < 3 ; dx ++ ) { for ( int dy = 0 ; dy < 3 ; dy ++ ) { cnt += black [ lx + dx ] [ ly + dy ] ; } } if ( cnt == 9 ) { System . out . println ( i ) ; exit ( ) ; } } } } System . out . println ( - 1 ) ; }
static final String getGridLength ( int n , String [ ] grid ) throws IOException { final String PYDEV = System . getProperty ( " PYDEV " ) ; if ( PYDEV . equals ( " true " ) ) { System . setIn ( new FileInputStream ( " sample - input . txt " ) ) ; } /* ▁ GridLength ▁ */ int L = 0 ; for ( int row = 0 ; row < n ; row ++ ) { L = Math . max ( L , Math . max ( row , 0 ) ) ; } for ( int c = 0 ; c < n ; c ++ ) { String col = StringUtils . getVal ( grid [ r ] , c ) ; L = Math . max ( L , Math . max ( col , 0 ) ) ; } for ( int row = - n ; row < 2 * n ; row ++ ) { String diag = StringUtils . getVal ( grid [ row + c ] , row ) ; L = Math . max ( L , Math . max ( row , 0 ) ) ; diag = StringUtils . getVal ( grid [ row - c ] , row ) ; L = Math . max ( L , Math . max ( diag , 0 ) ) ; } /* ▁ Make ▁ sure ▁ that ▁ the ▁ number ▁ of ▁ rows ▁ is ▁ 0 ▁ or ▁ 1 ▁ is ▁ the ▁ same ▁ as ▁ the ▁ number ▁ of ▁ rows ▁ */ while ( true ) { n = Integer . parseInt ( input ( ) ) ; if ( n == 0 ) { break ; } String [ ] grid = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { grid [ i ] = input ( ) . trim ( ) ; } System . out . println ( GridLength ( n , grid ) ) ; } }
static final double fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n * n ) + ( 15 * n * n * n * n * n ) + ( 10 * n * n * n * n ) - n ) / 30 ; }
@ VisibleForTesting static int maxLenSub ( int [ ] arr , int n ) { Map < Integer , Integer > um = new HashMap < > ( ) ; int maxLen = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int length = 0 ; if ( ( arr [ i ] - 1 ) != 0 && length < um . get ( arr [ i ] - 1 ) ) length = um . get ( arr [ i ] - 1 ) ; if ( arr [ i ] > 0 && length < um . get ( arr [ i ] ) ) length = um . get ( arr [ i ] ) ; if ( ( arr [ i ] + 1 ) != 0 && length < um . get ( arr [ i + 1 ] ) ) length = um . get ( arr [ i + 1 ] ) ; um . put ( arr [ i ] , length + 1 ) ; if ( maxLen < um . get ( arr [ i ] ) ) maxLen = um . get ( arr [ i ] ) ; } if ( className . equals ( " java . util . Arrays " ) ) { int [ ] arr = { 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 } ; n = arr . length ; System . out . println ( " Maximum ▁ length ▁ subsequence ▁ = " + maxLenSub ( arr , n ) ) ; } return maxLen ; }
[ ] arr = { 1 , 3 , 5 , 2 , 4 , 6 } ; /* ▁ Rearrange ▁ the ▁ number ▁ of ▁ elements ▁ in ▁ order ▁ to ▁ keep ▁ the ▁ order ▁ of ▁ the ▁ array ▁ */ int count ; int currIdx ; int swapIdx ; int temp ; int count ; if ( ( n % 2 ) == 1 ) return 0 ; currIdx = ( int ) ( ( n - 1 ) / 2 ) ; while ( ( currIdx > 0 ) && ( count > 0 ) ) { count = currIdx ; swapIdx = currIdx ; while ( ( count > 0 ) && ( ( arr [ swapIdx ] > arr [ swapIdx ] ) == 1 ) ) { temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx = swapIdx + 1 ; count = count - 1 ; } currIdx = currIdx - 1 ; } n = arr . length ; /* ▁ Rearrange ▁ the ▁ number ▁ of ▁ elements ▁ in ▁ order ▁ to ▁ keep ▁ the ▁ order ▁ of ▁ the ▁ array ▁ */ for ( int i = 0 ; i <= n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
static final int [ ] G ( ) { final BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] [ ] F = new int [ n ] [ ] ; for ( int i = 0 ; i < n ; ++ i ) { F [ i ] = 1e7 ; } for ( int i = 0 ; i < n ; ++ i ) { F [ i ] [ 0 ] = i ; } int [ ] H = new int [ ] { ( 0 , S ) } ; while ( H . length > 0 ) { int c = heapq ( H ) ; int u = r . read ( ) ; if ( u == - 1 ) return c ; for ( int i = 0 ; i < n ; ++ i ) { } } return null ; }
static void countCharacterType ( String str ) { int vowels = 0 ; int consonant = 0 ; int specialChar = 0 ; int digit = 0 ; for ( int i = 0 ; ( i != str . length ( ) ) && ( i != str . length ( ) ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) && ( ( ch >= ' a ' && ch <= ' e ' ) || ( ch >= ' i ' && ch <= ' o ' ) || ( ch >= ' u ' ) ) ) { vowels ++ ; } else { consonant ++ ; } } else if ( ( ch >= '0' && ch <= '9' ) ) { digit ++ ; } else { specialChar ++ ; } str = " geeks ▁ for ▁ geeks121" ; countCharacterType ( str ) ; }
static int increaseInVol ( int l , int b , int h ) { int percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ) ; percentInc -- ; percentInc *= 100 ; return percentInc ; }
public static int MaxTotalRectangleArea ( int [ ] a , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; int i = 0 ; while ( ( i < n - 1 ) && ( i < n ) ) { if ( ( i != 0 ) && ( i < n ) ) { i = i + 1 ; } if ( ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == false ) ) { flag = true ; len = a [ i + 1 ] ; i = i + 1 ; } else if ( ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == true ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i = i + 1 ; } } return sum ; }
static final Node < Integer > EMPTY = new Node < Integer > ( ) { private int data ; private int next ; private Node < Integer > newNode ; public Node < Integer > getNode ( int data ) { this . data = data ; this . next = null ; return newNode ; } public Node < Integer > insertEnd ( Node < Integer > head , Node < Integer > newNode ) { if ( ( head = newNode . next ) == null ) { newNode . next = newNode ; newNode . prev = newNode ; head = newNode ; return head ; } Node < Integer > last = head . prev ; newNode . next = head ; head . prev = newNode ; newNode . prev = last ; last . next = newNode ; return head ; } public Node < Integer > reverse ( Node < Integer > head ) { if ( ( head = head . next ) == null ) { return null ; } Node < Integer > newHead = null ; last = head . prev ; Node < Integer > curr = last ; while ( ( curr = curr . prev ) != null ) { Node < Integer > prev = curr . prev ; newHead = insertEnd ( newHead , curr ) ; curr = prev ; } newHead = insertEnd ( newHead , curr ) ; return newHead ; } public void display ( Node < Integer > head ) { if ( ( head = head . next ) == null ) { return ; } Node < Integer > temp = head ; System . out . print ( " Forward ▁ direction : ▁ " ) ; while ( ( temp = temp . next ) != head ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . next ; } System . out . println ( temp . data ) ; last = head . prev ; temp = last ; System . out . print ( " Backward ▁ direction : ▁ " ) ; while ( ( temp = temp . prev ) != last ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . prev ; } System . out . println ( temp . data ) ; } }
static void lastFiveDigits ( long n ) { n = ( ( ( int ) ( n / 10000 ) ) * 10000 + ( ( ( int ) ( n / 100 ) % 10 ) ) * 1000 + ( n % 10 ) * 100 + ( ( ( int ) ( n / 10 ) % 10 ) ) * 10 + ( ( ( int ) ( n / 1000 ) % 10 ) ) ; long ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } System . out . println ( ans ) ; }
static final String compute ( ) { final int DIGITS = 100 ; final int MULTIPLIER = 100 * DIGITS ; int ans = Arrays . stream ( String . valueOf ( EulerLib . sqrt ( i * MULTIPLIER ) ) . substring ( 0 , DIGITS ) ) . filter ( i -> EulerLib . sqrt ( i ) * i != i ) . findFirst ( ) . orElse ( Integer . toString ( ans ) ) ; if ( __name__ . equals ( " _ _ main _ _ " ) ) System . out . println ( compute ( ) ) ; return " " ; }
public static void evaluate ( int n ) { if ( ( n == 1 ) || ( n == 2 ) ) { System . out . println ( " No ▁ Pythagoras " + " ▁ Triplet ▁ exists " ) ; } else if ( ( n % 2 ) == 0 ) { var = n * n / 4 ; System . out . print ( " Pythagoras ▁ Triplets " + " ▁ exist ▁ i . e . ▁ " ) ; System . out . println ( Integer . toString ( n ) + " ▁ " + Integer . toString ( var - 1 ) + " ▁ " + Integer . toString ( var + 1 ) ) ; } else { } }
public static int abx ( ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; return b - a ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) { return b ; } return gcd ( b % a , a ) ; /* ▁ find ▁ number ▁ */ int ans = arr [ 0 ] ; for ( int i = 0 ; i <= n ; i ++ ) { ans = gcd ( ans , arr [ i ] ) ; } }
static int countKdivPairs ( int [ ] A , int n , int K ) { int [ ] freq = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) freq [ i ] = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int rem = A [ i ] % K ; if ( ( rem != 0 ) && ( rem > 0 ) ) ans += freq [ K - rem ] ; else ans += freq [ 0 ] ; freq [ rem ] ++ ; } return ans ; }
public static void print ( String input ) { System . out . println ( input . replace ( " , " , " ▁ " ) ) ; }
private static int [ ] input ( ) { return ArrayUtil . toIntArray ( input ( ) ) ; int n = Integer . parseInt ( input ( ) ) ; int [ ] list = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { list [ i ] = input . nextInt ( ) ; } if ( list [ 0 ] != list [ n - 1 ] ) System . out . println ( n - 1 ) ; else { int i = 1 ; while ( i < n && list [ i ] == list [ 0 ] ) i ++ ; int j = n - 2 ; while ( j >= 0 && list [ j ] == list [ 0 ] ) j -- ; System . out . println ( Math . max ( n - i - 1 , j ) ) ; } return list ; }
static int countSubarrays ( int arr [ ] , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hashPositive = new int [ n + 1 ] ; int [ ] hashNegative = new int [ n + 1 ] ; hashPositive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) { difference = difference + 1 ; } else { difference = difference - 1 ; } if ( ( difference < 0 ) && ( arr [ i ] == 1 ) ) { ans += hashNegative [ arr . length - difference ] ; hashNegative [ arr . length - difference ] = hashNegative [ arr . length - difference ] + 1 ; } else { ans += hashPositive [ difference ] ; hashPositive [ arr . length - difference ] = hashPositive [ arr . length - difference ] + 1 ; } } return ans ; }
static void printChar ( String string , int n ) { int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i <= n ; i ++ ) { freq [ ( string . charAt ( i ) - ' a ' ) ] ++ ; } for ( int i = 0 ; i <= n ; i ++ ) { if ( ( freq [ ( string . charAt ( i ) - ' a ' ) ] % 2 ) == 0 ) { System . out . print ( string . charAt ( i ) + " , ▁ " ) ; } } if ( getClass ( ) . getName ( ) . equals ( " java . lang . String " ) ) { string = " geeksforgeeks " ; n = string . length ( ) ; printChar ( string , n ) ; } }
public static void printChar ( String str_ , int n ) { final int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ ( str_ . charAt ( i ) - ' a ' ) ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( freq [ ( str_ . charAt ( i ) - ' a ' ) ] ) % 2 == 1 ) { System . out . print ( " " + str_ . charAt ( i ) ) ; } } }
static int countGreater ( int [ ] arr , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( ( l <= r ) && ( r <= n ) ) { int m = ( int ) ( l + ( r - l ) / 2 ) ; if ( ( arr [ m ] > k ) && ( arr [ m ] > k ) ) { leftGreater = m ; r = m - 1 ; } else { l = m + 1 ; } } return ( n - leftGreater ) ; }
public static int [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [
@ Test public static void findAandB ( int N ) { double val = N * N - 4.0 * N ; if ( ( val < 0 ) || ( val > 1.0 ) ) { System . out . println ( " NO " ) ; return ; } double a = ( N + Math . sqrt ( val ) ) / 2.0 ; double b = ( N - Math . sqrt ( val ) ) / 2.0 ; System . out . println ( " a ▁ = " + String . format ( " { 0 : . 6 } " , a ) ) ; System . out . println ( " b ▁ = " + String . format ( " { 0 : . 6 } " , b ) ) ; }
static final Scanner input = new Scanner ( System . in ) { @ Override public void close ( ) { Scanner scanner = new Scanner ( System . in ) ; for ( ; ; ) { int n = scanner . nextInt ( ) ; int c = 0 , d = 10 * 9 ; for ( int i = 0 ; i < n ; i ++ ) { int a = Integer . parseInt ( scanner . nextLine ( ) ) ; int b = Integer . parseInt ( scanner . nextLine ( ) ) ; if ( a > c ) { c = a ; } if ( b < d ) { d = b ; } } if ( c <= d ) { System . out . println ( 0 ) ; } else { System . out . println ( c - d ) ; } } } }
private static String [ ] getStrings ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) , m = Integer . parseInt ( input . nextLine ( ) ) ; List < String > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = input . nextLine ( ) ; Set < String > x = new HashSet < > ( s ) ; if ( " X " . equals ( x ) ) ans . add ( s ) ; } List < String > ans2 = ans . stream ( ) . map ( String :: valueOf ) . collect ( Collectors . toList ( ) ) ; return ans2 . toArray ( ) ; }
public static int INF = 10 ** 10 ; int MOD = 10 ** 9 + 7 ; { A = A . substring ( 0 , A . length ( ) - 1 ) ; B = B . substring ( 0 , B . length ( ) - 1 ) ; C = C . substring ( 0 , C . length ( ) - 1 ) ; int [ ] before = { 1 , 0 , 0 } ; int N = A . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] dp = new int [ 3 ] ; int s = 0 ; if ( i == N - 1 ) s ++ ; for ( int j = 0 ; j < 3 ; j ++ ) { for ( int a = s ; a < 10 ; a ++ ) { if ( A . charAt ( i ) != ' ? ' && Integer . parseInt ( A . substring ( i , a ) ) != a ) continue ; for ( int b = s ; b < 10 ; b ++ ) { if ( B . charAt ( i ) != ' ? ' && Integer . parseInt ( B . substring ( i , b ) ) != b ) continue ; for ( int c = s ; c < 10 ; c ++ ) { if ( C . charAt ( i ) != ' ? ' && Integer . parseInt ( C . substring ( i , c ) ) != c ) continue ; if ( ( j + a + b ) % 10 != c ) continue ; dp [ ( j + a + b ) / 10 ] += before [ j ] ; dp [ ( j + a + b ) / 10 ] %= MOD ; } } } } before = dp ; } int ans = before [ 0 ] ; System . out . println ( ans ) ; }
public static int n = Integer . parseInt ( input ) { for ( int i = 0 ; i < n ; i ++ ) { int test = Integer . parseInt ( input . nextLine ( ) ) ; int move = 0 ; while ( test != 1 ) { if ( test % 6 == 0 ) { test = test / 6 ; move ++ ; } else if ( test % 3 == 0 ) { test = test * 2 ; move ++ ; } else { System . out . println ( - 1 ) ; break ; } } else { System . out . println ( move ) ; } } return 0 ; }
static int minIncrementForUnique ( int [ ] A ) { final int [ ] count = CollectionHelper . getSortedIntArray ( A ) ; final Stack < Integer > taken = new Stack < > ( ) ; int ans = 0 ; for ( int x = 0 ; x < 100000 ; x ++ ) { if ( count [ x ] >= 2 ) taken . push ( x ) ; else taken . pop ( ) ; } return ans ; }
public static void main ( ) { n = ( int ) input . nextInt ( ) ; n -- ; if ( n < 0 ) { n = 0 ; } System . out . println ( ( 3 * ( n ) ) % 1000003 ) ; }
static final int MOD = ( int ) ( 1e9 + 7 ) ; int n ; int [ ] [ ] dp = new int [ n + 1 ] [ 13 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int nxt = ( int ) s . charAt ( i ) - '0' ; if ( ( s . charAt ( i ) == ' ? ' ) && ( j < 13 ) ) nxt = j ; for ( int k = 0 ; k < 13 ; k ++ ) { int rem = ( 10 * k + nxt ) % 13 ; dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; dp [ i + 1 ] [ rem ] %= MOD ; } if ( ( s . charAt ( i ) != ' ? ' ) && ( j < 13 ) ) break ; } } if ( __name__ . equals ( " java . lang . String " ) ) { String s = " ? 44" ; n = s . length ( ) ; System . out . println ( modulo_13 ( s , n ) ) ; } return ( int ) dp [ n ] [ 5 ] ; }
@ GwtIncompatible ( " java . util . concurrent . atomic . AtomicInteger " ) public static int countNums ( int a , int b , int c , int d ) { int x = b / c - ( a - 1 ) / c ; int y = b / d - ( a - 1 ) / d ; int k = ( c * d ) / gcd ( c , d ) ; int z = b / k - ( a - 1 ) / k ; return ( b - a + 1 - x - y + z ) ; }
static void printSubstrings ( int n ) { final int s = ( int ) Math . log10 ( n ) ; int d = ( Math . pow ( 10 , s ) ) ; int k = d ; while ( ( n > 0 ) && ( d > 0 ) ) { while ( ( d > 0 ) && ( n < d ) ) { System . out . println ( ( int ) ( n / d ) ) ; d = ( int ) ( d / 10 ) ; } n = ( int ) ( n % k ) ; k = ( int ) ( k / 10 ) ; d = k ; } if ( getClass ( ) . equals ( " java . lang . String " ) ) { n = 123 ; printSubstrings ( n ) ; } }
public static String NthCharacter ( int n ) { String s = " " ; int c = 1 ; while ( ( c = ( c = ( c + 1 ) ) ) != 0 ) { if ( ( c < 10 ) && ( c > 0 ) ) { s += ( char ) ( 48 + c ) ; } else { String s1 = " " ; int dup = c ; while ( ( dup > 0 ) && ( dup < 10 ) ) { s1 += ( char ) ( ( dup % 10 ) + 48 ) ; dup /= 10 ; } s1 = new String ( s1 ) ; s += s1 ; } c ++ ; if ( ( s . length ( ) >= n ) && ( s . charAt ( n - 1 ) == ' ▁ ' ) ) { return s . substring ( n - 1 ) ; } } if ( className . equals ( " java . lang . String " ) ) { n = 11 ; System . out . println ( NthCharacter ( n ) ) ; } return s ; }
public static int days ( int y , int m , int d ) { int cnt = 0 ; for ( int i = 1 ; i < y ; i ++ ) { if ( i % 3 == 0 ) { cnt += 200 ; } else { cnt += 195 ; } } for ( int i = 1 ; i < m ; i ++ ) { if ( y % 3 == 0 ) { cnt += 20 ; } else { if ( i % 2 == 0 ) { cnt += 19 ; } else { cnt += 20 ; } } } cnt += d - 1 ; return cnt ; } int n = Integer . parseInt ( input . nextLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { y = Integer . parseInt ( input . nextLine ( ) ) ; m = Integer . parseInt ( input . nextLine ( ) ) ; d = Integer . parseInt ( input . nextLine ( ) ) ; System . out . println ( days ( 1000 , 1 , 1 ) - days ( y , m , d ) ) ; }
public static boolean checkPrime ( int n ) { if ( ( n <= 1 ) && ( n <= 3 ) ) { return false ; } if ( ( n % 2 == 0 ) || ( n % 3 == 0 ) ) { return false ; } for ( int i = 5 ; i <= n ; i += 6 ) { if ( ( n % i == 0 ) || ( n % ( i + 2 ) == 0 ) ) { return false ; } } return true ; }
@ Function public static void main ( String [ ] args ) { @ SuppressWarnings ( " unchecked " ) List < Integer > hlist = ( List < Integer > ) Arrays . asList ( args ) ; hlist . stream ( ) . forEach ( ( n , m ) -> { int [ ] a = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] b = Integer . parseInt ( input . nextLine ( ) ) ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; } ) ; }
public static int catalan ( int n ) { if ( ( n == 0 ) || ( n == 1 ) ) { return 1 ; } int [ ] catalan = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { catalan [ i ] = 0 ; } catalan [ 0 ] = 1 ; catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { catalan [ i ] = catalan [ i ] + catalan [ j ] * catalan [ i - j - 1 ] ; } } return catalan [ n ] ; }
static final String compute ( ) { final double TARGET = Maths . toFraction ( 15499 , 94744 ) ; long totient = 1 ; long denominator = 1 ; int p = 2 ; do { totient *= p - 1 ; denominator *= p ; do { p ++ ; } while ( EulerLibrary . isPrime ( p ) ) ; } while ( totient < TARGET ) ; for ( int i = 1 ; i < p ; i ++ ) { long numer = i * totient ; long denom = i * denominator ; if ( Maths . toFraction ( numer , denom - 1 ) < TARGET ) { return String . valueOf ( denom ) ; } } if ( __name__ . equals ( " java . util . concurrent . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation . computation .
@ Function public static LinkedList < Point > from ( String path ) { String [ ] path = input . split ( " ▁ " ) ; HashSet < Point > coord = new HashSet < Point > ( ) ; coord . add ( new Point ( 0 , 0 ) ) ; Point temp = new Point ( 0 , 0 ) ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { char c = path [ i ] . charAt ( 0 ) ; if ( c == ' L ' ) temp = new Point ( temp . x , temp . y - 1 ) ; else if ( c == ' R ' ) temp = new Point ( temp . x , temp . y + 1 ) ; else if ( c == ' U ' ) temp = new Point ( temp . x - 1 , temp . y ) ; else temp = new Point ( temp . x + 1 , temp . y ) ; if ( coord . contains ( temp ) ) { coord . remove ( new Point ( p , q ) ) ; que += new Point ( p , q ) ; } } System . out . println ( " OK " ) ; return coord ; }
static boolean isPrime ( int n ) { if ( n <= 1 ) { return false ; } if ( n == 2 ) { return true ; } if ( n % 2 == 0 ) { return false ; } for ( int i = 3 ; i <= ( int ) Math . sqrt ( n ) ; i += 2 ) { if ( n % i == 0 ) { return false ; } } return true ; /* ▁ Possible ▁ if ▁ n ▁ is ▁ prime ▁ and ▁ n ▁ is ▁ prime ▁ */ if ( isPrime ( n ) && isPrime ( n - 2 ) ) { return true ; } else { return false ; } int n = 13 ; if ( isPossible ( n ) == true ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
static int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
public static void for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; if ( ( n <= 30 ) && ( n <= 31 ) ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; if ( ( n == 40 ) || ( n == 36 ) || ( n == 44 ) ) { System . out . println ( "6 ▁ 10 ▁ 15 ▁ " + ( n - 31 ) ) ; } else { System . out . println ( "6 ▁ 10 ▁ 14" + ( n - 30 ) ) ; } } }
@ Produces @ ApplicationScoped public static String solve ( @ Named ( " string " ) String string ) { int n = Integer . parseInt ( string ) ; int ... a = Integer . parseInt ( string ) ; return String . valueOf ( reduce ( a , n ) ) ; }
static final int [ ] getCopies ( ) { final int [ ] a = new int [ input . length ] ; for ( int i = 0 ; i <= 14 ; i ++ ) { a [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } int ans = 0 ; for ( int i = 0 ; i <= 14 ; i ++ ) { final int [ ] x = new int [ a . length ] ; final int n = a [ i ] / 14 ; final int r = a [ i ] % 14 ; x [ i ] = 0 ; for ( int j = 0 ; j <= 14 ; j ++ ) { x [ j ] += n ; } if ( r >= 13 - i ) { for ( int j = i + 1 ; j <= 14 ; j ++ ) { x [ j ] ++ ; } for ( int j = 0 ; j <= r - 13 + i ; j ++ ) { x [ j ] ++ ; } } else { for ( int j = i + 1 ; j <= i + 1 + r ; j ++ ) { x [ j ] ++ ; } } int summ = 0 ; for ( int j : x ) { if ( j % 2 == 0 ) { summ += j ; } } ans = Math . max ( ans , summ ) ; } System . out . println ( ans ) ; return a ; }
private static double pentdiagonal ( double a ) { if ( ( a < 0 ) || ( a > 0 ) ) { return - 1 ; } double d = 1.22 * a ; return d ; }
static int hexDiagonal ( int a ) { if ( ( a < 0 ) || ( a > 255 ) ) return - 1 ; double d = 1.73 * a ; return d ; }
public static void translate ( String st ) { int l = st . length ( ) ; if ( ( l < 2 ) || ( l > l ) ) { return ; } int i = 0 ; int j = 0 ; while ( ( j < l - 1 ) && ( i < l ) ) { if ( ( st . charAt ( j ) == ' A ' ) && ( st . charAt ( j + 1 ) == ' B ' ) ) { j += 2 ; st . set ( i , ' C ' ) ; i ++ ; continue ; } st . set ( i , st . charAt ( j ) ) ; j ++ ; } if ( ( j == l - 1 ) && ( i < l ) ) { st . set ( j ) ; i ++ ; } }
public static void translate ( String st ) { for ( int i = 1 ; i < st . length ( ) ; i ++ ) { if ( ( st . charAt ( i - 1 ) == ' A ' ) && ( st . charAt ( i ) == ' B ' ) ) { st . setChar ( i - 1 , ' C ' ) ; for ( int j = i ; j < st . length ( ) - 1 ; j ++ ) { st . setChar ( j + 1 ) ; } st . setChar ( ' ▁ ' ) ; } } }
static final String compute ( ) { final int TARGET = 2000 ; int count = 2 ; for ( int ring = 2 ; ring < 2 ; ring ++ ) { if ( Arrays . binarySearch ( new EulerBigInteger ( ring * 6 - 1 , ring * 6 + 1 , ring * 12 + 5 ) , new EulerBigInteger ( ring * 6 - 1 , ring * 6 + 5 , ring * 12 - 7 ) ) >= 0 ) { count ++ ; if ( count == TARGET ) return String . valueOf ( ring * ( ring - 1 ) * 3 + 2 ) ; } if ( Arrays . binarySearch ( new EulerBigInteger ( ring * 6 - 1 , ring * 6 + 5 , ring * 12 - 7 ) , new EulerBigInteger ( ring * 6 - 1 , ring * 6 + 5 , ring * 12 - 7 ) ) >= 0 ) { count ++ ; if ( count == TARGET ) return String . valueOf ( ring * ( ring + 1 ) * 3 + 1 ) ; } } if ( __name__ . equals ( " java . util . concurrent . ConcurrentLinkedQueue " ) ) { System . out . println ( compute ( ) ) ; } return " " ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; int x = Math . min ( n , m ) ; List < Integer > li = new ArrayList < > ( ) ; for ( int i = 0 ; i < x + 1 ; i ++ ) { double x1 = Math . pow ( i , 2 ) ; for ( int j = 0 ; j < x ; j ++ ) { double y1 = Math . pow ( j , 2 ) ; if ( ( x1 + j == n ) && ( i + y1 == m ) ) li . add ( new Integer ( i ) ) ; } } System . out . println ( li . size ( ) ) ; }
private static void digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( ( n = n % 10 ) != 0 ) { int r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = n / 10 ; } System . out . println ( largest + " ▁ " + smallest ) ; }
public static void solve ( int d1 , int d2 , int d3 ) { int maxx = Math . max ( d1 , Math . max ( d2 , d3 ) ) ; int sum = ( d1 + d2 + d3 ) ; if ( ( 2 * maxx > sum ) || ( sum % 2 == 1 ) ) { System . out . println ( " - 1" ) ; return ; } int x1 = 0 ; int y1 = 0 ; int x2 = d1 ; int y2 = 0 ; int x3 = ( d2 + d3 - d1 ) / 2 ; int y3 = ( y2 + d3 ) / 2 ; }
public static boolean distributingBalls ( int k , int n , String string ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ ( string . charAt ( i ) - ' a ' ) ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( ( a [ i ] > k ) && ( a [ i ] > n ) ) { return false ; } } return true ; }
public static void main ( String input ) { for ( ; ; ) { int N = Integer . parseInt ( input ) ; String S = input . substring ( 0 , N ) ; int ctr = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == ' T ' ) { ctr ++ ; } else { ctr -- ; } if ( ctr > N / 3 || ctr < 0 ) { break ; } } System . out . println ( ctr == N / 3 ? " YES " : " NO " ) ; } }
; e = list ( map . get ( input ) ) ; e . sort ( ) ; boolean frag = true ; for ( int i = 1 ; i < 4 ; i ++ ) { if ( e [ 0 ] != e [ i ] ) { frag = false ; break ; } } return frag ? " yes " : " no " ; }
static final int R = 4 ; final int C = 4 ; int first ( int arr [ ] , int low , int high ) { int mid ; if ( ( high >= low ) && ( arr [ high ] > 0 ) ) { mid = low + ( high - low ) / 2 ; if ( ( ( mid == 0 ) || ( arr [ mid - 1 ] == 0 ) ) && ( arr [ mid ] == 1 ) ) { return mid ; } else if ( ( arr [ mid ] == 0 ) ) { return first ( arr , ( mid + 1 ) , high ) ; } else { return first ( arr , low , ( mid - 1 ) ) ; } } return - 1 ; }
static final int bitAtGivenPosSetOrUnset ( int n , int k ) { int newNum = n > > ( k - 1 ) ; return ( newNum & 1 ) ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; StringBuilder sb = new StringBuilder ( ) ; if ( n % 4 == 0 ) { int k = n / 4 ; int a = sb . indexOf ( ' A ' ) ; int b = sb . indexOf ( ' G ' ) ; int c = sb . indexOf ( ' C ' ) ; int d = sb . indexOf ( ' T ' ) ; if ( a > k || b > k || c > k || d > k ) { System . out . println ( " = = = " ) ; } else { for ( int i = 0 ; i < k - a ; i ++ ) { sb . append ( ' ? ' ) ; } for ( int j = 0 ; j < k - b ; j ++ ) { sb . append ( ' G ' ) ; } for ( int m = 0 ; m < k - c ; m ++ ) { sb . append ( ' C ' ) ; } for ( int t = 0 ; t < k - d ; t ++ ) { sb . append ( ' T ' ) ; } System . out . println ( sb . toString ( ) ) ; } } else { System . out . println ( " = = = " ) ; } }
@ Parameters ( ) public static void mv ( ) { mv = new Vector ( ) ; mv . add ( new Vector ( ) ) ; mv . add ( new Vector ( ) ) ; mv . add ( new Vector ( ) ) ; mv . add ( new Vector ( ) ) ; mv . add ( new Vector ( ) ) ; n = Integer . parseInt ( input ) ; if ( n == 0 ) break ; char t1 = input . charAt ( 0 ) ; char t2 = input . charAt ( 0 ) ; char t3 = input . charAt ( 0 ) ; int s = ( t1 - ' A ' ) , t = ( t2 - ' A ' ) , b = ( t3 - ' A ' ) ; f = new Vector ( ) ; for ( int a = 0 ; a < 3 ; a ++ ) for ( int c = 0 ; c < 3 ; c ++ ) for ( int r = 0 ; r < 17 ; r ++ ) f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new Vector ( ) ) ; f . add ( new
public static void print ( String input ) { int l = Integer . parseInt ( input ) ; int r = Integer . parseInt ( input ) ; Set < Integer > result = new HashSet < Integer > ( ) ; for ( int x = 0 ; x < 31 ; x ++ ) { for ( int y = 0 ; y < 20 ; y ++ ) { int v = 2 * x * 3 * y ; if ( l <= v && v <= r ) { result . add ( v ) ; } } } System . out . println ( result . size ( ) ) ; }
static void N ( int N , int K ) { int L = 1 ; for ( int i = 0 ; i < N ; i ++ ) L += Math . min ( L , K ) ; System . out . println ( L ) ; }
static boolean arePermutations ( int [ ] a , int [ ] b , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }
static void findAndPrintUncommonChars ( String str1 , String str2 ) { int [ ] present = new int [ MAX_CHAR ] ; for ( int i = 0 ; ( present [ i ] = 0 ) != 0 ; ++ i ) { present [ i ] = 0 ; } int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; ( i < l1 ) && ( present [ ( int ) str1 . charAt ( i ) - ' a ' ) ] == 1 ; ++ i ) { present [ ( int ) str2 . charAt ( i ) - ' a ' ] = 1 ; } for ( int i = 0 ; ( i < l2 ) && ( present [ ( int ) str2 . charAt ( i ) - ' a ' ) ] == - 1 ; ++ i ) { present [ ( int ) str2 . charAt ( i ) - ' a ' ] = - 1 ; } for ( int i = 0 ; ( i < MAX_CHAR ) && ( present [ i ] = 1 ) != 0 ; ++ i ) { if ( ( present [ i ] = 1 ) != 0 || ( present [ i ] = 2 ) != 0 ) { System . out . print ( ( char ) ( i + ' a ' ) ) ; } } if ( className . equals ( " java . lang . String " ) ) { str1 = " characters " ; str2 = " alphabets " ; findAndPrintUncommonChars ( str1 , str2 ) ; } }
static boolean isInside ( int circleX , int circleY , int rad , int x , int y ) { if ( ( ( x - circleX ) * ( x - circleX ) + ( y - circleY ) * ( y - circleY ) <= rad * rad ) ) { return true ; } else { return false ; } } x = 1 ; y = 1 ; circleX = 0 ; circleY = 1 ; rad = 2 ; if ( ( isInside ( circleX , circleY , rad , x , y ) ) ) { System . out . println ( " Inside " ) ; } else { System . out . println ( " Outside " ) ; } return false ; }
static int minSum ( int arr [ ] , int n , int x ) { int Sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i <= n ; i ++ ) { Sum += arr [ i ] ; if ( ( arr [ i ] % x ) == 0 && largestDivisible < arr [ i ] ) { largestDivisible = arr [ i ] ; } if ( arr [ i ] < minimum ) { minimum = arr [ i ] ; } } if ( largestDivisible == - 1 ) { return Sum ; } int sumAfterOperation = ( Sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ) ; return Math . min ( Sum , sumAfterOperation ) ; }
public static int nthTerm ( int n ) { int nth = 0 ; if ( ( n % 2 ) == 0 ) { nth = 2 * ( ( n * n ) - n ) ; } else { nth = ( 2 * n * n ) - n ; } return nth ; }
public static Node < Integer > create ( ) { Node < Integer > node = new Node < Integer > ( ) ; node = tail . prev ; while ( node != null ) { st . add ( node . value ) ; node = node . prev ; } while ( node != null ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; Node < Integer > tail = new Node < Integer > ( null ) ; node = tail ; for ( ; ; ) { String command = input . nextLine ( ) ; if ( command . startsWith ( "0" ) ) { Node < Integer > nn = new Node < Integer > ( Integer . parseInt ( command . substring ( 2 ) ) ) ; nn . prev = node . prev ; nn . next = node ; if ( node . prev != null ) { node . prev . next = nn ; } node . prev = nn ; node = node . prev ; } else if ( command . startsWith ( "1" ) ) { int i = Integer . parseInt ( command . substring ( 2 ) ) ; if ( i > 0 ) { for ( ; i > 0 ; i -- ) { node = node . next ; } } else { for ( ; - i > 0 ; i -- ) { node = node . prev ; } } } else if ( command . startsWith ( "2" ) ) { Node < Integer > p = node . prev ; n = node . next ; node . prev = null ; node = n ; if ( p == null ) { n . prev = null ; } else { n . prev = p ; p . next = n ; } } else { throw new IllegalArgumentException ( " invalid ▁ command " ) ; } } Stack < Integer > st = new Stack < Integer > ( ) ; node = tail . prev ; while ( node != null ) { st . push ( node . value ) ; node = node . prev ; } while ( st . size ( ) > 0 ) { System . out . println ( st . pop ( ) ) ; } } if ( getClass ( ) . equals ( Node . class ) ) { run ( ) ; } return node ; }
public static int n ( ) { int k = Integer . parseInt ( input . nextLine ( ) . split ( " ▁ " ) [ 0 ] ) ; String s = input . nextLine ( ) ; int common = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { String a = s . substring ( n - 1 - i ) ; String b = s . substring ( 0 , i + 1 ) ; if ( ( a . equals ( b ) ) ) { common = i ; continue ; } } return ans ; }
static Node newNode ( int [ ] data ) { Node root ; Node . Data data ; Node . Data left = null ; Node . Data right = null ; Node . Data data ; Node . Data data ; Node . Data data ; Node . Data data ; Node . Data data ; Node . Data data ; Node . Data data ; Node . Data data ; Node . Data data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data = data ; data
public static String findSubString ( String string , String pat ) { int len1 = string . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } int [ ] hashPat = new int [ no_of_chars ] ; char [ ] hashStr = new char [ no_of_chars ] ; for ( int i = 0 ; i <= len2 ; i ++ ) { hashPat [ ( char ) pat . charAt ( i ) ] ++ ; } int start = 0 , startIndex = - 1 , minLen = Double . MAX_VALUE ; int count = 0 ; for ( int j = 0 ; j <= len1 ; j ++ ) { hashStr [ ( char ) string . charAt ( j ) ] ++ ; if ( ( hashPat [ ( char ) string . charAt ( j ) ] != 0 ) && ( hashStr [ ( char ) string . charAt ( j ) ] <= hashPat [ ( char ) string . charAt ( j ) ] ) ) count ++ ; if ( count == len2 ) { while ( ( hashStr [ ( char ) string . charAt ( start ) ] > hashPat [ ( char ) string . charAt ( start ) ] ) || ( hashStr [ ( char ) string . charAt ( start ) ] == 0 ) ) { if ( ( hashStr [ ( char ) string . charAt ( start ) ] > hashPat [ ( char ) string . charAt ( start ) ] ) ) hashStr [ ( char ) string . charAt ( start ) ] -- ; start ++ ; } int lenWindow = j - start + 1 ; if ( minLen > lenWindow ) { minLen = lenWindow ; startIndex = start ; } } } if ( startIndex == - 1 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } return string . substring ( startIndex , startIndex + minLen ) ; }
static final double tri ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { return Math . abs ( ( x2 - x1 ) * ( y3 - y1 ) - ( y2 - y1 ) * ( x3 - x1 ) ) / 2 ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; int [ ] array = new int [ n + m ] ; for ( int i = 0 ; i < n ; i ++ ) { array [ i ] = input . nextInt ( ) ; } if ( n > m ) System . out . println ( " YES " ) ; else if ( n < m ) System . out . println ( " NO " ) ; else if ( n == m ) { if ( new HashSet < > ( array ) . size ( ) % 2 != 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public static int [ ] addPrimes ( ) { int n = MAX ; boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p <= n ; p ++ ) { if ( p * p > n ) break ; if ( ( prime [ p ] = prime [ p ] ) == true ) { for ( int i = 2 * p ; i <= n ; i += p ) prime [ i ] = false ; } } int [ ] ans = new int [ n + 1 ] ; for ( int p = 2 ; p <= n ; p ++ ) { if ( ( prime [ p ] = prime [ p ] ) == true ) ans [ p ] = true ; } return ans ; }
[ ] a = new int [ 4 ] ; int [ ] b = new int [ 2 ] ; for ( int i = 0 ; i < 4 ; i ++ ) a [ i ] = Integer . parseInt ( input ) ; return a ; }
public static int result ( int n , @ Nonnull int [ ] a ) { int validMin = 15 ; if ( a [ 0 ] > validMin ) { return validMin ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= validMin ) { validMin = 15 + a [ i ] ; } } return validMin >= 90 ? 90 : validMin ; } if ( getClass ( ) . isClassPresent ( String . class ) ) { n = Integer . parseInt ( input ( ) ) ; a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( input ( ) ) ; } System . out . println ( result ( n , a ) ) ; }
public static int memo ( int index , int evenSum , int oddSum , int tight ) { if ( index == v . length ) { if ( evenSum > oddSum ) return 1 ; else return 0 ; } if ( dp [ index ] [ evenSum ] [ oddSum ] [ tight ] != - 1 ) return dp [ index ] [ evenSum ] [ oddSum ] [ tight ] ; int limit = tight > 0 ? v [ index ] : 9 ; int ans = 0 ; for ( int d = 0 ; d < limit + 1 ; d ++ ) { int currTight = 0 ; if ( d == v [ index ] ) currTight = tight ; if ( d % 2 != 0 ) ans += memo ( index + 1 , evenSum , oddSum + d , currTight ) ; else ans += memo ( index + 1 , evenSum + d , oddSum , currTight ) ; } dp [ index ] [ evenSum ] [ oddSum ] [ tight ] = ans ; return ans ; }
public static List < List < Integer > > list = new ArrayList < > ( ) { @ Override public int [ ] [ ] get ( int input ) { for ( int i = 0 ; i < 3 ; i ++ ) { list . add ( new LinkedList < > ( ) ) ; } int total = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { total += list . get ( i ) . get ( j ) ; } } total = total / 3 ; boolean flag = true ; for ( int i = 0 ; i < 3 ; i ++ ) { int a = list . get ( 0 ) . get ( i % 3 ) + list . get ( 1 ) . get ( ( i + 1 ) % 3 ) + list . get ( 2 ) . get ( ( i + 2 ) % 3 ) ; if ( a != total ) { flag = false ; } } int a = list . get ( 0 ) . get ( 0 ) + list . get ( 1 ) . get ( 2 ) + list . get ( 2 ) . get ( 1 ) ; if ( a != total ) { flag = false ; } a = list . get ( 1 ) . get ( 1 ) + list . get ( 0 ) . get ( 2 ) + list . get ( 2 ) . get ( 0 ) ; if ( a != total ) { flag = false ; } a = list . get ( 2 ) . get ( 2 ) + list . get ( 1 ) . get ( 0 ) + list . get ( 0 ) . get ( 1 ) ; if ( a != total ) { flag = false ; } if ( flag ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return list . toArray ( new List [ 3 ] ) ; } }
public static void solve ( ) { for ( int t = 0 ; t < Integer . parseInt ( input . nextLine ( ) ) ; t ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] diff = new int [ n ] ; for ( String s : input . nextLine ( ) . split ( " ▁ " ) ) diff [ 0 ] = Integer . parseInt ( s ) ; int [ ] arr = new int [ n ] ; arr [ 0 ] = diff [ 0 ] ; boolean flag = false ; for ( int i = 1 ; i < diff . length ; i ++ ) { int x = arr [ i - 1 ] + diff [ i ] ; int y = arr [ i - 1 ] - diff [ i ] ; if ( y >= 0 && x != y ) { flag = true ; break ; } else arr [ i ] = x ; } if ( flag ) System . out . println ( - 1 ) ; else { for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } } if ( className . equals ( " org . apache . commons . math . solve " ) ) solve ( ) ; }
public static String compute ( ) { return "0" ; }
public static int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] == x ) && ( arr [ i ] == arr [ i ] ) ) { return i ; } } return - 1 ; } arr = new int [ ] { 2 , 3 , 4 , 10 , 40 } ; x = 10 ; n = arr . length ; int result = search ( arr , n , x ) ; if ( ( result == - 1 ) && ( arr [ i ] == arr [ i ] ) ) { System . out . println ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) ; } else { System . out . println ( " Element ▁ is ▁ present ▁ at ▁ index " + result ) ; }
public static int [ ] [ ] getStdOut ( ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int C = Integer . parseInt ( input . nextLine ( ) ) ; List < List < Integer > > XV = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) XV . add ( Collections . singletonList ( Integer . parseInt ( input . nextLine ( ) ) ) ) ; int [ ] RIGHTSUM = new int [ N ] ; for ( int x = 0 ; x < N ; x ++ ) RIGHTSUM [ x ] = RIGHTSUM [ x ] - XV . get ( i ) . intValue ( ) ; int [ ] LEFTSUM = new int [ N ] ; for ( int x = 0 ; x < N ; x ++ ) LEFTSUM [ x ] = LEFTSUM [ x ] - XV . get ( i ) . intValue ( ) ; int [ ] RIGHT = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) RIGHT [ i ] = RIGHTSUM [ i + 1 ] - XV . get ( i ) . intValue ( ) ; int [ ] LEFT = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) LEFT [ i ] = LEFTSUM [ i + 1 ] - ( C - XV . get ( - i - 1 ) . intValue ( ) ) ; int [ ] RIGHTMAX = new int [ N ] ; RIGHTMAX [ 0 ] = RIGHT [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) RIGHTMAX [ i ] = Math . max ( RIGHTMAX [ i - 1 ] , RIGHT [ i ] ) ; int [ ] LEFTMAX = new int [ N ] ; LEFTMAX [ 0 ] = LEFT [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) LEFTMAX [ i ] = Math . max ( LEFTMAX [ i - 1 ] , LEFT [ i ] ) ; int ANS = Math . max ( Math . max ( RIGHT , 0 ) , Math . max ( LEFT , 0 ) ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ANS < ( RIGHTSUM [ i + 1 ] - XV . get ( i ) . intValue ( ) * 2 ) + LEFTMAX [ N - i -
static int toggleBitsFromLToR ( int n , int l , int r ) { int num = ( ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ) ; return ( n ^ num ) ; }
static int MinStep ( int [ ] a , int n ) { int positive = 0 ; int negative = 0 ; int zero = 0 ; int step = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == 0 ) && ( a [ i ] == 0 ) ) { zero ++ ; } else if ( ( a [ i ] < 0 ) && ( a [ i ] > 0 ) ) { negative ++ ; step = step + ( - 1 - a [ i ] ) ; } else { positive ++ ; step = step + ( a [ i ] - 1 ) ; } } if ( ( negative % 2 ) == 0 ) { step = step + zero ; } else { if ( ( zero > 0 ) && ( a [ i ] > 0 ) ) { step = step + zero ; } else { step = step + 2 ; } } return step ; }
static final String print ( String s ) { final int n = Integer . parseInt ( s ) ; final int a = Integer . parseInt ( s ) ; final int b = Integer . parseInt ( s ) ; return s . substring ( n ) ; }
public static void main ( String input ) { for ( ; ; ) { int n = Integer . parseInt ( input ) ; List < Integer > v = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { v . add ( Integer . parseInt ( input ) ) ; } Collections . sort ( v ) ; System . out . println ( v . get ( n - 1 ) + v . get ( n - 2 ) ) ; } }
@ org . python . Method ( __doc__ = " noOfSquares " ) public static void noOfSquares ( int x1 , int y1 , int x2 , int y2 ) { int dx = Math . abs ( x2 - x1 ) ; int dy = Math . abs ( y2 - y1 ) ; int ans = dx + dy - gcd ( dx , dy ) ; System . out . println ( ans ) ; }
public static String getMaximum ( String s , int [ ] a ) { StringBuilder sb = new StringBuilder ( s ) ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( int ) s . charAt ( i ) - '0' ) < a [ ( int ) s . charAt ( i ) - '0' ] ) { int j = i ; while ( ( j < n ) && ( ( int ) s . charAt ( j ) - '0' <= a [ ( int ) s . charAt ( j ) - '0' ] ) ) { sb . append ( ( char ) ( '0' + a [ ( int ) s . charAt ( j ) - '0' ] ) ) ; j ++ ; } return sb . toString ( ) ; } } return s ; }
public static boolean isOctal ( int n ) { while ( ( n != 0 ) && ( ( n % 10 ) >= 8 ) ) { return false ; } /* ▁ TODO ▁ Auto - generated ▁ method ▁ stub ▁ */ int divide = ( isOctal ( n ) == false ) ? 8 : 10 ; int [ ] octal = new int [ MAX_DIGITS ] ; while ( ( n != 0 ) && ( n % divide != 0 ) ) { octal [ -- k ] = n % divide ; n = ( int ) ( n / divide ) ; } int j = octal . length - 1 ; int k = 0 ; while ( ( k <= j ) && ( ( n % 10 ) != 0 ) ) { if ( ( octal [ j ] != octal [ k ] ) ) { return false ; } j -- ; k ++ ; } /* ▁ TODO ▁ Auto - generated ▁ method ▁ stub ▁ */ if ( getClassName ( ) . equals ( " java . lang . Integer " ) ) { int n = 97 ; if ( ( n = isPalindrome ( n ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } return true ; }
public static void main ( String input ) { int num = Integer . parseInt ( input ) ; String num = input . substring ( 0 , num ) ; int listIs [ ] = new int [ num . length ( ) ] ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { listIs [ i ] = Integer . parseInt ( num . substring ( i , i + 1 ) ) ; } int listIs1 [ ] = listIs . clone ( ) ; int listIs2 [ ] = listIs . clone ( ) ; int sum1 = Arrays . asList ( listIs1 ) . indexOf ( num ) ; int sum2 = Arrays . asList ( listIs2 ) . indexOf ( num ) ; boolean condition = false ; for ( int i = 0 ; i < listIs . length ; i ++ ) { if ( listIs [ i ] == 4 || listIs [ i ] == 7 ) { condition = true ; continue ; } else { condition = false ; break ; } } if ( condition == true ) { if ( sum1 == sum2 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { System . out . println ( " NO " ) ; } }
static int binarySearch ( int [ ] arr , int low , int high ) { if ( ( high < low ) || ( low > high ) ) return - 1 ; int mid = ( int ) ( ( low + high ) / 2 ) ; int midValue = arr [ mid ] ; if ( ( mid == arr [ mid ] ) || ( mid == arr [ mid ] ) ) return mid ; int leftIndex = Math . min ( mid - 1 , midValue ) ; int left = binarySearch ( arr , low , leftIndex ) ; if ( ( left >= 0 ) && ( left < arr [ leftIndex ] ) ) return left ; int rightIndex = Math . max ( mid + 1 , midValue ) ; int right = binarySearch ( arr , rightIndex , high ) ; return right ; }
public static int MAX = 10000 ; int [ ] prodDig = new int [ MAX ] ; int prod ; /* ▁ get ▁ digit ▁ product ▁ */ if ( ( prod = prodDig [ 0 ] ) != 0 ) return prodDig [ 0 ] ; prod = ( ( int ) ( prod % 10 ) * getDigitProduct ( ( int ) ( prod / 10 ) ) ) ; prodDig [ 0 ] = prod ; /* ▁ find ▁ seed ▁ */ int [ ] res = new int [ n ] ; for ( int i = 1 ; i < res . length ; i ++ ) { res [ i ] = i ; } return res [ 0 ] ; }
public static int N = Integer . parseInt ( input ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int K = Integer . parseInt ( input . nextLine ( ) ) ; int X = Integer . parseInt ( input . nextLine ( ) ) ; int answer = 10 * 18 ; for ( int i = 0 ; i < N - K + 1 ; i ++ ) { int left = i , right = i + K - 1 ; int al = Math . abs ( X [ left ] ) , ar = Math . abs ( X [ right ] ) ; if ( X [ left ] * X [ right ] >= 0 ) { answer = Math . min ( answer , Math . max ( al , ar ) ) ; } else { answer = Math . min ( answer , al * 2 + ar , al + ar * 2 ) ; } } System . out . println ( answer ) ; return answer ; }
public static double diff ( double n , double mid ) { if ( ( n > ( mid * mid * mid ) ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; /* ▁ cubicRoot ▁ */ double start = 0 ; double end = n ; double e = 0.0000001 ; while ( ( e = ( end + start ) ) > ( end + end ) ) { mid = ( start + end ) / 2 ; double error = diff ( n , mid ) ; if ( error <= e ) return mid ; } }
public static void print ( int n ) { int m = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } int kmax = Math . max ( a ) + m ; while ( m > 0 ) { a [ m ] ++ ; } int kmin = Math . min ( a ) ; }
public static int inv ( int a , int m ) { int m0 = m ; int x0 = 0 ; int x1 = 1 ; if ( ( m == 1 ) && ( a < 0 ) ) { return 0 ; } while ( ( a > 1 ) && ( a < 0 ) ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( ( x1 < 0 ) && ( a < 0 ) ) { x1 = x1 + m0 ; } return x1 ; }
static int findMaxOR ( int [ ] arr , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int maxOR = arr [ 0 ] ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( ( maxOR | arr [ i ] ) > maxOR ) ) { maxOR = maxOR | arr [ i ] ; count ++ ; } } return count ; }
public static int seriessum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * ( i + 1 ) / 2 ; } return sum ; }
public static int aliquotSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( n % i ) == 0 ) { sm = sm + i ; } } return sm ; }
public static int pentagonPyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
public static int fifthPowerSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sm = sm + ( i * i * i * i ) ; } return sm ; }
public static int squaresum ( int n ) { int sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sm = sm + ( i * i ) ; } return sm ; }
public static int seriessum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * ( i + 1 ) / 2 ; } return sum ; }
static int sumOfSeries ( int n ) { final int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; } return sum ; }
static int findSum ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ = ( summ + ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ) ; } return summ ; }
static final long fourthPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum = sum + ( i * i * i * i ) ; } return sum ; }
static int squareSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sum += ( 2 * i ) * ( 2 * i ) ; } return sum ; }
public static double AvgofSquareN ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += ( i * i ) ; } return sum / n ; }
static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += i * ( n - i ) ; } return 2 * sum ; }
@ GwtIncompatible ( " java . lang . String " ) public static int solve ( int n , int base ) { int sum = 0 ; while ( ( n > 0 ) && ( n < base ) ) { int remainder = n % base ; sum = sum + remainder ; n = ( int ) ( n / base ) ; } return sum ; /* ▁ SumOfDigits ▁ of ▁ the ▁ digits ▁ */ { int sum = 0 ; int N = floor ( n / 2 ) ; for ( int base = 2 ; base <= N ; base += 1 ) { sum = sum + solve ( n , base ) ; } System . out . println ( sum ) ; } if ( Class . isPrimitive ( " java . lang . String " ) ) { int n = 8 ; SumOfDigits ( n ) ; } return n ; }
static final boolean [ ] isPrime = new boolean [ 110001 ] ; final List < Integer > primes = new ArrayList < Integer > ( ) ; { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i < ( int ) Math . sqrt ( i ) ; i ++ ) { if ( isPrime [ i ] ) { int j = 2 * i ; while ( j <= n ) { isPrime [ j ] = false ; j = j + i ; } } } for ( int i = 2 ; i < 110000 ; i ++ ) { if ( isPrime [ i ] ) { primes . add ( i ) ; } } } ; eratos ( 110000 ) ; while ( true ) { try { int p = Integer . parseInt ( input . nextLine ( ) ) ; if ( p == 0 ) { break ; } int ans = 0 ; for ( int i = 0 ; i <= p ; i ++ ) { ans += primes . get ( i ) ; } System . out . println ( ans ) ; } catch ( Exception e ) { break ; } }
public static void print ( Integer bin , String s ) { System . out . println ( Integer . toBinaryString ( 4 ) . count ( '1' ) ) ; System . out . println ( Integer . toBinaryString ( 15 ) . count ( '1' ) ) ; }
public static int INT_MAX = 2147483647 ; int [ ] [ ] optimalSearchTree ( int [ ] keys , int [ ] freq , int n ) { int [ ] [ ] cost = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = freq [ i ] ; for ( int L = 2 ; L <= n ; L ++ ) { for ( int i = 0 ; i < n - L + 2 ; i ++ ) { int j = i + L - 1 ; if ( i >= n || j >= n ) break ; cost [ i ] [ j ] = INT_MAX ; for ( int r = i ; r <= j ; r ++ ) { int c = 0 ; if ( ( r > i ) && ( r < j ) ) c += cost [ i ] [ r - 1 ] ; if ( ( r < j ) && ( r < i ) ) c += cost [ r + 1 ] [ j ] ; c += sum ( freq , i , j ) ; if ( ( c < cost [ i ] [ j ] ) && ( c < cost [ i ] [ j ] ) ) cost [ i ] [ j ] = c ; } } } return cost [ 0 ] [ n - 1 ] ; }
public static int get ( int x , int y , int z ) { if ( ( x > z ) && ( y > z ) ) { return - 1 ; } int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] a = Lists . newArrayList ( ) . stream ( ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ a [ i ] - 1 ] = i ; } int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { res += Math . abs ( b [ i ] - b [ i - 1 ] ) ; } System . out . println ( res ) ; }
static int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < Math . min ( i , k ) + 1 ; j ++ ) { if ( ( j == 0 ) || ( j == i ) ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } } return C [ n ] [ k ] ; } /* ▁ max ▁ coefficientvalue ▁ */ if ( ( n % 2 ) == 0 ) { return binomialCoeff ( n , ( int ) ( n / 2 ) ) ; } else { return binomialCoeff ( n , ( int ) ( ( n + 1 ) / 2 ) ) ; } }
private static boolean isVowel ( char ch ) { switch ( ch ) { case ' a ' : case ' e ' : case ' i ' : case ' o ' : case ' u ' : return true ; default : return false ; } /* ▁ vowelPairs ▁ */ int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( isVowel ( s . charAt ( i ) ) ) && ( isVowel ( s . charAt ( i + 1 ) ) ) ) { cnt ++ ; } } return cnt ; }
public static void main ( String [ ] args ) { while ( true ) { N = Integer . parseInt ( input . nextLine ( ) ) ; if ( N == 0 ) { exit ( ) ; } final int W = Integer . parseInt ( input . nextLine ( ) ) ; final int H = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] [ ] persimmon = new int [ 100 ] [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { persimmon [ j ] [ j ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { final int x = Integer . parseInt ( input . nextLine ( ) ) ; final int y = Integer . parseInt ( input . nextLine ( ) ) ; persimmon [ x ] [ y ] = 1 ; } int [ ] [ ] cumsum = new int [ 100 ] [ 100 ] ; for ( int j = 0 ; j < 100 ; j ++ ) { for ( int i = 0 ; i < 100 ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { cumsum [ j ] [ i ] = 0 ; } for ( int i = 0 ; i < 100 ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { cumsum [ j ] [ i ] = cumsum [ j ] [ i ] + cumsum [ j ] [ i ] - cumsum [ j ] [ i ] - cumsum [ j ] [ i ] + persimmon [ j ] [ i ] ; } } } final int S = Integer . parseInt ( input . nextLine ( ) ) ; final int T = Integer . parseInt ( input . nextLine ( ) ) ; int maxPersiston = 0 ; for ( int x = S ; x <= W ; x ++ ) { for ( int y = T ; y <= H ; y ++ ) { maxPersiston = Math . max ( maxPersiston , cumsum [ x ] [ y ] + cumsum [ x - S ] [ y - T ] - cumsum [ x ] [ y - T ] - cumsum [ x - S ] [ y ] ) ; } } System . out . println ( maxPersiston ) ; } } }
static int isSubstring ( String s1 , String s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i < N - M + 1 ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( ( s2 . charAt ( i + j ) != s1 . charAt ( j ) ) ) { break ; } } if ( j + 1 == M ) { return i ; } } if ( className . equals ( " java . lang . String " ) ) { s1 = " for " ; s2 = " geeksforgeeks " ; int res = isSubstring ( s1 , s2 ) ; if ( res == - 1 ) { System . out . println ( " Not ▁ present " ) ; } else { System . out . println ( " Present ▁ at ▁ index ▁ " + res ) ; } } return - 1 ; }
static double angleOncirCumference ( double z ) { return ( z / 2 ) ; }
static void countSubarraysof1and0 ( int [ ] a , int n ) { int count1 = 0 ; int count0 = 0 ; int number1 = 0 ; int number0 = 0 ; for ( int i = 0 ; i <= n ; i += 1 ) { if ( ( a [ i ] == 1 ) && ( a [ i + 1 ] == 0 ) ) { count1 ++ ; } else { number1 += ( ( count1 ) * ( count1 + 1 ) / 2 ) ; count1 = 0 ; } } for ( int i = 0 ; i <= n ; i += 1 ) { if ( ( a [ i ] == 0 ) && ( a [ i + 1 ] == 0 ) ) { count0 ++ ; } else { number0 += ( count0 ) * ( count0 + 1 ) / 2 ; count0 = 0 ; } } if ( ( number1 > 0 ) && ( a [ i + 1 ] == 0 ) ) { number1 += ( count1 ) * ( count1 + 1 ) / 2 ; } if ( ( number0 > 0 ) && ( a [ i + 1 ] == 0 ) ) { number0 += ( count0 ) * ( count0 + 1 ) / 2 ; } System . out . println ( " Count ▁ of ▁ subarrays ▁ of ▁ 0 ▁ only : " + Integer . valueOf ( number0 ) ) ; System . out . println ( " Count ▁ of ▁ subarrays ▁ of ▁ 1 ▁ only : " + Integer . valueOf ( number1 ) ) ; }
static void printNumbers ( int N ) { int flag = 1 ; int x = N ; if ( ( N > 0 ) && ( flag == 1 ) ) { int digit ; while ( ( x > 0 ) && ( flag == 2 ) ) { digit = x % 10 ; if ( ( digit != 1 ) && ( digit != 3 ) ) { flag = 0 ; } x = x / 10 ; } if ( ( flag == 1 ) && ( x > 0 ) ) { System . out . print ( N + " ▁ " ) ; } printNumbers ( N - 1 ) ; } if ( className . equals ( " java . lang . Integer " ) ) { N = 20 ; printNumbers ( N ) ; } }
static void printPermutation ( int n , int k ) { int mx = n ; for ( int i = 1 ; i <= k ; i ++ ) { System . out . print ( mx ) ; mx -- ; } for ( int i = 1 ; i <= mx ; i ++ ) { System . out . print ( i ) ; } if ( Class . forName ( " java . util . Arrays $ Random " ) . equals ( " java . util . Arrays $ Random " ) ) { int N = 5 , K = 3 ; if ( K >= N - 1 ) { System . out . println ( " Not ▁ Possible " ) ; } else { printPermutation ( N , K ) ; } } }
public static void print ( int n ) { int n = Integer . parseInt ( input ( ) ) ; List < Integer > l = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { l . add ( Integer . valueOf ( input ( ) ) ) ; } Integer a = l . get ( 0 ) ; l . sort ( Collections . reverseOrder ( ) ) ; System . out . println ( l . indexOf ( a ) + 1 ) ; }
public static boolean isMember ( List < String > List , String key ) { for ( int i = 0 ; ( List != null ) && ( i < List . size ( ) ) ; i ++ ) { if ( key . equals ( List . get ( i ) ) ) { return true ; } } /* ▁ overlap ▁ the ▁ list ▁ of ▁ key ▁ */ for ( String key : List1 ) { if ( isMember ( List2 , key ) ) { return true ; } } /* ▁ if ▁ class ▁ is ▁ not ▁ found ▁ */ String s1 = " geeksforgeeks " ; String s2 = " geeks " ; List < String > List1 = new LinkedList < String > ( ) ; List1 . add ( s1 ) ; List < String > List2 = new LinkedList < String > ( ) ; List2 . add ( s2 ) ; String yeOrNo = String . valueOf ( overlap ( List1 , List2 ) ) ; if ( ( yeOrNo != null ) && ( yeOrNo . equals ( " Yes " ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
public static int t = Integer . parseInt ( input ) { int i = 1 ; while ( true ) { if ( i > t ) break ; int n = Integer . parseInt ( input . readLine ( ) ) ; int a = Integer . parseInt ( input . readLine ( ) ) ; int b = Integer . parseInt ( input . readLine ( ) ) ; int c = Integer . parseInt ( input . readLine ( ) ) ; int d = Integer . parseInt ( input . readLine ( ) ) ; if ( n * ( a - b ) > ( c + d ) || n * ( a + b ) < ( c - d ) ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; } i = i + 1 ; } }
static void findElements ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( arr [ j ] > arr [ i ] ) count ++ ; } if ( count >= 2 ) { } } }
static int N = 3 ; int maxPathSum [ ] [ ] tri = new int [ N ] [ N ] ; for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < i + 1 ; j ++ ) { if ( ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) ) { tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; } else { tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } }
static boolean isHeap ( int [ ] arr , int n ) { for ( int i = 0 ; i < ( int ) ( ( n - 2 ) / 2 ) + 1 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) { return false ; } if ( ( 2 * i + 2 ) < n && arr [ 2 * i + 2 ] > arr [ i ] ) { return false ; } } return true ; }
static boolean isHeap ( int [ ] arr , int i , int n ) { if ( i > ( int ) ( ( n - 2 ) / 2 ) ) return true ; if ( ( arr [ i ] >= arr [ 2 * i + 1 ] ) && ( arr [ i ] >= arr [ 2 * i + 2 ] ) && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) return true ; return false ; }
static List < Point > V = Collections . unmodifiableList ( new ArrayList < > ( ) { { for ( int i = 0 ; i < 3 ; i ++ ) { P . add ( new Point ( V . get ( 0 ) , V . get ( 1 ) ) ) ; V = V . subList ( 2 , V . size ( ) ) ; } } ) ; Point A = P . get ( 0 ) ; Point B = P . get ( 1 ) ; Point C = P . get ( 2 ) ; for ( int i = 1 ; i < 3 ; i ++ ) { int x = P . get ( i ) ; int y = P . get ( i ) ; int x0 = P . get ( 0 ) ; int y0 = P . get ( 0 ) ; P . set ( i , x - x0 , y - y0 ) ; } return P ; }
static int findMinDel ( int [ ] arr , int n ) { int minNum = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { minNum = Math . min ( arr [ i ] , minNum ) ; } int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] == minNum ) && ( arr [ i ] > 0 ) ) { cnt ++ ; } } return n - cnt ; }
static int count ( int x , int y ) { int ans = 0 ; Map < Integer , Integer > m = Maps . newHashMap ( ) ; while ( x % y != 0 ) { x %= y ; ans ++ ; if ( m . containsKey ( x ) ) { return - 1 ; } m . put ( x , 1 ) ; x *= 10 ; } return ans ; }
static boolean isPossibleToMakeDivisible ( int arr [ ] , int n ) { int remainder = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { remainder = ( remainder + arr [ i ] ) % 3 ; } return ( remainder == 0 ) ; arr = new int [ n ] ; arr [ 0 ] = 40 ; arr [ 1 ] = 50 ; arr [ 2 ] = 90 ; n = 3 ; if ( ( isPossibleToMakeDivisible ( arr , n ) ) && ( isPossibleToMakeDivisible ( arr , n ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
public static void print ( ) { final String input = System . getProperty ( " line . separator " ) ; final int N = Integer . parseInt ( input ) ; final int K = Integer . parseInt ( input ) ; final int [ ] A = Integer . parseInt ( input ) ; int ans = 0 ; final List < List < Integer > > graph = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { graph . add ( new ArrayList < > ( ) ) ; } final int [ ] Par = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int a = A [ i ] ; if ( i == 0 ) { if ( a != 1 ) ans ++ ; continue ; } Par [ i ] = a - 1 ; graph . get ( a - 1 ) . add ( i ) ; } final List < Pair < Integer > > qs = new ArrayList < > ( ) ; final AtomicInteger stack = new AtomicInteger ( 0 ) ; final int [ ] Depth = new int [ N ] ; Arrays . fill ( Depth , - 1 ) ; Depth [ 0 ] = 0 ; while ( stack . hasRemaining ( ) ) { int p = stack . getAndIncrement ( ) ; for ( int np : graph . get ( p ) ) { Depth [ np ] = Depth [ p ] + 1 ; stack . incrementAndGet ( ) ; } qs . add ( new Pair < > ( Depth [ p ] , p ) ) ; } Collections . sort ( qs , Collections . reverseOrder ( ) ) ; final boolean [ ] checked = new boolean [ N ] ; for ( int d = 0 , s = qs . size ( ) ; d < N ; d ++ ) { for ( int s = 0 ; s < N ; s ++ ) { if ( d <= K ) break ; if ( checked [ s ] ) continue ; for ( int i = 0 ; i < K - 1 ; i ++ ) s = Par [ s ] ; List < Integer > que = new ArrayList < > ( ) ; que . add ( s ) ; checked [ s ] = true ; while ( que . size ( ) > 0 ) { List < Integer > qq = new ArrayList < > ( ) ; for ( int p = 0 ; p < que . size ( ) ; p ++ ) { for ( int np : graph . get ( p ) ) { if ( ! checked [ np ] ) { checked [
static void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { int j = 1 ; for ( j = j * 3 ; j <= i ; j ++ ) { if ( ( j * 3 ) == i ) { System . out . print ( j * 3 + " ▁ " ) ; break ; } } } }
static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }
public static void main ( String input ) { try { int N = Integer . parseInt ( input ) ; int d = Integer . parseInt ( input ) ; int [ ] nums = Lists . newArrayList ( ) ; for ( int i = 0 ; i < N ; i ++ ) { nums [ i ] = Integer . parseInt ( input ) ; } Arrays . sort ( nums ) ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= i ; j -- ) { if ( Math . abs ( nums [ i ] - nums [ j ] ) <= d ) { ans = Math . max ( ans , j - i + 1 ) ; break ; } } } System . out . println ( N - ans ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } }
private static int solve ( String s ) { int a = s . charAt ( s . length ( ) - 1 ) - ' a ' ; int n = Integer . parseInt ( s . substring ( 0 , s . length ( ) - 1 ) ) ; int [ ] od = { 4 , 5 , 6 , 3 , 2 , 1 } ; int [ ] ad = { 0 , 7 , 0 , 7 } ; int c = 16 ; int ktmp = ( n - 1 ) / 4 ; int ttmp = ( n - 1 ) % 4 ; int ans = ktmp * 16 + ad [ ttmp ] + od [ a ] ; return ans ; }
static boolean isPerfectCube ( double x ) { int cr = ( int ) ( x * ( 1 / 3 ) ) ; return ( cr * cr * cr == x ) ; }
static final int input ( ) { int n = Integer . parseInt ( input ( ) ) ; String s = input ( ) ; String t = input ( ) ; String test = s + t ; if ( ( s == t ) || ( test . length ( ) == n ) ) { System . out . println ( test . length ( ) ) ; System . exit ( 0 ) ; } return n ; }
@ Nonnull public static < V > Graph < V > createGraph ( ) { class Graph { private final Map < V , Boolean > graph ; } Graph < V > graph = new Graph < V > ( ) { @ Nonnull @ Override public void addEdge ( V u , V v ) { graph . get ( u ) . add ( v ) ; } } ; DFSUtil ( V v , visited ) ; visited . put ( v , true ) ; System . out . println ( v ) ; return graph ; }
static private void countDigits ( int val , int [ ] arr ) { int digit ; while ( ( digit = val / 10 ) > 0 ) { digit = val % 10 ; arr [ ( int ) digit ] ++ ; val = val / 10 ; } /* ▁ Count ▁ the ▁ number ▁ of ▁ digits ▁ in ▁ the ▁ array ▁ */ int [ ] freqCount = new int [ 10 ] ; for ( int i = 1 ; i <= n ; i ++ ) { freqCount [ i ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { val = Math . pow ( x , i ) ; countDigits ( val , freqCount ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( freqCount [ i ] + " ▁ " ) ; } }
static final String input ( ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; LinkedList < Integer > a = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a . add ( i ) ; } String ans = " NO " ; a . sort ( ) ; while ( a . size ( ) > 0 && ! a . isEmpty ( ) ^ 1 ) { a . remove ( ) ; } a . reverse ( ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { if ( 2 * a . get ( i ) > a . get ( i + 1 ) && a . get ( i ) ^ a . get ( i + 1 ) ) { ans = " YES " ; break ; } } System . out . println ( ans ) ; }
public static void for ( int i = 0 ; i < N ; i ++ ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; System . out . println ( Math . max ( 0 , N - 2 ) ) ; }
public static void a ( String a ) { System . out . println ( " IO ▁ hb , e ▁ cmoym ▁ ek ▁ etyhbeo ▁ agrudy ! . " . substring ( Integer . parseInt ( a ( ) ) > Integer . parseInt ( a ( ) . split ( " ▁ " ) [ 1 ] + a ( ) . split ( " ▁ " ) [ 1 ] ) ) : : 2 ) ; }
public static int linearCheck ( int [ ] [ ] ar , int [ ] arr ) { int i , j ; boolean matched ; for ( i = 0 ; i < m ; i ++ ) { matched = true ; for ( j = 0 ; j < n ; j ++ ) { if ( ( ar [ i ] [ j ] != arr [ j ] ) ) { matched = false ; break ; } } if ( ( matched ) && ( i != j ) ) { return i + 1 ; } } return - 1 ; }
public static int n = Integer . parseInt ( input ) { while ( n > 0 ) { int p = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > l = Lists . newArrayList ( ) ; for ( int i = 0 ; i < p ; i ++ ) { l . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } int c = 0 ; int s = Integer . parseInt ( l . get ( 0 ) ) ; if ( s % p == 0 ) { for ( int i = 0 ; i < p ; i ++ ) { if ( l . get ( i ) > s / p ) { c ++ ; } } System . out . println ( c ) ; } else { System . out . println ( - 1 ) ; } n -- ; } return n ; }
public static double [ ] readDouble ( ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] t = Lists . newArrayList ( ) ; int [ ] v = Lists . newArrayList ( ) ; for ( int i = 0 ; i < N ; i ++ ) { t [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; v [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } int time = 0 ; int sumT = Arrays . stream ( t ) . mapToInt ( i -> i ) . sum ( ) ; double [ ] veloCap = new double [ 2 * sumT + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { veloCap [ i ] = Double . MAX_VALUE ; } for ( int i = 0 ; i < N ; i ++ ) { veloCap [ i ] = Math . min ( veloCap [ i ] , 2 * sumT - i , s ) ; } return veloCap ; }
static int nthTerm ( int n ) { return 2 * Math . pow ( n , 2 ) + 4 * n - 2 ; }
static int nthTerm ( int n ) { return 7 * Math . pow ( n , 2 ) - 7 * n + 7 ; }
static int nthTerm ( int n ) { return 5 * Math . pow ( n , 2 ) - 5 * n ; }
@ GwtIncompatible ( " java . math . BigInteger " ) public static BigInteger nthTerm ( BigInteger n ) { return BigInteger . valueOf ( n . longValue ( ) ) . add ( 2 * n . longValue ( ) ) . add ( 2 ) ; }
public static long nthTerm ( int n ) { return 2 * Math . pow ( n , 3 ) + Math . pow ( n , 2 ) ; }
static int nthTerm ( int n ) { return 2 * Math . pow ( n , 2 ) - n - 1 ; }
@ GwtIncompatible ( " java . math . BigInteger " ) public static BigInteger nthTerm ( BigInteger n ) { return BigInteger . valueOf ( n . bitLength ( ) ) . subtract ( 2 * n . add ( 2 ) ) ; }
static int nthTerm ( int n ) { return 3 * Math . pow ( n , 2 ) + n - 2 ; }
public static int x = Integer . parseInt ( input ) { int y = Integer . parseInt ( input ) ; int c = Math . abs ( x ) + Math . abs ( y ) ; if ( x > 0 && y > 0 ) { System . out . println ( 0 + c + " ▁ " + c + " ▁ " + 0 ) ; } if ( x < 0 && y > 0 ) { System . out . println ( - c + " ▁ " + 0 + " ▁ " + c ) ; } if ( x > 0 && y < 0 ) { System . out . println ( 0 + " ▁ " + - c + " ▁ " + c + " ▁ " + 0 ) ; } if ( x < 0 && y < 0 ) { System . out . println ( - c + " ▁ " + 0 + " ▁ " + - c ) ; } return c ; }
public static void input ( ) { s = input . nextLine ( ) ; K = Integer . parseInt ( input . nextLine ( ) ) ; l = s . length ( ) ; List < String > substr = new ArrayList < String > ( ) ; for ( int i = 0 ; i < l ; i ++ ) { for ( int k = 0 ; k < K ; k ++ ) { substr . add ( s . substring ( i , i + k + 1 ) ) ; if ( i + k + 1 >= l ) break ; } } substr = Collections . unmodifiableList ( substr ) ; Collections . sort ( substr ) ; System . out . println ( substr . get ( K - 1 ) ) ; }
public static int [ ] [ ] getSolution ( ) { int [ ] [ ] memo = new int [ 2 ] [ 2 ] ; memo [ 0 ] = 0 ; memo [ 1 ] = 1 ; int [ ] [ ] fib = new int [ 2 ] [ 2 ] ; if ( N < memo . length ) return memo [ N ] ; for ( int i = memo . length ; i <= N ; i ++ ) { memo [ i ] = memo [ i - 1 ] + memo [ i - 2 ] ; } return memo ; }
static final Scanner IO = new Scanner ( System . in ) { int t = Integer . parseInt ( input . nextLine ( ) ) ; @ Override public void GO_LIFE ( ) { List < String > a = new LinkedList < > ( ) ; List < Integer > b = new LinkedList < > ( ) ; for ( int i = 0 ; i < b . size ( ) ; i ++ ) { if ( b . get ( i ) . equals ( 0 ) ) { ok = 1 ; } } if ( b . size ( ) != 0 || ok == 1 ) { for ( int i : new ArrayList < > ( ) ) { System . out . print ( i + " , ▁ " ) ; } System . out . println ( ) ; return ; } Collections . sort ( a ) ; int [ ] q1 = new int [ n ] ; int [ ] q2 = new int [ n ] ; int [ ] q = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a . get ( i ) . equals ( " c " ) ) { q [ i ] = i ; } if ( a . get ( i ) . equals ( " b " ) ) { q1 [ 0 ] = i ; } } int i = 0 , j = 0 ; while ( j < q1 . length && i < q . length ) { a . set ( q [ i ] , q1 [ j ] ) ; i ++ ; j ++ ; } for ( int i : a ) { System . out . print ( i + " , ▁ " ) ; } System . out . println ( ) ; } }
PI = 3.142 ; public static double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 ; double fact = 1 ; double pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) ; } return res ; }
static int findNumber ( int N , int S ) { int i = ( ( ( N ) * ( N + 1 ) ) / 4 ) - ( ( S + 1 ) / 2 ) ; return i ; }
public static boolean multipleOfThree ( int K , int dig0 , int dig1 ) { int sum = 0 ; int temp = ( dig0 + dig1 ) % 10 ; sum = dig0 + dig1 ; if ( ( K == 2 ) && ( sum % 3 == 0 ) ) { if ( ( sum % 3 == 0 ) && ( sum % 4 == 0 ) ) { return true ; } else { return false ; } } sum += temp ; int numberofGroups = ( K - 3 ) / 4 ; int remNumberofDigits = ( K - 3 ) % 4 ; sum += ( numberofGroups * 20 ) ; for ( int i = 0 ; i < remNumberofDigits ; i ++ ) { temp = ( 2 * temp ) % 10 ; sum += temp ; } if ( ( sum % 3 == 0 ) && ( sum % 4 == 0 ) ) { return true ; } else { return false ; } if ( getClass ( ) . equals ( " java . lang . Integer " ) ) { K = 5 ; dig0 = 3 ; dig1 = 4 ; if ( ( multipleOfThree ( K , dig0 , dig1 ) ) && ( sum % 3 == 0 ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } return false ; }
public static void print ( String s ) { n = Integer . parseInt ( s ) ; a = Arrays . stream ( n . split ( " ▁ " ) ) . map ( x -> Integer . parseInt ( x ) ) ; int total = sum ( a ) ; b . sort ( ) ; System . out . println ( total <= b . length - 1 + b . length - 2 ? " YES " : " NO " ) ; }
static int countOcc ( String s ) { int cnt = 0 ; for ( int i = 0 ; i <= s . length ( ) - 3 ; i ++ ) { int c = 0 , l = 0 , a = 0 , p = 0 ; for ( int j = i ; j < i + 4 ; j ++ ) { switch ( s . charAt ( j ) ) { case ' c ' : c ++ ; break ; case ' l ' : l ++ ; break ; case ' a ' : a ++ ; break ; case ' p ' : p ++ ; break ; } } if ( c == 1 && l == 1 && a == 1 && p == 1 ) { cnt ++ ; } } if ( getClass ( ) . getName ( ) . equals ( s ) ) { s = " clapc " ; System . out . println ( countOcc ( s . toLowerCase ( ) ) ) ; } return cnt ; }
static final int countSteps ( int x , int y ) { if ( ( x % y ) == 0 ) { return Math . floor ( x / y ) ; } return Math . floor ( ( x / y ) + countSteps ( y , x % y ) ) ; }
static final boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
static double PI = 3.14159265 ; double areaInscribed = ( P , B , H ) { return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) ; }
public static void print ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == 0 ) break ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( ; n > 0 ; n -- ) { String k = input . nextLine ( ) . trim ( ) ; String v = input . nextLine ( ) . trim ( ) ; map . put ( k , v ) ; } for ( ; n > 0 ; n -- ) { String e = input . nextLine ( ) . trim ( ) ; System . out . print ( map . containsKey ( e ) ? map . get ( e ) : e ) ; } System . out . println ( ) ; }
@ VisibleForTesting static int getCount ( int [ ] v , int n ) { Arrays . sort ( v ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int tmp = n - 1 - upperBound ( v , v [ i ] - 1 ) ; if ( tmp == v [ i ] ) ++ cnt ; } return cnt ; }
public static int trailingZeros ( int N ) { int countOfTwo = 0 ; int countOfFive = 0 ; for ( int i = 1 ; i <= N ; i += 1 ) { int val = i ; while ( ( val % 2 == 0 ) && ( val > 0 ) ) { val /= 2 ; countOfTwo += i ; } while ( ( val % 5 == 0 ) && ( val > 0 ) ) { val /= 5 ; countOfFive += i ; } } int ans = Math . min ( countOfTwo , countOfFive ) ; return ans ; }
static public int removeZero ( int n ) { int res = 0 ; int d = 1 ; while ( ( n > 0 ) && ( n < 10 ) ) { if ( ( n % 10 != 0 ) && ( n < 10 ) ) { res += ( n % 10 ) * d ; d *= 10 ; } n /= 10 ; } return res ; /* ▁ If ▁ the ▁ number ▁ is ▁ zero , ▁ return ▁ true ▁ */ int a = 105 ; int b = 106 ; if ( ( a == b ) && ( a == a ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return a ; }
@ VisibleForTesting static long m = 1000000007 ; Scanner fI = new Scanner ( System . in ) ; int N = Integer . parseInt ( fI . nextLine ( ) ) ; String [ ] nType = new String [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { String t = fI . nextLine ( ) ; nType [ i ] = " " ; } List < Integer > [ ] adj = new ArrayList [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { adj [ i ] = new ArrayList < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) adj [ j ] . add ( i ) ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { int s = Integer . parseInt ( fI . nextLine ( ) ) ; int t = Integer . parseInt ( fI . nextLine ( ) ) ; s -- ; t -- ; adj [ s ] . add ( t ) ; } @ SuppressWarnings ( " unused " ) private static long prod ( List < Integer > nums ) { long p = 1 ; for ( int n : nums ) p *= n ; return p ; } final int [ ] [ ] cS = new int [ 4000 ] [ 4000 ] ; System . arraycopy ( cS , 0 , cS , 0 , 4000 ) ; return cS [ 0 ] [ 4000 ] ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; List < Integer > l = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { l . add ( Integer . parseInt ( input ) ) ; } if ( n == 1 ) { System . out . println ( l . get ( 0 ) ) ; } else { int x = Math . abs ( l . get ( 0 ) - l . get ( 1 ) ) ; int m1 = Math . min ( l . get ( 0 ) , x ) ; int m2 = Math . max ( l . get ( 1 ) , x ) ; System . out . println ( ( m1 + m2 ) / 2 ) ; } }
public static int [ ] input ( ) { int [ ] x = new int [ input . length ] ; for ( int i = 0 ; i < x . length ; i ++ ) { x [ i ] = Integer . parseInt ( input . readLine ( ) ) ; } int a = x [ 0 ] ; int b = x [ 1 ] ; System . out . print ( min ( x ) + " ▁ " ) ; if ( Math . abs ( a - b ) >= 2 ) { System . out . println ( Math . abs ( a - b ) / 2 ) ; } else { System . out . println ( 0 ) ; } return x ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; int q = n / m ; int r = n % m ; int [ ] a = new int [ q ] ; for ( int i = 0 ; i < r ; i ++ ) { a [ i ] ++ ; } for ( int i = 0 ; i < m ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; } }
static int countSetBits ( int n ) { int count = 0 ; while ( ( n = n & 1 ) != 0 ) { count += n & 1 ; n >>>= 1 ; } return count ; /* ▁ total ▁ pairs ▁ */ int [ ] arr1 = new int [ 7 ] ; int [ ] arr2 = new int [ 7 ] ; for ( int i = 0 ; i < s1 . length ; i ++ ) { int set_bits = countSetBits ( ( char ) s1 [ i ] ) ; arr1 [ set_bits ] ++ ; } for ( int i = 0 ; i < s2 . length ; i ++ ) { int set_bits = countSetBits ( ( char ) s2 [ i ] ) ; arr2 [ set_bits ] ++ ; } for ( int i = 1 ; i < 7 ; i ++ ) { count += ( arr1 [ i ] * arr2 [ i ] ) ; } /* ▁ if ▁ ( Class . getName ( ) . equals ( String . class ) ) ▁ { STRNEWLINE ▁ String ▁ s1 ▁ = ▁ " geeks " ; STRNEWLINE ▁ String ▁ s2 ▁ = ▁ " forgeeks " ; STRNEWLINE ▁ System . out . println ( totalPairs ( s1 , ▁ s2 ) ) ; STRNEWLINE ▁ } */ }
static int countSubSeq ( int i , int Sum , int cnt , int [ ] a , int n ) { if ( ( i == n ) && ( Sum == 0 ) && ( cnt > 0 ) ) { return 1 ; } else { return 0 ; } int ans = 0 ; ans += countSubSeq ( i + 1 , Sum , cnt , a , n ) ; ans += countSubSeq ( i + 1 , Sum + a [ i ] , cnt + 1 , a , n ) ; return ans ; }
public static String print ( String input ) { int n = Integer . parseInt ( input ) ; String in = input ; int index ; if ( n % 2 == 0 ) { index = Integer . parseInt ( n / 2 ) - 1 ; } else { index = Integer . parseInt ( n / 2 ) ; } /* ▁ Method ▁ of ▁ the ▁ input ▁ string ▁ */ int j = 0 ; List < Integer > inList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { inList . add ( i ) ; } String [ ] out = new String [ n ] ; while ( ( inList . size ( ) > 0 ) && ( j < n ) ) { if ( ( index - j >= 0 ) ) { out [ index ] = inList . get ( 0 ) ; inList . remove ( 0 ) ; } else { if ( ( index + j < n ) ) { out [ index + j ] = inList . get ( 0 ) ; inList . remove ( 0 ) ; } if ( ( index - j >= 0 ) ) { out [ index - j ] = inList . get ( 0 ) ; inList . remove ( 0 ) ; } } } return out [ index ] ; }
public static int a ( int n , int m ) { int count = 0 ; List < Integer > checkList = new ArrayList < Integer > ( ) ; int i = 0 ; if ( a == 0 ) i = 1 ; while ( ( i + a ) * n < m ) { checkList . add ( ( i + a ) * n ) ; i ++ ; } for ( Integer x : checkList ) { } return count ; }
static int pivotedBinarySearch ( int [ ] arr , int n , int key ) { int pivot = findPivot ( arr , 0 , n - 1 ) ; if ( pivot == - 1 ) return binarySearch ( arr , 0 , n - 1 , key ) ; if ( arr [ pivot ] == key ) return pivot ; if ( arr [ 0 ] <= key ) return binarySearch ( arr , 0 , pivot - 1 , key ) ; return binarySearch ( arr , pivot + 1 , n - 1 , key ) ; }
static void print ( int n ) { int n = input . nextInt ( ) + 1 ; long d = 1000000007 ; long [ ] [ ] g = new long [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) g [ i ] [ 0 ] = g [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) g [ i ] [ j ] = ( g [ i ] [ j - 1 ] + g [ i - 1 ] [ j - 1 ] ) % d ; }
@ System . out . sys . stdin . public static String print ( String input ) { @ SuppressWarnings ( " resource " ) List < String > answer = new ArrayList < > ( ) ; int n = Integer . parseInt ( input ) ; List < Integer > a = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a . add ( i ) ; } List < Integer > b = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { b . add ( i ) ; } Map < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map . put ( a . get ( i ) , i ) ; } visited = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { visited [ i ] = true ; } return answer . toString ( ) ; }
@ DataProvider ( name = " vector " ) public static Object [ ] [ ] vector = new Object [ ] [ ] { { 0 , - 1 } , { 1 , 0 } , { 0 , 1 } , { - 1 , 0 } } ; /* ▁ make ▁ gurugu ▁ for ▁ the ▁ number ▁ of ▁ elements ▁ */ Object [ ] [ ] lst = new Object [ d + 4 ] [ d + 2 ] ; for ( int i = 0 ; i < d + 2 ; i ++ ) { lst [ i ] = new Object [ d + 2 ] ; lst [ i ] [ 0 ] = " # " ; } int x = 2 , y = d + 1 ; lst [ y ] [ x ] = " # " ; int direct = 0 ; int vx = vector [ 0 ] ; int vy = vector [ 1 ] ; int cnt = 1 ; do { while ( lst [ y + vy * 2 ] [ x + vx * 2 ] == " ▁ " ) { lst [ y + vy ] [ x + vx ] = " # " ; y += vy ; x += vx ; cnt ++ ; } while ( cnt <= 1 ) ; direct = ( direct + 1 ) % 4 ; vx = vector [ direct ] ; vy = vector [ direct ] ; cnt = 0 ; } while ( true ) ; for ( int y = 2 ; y < d + 2 ; y ++ ) System . out . println ( Arrays . toString ( lst [ y ] ) . substring ( 2 , lst [ y ] . length ( ) - 2 ) ) ; int n = Integer . parseInt ( input . nextLine ( ) ) ; /* ▁ make ▁ gurugu ▁ for ▁ the ▁ number ▁ of ▁ elements ▁ */ for ( int i = 0 ; i < n - 1 ; i ++ ) { System . out . println ( ) ; /* ▁ make ▁ gurugu ▁ for ▁ the ▁ number ▁ of ▁ elements ▁ */ lst [ i ] [ 0 ] = lst [ y ] [ i + 1 ] ; lst [ i ] [ 1 ] = lst [ y ] [ i + 2 ] ; } return lst ; }
static final String compute ( ) { final long ans = Long . valueOf ( 1 << 10 ) . longValue ( ) ; for ( int i = 1 ; i < 1 << 10 ; i ++ ) { for ( int j = i ; j < 1 << 10 ; j ++ ) { if ( eulerUtil . popCount ( i ) == eulerUtil . popCount ( j ) == 6 && isArrangementValid ( i , j ) ) { return Long . toString ( ans ) ; } } } return String . valueOf ( ans ) ; /* ▁ if ▁ ( testBit ( a , 6 ) ▁ | | ▁ testBit ( a , 9 ) ) ▁ { STRNEWLINE ▁ a ▁ |= ▁ ( 1 << 6 ) . intValue ( ) ; STRNEWLINE ▁ } */ if ( testBit ( b , 6 ) || testBit ( b , 9 ) ) { b |= ( 1 << 6 ) . intValue ( ) ; } /* ▁ if ▁ ( testBit ( a , c ) ▁ | | ▁ testBit ( b , d ) ) ▁ { STRNEWLINE ▁ c ▁ |= ▁ ( a ▁ & ▁ b ) . intValue ( ) ; STRNEWLINE ▁ d ▁ |= ▁ ( a ▁ & ▁ b ) . intValue ( ) ; STRNEWLINE ▁ } */ /* ▁ test ▁ bit ▁ ( x , ▁ i ) ▁ { STRNEWLINE ▁ return ▁ ( ( x ▁ > > ▁ i ) ▁ & ▁ 1 ) ▁ ! = ▁ 0 ; STRNEWLINE ▁ } */ }
public static void main ( Scanner input ) { int n = input . nextInt ( ) ; int [ ] [ ] a = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] info = input . nextInt ( ) . split ( " ▁ " ) ; for ( int j = 2 ; j < info . length ; j ++ ) { a [ i ] [ j - 1 ] = 1 ; } } for ( int v : a ) { System . out . println ( ( ( Integer ) v ) . intValue ( ) ) ; } }
private static void input ( Scanner in ) { int n = in . nextInt ( ) , m = in . nextInt ( ) ; int [ ] [ ] a = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] x = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { x [ j ] = in . nextInt ( ) ; } a [ i ] = x ; } int count = 0 ; for ( int j = 0 ; j < m - 1 ; j ++ ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { Set set = new HashSet ( ) ; set . add ( a [ i ] [ j ] ) ; set . add ( a [ i + 1 ] [ j ] ) ; set . add ( a [ i ] [ j + 1 ] ) ; set . add ( a [ i + 1 ] [ j + 1 ] ) ; if ( set . equals ( { set . add ( ' a ' ) , set . add ( ' f ' ) , set . add ( ' c ' ) , set . add ( ' e ' ) } ) ) { count ++ ; } } } System . out . println ( count ) ; }
@ typing . Optional public static < String > getAlternatingCurrent ( List < String > wires ) { final int INF = ( int ) ( 1e9 + 7 ) ; System . setSecurityManager ( new SecurityManager ( ) { @ Override public void checkPermission ( Permission perm ) { } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } } ) ; return new String ( ) { @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } @ Override public String getPermission ( ) { return " Permission " ; } } ; }
@ VisibleForTesting static final Scanner getScanner ( ) { final Scanner scanner = new Scanner ( System . in ) ; final int N = scanner . nextInt ( ) ; final int M = scanner . nextInt ( ) ; final int E = scanner . nextInt ( ) ; final BipartiteMatching bm = new BipartiteMatching ( N , M ) ; for ( int i = 0 ; i < E ; i ++ ) { final int x = scanner . nextInt ( ) ; final int y = scanner . nextInt ( ) ; bm . add ( x , y ) ; } System . out . println ( bm . solve ( ) ) ; return scanner ; }
MAX = 100 ; int [ ] [ ] a = { 1 , 2 , 3 } ; int n = 3 ; System . out . println ( countMountains ( a , n ) ) ; int count = 0 ; for ( int i = 0 ; i < n + 2 ; i ++ ) { for ( int j = 0 ; j < n + 2 ; j ++ ) { if ( ( ( i == 0 ) || ( j == 0 ) ) || ( ( i == n + 1 ) || ( j == n + 1 ) ) ) { A [ i ] [ j ] = Double . NEGATIVE_INFINITY ; } else { A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] ; } } } for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) ) ) { count = count + 1 ; } } } a = new int [ ] [ ] { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; n = 3 ; System . out . println ( countMountains ( a , n ) ) ; }
@ VisibleForTesting static void main ( String [ ] args ) { int N = 100005 ; int [ ] d = new int [ N ] ; int [ ] pre = new int [ N ] ; new Thread ( ) { @ Override public void run ( ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; ( j <= ( int ) Math . sqrt ( i ) ) ; j ++ ) { if ( ( i % j ) == 0 ) { if ( ( j * j ) == i ) { d [ i ] ++ ; } else { d [ i ] += 2 ; } } } } int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( ( d [ i ] == d [ i - 1 ] ) && ( d [ i ] == d [ i ] ) ) { ans ++ ; } pre [ i ] = ans ; } } } . start ( ) ; if ( Class . forName ( " org . apache . commons . math . MathHelper " ) . equals ( " org . apache . commons . math . MathHelper " ) ) { new Thread ( ) { @ Override public void run ( ) { int n = 15 ; System . out . println ( pre [ n ] ) ; } } . start ( ) ; } }
static void defragment ( String input ) { int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; String [ ] s = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) s [ i ] = input . split ( " ▁ " ) ; int [ ] a = new int [ m ] ; int num = 1 ; { int x ; int i ; int x ; int j ; for ( i = 0 ; i < m - x + 1 ; i ++ ) { x = Integer . parseInt ( input . substring ( i , i + 1 ) ) ; for ( j = 0 ; j < m - x + 1 ; j ++ ) { if ( a [ i ] = new int [ i + x ] ) { a [ i ] = num ++ ; System . out . println ( num ++ ) ; return ; } } } System . out . println ( " NULL " ) ; } { int x ; int i ; int x ; if ( x < 1 || x < 1 ) { System . out . println ( " ILLEGAL _ ERASE _ ARGUMENT " ) ; } for ( i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] == x ) a [ i ] = 0 ; } } { int x ; a = Arrays . copyOf ( a , a . length ) ; a [ a . length - 1 ] = 0 ; } { StringBuilder sb = new StringBuilder ( ) ; for ( i = 0 ; i < m ; i ++ ) sb . append ( " ▁ " ) ; sb . append ( s [ i ] ) ; } { StringBuilder sb = new StringBuilder ( ) ; for ( i = 0 ; i < m ; i ++ ) sb . append ( " ▁ " ) ; sb . append ( s [ i ] ) ; } { StringBuilder sb = new StringBuilder ( ) ; for ( i = 0 ; i < m ; i ++ ) sb . append ( " ▁ " ) ; sb . append ( s [ i ] ) ; } }
static double areaOfRegularPolygon ( int n , int len ) { final double P = ( len * n ) ; final double A = len / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; final double area = ( P * A ) / 2 ; return area ; }
public static String lastNonRepeating ( String string , int n ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ ( string . charAt ( i ) & 0xFF ) ] ++ ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = string . charAt ( i ) ; if ( ( freq [ ( int ) ch ] == 1 ) && ( ( ch > 0 ) && ( ch < freq [ ( int ) ch ] ) ) ) { return ( " " + ch ) ; } } return " - 1" ; }
public static int [ ] [ ] a ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] [ ] a = new int [ n ] [ 2 ] ; int minx = 1000000000 ; int maxy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = Integer . parseInt ( input . nextLine ( ) ) ; int y = Integer . parseInt ( input . nextLine ( ) ) ; minx = Math . min ( minx , x ) ; maxy = Math . max ( maxy , y ) ; a [ i ] = new int [ ] { x , y } ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] [ 0 ] == minx && a [ i ] [ 1 ] == maxy ) { System . out . println ( i + 1 ) ; break ; } } else { System . out . println ( - 1 ) ; } return a ; }
public static double y ( double x ) { return ( 1 / ( 1 + x ) ) ; /* BooleRule ▁ = ▁ new ▁ BooleRule ( ) ; STRNEWLINE ▁ int ▁ a ▁ = ▁ ( int ) ▁ ( x ▁ - ▁ 1 ) ; STRNEWLINE ▁ int ▁ b ▁ = ▁ ( int ) ▁ ( x ▁ - ▁ 1 ) ; STRNEWLINE ▁ int ▁ h ▁ = ▁ ( ( b ▁ - ▁ a ) ▁ / ▁ n ) ; STRNEWLINE ▁ double ▁ sum ▁ = ▁ 0 ; STRNEWLINE ▁ double ▁ bl ▁ = ▁ ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ; STRNEWLINE ▁ sum ▁ + = ▁ bl ; STRNEWLINE ▁ */ if ( getClass ( ) . equals ( int . class ) ) { lowlimit = 0 ; upplimit = 4 ; System . out . println ( " f ( x ) ▁ = " + Math . round ( BooleRule ( 0 , 4 ) ) ) ; } return sum ; }
static final int [ ] [ ] getLen ( int n , int m ) { int maxN = 20 ; int maxM = 256 ; int [ ] [ ] dp = new int [ maxN ] [ maxM ] ; int [ ] [ ] v = new int [ maxN ] [ maxM ] ; int i ; int l ; int r ; int ans ; /* ▁ find ▁ len ▁ */ if ( ( i = arr . length ) == n ) { if ( ( curr = arr [ i ] ) == m ) { return 0 ; } else { return - 1 ; } } if ( ( v [ i ] [ curr ] = 1 ) != 0 ) { return dp [ i ] [ curr ] ; } v [ i ] [ curr ] = 1 ; l = findLen ( arr , i + 1 , curr , n , m ) ; r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( ( r != - 1 ) && ( dp [ i ] [ curr ] = r + 1 ) != 0 ) { dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; } return dp [ i ] [ curr ] ; }
static final int [ ] [ ] findLen ( int [ ] arr , int i , int curr , int n , int m ) { int maxN = 20 ; int maxM = 64 ; int [ ] [ ] dp = new int [ maxN ] [ maxM ] ; int [ ] [ ] v = new int [ maxN ] [ maxM ] ; /* ▁ find ▁ len ▁ */ if ( ( i == n ) && ( curr == m ) ) { if ( ( i == m ) && ( v [ i ] [ curr ] != 0 ) ) { return 0 ; } else { return - 1 ; } } if ( ( v [ i ] [ curr ] != 0 ) && ( dp [ i ] [ curr ] != 0 ) ) { return dp [ i ] [ curr ] ; } v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( ( r != - 1 ) && ( dp [ i ] [ curr ] != 0 ) ) { dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; } return dp [ i ] [ curr ] ; }
public static void print ( ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; if ( N == 0 ) break ; int [ ] [ ] R = new int [ N + 1 ] [ N + 1 ] ; /* ▁ dfs2 ▁ max ▁ */ int max = - R [ N ] [ pre ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) { max = max = max = max ( max , dfs2 ( i , cur ) + R [ N ] [ i ] ) ; } int total = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; int t = Integer . parseInt ( input . nextLine ( ) ) ; R [ a ] [ b ] = t ; R [ b ] [ a ] = t ; total += ( t * 2 ) ; } for ( int i = 2 ; i <= N ; i ++ ) { int [ ] spam = Arrays . stream ( R [ i ] ) . filter ( x -> x > 0 ) . toArray ( ) ; if ( ( spam . length <= 1 ) && ( spam [ 0 ] == 1 ) ) { total -= ( spam [ 0 ] * 2 ) ; } } System . out . println ( ( total - dfs2 ( 1 , 0 ) ) ) ; }
public static int N = Integer . parseInt ( input ) { if ( Integer . parseInt ( input ) > N ) { return 0 ; } int ans = new HashSet < String > ( ) { { add ( "1" ) ; } } ; return ans ; }
static int minDiff ( int [ ] arr , int n , int k ) { int result = + 2147483647 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { result = ( int ) Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; } return result ; }
static final int [ ] [ ] loadBalances ( ) { System . setSecurityManager ( new SecurityManager ( ) { public void checkListen ( int i , String line ) { System . setOut ( new PrintStream ( System . out ) ) ; } } ) ; int [ ] [ ] loadBalances = new int [ 1 ] [ ] ; int LINE_NUM = 0 , TOTAL = 0 ; int [ ] [ ] balls = new int [ TOTAL_COUNT ] [ ] ; int i = 0 ; while ( ( line = System . in . readLine ( ) ) != null ) { line = line . trim ( ) ; LINE_NUM ++ ; if ( LINE_NUM == 1 ) { TOTAL = Integer . parseInt ( line . trim ( ) ) ; continue ; } balls [ i ++ ] = Integer . parseInt ( line ) ; if ( LINE_NUM == TOTAL + 1 ) break ; } class VesselClass { public void fill ( ) { tmp = new int [ 1 ] ; left = new int [ 1 ] ; right = new int [ 1 ] ; } public void fill ( @ Nonnull int balls [ ] ) { tmp = balls ; } public void DFS ( ) { if ( tmp . length == 0 ) System . out . println ( " YES " ) ; else if ( left [ left . length - 1 ] < tmp [ 0 ] ) { left [ tmp . length - 1 ] = tmp [ 0 ] ; tmp . pop ( 0 ) ; DFS ( ) ; } else if ( right [ right . length - 1 ] < tmp [ 0 ] ) { right [ tmp . length - 1 ] = tmp [ 0 ] ; tmp . pop ( 0 ) ; DFS ( ) ; } else System . out . println ( " NO " ) ; } } int [ ] [ ] balls_list = loadBalances ( ) ; for ( int [ ] balls : balls_list ) { Vessel Vessel = new VesselClass ( ) ; Vessel . fill ( balls ) ; Vessel . DFS ( ) ; } return balls ; }
public static int t = Integer . parseInt ( input ) { int y = 0 ; int j = 1 ; while ( y < x ) { y += j ; if ( y == x ) { return ( j ) ; } j ++ ; } if ( y - x == 1 ) { return ( j ) ; } else { return ( j - 1 ) ; } }
public static double Mean ( int [ ] arr , int n ) { double sm = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sm = sm + arr [ i ] ; } return sm / n ; /* ▁ mean ▁ absolute ▁ deviation ▁ */ }
static final String compute ( ) { final int LIMIT = 10 * 9 ; final List < Integer > primes = EulerLibrary . listPrimes ( 100 ) ; return String . valueOf ( count ( 0 , 1 ) ) ; /* if ▁ ( primeIndex ▁ = = ▁ primes . size ( ) ) ▁ { STRNEWLINE ▁ return ▁ product ▁ <= ▁ LIMIT ▁ ? ▁ 1 ▁ : ▁ 0 ; STRNEWLINE ▁ } */ }
static int maximumXOR ( int n , int l , int r ) { final int x = 0 ; for ( int i = ( int ) Math . log2 ( r ) ; i >= 0 ; i -- ) { if ( ( n & ( 1 << i ) ) != 0 ) { if ( ( x > r ) || ( x + ( 1 << i ) - 1 < l ) ) x ^= ( 1 << i ) ; } } return n ^ x ; }
static int maxPrimefactorNum ( int N ) { boolean arr [ ] = new boolean [ N + 5 ] ; int i = 3 ; while ( ( i * i <= N ) && ( arr [ i ] ) ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = false ; } } i += 2 ; int prime [ ] = new int [ N + 1 ] ; prime [ 0 ] = 2 ; for ( int j = 3 ; j <= N ; j += 2 ) { if ( arr [ j ] ) prime [ j ] = i ; } i = 0 ; int ans = 1 ; while ( ( ans * prime [ i ] <= N ) && i < prime . length ) { ans *= prime [ i ] ; i ++ ; } return ans ; }
private static int countTrailingZeros ( int n ) { String bit = Integer . toBinaryString ( n ) ; bit = bit . substring ( 0 , bit . length ( ) - 1 ) ; int zero = 0 ; for ( int i = 0 ; i < bit . length ( ) ; i ++ ) { if ( ( bit . charAt ( i ) == '0' ) ) { zero ++ ; } else { break ; } } return zero ; }
public static int a , int b , int c ; int case1 = Integer . parseInt ( input . nextLine ( ) ) ; int case2 = a + b + c ; int case3 = a + c + c + a ; int case4 = b + c + c + b ; System . out . println ( min ( case1 , case2 , case3 , case4 ) ) ; }
public static void main ( String input ) { for ( int t = 0 ; t < Integer . parseInt ( input ) ; t ++ ) { int n = Integer . parseInt ( input ) ; int [ ] p = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) p [ i ] = Integer . parseInt ( input ) ; int result = 0 ; int c = 0 ; while ( c < n - 1 ) { if ( p [ c ] > p [ c + 1 ] ) { result ++ ; c ++ ; } c ++ ; } System . out . println ( result ) ; } }
static int distinctSubstring ( String P , String Q , int K , int N ) { Set < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; i <= N ; i ++ ) { int sum = 0 ; StringBuffer sb = new StringBuffer ( ) ; for ( int j = i ; j <= N ; j ++ ) { int pos = ( int ) P . charAt ( j ) - 97 ; sum = sum + ( int ) Q . charAt ( pos ) - 48 ; sb . append ( P . charAt ( j ) ) ; } } return S . size ( ) ; }
public static String makeEven ( String [ ] arr , int n ) { final String result ; int firstEI = - 1 ; int lastEI = - 1 ; int lastNI = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( Integer . parseInt ( arr [ i ] ) % 2 ) == 0 && ( Integer . parseInt ( arr [ i ] ) < Integer . parseInt ( arr [ lastNI ] ) ) ) { firstEI = i ; break ; } if ( Integer . parseInt ( arr [ i ] ) % 2 == 0 ) { lastEI = i ; } } if ( firstEI != - 1 ) { ( arr [ firstEI ] = arr [ lastNI ] ) . compareTo ( arr [ firstEI ] ) ; return arr [ firstEI ] ; } if ( firstEI == - 1 && lastEI != - 1 ) { ( arr [ lastEI ] = arr [ lastNI ] ) . compareTo ( arr [ lastEI ] ) ; return arr [ lastEI ] ; } return arr [ 0 ] ; }
static void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) div [ i ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j * i <= n ) div [ i * j ] ++ ; } } for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( div [ i ] + " ▁ " ) ; } if ( getClass ( ) . isAnonymousClass ( ) ) { n = 10 ; findDivisors ( n ) ; } }
public static void input ( ) { String a = input ( ) ; String b = input ( ) ; int [ ] numOf0 = new int [ b . length ( ) + 1 ] ; int [ ] numOf1 = new int [ b . length ( ) + 1 ] ; int r = 0 ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) { numOf0 [ i ] = numOf0 [ i - 1 ] + ( b . charAt ( i ) == '0' ) ; numOf1 [ i ] = numOf1 [ i - 1 ] + ( b . charAt ( i ) == '1' ) ; } for ( int i = 0 ; i < a . length ( ) ; i ++ ) { r += ( a . charAt ( i ) == '0' ) ? ( numOf1 [ b . length ( ) - a . length ( ) + i ] - numOf1 [ i - 1 ] ) : ( numOf0 [ b . length ( ) - a . length ( ) + i ] - numOf0 [ i - 1 ] ) ; } System . out . println ( r ) ; }
public static void printDistinct ( String Str ) { int n = Str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = Character . getNumericValue ( Str . charAt ( i ) ) ; count [ x ] ++ ; if ( ( count [ x ] == 1 ) && ( x != ' ▁ ' ) ) index [ x ] = i ; if ( ( count [ x ] == 2 ) ) index [ x ] = n ; } Arrays . sort ( index ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( index [ i ] == n ) break ; System . out . print ( Str . charAt ( index [ i ] ) ) ; } }
static int calculate ( int x , int k , int m ) { double result = x ; k = k - 1 ; while ( ( k > 0 ) && ( result < m ) ) { result = Math . pow ( result , x ) ; } return ( int ) result ; }
public static void converthenumber ( int n ) { String s = Integer . toString ( n ) ; String res = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s . charAt ( i ) == '1' ) || ( s . charAt ( i ) == '3' ) || ( s . charAt ( i ) == '5' ) || ( s . charAt ( i ) == '7' ) || ( s . charAt ( i ) == '9' ) ) { res += s . charAt ( i ) ; } if ( ( res . length ( ) == 2 ) ) { break ; } } if ( ( res . length ( ) == 2 ) ) { System . out . println ( res ) ; } else { System . out . println ( " - 1" ) ; } }
private static void solve ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; String s = input . nextLine ( ) ; for ( int a = 0 ; a < 26 ; a ++ ) { char c = ( char ) ( a + ' a ' ) ; if ( ! s . contains ( c ) ) { System . out . println ( c ) ; return ; } } for ( int a = 0 ; a < 26 ; a ++ ) { char c1 = ( char ) ( a + ' a ' ) ; for ( int b = 0 ; b < 26 ; b ++ ) { char c2 = ( char ) ( b + ' a ' ) ; char c = c1 + c2 ; if ( ! s . contains ( c ) ) { System . out . println ( c ) ; return ; } } } for ( int a = 0 ; a < 26 ; a ++ ) { char c1 = ( char ) ( a + ' a ' ) ; for ( int b = 0 ; b < 26 ; b ++ ) { char c2 = ( char ) ( b + ' a ' ) ; char c4 = c1 + c2 ; for ( int d = 0 ; d < 26 ; d ++ ) { char c3 = ( char ) ( d + ' a ' ) ; char c = c4 + c3 ; if ( ! s . contains ( c ) ) { System . out . println ( c ) ; return ; } } } } int t = Integer . parseInt ( input . nextLine ( ) ) ; while ( t != 0 ) { t -- ; solve ( ) ; } }
public static void main ( String input ) { for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { n = Integer . parseInt ( input ) ; l = Lists . newArrayList ( Integer . parseInt ( input ) ) ; a = new HashSet < > ( l ) ; for ( int j = 0 ; j < n ; j ++ ) a . add ( Integer . parseInt ( input ) ) ; } List < Integer > l1 = new ArrayList < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) l1 . add ( Math . max ( i , a . size ( ) ) ) ; System . out . println ( l1 ) ; }
static int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; }
public static void input ( ) { int h = Integer . parseInt ( input . readLine ( ) ) ; int w = Integer . parseInt ( input . readLine ( ) ) ; char [ ] s = new char [ h ] ; for ( int i = 0 ; i < h ; i ++ ) s [ i ] = Character . toString ( input . charAt ( i ) ) ; int ans = 0 ; int [ ] ci = new int [ w ] ; for ( int i = h - 1 ; i >= 0 ; i -- ) { int co = 0 ; for ( int j = w - 1 ; j >= 0 ; j -- ) { switch ( s [ i ] ) { case ' J ' : ans += co * ci [ j ] ; break ; case ' O ' : co ++ ; break ; case ' I ' : ci [ j ] ++ ; break ; } } } System . out . println ( ans ) ; }
static int countDivisors ( int n , int k ) { final int count = 0 ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( n ) ; i ++ ) { if ( ( n % i ) == 0 ) { if ( ( i % k ) == 0 ) { count ++ ; } if ( ( ( n / i ) % k ) == 0 ) { count ++ ; } } } if ( ( ( i * i == n ) && ( i % k ) == 0 ) ) { count -- ; } return count ; }
static int countDivisors ( int n , int k ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( n % i == 0 ) && ( i % k == 0 ) ) { count ++ ; } } if ( getClass ( ) . getName ( ) . equals ( " java . lang . Integer " ) ) { n = 12 ; k = 3 ; System . out . println ( countDivisors ( n , k ) ) ; } return count ; }
public static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( ( y > 0 ) != 0 ) { if ( ( y > 0 ) && ( ++ y > 1 ) ) { res = ( res * x ) % p ; } y = y > > 1 ; x = ( x * x ) % p ; } return res ; /* ▁ find ▁ modulo ▁ by ▁ M ▁ */ int X , N , M ; if ( ( N < 6 ) && ( M = ( M = ( M = ( N / 2 ) ) ) ) != 0 ) { char temp = ( char ) ( 48 + X ) * N ; res = Integer . parseInt ( temp ) % M ; return res ; } if ( ( N % 2 ) == 0 ) { int half = findModuloByM ( X , N / 2 , M ) % M ; res = ( half * power ( 10 , N / 2 , M ) + half ) % M ; return res ; } else { int half = findModuloByM ( X , N / 2 , M ) % M ; res = ( half * power ( 10 , N / 2 + 1 , M ) + half * 10 + X ) % M ; return res ; } }
public static void print ( int t = Integer . parseInt ( input ) ) { for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > p = Lists . newArrayList ( ) ; for ( int j = 0 ; j < n ; j ++ ) { p . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } int m = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > q = Lists . newArrayList ( ) ; for ( int j = 0 ; j < m ; j ++ ) { q . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } List < Integer > evenP = new ArrayList < Integer > ( ) ; for ( int j = 0 ; j < m ; j ++ ) { evenP . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } List < Integer > odP = new ArrayList < Integer > ( ) ; for ( int j = 0 ; j < m ; j ++ ) { odP . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } List < Integer > evenQ = new ArrayList < Integer > ( ) ; for ( int j = 0 ; j < m ; j ++ ) { evenQ . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } List < Integer > odQ = new ArrayList < Integer > ( ) ; for ( int j = 0 ; j < m ; j ++ ) { odQ . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } System . out . println ( evenQ . size ( ) * evenP . size ( ) + odQ . size ( ) * odP . size ( ) ) ; } }
static int findMaxDiff ( int [ ] a , int n ) { if ( ( n < 2 ) || ( n > 3 ) ) { System . out . println ( " Invalid ▁ " ) ; return 0 ; } int minVal = Integer . MAX_VALUE ; int maxVal = - Integer . MIN_VALUE - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( a [ i ] - i ) > maxVal ) && ( a [ i ] > minVal ) ) { maxVal = a [ i ] - i ; } if ( ( ( a [ i ] - i ) < minVal ) && ( a [ i ] < minVal ) ) { minVal = a [ i ] - i ; } } return ( maxVal - minVal ) ; }
public static void print ( int n ) { char h = ' # ' ; char [ ] [ ] f = new char [ n + 2 ] [ n + 1 ] ; char [ ] [ ] a = f . clone ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i + 1 ] [ j + 1 ] > h ) { for ( int k = 2 , l = 0 ; k < n ; k ++ , l ++ ) { if ( a [ i + k ] [ j + l ] == h ) System . out . println ( " NO " ) ; exit ( ) ; a [ i + k ] [ j + l ] = h ; } } } } System . out . println ( " YES " ) ; }
static int numberOfPaths ( int m , int n ) { int [ ] [ ] count = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { count [ i ] [ 0 ] = 1 ; } for ( int j = 0 ; j < n ; j ++ ) { count [ 0 ] [ j ] = 1 ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } } return count [ m - 1 ] [ n - 1 ] ; }
public static void print ( String input ) { int m = Integer . parseInt ( input ) ; for ( int i = 0 ; i < m ; i ++ ) { int n = Integer . parseInt ( input ) ; List < Integer > a = Lists . newArrayList ( ) ; for ( int j = 0 ; j < n ; j ++ ) { a . add ( Integer . parseInt ( input ) ) ; } int s = Integer . parseInt ( input ) ; if ( ( s % n ) == 0 ) { if ( ( s / n ) . contains ( a . get ( s / n ) ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { System . out . println ( " NO " ) ; } } }
static boolean isKthBitSet ( int n , int k ) { if ( ( ( n > > ( k - 1 ) ) & 1 ) != 0 ) return true ; return false ; /* ▁ set ▁ the ▁ bit ▁ to ▁ the ▁ k ▁ */ int n = ( ( 1 << ( k - 1 ) ) | n ) ; /* ▁ all ▁ bits ▁ are ▁ set ▁ */ if ( ( ( ( n + 1 ) & n ) == 0 ) && ( ( ( n + 1 ) & n ) == 0 ) ) return true ; /* ▁ bits ▁ are ▁ in ▁ alt ▁ order ▁ */ int num = n ^ ( n > > 1 ) ; /* ▁ bits ▁ are ▁ in ▁ alt ▁ patrnInGivenRange ▁ */ int leftShift ; if ( ( isKthBitSet ( n , r ) ) && ( ( isKthBitSet ( n , r ) ) ) ) num = n ; leftShift = r ; else { num = setKthBit ( n , ( r + 1 ) ) ; leftShift = r + 1 ; } num = num & ( ( 1 << leftShift ) - 1 ) ; num = num > > ( l - 1 ) ; /* ▁ bits ▁ are ▁ in ▁ alt ▁ patrnInGivenRange ▁ */ if ( className . equals ( " java . util . BitSet " ) ) { n = 18 ; l = 1 ; r = 3 ; if ( ( bitsAreInAltPatrnInGivenRange ( n , l , r ) ) && ( bitsAreInAltPatrnInGivenRange ( n , l , r ) ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } return false ; }
public static int factorial ( int n ) { if ( ( n <= 1 ) && ( n <= 2 ) ) return 1 ; return n * factorial ( n - 1 ) ; /* ▁ nCr ▁ */ }
static String commonPrefixUtil ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; String result = " " ; int j = 0 ; int i = 0 ; while ( ( i <= n1 - 1 ) && ( j <= n2 - 1 ) ) { if ( ( str1 . charAt ( i ) != str2 . charAt ( j ) ) ) { break ; } result += ( str1 . charAt ( i ) ) ; i ++ ; j ++ ; } return ( result ) ; /* ▁ System . out . println ( commonPrefixUtil ( arr , ▁ n ) ) ; ▁ */ if ( getClass ( ) . getName ( ) . equals ( " java . lang . String " ) ) { String arr [ ] = { " geeksforgeeks " , " geeks " , " geek " , " geezer " } ; int n = arr . length ; commonPrefix ( arr , n ) ; } return ( result ) ; }
@ VisibleForTesting static Statistics median ( ) { final int mod = 10 * 9 + 7 ; final int [ ] A = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } final int n = Integer . parseInt ( input . nextLine ( ) ) ; final int [ ] A = readInts ( ) ; Arrays . sort ( A ) ; int ans = 0 ; for ( int i = A . length - 2 ; i > A . length - 2 * n - 1 ; i -= 2 ) { ans += A [ i ] ; } System . out . println ( ans ) ; if ( Class . isAnnotationPresent ( Median . class ) ) { return new Median ( ) ; } return null ; }
public static int [ ] getN ( ) { int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; A [ i ] = a ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int nex ; if ( i == 0 ) { now = 0 ; nex = A [ 0 ] ; count ++ ; } else { nex = A [ nex - 1 ] ; } } return A ; }
public static String compute ( ) { int a = 0 ; int b = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { a = b ; b = a + b ; } return Integer . toString ( a ) ; }
static void findFrequencyUtil ( int arr [ ] , int low , int high , int [ ] freq ) { if ( ( arr [ low ] == arr [ high ] ) && ( arr [ low ] == arr [ high ] ) ) { freq [ arr [ low ] ] += high - low + 1 ; } else { int mid = ( int ) ( ( low + high ) / 2 ) ; findFrequencyUtil ( arr , low , mid , freq ) ; findFrequencyUtil ( arr , mid + 1 , high , freq ) ; } /* ▁ find ▁ the ▁ frequency ▁ */ int [ ] freq = new int [ n - 1 + 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { freq [ i ] = 0 ; } findFrequencyUtil ( arr , 0 , n - 1 , freq ) ; for ( int i = 0 ; i <= arr [ n - 1 ] ; i += 1 ) { if ( ( freq [ i ] != 0 ) && ( arr [ i + 1 ] == arr [ low ] ) ) { System . out . println ( " Element " + i + " ▁ occurs " + freq [ i ] + " ▁ times " ) ; } } if ( Class . isPrimitive ( ) ) { arr = new int [ ] { 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 } ; int n = arr . length ; findFrequency ( arr , n ) ; } }
static final String compute ( ) { final List < Integer > totients = EulerUtil . listTotients ( 10 * 7 - 1 ) ; int minnumer = 1 ; int mindenom = 0 ; final Iterator < Integer > it = totients . subList ( 2 , totients . size ( ) ) . iterator ( ) ; for ( int i = 0 ; i < totients . size ( ) ; i ++ ) { final int tot = totients . get ( i ) ; if ( i * mindenom < minnumer * tot && new String ( Integer . toString ( i ) ) . equals ( new String ( tot ) ) ) { minnumer = i ; mindenom = totients . get ( i ) ; } } return Integer . toString ( minnumer ) ; }
public static void intersection ( int [ ] a , int [ ] b , int n , int m ) { int i = 0 ; int j = 0 ; while ( ( i < n ) && ( j < m ) ) { if ( ( a [ i ] > b [ j ] ) ) { j ++ ; } else { if ( ( b [ j ] > a [ i ] ) ) { i ++ ; } else { System . out . print ( a [ i ] + " ▁ " ) ; i ++ ; j ++ ; } } } if ( getClass ( ) . equals ( " java . util . Arrays " ) ) { a = new int [ ] { 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 } ; b = new int [ ] { 3 , 3 , 5 } ; n = a . length ; m = b . length ; intersection ( a , b , n , m ) ; } }
static int findMin ( int [ ] a , int n ) { _sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { _sum += m . log ( a [ i ] ) ; } double x = m . exp ( _sum / n ) ; return ( int ) x ; }
@ GwtIncompatible ( " java . util . Arrays " ) public static int lcmOfArray ( int [ ] arr , int n ) { if ( ( n < 1 ) || ( n > arr . length ) ) return 0 ; int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i += 1 ) { lcm = ( int ) ( ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ) ; } return lcm ; }
static int subArrayCount ( int [ ] arr , int n ) { int result = 0 ; int fast = 0 , slow = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == 1 ) { fast ++ ; } else { int length = fast - slow + 1 ; result += length * ( length - 1 ) / 2 ; fast = i ; slow = i ; } } if ( ( fast != slow ) && ( slow != 0 ) ) { int length = fast - slow + 1 ; result += length * ( length - 1 ) / 2 ; } return result ; }
public static List < int [ ] > solve ( int n ) { int f = 0 ; int s = 0 ; boolean fs = true ; if ( ( n & 1 ) != 0 ) { n -- ; fs = false ; } while ( n > 0 ) { if ( n == 4 ) { f += 3 ; s ++ ; n = 0 ; } else if ( ( n / 2 ) & 1 != 0 ) { f += n / 2 ; s ++ ; n = ( n / 2 ) - 1 ; } else { } } ans . add ( s ) ; }
public static void main ( String input ) { n = Integer . parseInt ( input ) ; a = list ( map ( n , input ) ) ; System . out . println ( min ( a ) + " , " + max ( a ) + " , " + sum ( a ) ) ; }
@ Nullable public static String findSubString ( String strr ) { int MAX_CHARS = 256 ; int n = strr . length ( ) ; if ( n <= 1 ) return strr ; int distCount = new HashSet ( Arrays . asList ( strr . split ( " ▁ " ) ) ) . size ( ) ; int [ ] currCount = new int [ n ] ; int count = 0 ; int start = 0 ; int minLen = n ; for ( int j = 0 ; j < n ; j ++ ) { currCount [ strr . charAt ( j ) ] ++ ; if ( currCount [ strr . charAt ( j ) ] == 1 ) count ++ ; if ( count == distCount ) { while ( currCount [ strr . charAt ( start ) ] > 1 ) { if ( currCount [ strr . charAt ( start ) ] > 1 ) currCount [ strr . charAt ( start ) ] -- ; start ++ ; } int lenWindow = j - start + 1 ; if ( minLen > lenWindow ) { minLen = lenWindow ; startIndex = start ; } } } return String . valueOf ( strr . substring ( startIndex , startIndex + minLen ) ) ; }
public static int concentration ( int water , int suger ) { return 100 * suger / ( water + suger ) ; int WATER_A = Integer . parseInt ( input . nextLine ( ) ) ; int WATER_B = Integer . parseInt ( input . nextLine ( ) ) ; int SUGER_C = Integer . parseInt ( input . nextLine ( ) ) ; int SUGER_D = Integer . parseInt ( input . nextLine ( ) ) ; int MELT_PER_100 = Integer . parseInt ( input . nextLine ( ) ) ; int LIMIT = Integer . parseInt ( input . nextLine ( ) ) ; WATER_A *= 100 ; WATER_B *= 100 ; int MELT_PERCENT_LIMIT = concentration ( 100 , MELT_PER_100 ) ; int wa = 0 ; int wb = 0 ; int sc = 0 ; int sd = 0 ; Set < Integer > waterSet = new HashSet < Integer > ( ) ; while ( wa * WATER_A <= LIMIT ) { while ( wb * WATER_B <= LIMIT ) { water = wa * WATER_A + wb * WATER_B ; if ( water <= LIMIT ) { waterSet . add ( water ) ; } wb ++ ; } wb = 0 ; wa ++ ; } Set < Integer > sugerSet = new HashSet < Integer > ( ) ; while ( sc * SUGER_C <= LIMIT ) { while ( sd * SUGER_D <= LIMIT ) { int suger = sc * SUGER_C + sd * SUGER_D ; if ( suger <= LIMIT ) { sugerSet . add ( suger ) ; } sd ++ ; } sd = 0 ; sc ++ ; } int ansSugerWater = 0 ; int ansSuger = 0 ; int maxConcentration = 0 ; for ( Integer water : waterSet ) { for ( Integer suger : sugerSet ) { if ( ! ( 0 < water + suger <= LIMIT ) ) continue ; int sugerPrecent = concentration ( water , suger ) ; if ( maxConcentration <= sugerPrecent && sugerPrecent <= MELT_PERCENT_LIMIT ) { maxConcentration = sugerPrecent ; ansSugerWater = water + suger ; ansSuger = suger ; } } } System . out . println ( ansSugerWater + " ▁ " + ansSuger ) ; return maxConcentration ; }
static final String [ ] [ ] getLines ( ) { final BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; final List < List < Integer > > lines = new ArrayList < > ( ) ; for ( String line : br . readLine ( ) . split ( " , " ) ) { lines . add ( Collections . singletonList ( line ) ) ; } for ( int i = 1 ; i <= lines . size ( ) / 2 ; i ++ ) { for ( int j = 0 ; j < lines . get ( i ) ; j ++ ) { lines . get ( i ) . add ( j ) ; } } return lines . get ( lines . size ( ) - 1 ) . toArray ( ) ; }
static void countPairs ( int [ ] arr , int n ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 ) == 0 ) { even ++ ; } else { odd ++ ; } } int odPairs = odd * ( n - 1 ) ; int evenPairs = even * ( n - 1 ) ; System . out . println ( odPairs ) ; System . out . println ( evenPairs ) ; } if ( getClass ( ) . equals ( ArrayList . class ) ) { int [ ] arr = { 2 , 3 , 4 , 5 } ; int n = arr . length ; countPairs ( arr , n ) ; }
public static void print ( String input ) { int h = Integer . parseInt ( input ) ; for ( int x = 0 ; x < h ; x ++ ) { int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; int s = Math . min ( m , b ) ; m -= s ; b -= s ; while ( a % 10 == 0 ) { b ++ ; a = a / 10 ; } while ( n % 10 == 0 ) { m ++ ; n = n / 10 ; } String h = String . valueOf ( a ) ; String k = String . valueOf ( n ) ; if ( h . length ( ) + b > k . length ( ) + m ) { System . out . println ( " > " ) ; } else if ( h . length ( ) + b < k . length ( ) + m ) { System . out . println ( " < " ) ; } else { if ( h > k ) { System . out . println ( " > " ) ; } else if ( h < k ) { System . out . println ( " < " ) ; } else { System . out . println ( " = " ) ; } } } }
public static List < Integer > numbers = Lists . newArrayList ( ) ; for ( int i = 0 ; i <= columns ; i ++ ) { String x = input . nextLine ( ) ; String g = " not " ; String s = " not " ; int count = 0 ; for ( int j = 0 ; j <= rows ; j ++ ) { if ( x . charAt ( j ) == ' S ' ) { if ( g . equals ( " found " ) ) { counter = count + 1 ; if ( ! f . equals ( counter ) ) { data . add ( f . hashCode ( counter ) ) ; } } else { stop = 1 ; } break ; } else { count ++ ; } } }
public static boolean search ( int arr [ ] , int n , int x ) { int front = 0 ; int back = n - 1 ; while ( ( front <= back ) && ( arr [ front ] == x ) ) { if ( ( arr [ front ] == x ) || ( arr [ back ] == x ) ) { return true ; } front ++ ; back -- ; } return false ; arr = new int [ ] { 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 } ; x = 130 ; n = arr . length ; if ( ( search ( arr , n , x ) ) && ( arr [ n ] == x ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
static void countFreq ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , 0 ) ; } mp . put ( arr [ i ] , 1 ) ; } }
static int MinCostTree ( int arr [ ] , int n ) { int ans = 0 ; Stack < Integer > st = new Stack < > ( 2 * 32 ) ; for ( int i = 0 ; i < n ; i ++ ) { int x ; while ( ( x = st . peek ( ) ) <= arr [ i ] ) { st . pop ( ) ; ans += x * Math . min ( st . peek ( ) , arr [ i ] ) ; } st . push ( arr [ i ] ) ; } for ( int i = 2 ; i < st . size ( ) ; i ++ ) { ans += st . pop ( ) * st . peek ( ) ; } return ans ; }
public static int [ ] getDigits ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; LinkedList < String > s = new LinkedList < String > ( ) ; LinkedList < String > t = new LinkedList < String > ( ) ; for ( int i = 97 ; i <= 97 ; i ++ ) { s . add ( String . valueOf ( i ) ) ; t . add ( String . valueOf ( i ) ) ; } HashMap < Character , Integer > dic_s = new HashMap < Character , Integer > ( ) ; HashMap < Character , Integer > dic_t = new HashMap < Character , Integer > ( ) ; for ( int i = 97 ; i <= 97 ; i ++ ) { dic_s . put ( ( char ) i , 0 ) ; dic_t . put ( ( char ) i , 0 ) ; } for ( int i = 0 ; i < n ; i ++ ) { dic_s . put ( s . get ( i ) , 1 ) ; dic_t . put ( t . get ( i ) , 1 ) ; } if ( dic_s . size ( ) != dic_t . size ( ) ) { System . out . println ( - 1 ) ; } else { ArrayList < Integer > c = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( true ) { if ( s . get ( i ) . equals ( t . get ( i ) ) ) { break ; } int target = i + s . get ( i ) . indexOf ( t . get ( i ) ) ; c . add ( target - 1 ) ; s . set ( target - 1 , s . get ( target ) ) ; s . set ( target , s . get ( target ) ) ; } } int [ ] result = new int [ c . size ( ) ] ; for ( int el : c ) { System . out . print ( el + 1 ) ; } System . out . println ( c . size ( ) ) ; for ( int el : result ) { System . out . print ( el + " ▁ " ) ; } } return result ; }
static void findEquation ( int a , int b ) { int summ = ( a + b ) ; int product = ( a * b ) ; System . out . println ( " x ^ 2 ▁ - ▁ ( " + summ + " x ) ▁ + ▁ ( " + product + " ) ▁ = ▁ 0" ) ; }
public static void circleEquation ( int x1 , int y1 , int r ) { int a = - 2 * x1 ; int b = - 2 * y1 ; int c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; System . out . print ( " x ^ 2 ▁ + ▁ ( " + a + " ) ▁ + ▁ " ) ; }
public static void uniqueCombination ( int l , int sum , int K , List < Integer > local , List < Integer > A ) { if ( ( sum == K ) && ( l < local . size ( ) ) ) { System . out . print ( " { " ) ; for ( int i = 0 ; i < local . size ( ) ; i ++ ) { if ( ( i != 0 ) && ( i != 0 ) ) System . out . print ( " ▁ " ) ; System . out . print ( local . get ( i ) ) ; if ( ( i != local . size ( ) - 1 ) && ( i != l ) ) System . out . print ( " , ▁ " ) ; } System . out . println ( " } " ) ; return ; } for ( int i = l ; i < A . size ( ) ; i += 1 ) { if ( ( sum + A . get ( i ) ) > K ) continue ; if ( ( i == 1 ) && ( A . get ( i ) == A . get ( i - 1 ) ) && ( i > l ) ) continue ; local . add ( A . get ( i ) ) ; uniqueCombination ( i + 1 , sum + A . get ( i ) , K , local , A ) ; local . remove ( local . size ( ) - 1 ) ; } /* ▁ A . sort ( false ) ; ▁ local . clear ( ) ; STRNEWLINE ▁ uniqueCombination ( 0 , 0 , K , local , A ) ; */ if ( className . equals ( " java . util . Arrays " ) ) { int [ ] A = { 10 , 1 , 2 , 7 , 6 , 1 , 5 } ; K = 8 ; Combination ( A , K ) ; } }
static final int [ ] getPrices ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; ArrayList < Integer > prices = new ArrayList < > ( ) ; for ( String s : input . nextLine ( ) . split ( " ▁ " ) ) { prices . add ( Integer . parseInt ( s ) ) ; } for ( int i = 0 ; i < Integer . parseInt ( input . nextLine ( ) ) ; i ++ ) { System . out . println ( Arrays . binarySearch ( prices , Integer . parseInt ( input . nextLine ( ) ) ) ) ; } return prices . toArray ( new Integer [ 0 ] ) ; }
private static String z = " abcdefghijklmnopqrstuvwxyz " ; String a ; for ( int i = 1 ; i < 26 ; i += 2 ) { for ( int j = 0 ; j < 26 ; j ++ ) { a = StringUtils . charAt ( z . indexOf ( c ) * i + j ) ; if ( a . contains ( " that " ) || a . contains ( " this " ) ) return a ; } }
static boolean findNature ( int a , int b , int n ) { if ( ( n == 0 ) && ( a == 1 ) ) return ( a & 1 ) == 0 ; if ( ( n == 1 ) && ( b == 1 ) ) return ( b & 1 ) == 0 ; if ( ( ( a & 1 ) == 0 ) && ( ( b & 1 ) == 0 ) ) { if ( ( ( b & 1 ) == 0 ) && ( ( n - 1 ) % 3 != 0 ) ) return false ; else return ( ( n % 3 != 0 ) ? true : false ) ; } else { if ( ( ( b & 1 ) == 0 ) && ( ( n - 1 ) % 3 != 0 ) ) return ( ( n - 1 ) % 3 != 0 ) ? true : false ; else return ( ( n + 1 ) % 3 != 0 ) ? true : false ; } }
public static void main ( String input ) { int d = Integer . parseInt ( input ) ; int e = Integer . parseInt ( input ) ; if ( d == 0 ) { break ; } ArrayList < Point > list = new ArrayList < Point > ( ) ; for ( int i = 0 ; i <= 101 ; i ++ ) { for ( int j = 0 ; j <= 101 ; j ++ ) { list . add ( new Point ( Math . abs ( ( ( i * i + j * j ) * 0.5 ) - e ) , i , j ) ) ; } } for ( Point p : new ArrayList < Point > ( list ) ) { if ( p . y + p . z == d ) { System . out . println ( p . x ) ; break ; } } }
public static int maxSum ( int [ ] a , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; } if ( ( n == 1 ) && ( a [ i ] == 0 ) ) { dp [ 0 ] = Math . max ( 0 , a [ i ] ) ; } else if ( ( n == 2 ) && ( a [ i ] == 0 ) ) { dp [ 0 ] = Math . max ( 0 , a [ i ] ) ; dp [ 1 ] = Math . max ( a [ i ] , dp [ 0 ] ) ; } else if ( ( n >= 3 ) && ( a [ i ] == 0 ) ) { dp [ 0 ] = Math . max ( 0 , a [ i ] ) ; dp [ 1 ] = Math . max ( a [ i ] , Math . max ( 0 , a [ i ] ) ) ; dp [ 2 ] = Math . max ( a [ i ] , Math . max ( a [ i ] , Math . max ( 0 , a [ i ] ) ) ) ; int i = 3 ; while ( ( i < n ) && ( a [ i ] == 0 ) ) { dp [ i ] = Math . max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ; i ++ ; } } return dp [ n - 1 ] ; }
public static void input ( ) { int start = - 1 , letter = Integer . MIN_VALUE ; do { if ( ( sentence . charAt ( start ) != ' ▁ ' ) && ( sentence . charAt ( start ) != ' ? ' ) ) { letter = sentence . charAt ( start ) ; break ; } start -- ; } while ( start > 0 ) ; if ( letter . equalsIgnoreCase ( " a " ) || letter . equalsIgnoreCase ( " e " ) || letter . equalsIgnoreCase ( " i " ) || letter . equalsIgnoreCase ( " o " ) || letter . equalsIgnoreCase ( " u " ) || letter . equalsIgnoreCase ( " y " ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } }
static int minimumX ( int n , int k ) { int mini = Integer . MAX_VALUE ; int i = 1 ; while ( i * i <= n ) { if ( ( n % i ) == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( ( res == n ) && ( mini == mini ) ) { mini = Math . min ( num1 , mini ) ; } int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( ( res == n ) && ( mini == mini ) ) { mini = Math . min ( num2 , mini ) ; } } i ++ ; } return mini ; }
public static int findLongest ( int node ) { visited [ node ] = true ; if ( ! graph [ node ] . contains ( node ) ) return 1 ; int maxChild = 0 ; for ( int i : graph [ node ] ) { if ( visited [ i ] ) continue ; maxChild = Math . max ( maxChild , findLongest ( i ) ) ; } return maxChild + 1 ; }
public static int SellingPrice ( int CP , int PP ) { int Pdecimal = 1 + ( PP / 100 ) ; int res = Pdecimal * CP ; return res ; }
public static int t = Integer . parseInt ( input ) { for ( int c = 0 ; c < t ; c ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] seq = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) seq [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] posis = new int [ n + 1 ] ; for ( int u = 0 ; u <= n ; u ++ ) posis [ seq [ u ] ] = u ; System . out . print ( 1 ) ; int l = posis [ 1 ] ; int r = posis [ 1 ] ; for ( int num = 2 ; num <= n ; num ++ ) { if ( ( posis [ num ] < l ) && ( posis [ num ] > r ) ) l = posis [ num ] ; if ( ( posis [ num ] > r ) && ( posis [ num ] > l ) ) r = posis [ num ] ; System . out . print ( num == r - l + 1 ? 1 : 0 ) ; } System . out . println ( ) ; } return t ; }
static public @ Nonnull int f ( int b , int n ) { if ( b > n ) return n ; return f ( b , n / b ) + ( n % b ) ; }
public static void main ( String input ) { int m = Integer . parseInt ( input . split ( " ▁ " ) [ 0 ] ) ; int b = Integer . parseInt ( input . split ( " ▁ " ) [ 1 ] ) ; int maximum = 0 ; for ( int y = 0 ; y < b + 1 ; y ++ ) { int sum = ( m * ( b - y ) + y ) * ( m * ( b - y ) + 1 ) * ( y + 1 ) / 2 ; if ( maximum <= sum ) { maximum = sum ; } else { break ; } } System . out . println ( maximum ) ; }
static void check ( int n , int m ) { if ( ( m % n ) == 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
public static void main ( String input ) { for ( ; ; ) { int x = Integer . parseInt ( input ) ; int [ ] a = Integer . parseInt ( input . substring ( 0 , 2 ) ) ; int p = 0 ; for ( int i = 0 ; i < x - 2 ; i ++ ) { if ( a [ i ] >= 0 && a [ i + 2 ] <= 0 ) { p = 1 ; break ; } } System . out . println ( p != 0 ? " YES " : " NO " ) ; } }
public static int print ( int a , int b ) { if ( a < b ) { System . out . println ( b - a ) ; } else if ( a > b ) { System . out . println ( a - b ) ; } else { System . out . println ( 0 ) ; } return a ; }
private static Map < String , String > map ( String input ) { int n = Integer . parseInt ( input ) ; int m = Integer . parseInt ( input ) ; String s = input . substring ( 0 , n ) ; Map < String , String > ls = new HashMap < String , String > ( ) ; for ( int i = 0 ; i < m ; i ++ ) ls . put ( s , s ) ; return ls ; }
static int findNthOccur ( String string , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( ( string . charAt ( i ) == ch ) && ( occur == N ) ) { return i ; } } return - 1 ; }
@ Function public static int mostFrequent ( List < Integer > list ) { AtomicInteger occurentCount = new AtomicInteger ( list ) ; return occurentCount . getAndIncrement ( ) . get ( ) ; }
static String compute ( ) { final int LIMIT = 10 * 15 ; final int MODULUS = 10 * 9 ; final int splitcount = EulerMath . sqrt ( LIMIT ) ; final int splitat = LIMIT / ( splitcount + 1 ) ; { final int sum = ( e * ( e + 1 ) * ( e * 2 + 1 ) - s * ( s + 1 ) * ( s * 2 + 1 ) ) / 6 ; int ans = sum + ( i * i * ( LIMIT / i ) ) ; ans += sum ; ans += ( ( sumSquares ( LIMIT / ( i + 1 ) , LIMIT / i ) * i ) ) ; ans += sum ; ans += ( ( sumSquares ( LIMIT / ( i + 1 ) , LIMIT / i ) * i ) ) ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; ans += sum ; } }
public static void main ( String input ) { for ( ; ; ) { int n = Integer . parseInt ( input . substring ( 0 , input . indexOf ( " ▁ " ) ) ) ; int k = Integer . parseInt ( input . substring ( input . indexOf ( " ▁ " ) + 1 ) ) ; int z = Integer . parseInt ( input . substring ( input . indexOf ( " ▁ " ) + 1 ) ) ; int [ ] a = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int ans = 0 ; int s = 0 ; int mx = 0 ; for ( int i = 0 ; i < k + 1 ; i ++ ) { if ( i < n - 1 ) { mx = Math . max ( mx , a [ i ] + a [ i + 1 ] ) ; } s += a [ i ] ; if ( i % 2 == k % 2 ) { int tmp = ( k - i ) / 2 ; if ( tmp <= z ) { ans = Math . max ( ans , s + mx * tmp ) ; } } } System . out . println ( ans ) ; } }
public static void print ( int n ) { int [ ] arr = Integer . parseInt ( input ( ) ) ; int l = - 1 , r = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] != s ) { s -- ; continue ; } else { System . out . println ( 0 , 0 ) ; exit ( 0 ) ; } } }
public static List < Set < Integer > > convert ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; List < List < Integer > > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { list . add ( Collections . singletonList ( Integer . parseInt ( input . nextLine ( ) ) ) ) ; } int [ ] aStart = new int [ n ] ; int [ ] aEnd = new int [ n ] ; int [ ] hStart = new int [ n ] ; int [ ] hEnd = new int [ n ] ; int [ ] bStart = new int [ n ] ; int [ ] bEnd = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { list . add ( Collections . singletonList ( Integer . parseInt ( input . nextLine ( ) ) ) ) ; } /* ▁ make ▁ sets ▁ of ▁ integers ▁ */ List < Set < Integer > > sets = new ArrayList < > ( ) ; BitSet member = new BitSet ( ) ; for ( int i = 0 ; i < 1440 ; i ++ ) { boolean upd = false ; for ( int j = 0 ; j < n ; j ++ ) { if ( start [ j ] == i ) { member . set ( j ) ; upd = true ; } if ( end [ j ] == i - 1 ) { member . remove ( j ) ; upd = true ; } } if ( upd ) { sets . add ( new HashSet < > ( member ) ) ; } } return sets ; }
public static int [ ] getTwoInt ( ) { int [ ] twoInt = input . nextInt ( ) ; for ( int i = 0 ; i < 2 ; i ++ ) { twoInt [ i ] = Integer . parseInt ( twoInt [ i ] ) ; } return twoInt ; /* ▁ distributeStone ▁ of ▁ the ▁ two ▁ integers ▁ */ int candidateNum = 0 ; int stoneNum = 0 ; int [ ] candidateArray = new int [ candidateNum ] ; int i = 0 ; int order ; do { order = i % candidateNum ; if ( bowlStone != 0 ) { candidateArray [ order ] ++ ; bowlStone -- ; } else if ( bowlStone == 0 && candidateArray [ order ] == stoneNum ) { return order ; } else { bowlStone = candidateArray [ order ] ; candidateArray [ order ] = 0 ; } i ++ ; } while ( true ) ; if ( getClass ( ) . equals ( String . class ) ) { while ( true ) { candidateNum = getTwoInt ( ) ; stoneNum = getTwoInt ( ) ; if ( candidateNum == 0 ) { break ; } order = distributeStone ( candidateNum , stoneNum ) ; System . out . println ( order ) ; } } return null ; }
public static int countTwoIdx ( int [ ] A , int q ) { int ans = 0 ; int left = 0 ; int csum = 0 ; for ( int right = 0 ; right < N ; right ++ ) { csum += A [ right ] ; while ( csum > q ) { csum -= A [ left ] ; left ++ ; } ans += right - left + 1 ; } return ans ; }
public static int a = Integer . parseInt ( input ) { for ( int i = 0 ; i < a ; i ++ ) { int b = Integer . parseInt ( input . nextLine ( ) ) ; int c = Integer . parseInt ( input . nextLine ( ) ) ; int d = Math . abs ( b - c ) ; if ( d % 10 != 0 ) { System . out . println ( d / 10 + 1 ) ; } else { System . out . println ( d / 10 ) ; } } return a ; }
public static void performQueries ( int maxSize , int maxSize ) { final boolean [ ] isFib = new boolean [ maxSize ] ; final int [ ] prefix = new int [ maxSize ] ; { int i ; int prev = 0 ; int curr = 1 ; isFib [ prev ] = true ; isFib [ curr ] = true ; while ( ( curr = ( curr + 1 ) ) != 0 ) { s = s + num % 10 ; curr = num / 10 ; } } { generateFibonacci ( ) ; int sum ; int prev = 0 ; int curr = 1 ; isFib [ prev ] = true ; isFib [ curr ] = true ; while ( ( curr = ( curr + 1 ) ) != 0 ) { temp = curr + prev ; if ( temp < maxSize ) { isFib [ temp ] = true ; } prev = curr ; curr = temp ; } } { generateFibonacci ( ) ; synchronized ( prefix ) { for ( i = 1 ; i < maxSize ; i ++ ) { sum = digitSum ( i ) ; if ( ( isFib [ sum ] == true ) && ( sum % k == 0 ) ) { prefix [ i ] ++ ; } } for ( i = 1 ; i < maxSize ; i ++ ) { prefix [ i ] = prefix [ i ] + prefix [ i - 1 ] ; } } } { precompute ( k ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = query [ i ] [ 0 ] ; int r = query [ i ] [ 1 ] ; int cnt = prefix [ r ] - prefix [ l - 1 ] ; System . out . println ( cnt ) ; } } }
public static void for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { int x1 = Integer . parseInt ( input . nextLine ( ) ) ; int y1 = Integer . parseInt ( input . nextLine ( ) ) ; int x2 = Integer . parseInt ( input . nextLine ( ) ) ; int y2 = Integer . parseInt ( input . nextLine ( ) ) ; int x3 = Integer . parseInt ( input . nextLine ( ) ) ; int y3 = Integer . parseInt ( input . nextLine ( ) ) ; int alpha = 0 ; if ( y1 == y2 && y3 < y1 ) alpha += Math . abs ( x1 - x2 ) ; if ( y2 == y3 && y1 < y2 ) alpha += Math . abs ( x2 - x3 ) ; if ( y3 == y1 && y2 < y3 ) alpha += Math . abs ( x3 - x1 ) ; System . out . println ( alpha ) ; }
public static boolean isPalindrome ( String s ) { int l = s . length ( ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) { if ( ( s . charAt ( i ) != s . charAt ( l - 1 - i ) ) && ( s . charAt ( i ) != s . charAt ( l - 1 - i ) ) ) { return false ; } } /* ▁ create ▁ string ▁ and ▁ check ▁ palindrome ▁ */ String sub = " " + ( char ) ( '0' + s . charAt ( l ) ) ; String resStr = " " ; int sum = 0 ; int digit ; while ( ( digit = ( int ) ( N % 10 ) ) > 0 ) { digit = ( int ) ( N % 10 ) ; sum += digit ; digit = ( int ) ( N / 10 ) ; } while ( ( digit = ( int ) ( resStr . length ( ) ) ) < sum ) { resStr += sub ; } if ( ( resStr . length ( ) > sum ) && ( isPalindrome ( resStr ) ) ) { return true ; } /* ▁ if ▁ ( Class . getName ( ) . equals ( " java . lang . String " ) ) ▁ { STRNEWLINE ▁ int ▁ N ▁ = ▁ 10101 ; STRNEWLINE ▁ if ▁ ( ( ( String ) ▁ resStr ) . length ( ) = = 0 ) ▁ { STRNEWLINE ▁ System . out . println ( " Yes " ) ; STRNEWLINE ▁ } STRNEWLINE ▁ else ▁ { STRNEWLINE ▁ System . out . println ( " No " ) ; STRNEWLINE ▁ } STRNEWLINE ▁ } */ return false ; }
public static void main ( String input ) { String [ ] soots = { " S " , " H " , " C " , " D " } ; String [ ] sootlist = new String [ n ] ; int [ ] numlist = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String soot = Integer . parseInt ( input . substring ( 0 , i ) ) ; String num = Integer . parseInt ( input . substring ( i + 1 , i + 2 ) ) ; sootlist [ i ] = soot ; numlist [ i ] = Integer . parseInt ( num ) ; } String [ ] anSootlist = new String [ sootlist . length ] ; int [ ] anNumlist = new int [ sootlist . length ] ; for ( int i = 0 ; i < soots . length ; i ++ ) { for ( int num = 1 ; num < 14 ; num ++ ) { int flag = 0 ; for ( String s = sootlist [ i ] ; s != null && sootlist [ i ] . length ( ) > 0 ; s = s . substring ( 0 , i + 1 ) ) { int n = numlist [ i ] ; if ( soot . equals ( s ) && num == n ) { flag = 1 ; break ; } } if ( flag == 1 ) { continue ; } else { anSootlist [ i ] = soot ; anNumlist [ i ] = num ; } } } for ( int i = 0 ; i < anSootlist . length ; i ++ ) { System . out . println ( anSootlist [ i ] + " ▁ " + anNumlist [ i ] ) ; } }
public static int sumEvenAndEvenIndex ( int [ ] arr , int n ) { int i = 0 ; int sum = 0 ; for ( i = 0 ; i < n ; i += 2 ) { if ( ( arr [ i ] % 2 ) == 0 ) { sum += arr [ i ] ; } } return sum ; }
@ VisibleForTesting static Iterable < String > combinations ( ) { for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { String ans = " YES " ; for ( Map . Entry < String , Collection < String > > e : input . entrySet ( ) ) { if ( Collections . frequency ( e . getValue ( ) , 1 ) == 1 ) { ans = " NO " ; break ; } } System . out . println ( ans ) ; } return Collections . emptyList ( ) ; }
static void printDuplicates ( int arr [ ] , int n ) { int fl = 0 ; for ( int i = 0 ; ( i <= n ) && ( fl == 0 ) ; i ++ ) { if ( ( arr [ arr [ i ] % n ] >= n ) && ( arr [ arr [ i ] % n ] < 2 * n ) ) { System . out . print ( arr [ i ] % n + " ▁ " ) ; fl = 1 ; } } arr [ 0 ] += n ; }
public static void print ( int sum ( 1 / ( i + 1 ) for i in range ( int len ( input ) ) ) ) { }
private static int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
static int maxHandshake ( int n ) { return ( int ) ( ( n * ( n - 1 ) ) / 2 ) ; }
public static int grayCode ( int n ) { return n ^ ( n > > 1 ) ; }
public static int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
public static int possibleways ( int n ) { if ( ( n % 2 ) == 1 ) { return 0 ; } else if ( ( n % 4 ) == 0 ) { return n / 4 - 1 ; } else { return n / 4 ; } }
static int CountSetBits ( int n ) { if ( ( n == 0 ) || ( n == 1 ) ) { return 0 ; } if ( ( ( n & 1 ) == 1 ) ) { return 1 + CountSetBits ( n > > 1 ) ; } else { return CountSetBits ( n > > 1 ) ; } if ( getClass ( ) . getName ( ) . equals ( " java . util . concurrent . atomic . AtomicInteger " ) ) { n = 21 ; System . out . println ( CountSetBits ( n ) ) ; } return 0 ; }
static int summ ( int m , int n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; }
public static int SUM ( int n , int m ) { if ( ( m == 1 ) || ( n == 1 ) ) { return ( n * ( n + 1 ) / 2 ) ; } double sum = SUM ( n , m ) ; return sum ; }
static int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; }
static int findSum ( int n ) { return ( ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ) ; }
static int cntWays ( int n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } n = 18 ; System . out . println ( cntWays ( n ) ) ; }
private static void findCompositeNots ( int n ) { System . out . println ( 9 * n + " \t " + 8 * n ) ; }
static int findThirdDigit ( int n ) { if ( n < 3 ) { return 0 ; } return n > 0 && 1 < n ? 6 : 0 ; }
static int countMaxIntersect ( int n ) { return ( int ) ( n * ( n - 1 ) / 2 ) ; }
public static int sum ( int n ) { if ( ( n == 1 ) || ( n == 2 ) ) { return 2 ; } else { return ( n * ( n + 1 ) + sum ( n - 1 ) ) ; } }
static int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
static int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; }
public static String S = input ( ) { for ( int i = ( int ) ' a ' ; i <= ( int ) ' z ' ; i ++ ) { if ( ( char ) i != ' ' && ! list . contains ( S ) ) { System . out . println ( ( char ) i ) ; exit ( ) ; } } System . out . println ( " None " ) ; return null ; }
public static void print ( int n ) { int [ ] array = input . split ( " ▁ " ) ; int a = 0 ; while ( a < n ) { array [ a ] = Integer . parseInt ( array [ a ] ) ; a ++ ; } int smallest = min ( array ) ; Arrays . sort ( array ) ; int i = 1 ; boolean tOrF = true ; while ( i < n ) { if ( array [ i ] / smallest != ( int ) ( array [ i ] / smallest ) ) { tOrF = false ; } i ++ ; } if ( tOrF == true ) { System . out . println ( smallest ) ; } else { System . out . println ( - 1 ) ; } }
public static void print ( String input ) { print ( " ABC " if ( int . parseInt ( input ) < 1200 ) else " ARC " ) ; }
static private final char skipSpaces ( ) throws Exception { char c = ' ▁ ' ; while ( Character . isWhitespace ( c ) ) { c = Character . current ( ) ; } return c ; }
public static int smallest ( int x , int y , int z ) { int c = 0 ; while ( ( x > 0 && y > 0 && z > 0 ) ) { x = x - 1 ; y = y - 1 ; z = z - 1 ; c = c + 1 ; } return c ; }
public static int a , int b , int c , int d , int e , int f ; int sum = Integer . parseInt ( input . readLine ( ) ) ; sum = a + b * 5 + c * 10 + d * 50 + e * 100 + f * 500 ; return ( sum >= 1000 ? 1 : 0 ) ; }
public static int m ( ) { int r = Integer . parseInt ( input . nextLine ( ) ) ; double res = 0 , sq2 = ( 2 * .5 ) ; for ( int i = 1 ; i < m ; i ++ ) { res += 2 + sq2 + 2 * sq2 * ( i - 1 ) + ( i - 1 ) * i ; } res = ( res + m ) * 2 * r ; return res / ( m * m ) ; }
@ org . python . Method ( __doc__ = " Count ▁ of ▁ cubes ▁ is ▁ " ) public static int countCubes ( ) { return ( floor ( b * ( 1. / 3. ) ) - ceil ( a * ( 1. / 3. ) ) + 1 ) ; }
@ VisibleForTesting static void heapSearch ( List < Integer > itemArr , int d ) { final int INF = 10 * 20 ; { final Map < Integer , Boolean > visited = new HashMap < > ( ) ; visited . put ( new Integer ( 0 ) , true ) ; List < Integer > que = new ArrayList < > ( ) ; heapSearch ( que , new IntArrayDeque ( ) ) ; while ( que . size ( ) > 0 ) { int score = Integer . parseInt ( que . get ( 0 ) ) ; int a = Integer . parseInt ( que . get ( 1 ) ) ; int e = Integer . parseInt ( que . get ( 2 ) ) ; for ( int da : itemArr . get ( e ) ) { int de = itemArr . get ( da ) ; int na = a + da ; if ( na >= d ) { System . out . println ( score + 1 ) ; return ; } int ne = e + de ; if ( ne > 100 ) { ne = 100 ; } if ( ! visited . containsKey ( new Integer ( na ) ) ) { visited . put ( new Integer ( na ) , new Integer ( ne ) ) ; heapSearch ( que , new IntArrayDeque ( ) ) ; } } } System . out . println ( ) ; } }
static final String compute ( ) { final long triangle = 0 ; for ( int i = 1 ; i < 1000 ; i ++ ) { triangle += i ; if ( numDivisors ( triangle ) > 500 ) { return String . valueOf ( triangle ) ; } } { final long end = EulerMath . sqrt ( n ) ; long result = Long . valueOf ( 2 ) ; for ( int i = 1 ; i <= end ; i ++ ) { if ( n % i == 0 ) { result -- ; } } return result ; } if ( __name__ . equals ( " _ _ main _ _ " ) ) { System . out . println ( compute ( ) ) ; } return " " ; }
static int findDelta ( int a , int b , int c , int d ) { return ( int ) ( ( b * c - a * d ) / ( d - c ) ) ; }
private static void sieveOfEratosthenes ( int n , boolean [ ] isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) { isPrime [ i ] = true ; } int p = 2 ; while ( ( p * p <= n ) && ( isPrime [ p ] ) ) { int i = p * p ; while ( ( i <= n ) && ( isPrime [ i ] ) ) { isPrime [ i ] = false ; i += p ; } } p ++ ; }
static int replaceDigit ( int x , int d1 , int d2 ) { int result = 0 ; int multiply = 1 ; while ( ( x % 10 ) > 0 ) { int remainder = x % 10 ; if ( ( remainder == d1 ) && ( remainder == d2 ) ) result = ( result + d2 * multiply ) ; else result = remainder ; } return result ; }
static int printPattern ( int i , int j , int n ) { if ( ( j >= n ) && ( j <= n ) ) return 0 ; if ( ( i >= n ) && ( j <= n ) ) return 1 ; if ( ( j == i ) || ( j == n - 1 - i ) ) { if ( ( i == n - 1 - j ) && ( j == n - 1 ) ) System . out . print ( " / " ) ; else System . out . print ( " \ " " ) ; } else System . out . print ( " * " ) ; if ( ( printPattern ( i , j + 1 , n ) ) == 1 ) return 1 ; System . out . println ( ) ; return printPattern ( i + 1 , 0 , n ) ; }
static int getPairsCount ( int arr [ ] , int n , int sum ) { final int [ ] m = new int [ 1000 ] ; for ( int i = 0 ; i <= n ; i ++ ) { m [ arr [ i ] ] ++ ; } int twiceCount = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { twiceCount += m [ sum - arr [ i ] ] ; if ( ( sum - arr [ i ] ) == arr [ i ] ) twiceCount -- ; } return ( int ) twiceCount / 2 ; }
public static int Count_subarray ( int [ ] arr , int n ) { int subarraySum = 0 , remainingSum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarraySum = 0 ; remainingSum = 0 ; for ( int k = i ; k <= j ; k ++ ) subarraySum += arr [ k ] ; for ( int l = 0 ; l < i ; l ++ ) remainingSum += arr [ l ] ; for ( int l = j + 1 ; l < n ; l ++ ) remainingSum += arr [ l ] ; if ( ( subarraySum > remainingSum ) && ( subarraySum < remainingSum ) ) count ++ ; } } return count ; }
public static void main ( String input ) { for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { int n = Integer . parseInt ( input . substring ( 0 , input . indexOf ( " ▁ " ) ) ) ; int x = Integer . parseInt ( input . substring ( input . indexOf ( " ▁ " ) , input . indexOf ( " ▁ " ) ) ) ; int a = Integer . parseInt ( input . substring ( input . indexOf ( " ▁ " ) , input . indexOf ( " ▁ " ) ) ) ; int b = Integer . parseInt ( input . substring ( input . indexOf ( " ▁ " ) , input . indexOf ( " ▁ " ) ) ) ; int p = Math . abs ( a - b ) ; int q = p + x ; if ( q >= n - 1 ) System . out . println ( n - 1 ) ; else System . out . println ( q ) ; } }
static final int [ ] s ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } Arrays . sort ( s ) ; int t = Integer . parseInt ( s [ n ] ) ; if ( t % 10 != 0 ) { System . out . println ( t ) ; System . exit ( 0 ) ; } return s ; }
@ VisibleForTesting static void shuffle ( ) { final Scanner input = new Scanner ( System . in ) ; for ( ; ; ) { final int n = input . nextInt ( ) ; final int k = input . nextInt ( ) ; final int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = input . nextInt ( ) ; } int res = Integer . MAX_VALUE ; for ( int color = 1 ; color <= 101 ; color ++ ) { int i = 0 ; int day = 0 ; while ( i < n ) { if ( i < n && arr [ i ] != color ) { i += k ; day ++ ; } else { i ++ ; } } res = Math . min ( res , day ) ; } System . out . println ( res ) ; } }
@ VisibleForTesting static int findRepeatingNumber ( int [ ] arr , int n ) { double sq = Math . sqrt ( n ) ; int range__ = ( int ) ( ( n / sq ) + 1 ) ; int [ ] count = new int [ range__ ] ; for ( int i = 0 ; i < n ; i += 1 ) { count [ ( int ) ( ( arr [ i ] - 1 ) / sq ) ] ++ ; } int selectedBlock = range__ - 1 ; for ( int i = 0 ; i <= range__ - 1 ; i += 1 ) { if ( ( count [ i ] > sq ) && ( count [ i ] > sq ) ) { selectedBlock = i ; break ; } } Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( ( ( selectedBlock * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selectedBlock + 1 ) * sq ) ) ) ) { m . put ( arr [ i ] , 1 ) ; if ( ( m . get ( arr [ i ] ) > 1 ) && ( m . get ( arr [ i ] ) > 1 ) ) { return arr [ i ] ; } } } return - 1 ; }
static int maxPrimeFactors ( int n ) { final int maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n >>= 1 ; } for ( int i = 3 ; i <= ( int ) Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } return ( int ) maxPrime ; }
public static void print ( int t = Integer . parseInt ( input ) ) { for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > l = Lists . newArrayList ( ) ; for ( int j = 0 ; j < n ; j ++ ) { l . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } int count = 0 ; for ( int j = 0 ; j < l . size ( ) ; j ++ ) { count += l . get ( j ) % 2 ; } System . out . println ( Math . min ( count , n - count ) ) ; } }
public static void input ( ) { int num_0 = 0 ; int num_1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '0' ) num_0 ++ ; else num_1 ++ ; } System . out . println ( Math . min ( num_0 , num_1 ) * 2 ) ; }
public static void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= ( int ) ( n / 3 ) ; i ++ ) { for ( int j = i + 1 ; j <= ( int ) ( n / 2 ) ; j ++ ) { int k = n - i - j ; if ( ( i * i + j * j ) == k * k ) { System . out . println ( i + " , ▁ " + j + " , ▁ " + k ) ; return ; } } } }
static final int countDigits ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) { return 1 ; } return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }
static int indexOfFirstOne ( int arr [ ] , int low , int high ) { int mid ; while ( ( low <= high ) && ( arr [ low ] == 1 ) ) { mid = ( low + high ) / 2 ; if ( ( arr [ mid ] == 1 ) && ( mid == 0 || arr [ mid - 1 ] == 0 ) ) { break ; } else if ( ( arr [ mid ] == 1 ) ) { high = mid - 1 ; } else { low = mid + 1 ; } } /* ▁ index ▁ of ▁ first ▁ */ return mid ; }
static final Scanner getScanner ( ) { final Scanner scanner = new Scanner ( System . in ) ; final int n = scanner . nextInt ( ) ; if ( n % 3 == 0 ) { System . out . println ( n / 3 * 2 ) ; } else if ( n < 3 ) { System . out . println ( 1 ) ; } else { System . out . println ( n / 3 * 2 + 1 ) ; } return scanner ; }
public static void print ( ) { double n ; while ( true ) { n = Double . parseDouble ( input . nextLine ( ) ) ; if ( n < 0 ) break ; if ( ( int ) ( n * 16 ) - n * 16 > 0 ) System . out . println ( " NA " ) ; continue ; else { String s = Integer . toBinaryString ( ( int ) ( n * 16 ) ) . substring ( 2 ) . toString ( 12 ) ; System . out . println ( s . substring ( 0 , s . length ( ) - 4 ) + " . " + s . substring ( s . length ( ) - 4 ) ) ; } } }
static int digSum ( int n ) { int sum = 0 ; int rem = 0 ; while ( ( n = n / 10 ) > 0 ) { rem = n % 10 ; sum = sum + rem ; n = ( int ) ( n / 10 ) ; } return sum ; }
public static void main ( String [ ] args ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] P = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { P [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } editorial ( N , P ) ; { if ( N == 1 ) { System . out . println ( 0 ) ; return ; } int [ ] a = new int [ N + 1 ] ; for ( int i = 0 ; i < P . length ; i ++ ) { a [ P [ i ] ] = i ; } int tmp = 1 ; int maxLen = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { tmp ++ ; maxLen = Math . max ( maxLen , tmp ) ; } else { tmp = 1 ; } } int ans = N - maxLen ; System . out . println ( ans ) ; } { int tmp = 0 ; int ans = 0 ; for ( int i = 0 ; i < P . length ; i ++ ) { if ( i == 0 || P [ i - 1 ] + 1 == P [ i ] ) { tmp ++ ; } else { ans = Math . max ( ans , tmp ) ; tmp = 1 ; } } System . out . println ( N - ans ) ; } if ( getClass ( ) . isClassPresent ( Main . class ) ) { Main . main ( args ) ; } }
public static void main ( ) { for ( int i = 0 ; i < 7 ; i ++ ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; System . out . println ( a - b ) ; } }
static void performQueries ( int [ ] A , int [ ] [ ] q ) { int n = A . length ; int [ ] pref_xor = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) pref_xor [ i ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] ; for ( int i = 0 ; i < q . length ; i ++ ) { int L = q [ i ] [ 0 ] ; int R = q [ i ] [ 1 ] ; if ( ( L > R ) && ( R > R ) ) L = R ; } }
static final String toString ( ) { return " I ▁ ( " + Arrays . asList ( Integer . toString ( 0 ) ) + " ) " ; }
public static double [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [
; if ( __name__ == " _ _ main _ _ " ) { int num = 3 ; int lterm = 1 ; int rterm = num * num + 1 ; for ( int i = num ; i >= 0 ; i -- ) { for ( int space = num ; space >= i ; space -- ) { System . out . print ( " ▁ " ) ; } for ( int j = 1 ; j <= i ; lterm ++ ) { System . out . print ( Integer . toString ( lterm ) + " * " ) ; lterm ++ ; } for ( int j = 1 ; j <= i ; rterm ++ ) { System . out . print ( rterm ) ; if ( j < i ) { System . out . print ( " * " ) ; } rterm ++ ; } rterm = rterm - ( i - 1 ) * 2 - 1 ; System . out . println ( ) ; } }
static void findPerm ( int n , int [ ] differences ) { int [ ] ans = new int [ n ] ; Arrays . fill ( ans , 0 ) ; int x = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = differences [ i ] ; x = x + diff ; ans [ i ] = x ; } int [ ] anss = ans ; Arrays . sort ( ans ) ; int flag = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { int res = ans [ i ] - ans [ i - 1 ] ; if ( ( res != 1 ) && ( flag == 1 ) ) flag = 0 ; } if ( ( flag == 0 ) && ( anss . length == 0 ) ) { System . out . println ( " - 1" ) ; return ; } else { } }
static int countPrimeFactors ( int n ) { int count = 0 ; while ( ( n % 2 ) == 0 ) { n = n / 2 ; count ++ ; } int i = 3 ; while ( ( i <= Math . sqrt ( n ) ) ) { while ( ( n % i ) == 0 ) { n = n / i ; count ++ ; } i = i + 2 ; } if ( ( n > 2 ) && ( n > 1 ) ) { count ++ ; } return ( count ) ; }
public static int solve ( int N , int K ) { int [ ] combo = new int [ N + 1 ] ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; }
public static void input ( ) { String X = input . readLine ( ) ; if ( X . equals ( "0" ) ) break ; String r = " " ; boolean minus = false ; if ( X . charAt ( 0 ) == ' - ' ) { minus = true ; X = X . substring ( 1 ) ; } int kuri = 0 ; int idx = X . length ( ) - 1 ; while ( idx >= 0 ) { int a = Integer . parseInt ( X . substring ( idx , idx + 1 ) ) ; if ( minus ) { r = Integer . toString ( ( 10 - a - kuri ) % 10 ) + r ; kuri = kuri + a == 0 ? 0 : 1 ; } else { r = Integer . toString ( ( kuri + a ) % 10 ) + r ; kuri = ( kuri + a ) / 10 ; } minus = ! minus ; if ( idx == 0 && kuri > 0 ) X = "0" + X ; else idx -- ; } r = Integer . toString ( kuri ) + r ; System . out . println ( Integer . parseInt ( r ) ) ; }
static double normal ( int m , int n ) { final double N = ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( n ) ) ) ) ; return N ; }
public static void main ( String input ) { int n = Integer . parseInt ( input . split ( " ▁ " ) [ 0 ] ) ; double h = Double . parseDouble ( input ) ; double [ ] ans = new double [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { ans [ i ] = h * ( ( i / n ) ** 0.5 ) ; } System . out . println ( * ans ) ; }
static int countBits ( int n ) { int count = 0 ; while ( ( n & 1 ) != 0 ) { count ++ ; n >>>= 1 ; } return count ; }
public static void main ( String input ) { int h = Integer . parseInt ( input . substring ( 0 , 1 ) ) ; int a = Integer . parseInt ( input . substring ( 1 , 2 ) ) ; int b = Integer . parseInt ( input . substring ( 2 , 3 ) ) ; System . out . println ( h * w - ( a * b * ( ( h / a ) * ( w / b ) ) ) ) ; }
@ VisibleForTesting static void binarySearch ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > tlst = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { tlst . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } int maxT = tlst . get ( tlst . size ( ) - 1 ) ; int [ ] divisors = new int [ maxT + 1 ] ; for ( int i = 1 ; i <= maxT ; i ++ ) { divisors [ i ] = i ; } int ans = 0 ; for ( int t : tlst ) { int ind = bl ( divisors , t ) ; ans += divisors [ ind ] - t ; } System . out . println ( ans ) ; }
public static int LongestSubarray ( int [ ] arr , int n , int k ) { int [ ] arr2 = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] % k ; } int maxLength = 0 ; int i = 0 ; while ( i < n ) { int currentLength = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr2 [ j ] == arr2 [ i ] ) && ( arr2 [ j ] == arr2 [ j ] ) ) { currentLength ++ ; } else { break ; } } maxLength = Math . max ( maxLength , currentLength ) ; i = j ; i ++ ; } return maxLength ; }
public static int n ( ) { int m = map ( Integer . parseInt ( input . nextLine ( ) ) , n ) ; return m - 1 <= n && m + 1 <= n && n != 1 ? m + 1 : 1 ; }
static boolean isHeterogram ( String s , int n ) { int [ ] hash = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != ' ▁ ' ) { if ( hash [ ( int ) s . charAt ( i ) - ' a ' ] == 0 ) { hash [ ( int ) s . charAt ( i ) - ' a ' ] = 1 ; } else { return false ; } } } return true ; }
static String compute ( ) { final List < String > arr = new LinkedList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { arr . add ( " " + i ) ; } Iterable < String > temp = new IterableWithToString < > ( ) ; for ( String s : arr ) { temp . add ( s ) ; } return " " . concat ( String . valueOf ( temp ) ) ; }
private static boolean findPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( ( x > x1 && x < x2 ) && ( y > y1 && y < y2 ) ) { return true ; } else { return false ; } if ( getClass ( ) . getName ( ) . equals ( " java . awt . GraphicsDevice " ) ) { x1 = 0 ; y1 = 0 ; x2 = 10 ; y2 = 8 ; x = 1 ; y = 5 ; if ( findPoint ( x1 , y1 , x2 , y2 , x , y ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } return false ; }
@ Sys public static int from ( @ Max ( 1 ) int INT_MAX ) { final int MX = 2001 ; final int OFF = 1000 ; class point { int x ; int y ; } public int countPoints ( int n , @ NonNull Point [ ] points ) { int [ ] minx = new int [ MX ] ; int [ ] miny = new int [ MX ] ; int [ ] maxx = new int [ MX ] ; int [ ] maxy = new int [ MX ] ; int x , y ; for ( int i = 0 ; i < n ; i ++ ) { points [ i ] . x += OFF ; points [ i ] . y += OFF ; x = points [ i ] . x ; y = points [ i ] . y ; minx [ y ] = Math . min ( minx [ y ] , x ) ; maxx [ y ] = Math . max ( maxx [ y ] , x ) ; miny [ x ] = Math . min ( miny [ x ] , y ) ; maxy [ x ] = Math . max ( maxy [ x ] , y ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = points [ i ] . x ; y = points [ i ] . y ; if ( ( x > minx [ y ] ) && ( x < maxx [ y ] ) ) { if ( ( y > miny [ x ] ) && ( y < maxy [ x ] ) ) { count ++ ; } } } return count ; } if ( __name__ . equals ( " java . util . Vector " ) ) { Point [ ] points = { point ( 0 , 0 ) , point ( 0 , 1 ) , point ( 1 , 0 ) , point ( 0 , - 1 ) , point ( - 1 , 0 ) } ; int n = points . length ; System . out . println ( countPoints ( n , points ) ) ; } return 0 ; }
public static void print ( int X_low , int Y_up ) { int value = X_low ; int cnt = 0 ; while ( ( value <= Y_up ) ) { cnt ++ ; value *= 2 ; } System . out . println ( cnt ) ; }
@ java . lang . SuppressWarnings ( " all " ) public static int [ ] sticks ( String string , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ ( string . charAt ( i ) - '0' ) ] ) ; } return cnt ; }
public static int T = Integer . parseInt ( input ) { for ( int t = 0 ; t <= T ; t ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } int ctr = 0 ; int maxi = Math . max ( a [ 0 ] , maxi ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] && a [ i - 1 ] > a [ i - 2 ] ) { ctr ++ ; if ( i != n - 1 ) { a [ i ] = Math . max ( a [ i - 1 ] , a [ i + 1 ] ) ; } else { a [ i ] = a [ i - 1 ] ; } } } System . out . println ( ctr ) ; for ( int item : a ) { System . out . print ( item + " ▁ " ) ; } System . out . println ( ) ; } return T ; }
public static void command ( int brr , int a , int b ) { arr [ a ] ^= 1 ; arr [ b + 1 ] ^= 1 ; }
static int mostFrequent ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int maxCount = 1 ; int res = arr [ 0 ] ; int currCount = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] == arr [ i - 1 ] ) && ( arr [ i ] == arr [ i ] ) ) { currCount ++ ; } else { if ( ( currCount > maxCount ) && ( arr [ i ] == arr [ i ] ) ) { maxCount = currCount ; res = arr [ i - 1 ] ; } currCount = 1 ; } } if ( ( currCount > maxCount ) && ( arr [ n ] == arr [ n ] ) ) { maxCount = currCount ; res = arr [ n - 1 ] ; } return res ; }
public static int maxLength ( String str , int len ) { int res = 0 ; int [ ] lastPos = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { lastPos [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int C = ( str . charAt ( i ) - ' a ' ) ; if ( ( lastPos [ C ] != - 1 ) && ( i < lastPos . length ) ) { res = Math . max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) ; } lastPos [ C ] = i ; } return res ; }
public static int ksmallest ( int [ ] arr , int n , int k ) { int [ ] b = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; ; j ++ ) { } }
static boolean isDivisible ( int n ) { while ( n / 100 != 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
public static boolean isDivisible ( int n ) { while ( n / 100 != 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; if ( getClassName ( ) . equals ( " java . lang . Integer " ) ) { n = 59173 ; if ( ( isDivisible ( n ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } return false ; }
static boolean isDivisible ( int n ) { while ( n / 100 != 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
static boolean isDivisible ( int n ) { while ( n / 100 != 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; if ( getClass ( ) . getName ( ) . equals ( " java . lang . Integer " ) ) { int N = 5041 ; if ( ( isDivisible ( N ) ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } return false ; }
private static int OddSum ( int n ) { int total = ( n + 1 ) / 2 ; int odd = total * total ; return odd ; }
static boolean isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( ( lowCost <= ans && ans <= upCost ) ) { return true ; } } return false ; } int lowCost = 14 ; int upCost = 30 ; int lowQuant = 5 ; int upQuant = 12 ; int r = 9 ; if ( ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; }
static private boolean Log2 ( int x ) { if ( x == 0 ) { return false ; } return ( Math . log10 ( x ) / Math . log10 ( 2 ) ) != 0 ; /* ▁ Is ▁ this ▁ a ▁ power ? ▁ */ }
static String compute ( ) { final long LIMIT = 50000000 ; final List < BigInteger > primes = EulerLibrary . listPrimes ( EulerLibrary . sqrt ( LIMIT ) ) ; final Set < BigInteger > sums = new HashSet < BigInteger > ( 0 ) ; for ( int i = 2 ; i < 5 ; i ++ ) { final Set < BigInteger > newsums = new HashSet < BigInteger > ( ) ; for ( BigInteger p : primes ) { final long q = p . pow ( i ) ; if ( q > LIMIT ) break ; for ( BigInteger x : sums ) { if ( x . add ( q ) . compareTo ( LIMIT ) <= 0 ) newsums . add ( x . add ( q ) ) ; } } sums = newsums ; } return String . valueOf ( sums . size ( ) ) ; }
@ VisibleForTesting static long longLenSub ( int [ ] arr , int n ) { Map < Integer , Integer > um = new HashMap < > ( ) ; long longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len1 = 0 ; if ( ( arr [ i - 1 ] >= 0 ) && ( len1 < um . get ( arr [ i ] - 1 ) ) ) { len1 = um . get ( arr [ i ] - 1 ) ; } if ( ( arr [ i + 1 ] >= 0 ) && ( len1 < um . get ( arr [ i + 1 ] ) ) ) { len1 = um . get ( arr [ i + 1 ] ) ; } um . put ( arr [ i ] , len1 + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } return longLen ; }
public static void main ( String input ) { for ( ; ; ) { int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; System . out . println ( a + b ) ; } }
static int calculateSum ( int n ) { int sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
static int calculateSum ( int n ) { int sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
static int maxDiff ( int [ ] arr , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int currSum = diff ; int maxSum = currSum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( ( currSum > 0 ) && ( currSum < diff ) ) { currSum += diff ; } else { currSum = diff ; } if ( ( currSum > maxSum ) && ( currSum < maxSum ) ) { maxSum = currSum ; } } return maxSum ; }
public static long f3 ( int n ) { long a = 0 ; long b = 0 ; long c = 0 ; for ( ; n > 0 ; n -- ) { a = ( a + b + c + 1 ) % 100000007 ; b = a ; c = b ; } return a ; long f5 ( n ) ; long a = 0 ; long b = 0 ; long c = 0 ; long d = 0 ; long e = 0 ; for ( ; n > 0 ; n -- ) { a = ( a + b + c + d + e + 1 ) % 100000007 ; b = ( a + b + c + d + e + 1 ) % 100000007 ; c = ( a + b + c + d + e + 1 ) % 100000007 ; d = ( a + b + c + d + e + 1 ) % 100000007 ; e = ( a + b + c + d + e + 1 ) % 100000007 ; } while ( true ) { String s = input . next ( ) ; if ( s . equals ( " # " ) ) break ; long ans = 1 ; String num = " _ " ; int cnt = 1 ; for ( ; n < s . length ( ) ; n ++ ) { if ( s . charAt ( n ) == num ) cnt ++ ; else { if ( "80" . equals ( num ) ) ans = ans * f3 ( cnt ) % 100000007 ; else ans = ans * f5 ( cnt ) % 100000007 ; num = s . charAt ( n ) ; cnt = 1 ; } } System . out . println ( ans ) ; } }
static int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int Max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( ( val == Max ) && ( val == Max ) ) count ++ ; } } return count ; }
public static void input ( Scanner in ) { String n = in . nextLine ( ) . trim ( ) ; int l = in . nextInt ( ) ; int [ ] x = new int [ l ] ; for ( int i = 0 ; i < l - 1 ; i ++ ) { if ( i == 0 ) { x [ i ] = 0 ; } else { x [ i ] = x [ i - 1 ] ; } if ( n . charAt ( i ) == n . charAt ( i + 1 ) ) { x [ i ] ++ ; } } for ( int m = 0 ; m < Integer . parseInt ( in . nextLine ( ) ) ; m ++ ) { int y = in . nextInt ( ) , z = in . nextInt ( ) ; if ( y == 1 ) { System . out . println ( x [ z - 2 ] ) ; } else { System . out . println ( x [ z - 2 ] - x [ y - 2 ] ) ; } } }
@ Test public static void solve ( ) { Scanner f_i = new Scanner ( System . in ) ; /* ▁ First ▁ rec ▁ the ▁ number ▁ of ▁ integers ▁ */ int n = f_i . nextInt ( ) ; int m = f_i . nextInt ( ) ; if ( n == 0 ) { return ; } char tray = cups [ n - 1 ] ; if ( tray == ' A ' ) { /* ▁ First ▁ rec ▁ the ▁ number ▁ of ▁ integers ▁ */ int i = f_i . nextInt ( ) ; if ( i == 0 ) { break ; } cups [ i ] = null ; for ( char tray : " ABC " . toCharArray ( ) ) { Iterator itr = f_i . nextInt ( ) ; ( ( Integer ) itr . next ( ) ) . intValue ( ) ; while ( itr . hasNext ( ) ) { cups [ i - 1 ] = tray ; } } int num = i ; int ans = Math . min ( num , 3 * n - 1 - num ) ; if ( ans <= m ) { System . out . println ( ans ) ; } else { System . out . println ( - 1 ) ; } } }
static void print ( int [ ] g1 , int a , int [ ] g2 , int b ) { for ( int i = 0 ; i < a ; i ++ ) System . out . print ( g1 [ i ] + " ▁ " ) ; System . out . print ( " and ▁ " ) ; for ( int i = 0 ; i < b ; i ++ ) System . out . print ( g2 [ i ] + " ▁ " ) ; System . out . print ( " \n " ) ; }
static void cutRibbon ( ) { int [ ] arr = new int [ 3 ] ; for ( int i = 0 ; i < input . length ; i ++ ) { arr [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } int length = arr [ 0 ] ; Arrays . sort ( arr , 1 , 4 , false ) ; if ( ( length % arr [ 0 ] ) == 0 ) { System . out . println ( ( int ) ( length / arr [ 0 ] ) ) ; return ; } int ans = 0 ; if ( ( arr [ 0 ] == arr [ 1 ] ) && ( arr [ 2 ] == arr [ 2 ] ) ) { int k = 0 ; for ( int i = 0 ; i < ( int ) ( length / arr [ 2 ] ) + 1 ; i ++ ) { int check = length - i * arr [ 2 ] - j * arr [ 1 ] ; if ( ( check >= 0 ) && ( check % arr [ 0 ] ) == 0 ) { k = ( int ) ( check / arr [ 0 ] ) ; ans = Math . max ( ans , k + i + j ) ; } } } System . out . println ( ans ) ; }
static int maxSubseq ( int [ ] vec , int n ) { int suffix = 0 ; int i = n - 1 ; while ( ( i >= 0 ) && ( vec [ i ] == 1 ) ) { suffix ++ ; vec [ i ] = suffix ; } i -- ; int res = 0 ; int zero = 0 ; for ( i = 0 ; i < n ; i += 1 ) { if ( ( vec [ i ] == 0 ) && ( vec [ i ] == 1 ) ) { zero ++ ; } if ( ( vec [ i ] > 0 ) && ( vec [ i ] == 1 ) ) { res = Math . max ( res , zero + vec [ i ] ) ; } } return Math . max ( res , zero ) ; }
public static int countPaths ( int [ ] [ ] maze ) { int R = 4 ; int C = 4 ; int i ; int j ; if ( ( maze [ 0 ] [ 0 ] == - 1 ) && ( maze [ 0 ] [ 1 ] == 0 ) ) { return 0 ; } for ( i = 0 ; i < R ; i ++ ) { if ( ( maze [ i ] [ 0 ] == 0 ) && ( maze [ i ] [ 1 ] == 0 ) ) { maze [ i ] [ 0 ] = 1 ; } else { break ; } } for ( i = 1 ; i < C ; i += 1 ) { if ( ( maze [ 0 ] [ i ] == 0 ) && ( maze [ i ] [ 1 ] == 0 ) ) { maze [ 0 ] [ i ] = 1 ; } else { break ; } } for ( i = 1 ; i < R ; i += 1 ) { for ( j = 1 ; j < C ; j += 1 ) { if ( ( maze [ i ] [ j ] == - 1 ) && ( maze [ i - 1 ] [ j ] > 0 ) ) { maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; } if ( ( maze [ i ] [ j - 1 ] > 0 ) && ( maze [ i ] [ j ] > 0 ) ) { maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } } if ( ( maze [ R - 1 ] [ C - 1 ] > 0 ) && ( maze [ R - 1 ] [ C - 1 ] > 0 ) ) { return maze [ R - 1 ] [ C - 1 ] ; } else { return 0 ; } }
static void isPrime ( int N ) { boolean isPrime = true ; int arr [ ] = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( ( N < 2 ) || ( N % 2 == 0 ) || ( N % 3 == 0 ) || ( N % 5 == 0 ) ) { isPrime = false ; } for ( int i = 0 ; ( i < ( int ) Math . sqrt ( N ) ) && ( arr [ i ] > ( int ) Math . sqrt ( N ) ) ; i += 30 ) { for ( int j = 0 ; j < arr . length ; j ++ ) { int c = arr [ j ] ; if ( ( c > ( int ) Math . sqrt ( N ) ) && ( arr [ j ] > ( int ) Math . sqrt ( N ) ) ) { break ; } else { if ( ( N % ( c + i ) == 0 ) && ( arr [ j ] > ( int ) Math . sqrt ( N ) ) ) { isPrime = false ; break ; } } if ( ( ! isPrime ) && ( arr [ j ] == 0 ) ) { break ; } } } if ( ( isPrime ) && ( arr [ 0 ] == 0 ) ) { System . out . println ( " Prime ▁ Number " ) ; } else { System . out . println ( " Not ▁ a ▁ Prime ▁ Number " ) ; } if ( Class . forName ( " java . lang . Integer " ) . equals ( " java . lang . Math . PI " ) ) { N = 121 ; isPrime = true ; } }
public static void drawLine ( ) { x1 = 0 ; y1 = 0 ; x2 = 0 ; y2 = Integer . parseInt ( input . nextLine ( ) ) ; a = x2 - x1 ; b = y2 - y1 ; System . out . println ( x2 - b , y2 + a , x1 - b , y1 + a ) ; }
public static int max ( int x , int y ) { if ( ( x > y ) && ( x < y ) ) { return x ; } return y ; /* ▁ if ▁ ( ( i ▁ = = ▁ 0 ▁ & & ▁ j ▁ = = ▁ 1 ) ▁ & & ▁ ( i ▁ < ▁ x ) ▁ & & ▁ ( j ▁ < ▁ y ) ▁ & & ▁ ( i ▁ < ▁ x ) ▁ & & ▁ ( j ▁ < ▁ y ) ) ▁ { STRNEWLINE ▁ return ▁ 1 ; STRNEWLINE ▁ } */ /* ▁ if ▁ ( ( i ▁ = = ▁ 0 ▁ & & ▁ j ▁ = = ▁ 1 ) ▁ & & ▁ ( i ▁ < ▁ x ) ▁ & & ▁ ( j ▁ < ▁ x ) ▁ & & ▁ ( i ▁ < ▁ x ) ▁ & & ▁ ( j ▁ < ▁ y ) ) ▁ { STRNEWLINE ▁ return ▁ 2 ; STRNEWLINE ▁ } */ /* ▁ if ▁ ( ( i ▁ = = ▁ 0 ▁ & & ▁ j ▁ = = ▁ 0 ▁ & & ▁ i ▁ < ▁ x ) ▁ & & ▁ ( j ▁ < ▁ x ) ▁ & & ▁ ( i ▁ < ▁ x ) ▁ & & ▁ ( j ▁ < ▁ y ) ) ▁ { STRNEWLINE ▁ return ▁ lps ( seq , ▁ i + 1 , ▁ j ▁ - ▁ 1 ) ▁ + ▁ 2 ; STRNEWLINE ▁ } */ /* ▁ return ▁ max ( lps ( seq , ▁ i , ▁ j ▁ - ▁ 1 ) , ▁ lps ( seq , ▁ i + 1 , ▁ j ) ) ; STRNEWLINE ▁ */ }
static int findLength ( String st , int n ) { int [ ] total = new int [ n + 1 ] ; total [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { total [ i ] = ( total [ i - 1 ] + Integer . parseInt ( st . substring ( i - 1 ) ) - Integer . parseInt ( "0" ) ) ; } int ans = 0 ; int l = 2 ; while ( ( l <= n ) && ( ans == 0 ) ) { for ( int i = 0 ; i < n - l + 1 ; i ++ ) { int j = i + l - 1 ; if ( ( total [ i + Integer . parseInt ( l / 2 ) ] - total [ i ] ) == total [ i + l ] - total [ i + Integer . parseInt ( l / 2 ) ] ) ans = j ; } l = l + 2 ; } return ans ; }
private static void prints ( char [ ] a , int n , int ind ) { int i = ind ; while ( i < n + ind ) { System . out . print ( a [ ( i % n ) ] + " ▁ " ) ; i = i + 1 ; } }
private static void prints ( String [ ] a , int n , int ind ) { String [ ] b = new String [ 2 * n ] ; b [ 0 ] = null ; b [ 1 ] = a [ 0 ] ; b [ 2 ] = a [ 1 ] ; }
static void solve ( ) { final Scanner input = new Scanner ( System . in ) ; solve ( ) ; final int n = Integer . parseInt ( input . nextLine ( ) ) ; final int a = Integer . parseInt ( input . nextLine ( ) ) ; final int b = Integer . parseInt ( input . nextLine ( ) ) ; }
static final void main ( String input ) { System . setSecurityManager ( new SecurityManager ( ) ) ; int n = Integer . parseInt ( input ) ; a = new int [ n ] ; b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { } }
public static int v1 = Integer . parseInt ( input ) { int v2 = Integer . parseInt ( input . nextLine ( ) ) ; int t = Integer . parseInt ( input . nextLine ( ) ) ; int d = Integer . parseInt ( input . nextLine ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < t ; i ++ ) { sum += Math . min ( v1 + d * i , v2 + d * ( t - i - 1 ) ) ; } System . out . println ( sum ) ; return 0 ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; List < Integer > Sherlock = new LinkedList < Integer > ( ) ; List < Integer > Moriarty = new ArrayList < Integer > ( ) ; Collections . sort ( Moriarty ) ; List < Integer > copySherlock = new ArrayList < Integer > ( ) ; for ( int digit : Sherlock ) { copySherlock . add ( digit ) ; } List < Integer > copyMoriarty = new ArrayList < Integer > ( ) ; for ( int digit : Moriarty ) { copyMoriarty . add ( digit ) ; } int minHits = 0 ; int maxHits = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( copyMoriarty . get ( j ) == - 1 ) continue ; if ( copyMoriarty . get ( j ) > copySherlock . get ( i ) ) { maxHits ++ ; copyMoriarty . set ( j ) ; break ; } } } System . out . println ( minHits ) ; System . out . println ( maxHits ) ; }
static final int [ ] [ ] a ( ) { int [ ] [ ] a = new int [ ] [ ] { Integer . MIN_VALUE } ; return a ; }
public static int t = Integer . parseInt ( input ) { for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < j + 1 ; k ++ ) { if ( k == 0 || k == j ) { System . out . print ( 1 ) ; } else { System . out . print ( 0 ) ; } } System . out . println ( ) ; } } return t ; }
public static void bin ( int n ) { if ( ( n > 1 ) && ( n < 3 ) ) { bin ( n > > 1 ) ; } System . out . print ( n & 1 ) ; bin ( 3 ) ; }
public static String compute ( ) { int ans = Integer . valueOf ( 1000 ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { if ( ( i % 3 == 0 || i % 5 == 0 ) ) { ans ++ ; } } return String . valueOf ( ans ) ; }
public static void input ( ) { S = input ( ) ; A = S . count ; System . out . println ( '1 ▁ ' * A . get ( ' n ' ) + '0 ▁ ' * A . get ( ' z ' ) ) ; }
public static void print ( int a ) { int b = ( int ) input ( ) ; System . out . println ( b * 2 - a ) ; }
private static int circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; if ( getClass ( ) . equals ( " java . lang . Integer " ) ) { n = 4 ; System . out . println ( circular ( n - 1 ) ) ; } return 0 ; }
static int productDiagonals ( int [ ] [ ] arr , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * arr [ i ] [ i ] ; product = product * arr [ i ] [ n - i - 1 ] ; } if ( ( n % 2 ) == 1 ) { product = product / arr [ n / 2 ] [ n / 2 ] ; } return product ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; if ( n == 0 ) break ; HashMap < Integer , Integer > dic = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int c = Integer . parseInt ( input ) ; dic . put ( c , ++ i ) ; } for ( int v : dic . values ( ) ) { System . out . println ( v != 0 ? ' * ' + v : ' - ' ) ; } }
public static char getSecondMostFreq ( String str ) { final int NO_OF_CHARS = 256 ; int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ ( int ) str . charAt ( i ) ] ++ ; } int first = 0 , second = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( ( count [ i ] > count [ second ] ) && ( count [ i ] != count [ first ] ) ) { second = i ; } } return ( char ) second ; }
public static int [ ] a ( int [ ] a ) { for ( int i = 0 ; i < 4001 ; i ++ ) a [ i ] = a [ 4000 - i ] = ( i + 3 ) * ( i + 2 ) * ( i + 1 ) / 6 - 4 * a [ i - 1001 ] * ( i > 999 ) ; while ( true ) { try { System . out . println ( a [ Integer . parseInt ( input ( ) ) ] ) ; } catch ( Exception e ) { break ; } } return a ; }
static int [ ] mySort ( int [ ] arr , int n ) { int [ ] arr1 = new int [ n / 2 ] ; int [ ] arr2 = new int [ n / 2 ] ; System . arraycopy ( arr , 0 , arr1 , 0 , n / 2 ) ; System . arraycopy ( arr , n / 2 , arr1 , n / 2 ) ; Arrays . sort ( arr2 , 0 , n , true ) ; return arr1 ; }
public static int minflip ( int [ ] arr1 , int [ ] arr2 , int [ ] arr3 , int p , int q , int n ) { int flip = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr1 [ i ] ^ arr2 [ i ] != arr3 [ i ] ) ) { flip ++ ; } } return ( flip <= p + q ) ? flip : - 1 ; }
public static double sum ( int n ) { int i = 1 ; double s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) { s = s + 1 / i ; } return s ; }
public static void bitonicGenerator ( int [ ] arr , int n ) { int [ ] evenArr = new int [ n ] ; int [ ] oddArr = new int [ n ] ; for ( int i = 0 ; i < evenArr . length ; i ++ ) { if ( ( ( i % 2 ) == 0 ) && ( arr [ i ] == 0 ) ) { evenArr [ i ] = arr [ i ] ; } else { oddArr [ i ] = arr [ i ] ; } } Arrays . sort ( evenArr ) ; Arrays . sort ( oddArr ) ; oddArr = Arrays . sort ( oddArr ) ; int [ ] oddArray = oddArr . clone ( ) ; Arrays . sort ( oddArray ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . length ; j ++ ) { arr [ i ] = evenArr [ j ] ; i ++ ; } for ( int j = 0 ; j < oddArr . length ; j ++ ) { arr [ i ] = oddArr [ j ] ; i ++ ; } arr = new int [ ] { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; n = arr . length ; bitonicGenerator ( arr , n ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int countPairs ( int arr [ ] , int n ) { int count = 0 ; int right = 0 ; int left = 0 ; boolean [ ] visited = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { visited [ arr [ right ] ] = false ; } while ( ( right < n ) && ( visited [ arr [ right ] ] == false ) ) { count += ( right - left ) ; visited [ arr [ right ] ] = true ; right ++ ; } while ( ( left < right ) && ( right != n ) && ( visited [ arr [ right ] ] == true ) ) { visited [ arr [ left ] ] = false ; left ++ ; } return count ; }
public static TreeNode < Integer > createTreeNode ( int val ) { TreeNode < Integer > root ; TreeNode < Integer > root ; TreeNode < Integer > left ; TreeNode < Integer > right ; class Solution implements Comparable < Integer > { public boolean isSubtree ( TreeNode < Integer > s , TreeNode < Integer > t ) { String sRes = preorder ( s , true ) ; String tRes = preorder ( t , true ) ; return tRes . contains ( sRes ) ; } public String preorder ( TreeNode < Integer > root , boolean isLeft ) { if ( root == null ) { if ( isLeft ) { return " lnull " ; } else { return " rnull " ; } } return " # " + root . val + " ▁ " + preorder ( root . left , true ) + " ▁ " + preorder ( root . right , false ) ; } } if ( __name__ . equals ( " Solution " ) ) { Solution sObj = new Solution ( ) ; root = new TreeNode < Integer > ( 3 ) ; root . left = new TreeNode < Integer > ( 4 ) ; root . right = new TreeNode < Integer > ( 5 ) ; root . left . left = new TreeNode < Integer > ( 1 ) ; root . left . right = new TreeNode < Integer > ( 2 ) ; TreeNode < Integer > subRoot = new TreeNode < Integer > ( 4 ) ; subRoot . left = new TreeNode < Integer > ( 1 ) ; subRoot . right = new TreeNode < Integer > ( 2 ) ; boolean out = sObj . isSubtree ( root , subRoot ) ; System . out . println ( out ) ; } return root ; }
public static int M = 1001 ; int MOD = 998244353 ; int [ ] [ ] dp = new int [ M ] [ M ] ; int ans ; int N = 0 ; int M = 0 ; int K = 0 ; for ( int i = 0 ; i < M ; i ++ ) { dp [ i ] [ i ] = - 1 ; } /* ▁ solve ▁ the ▁ idx ▁ */ if ( ( idx > N ) && ( ( diff > K ) ) ) { if ( ( diff == K ) && ( ( dp [ idx ] [ diff ] == - 1 ) ) ) { return 1 ; } /* ▁ return ▁ 0 ; ▁ */ if ( ( dp [ idx ] [ diff ] != - 1 ) && ( dp [ idx ] [ diff ] == - 1 ) ) { return dp [ idx ] [ diff ] ; } ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; dp [ idx ] [ diff ] = ans % MOD ; return dp [ idx ] [ diff ] ; } if ( __name__ . equals ( " java . util . Arrays " ) ) { N = 3 ; M = 3 ; K = 0 ; System . out . println ( M * solve ( 2 , 0 , N , M , K ) ) ; } return 0 ; }
static String compute ( ) { final int NUM_SPHERES = 21 ; final int [ ] sphereradii = new int [ NUM_SPHERES ] ; for ( int i = 0 ; i < NUM_SPHERES ; i ++ ) { sphereradii [ i ] = ( i + 30 ) * 1000 ; } final double [ ] [ ] minlength = new double [ 2 * NUM_SPHERES ] [ NUM_SPHERES ] ; for ( int i = 0 ; i < NUM_SPHERES ; i ++ ) { minlength [ i ] [ i ] = null ; } /* ▁ find ▁ minimum ▁ length ▁ */ final int currentsphereIndex = i ; final int setofspheres = i ; if ( ( setofspheres & ( 1 << currentsphereIndex ) ) == 0 ) { throw new IllegalArgumentException ( ) ; } if ( minlength [ currentsphereIndex ] [ setofspheres ] == null ) { double result ; if ( EulerUtil . popCount ( setofspheres ) == 1 ) { result = sphereradii [ currentsphereIndex ] ; } else { result = Double . POSITIVE_INFINITY ; final int newsetofspheres = setofspheres ^ ( 1 << currentsphereIndex ) ; for ( int i = 0 ; i < NUM_SPHERES ; i ++ ) { if ( ( newsetofspheres & ( 1 << i ) ) == 0 ) { continue ; } double temp = Math . sqrt ( ( sphereradii [ i ] + sphereradii [ currentsphereIndex ] - 50000 ) * 200000 ) ; temp += findMinimumLength ( i , newsetofspheres ) ; result = Math . min ( temp , result ) ; } } minlength [ currentsphereIndex ] [ setofspheres ] = result ; } final double ans = Math . min ( ( findMinimumLength ( i , ( 1 << NUM_SPHERES ) - 1 ) + sphereradii [ i ] ) , Double . MAX_VALUE ) ; return String . valueOf ( ( int ) Math . round ( ans ) ) ; }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] t = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) { t [ j ] = Integer . parseInt ( input ) ; } Arrays . sort ( t ) ; int a = t [ 0 ] * t [ 0 ] + t [ 1 ] * t [ 1 ] ; int b = t [ 2 ] * t [ 2 ] ; if ( a == b ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
static int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { if ( ( N % 2 ) == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) { res ^= arr [ i ] ; } return res ; }
static int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( ( freq % 2 ) == 1 ) res = res ^ arr [ i ] ; } return res ; }
; if ( __name__ == " _ _ main _ _ " ) { long l = Long . parseLong ( input . nextLine ( ) ) ; long p = Long . parseLong ( input . nextLine ( ) ) ; long q = Long . parseLong ( input . nextLine ( ) ) ; long s = l / ( p + q ) ; long x = p * s ; System . out . println ( x ) ; }
public static void main ( String input ) { for ( ; ; ) { int n = Integer . parseInt ( input ) ; List < Integer > l = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { l . add ( Integer . parseInt ( input ) ) ; } System . out . println ( l . get ( n ) - l . get ( n - 1 ) ) ; } }
public static void print ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] t = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int ans = 0 ; Map < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( - t [ i ] ) ) { ans += freq . get ( - t [ i ] ) ; } if ( freq . containsKey ( t [ i ] ) ) { freq . put ( t [ i ] , 1 ) ; } else { freq . put ( t [ i ] , 1 ) ; } } System . out . println ( ans ) ; }
public static void main ( String input ) { int pya = Integer . parseInt ( input ) ; String [ ] arre = new String [ 3 ] ; while ( pya > 0 ) { pya -- ; arre [ pya ] = input . toLowerCase ( ) ; } String oString = input ; String lowString = oString . toLowerCase ( ) ; char letter1 = input . charAt ( 0 ) . toLowerCase ( ) ; char letter2 = Character . toLowerCase ( letter1 ) != ' a ' ? ' a ' : ' b ' ; int [ ] valid = new int [ oString . length ( ) ] ; for ( int i = 0 ; i < oString . length ( ) ; i ++ ) { valid [ i ] = 0 ; } Set < Integer > setcito = new HashSet < Integer > ( ) ; for ( String s : arre ) { if ( lowString . indexOf ( s ) >= 0 ) { int wat = 0 ; do { int index = lowString . indexOf ( s , wat ) ; if ( index < 0 ) break ; for ( int j = index ; j < index + s . length ( ) ; j ++ ) setcito . add ( j ) ; } } } System . out . println ( ) ; }
static final long bigPrimeSum ( ) { final long bigPrimeSum = 1000000007 ; final long sum = BigInteger . valueOf ( 1 ) . multiply ( BigInteger . valueOf ( 2 ) ) . divide ( BigInteger . valueOf ( 2 ) ) ; return sum / bigPrimeSum ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] chips = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { chips [ i ] = i ; } }
@ VisibleForTesting static int [ ] [ ] solve ( ) { int N = 10100000 ; boolean [ ] temp = new boolean [ N + 1 ] ; temp [ 0 ] = temp [ 1 ] = false ; for ( int i = 2 ; i < ceil ( sqrt ( N + 1 ) ) ; i ++ ) { if ( temp [ i ] ) { temp [ i + i ] = new boolean [ temp [ i + i ] . length ] ; } } boolean [ ] quadruplet = new boolean [ ] { true , false , true , false , false , false , true , false , true } ; while ( true ) { try { int n = Integer . parseInt ( input . nextLine ( ) ) ; for ( int i = n ; i > 9 ; i -- ) { if ( temp [ i ] && temp [ i - 8 ] == quadruplet [ i ] ) { System . out . println ( i ) ; break ; } } } catch ( Exception e ) { System . out . println ( e ) ; } } return quadruplet ; }
public static int [ ] getBigIntegerArray ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } int [ ] r = new int [ a . length ] ; int s = 0 ; int l = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] != 1 ) { s = s + a [ i ] ; int t = i + 1 - l ; int p = s - 1 * t ; if ( p % 2 == 0 ) { r [ p ] = 2 ; } else { r [ p ] = 1 ; } } else { l = l + 1 ; if ( r . length == 0 ) { r [ p ] = 2 ; } else { int q = r [ r . length - 1 ] ; r [ p ] = q ; } } } for ( int i = 0 ; i < r . length ; i ++ ) { System . out . println ( r [ i ] ) ; } return r ; }
static boolean powerOfTwo ( int n ) { return ( ! ( n & n - 1 ) ) ; /* ▁ Only ▁ first ▁ and ▁ last ▁ are ▁ set ▁ */ if ( ( n == 1 ) && ( powerOfTwo ( n - 1 ) == 0 ) ) { return true ; } /* ▁ The ▁ following ▁ are ▁ the ▁ same ▁ as ▁ powerOfTwo ( n ) ▁ */ int n = 9 ; if ( ( n & n ) != 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
static int minimumCostOfBreaking ( int [ ] X , int [ ] Y , int m , int n ) { int res = 0 ; Arrays . sort ( X ) ; Arrays . sort ( Y ) ; int hzntl = 1 ; int vert = 1 ; int i = 0 ; int j = 0 ; while ( ( i < m ) && ( j < n ) ) { if ( ( X [ i ] > Y [ j ] ) && ( X [ i ] > Y [ j ] ) ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( ( i < m ) && ( i < n ) ) { total += X [ i ] ; i ++ ; } res += total * vert ; total = 0 ; while ( ( j < n ) && ( Y [ j ] > Y [ j ] ) ) { total += Y [ j ] ; j ++ ; } res += total * hzntl ; return res ; }
static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) return b ; return Math . gcd ( b % a , a ) ; }
public static int [ ] [ ] multiply ( int [ ] [ ] a , int [ ] [ ] b ) { int [ ] [ ] mul = new int [ 3 ] [ 3 ] ; for ( int x = 0 ; x < 3 ; x ++ ) mul [ x ] [ y ] = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) { mul [ i ] [ j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; } for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) a [ i ] [ j ] = mul [ i ] [ j ] ; return a ; }
public static void MinimumValue ( int x , int y ) { if ( ( x > y ) && ( x < y ) ) { x = y ; y = x ; } int a = 1 ; int b = 13 ; MinimumValue ( x , y ) ; }
public static boolean isSolution ( ) { int [ ] nums = { 4 , 2 , 3 } ; boolean out ; int [ ] out ; int brokenNum = 0 ; for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( ( nums [ i ] > nums [ i + 1 ] ) && ( nums [ i + 1 ] <= nums [ i ] ) ) { brokenNum ++ ; if ( brokenNum >= 2 ) return false ; if ( ( i - 1 < 0 ) || ( nums [ i - 1 ] <= nums [ i + 1 ] ) ) { nums [ i ] = nums [ i + 1 ] ; } else { nums [ i + 1 ] = nums [ i ] ; } } } return out ; }
public static boolean check ( int mid , int [ ] array , int n , int K ) { int count = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( array [ i ] > mid ) && ( sum > mid ) ) { return false ; } sum += array [ i ] ; if ( ( sum > mid ) && ( sum > mid ) ) { count ++ ; sum = array [ i ] ; } } count ++ ; if ( ( count <= K ) && ( sum > 0 ) ) { return true ; } /* solve */ int start = 1 ; int end = 0 ; for ( int i = 0 ; i < n ; i ++ ) { end += array [ i ] ; } int answer = 0 ; while ( ( start <= end ) && ( answer > mid ) ) { int mid = ( start + end ) / 2 ; if ( ( mid > 0 ) && ( answer < mid ) ) { answer = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } /* solve */ if ( getClass ( ) . equals ( " java . util . Arrays " ) ) { int [ ] array = { 1 , 2 , 3 , 4 } ; n = array . length ; K = 3 ; System . out . println ( solve ( array , n , K ) ) ; } return true ; }
@ VisibleForTesting static void main ( String s ) { int m , n ; do { m = ( Integer ) input . split ( s ) . get ( ) ; n = ( Integer ) input . split ( s ) . get ( ) ; } while ( m == 0 ) ; objs = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) objs [ i ] = Integer . parseInt ( input . split ( s ) , 2 ) ; int [ ] [ ] dp = new int [ 1 << m ] [ 1 << m ] ; int [ ] bits = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) bits [ i ] = 1 << i ; for ( int mask = 0 ; mask < 1 << m ; mask ++ ) { Set < Integer > s = new HashSet < Integer > ( objs . size ( ) ) ; objs . stream ( ) . filter ( obj -> obj & mask ) . forEach ( obj -> { for ( int b : s . iterator ( ) ) { if ( b > 1 ) dp [ mask ] [ b ] = Math . min ( Math . max ( dp [ mask | b ] [ masked ] , dp [ mask | b ] [ masked | b ] ) + 1 , Math . max ( dp [ mask | b ] [ masked | b ] , dp [ mask | b ] ) + 1 ) ; } } ) ; } System . out . println ( dp [ 0 ] [ 0 ] ) ; }
public static int test = Integer . parseInt ( input ) { for ( int i = 0 ; i < test ; i ++ ) { String a = input . next ( ) ; String b = input . next ( ) ; a = Integer . parseInt ( a ) ; b = Integer . parseInt ( b ) ; int c = ( Math . min ( a , b ) * 2 ) * 2 ; int d = ( Math . max ( a , b ) * 2 ) ; System . out . println ( Math . max ( c , d ) ) ; } return test ; }
public static String print ( String input ) { int t = Integer . parseInt ( input ) ; while ( t > 0 ) { int n = Integer . parseInt ( input ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( input ) ; } String ans = " YES " ; int [ ] zero = new int [ n ] ; int temp = - 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( b [ i ] == 0 ) { zero [ i ] = a [ i ] ; continue ; } int x = a [ i ] - b [ i ] ; if ( temp == - 1 ) { temp = x ; } if ( x < 0 || x != temp ) { ans = " NO " ; break ; } } if ( n == zero . length ) { temp = Math . max ( zero . length , zero . length ) ; } for ( int i : zero ) { if ( i <= temp ) { continue ; } else { ans = " NO " ; break ; } } System . out . println ( ans ) ; t -- ; } return ans ; }
public static String evenOrOdd ( String N ) { int l = N . length ( ) ; if ( ( N . charAt ( l - 1 ) == '0' ) || ( N . charAt ( l - 1 ) == '2' ) || ( N . charAt ( l - 1 ) == '4' ) || ( N . charAt ( l - 1 ) == '6' ) ) { return " Even " ; } else { return " Odd " ; } }
public static List < List < String > > a = Arrays . asList ( input . split ( " ▁ " ) ) ; List < List < String > > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < a . get ( 0 ) ; i ++ ) { list . add ( new ArrayList < > ( ) ) ; } for ( int i = 0 ; i < a . get ( 1 ) ; i ++ ) { int [ ] cmd = new int [ 2 ] ; for ( int j = 0 ; j < cmd . length ; j ++ ) { cmd [ j ] = Integer . parseInt ( input . readLine ( ) ) ; } switch ( cmd [ 0 ] ) { case 0 : list . get ( cmd [ 1 ] ) . add ( cmd [ 2 ] ) ; break ; case 1 : List < String > maped = CollectionUtils . toArrayList ( list . get ( cmd [ 1 ] ) ) ; String output = maped . toString ( ) ; System . out . println ( output ) ; break ; case 2 : list . set ( cmd [ 1 ] , new ArrayList < > ( ) ) ; break ; } } return list ; }
public static void input ( Scanner in ) { String [ ] num = in . nextLine ( ) . split ( " ▁ " ) ; int even = 0 ; for ( int i = 0 ; i < num . length ; i ++ ) { if ( Integer . parseInt ( num [ i ] ) % 2 == 0 ) { even ++ ; } } if ( even == 1 ) { for ( int i = 0 ; i < num . length ; i ++ ) { if ( Integer . parseInt ( num [ i ] ) % 2 == 0 ) { System . out . println ( num [ num . indexOf ( num [ i ] ) + 1 ] ) ; } } } else { for ( int i = 0 ; i < num . length ; i ++ ) { if ( Integer . parseInt ( num [ i ] ) % 2 == 1 ) { System . out . println ( num [ num . indexOf ( num [ i ] ) + 1 ] ) ; } } } }
public static int solve ( String X , String Y , int N , int K ) { int [ ] count = new int [ N + 1 ] ; int sol = 0 ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count [ i ] = ( count [ i - 1 ] + Math . abs ( ( int ) X . charAt ( i - 1 ) - ( int ) Y . charAt ( i - 1 ) ) ) ; } int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { while ( ( ( count [ i ] - count [ j ] ) > K ) && ( ( count [ i ] - count [ j ] ) > K ) ) { j ++ ; } sol = Math . max ( sol , i - j ) ; } return sol ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) , m = Integer . parseInt ( input ) ; for ( int i = 0 ; i < m ; i ++ ) { int a = Integer . parseInt ( input ) ; while ( a > 0 ) { n = a ; a = n % a ; } } System . out . println ( new String [ ] { " No " , " Yes " } [ n == 1 ] ) ; }
static boolean isPrime ( int n , int i ) { if ( ( n <= 2 ) && ( n <= 3 ) ) return ( n == 2 ) ? true : false ; if ( ( n % i == 0 ) && ( n <= 3 ) ) return false ; if ( ( i * i > n ) && ( n <= 3 ) ) return true ; return isPrime ( n , i + 1 ) ; int n = 15 ; if ( ( isPrime ( n ) ) && ( n <= 3 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; return false ; }
static boolean isPrime ( int n ) { int i = 2 ; while ( ( i * i <= n ) && ( n % i == 0 ) ) { if ( ( n % i == 0 ) && ( n % i == 0 ) ) { return false ; } i ++ ; } return true ; }
@ VisibleForTesting static int getPrime ( int x ) { for ( int i = 2 ; i <= ( int ) Math . sqrt ( x ) ; i ++ ) { if ( ( x % i ) == 0 ) { return 0 ; } } return 1 ; }
public static int snoob ( int x ) { int next = 0 ; if ( ( x != 0 ) && ( x != 0 ) ) { int rightOne = x & - ( x ) ; int nextHigherOneBit = x + ( int ) rightOne ; int rightOnesPattern = x ^ ( int ) nextHigherOneBit ; rightOnesPattern = ( Integer ) rightOnesPattern / Integer . MAX_VALUE > > 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
static int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = n + 1 ; ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j * j > i ) break ; if ( ( i % j ) == 0 ) { if ( ( i / j ) == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } if ( getClass ( ) . getName ( ) . equals ( " java . lang . Integer " ) ) { n = 4 ; System . out . println ( properDivisorSum ( n ) ) ; n = 5 ; System . out . println ( properDivisorSum ( n ) ) ; } return sum ; }
static int getMinLength ( int arr [ ] , int n ) { int count = 0 ; int result = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] == 1 ) && ( count != 0 ) ) { count ++ ; } else { if ( count != 0 ) { result = Math . min ( result , count ) ; } count = 0 ; } } return result ; }
public static int getLevenstein ( String inpt ) { String revInput = inpt . substring ( 0 , inpt . length ( ) - 1 ) ; int n = inpt . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int __ = 0 ; __ < n + 1 ; __ ++ ) { dp [ 0 ] [ __ ] = - 1 ; } for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( inpt . charAt ( i - 1 ) == revInput . charAt ( j - 1 ) ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } int res = INT_MAX ; int i = n , j = 0 ; while ( i >= 0 ) { res = Math . min ( res , dp [ i ] [ j ] ) ; if ( i < n ) { res = Math . min ( res , dp [ i + 1 ] [ j ] ) ; } if ( i > 0 ) { res = Math . min ( res , dp [ i - 1 ] [ j ] ) ; } i -- ; j ++ ; } return res ; }
public static String compute ( ) { final int LIMIT = 12000 ; final int [ ] minsumproduct = new int [ LIMIT + 1 ] ; Arrays . fill ( minsumproduct , null ) ; { if ( remain == 1 ) { if ( sum > n ) { throw new AssertionError ( ) ; } terms += n - sum ; if ( terms <= LIMIT && ( minsumproduct [ terms ] == 0 || n < minsumproduct [ terms ] ) ) { minsumproduct [ terms ] = n ; } } else { for ( int i = 2 ; i <= maxfactor ; i ++ ) { if ( remain % i == 0 ) { final int factor = i ; factorize ( n , remain / factor , Math . min ( factor , maxfactor ) , sum + factor , terms + 1 ) ; } } } } for ( int i = 2 ; i <= LIMIT * 2 ; i ++ ) { factorize ( i , i , i , 0 , 0 ) ; } final int ans = Integer . MAX_VALUE ; for ( int i = 2 ; i <= LIMIT ; i ++ ) { ans = Integer . MAX_VALUE ; } return String . valueOf ( ans ) ; }
public static void main ( String [ ] args ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int MOD = 10 * 9 + 7 ; int [ ] fact = new int [ N + 1 ] , factInv = new int [ N + 1 ] , inv = new int [ N + 1 ] ; { int [ ] a = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) a [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i % MOD ; factInv [ N ] = Math . pow ( fact [ N ] , MOD - 2 , MOD ) ; for ( int i = N - 1 ; i > 0 ; i -- ) factInv [ i ] = factInv [ i + 1 ] * ( i + 1 ) % MOD ; for ( int i = 1 ; i <= N ; i ++ ) inv [ i ] = factInv [ i ] * fact [ i - 1 ] % MOD ; int [ ] b = new int [ N + 1 ] , s = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) s [ i ] = ( s [ i - 1 ] + inv [ i ] ) % MOD ; for ( int i = 0 ; i < N ; i ++ ) b [ i ] = ( s [ i + 1 ] + s [ N - i ] - 1 ) % MOD ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) ans = ( ans + a [ i ] * b [ i ] ) % MOD ; ans = ans * fact [ N ] % MOD ; System . out . println ( ans ) ; } if ( getClass ( ) . isClassPresent ( Main . class ) ) { Main . main ( args ) ; } }
static final class Queue < Integer > FACTORY = new Queue < Integer > ( ) { private final List < Integer > items = new ArrayList < Integer > ( ) ; public boolean isEmpty ( ) { return items . isEmpty ( ) ; } public void add ( Integer item ) { items . add ( item ) ; } public Integer pop ( ) { return items . remove ( 0 ) ; } public Integer front ( ) { return items . get ( 0 ) ; } public void printQueue ( ) { for ( Integer i : items ) { System . out . print ( i + " ▁ " ) ; } System . out . println ( ) ; } }
public static int findDiff ( int [ ] arr , int n ) { int MAX = 1000000 ; boolean [ ] prime = new boolean [ MAX + 1 ] ; { prime [ 1 ] = false ; int p = 2 ; int c = 0 ; while ( ( p * p <= MAX ) && ( c < MAX ) ) { c ++ ; if ( ( prime [ p ] = true ) && ( prime [ p ] = false ) ) { for ( int i = p * 2 ; i <= MAX ; i += p ) { prime [ i ] = false ; } } p ++ ; } } int res ; int min = MAX + 2 ; int max = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( prime [ arr [ i ] ] = true ) && ( arr [ i ] == true ) ) { if ( ( arr [ i ] > max ) && ( arr [ i ] > arr [ i ] ) ) max = arr [ i ] ; if ( ( arr [ i ] < min ) && ( arr [ i ] < arr [ i ] ) ) min = arr [ i ] ; } } return ( max == - 1 ) ? - 1 : ( max - min ) ; }
public static int find ( int x , int [ ] parArr ) { if ( parArr [ x ] == x ) { return x ; } int root = find ( parArr [ x ] , parArr ) ; parArr [ x ] = root ; return root ; } while ( true ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == 0 ) break ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] edges = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; int d = Integer . parseInt ( input . nextLine ( ) ) ; edges [ i ] = new int [ ] { d / 100 - 1 , a , b } ; } Arrays . sort ( edges ) ; parArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int d = i ; int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; int parA = find ( a , parArr ) ; int parB = find ( b , parArr ) ; if ( parA != parB ) { parArr [ parA ] = parB ; ans += d ; } } System . out . println ( ans ) ; }
public static int [ ] li ( ) { int ind = 0 ; for ( int i = 1 ; i <= 371 ; i ++ ) { int [ ] temp = new int [ 3 ] ; int p = i , q = i ; int count = 0 ; while ( p != 0 ) { p /= 10 ; count ++ ; } if ( count == 1 ) { li [ ind ++ ] = i ; } if ( count == 2 ) { temp = new int [ 3 ] ; while ( q != 0 ) { int x = q % 10 ; q /= 10 ; temp [ x ] = x ; } li = li + temp [ 0 ] ; } } li [ ind ] = i ; li [ ind ] = i ; int n = Integer . parseInt ( input ) ; System . out . println ( li [ n - 1 ] ) ; return li ; }
static int distinctSubstring ( String P , int N ) { Map < String , Integer > S = Maps . newHashMap ( ) ; for ( int i = 0 ; i < N ; i ++ ) { boolean freq [ ] = new boolean [ 26 ] ; String s = " " ; for ( int j = i ; j < N ; j ++ ) { int pos = ( P . charAt ( j ) - ' a ' ) ; if ( ( freq [ pos ] == true ) && ( pos < N ) ) break ; freq [ pos ] = true ; s += P . charAt ( j ) ; S . put ( s , 1 ) ; } } return S . size ( ) ; }
public static int n ( ) { int k = Integer . parseInt ( input . nextLine ( ) ) ; int a = Integer . parseInt ( input . nextLine ( ) ) ; int ans ; if ( ( ( n - k ) % ( k - 1 ) ) == 0 ) ans = ( n - k ) / ( k - 1 ) + 1 ; return ans ; }
static final long INT_MAX = System . maxsize ; final long INT_MIN = - ( System . maxsize - 1 ) ; { long minDiff = INT_MAX ; for ( int i = 1 << n ; i < n ; i ++ ) { int cnt = Integer . numberOfLeadingZeros ( i ) ; if ( ( cnt == n - k ) && ( cnt > 0 ) ) { int [ ] temp = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i & ( 1 << j ) ) != 0 ) && ( j < n ) ) { temp [ j ] = a [ j ] ; } } long maxDiff = INT_MIN ; for ( int j = 0 ; j < temp . length - 1 ; j ++ ) { maxDiff = Math . max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ; } minDiff = Math . min ( minDiff , maxDiff ) ; } } if ( className . equals ( " java . util . Arrays " ) ) { int n = 5 ; int k = 2 ; int [ ] a = { 3 , 7 , 8 , 10 , 14 } ; System . out . println ( minimumAdjacentDifference ( a , n , k ) ) ; } return minDiff ; }
public static void difference ( int arr [ ] , int n ) { int largest = arr [ 0 ] ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( ( largest < arr [ i ] ) && ( arr [ i ] > largest ) ) { largest = arr [ i ] ; } } for ( ; i < n ; i ++ ) { arr [ i ] = largest - arr [ i ] ; } for ( ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } if ( className . equals ( " java . util . Vector " ) ) { arr = new int [ ] { 10 , 5 , 9 , 3 , 2 } ; n = arr . length ; difference ( arr , n ) ; }
static int countKdivPairs ( int [ ] A , int n , int K ) { int [ ] freq = new int [ K ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ A [ i ] % K ] ++ ; } long sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ; int i = 1 ; while ( ( i <= K / 2 ) && ( i != ( K - i ) ) ) { sum += freq [ i ] * freq [ K - i ] ; i ++ ; } if ( ( K % 2 ) == 0 ) { sum += ( freq [ K / 2 ] * ( freq [ K / 2 ] - 1 ) / 2 ) ; } return ( int ) sum ; }
public static String f ( String a ) { for ( char x = ' b ' ; x <= ' w ' ; x ++ ) { if ( a . substring ( 0 , 4 ) . indexOf ( x ) == 3 || a . substring ( 2 , 7 ) . indexOf ( x ) == 3 ) return x ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( a . substring ( i * 3 , i * 3 + 3 ) . indexOf ( x ) == 3 || a . substring ( i , i ) . indexOf ( x ) == 3 ) return x ; } return " NA " ; } while ( true ) { a = new String ( input . nextLine ( ) ) ; if ( a . length ( ) == 1 ) break ; a += new String ( input . nextLine ( ) ) + new String ( input . nextLine ( ) ) ; System . out . println ( f ( a ) ) ; } }
static int maxOnesIndex ( int [ ] arr , int n ) { int maxCount = 0 ; int maxIndex = 0 ; int prevZero = - 1 ; int prevPrevZero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( ( arr [ curr ] == 0 ) && ( arr [ curr ] > 0 ) ) { if ( ( curr - prevPrevZero ) > maxCount ) { maxCount = curr - prevPrevZero ; maxIndex = prevZero ; } prevPrevZero = prevZero ; prevZero = curr ; } } if ( ( n - prevPrevZero ) > maxCount ) { maxIndex = prevZero ; } return maxIndex ; }
public static int minimumX ( int n , int k ) { int ans = 10 * 18 ; for ( int i = k - 1 ; i > 0 ; i -- ) { if ( n % i == 0 ) ans = i + ( n / i ) * k ; } return ans ; }
public static int moduloMultiplication ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; while ( ( b != 0 ) ) { if ( ( b & 1 ) != 0 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; }
private static int searchNode ( int i , boolean [ ] [ ] u , boolean [ ] [ ] path ) { int r = 1 ; u [ i ] = true ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( path [ i ] [ j ] && ( ! u [ j ] ) ) r += searchNode ( j , u , path ) ; } return r ; int n ; while ( ( n = input . nextInt ( ) ) != - 1 ) { int [ ] strs = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) strs [ i ] = Lists . newArrayList ( ) ; for ( int j = 0 ; j < 26 ; j ++ ) strs [ i ] [ j ] = Lists . newArrayList ( ) ; int [ ] ss = new int [ 26 ] , [ ] ee = new int [ 26 ] ; path = new int [ 27 ] ; u [ 0 ] = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { int s = strs [ j ] ; int e = strs [ j ] ; ss [ ( s - ' a ' ) ] ++ ; ee [ ( e - ' a ' ) ] ++ ; path [ ( s - ' a ' ) ] [ ( e - ' a ' ) ] ++ ; } if ( Arrays . equals ( ss , ee ) ) { System . out . println ( " NG " ) ; continue ; } System . out . println ( Arrays . equals ( ss , ee ) ? 1 : 0 ) ; } return 0 ; }
public static void print ( int n ) { int [ ] a = Integer . parseInt ( input ( ) ) ; int ma = max ( a ) ; int mai = a . indexOf ( ma ) ; int mi = min ( a ) ; int mii = a . indexOf ( mi ) ; ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; if ( Math . abs ( ma ) >= Math . abs ( mi ) ) { for ( int i = 0 ; i < n ; i ++ ) { a [ i ] += ma ; ans . add ( new Integer ( mai + 1 ) ) ; } for ( int i = 1 ; i < n ; i ++ ) { a [ i ] += a [ i - 1 ] ; ans . add ( new Integer ( i ) ) ; } } else { for ( int i = 0 ; i < n ; i ++ ) ans . add ( new Integer ( i + 2 ) ) ; } }
static boolean checkPalindrome ( String string ) { int length = string . length ( ) ; length -- ; for ( int i = 0 ; i < length ; i ++ ) { if ( string . charAt ( i ) != string . charAt ( length ) ) { return false ; } length -- ; } /* ▁ print ▁ solution ▁ */ for ( int i = 0 ; i < partitions . length ; i ++ ) { for ( int j = 0 ; j < partitions [ i ] . length ; j ++ ) { System . out . print ( partitions [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } /* ▁ add ▁ strings ▁ */ Vector < String [ ] > v = new Vector < String [ ] > ( ) ; String [ ] s = new String [ length ] ; String [ ] temp = new String [ length ] ; int index = 0 ; int length = s . length ( ) ; String string = " " ; String [ ] current = temp . clone ( ) ; if ( index == 0 ) { temp = new String [ length ] ; } for ( int i = index ; i < length ; i ++ ) { string += s . charAt ( i ) ; if ( checkPalindrome ( string ) ) { temp [ index ] = string ; if ( i + 1 < length ) { /* ▁ add ▁ strings ▁ */ v . add ( temp ) ; } else { v . add ( temp ) ; } temp = current ; } } /* ▁ partition ▁ */ Vector < String [ ] > temp = new Vector < String [ ] > ( ) ; /* ▁ add ▁ strings ▁ */ v . add ( s ) ; /* ▁ print ▁ solution ▁ */ printSolution ( v ) ; }
static int MOD = 100000007 ; int dp ( int n , int k ) { if ( tbl [ n ] [ k ] != 0 ) return tbl [ n ] [ k ] ; int ans ; if ( ( k << 1 ) > n ) k = n - k ; if ( k == 0 ) ans = 1 ; else if ( k == 1 ) ans = n ; else ans = dp ( n - 1 , k ) + dp ( n - 1 , k - 1 ) ; tbl [ n ] [ k ] = ans % MOD ; return tbl [ n ] [ k ] ; } tbl = new int [ 1001 ] [ 1001 ] ; for ( int j = 0 ; j < 1001 ; j ++ ) tbl [ j ] [ 0 ] = 0 ; int k = 0 ; int r = Integer . parseInt ( input . nextLine ( ) ) , c = Integer . parseInt ( input . nextLine ( ) ) , a1 = Integer . parseInt ( input . nextLine ( ) ) , a2 = Integer . parseInt ( input . nextLine ( ) ) , b1 = Integer . parseInt ( input . nextLine ( ) ) , b2 = Integer . parseInt ( input . nextLine ( ) ) ; int dr = Math . abs ( a1 - b1 ) ; if ( dr > r - dr ) dr = r - dr ; if ( ( dr << 1 ) == r ) k ++ ; int dc = Math . abs ( a2 - b2 ) ; if ( dc > c - dc ) dc = c - dc ; if ( ( dc << 1 ) == c ) k ++ ; System . out . println ( ( dp ( dr + dc , Math . min ( dr , dc ) ) << k ) % MOD ) ; return ans ; }
@ GwtIncompatible ( " java . util . Arrays " ) static void findSubsequence ( int [ ] arr , int n , int k ) { int [ ] M = new int [ n ] ; for ( int i = 0 ; i <= n ; i ++ ) { M [ arr [ i ] ] ++ ; } int [ ] numCount = new int [ k + 1 ] ; for ( int p : M ) { if ( p <= k ) { int i = 1 ; while ( p * i <= k ) { numCount [ p * i ] += M [ p ] ; i ++ ; } } else { break ; } } int lcm = 0 , length = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { if ( numCount [ i ] > length ) { length = numCount [ i ] ; lcm = i ; } } if ( lcm == 0 ) { System . out . println ( - 1 ) ; } else { System . out . println ( " LCM ▁ = ▁ " + lcm + " , ▁ Length ▁ = ▁ " + length ) ; System . out . print ( " Indexes ▁ = ▁ " ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( lcm % arr [ i ] == 0 ) { System . out . print ( i + " ▁ " ) ; } } } if ( Class . isPrimitive ( ) ) { k = 14 ; arr = new int [ ] { 2 , 3 , 4 , 5 } ; n = arr . length ; findSubsequence ( arr , n , k ) ; } }
public static int countPairs ( int [ ] a , int [ ] b , int n , int m ) { int odd1 = 0 ; int even1 = 0 ; int odd2 = 0 ; int even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] % 2 ) == 1 ) { odd1 ++ ; } else { even1 ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( ( b [ i ] % 2 ) == 1 ) { odd2 ++ ; } else { even2 ++ ; } } int pairs = Math . min ( odd1 , odd2 ) + Math . min ( even1 , even2 ) ; return pairs ; }
public static int countPairs ( int [ ] a , int [ ] b , int n , int m ) { int odd1 = 0 ; int even1 = 0 ; int odd2 = 0 ; int even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] % 2 ) != 0 ) { odd1 ++ ; } else { even1 ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( ( b [ i ] % 2 ) != 0 ) { odd2 ++ ; } else { even2 ++ ; } } int pairs = ( Math . min ( odd1 , even2 ) + Math . min ( odd2 , even1 ) ) ; return pairs ; }
static int maxDiff ( int [ ] arr , int arrSize ) { int maxDiff = arr [ 1 ] - arr [ 0 ] ; int minElement = arr [ 0 ] ; for ( int i = 1 ; i < arrSize ; i ++ ) { if ( ( arr [ i ] - minElement ) > maxDiff ) { maxDiff = arr [ i ] - minElement ; } if ( ( arr [ i ] < minElement ) ) { minElement = arr [ i ] ; } } return maxDiff ; }
static int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < Math . min ( i , k ) + 1 ; j ++ ) { if ( ( j == 0 ) || ( j == i ) ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } } return C [ n ] [ k ] ; }
MAX = 26 ; int minAddition = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { freq [ ( int ) str1 . charAt ( i ) - ( int ) ' a ' ] ++ ; } int maxFreq = Collections . max ( freq ) ; minAddition = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( ( freq [ i ] > 0 ) && ( freq [ i ] < maxFreq ) ) { minAddition += Math . abs ( maxFreq - freq [ i ] ) ; } }
public static void print ( int n ) { int a = input . nextInt ( ) ; int b = input . nextInt ( ) ; int ans = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { ans = ans + Math . min ( 10 - Math . abs ( ( int ) a - b ) , Math . abs ( ( int ) a - b ) ) ; } System . out . println ( ans ) ; }
public static int [ ] MAX = 32 ; int [ ] pow2 = new int [ MAX ] ; boolean [ ] visited = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { visited [ i ] = true ; } int [ ] ans = new int [ MAX ] ; { int an = 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { pow2 [ i ] = an ; an *= 2 ; } } { int setBits = 0 ; while ( ( x = pow2 [ 0 ] ) != 0 ) { x = pow2 [ 0 ] & ( x - 1 ) ; setBits ++ ; } } { int point = 0 ; int value = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( ( visited [ i ] ) && ( point < n ) ) { continue ; } else { if ( ( num & 1 ) != 0 ) { value += ( 1 << i ) ; } num = num / 2 ; } } ans [ point ++ ] = value ; } { int n = 0 ; int countk = countSetBits ( k ) ; if ( ( pow2 [ countk ] < n ) && ( pow2 [ countk ] > n ) ) { System . out . println ( - 1 ) ; return null ; } int count = 0 ; for ( int i = 0 ; i < pow2 [ countk ] - 1 ; i ++ ) { add ( i ) ; count ++ ; if ( ( count == n ) && ( pow2 [ countk ] > n ) ) { break ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } } if ( __name__ == " main " ) { int n = 3 ; int k = 5 ; power2 ( ) ; solve ( n , k ) ; } return ans ; }
static final long [ ] getPrimes ( ) { return new long [ ] { Long . MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , MIN_VALUE , 0 , MIN_VALUE , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; }
public static void pratyush ( ) { for ( int i = 0 ; i < Integer . parseInt ( input . nextLine ( ) ) ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int r = Integer . parseInt ( input . nextLine ( ) ) ; int a = Math . min ( r , n - 1 ) ; int ans = ( int ) ( ( a * ( a + 1 ) ) / 2 ) ; if ( a != r ) ans ++ ; System . out . println ( ans ) ; } }
static final int [ ] findSubset ( int [ ] a , int n ) { final int MAX = 100001 ; final int [ ] isPrime = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { isPrime [ i ] = 0 ; } /* ▁ sieve ▁ */ for ( int p = 2 ; p < Math . ceil ( Math . sqrt ( MAX ) ) ; p ++ ) { if ( ( isPrime [ p ] == 0 ) ) { for ( int i = 2 * p ; i < MAX ; i += p ) { isPrime [ i ] = 1 ; } } } /* ▁ find ▁ subset ▁ */ int [ ] findSubset = new int [ n ] ; int cnt1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == 1 ) && ( isPrime [ a [ i ] + 1 ] == 0 ) ) { System . out . println ( cnt1 + 1 ) ; for ( int j = 0 ; j < cnt1 ; j ++ ) { System . out . print ( "1" ) ; } System . out . println ( a [ i ] ) ; return 0 ; } } return findSubset ; }
public static void print ( int n , int r , int t ) { int [ ] speed = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) speed [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] point = new int [ n ] ; int [ ] bottle = new int [ r ] ; for ( int i = 0 ; i < n ; i ++ ) { point [ i ] = ( point [ i ] + speed [ i ] ) % r ; bottle [ point [ i ] ] ++ ; } for ( int i = 0 ; i < t - 1 ; i ++ ) { int [ ] nums = new int [ r ] ; for ( int j = 0 ; j < n ; j ++ ) { bottle [ j ] -- ; point [ i ] = ( point [ i ] + speed [ i ] ) % r ; nums [ point [ i ] ] ++ ; } for ( int j = 0 ; j < r ; j ++ ) { if ( bottle [ j ] < nums [ j ] ) bottle [ j ] = nums [ j ] ; bottle [ j ] += nums [ j ] ; } } System . out . println ( Arrays . toString ( bottle ) ) ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( input . replace ( " Hoshino " , " Hoshina " ) ) ; } }
static int countRotations ( int arr [ ] , int low , int high ) { if ( ( high < low ) || ( arr [ high ] == 0 ) ) return 0 ; if ( ( high == low ) || ( arr [ high ] == 0 ) ) return low ; int mid = low + ( high - low ) / 2 ; int result = Integer . MIN_VALUE ; if ( ( result < high ) && ( arr [ mid + 1 ] < arr [ mid ] ) ) return ( result + 1 ) ; if ( ( result > low ) && ( arr [ mid ] < arr [ mid - 1 ] ) ) return mid ; return 0 ; }
static final void print ( String input ) { final int n = Integer . parseInt ( input ) , m = Integer . parseInt ( input ) ; int i = 0 ; do { if ( i + 1 > m ) { ans = m ; break ; } m -= i + 1 ; i ++ ; i %= n ; } while ( true ) ; }
public static boolean modularSum ( int arr [ ] , int n , int m ) { if ( ( n > m ) && ( arr [ n ] == 0 ) ) return true ; boolean [ ] DP = new boolean [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { DP [ i ] = false ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( DP [ 0 ] ) && ( arr [ i ] == 0 ) ) return true ; boolean [ ] temp = new boolean [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { temp [ j ] = false ; } for ( int j = 0 ; j < m ; j ++ ) { if ( ( DP [ j ] ) && ( arr [ j ] == 1 ) ) DP [ j ] = true ; } DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
public static void main ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] a = list ( Integer . parseInt ( input ) ) ; int q = Integer . parseInt ( input ) ; for ( int i = 0 ; i < q ; i ++ ) { int b = Integer . parseInt ( input ) ; int e = Integer . parseInt ( input ) ; int k = Integer . parseInt ( input ) ; System . out . println ( a [ b ] + " ▁ " + e + " ▁ " + k ) ; } }
public static int N = Integer . parseInt ( input ) { int x = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] A = list ( Integer . parseInt ( input . nextLine ( ) ) ) ; int INF = ( 1 << 42 ) - 1 ; int [ ] [ ] cum = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j ++ ) { cum [ i ] [ j ] = Math . min ( cum [ i ] [ j - 1 ] , A [ j ] ) ; } } int ans = INF ; for ( int k = 0 ; k < N ; k ++ ) { int score = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( j - k >= 0 ) { score += cum [ j - k ] [ j ] ; } else { score += Math . min ( cum [ 0 ] [ j ] , cum [ ( j - k ) % N ] [ N ] - 1 ] ) ; } } ans = Math . min ( ans , k * x + score ) ; } System . out . println ( ans ) ; return ans ; }
public static void main ( String input ) { int d = Integer . parseInt ( input ) ; int w = Integer . parseInt ( input ) ; if ( d + w == 0 ) break ; List < List < Integer > > pond = new ArrayList < > ( ) ; for ( int i = 0 ; i < d ; i ++ ) pond . add ( Collections . singletonList ( Integer . parseInt ( input ) ) ) ; int ans = 0 ; for ( int left = 0 ; left < w - 1 ; left ++ ) { for ( int right = w - 1 ; right > left + 1 ; right -- ) { for ( int top = 0 ; top < d - 1 ; top ++ ) { for ( int under = d - 1 ; under > top + 1 ; under -- ) { int outh = 10 ; outh = Math . min ( outh , Math . min ( pond . get ( top ) , left ) ) ; outh = Math . min ( outh , Math . min ( pond . get ( under ) , left ) ) ; List < Integer > zpond = Lists . newArrayList ( ) ; for ( int i = 0 ; i < zpond . size ( ) ; i ++ ) { zpond . set ( i , pond . get ( i ) ) ; } outh = Math . min ( outh , Math . min ( zpond . get ( left ) , top ) ) ; outh = Math . min ( outh , Math . min ( zpond . get ( right ) , top ) ) ; int pondh = 0 ; for ( int i = top + 1 ; i < under ; i ++ ) { pondh = Math . max ( pondh , Math . max ( pond . get ( i ) , left + 1 , right ) ) ; } if ( pondh < outh ) { int cap = outh * ( under - top - 1 ) * ( right - left - 1 ) - Integer . valueOf ( Integer . parseInt ( pond . get ( i ) ) ) ; ans = Math . max ( cap , ans ) ; } } } } } System . out . println ( ans ) ; }
public static int num ( String input , int k ) { int [ ] arr = new int [ input . length ( ) ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = Integer . parseInt ( input ) ; } HashSet < Integer > different = new HashSet < Integer > ( ) ; int temp = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] % k != 0 ) || ! different . contains ( arr [ i ] / k ) ) different . add ( arr [ i ] ) ; temp = Math . max ( different . size ( ) , temp ) ; } return temp ; }
public static int sum ( int k , int n ) { int sum = ( Math . pow ( k , n + 1 ) - Math . pow ( k - 1 , n + 1 ) ) ; return sum ; }
public static int solve ( int i , boolean tight , int sumSoFar , int Sum , String number , int length ) { if ( i == length ) { if ( sumSoFar == Sum ) return 1 ; else return 0 ; } int ans = dp [ i ] [ tight ] [ sumSoFar ] ; if ( ans != - 1 ) return ans ; ans = 0 ; for ( int currdigit = 0 ; currdigit <= 10 ; currdigit ++ ) { String currdigitStr = String . valueOf ( currdigit ) ; if ( tight == 0 && currdigitStr . compareTo ( number . charAt ( i ) ) > 0 ) break ; boolean ntight = tight || currdigitStr . compareTo ( number . charAt ( i ) ) < 0 ; int nsumSoFar = sumSoFar + currdigit ; ans += solve ( i + 1 , ntight , nsumSoFar , Sum , number , length ) ; } if ( getClass ( ) . getName ( ) . equals ( " java . lang . String " ) ) { int count = 0 , Sum = 4 ; String number = "100" ; dp = new int [ 162 ] [ 2 ] [ 18 ] ; for ( int j = 0 ; j < 18 ; j ++ ) { for ( int k = 0 ; k < 18 ; k ++ ) { dp [ i ] [ j ] [ k ] = - 1 ; } } System . out . println ( solve ( 0 , 0 , 0 , Sum , number , number . length ( ) ) ) ; } return ans ; }
public static int total = 0 ; int num_cases = Integer . parseInt ( input . nextLine ( ) ) ; for ( int i = 0 ; i < num_cases ; i ++ ) { String line = input . nextLine ( ) ; if ( Integer . parseInt ( line ) >= 2 ) { total ++ ; } } return total ; }
public static < K > Node < K > newNode ( K key ) { Node < K > root ; Node < K > data ; Node < K > left ; Node < K > right ; Node < K > result ; int evenOddLevelDifference ( Node < K > root ) { if ( ( root = data . left ) == null ) return 0 ; Queue < Node < K > > q = new LinkedList < Node < K > > ( ) ; q . add ( root ) ; int level = 0 ; int evenSum = 0 ; int oddSum = 0 ; while ( ( level = q . size ( ) ) > 0 ) { int size = q . size ( ) ; level ++ ; while ( ( size > 0 ) && ( level < size ) ) { Node < K > temp = q . get ( 0 ) ; q . remove ( 0 ) ; if ( ( level % 2 ) == 0 ) { evenSum += temp . data ; } else { oddSum += temp . data ; } if ( ( temp = data . left ) != null ) q . add ( temp . left ) ; if ( ( temp = data . right ) != null ) q . add ( temp . right ) ; size -- ; } } return ( oddSum - evenSum ) ; } if ( Class . isPrimitive ) { root = new Node < K > ( 5 ) ; root . left = new Node < K > ( 2 ) ; root . right = new Node < K > ( 6 ) ; root . left . left = new Node < K > ( 1 ) ; root . left . right = new Node < K > ( 4 ) ; root . left . right . left = new Node < K > ( 3 ) ; root . right . right = new Node < K > ( 8 ) ; root . right . right . right = new Node < K > ( 9 ) ; root . right . right . left = new Node < K > ( 7 ) ; result = evenOddLevelDifference ( root ) ; System . out . println ( " Difference ▁ between ▁ sums ▁ is " + result ) ; } return null ; }
static int countSubarrays ( int [ ] a , int n , int x ) { int count = 0 ; int number = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] > x ) && ( a [ i ] > x ) ) { count ++ ; } else { number += ( count ) * ( count + 1 ) / 2 ; count = 0 ; } } if ( ( count > 0 ) && ( a [ n - 1 ] > x ) ) { number += ( count ) * ( count + 1 ) / 2 ; } return ( int ) number ; }
static int minCost ( int [ ] arr , int n ) { int countEven = 0 ; int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 ) == 0 ) { countEven ++ ; } else { countOdd ++ ; } } return Math . min ( countEven , countOdd ) ; }
static void printLastOccurrence ( int [ ] a , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( 7 ) ; for ( int i = 0 ; i < 7 ; i ++ ) { mp . put ( a [ i ] , i ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( mp . get ( a [ i ] ) == i ) && ( mp . get ( a [ i ] ) == i ) ) { System . out . print ( a [ i ] + " ▁ " ) ; } } if ( getClass ( ) . isAnnotationPresent ( Integer [ ] . class ) ) { int [ ] a = { 1 , 5 , 5 , 1 , 6 , 1 } ; n = a . length ; printLastOccurrence ( a , n ) ; } }
public static void print ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == 0 ) { break ; } List < Integer > s = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; } if ( max ( s ) < 2 ) { System . out . println ( " NA " ) ; } else { int t = s . stream ( ) . filter ( i -> i > 0 ) . count ( ) ; System . out . println ( n - t + 1 ) ; } }
static int countPaths ( int m , int n ) { if ( m == 1 || n == 1 ) { return 1 ; } return ( countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ) ; } if ( getClass ( ) . getName ( ) . equals ( " java . lang . Object " ) ) { n = 5 ; m = 5 ; System . out . println ( countPaths ( n , m ) ) ; }
static int sumOfAP ( int a , int d , int n ) { int sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
static final int countPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] ) { count ++ ; } } } return count ; }
static void coordinateCompression ( int arr [ ] , int n ) { Map < Integer , Integer > s = Maps . newHashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . put ( arr [ i ] , 1 ) ; } int index = 0 ; Map < Integer , Integer > mp = Maps . newHashMap ( ) ; for ( Iterator < Integer > itr = s . values ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { index ++ ; mp . put ( itr . next ( ) , index ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = mp . get ( arr [ i ] ) ; } /* ▁ query ▁ bit ▁ */ int ans = 0 ; while ( ( index > 0 ) && ( ans == arr [ index ] ) ) { ans = Math . max ( ans , arr [ index ] ) ; index -= index & ( - index ) ; } /* ▁ update ▁ bit ▁ */ int x = query ( BIT , index - 1 , n ) ; int value = x + 1 ; while ( ( index <= n ) && ( value <= arr [ index ] ) ) { BIT [ index ] = 0 ; value += index & ( - index ) ; } /* ▁ find ▁ LISLength ▁ */ arr = 6 ; arr = 5 ; arr = 1 ; arr = 2 ; arr = 4 ; arr = 8 ; arr = 7 ; ans = findLISLength ( arr , n ) ; System . out . println ( ans ) ; }
public static void print ( String input ) { int t = Integer . parseInt ( input ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( input ) ; int [ ] [ ] a = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { a [ j ] = new int [ n ] ; } for ( int j = 0 ; j < n ; j ++ ) { a [ j ] = new int [ n ] ; } boolean ans = false ; for ( int j = 0 ; j < 5 ; j ++ ) { for ( int k = 0 ; k < 5 ; k ++ ) { if ( k != j ) { int cnt1 = 0 ; int cnt2 = 0 ; int cntno = 0 ; for ( int z = 0 ; z < n ; z ++ ) { if ( a [ z ] [ j ] == 1 ) cnt1 ++ ; if ( a [ z ] [ k ] == 1 ) cnt2 ++ ; if ( a [ z ] [ j ] == 0 && a [ z ] [ k ] == 0 ) cntno ++ ; } if ( cnt1 >= n / 2 && cnt2 >= n / 2 && cntno == 0 ) { ans = true ; } } } } if ( ans ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public static String compute ( ) { final int BASE = 10 ; final int DIGITS = 20 ; final int CONSECUTIVE = 3 ; final int MAX_SUM = 9 ; final int innerlen = BASE * CONSECUTIVE ; final int [ ] [ ] ways = new int [ innerlen ] [ ] ; ways [ 0 ] = new int [ innerlen - 1 ] ; for ( int digits = 1 ; digits <= DIGITS ; digits ++ ) { int [ ] newrow = new int [ innerlen ] ; for ( int prefix = 0 ; prefix < innerlen ; prefix ++ ) { int sum = 0 ; if ( digSum ( prefix ) <= MAX_SUM ) { for ( int nextdigit = 0 ; nextdigit < BASE ; nextdigit ++ ) { sum += ways [ digits - 1 ] [ prefix % ( BASE * ( CONSECUTIVE - 1 ) ) * BASE + nextdigit ] ; } } newrow [ digits - 1 ] = sum ; } ways [ digits - 1 ] [ 0 ] = newrow ; } final int ans = ways [ ways . length - 1 ] [ 0 ] - ways [ ways . length - 2 ] [ 0 ] ; return String . valueOf ( ans ) ; }
{ arr = new String [ ] { input , input , input , input , input } ; boolean exit = false ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( exit ) { break ; } for ( int j = 0 ; j < 3 ; j ++ ) { int countw = 0 ; int countb = 0 ; if ( arr [ i ] [ j ] == ' # ' ) { countb ++ ; } else { countw ++ ; } if ( arr [ i + 1 ] [ j ] == ' # ' ) { countb ++ ; } else { countw ++ ; } if ( arr [ i ] [ j + 1 ] == ' # ' ) { countb ++ ; } else { countw ++ ; } if ( arr [ i + 1 ] [ j + 1 ] == ' # ' ) { countb ++ ; } else { countw ++ ; } if ( countw >= 3 || countb >= 3 ) { System . out . println ( " YES " ) ; exit = true ; break ; } } if ( ! exit ) { System . out . println ( " NO " ) ; } }
public static Solution Solution = new Solution ( ) { public boolean isToeplitzMatrix ( int [ ] [ ] matrix ) { for ( int r = 0 ; r < matrix . length - 1 ; r ++ ) { for ( int c = 0 ; c < matrix [ 0 ] . length - 1 ; c ++ ) { if ( matrix [ r ] [ c ] != matrix [ r + 1 ] [ c + 1 ] ) { return false ; } } } return true ; } }
static final String compute ( ) { final int LIMIT = 10 * 9 ; long ans = 0 ; for ( int s = 1 ; s < 2 ; s ++ ) { if ( s * s > ( LIMIT + 1 ) / 3 ) break ; for ( int t = s - 2 ; t > 0 ; t -= 2 ) { if ( MathUtils . gcd ( s , t ) == 1 ) { int a = s * t ; int b = ( s * s - t * t ) / 2 ; int c = ( s * s + t * t ) / 2 ; if ( a * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) ans += p ; } if ( a * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) ans += p ; } if ( b * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) ans += p ; } if ( b * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) ans += p ; } } } } return Long . toString ( ans ) ; }
public static void loop ( ) { int n , t , L , b ; int [ ] loses ; int [ ] backs ; int [ ] stops ; int i , j ; int i , j ; int i ; int l = ( Integer . parseInt ( input . readLine ( ) ) ) ; while ( ( i = in . nextInt ( ) ) != - 1 ) { n = ( Integer . parseInt ( input . readLine ( ) ) ) ; t = ( Integer . parseInt ( input . readLine ( ) ) ) ; L = ( Integer . parseInt ( input . readLine ( ) ) ) ; b = ( Integer . parseInt ( input . readLine ( ) ) ) ; if ( ( n = in . nextInt ( ) ) == 0 ) break ; loses = new int [ L ] ; backs = new int [ b ] ; for ( i = 0 ; i < b ; i ++ ) loses [ i ] = Integer . parseInt ( input . readLine ( ) ) ; backs = new int [ b ] ; for ( i = 0 ; i < 3 ; i ++ ) backs [ i ] = Integer . parseInt ( input . readLine ( ) ) ; dp = new float [ n + 1 ] [ n ] ; dp [ 0 ] [ n ] = 0.0f ; dp [ 1 ] [ n ] = 1.0f ; stops = new int [ n + 1 ] ; for ( i = 0 ; i < n ; i ++ ) stops [ i ] = i + 1 ; for ( i = 0 ; i < t ; i ++ ) for ( j = 0 ; j < n ; j ++ ) dp [ i % 3 ] [ j ] = loses [ i ] ? dp [ ( i + 2 ) % 3 ] [ d ] : backs [ i ] ? dp [ ( i + 1 ) % 3 ] [ 0 ] : dp [ ( i + 1 ) % 3 ] [ d ] ; for ( j = 0 ; j < n ; j ++ ) dp [ j ] [ j ] = stops [ j ] + 1 ; System . out . println ( dp [ 0 ] [ 0 ] + " ▁ " + dp [ j ] ) ; } }
public static void main ( String input ) { for ( int i = 0 ; i < Integer . parseInt ( input ) ; i ++ ) { int n = Integer . parseInt ( input ) ; int [ ] arr = copyOf ( Ints . toByteArray ( input ) ) ; int odCount = 0 , evenCount = 0 , odSum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & 1 ) != 0 ) { odSum += arr [ j ] ; odCount ++ ; } else { evenCount ++ ; } } if ( odSum % 2 != 0 ) { System . out . println ( " YES " ) ; } else if ( odCount > 0 && evenCount > 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
static final int minInsertions ( int [ ] H , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; if ( ( diff <= K ) ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; } return inser ; }
static int countWords ( String str , int l ) { int count = 1 ; if ( ( l == 1 ) && ( str . charAt ( 0 ) == str . charAt ( 1 ) ) ) { return count ; } if ( ( str . charAt ( 0 ) == str . charAt ( 1 ) ) && ( str . charAt ( 0 ) == str . charAt ( 1 ) ) ) { count *= 1 ; } else { count *= 2 ; } for ( int j = 1 ; j < l - 1 ; j ++ ) { if ( ( str . charAt ( j ) == str . charAt ( j - 1 ) ) && ( str . charAt ( j ) == str . charAt ( j + 1 ) ) ) { count *= 1 ; } else if ( ( str . charAt ( j ) == str . charAt ( j - 1 ) ) || ( str . charAt ( j ) == str . charAt ( j + 1 ) ) || ( str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) ) { count *= 2 ; } else { count *= 3 ; } } if ( ( str . charAt ( l - 1 ) == str . charAt ( l - 2 ) ) ) { count *= 1 ; } else { count *= 2 ; } return count ; }
public static int t = Integer . parseInt ( input ) { List < Integer > l = new ArrayList < Integer > ( Collections . nCopies ( t , Integer . parseInt ( input ) ) ) ; int s = Integer . parseInt ( input . nextLine ( ) ) ; if ( s % 2 == 0 ) { System . out . println ( s ) ; } else { for ( int i = 0 ; i < l . size ( ) ; i ++ ) { if ( l . get ( i ) % 2 != 0 ) { System . out . println ( s - l . get ( i ) ) ; break ; } } } return s ; }
static int [ ] getPerfectSquares ( int n ) { int [ ] perfectSquares = new int [ n ] ; int current = 1 ; int i = 1 ; while ( ( current <= n ) && ( current <= n ) ) { perfectSquares [ i ] = current ; i ++ ; current = ( int ) Math . pow ( i , 2 ) ; } return perfectSquares ; /* ▁ max ▁ pair ▁ sum ▁ */ int n = arr . length ; int max = 0 ; int secondMax = 0 ; if ( ( max > n ) && ( secondMax > n ) ) { max = n ; secondMax = n ; } else { max = n ; secondMax = n ; } for ( int i = 2 ; i < n ; i ++ ) { if ( ( max > n ) && ( secondMax > n ) ) { secondMax = max ; max = n ; } else if ( ( max > secondMax ) && ( secondMax > n ) ) { secondMax = n ; } } /* ▁ count ▁ pairs ▁ */ int count = 0 ; for ( int i = 0 ; i < perfectSquares . length ; i ++ ) { int temp = perfectSquares [ i ] - n ; if ( ( temp > n ) && ( nums [ temp ] >= n ) ) { count ++ ; } } /* ▁ count ▁ pairs ▁ */ int [ ] arr = { 2 , 3 , 6 , 9 , 10 , 20 } ; System . out . println ( countPairs ( arr ) ) ; return arr ; }
static int findHypotenuse ( int side1 , int side2 ) { int h = ( ( ( side1 * side1 ) + ( side2 * side2 ) ) * ( 1 / 2 ) ) ; return h ; }
static void printTwoOdd ( int [ ] arr , int size ) { int xor2 = arr [ 0 ] ; int setBitNo = 0 ; int n = size - 2 ; int x = 0 , y = 0 ; for ( int i = 1 ; i < size ; i ++ ) { xor2 = xor2 ^ arr [ i ] ; } setBitNo = xor2 & ~ ( xor2 - 1 ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & setBitNo ) != 0 ) { x = x ^ arr [ i ] ; } else { y = y ^ arr [ i ] ; } } }
public static double solve ( int n , List < String > nums ) { int maxIndex = nums . indexOf ( max ( nums ) ) ; int minIndex = nums . indexOf ( min ( nums ) ) ; double ans = Double . parseDouble ( " INF " ) ; ans = Math . min ( ans , Math . max ( maxIndex , minIndex ) + 1 ) ; ans = Math . min ( ans , n - Math . min ( maxIndex , minIndex ) ) ; ans = Math . min ( ans , maxIndex + 1 + n - minIndex ) ; ans = Math . min ( ans , minIndex + 1 + n - maxIndex ) ; return ans ; int t = Integer . parseInt ( input ( ) ) ; for ( int T = 0 ; T < t ; T ++ ) { int n = Integer . parseInt ( input ( ) ) ; nums = Lists . newArrayList ( ) ; for ( String s : input ( ) . split ( " \\s + " ) ) { nums . add ( s ) ; } System . out . println ( solve ( n , nums ) ) ; } return ans ; }
static final String getScanner ( ) { final Scanner I = new Scanner ( System . in ) ; final int [ ] [ ] ints = new int [ 3 ] [ 3 ] ; final int [ ] [ ] ints = new int [ 3 ] [ 3 ] ; final int [ ] [ ] ints = new int [ 3 ] [ 3 ] ; final int [ ] [ ] ints = new int [ 3 ] [ 3 ] ; final int [ ] [ ] ints = new int [ 3 ] [ 3 ] ; final int [ ] [ ] ints = new int [ 3 ] [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] [ ] ints = new int [ 3 ] [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; final int [ ] ints = new int [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; ints [ i ] = ints [ i ] ; return new String ( ints ) ;
public static int kolvomest = Integer . parseInt ( input ) { int k = 0 ; String [ ] spisok = new String [ kolvomest ] ; for ( int stroka = 0 ; stroka < kolvomest ; stroka ++ ) { String ryad = input . nextLine ( ) ; if ( ryad . contains ( " OO " ) && k == 0 ) { k = 1 ; ryad = ryad . replace ( " OO " , " + + " , 1 ) ; } spisok [ stroka ] = ryad ; } if ( k == 1 ) { System . out . println ( " YES " ) ; for ( int stroka = 0 ; stroka < kolvomest ; stroka ++ ) { System . out . println ( spisok [ stroka ] ) ; } } else { System . out . println ( " NO " ) ; } return k ; }
static final int [ ] getHeads ( ) { class Node { int [ ] data ; Node ( int [ ] data ) { this . data = data ; this . next = null ; } } { Node ( Node head ) ; if ( ( head == null ) || ( head . next == null ) ) { return null ; } Node temp = head ; System . out . print ( temp . data + " - > " ) ; temp = temp . next ; while ( ( temp = temp . next ) != null ) { System . out . print ( temp . data + " - > " ) ; temp = temp . next ; } System . out . println ( head . data ) ; } { Node ( Node headRef , int k ) { Node head = headRef ; if ( ( head == null ) || ( head . next == null ) ) { return null ; } Node curr = head ; Node prev = null ; while ( true ) { if ( ( curr . next == head ) && ( curr == head ) ) { break ; } prList ( head ) ; for ( int i = 0 ; i < k ; i ++ ) { prev = curr ; curr = curr . next ; } if ( ( curr == head ) || ( curr == head ) ) { prev = head ; while ( ( prev . next != null ) && ( prev . next != null ) ) { prev = prev . next ; } head = curr . next ; prev . next = head ; headRef = head ; } else if ( ( curr . next == head ) || ( curr . next == head ) ) { prev . next = head ; } else { prev . next = curr . next ; } } } } { Node head = headRef ; Node temp = new Node ( x ) ; if ( ( head == null ) || ( temp . next == null ) ) { temp . next = temp ; headRef = temp ; return headRef ; } else { Node temp1 = head ; while ( ( temp1 = temp1 . next ) != null ) { temp1 = temp1 . next ; } temp1 . next = temp ; temp . next = head ; } } if ( getClass ( ) . isClass ( " java . lang . Object " ) ) { Node head = null ; head = insertNode ( head , 1 ) ; head = insertNode ( head , 2 ) ; head = insertNode ( head , 3 ) ; head = insertNode ( head , 4 ) ; head = insert
public static double steps ( double cur , double x , double n ) { if ( x == 0 ) { return Double . MAX_VALUE ; } else if ( x > 0 ) { return Math . abs ( ( n - cur ) / x ) ; } else { return Math . abs ( ( int ) ( ( cur - 1 ) / x ) ) ; } /* ▁ countSteps ( curx , ▁ cury , ▁ n , ▁ m , ▁ [ ] ▁ moves ) ▁ */ double count = 0 ; int k = moves . length ; for ( int i = 0 ; i <= k ; i ++ ) { double x = moves [ i ] [ 0 ] ; double y = moves [ i ] [ 1 ] ; double stepct = Math . min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; count += stepct ; curx += stepct * x ; cury += stepct * y ; } /* ▁ if ▁ ( getClass ( ) . getName ( ) . equals ( " java . lang . Object " ) ) ▁ { STRNEWLINE ▁ n = 4 ; STRNEWLINE ▁ m = 5 ; STRNEWLINE ▁ x = 1 ; STRNEWLINE ▁ y = 1 ; STRNEWLINE ▁ moves [ ] ▁ = ▁ { ▁ 1 , ▁ 1 } ; STRNEWLINE ▁ moves [ 0 ] ▁ = ▁ - 2 ; STRNEWLINE ▁ moves [ 1 ] ▁ = ▁ { ▁ 1 , ▁ 1 } ; STRNEWLINE ▁ moves [ 2 ] ▁ = ▁ { ▁ 0 , ▁ - 2 } ; STRNEWLINE ▁ System . out . println ( countSteps ( x , ▁ y , ▁ n , ▁ m , ▁ moves ) ) ; STRNEWLINE ▁ } */ return count ; }
public static int [ ] input ( ) { int [ ] n = input . split ( " ▁ " ) ; return n ; }
@ GwtIncompatible ( " java . util . Arrays " ) public static int cntSubArr ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int currGcd = 0 ; for ( int j = i ; j < n ; j ++ ) { currGcd = gcd ( currGcd , arr [ j ] ) ; ans += ( currGcd == 1 ) ? j : 1 ; } } return ans ; }
static boolean isVowel ( char c ) { if ( ( c == ' a ' ) || ( c == ' e ' ) || ( c == ' i ' ) || ( c == ' o ' ) || ( c == ' u ' ) ) { return true ; } return false ; }
static int minStepToDeleteString ( String str ) { int N = str . length ( ) ; int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; for ( int x = 0 ; x < N + 1 ; x ++ ) { dp [ x ] [ x ] = 0 ; } for ( int l = 1 ; l <= N ; l ++ ) { int i = 0 ; int j = l - 1 ; while ( j < N ) { if ( ( l == 1 ) && ( str . charAt ( i ) == str . charAt ( i + 1 ) ) ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( ( str . charAt ( i ) == str . charAt ( i + 1 ) ) && ( str . charAt ( i + 2 ) == str . charAt ( i + 2 ) ) ) { dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; } for ( int K = i + 2 ; K <= j ; K ++ ) { if ( ( str . charAt ( i ) == str . charAt ( K ) ) && ( str . charAt ( i + 1 ) == str . charAt ( i + 2 ) ) ) { dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } i ++ ; j ++ ; } } return dp [ 0 ] [ N - 1 ] ; }
public static void sieve ( ) { limit = 1000000 ; position = new int [ limit + 1 ] ; /* ▁ position [ 0 ] ▁ = ▁ - 1 ; STRNEWLINE ▁ position [ 1 ] ▁ = ▁ - 1 ; STRNEWLINE ▁ int ▁ pos ▁ = ▁ 0 ; STRNEWLINE ▁ for ▁ ( int ▁ i ▁ = ▁ 2 ; ▁ i ▁ < ▁ limit ; ▁ i + + ) ▁ { STRNEWLINE ▁ if ▁ ( ( position [ i ] ▁ = = ▁ 0 ) ▁ | | ▁ ( position [ i ] ▁ = = ▁ - 1 ) ) ▁ { STRNEWLINE ▁ pos ▁ + = ▁ 1 ; STRNEWLINE ▁ position [ i ] ▁ = ▁ pos ; STRNEWLINE ▁ for ▁ ( int ▁ j ▁ = ▁ i * 2 ; ▁ j ▁ < ▁ limit ; ▁ j + + ) ▁ { STRNEWLINE ▁ position [ j ] ▁ = ▁ - 1 ; STRNEWLINE ▁ } STRNEWLINE ▁ } STRNEWLINE ▁ } STRNEWLINE ▁ if ▁ ( Class . forName ( " org . apache . commons . lang . StaticJavaMethod " ) . isAssignableFrom ( Class . forName ( " org . apache . commons . lang . StaticJavaMethod " ) ) ) ▁ { STRNEWLINE ▁ sieve ( ) ; STRNEWLINE ▁ int ▁ n ▁ = ▁ 11 ; STRNEWLINE ▁ System . out . println ( position [ n ] ) ; STRNEWLINE ▁ } */ }
public static int getNumMonotone ( int ln ) { int [ ] [ ] DP = new int [ ln ] [ DP_s ] ; for ( int i = 0 ; i < ln ; i ++ ) { DP [ 0 ] [ i ] = i + 1 ; } for ( int i = 0 ; i < ln ; i ++ ) { DP [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < ln ; i ++ ) { for ( int j = 1 ; j < DP_s ; j ++ ) { DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; } } return DP [ ln - 1 ] [ DP_s - 1 ] ; }
public static int getNumMonotone ( int ln ) { int [ ] [ ] DP = new int [ ln ] [ DP_s ] ; for ( int i = 0 ; i < ln ; i ++ ) { DP [ 0 ] [ i ] = i + 1 ; } for ( int i = 0 ; i < ln ; i ++ ) { DP [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < ln ; i ++ ) { for ( int j = 1 ; j < DP_s ; j ++ ) { DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; } } return DP [ ln - 1 ] [ DP_s - 1 ] ; }
static int maxCost ( int [ ] a , int n , int l , int r ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . max ( mx , a [ i ] ) ; int [ ] count = new int [ mx + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int [ ] res = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { int k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
public static boolean test ( ) { int nrow = Integer . parseInt ( input . readLine ( ) ) ; int ncol = Integer . parseInt ( input . readLine ( ) ) ; int [ ] [ ] arr = new int [ nrow ] [ ncol ] ; long val = 100000000000 ; int lr = 0 , lc = 0 ; for ( int rowId = 0 ; rowId < nrow ; rowId ++ ) { String [ ] temp = new String [ input . readLine ( ) . split ( " ▁ " ) . length ] ; arr [ rowId ] = new int [ temp . length ] ; for ( int colId = 0 ; colId < ncol ; colId ++ ) { if ( temp [ colId ] . equals ( " R " ) ) { long temp2 = rowId + colId ; arr [ rowId ] [ colId ] = temp2 ; if ( temp2 < val ) { val = temp2 ; lr = rowId ; lc = colId ; } } else { arr [ rowId ] [ colId ] = 0 ; } } } for ( int i = 0 ; i < lr ; i ++ ) { int [ ] temp = arr [ i ] ; if ( max ( temp ) > 0 ) { return false ; } } for ( int i = 0 ; i < nrow ; i ++ ) { for ( int j = 0 ; j < lc ; j ++ ) { if ( arr [ i ] [ j ] > 0 ) { return false ; } } } return true ; int numTestCases = Integer . parseInt ( input . readLine ( ) ) ; for ( int test_case = 0 ; test_case < numTestCases ; test_case ++ ) { val = test ( ) ; if ( val > 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } return false ; }
static double findArea ( double r ) { double PI = 3.142 ; return PI * ( r * r ) ; }
public static void main ( String input , int n , int k ) { int [ ] s = new int [ n ] ; for ( int i = 0 ; i < s . length ; i ++ ) s [ i - 1 ] = 1 ; int [ ] [ ] e = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) e [ i ] = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { final int x = ( Integer . parseInt ( input ) - 1 ) ; final int y = ( Integer . parseInt ( input ) - 1 ) ; e [ x ] [ y ] = y ; e [ y ] [ x ] = x ; } int [ ] q = new int [ n ] ; int [ ] fa = new int [ n ] ; fa [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = q [ i ] ; for ( int y : e [ x ] ) { if ( fa [ y ] == x ) { int i = s [ y ] ; s [ x ] += i ; dp [ x ] += dp [ y ] + ( i > k ? k2 - i : i ) ; } } } System . out . println ( dp [ 0 ] ) ; }
public static int nthTerm ( int N ) { return ( Math . abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) ) ; }
static int getHeight ( int X ) { return ( 2 * X ) ; }
V = 4 ; int count = 0 ; int [ ] [ ] graph = { { 0 , 1 , 1 , 1 , } , { 0 , 0 , 0 , 1 , } , { 0 , 1 , 0 , 1 , } , { 0 , 0 , 0 , 1 , } , { 0 , 0 , 0 , 1 , } , { 0 , 0 , 0 , 0 } } ; int u = 0 ; int v = 3 ; int k = 2 ; System . out . println ( countwalks ( graph , u , v , k ) ) ; }
@ VisibleForTesting static int findDigits ( int n , int b ) { if ( ( n < 0 ) || ( n > b ) ) { return 0 ; } final double M_PI = 3.141592 ; final double M_E = 2.7182 ; if ( ( n <= 1 ) || ( n <= b ) ) { return 1 ; } double x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) ; return Math . floor ( x ) + 1 ; }
public static void Bit ( ) { int N ; int [ ] bit = new int [ N + 1 ] ; int x ; int w ; int ret ; { this . N = N ; this . bit = new int [ N + 1 ] ; } public void add ( int a , int w ) { x = a ; while ( x <= this . N ) { this . bit [ x ] += w ; x += x & - x ; } } public int sum ( int a ) { int ret = 0 ; x = a ; while ( x > 0 ) { ret += this . bit [ x ] ; x -= x & - x ; } return ret ; } public int rangeSum ( int x , int y ) { int ret1 = this . sum ( y ) ; int ret2 = this . sum ( x - 1 ) ; return ret1 - ret2 ; } }
public static int mod ( int mod ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; /* ▁ n ▁ > = ▁ ( n ▁ > > ▁ d ) ▁ & ▁ 1 ▁ */ int [ ] [ ] dp = new int [ 61 ] [ ] ; for ( int i = 0 ; i < dp . length ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ i ] [ 1 ] = 1 ; } for ( int d = 59 ; d >= 0 ; d -- ) { for ( int s = 0 ; s < 3 ; s ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { int s2 = Math . min ( 2 , 2 * s + nthBit ( d ) - k ) ; if ( s2 >= 0 ) { dp [ d ] [ s2 ] += dp [ d + 1 ] [ s ] ; } } } } int ans = Integer . valueOf ( dp [ 0 ] ) % mod ; System . out . println ( ans ) ; return ans ; }
@ functools . lru_cache ( maxsize = 1 << 10 ) public static int solve ( int p , int q , int a , int n ) { int num = p ; int dem = q ; int d = a ; int m = n ; int s = n ; if ( num == 0 ) { return 1 ; } if ( d == 0 ) { return 0 ; } if ( num * a / m < dem ) { return 0 ; } return Math . min ( num , dem ) ; }
public static String binaryConversion ( String s , int m ) { int temp ; while ( ( temp = m / 2 ) > 0 ) { s += temp ; m = m / 2 ; } /* ▁ find ▁ character ▁ */ s = " " ; s = binaryConversion ( s , m ) ; String s1 = " " ; for ( int x = 0 ; x < n ; x ++ ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == '1' ) { s1 += "10" ; } else { s1 += "01" ; } } s = s1 ; s1 = " " ; } int e = ( int ) s . charAt ( i ) ; int r = ( int ) '0' ; return e - r ; }
static int countSubSets ( int [ ] arr , int n ) { Set < Integer > us = new HashSet < > ( ) ; int evenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { us . add ( arr [ i ] ) ; } } evenCount = us . size ( ) ; return Math . pow ( 2 , evenCount ) - 1 ; }
public static int [ ] getFibonacci ( int MAX ) { int [ ] f = new int [ MAX ] ; int n ; if ( ( n = fib ( n ) ) == 0 ) { return 0 ; } if ( ( n == 1 ) || ( n == 2 ) ) { f [ n ] = 1 ; return f [ n ] ; } if ( ( f [ n ] = fib ( n ) ) == 0 ) { return f [ n ] ; } int k = ( n & 1 ) != 0 ? ( n + 1 ) / 2 : n / 2 ; if ( ( n & 1 ) != 0 ) { f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; } else { f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; } return f [ n ] ; }
static int findNumbers ( int n , int w ) { int x = 0 ; int sum = 0 ; if ( ( w >= 0 ) && ( w <= 8 ) ) { x = 9 - w ; } else if ( w >= - 9 ) { x = 10 + w ; } sum = Math . pow ( 10 , n - 2 ) ; return sum ; }
static int findKthChar ( String s , int k ) { int len1 = s . length ( ) ; int i = 0 ; int totalLen = 0 ; while ( ( i < len1 ) && ( s . charAt ( i ) == ' ▁ ' ) ) { totalLen ++ ; if ( ( totalLen == k ) && ( s . charAt ( i ) == ' ▁ ' ) ) { return s . charAt ( i ) ; } i ++ ; } else { int n = 0 ; while ( ( i < len1 ) && ( s . charAt ( i ) == ' ▁ ' ) ) { n = n * 10 + ( ( s . charAt ( i ) - '0' ) ) ; i ++ ; } int nextTotalLen = totalLen * n ; if ( ( k <= nextTotalLen ) && ( s . charAt ( i ) == ' ▁ ' ) ) { int pos = k % totalLen ; if ( ( pos == 0 ) && ( s . charAt ( i ) == ' ▁ ' ) ) { pos = totalLen ; } return findKthChar ( s , pos ) ; } else { totalLen = nextTotalLen ; } } if ( className . equals ( " java . lang . String " ) ) { s = " ab2c3" ; k = 5 ; System . out . println ( findKthChar ( s , k ) ) ; } return - 1 ; }
static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return ( int ) ( n * ( n + 1 ) / 2 ) ; }
