def main ( ) : NEW_LINE INDENT f = sys . stdin NEW_LINE pg = PrimeNumberGenerator ( ) NEW_LINE while True : NEW_LINE INDENT n = int ( f . readline ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if pg . is_prime ( n ) : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT begin = - 1 NEW_LINE end = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if pg . is_prime ( i ) : NEW_LINE INDENT begin = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n + 1 , 2000000 , - 1 ) : NEW_LINE INDENT if pg . is_prime ( i ) : NEW_LINE INDENT end = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( end - begin ) NEW_LINE DEDENT DEDENT class PrimeNumberGenerator : NEW_LINE INDENT def __init__ ( self , N ) : NEW_LINE INDENT self . N = 2000000 NEW_LINE DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . N == index NEW_LINE DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . N == index NEW_LINE DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . N == index NEW_LINE DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . N == index NEW_LINE DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . N == index NEW_LINE DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . N == index NEW_LINE DEDENT DEDENT class PrimeNumberGenerator ( object ) : NEW_LINE INDENT def __init__ ( self , N ) : NEW_LINE INDENT self . N = N NEW_LINE DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . N == index NEW_LINE DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . N == index NEW_LINE DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . N == index NEW_LINE DEDENT DEDENT class PrimeNumberGenerator ( object ) : NEW_LINE INDENT def __init__ ( self , N ) : NEW_LINE INDENT self . N = N NEW_LINE DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . N == index NEW_LINE DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . N == index NEW_LINE DEDENT DEDENT class PrimeNumberGenerator ( object ) : NEW_LINE INDENT def __init__ ( self , N ) : NEW_LINE INDENT self . N = N NEW_LINE DEDENT def is_prime ( self , index ) : NEW_LINE INDENT return self . N == index NEW_LINE DEDENT DEDENT DEDENT
def GFG ( str , freq , len ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE def count_freq ( str , freq , len ) : NEW_LINE INDENT for i in range ( len ) : NEW_LINE INDENT freq [ str [ i ] - ' a ' ] += 1 NEW_LINE DEDENT DEDENT can_make_palindrome ( freq , len ) NEW_LINE count_odd = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if freq [ i ] % 2 != 0 : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT if len % 2 == 0 : NEW_LINE INDENT if count_odd > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if count_odd != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def find_odd_and_remove_itr_freq ( freq ) : NEW_LINE INDENT odd_str = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if freq [ i ] % 2 != 0 : NEW_LINE INDENT freq [ i ] -= 1 NEW_LINE odd_str = odd_str + chr ( i + ' a ' ) NEW_LINE return odd_str NEW_LINE DEDENT DEDENT return odd_str NEW_LINE DEDENT def find_palindromic_string ( str ) : NEW_LINE INDENT len = len ( str ) NEW_LINE freq = [ 0 ] * MAX_CHAR NEW_LINE count_freq ( str , freq , len ) NEW_LINE if not can_make_palindrome ( freq , len ) : NEW_LINE INDENT return " No ▁ Palindromic ▁ String " NEW_LINE DEDENT odd_str = find_odd_and_remove_itr_freq ( freq ) NEW_LINE front_str , rear_str = " " , " ▁ " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT temp = " " NEW_LINE if freq [ i ] != 0 : NEW_LINE INDENT ch = chr ( i + ' a ' ) NEW_LINE for j in range ( 1 , freq [ i ] / 2 ) : NEW_LINE INDENT temp = temp + ch NEW_LINE DEDENT front_str = front_str + temp NEW_LINE rear_str = temp + rear_str NEW_LINE DEDENT DEDENT return ( front_str + odd_str + rear_str ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import doctest NEW_LINE import os NEW_LINE import numpy NEW_LINE import numpy . linalg NEW_LINE import numpy . random NEW_LINE import numpy . ma NEW_LINE q = numpy . random . randint ( 0 , 10 , size = ( 10 , 10 ) ) NEW_LINE for i in range ( q . size ) : NEW_LINE INDENT doctest . testmod ( numpy . linalg ) NEW_LINE DEDENT class CGL_2B ( numpy . ndarray ) : NEW_LINE INDENT seg_seg_dist = numpy . empty ( ( q . size , q . size ) ) NEW_LINE DEDENT def doIt ( self , l1 , l2 ) : NEW_LINE INDENT l1 = l1 . intersects_line ( l2 ) ; NEW_LINE l2 = l2 . intersects_line ( l1 ) ; NEW_LINE print ( " % .10f " % seg_seg_dist ( l1 , l2 ) ) NEW_LINE DEDENT def doIt ( self , l1 , l2 ) : NEW_LINE INDENT l1 = l1 . intersects_line ( l2 ) ; NEW_LINE l2 = l2 . intersects_line ( l1 ) ; NEW_LINE print ( " % .10f " % seg_seg_dist ( l1 , l2 ) ) NEW_LINE DEDENT def doIt ( self , l1 , l2 ) : NEW_LINE INDENT l1 = l1 . intersects_line ( l2 ) ; NEW_LINE l2 = l2 . intersects_line ( l1 ) ; NEW_LINE print ( " % .10f " % seg_seg_dist ( l1 , l2 ) ) NEW_LINE DEDENT DEDENT
def GFG ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 1 ] * 9 NEW_LINE result = 0 NEW_LINE mod_sum , continuous_zero = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( number [ i ] - '0' ) == 0 : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += ( number [ i ] - '0' ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE DEDENT return result NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if K == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = fast_pow ( N , K / 2 ) NEW_LINE if K % 2 == 0 : NEW_LINE INDENT return temp ** 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N * temp ** 2 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s = [ 0 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE for line in sys . stdin : NEW_LINE INDENT n = len ( line ) NEW_LINE a = [ ] NEW_LINE if n == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT while n -- : NEW_LINE INDENT m = len ( line ) NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT print ( ( a [ i ] ^ s [ m ] [ i ] ) + ( i == 6 and ' \n ' or ' ' ) ) NEW_LINE DEDENT a = s [ m ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX = 10000 NEW_LINE arr = Vector ( ) NEW_LINE SieveOfEratosthenes ( ) NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE for p in range ( 2 , MAX * 2 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT is_euclid = 1 NEW_LINE i = 0 NEW_LINE while product ( arr ) < n : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if product + 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE arr = Vector ( ) NEW_LINE prime = [ False ] * MAX NEW_LINE SieveOfEratosthenes ( ) NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , p * p < MAX ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT def is_primorial_prime ( n ) : NEW_LINE INDENT if not prime [ n ] : NEW_LINE INDENT return False NEW_LINE DEDENT product = 1 NEW_LINE i = 0 NEW_LINE while product < n : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if product + 1 == n or product - 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT def test_prime ( n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if is_primorial_prime ( n ) : NEW_LINE INDENT assert ' YES ' == str ( arr [ n ] ) NEW_LINE DEDENT else : NEW_LINE INDENT assert ' NO ' == str ( arr [ n ] ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( N , i ) : NEW_LINE INDENT if i > 10 : NEW_LINE INDENT return NEW_LINE DEDENT print ( N , i , " ▁ * ▁ " , N * i ) NEW_LINE return NEW_LINE DEDENT
def close_to_n_divisible_m ( n , m ) : NEW_LINE INDENT q = n // m NEW_LINE n1 = m * q NEW_LINE n2 = ( n * m ) or ( m * ( q + 1 ) ) NEW_LINE if abs ( n - n1 ) < abs ( n - n2 ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT
def GFG ( ang , n ) : NEW_LINE INDENT if ( ang * n ) > ( 180 * ( n - 2 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ang * n ) % 180 != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) / 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT
def GFG ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ ] NEW_LINE len = None NEW_LINE lps . append ( 0 ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == s [ len ( s ) ] : NEW_LINE INDENT len += 1 NEW_LINE lps . append ( len ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if len != None : NEW_LINE INDENT len = lps [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps . append ( 0 ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT min_ele = np . inf NEW_LINE max_ele = np . inf NEW_LINE min_index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < min_ele : NEW_LINE INDENT min_ele = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT flag1 = True NEW_LINE for i in range ( 1 , min_index + 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag1 = False NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = True NEW_LINE for i in range ( min_index + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag2 = False NEW_LINE break NEW_LINE DEDENT DEDENT if min_index == 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE return NEW_LINE DEDENT if flag1 and flag2 and ( arr [ n - 1 ] < arr [ min_index - 1 ] ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def pyiss_runapp ( app ) : NEW_LINE INDENT return app . runapp ( ' pyiss ' ) NEW_LINE DEDENT
def GFG ( num ) : NEW_LINE INDENT input = num NEW_LINE count = 0 NEW_LINE factor = [ ] NEW_LINE if num % 2 == 0 : NEW_LINE INDENT while num % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE num /= 2 NEW_LINE DEDENT factor . append ( count ) NEW_LINE DEDENT for i in range ( 3 , num * i <= num , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while num % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE num /= i NEW_LINE DEDENT if count > 0 : NEW_LINE INDENT factor . append ( count ) NEW_LINE DEDENT DEDENT if num > 1 : NEW_LINE INDENT factor . append ( 1 ) NEW_LINE DEDENT product = 1 NEW_LINE for i in range ( num + 1 ) : NEW_LINE INDENT if factor [ i ] > 0 : NEW_LINE INDENT product = product * factor [ i ] ** i NEW_LINE DEDENT DEDENT if product == input : NEW_LINE INDENT print ( " Power - isolated ▁ Integer " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Power - isolated ▁ Integer " ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s = sys . stdin . read ( ) NEW_LINE len = 0 NEW_LINE for c in s : NEW_LINE INDENT if len % 2 == 0 and c == ' A ' or len % 2 == 1 and c == ' Z ' : NEW_LINE INDENT len += 1 NEW_LINE DEDENT DEDENT len /= 2 NEW_LINE if len == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT s = ' AZ ' NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def test_r765a ( ) : NEW_LINE INDENT f = open ( ' r765a . txt ' , ' r ' ) NEW_LINE t = int ( f . readline ( ) ) NEW_LINE while t : NEW_LINE INDENT t = f . readline ( ) NEW_LINE n = int ( t ) NEW_LINE arr = [ ] NEW_LINE f = open ( ' r765a . txt ' , ' w ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( int ( f . readline ( ) ) ) NEW_LINE DEDENT solve ( arr ) NEW_LINE DEDENT class Diff ( object ) : NEW_LINE INDENT prev = None NEW_LINE DEDENT def solve ( arr ) : NEW_LINE INDENT max = - 1 NEW_LINE d = { } NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if d . has_key ( arr [ i ] ) : NEW_LINE INDENT diff = d [ arr [ i ] ] NEW_LINE prev = diff [ ' prev ' ] NEW_LINE count = prev + len ( arr [ i ] ) - i NEW_LINE if count > max : NEW_LINE INDENT max = count NEW_LINE DEDENT diff [ ' prev ' ] = i NEW_LINE DEDENT else : NEW_LINE INDENT diff = Diff ( prev = i ) NEW_LINE d [ arr [ i ] ] = diff NEW_LINE DEDENT DEDENT print ( max ) NEW_LINE DEDENT DEDENT
def GFG ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if len1 == 0 or len2 == 0 : NEW_LINE INDENT return '0' NEW_LINE DEDENT result = [ 0 ] * ( len1 + len2 ) NEW_LINE i_n1 = 0 NEW_LINE i_n2 = 0 NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = num1 [ i ] - '0' NEW_LINE i_n2 = 0 NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = num2 [ j ] - '0' NEW_LINE sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry NEW_LINE carry = sum / 10 NEW_LINE result [ i_n1 + i_n2 ] = sum % 10 NEW_LINE i_n2 += 1 NEW_LINE DEDENT if carry > 0 : NEW_LINE INDENT result [ i_n1 + i_n2 ] += carry NEW_LINE DEDENT i_n1 += 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while i >= 0 and result [ i ] == 0 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if i == - 1 : NEW_LINE INDENT return '0' NEW_LINE DEDENT s = ' ' NEW_LINE while i >= 0 : NEW_LINE INDENT s += ( result [ i ] ) NEW_LINE DEDENT return s NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE arr = [ ] NEW_LINE sum = 0 NEW_LINE sum1 = 0 NEW_LINE arr1 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( sys . argv [ i ] ) NEW_LINE sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr1 . append ( sys . argv [ i ] ) NEW_LINE sum1 += arr1 [ i ] NEW_LINE DEDENT if sum >= sum1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n , k = sys . argv [ 1 : ] NEW_LINE a = sys . argv [ 2 : ] NEW_LINE if k > n / 2 : NEW_LINE INDENT while k < n : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE k += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while k > 1 : NEW_LINE INDENT print ( " LEFT " ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT if k == 1 : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT print ( " PRINT ▁ " + a [ i ] ) NEW_LINE if ( i + 1 ) < len ( a ) : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( " PRINT ▁ " + a [ i ] ) NEW_LINE if ( i - 1 ) >= 0 : NEW_LINE INDENT print ( " LEFT " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def get_dist_sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT dp = [ False for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if dp [ i - 1 ] [ j ] == True : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( 0 , sum + 1 ) : NEW_LINE INDENT if dp [ n ] [ j ] == True : NEW_LINE INDENT print ( j , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( a , b ) : NEW_LINE INDENT c = a + ( ~ b + 1 ) NEW_LINE return c NEW_LINE DEDENT
def test_infinite_sequence ( ) : NEW_LINE INDENT f = BytesIO ( ) NEW_LINE n1 = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE n = int ( ( np . sqrt ( 1 + ( 8 * n1 ) ) - 1 ) / 2 ) NEW_LINE ans = n1 - ( ( ( n + 1 ) ** 2 ) / 2 ) NEW_LINE assert ( ans != 0 ) . all ( ) NEW_LINE DEDENT
def test_codeforces ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ codeforces ▁ for ▁ the ▁ code ▁ forces . STRNEWLINE ▁ """ NEW_LINE x = symbols ( ' x ' ) NEW_LINE n = symbols ( ' n ' ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE arr . append ( i - 1 ) NEW_LINE DEDENT lt = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i in arr : NEW_LINE INDENT lt = True NEW_LINE break NEW_LINE DEDENT DEDENT if lt : NEW_LINE INDENT assert ' YES ' in arr NEW_LINE DEDENT else : NEW_LINE INDENT assert ' NO ' in arr NEW_LINE DEDENT DEDENT
def GFG ( i , occurrences ) : NEW_LINE INDENT while i < len ( occurrences ) : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE FLIP = [ 0 , 1 , 5 , - 1 , - 1 , 2 , - 1 , - 1 , 8 , - 1 ] NEW_LINE stdin = sys . stdin NEW_LINE nC = sys . stdin . readline ( ) . count ( ' \n ' ) NEW_LINE for loop in range ( nC ) : NEW_LINE INDENT hr , min = stdin . readline ( ) . split ( ' : ' ) NEW_LINE tok = re . split ( ' [ : ] ' , stdin . readline ( ) ) NEW_LINE sHr = int ( tok [ 0 ] ) NEW_LINE sMin = int ( tok [ 1 ] ) NEW_LINE res = None NEW_LINE for i in range ( sHr * min + sMin , hr * min + 1 ) : NEW_LINE INDENT res = flip ( i , hr , min ) NEW_LINE if res : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not res : NEW_LINE INDENT res = [ 0 , 0 , 0 , 0 ] NEW_LINE DEDENT print ( ' % d % d : % d % d ' % ( res [ 0 ] , res [ 1 ] , res [ 2 ] , res [ 3 ] ) ) NEW_LINE DEDENT def flip ( val , hr , min ) : NEW_LINE INDENT thisHr = val // min NEW_LINE thisMin = val % min NEW_LINE disp = [ thisMin % 10 , thisMin // 10 , thisHr % 10 , thisHr // 10 ] NEW_LINE for disp in disp : NEW_LINE INDENT if FLIP [ disp ] == - 1 : NEW_LINE INDENT return None NEW_LINE DEDENT disp = FLIP [ disp ] NEW_LINE DEDENT newHr = 10 ** ( disp [ 0 ] ) + disp [ 1 ] NEW_LINE newMin = 10 ** ( disp [ 2 ] ) + disp [ 3 ] NEW_LINE if newHr >= hr or newMin >= min : NEW_LINE INDENT return None NEW_LINE DEDENT return thisHr // 10 , thisHr % 10 , thisMin // 10 , thisMin % 10 NEW_LINE DEDENT sys . stdin . close ( ) NEW_LINE DEDENT
def test_fastreader ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import doctest NEW_LINE import tempfile NEW_LINE import os NEW_LINE import re NEW_LINE import random NEW_LINE import string NEW_LINE import tempfile NEW_LINE import os NEW_LINE import random NEW_LINE import string NEW_LINE import tempfile NEW_LINE import random NEW_LINE import string NEW_LINE import re NEW_LINE import tempfile NEW_LINE import os NEW_LINE import random NEW_LINE import string NEW_LINE import re NEW_LINE import tempfile NEW_LINE import random NEW_LINE import string NEW_LINE import re NEW_LINE import tempfile NEW_LINE import os NEW_LINE import re NEW_LINE import string NEW_LINE import re NEW_LINE import tempfile NEW_LINE import random NEW_LINE import string NEW_LINE import re NEW_LINE import tempfile NEW_LINE import os NEW_LINE import tempfile NEW_LINE import re NEW_LINE import string NEW_LINE import re NEW_LINE import tempfile NEW_LINE import os NEW_LINE import re NEW_LINE import tempfile NEW_LINE import string NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import os NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import string NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import os NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import string NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import os NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import string NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import os NEW_LINE import re NEW_LINE import re NEW_LINE import string NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import os NEW_LINE import re NEW_LINE import re NEW_LINE import string NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import os NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import string NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE
def helloworld ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . _getframe ( 1 ) . f_back . f_code . co_name NEW_LINE while t . f_back . f_code . co_filename != ' _ _ main _ _ . py ' : NEW_LINE INDENT n = sys . _getframe ( 1 ) . f_back . f_code . co_filename NEW_LINE s = [ ] NEW_LINE if n == 1 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT while n : NEW_LINE INDENT ans = n & 1 NEW_LINE n = n >> 1 NEW_LINE if ans == 1 : NEW_LINE INDENT s . insert ( 0 , 1 ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT s . insert ( 0 , 0 ) NEW_LINE DEDENT DEDENT if n == 0 : NEW_LINE INDENT s . pop ( ) NEW_LINE s . append ( 1 ) NEW_LINE DEDENT val = eval ( s , { } , { } ) NEW_LINE print ( val ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE arr = np . zeros ( ( n + 3 , ) , dtype = bool ) NEW_LINE arr [ 0 , : ] = True NEW_LINE arr [ 1 , : ] = True NEW_LINE count = 0 NEW_LINE for i in range ( 2 , len ( arr ) ) : NEW_LINE INDENT if not arr [ i ] : NEW_LINE INDENT for j in range ( 2 , i * len ( arr ) ) : NEW_LINE INDENT arr [ i * j , : ] = True NEW_LINE DEDENT if not arr [ i ] and not arr [ i - 2 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count * 2 ) NEW_LINE DEDENT
def league ( ) : NEW_LINE INDENT n = len ( sys . argv ) NEW_LINE num = 0 NEW_LINE a = [ 0 ] * 1000001 NEW_LINE start = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num += sys . argv [ i ] NEW_LINE for j in range ( start , num + 1 ) : NEW_LINE INDENT a [ j ] = i NEW_LINE DEDENT start = num NEW_LINE DEDENT m = sys . argv [ n + 1 ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT sys . stdout . write ( a [ sys . argv [ n + 1 ] - 1 ] ) NEW_LINE sys . stdout . write ( " \n " ) NEW_LINE DEDENT DEDENT
def ada ( ) : NEW_LINE INDENT n = len ( input ( ) ) NEW_LINE m = len ( input ( ) ) NEW_LINE dp = [ 0 ] * n + [ 0 ] * n + [ 0 ] * n NEW_LINE pre = [ 0 ] * n + [ 0 ] * n + [ 0 ] * n NEW_LINE prev_sum = dp [ 1 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i != 1 : NEW_LINE INDENT pre [ i ] = ( pre [ i - 1 ] + pre [ i ] ) % m NEW_LINE dp [ i ] = ( prev_sum + pre [ i ] ) % m NEW_LINE prev_sum = ( prev_sum + dp [ i ] ) % m NEW_LINE DEDENT for p , j in zip ( 2 * i , 2 * i + 1 ) : NEW_LINE INDENT r = j + p NEW_LINE pre [ j ] = ( pre [ j ] + dp [ i ] ) % m NEW_LINE if r <= n : NEW_LINE INDENT pre [ r ] = ( ( pre [ r ] - dp [ i ] ) % m + m ) % m NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] ) NEW_LINE DEDENT
def test_sliding_window ( ) : NEW_LINE INDENT from collections import deque NEW_LINE from sympy . utilities . randtest import get_random_symbols NEW_LINE Qi = deque ( ) NEW_LINE i = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT while not Qi . empty ( ) and arr [ i ] >= arr [ Qi . pop ( ) ] : NEW_LINE INDENT Qi . pop ( ) NEW_LINE DEDENT Qi . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ Qi . pop ( ) ] , end = ' ▁ ' ) NEW_LINE while ( not Qi . empty ( ) ) and Qi . pop ( ) <= i - k : NEW_LINE INDENT Qi . pop ( ) NEW_LINE DEDENT while ( not Qi . empty ( ) ) and arr [ i ] >= arr [ Qi . pop ( ) ] : NEW_LINE INDENT Qi . pop ( ) NEW_LINE DEDENT Qi . append ( i ) NEW_LINE DEDENT print ( arr [ Qi . pop ( ) ] , end = ' ▁ ' ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT from sympy . polys . distributedmodules import russian_peasant NEW_LINE res = 0 NEW_LINE while b : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT assert res == 0 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT for i in range ( 1 , len ( str ( x ) ) + 1 ) : NEW_LINE INDENT if str ( x ) == str ( x - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def pythontag_in_function ( n , t ) : NEW_LINE INDENT rng = np . random . RandomState ( 0 ) NEW_LINE a = rng . randint ( 0 , n - 3 , size = ( n - 3 ) ) + 2 NEW_LINE e = ( n - 1 ) / 2 NEW_LINE while t > 0 : NEW_LINE INDENT result = ( ( np . power ( a , e ) ) . sum ( ) ) % n NEW_LINE if ( result % n ) == 1 or ( result % n ) == ( n - 1 ) : NEW_LINE INDENT a = rng . randint ( 0 , n - 3 , size = ( n - 3 ) ) + 2 NEW_LINE t -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def pysub ( ) : NEW_LINE INDENT f = sys . stdin NEW_LINE num = 0 NEW_LINE while num : NEW_LINE INDENT a = f . readline ( ) NEW_LINE b = f . readline ( ) NEW_LINE res = 0 NEW_LINE while a != ' ' and b != ' ' : NEW_LINE INDENT if a >= b : NEW_LINE INDENT res += a / b NEW_LINE a %= b NEW_LINE DEDENT else : NEW_LINE INDENT res += b / a NEW_LINE b %= a NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT DEDENT
def _cp ( s ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( s , ' ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - h ' : NEW_LINE INDENT h = sys . argv [ 0 ] NEW_LINE DEDENT elif o == ' - c ' : NEW_LINE INDENT c = sys . argv [ 0 ] NEW_LINE DEDENT elif o == ' - d ' : NEW_LINE INDENT d = sys . argv [ 0 ] NEW_LINE DEDENT elif o == ' - l ' : NEW_LINE INDENT l = sys . argv [ 0 ] NEW_LINE DEDENT DEDENT def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def print_vector ( al ) : NEW_LINE INDENT for i in al : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def digitsum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT try : NEW_LINE INDENT s = sys . stdin NEW_LINE DEDENT except EOFError : NEW_LINE INDENT print ( sys . argv [ 0 ] ) NEW_LINE return NEW_LINE DEDENT s = s . readline ( ) NEW_LINE k = s . tell ( ) NEW_LINE hs = set ( ) NEW_LINE for x in s : NEW_LINE INDENT hs . add ( x ) NEW_LINE DEDENT if len ( s ) < k : NEW_LINE INDENT s . write ( ' impossible ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if k <= len ( hs ) : NEW_LINE INDENT s . write ( '0 \n ' ) NEW_LINE DEDENT else : NEW_LINE INDENT s . write ( k - len ( hs ) ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT DEDENT
def GFG ( mat ) : NEW_LINE INDENT N = 3 NEW_LINE MaxTraceSub = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT r , s , trace = i , j , 0 NEW_LINE while r < N and s < N : NEW_LINE INDENT trace += mat [ r ] [ s ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE MaxTraceSub = max ( trace , MaxTraceSub ) NEW_LINE DEDENT DEDENT DEDENT return MaxTraceSub NEW_LINE DEDENT
def pymatlab ( ) : NEW_LINE INDENT import numpy as np NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt NEW_LINE import matplotlib . pyplot as plt
def test_array_elimination ( ) : NEW_LINE INDENT import numpy as np NEW_LINE t = np . arange ( 10 ) NEW_LINE for tt in t : NEW_LINE INDENT n = t [ tt ] NEW_LINE bit = [ 0 ] * 32 NEW_LINE arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE INDENT temp = ( 1 << ( j - 1 ) ) NEW_LINE bitwise_and = arr [ i ] & temp NEW_LINE if bitwise_and : NEW_LINE INDENT bit [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT possible = True NEW_LINE for j in range ( 32 ) : NEW_LINE INDENT if bit [ j ] % i != 0 : NEW_LINE INDENT possible = False NEW_LINE break NEW_LINE DEDENT DEDENT if possible : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT div_count = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT div_count += 1 NEW_LINE DEDENT DEDENT if ( div_count % 2 ) != 0 : NEW_LINE INDENT yield ( test_GFG , i , j ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n , m = sys . argv [ 1 ] , sys . argv [ 2 ] NEW_LINE M = float ( m ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT max = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = int ( math . ceil ( arr [ i ] / M ) ) NEW_LINE if x >= max : NEW_LINE INDENT max = x NEW_LINE ans = i NEW_LINE DEDENT DEDENT print ( ans + 1 ) NEW_LINE DEDENT
def GFG ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE replacedArray ( N , arr ) NEW_LINE pos_sum , neg_sum , i , j , diff = replacedArray ( N , arr ) NEW_LINE pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE if arr [ i ] > 0 : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ i ] NEW_LINE DEDENT arr [ i ] = abs ( diff ) NEW_LINE DEDENT DEDENT
def GFG ( N , arr ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE replacedArray ( N , arr ) NEW_LINE pos_sum , neg_sum , i , j , diff = replacedArray ( N , arr ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT if arr [ j ] > 0 : NEW_LINE INDENT pos_sum += arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum += arr [ j ] NEW_LINE DEDENT DEDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE arr [ i ] = abs ( diff ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] in [ '4' , '8' , '0' ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT h = ( s [ i ] - '0' ) * 10 + ( s [ i + 1 ] - '0' ) NEW_LINE if h % 4 == 0 : NEW_LINE INDENT count = count + i + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def test_cf1535_A ( ) : NEW_LINE INDENT input = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] , dtype = np . int32 ) NEW_LINE t = input . dtype . itemsize NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT a = [ ] NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT a . append ( input ( " % d " % k ) ) NEW_LINE DEDENT if max ( a ) > min ( a ) and max ( a ) > min ( a ) : NEW_LINE INDENT assert " YES " in a NEW_LINE DEDENT else : NEW_LINE INDENT assert " NO " in a NEW_LINE DEDENT DEDENT DEDENT
def test_96B ( ) : NEW_LINE INDENT f = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 115 , 116 , 117 , 118 , 119 , 101 , 120 , 121 , 122 , 123 , 124 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 149 , 150 , 151 , 152 , 153 , 144 , 145 , 146 , 147 , 148 , 149 , 150 , 151 , 152 , 153 , 144 , 145 , 146 , 147 , 148 , 149 , 150 , 151 , 152 , 153 , 144 , 145 , 146 , 148 , 149 , 150 , 151 , 152 , 153 , 144 , 146 , 148 , 149 , 150 , 151 , 152 , 153 , 144 , 146 , 148 , 149 , 150 , 151 , 152 , 153 , 144 , 146 , 148 , 149 , 150 , 151 , 152 , 153 , 144 , 146 , 148 , 149 , 150 , 151 , 152 , 153 , 144 , 146 , 148 , 149 , 150 , 151 , 152 , 153 , 144 , 146 , 148 , 149 , 150 , 151 , 152 , 153 , 144 , 146 , 148 , 149 , 150 , 151 , 152 , 153 , 144 , 146 , 148 , 149 , 150 , 151 , 152 ] ) NEW_LINE DEDENT
def test_orac_and_median_641b ( ) : NEW_LINE INDENT f = open ( ' / home / jeko / Downloads / orac _ and _ median _ 641b . txt ' , ' r ' ) NEW_LINE cases = int ( f . read ( ) ) NEW_LINE for cases in cases : NEW_LINE INDENT tokens = f . readline ( ) . split ( ) NEW_LINE n = int ( tokens [ 0 ] ) NEW_LINE target = int ( tokens [ 1 ] ) NEW_LINE nums = [ int ( x ) for x in tokens [ 2 : ] ] NEW_LINE helper ( nums , target ) NEW_LINE DEDENT DEDENT
def py_smooth ( ) : NEW_LINE INDENT import sys NEW_LINE memo = [ [ ] , [ ] , [ ] ] NEW_LINE def solve ( ) : NEW_LINE INDENT T = sys . getrecursionlimit ( ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT print ( " Case ▁ # " + str ( i ) + " : ▁ " ) NEW_LINE solve_case ( ) NEW_LINE DEDENT DEDENT def SPC ( ) : NEW_LINE INDENT def solve_case ( ) : NEW_LINE INDENT del sys . getrecursionlimit ( ) NEW_LINE ins , max_dist , n = sys . getrecursioninfo ( ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( sys . getrecursionlimit ( ) ) NEW_LINE DEDENT for arr in memo : NEW_LINE INDENT del arr [ : ] NEW_LINE DEDENT print ( solve ( 0 , SPC ) ) NEW_LINE DEDENT del sys . getrecursionlimit ( ) , ins , max_dist , n NEW_LINE def solve ( ) : NEW_LINE INDENT if index >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if memo [ index ] [ prev ] == - 1 : NEW_LINE INDENT res = del + solve ( index + 1 , prev ) NEW_LINE for val in SPC : NEW_LINE INDENT res = min ( res , abs ( arr [ index ] - val ) + ins_cost ( val , prev ) + solve ( index + 1 , val ) ) NEW_LINE DEDENT memo [ index ] [ prev ] = res NEW_LINE DEDENT return memo [ index ] [ prev ] NEW_LINE DEDENT def ins_cost ( cur , prev ) : NEW_LINE INDENT if prev == SPC or cur == prev : NEW_LINE INDENT return 0 NEW_LINE DEDENT if max_dist == 0 : NEW_LINE INDENT return 100000000 NEW_LINE DEDENT return ins * ( ( abs ( cur - prev ) + max_dist - 1 ) / max_dist - 1 ) NEW_LINE DEDENT return solve ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE N = 12 NEW_LINE ofs = [ [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] , [ 0 , 1 ] ] NEW_LINE del ( map , y , x ) NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT nx = x + ofs [ i ] [ 0 ] NEW_LINE ny = y + ofs [ i ] [ 1 ] NEW_LINE if 0 <= ny < N and 0 <= nx < N : NEW_LINE INDENT if map [ ny , nx ] : NEW_LINE INDENT del ( map , ny , nx ) NEW_LINE DEDENT DEDENT DEDENT solve ( map ) NEW_LINE c = 0 NEW_LINE for y in range ( N ) : NEW_LINE INDENT for x in range ( N ) : NEW_LINE INDENT if map [ y , x ] : NEW_LINE INDENT c += 1 NEW_LINE del ( map , y , x ) NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i - 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def test_candies ( ) : NEW_LINE INDENT from sympy . utilities . randtest import seed NEW_LINE t = seed ( ) NEW_LINE while t > 0 : NEW_LINE INDENT a = range ( t ) NEW_LINE x = [ 0 ] * a NEW_LINE x [ a ] = 1 NEW_LINE x [ a ] = 2 NEW_LINE x [ a ] = 3 NEW_LINE x [ a ] = 4 NEW_LINE x [ a ] = 5 NEW_LINE x [ a ] = 6 NEW_LINE x [ a ] = 7 NEW_LINE x [ a ] = 8 NEW_LINE x [ a ] = 9 NEW_LINE s = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT s += abs ( x [ i ] - x [ 0 ] ) NEW_LINE DEDENT assert s == 1 NEW_LINE DEDENT DEDENT
def get_kmg_count ( arr , n , k ) : NEW_LINE INDENT h = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if h . has_key ( arr [ i ] ) : NEW_LINE INDENT h [ arr [ i ] ] = h [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if len ( h ) < k : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if h [ arr [ i ] ] == 1 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if dist_count == k : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT f = [ 0 ] * 60 NEW_LINE for i in range ( 2 , 59 ) : NEW_LINE INDENT f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 NEW_LINE DEDENT find_last_digit ( n ) NEW_LINE index = int ( n % 60. ) NEW_LINE return f [ index ] NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global num_1 , num_2 , num_3 NEW_LINE if sys . argv [ 1 : ] != [ ' - - help ' ] : NEW_LINE INDENT sys . exit ( __doc__ ) NEW_LINE DEDENT num_1 = int ( sys . argv [ 1 ] ) NEW_LINE num_2 = int ( sys . argv [ 2 ] ) NEW_LINE num_3 = int ( sys . argv [ 3 ] ) NEW_LINE if num_1 == 7 : NEW_LINE INDENT if num_2 == 5 and num_3 == 5 : NEW_LINE INDENT sys . exit ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . exit ( ' NO ' ) NEW_LINE DEDENT DEDENT elif num_2 == 7 : NEW_LINE INDENT if num_1 == 5 and num_3 == 5 : NEW_LINE INDENT sys . exit ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . exit ( ' NO ' ) NEW_LINE DEDENT DEDENT elif num_3 == 7 : NEW_LINE INDENT if num_2 == 5 and num_1 == 5 : NEW_LINE INDENT sys . exit ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . exit ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n , z , w = sys . argv [ 1 : ] NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( abs ( w - a [ 0 ] ) ) NEW_LINE return NEW_LINE DEDENT ans1 = abs ( a [ - 2 ] - a [ - 1 ] ) NEW_LINE ans2 = abs ( w - a [ - 1 ] ) NEW_LINE print ( max ( ans1 , ans2 ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT for arr1 in [ 1 , 2 , 3 , 4 , 7 , 9 ] : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if arr2 [ j ] <= arr1 [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def test_maximum_of_maximums_of_minimums ( ) : NEW_LINE INDENT f = BytesIO ( ) NEW_LINE n , k = symbols ( ' n ▁ k ' , integer = True , positive = True ) NEW_LINE a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] NEW_LINE b = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = i NEW_LINE DEDENT f . seek ( 0 ) NEW_LINE def solve ( n , a , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT res = S . Zero NEW_LINE for x in a : NEW_LINE INDENT res = min ( x , res ) NEW_LINE DEDENT return res NEW_LINE DEDENT if k == 2 : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return a NEW_LINE DEDENT dq = ArrayQueue ( ) NEW_LINE for x in a : NEW_LINE INDENT dq . add ( x ) NEW_LINE DEDENT lMin , rMin = S . Infinity , S . Infinity NEW_LINE ans = a [ 0 ] NEW_LINE while not dq . empty ( ) : NEW_LINE INDENT lMin = min ( dq . pop ( ) , lMin ) NEW_LINE if rMin == S . Infinity and dq . empty ( ) : NEW_LINE INDENT rMin = S . Infinity NEW_LINE break NEW_LINE DEDENT if not dq . empty ( ) : NEW_LINE INDENT break NEW_LINE DEDENT rMin = min ( dq . pop ( ) , rMin ) NEW_LINE ans = max ( ans , max ( rMin , lMin ) ) NEW_LINE DEDENT ans = max ( ans , max ( rMin , lMin ) ) NEW_LINE return ans NEW_LINE DEDENT ans = S . Zero NEW_LINE for x in a : NEW_LINE INDENT ans = max ( ans , x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def debug ( * obj ) : NEW_LINE INDENT sys . stderr . write ( ' % s \n ' % type ( obj ) . __name__ ) NEW_LINE DEDENT DEDENT
def pynewclass ( ) : NEW_LINE INDENT import sys NEW_LINE name1 , name2 = sys . argv [ 1 : ] NEW_LINE print ( name1 , name2 ) NEW_LINE n = 1 NEW_LINE while True : NEW_LINE INDENT s1 , s2 = sys . argv [ 1 : ] NEW_LINE if s1 == name1 : NEW_LINE INDENT name1 = s2 NEW_LINE DEDENT if s1 == name2 : NEW_LINE INDENT name2 = s2 NEW_LINE DEDENT print ( name1 , name2 ) NEW_LINE n -= 1 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import getopt NEW_LINE parser = optparse . OptionParser ( usage = " % prog ▁ [ options ] " ) NEW_LINE parser . add_option ( " - - input " , dest = " input " , help = " Input ▁ file ▁ to ▁ read " ) NEW_LINE parser . add_option ( " - - output " , dest = " output " , help = " Output ▁ file ▁ to ▁ write " ) NEW_LINE parser . add_option ( " - - solver " , dest = " solver " , help = " Solver ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file " , dest = " solver _ file " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - file " , dest = " solver _ file _ file " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - file " , dest = " solver _ file _ file _ file " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - file " , dest = " solver _ file _ file _ file " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - file - file " , dest = " solver _ file _ file _ file " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - file - file " , dest = " solver _ file _ file _ file " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - file - file " , dest = " solver _ file _ file _ file " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - file - file - file " , dest = " solver _ file _ file _ file " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - file - file - file " , dest = " solver _ file _ file _ file " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE options , args = parser . parse_args ( ) NEW_LINE solver = TaskA ( ) NEW_LINE solver . solve ( 1 , options . solver , options . solver , options . solver
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import getopt NEW_LINE parser = optparse . OptionParser ( usage = " % prog ▁ [ options ] " ) NEW_LINE parser . add_option ( " - - input " , dest = " input " , help = " Input ▁ file ▁ to ▁ read " ) NEW_LINE parser . add_option ( " - - output " , dest = " output " , help = " Output ▁ file ▁ to ▁ write " ) NEW_LINE parser . add_option ( " - - solver " , dest = " solver " , help = " Solver ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file " , dest = " solver _ file " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - out " , dest = " solver _ file _ out " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - out " , dest = " solver _ file _ out " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - out " , dest = " solver _ file _ out " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - out " , dest = " solver _ file _ out " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - out " , dest = " solver _ file _ out " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - out " , dest = " solver _ file _ out " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - out " , dest = " solver _ file _ out " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - out " , dest = " solver _ file _ out " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE parser . add_option ( " - - solver - file - out " , dest = " solver _ file _ out " , help = " Solver ▁ file ▁ to ▁ use " ) NEW_LINE options , args = parser . parse_args ( ) NEW_LINE solver = TaskA ( ) NEW_LINE solver . solve ( 1 , options )
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE n = len ( sys . argv ) NEW_LINE a = [ ] NEW_LINE p = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( sys . argv [ i ] - 1 ) NEW_LINE p [ a [ i ] ] = i NEW_LINE DEDENT x = sorted ( p ) NEW_LINE l = [ ] NEW_LINE r = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x . append ( p [ i ] ) NEW_LINE if x . first ( ) == p [ i ] : NEW_LINE INDENT l . append ( p [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT lower = x . lower ( p [ i ] ) NEW_LINE l . append ( p [ i ] - lower ) NEW_LINE DEDENT if x . last ( ) == p [ i ] : NEW_LINE INDENT r . append ( n - p [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT high = x . higher ( p [ i ] ) NEW_LINE r . append ( high - p [ i ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += long ( l [ i ] * r [ i ] * ( i + 1 ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def LPS ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE i , j , cl = seq NEW_LINE L = [ [ 1 ] * n for i in range ( n ) ] NEW_LINE for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if seq [ i ] == seq [ j ] and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif seq [ i ] == seq [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def GFG ( last , first ) : NEW_LINE INDENT print ( first ) NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( " ▁ + ▁ " + str ( x ) ) NEW_LINE DEDENT find_consecutive ( N ) NEW_LINE for last in range ( 1 , N + 1 ) : NEW_LINE INDENT for first in range ( 0 , last + 1 ) : NEW_LINE INDENT if 2 * N == ( last - first ) * ( last + first + 1 ) : NEW_LINE INDENT print ( N + " ▁ = ▁ " ) NEW_LINE print_consecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT
def test_CF ( ) : NEW_LINE INDENT f = py . io . TextIO ( encoding = ' utf - 8' ) NEW_LINE f . write ( ' ' ) NEW_LINE even , odd = f . getvalue ( ) . split ( ' \n ' ) NEW_LINE if even == ' ' and odd == ' ' : NEW_LINE INDENT assert ' NO ' in f . getvalue ( ) NEW_LINE DEDENT else : NEW_LINE INDENT sub = abs ( even - odd ) NEW_LINE if sub <= 1 : NEW_LINE INDENT assert ' YES ' in f . getvalue ( ) NEW_LINE DEDENT else : NEW_LINE INDENT assert ' NO ' in f . getvalue ( ) NEW_LINE DEDENT DEDENT f . close ( ) NEW_LINE DEDENT
def __gcd ( x , y ) : NEW_LINE INDENT if not isinstance ( x , int ) or not isinstance ( y , int ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if not a ( x ) : NEW_LINE INDENT return a ( y ) NEW_LINE DEDENT if a ( x ) > b ( y ) : NEW_LINE INDENT return __gcd ( a ( x ) - b ( y ) ) NEW_LINE DEDENT return __gcd ( a ( x ) , b ( y ) - a ( x ) ) NEW_LINE DEDENT
def get_GFG ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c . append ( s [ i ] ) NEW_LINE DEDENT c . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if c [ i ] != s [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def GFG ( arr , n , k ) : NEW_LINE INDENT j , max = 0 , 0 NEW_LINE for i in range ( 0 , n - k ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE for j in range ( 1 , k ) : NEW_LINE INDENT if arr [ i + j ] > max : NEW_LINE INDENT max = arr [ i + j ] NEW_LINE DEDENT DEDENT print ( max , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE global graph NEW_LINE global visited NEW_LINE color = [ ] NEW_LINE one = 0 NEW_LINE bipartite = 0 NEW_LINE count = 0 NEW_LINE mujun = 0 NEW_LINE dfs ( ) NEW_LINE if visited [ a ] : NEW_LINE INDENT if color [ a ] >= 0 and color [ a ] != c : NEW_LINE INDENT mujun = True NEW_LINE DEDENT return 0 NEW_LINE DEDENT visited [ a ] = True NEW_LINE color [ a ] = c NEW_LINE total = 1 NEW_LINE for b in graph [ a ] : NEW_LINE INDENT total += dfs ( b , 1 - c ) NEW_LINE DEDENT return total NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE parser = optparse . OptionParser ( usage = " % prog ▁ [ options ] " ) NEW_LINE parser . add_option ( " - - test - number " , dest = " test _ number " , help = " test ▁ number ▁ to ▁ run " ) NEW_LINE parser . add_option ( " - - test - file " , dest = " test _ file " , help = " test ▁ file ▁ to ▁ run " ) NEW_LINE parser . add_option ( " - - test - file - type " , dest = " test _ file _ type " , help = " test ▁ file ▁ type ▁ to ▁ run " ) NEW_LINE parser . add_option ( " - - test - file - type - multiple " , dest = " test _ file _ type _ multiple " , help = " test ▁ file ▁ type ▁ multiple ▁ times " ) NEW_LINE parser . add_option ( " - - test - file - type - multiple " , dest = " test _ file _ type _ multiple " , help = " test ▁ file ▁ type ▁ multiple ▁ times " ) NEW_LINE parser . add_option ( " - - test - file - type - multiple " , dest = " test _ file _ type _ multiple " , help = " test ▁ file ▁ type ▁ multiple ▁ times " ) NEW_LINE parser . add_option ( " - - test - file - type - multiple " , dest = " test _ file _ type _ multiple " , help = " test ▁ file ▁ type ▁ multiple ▁ times " ) NEW_LINE parser . add_option ( " - - test - file - type - multiple " , dest = " test _ file _ type _ multiple " , help = " test ▁ file ▁ type ▁ multiple ▁ times " ) NEW_LINE parser . add_option ( " - - test - file - type - multiple " , dest = " test _ file _ type _ multiple " , help = " test ▁ file ▁ type ▁ multiple ▁ times " ) NEW_LINE parser . add_option ( " - - test - file - type - multiple " , dest = " test _ file _ type _ multiple " , help = " test ▁ file ▁ type ▁ multiple ▁ times " ) NEW_LINE parser . add_option ( " - - test - file - type - multiple " , dest = " test _ file _ type _ multiple " , help = " test ▁ file ▁ type ▁ multiple ▁ times " ) NEW_LINE options , args = parser . parse_args ( ) NEW_LINE if options . test_number is None : NEW_LINE INDENT parser . print_help ( ) NEW_LINE sys . exit (
def main ( ) : NEW_LINE INDENT import sys NEW_LINE main = sys . exit NEW_LINE class P ( object ) : NEW_LINE INDENT x = [ ] NEW_LINE y = [ ] NEW_LINE def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT @ property NEW_LINE def __lt__ ( self , other ) : NEW_LINE INDENT return any ( self . x < other . x for x in self . x ) NEW_LINE DEDENT @ property NEW_LINE def __gt__ ( self , other ) : NEW_LINE INDENT return any ( self . x > other . x for x in self . x ) NEW_LINE DEDENT DEDENT sys . argv = sys . argv [ 1 : ] NEW_LINE N = sys . argv [ 2 ] NEW_LINE K = sys . argv [ 3 ] NEW_LINE x = [ ] NEW_LINE y = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x . append ( i ) NEW_LINE y . append ( i ) NEW_LINE DEDENT ans = float ( ' inf ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT x1 = x [ i ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT x2 = x [ j ] NEW_LINE if x1 >= x2 : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( N ) : NEW_LINE INDENT y1 = y [ k ] NEW_LINE for l in range ( N ) : NEW_LINE INDENT y2 = y [ l ] NEW_LINE if y1 >= y2 : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE for m in range ( N ) : NEW_LINE INDENT if x1 <= x [ m ] and x [ m ] <= x2 and y1 <= y [ m ] and y [ m ] <= y2 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt == K : NEW_LINE INDENT ans = min ( ans , ( x2 - x1 ) * ( y2 - y1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE for o , a in getopt . getopt ( sys . argv [ 1 : ] , ' ' ) : NEW_LINE INDENT if o == ' - h ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - v ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - version ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - name - id ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - name - id ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT if o == ' - - id - name ' : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT sys . exit ( 1 ) NEW_LINE DEDENT
def test_GFG ( substrings , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dup = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT dup += s [ j ] NEW_LINE substrings [ count ] = dup NEW_LINE DEDENT DEDENT size = len ( substrings ) NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len ( substrings ) ) : NEW_LINE INDENT if substrings [ i ] > substrings [ j ] : NEW_LINE INDENT temp = substrings [ i ] NEW_LINE substrings [ i ] , substrings [ j ] = substrings [ j ] , substrings [ i ] NEW_LINE substrings [ j ] = temp NEW_LINE DEDENT DEDENT DEDENT s = " geek " NEW_LINE substrings = [ ] NEW_LINE pre_process ( substrings , s ) NEW_LINE queries = [ 1 , 5 , 10 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT assert substrings [ queries [ i ] - 1 ] == s [ queries [ i ] - 1 ] NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while 1 : NEW_LINE INDENT w , h = input ( ) . split ( ) NEW_LINE if w == 0 and h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = " " NEW_LINE t = 0 NEW_LINE d = 0 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE c = " " NEW_LINE while 1 : NEW_LINE INDENT s = input ( ) . split ( ) NEW_LINE c = s [ 0 ] NEW_LINE if c == " S " : NEW_LINE INDENT print ( ( x , y ) ) NEW_LINE break NEW_LINE DEDENT elif c == " R " : NEW_LINE INDENT d += 1 NEW_LINE if d == 4 : NEW_LINE INDENT d = 0 NEW_LINE DEDENT DEDENT elif c == " L " : NEW_LINE INDENT d -= 1 NEW_LINE if d == - 1 : NEW_LINE INDENT d = 3 NEW_LINE DEDENT DEDENT elif ( c == " F " and d == 0 ) or ( c == " B " and d == 2 ) : NEW_LINE INDENT t = input ( ) . split ( ) NEW_LINE y += t NEW_LINE if y > h - 1 : NEW_LINE INDENT y = h - 1 NEW_LINE DEDENT DEDENT elif ( c == " F " and d == 1 ) or ( c == " B " and d == 3 ) : NEW_LINE INDENT t = input ( ) . split ( ) NEW_LINE x += t NEW_LINE if x > w - 1 : NEW_LINE INDENT x = w - 1 NEW_LINE DEDENT DEDENT elif ( c == " F " and d == 2 ) or ( c == " B " and d == 0 ) : NEW_LINE INDENT t = input ( ) . split ( ) NEW_LINE y -= t NEW_LINE if y < 0 : NEW_LINE INDENT y = 0 NEW_LINE DEDENT DEDENT elif ( c == " F " and d == 3 ) or ( c == " B " and d == 1 ) : NEW_LINE INDENT t = input ( ) . split ( ) NEW_LINE x -= t NEW_LINE if x < 0 : NEW_LINE INDENT x = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def get_file_name ( ) : NEW_LINE INDENT import sys NEW_LINE import string NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' x ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE total = 0 NEW_LINE for o , a in opts : NEW_LINE INDENT if o == ' - x ' : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT if count >= 3 : NEW_LINE INDENT total += count - 2 NEW_LINE count = 0 NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT if count >= 3 : NEW_LINE INDENT total += count - 2 NEW_LINE count = 0 NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT f = sys . stdin NEW_LINE while True : NEW_LINE INDENT a = f . readline ( ) NEW_LINE num = a . split ( ) NEW_LINE if num [ 0 ] == '0' : NEW_LINE INDENT break NEW_LINE DEDENT A , B = 0 , 0 NEW_LINE for c in num : NEW_LINE INDENT if c == ' A ' : NEW_LINE INDENT A += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT DEDENT if A > B : NEW_LINE INDENT A += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT print ( A , B ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT i , product = symbols ( ' i ▁ product ' , integer = True , positive = True ) NEW_LINE assert product . nthpoly ( 1 ) == ( 1 , 1 ) NEW_LINE assert product . nthpoly ( 2 ) == ( 2 , 2 ) NEW_LINE assert product . nthpoly ( 3 ) == ( 3 , 3 ) NEW_LINE assert product . nthpoly ( 4 ) == ( 4 , 4 ) NEW_LINE assert product . nthpoly ( 5 ) == ( 5 , 5 ) NEW_LINE assert product . nthpoly ( 6 ) == ( 6 , 6 ) NEW_LINE assert product . nthpoly ( 7 ) == ( 7 , 7 ) NEW_LINE assert product . nthpoly ( 8 ) == ( 8 , 8 ) NEW_LINE assert product . nthpoly ( 9 ) == ( 9 , 9 ) NEW_LINE assert product . nthpoly ( 10 ) == ( 10 , 10 ) NEW_LINE assert product . nthpoly ( 11 ) == ( 11 , 11 ) NEW_LINE assert product . nthpoly ( 12 ) == ( 12 , 12 ) NEW_LINE assert product . nthpoly ( 13 ) == ( 13 , 13 ) NEW_LINE assert product . nthpoly ( 14 ) == ( 14 , 14 ) NEW_LINE assert product . nthpoly ( 15 ) == ( 15 , 15 ) NEW_LINE assert product . nthpoly ( 16 ) == ( 16 , 16 ) NEW_LINE assert product . nthpoly ( 17 ) == ( 17 , 17 ) NEW_LINE assert product . nthpoly ( 18 ) == ( 18 , 18 ) NEW_LINE assert product . nthpoly ( 19 ) == ( 19 , 19 ) NEW_LINE assert
def GFG ( arr , n ) : NEW_LINE INDENT is_zero_present = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT is_zero_present = True NEW_LINE break NEW_LINE DEDENT DEDENT if is_zero_present : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT
def test_aa ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE for i in range ( t . size ) : NEW_LINE INDENT k = symbols ( ' k ' , integer = True , positive = True ) NEW_LINE x = symbols ( ' x ' , integer = True , positive = True ) NEW_LINE f = k * 9 NEW_LINE for y in range ( x , 9 ) : NEW_LINE INDENT f -= 1 NEW_LINE DEDENT assert f == x ** 9 NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT left , right , above , below = x * b , ( l - x - 1 ) * b , ( b - y - 1 ) * l NEW_LINE assert max ( max ( [ left , right ] ) , key = lambda x : x ) == max ( [ above , below ] ) NEW_LINE DEDENT
def GFG ( str , n ) : NEW_LINE INDENT NO_OF_CHARS = 256 NEW_LINE max_distinct_char = [ 0 ] * ( NO_OF_CHARS - 1 ) NEW_LINE max_distinct = 0 NEW_LINE for char in str : NEW_LINE INDENT if char != 0 : NEW_LINE INDENT max_distinct += 1 NEW_LINE DEDENT DEDENT return max_distinct NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import os NEW_LINE import string NEW_LINE import re NEW_LINE import math NEW_LINE import random NEW_LINE import time NEW_LINE import sys NEW_LINE import string NEW_LINE import os NEW_LINE import re NEW_LINE import math NEW_LINE import math NEW_LINE import time NEW_LINE import string NEW_LINE import math NEW_LINE import random NEW_LINE import string NEW_LINE import math NEW_LINE import math NEW_LINE import sys NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string
def GFG ( n , q , size ) : NEW_LINE INDENT row = [ ] NEW_LINE col = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT x , y = q [ i ] NEW_LINE row . append ( x - 1 ) NEW_LINE col . append ( y - 1 ) NEW_LINE DEDENT r1 , r2 = 0 , 0 NEW_LINE c1 , c2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if row [ i ] % 2 == 0 : r1 += 1 NEW_LINE if row [ i ] % 2 == 1 : r2 += 1 NEW_LINE if col [ i ] % 2 == 0 : c1 += 1 NEW_LINE if col [ i ] % 2 == 1 : c2 += 1 NEW_LINE DEDENT count = r1 * c1 + r2 * c2 NEW_LINE return count NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = np . array ( [ 1 , 2 , 3 , 4 ] ) NEW_LINE n = len ( arr ) NEW_LINE check_dtype ( arr , n ) NEW_LINE DEDENT
def binary_str ( ) : NEW_LINE INDENT bf = open ( ' / proc / cpuinfo ' , ' r ' ) NEW_LINE t = int ( bf . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( bf . readline ( ) ) NEW_LINE arr = bf . readline ( ) . split ( ) NEW_LINE arr2 = [ arr [ i ] ] NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT if j % 2 == 0 : arr2 . append ( '0' ) NEW_LINE else : arr2 . append ( '1' ) NEW_LINE DEDENT cur = 0 NEW_LINE k = 0 NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ j ] == arr2 [ j ] : continue NEW_LINE for k in range ( j , n - 1 ) : NEW_LINE INDENT if arr [ k ] == arr2 [ k ] : break NEW_LINE DEDENT cur += 1 NEW_LINE j = k - 1 NEW_LINE DEDENT ans = int ( ' ' ) NEW_LINE ans = min ( ans , cur ) NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ j ] == arr2 [ j ] : continue NEW_LINE for k in range ( j , n - 1 ) : NEW_LINE INDENT if arr [ k ] == arr2 [ k ] : break NEW_LINE DEDENT cur += 1 NEW_LINE j = k - 1 NEW_LINE DEDENT ans = min ( ans , cur ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
def test_code_forces ( ) : NEW_LINE INDENT fs = code_forces ( ) NEW_LINE a , b , c , d = fs NEW_LINE p , q = a * d - b * c , a * d NEW_LINE k = gcd ( p , q ) NEW_LINE p /= k NEW_LINE q /= k NEW_LINE assert p == q NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT x = 3 NEW_LINE assert number_of_ways ( x ) == x NEW_LINE DEDENT
def pyGFG ( arr , n ) : NEW_LINE INDENT j , temp = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT if i != j : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , temp NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 7 NEW_LINE assert n == 1 NEW_LINE assert n == 2 NEW_LINE assert n == 3 NEW_LINE assert n == 4 NEW_LINE assert n == 5 NEW_LINE assert n == 6 NEW_LINE assert n == 7 NEW_LINE assert n == 8 NEW_LINE assert n == 9 NEW_LINE assert n == 10 NEW_LINE assert n == 11 NEW_LINE assert n == 12 NEW_LINE assert n == 13 NEW_LINE assert n == 14 NEW_LINE assert n == 15 NEW_LINE assert n == 16 NEW_LINE assert n == 17 NEW_LINE assert n == 18 NEW_LINE assert n == 19 NEW_LINE assert n == 20 NEW_LINE assert n == 21 NEW_LINE assert n == 22 NEW_LINE assert n == 23 NEW_LINE assert n == 24 NEW_LINE assert n == 25 NEW_LINE assert n == 26 NEW_LINE assert n == 27 NEW_LINE assert n == 28 NEW_LINE assert n == 29 NEW_LINE assert n == 30 NEW_LINE assert n == 31 NEW_LINE assert n == 32 NEW_LINE assert n == 33 NEW_LINE assert n == 34 NEW_LINE assert n == 35 NEW_LINE assert n == 36 NEW_LINE assert n == 37 NEW_LINE assert n == 38 NEW_LINE assert n == 39 NEW_LINE assert n == 40 NEW_LINE assert n == 41 NEW_LINE assert n == 42 NEW_LINE assert n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n ==
def pyteest ( ) : NEW_LINE INDENT import sys NEW_LINE import doctest NEW_LINE import os NEW_LINE import pickle NEW_LINE import tempfile NEW_LINE import time NEW_LINE import doctest NEW_LINE import tempfile NEW_LINE import pickle NEW_LINE import os NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE DEDENT
def test_growth_the_tree ( ) : NEW_LINE INDENT G = nx . DiGraph ( ) NEW_LINE G . add_nodes_from ( [ 1 , 2 , 3 ] ) NEW_LINE G . add_nodes_from ( [ 4 , 5 , 6 ] ) NEW_LINE G . add_nodes_from ( [ 7 , 8 , 9 ] ) NEW_LINE G . add_edge ( 1 , 2 ) NEW_LINE G . add_edge ( 2 , 3 ) NEW_LINE G . add_edge ( 3 , 4 ) NEW_LINE G . add_edge ( 4 , 5 ) NEW_LINE G . add_edge ( 5 , 6 ) NEW_LINE G . add_edge ( 6 , 7 ) NEW_LINE G . add_edge ( 7 , 8 ) NEW_LINE G . add_edge ( 8 , 9 ) NEW_LINE G . add_edge ( 9 , 10 ) NEW_LINE G . add_edge ( 10 , 11 ) NEW_LINE G . add_edge ( 11 , 12 ) NEW_LINE G . add_edge ( 12 , 13 ) NEW_LINE G . add_edge ( 13 , 14 ) NEW_LINE G . add_edge ( 14 , 15 ) NEW_LINE G . add_edge ( 15 , 16 ) NEW_LINE G . add_edge ( 16 , 17 ) NEW_LINE G . add_edge ( 17 , 18 ) NEW_LINE G . add_edge ( 18 , 19 ) NEW_LINE G . add_edge ( 19 , 20 ) NEW_LINE G . add_edge ( 20 , 21 ) NEW_LINE G . add_edge ( 21 , 22 ) NEW_LINE G . add_edge ( 22 , 23 ) NEW_LINE G . add_edge ( 23 , 24 ) NEW_LINE G . add_edge ( 24 , 25 ) NEW_LINE G . add_edge ( 25 , 26 ) NEW_LINE G . add_edge ( 26 , 27 ) NEW_LINE G . add_edge ( 27 , 28 ) NEW_LINE G . add_edge ( 28 , 29 ) NEW_LINE G . add_edge ( 29 , 30 ) NEW_LINE G . add_edge ( 30 , 31 ) NEW_LINE G . add_edge ( 31 , 32 ) NEW_LINE G . add_edge ( 32 , 33 ) NEW_LINE G . add_edge ( 33 , 34 ) NEW_LINE G . add_edge ( 34 , 35 ) NEW_LINE G . add_edge ( 35 , 36 ) NEW_LINE G . add_edge ( 36 , 37 ) NEW_LINE G . add_edge ( 37 , 38 ) NEW_LINE G . add_edge ( 38 , 39 ) NEW_LINE G . add_edge ( 39 , 40 ) NEW_LINE G . add_edge ( 40 , 41 ) NEW_LINE G . add_edge ( 41 , 42 ) NEW_LINE G . add_edge ( 42 , 43 ) NEW_LINE G . add_edge ( 43 , 44 ) NEW_LINE G . add_edge ( 44 , 45 ) NEW_LINE G . add_edge ( 45 , 46 ) NEW_LINE G . add_edge ( 46 , 47 ) NEW_LINE G . add_edge ( 47 , 58 ) NEW_LINE G . add_edge ( 58 , 59 ) NEW_LINE G . add_edge ( 58 , 59 ) NEW_LINE DEDENT
def get_max_subarray_sum ( arr , size ) : NEW_LINE INDENT max_so_far = arr [ 0 ] NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( arr [ i ] , curr_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global debug NEW_LINE global solve NEW_LINE global dump NEW_LINE import time NEW_LINE import sys NEW_LINE import os NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , " dmp " ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( msg ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - d ' : NEW_LINE INDENT debug = a NEW_LINE DEDENT elif o == ' - h ' : NEW_LINE INDENT usage ( ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT DEDENT if args : NEW_LINE INDENT for arg in args : NEW_LINE INDENT if arg [ 0 ] == ' - d ' : NEW_LINE INDENT debug = True NEW_LINE DEDENT DEDENT DEDENT if debug : NEW_LINE INDENT sys . exit ( 0 ) NEW_LINE DEDENT for arg in args : NEW_LINE INDENT if arg . startswith ( " - " ) : NEW_LINE INDENT if arg [ 1 : ] == " - " : NEW_LINE INDENT arg = arg [ 2 : ] NEW_LINE DEDENT if arg not in dump : NEW_LINE INDENT dump [ arg ] = 1 NEW_LINE DEDENT DEDENT DEDENT if debug : NEW_LINE INDENT sys . exit ( 0 ) NEW_LINE DEDENT for arg in args : NEW_LINE INDENT if arg . startswith ( " - " ) : NEW_LINE INDENT if arg [ 1 : ] == " - " : NEW_LINE INDENT arg = arg [ 2 : ] NEW_LINE DEDENT if arg not in dump : NEW_LINE INDENT dump [ arg ] = 1 NEW_LINE DEDENT DEDENT DEDENT if dump : NEW_LINE INDENT print ( " % d ▁ ms " % ( len ( dump ) ) ) NEW_LINE DEDENT DEDENT
def GFG ( dividend , divisor , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return [ 0 , dividend ] NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE n = dividend - divisor * mid NEW_LINE if n > divisor : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT elif n < 0 : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if n == divisor : NEW_LINE INDENT yield mid , n NEW_LINE n = 0 NEW_LINE DEDENT return [ mid , n ] NEW_LINE DEDENT DEDENT
def test_omar ( ) : NEW_LINE INDENT input = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) NEW_LINE size = input . shape [ 0 ] NEW_LINE min , max = 0 , 0 NEW_LINE arr = input [ : size ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT min , max = abs ( arr [ i ] - arr [ i + 1 ] ) , abs ( arr [ i ] - arr [ size - 1 ] ) NEW_LINE DEDENT elif i == size - 1 : NEW_LINE INDENT min , max = abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ 0 ] ) NEW_LINE DEDENT elif i != 0 and i != size - 1 : NEW_LINE INDENT min , max = min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) , abs ( arr [ i ] - arr [ size - 1 ] ) NEW_LINE DEDENT assert min == max NEW_LINE DEDENT DEDENT
def mp3 ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE DEDENT
def GFG ( n , from_rod , to_rod , aux_rod1 , aux_rod2 ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT print ( " Move ▁ disk ▁ % d ▁ from ▁ rod ▁ % d ▁ to ▁ rod ▁ % d " % ( n , from_rod , to_rod ) ) NEW_LINE return NEW_LINE DEDENT towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) NEW_LINE print ( " Move ▁ disk ▁ % d ▁ from ▁ rod ▁ % d ▁ to ▁ rod ▁ % d " % ( ( n - 1 ) , from_rod , to_rod ) ) NEW_LINE print ( " Move ▁ disk ▁ % d ▁ from ▁ rod ▁ % d ▁ to ▁ rod ▁ % d " % ( n , from_rod , to_rod ) ) NEW_LINE print ( " Move ▁ disk ▁ % d ▁ from ▁ rod ▁ % d ▁ to ▁ rod ▁ % d " % ( ( n - 1 ) , aux_rod2 , to_rod ) ) NEW_LINE towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - n | - o | - a | - b | - c | - d ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁
def main ( ) : NEW_LINE INDENT stdscr = curses . initscr ( ) NEW_LINE dic = { } NEW_LINE count = stdscr . getcount ( ) NEW_LINE for i in range ( count ) : NEW_LINE INDENT command = stdscr . getch ( ) NEW_LINE try : NEW_LINE INDENT dic [ command ] = stdscr . getch ( ) NEW_LINE DEDENT except curses . error : NEW_LINE INDENT print ( " Invalid ▁ command : ▁ " + command ) NEW_LINE DEDENT if dic [ command ] : NEW_LINE INDENT print ( dic [ command ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT break NEW_LINE DEDENT stdscr . keypad ( 1 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr , n = symbols ( ' arr ▁ n ' , integer = True , positive = True ) NEW_LINE sum , prev = arr , arr NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] <= prev : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum , sum = sum + prev , sum NEW_LINE DEDENT else : NEW_LINE INDENT sum , sum = sum + arr [ i ] , sum NEW_LINE prev , prev = arr [ i ] , prev + 1 NEW_LINE DEDENT DEDENT assert minsum ( arr , n ) == sum NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT k = 7 NEW_LINE res = find_n ( k ) NEW_LINE if res == - 1 : NEW_LINE INDENT assert " Not ▁ possible " in res NEW_LINE DEDENT else : NEW_LINE INDENT assert res == 1 NEW_LINE DEDENT DEDENT
def get_subset_XOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max_ele : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << int ( math . log ( max_ele , 2 ) / math . log ( 2 ) + 1 ) ) - 1 NEW_LINE dp = [ [ 0 ] * ( n + 1 ) + [ 0 ] * ( m + 1 ) + [ 0 ] * ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT for k in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT for k in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if k != 0 : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE D = int ( sys . argv [ 1 ] ) NEW_LINE G = int ( sys . argv [ 2 ] ) NEW_LINE p = [ ] NEW_LINE c = [ ] NEW_LINE for i in range ( D ) : NEW_LINE INDENT p . append ( i ) NEW_LINE c . append ( i ) NEW_LINE DEDENT min = 1001 NEW_LINE count = 0 NEW_LINE ans = 0 NEW_LINE a = 4 NEW_LINE for i in range ( pow ( 2 , D ) ) : NEW_LINE INDENT bit = str ( i ) . replace ( ' ▁ ' , '0' ) NEW_LINE N = len ( bit ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT if bit [ j ] == '1' : NEW_LINE INDENT count += p [ j ] * ( j + 1 ) * 100 + c [ j ] NEW_LINE ans += p [ j ] NEW_LINE DEDENT DEDENT if count < G : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if bit [ j ] == '0' : NEW_LINE INDENT l = p [ j ] NEW_LINE while count < G and l > 0 : NEW_LINE INDENT count += ( j + 1 ) * 100 NEW_LINE ans += 1 NEW_LINE l -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if count >= G : NEW_LINE INDENT min = min ( ans , min ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 0 NEW_LINE DEDENT print ( min ) NEW_LINE DEDENT
def application ( environ , start_response ) : NEW_LINE INDENT start_response ( '200 ▁ OK ' , [ ( ' Content - Type ' , ' text / plain ' ) ] ) NEW_LINE data = environ [ ' wsgi . input ' ] . read ( ) NEW_LINE for key in data . keys ( ) : NEW_LINE INDENT k = 0 NEW_LINE a = data [ key ] NEW_LINE b = data [ key ] NEW_LINE for i in range ( a ) : NEW_LINE INDENT k += i NEW_LINE DEDENT if b == k : NEW_LINE INDENT return ' YES ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' NO ' NEW_LINE DEDENT DEDENT DEDENT
def test_omar ( ) : NEW_LINE INDENT input = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE size = input . shape [ 0 ] NEW_LINE count = 0 NEW_LINE arr = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] > arr [ 0 ] and arr [ i ] < arr [ size - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT assert count == size NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ GFG ▁ algorithm . """ NEW_LINE left = int ( np . power ( 2 , int ( np . log ( n ) / np . log ( 2 ) ) ) ) NEW_LINE right = left ** 2 NEW_LINE assert min ( ( n - left ) for n in range ( left , right + 1 ) ) == ( right - n ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if arr1 [ i ] == arr2 [ j ] : NEW_LINE INDENT if current + 1 > table [ j ] : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT if arr1 [ i ] > arr2 [ j ] : NEW_LINE INDENT if table [ j ] > current : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if table [ i ] > result : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT bit_count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bit_count += count_set_bits_util ( i ) NEW_LINE DEDENT return bit_count NEW_LINE DEDENT
def get_GFG ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ low ] NEW_LINE i , j = low - 1 , high + 1 NEW_LINE while True : NEW_LINE INDENT do : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while arr [ i ] < pivot : NEW_LINE INDENT do : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT while arr [ j ] > pivot : NEW_LINE INDENT if i >= j : NEW_LINE INDENT return j NEW_LINE DEDENT temp = arr [ i ] NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , temp NEW_LINE DEDENT DEDENT DEDENT quickSort ( arr , low , high ) NEW_LINE if low < high : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE quickSort ( arr , low , pi ) NEW_LINE quickSort ( arr , pi + 1 , high ) NEW_LINE DEDENT printArray ( arr , n ) NEW_LINE DEDENT
def gen_free_order ( array , position1 , position2 ) : NEW_LINE INDENT temp = array [ position1 ] NEW_LINE array [ position1 ] = array [ position2 ] NEW_LINE array [ position2 ] = temp NEW_LINE partition ( arr , low , high ) NEW_LINE i = ( low - 1 , high ) NEW_LINE for j in range ( low , high - 1 ) : NEW_LINE INDENT if arr [ j ] <= pivot : NEW_LINE INDENT i += 1 NEW_LINE swap ( arr , i , j ) NEW_LINE DEDENT DEDENT swap ( arr , i + 1 , high ) NEW_LINE return ( i + 1 , i ) NEW_LINE DEDENT
def GFG ( a , size ) : NEW_LINE INDENT max_so_far , max_ending_here = int ( a [ 0 ] ) , 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far , max_ending_here = max_ending_here , max_ending_here NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here , max_ending_here = 0 , 0 NEW_LINE DEDENT DEDENT return max_so_far , max_ending_here NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import os NEW_LINE import string NEW_LINE import re NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import sys NEW_LINE import os NEW_LINE import time NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string
def pyGFG ( N , SUM , K ) : NEW_LINE INDENT minSum = ( N * ( N + 1 ) ) / 2 NEW_LINE maxSum = ( N * K ) - ( N * ( N - 1 ) ) / 2 NEW_LINE if minSum > SUM or maxSum < SUM : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT arr = [ i for i in range ( N + 1 ) ] NEW_LINE sum = minSum NEW_LINE for i in range ( N , - 1 , - 1 ) : NEW_LINE INDENT x = sum + ( K - i ) NEW_LINE if x < SUM : NEW_LINE INDENT sum = sum + ( K - i ) NEW_LINE arr [ i ] = K NEW_LINE K -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( SUM - sum ) NEW_LINE sum = SUM NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ greatest ▁ factorial ▁ minimization ▁ of ▁ polynomials . """ NEW_LINE COST = 3 NEW_LINE def f ( x , y , z ) : NEW_LINE INDENT type1 = x // COST NEW_LINE x %= COST NEW_LINE type2 = y // COST NEW_LINE y %= COST NEW_LINE type3 = z // COST NEW_LINE z %= COST NEW_LINE type4 = min ( x , min ( y , z ) ) NEW_LINE max_items = type1 + type2 + type3 + type4 NEW_LINE return max_items NEW_LINE DEDENT assert f ( [ 1 , 2 , 3 , 4 ] ) == [ 1 , 2 , 3 , 4 ] NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT A = Queue ( ) NEW_LINE B = Queue ( ) NEW_LINE total_time = 0 NEW_LINE while not A . empty ( ) : NEW_LINE INDENT x = A . get ( ) NEW_LINE y = B . get ( ) NEW_LINE if x == y : NEW_LINE INDENT A . remove ( ) NEW_LINE B . remove ( ) NEW_LINE total_time += 1 NEW_LINE DEDENT else : NEW_LINE INDENT A . remove ( ) NEW_LINE A . put ( x ) NEW_LINE total_time += 2 NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT c = int ( 2 * y0 * x0 ) NEW_LINE assert str ( y0 ) == " x " + " ▁ + ▁ " + str ( x0 ) + " y ▁ = ▁ " + str ( c ) NEW_LINE DEDENT
def main ( agrs ) : NEW_LINE INDENT f = open ( ' / home / jeko / Downloads / test . txt ' , ' r ' ) NEW_LINE n = len ( f ) NEW_LINE set = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = f . read ( ) NEW_LINE l = len ( s ) NEW_LINE x = [ 0 ] * 26 NEW_LINE s1 = " " NEW_LINE for j in range ( l ) : NEW_LINE INDENT c = s [ j ] - ' a ' NEW_LINE x [ c ] += 1 NEW_LINE DEDENT for j in range ( 26 ) : NEW_LINE INDENT if x [ j ] > 0 : NEW_LINE INDENT s1 += chr ( ord ( ' a ' ) + j ) NEW_LINE DEDENT DEDENT set . add ( s1 ) NEW_LINE DEDENT print ( len ( set ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE q = 0 NEW_LINE for line in sys . stdin : NEW_LINE INDENT getopt . getopt ( line , " q " ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT [ c , l , r ] = getopt . getopt ( sys . stdin , " ql : r : " ) ; NEW_LINE if not c : NEW_LINE INDENT print ( " Usage : " , sys . argv [ 0 ] , " - q " ) NEW_LINE return NEW_LINE DEDENT if not l : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not r : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not r : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not r : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not l : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not r : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not r : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not c : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not l : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not r : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not c : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not r : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not l : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not r : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not c : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not r : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not c : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT if not r : NEW_LINE INDENT print ( " No ▁ line ▁ to ▁ read " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT
def get_GFG ( s ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for c in s : NEW_LINE INDENT unique . add ( c ) NEW_LINE DEDENT if len ( unique ) > 1 : NEW_LINE INDENT return unique NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def test_find_majority ( arr , n ) : NEW_LINE INDENT arr = arr [ n // 2 ] NEW_LINE n = len ( arr ) NEW_LINE assert find_majority ( arr , n ) == n NEW_LINE DEDENT
def get_solution ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ a ▁ list ▁ of ▁ all ▁ possible ▁ solutions ▁ for ▁ the ▁ current ▁ node . STRNEWLINE ▁ """ NEW_LINE nodes_colors = [ ] NEW_LINE visited = [ ] NEW_LINE neighborstring = [ ] NEW_LINE start_indices = [ ] NEW_LINE edges_to_print = [ ] NEW_LINE mod = 998244353 NEW_LINE parents = set ( ) NEW_LINE cycle_set = set ( ) NEW_LINE neighborpriority = [ ] NEW_LINE min_points_to_enter_room = [ ] NEW_LINE max_points_to_enter_room = [ ] NEW_LINE point_of_each_room = [ ] NEW_LINE neighbors = [ ] NEW_LINE memo = [ ] NEW_LINE for i in range ( count ) : NEW_LINE INDENT s = nodes_colors [ i ] NEW_LINE no = int ( s [ 0 ] ) NEW_LINE if s [ 1 ] == ' South ' : NEW_LINE INDENT pos += no NEW_LINE if pos > 20000 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif s [ 1 ] == ' North ' : NEW_LINE INDENT pos -= no NEW_LINE if pos < 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if pos == 0 or pos == 20000 : NEW_LINE INDENT pos = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if pos == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT return nodes_colors , visited , neighborstring , start_indices , edges_to_print , mod , parents , cycle_set , min_points_to_enter_room , max_points_to_enter_room , point_of_each_room , neighbors , memo NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import numpy NEW_LINE class solution : NEW_LINE INDENT def count_subarrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if bitwise_or >= K : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( count_subarrays ( arr , n , k ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = [ a for a in range ( 3 ) ] NEW_LINE arr = sorted ( arr ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] NEW_LINE k = k - diff NEW_LINE if k < 0 or k % 3 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def gen_free_graph ( ) : NEW_LINE INDENT adjacency = [ ] NEW_LINE insert = lambda x , y : adjacency . append ( [ x , y ] ) NEW_LINE dfs = { } NEW_LINE for node in adjacency [ node ] : NEW_LINE INDENT it = adjacency [ node ] [ node ] NEW_LINE if vis [ it ] == 0 : NEW_LINE INDENT dfs ( it , leaf , vis ) NEW_LINE leaf += [ node ] NEW_LINE DEDENT DEDENT if len ( adjacency [ node ] ) == 0 : NEW_LINE INDENT leaf = [ 1 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " The ▁ node ▁ % d ▁ has ▁ % d ▁ leaf ▁ nodes \n " % ( i , leaf [ i ] ) ) NEW_LINE DEDENT DEDENT
def main ( $ ) : NEW_LINE INDENT s = sys . stdin NEW_LINE v = s . readline ( ) NEW_LINE n = len ( v ) NEW_LINE for i , c in enumerate ( ( ' ' , ' \n ' ) ) : NEW_LINE INDENT if c != '1' : NEW_LINE INDENT print ( c ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( '1' ) NEW_LINE DEDENT
def test_garland ( ) : NEW_LINE INDENT s = nx . Graph ( ) NEW_LINE s1 = s . nodes ( ) NEW_LINE s2 = s . nodes ( ) NEW_LINE if is_valid ( s1 , s2 ) is False : NEW_LINE INDENT assert_equal ( - 1 , len ( s1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT m1 = { } NEW_LINE m2 = { } NEW_LINE for c in s1 : NEW_LINE INDENT if m1 . has_key ( c ) : NEW_LINE INDENT m1 [ c ] = m1 [ c ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 [ c ] = 1 NEW_LINE DEDENT DEDENT for c in s2 : NEW_LINE INDENT if m2 . has_key ( c ) : NEW_LINE INDENT m2 [ c ] = m2 [ c ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m2 [ c ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE hs = set ( ) NEW_LINE for c in s2 : NEW_LINE INDENT if not hs . isdisjoint ( c ) : NEW_LINE INDENT hs . add ( c ) NEW_LINE x1 = m1 [ c ] NEW_LINE x2 = m2 [ c ] NEW_LINE x1 = min ( x1 , x2 ) NEW_LINE ans += x1 NEW_LINE DEDENT DEDENT assert_equal ( ans , 0 ) NEW_LINE DEDENT DEDENT
def LCS_3Strings ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * m +
def test_cf596B ( ) : NEW_LINE INDENT x = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE n = len ( x ) NEW_LINE arr = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE answer = np . abs ( arr [ 0 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += np . abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT assert answer == 1 NEW_LINE DEDENT
def GFG ( n , a ) : NEW_LINE INDENT sum , c1 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE if a [ i ] == 1 : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if sum % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( sum / 2 ) % 2 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if c1 > 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE arr = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr . append ( sys . argv [ i ] ) NEW_LINE DEDENT dp = [ 0 ] * 5 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 1 ] = dp [ 1 ] + ( arr [ i ] == 1 ) NEW_LINE dp [ 2 ] = max ( dp [ 1 ] , dp [ 2 ] + ( arr [ i ] == 2 ) ) NEW_LINE dp [ 3 ] = max ( dp [ 2 ] , dp [ 3 ] + ( arr [ i ] == 1 ) ) NEW_LINE dp [ 4 ] = max ( dp [ 3 ] , dp [ 4 ] + ( arr [ i ] == 2 ) ) NEW_LINE DEDENT print ( dp [ 4 ] ) NEW_LINE DEDENT
def test_GFG ( min , max , steps ) : NEW_LINE INDENT a , b , even , odd = steps NEW_LINE beven , aeven = True , False , False NEW_LINE n = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = steps [ i ] NEW_LINE if not ( aeven or ( a & 1 ) > 0 ) : NEW_LINE INDENT aeven = True NEW_LINE DEDENT if beven : NEW_LINE INDENT if ( b & 1 ) > 0 : NEW_LINE INDENT beven = False NEW_LINE DEDENT DEDENT elif not ( ( a & 1 ) > 0 ) : NEW_LINE INDENT if not ( ( b & 1 ) > 0 ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) > 0 : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT DEDENT if beven : NEW_LINE INDENT even = int ( max ) // 2 - int ( min - 1 ) // 2 NEW_LINE odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT even = int ( max ) // 2 - int ( min - 1 ) // 2 NEW_LINE odd = 0 NEW_LINE DEDENT if not ( beven ^ aeven ) : NEW_LINE INDENT even += max - min + 1 - int ( max ) // 2 + int ( min - 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT odd += max - min + 1 - int ( max ) // 2 + int ( min - 1 ) NEW_LINE DEDENT assert even == odd NEW_LINE DEDENT
def test_JohnyLikesNumbers ( ) : NEW_LINE INDENT import sympy NEW_LINE n , k = symbols ( ' n ▁ k ' , integer = True , positive = True ) ; NEW_LINE assert ( n / k + 1 ) ** k == 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT prime = [ True for i in range ( B + 1 ) ] NEW_LINE p_factors = [ 0 for i in range ( B + 1 ) ] NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if p_factors [ p ] == 0 : NEW_LINE INDENT for i in range ( p , B + 1 , p ) : NEW_LINE INDENT p_factors [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if p_factors [ i ] == K : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def get_reverse_words ( str ) : NEW_LINE INDENT st = Stack ( ) NEW_LINE for c in str : NEW_LINE INDENT if c not in st : NEW_LINE INDENT st . push ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT while st . empty ( ) == False : NEW_LINE INDENT print ( st . pop ( ) ) NEW_LINE DEDENT print ( " ▁ " ) NEW_LINE DEDENT DEDENT while st . empty ( ) == False : NEW_LINE INDENT print ( st . pop ( ) ) NEW_LINE DEDENT DEDENT
def test_task ( ) : NEW_LINE INDENT n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE p = [ 1 , 2 , 3 , 4 ] NEW_LINE only_fist_solve = 0 NEW_LINE only_second_solve = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = solve ( p [ i ] , p [ i ] ) NEW_LINE if p [ i ] == 1 and r == 0 : NEW_LINE INDENT only_fist_solve += 1 NEW_LINE DEDENT elif p [ i ] == 0 and r == 1 : NEW_LINE INDENT only_second_solve += 1 NEW_LINE DEDENT DEDENT if only_fist_solve == 0 : NEW_LINE INDENT assert - 1 == n NEW_LINE DEDENT else : NEW_LINE INDENT assert ( only_second_solve + only_fist_solve ) / only_fist_solve == n NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT N = int ( sys . argv [ 1 ] ) NEW_LINE DEDENT except : NEW_LINE INDENT N = 1e7 NEW_LINE DEDENT IsPrime = [ ] NEW_LINE def Is_prime ( ) : NEW_LINE INDENT x = ( n <= 2 ) NEW_LINE n += 1 NEW_LINE sys . stdout . write ( x ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if IsPrime [ i ] : NEW_LINE INDENT sys . stdout . write ( 1 + " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( 2 + " ▁ " ) NEW_LINE DEDENT DEDENT sys . stdout . close ( ) NEW_LINE DEDENT def Is_prime ( ) : NEW_LINE INDENT IsPrime = [ ] NEW_LINE del IsPrime NEW_LINE IsPrime . append ( False ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if IsPrime [ i ] : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT IsPrime . append ( False ) NEW_LINE DEDENT DEDENT DEDENT DEDENT class IRead ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT self . input = open ( * args ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not self . input . readline ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . input . readline ( ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return self . input . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return str ( self . input . readline ( ) ) NEW_LINE DEDENT DEDENT sys . stdin . close ( ) NEW_LINE sys . stdout . close ( ) NEW_LINE sys . stderr . close ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE h , w , c , ans = getopt . getopt ( sys . argv [ 1 : ] , ' c : ' , [ ' color _ order ' , ' map ' , ' tmp ' ] ) NEW_LINE if not h : NEW_LINE INDENT h = sys . argv [ 1 : ] NEW_LINE DEDENT if not w : NEW_LINE INDENT w = sys . argv [ 1 : ] NEW_LINE DEDENT if not c : NEW_LINE INDENT c = sys . argv [ 1 : ] NEW_LINE DEDENT if not ans : NEW_LINE INDENT return NEW_LINE DEDENT if not count ( c ) : NEW_LINE INDENT return NEW_LINE DEDENT color_order = c NEW_LINE map = { } NEW_LINE tmp = [ ] NEW_LINE for n in c : NEW_LINE INDENT if len ( n ) > 1 : NEW_LINE INDENT map [ n ] = float ( n [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT sw = n [ 0 ] NEW_LINE try : NEW_LINE INDENT sw = float ( sw ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if sw == '0' : NEW_LINE INDENT x = stack ( ) NEW_LINE y = stack ( ) NEW_LINE map [ x + y ] = y NEW_LINE DEDENT elif sw == '1' : NEW_LINE INDENT x = stack ( ) NEW_LINE y = stack ( ) NEW_LINE map [ y - x ] = x NEW_LINE DEDENT elif sw == '2' : NEW_LINE INDENT x = stack ( ) NEW_LINE y = stack ( ) NEW_LINE map [ y * x ] = y * x NEW_LINE DEDENT elif sw == '3' : NEW_LINE INDENT x = stack ( ) NEW_LINE y = stack ( ) NEW_LINE map [ y / x ] = y / x NEW_LINE DEDENT DEDENT ans = stack ( ) NEW_LINE print ( ' % .6f ' % ans ) NEW_LINE DEDENT
def test_function_height ( ) : NEW_LINE INDENT x = Symbol ( ' x ' ) NEW_LINE n = Symbol ( ' n ' , integer = True ) NEW_LINE k = Symbol ( ' k ' , integer = True ) NEW_LINE assert n . is_even is True NEW_LINE assert ( k . is_even if n . is_even else k / n ) . is_even is True NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT N = 4 NEW_LINE assert find_nth_term ( N ) == [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 81 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 89 , 90 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 89 , 90 , 81 , 82 , 83 , 84 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 , 85 ,
def GFG ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] >= arr [ i ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if len > 1 : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) / 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ maximize ▁ of ▁ a ▁ polynomial ▁ in ▁ the ▁ GF ▁ ( 1 - x ) . """ NEW_LINE c = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c . append ( A2 [ i ] - A1 [ i ] ) NEW_LINE sum += A1 [ i ] NEW_LINE DEDENT temp = None NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if c [ i ] < c [ i + 1 ] : NEW_LINE INDENT temp = c [ i ] NEW_LINE c [ i ] , c [ i + 1 ] = c [ i + 1 ] , c [ i + 1 ] NEW_LINE c [ i + 1 ] , c [ i + 1 ] = temp NEW_LINE DEDENT DEDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += c [ i ] NEW_LINE if i + 1 >= ( n - x ) : NEW_LINE INDENT maxi = max ( sum , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT f = open ( ' / proc / cpuinfo ' , ' r ' ) NEW_LINE t = int ( f . readline ( ) ) NEW_LINE while t : NEW_LINE INDENT t = f . readline ( ) NEW_LINE x = int ( t ) NEW_LINE s = str ( x ) NEW_LINE extra = len ( s ) NEW_LINE temp = ord ( s [ 0 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , temp ) : NEW_LINE INDENT ans += 10 NEW_LINE DEDENT ans += ( extra ) * ( extra + 1 ) / 2 NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( ' ERROR : ▁ % s \n ' % msg ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT N = int ( args [ 0 ] ) NEW_LINE K = [ ] NEW_LINE for o , a in opts : NEW_LINE INDENT if o == ' - d ' : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT K . append ( INFINITY ) NEW_LINE DEDENT DEDENT DEDENT m = int ( args [ 1 ] ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT str = args [ i ] . strip ( ) . split ( ' , ' ) NEW_LINE a = int ( str [ 0 ] ) - 1 NEW_LINE b = int ( str [ 1 ] ) - 1 NEW_LINE K . append ( a ) NEW_LINE K . append ( b ) NEW_LINE K . append ( a ) NEW_LINE DEDENT str = args [ m ] . strip ( ) . split ( ' , ' ) NEW_LINE start = int ( str [ 0 ] ) - 1 NEW_LINE goal = int ( str [ 1 ] ) - 1 NEW_LINE V = int ( str [ 2 ] ) NEW_LINE P = int ( str [ 3 ] ) NEW_LINE for k in range ( N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if K [ i ] [ j ] > K [ i ] [ k ] + K [ k ] [ j ] : NEW_LINE INDENT K [ i ] [ j ] = K [ i ] [ k ] + K [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( V - P - K [ start ] [ goal ] - K [ goal ] [ start ] ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT input = sys . stdin NEW_LINE r1 , r2 , c1 , c2 , d1 , d2 = input NEW_LINE if ( c1 + c2 - r1 - r2 ) != 0 or ( d1 + d2 - r1 - r2 ) != 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE t , z = ( r2 - d2 + c2 ) // 2 , d2 - c2 + t , c2 - t , r1 + r2 - y - z - t NEW_LINE box = [ x , y , z , t ] NEW_LINE for gem in box : NEW_LINE INDENT if gem > 9 or gem < 1 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( x == y ) or ( x == z ) or ( x == t ) or ( y == z ) or ( y == t ) or ( z == t ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT if flag : NEW_LINE INDENT print ( x , y , z , t ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT n , m = int ( line . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ int ( x ) for x in line . split ( ) ] NEW_LINE w = [ int ( x ) for x in line . split ( ) ] NEW_LINE common_additions = None NEW_LINE for i in range ( n ) : NEW_LINE INDENT additions = [ ] NEW_LINE b_just = calc_nearest_weight ( a [ i ] , w , 0 , 0 , additions ) NEW_LINE if not b_just : NEW_LINE INDENT if common_additions is None : NEW_LINE INDENT common_additions = additions NEW_LINE DEDENT else : NEW_LINE INDENT common_additions . append ( additions ) NEW_LINE DEDENT DEDENT if common_additions is None : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if common_additions : NEW_LINE INDENT print ( common_additions [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT sys . stdin . close ( ) NEW_LINE DEDENT def calc_nearest_weight ( x , w , i , sum , additions ) : NEW_LINE INDENT if x == sum : NEW_LINE INDENT return True NEW_LINE DEDENT if i == len ( w ) : NEW_LINE INDENT additions . append ( abs ( x - sum ) ) NEW_LINE return False NEW_LINE DEDENT if calc_nearest_weight ( x , w , i + 1 , sum , additions ) : NEW_LINE INDENT return True NEW_LINE DEDENT if calc_nearest_weight ( x , w , i + 1 , sum + w [ i ] , additions ) : NEW_LINE INDENT return True NEW_LINE DEDENT return calc_nearest_weight ( x , w , i + 1 , sum - w [ i ] , additions ) NEW_LINE DEDENT DEDENT
def get_DP ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import os NEW_LINE import string NEW_LINE N = len ( sys . argv ) NEW_LINE dp = [ ] NEW_LINE del dp [ 0 ] NEW_LINE dp . append ( 0 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT price = sys . argv [ i ] NEW_LINE s = sys . argv [ i + 1 ] NEW_LINE mask = 0 NEW_LINE if s . find ( ' A ' ) != - 1 : NEW_LINE INDENT mask |= 1 NEW_LINE DEDENT if s . find ( ' B ' ) != - 1 : NEW_LINE INDENT mask |= 2 NEW_LINE DEDENT if s . find ( ' C ' ) != - 1 : NEW_LINE INDENT mask |= 4 NEW_LINE DEDENT for k in ( 1 , 3 ) : NEW_LINE INDENT if dp [ k ] != int ( s ) : NEW_LINE INDENT t = k | mask NEW_LINE dp [ t ] = min ( dp [ t ] , dp [ k ] + price ) NEW_LINE DEDENT DEDENT DEDENT out = ' ' NEW_LINE class Scanner : NEW_LINE INDENT def __init__ ( self , s ) : NEW_LINE INDENT self . s = s NEW_LINE DEDENT def read ( self ) : NEW_LINE INDENT if not self . s or not self . s . endswith ( ' \n ' ) : NEW_LINE INDENT self . s = self . s [ : - 1 ] NEW_LINE DEDENT return self . s NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . s or not self . s : NEW_LINE INDENT self . s = self . s . split ( ' \n ' ) NEW_LINE DEDENT return self . s NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return int ( next ( self . s ) ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return int ( next ( self . s ) ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return next ( self . s ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return next ( self . s ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return next ( self . s ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return next ( self . s ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return next ( self . s ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return next ( self . s ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return next ( self . s ) NEW_LINE DEDENT DEDENT return Scanner ( ' ' ) , Scanner ( ' ' ) NEW_LINE DEDENT
def pyGFG ( str , pre ) : NEW_LINE INDENT str_len = len ( str ) NEW_LINE pre_len = len ( pre ) NEW_LINE i , j = 0 , 0 NEW_LINE while i < str_len and j < pre_len : NEW_LINE INDENT if str [ i ] != pre [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def pyGG_is_string ( str , suff ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE j = len ( suff ) - 1 NEW_LINE while i >= 0 and j >= 0 : NEW_LINE INDENT if str [ i ] != suff [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def pyGG_check_string ( str , a , b ) : NEW_LINE INDENT if len ( str ) != len ( a ) + len ( b ) : NEW_LINE INDENT return False NEW_LINE DEDENT if startswith ( str , a ) : NEW_LINE INDENT if endswith ( str , b ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if startswith ( str , b ) : NEW_LINE INDENT if endswith ( str , a ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def pyGG_is_string ( str , a , b ) : NEW_LINE INDENT if check_string ( str , a , b ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def pyGG_is_string ( str , a , b ) : NEW_LINE INDENT if check_string ( str , a , b ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def pyGG_is_string ( str , a , b ) : NEW_LINE INDENT if check_string ( str , a , b ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def pyGG_is_string ( str , a , b ) : NEW_LINE INDENT if check_string ( str , a , b ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def pyGG_is_string ( str , a , b ) : NEW_LINE INDENT if check_string ( str , a , b ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def pyGG_is_string ( str , a , b ) : NEW_LINE INDENT if check_string ( str , a , b ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def pyGG_is_string ( str , a , b ) : NEW_LINE INDENT if check_string ( str , a , b ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if i % 3 != 0 : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if j % 3 != 0 : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if k % 3 != 0 and ( i + j + k ) == n : NEW_LINE INDENT print ( i , j , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 3 NEW_LINE assert count_integral_solutions ( n ) == 0 NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT def digitsum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n : NEW_LINE INDENT sum += n % TEN NEW_LINE n /= TEN NEW_LINE DEDENT return sum NEW_LINE DEDENT def get_nth_term ( n ) : NEW_LINE INDENT sum = digitsum ( n ) NEW_LINE if sum % TEN == 0 : NEW_LINE INDENT return ( n * TEN ) NEW_LINE DEDENT extra = TEN - ( sum % TEN ) NEW_LINE return ( ( n * TEN ) + extra ) NEW_LINE DEDENT def first_n_terms ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( get_nth_term ( i ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 10 NEW_LINE first_n_terms ( n ) NEW_LINE DEDENT DEDENT
def GFG ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while a : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( msg + ' \n ' ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT res = [ ] NEW_LINE p = [ ] NEW_LINE for o , a in opts : NEW_LINE INDENT if o == ' - d ' : NEW_LINE INDENT res . append ( a ) NEW_LINE DEDENT elif o == ' - u ' : NEW_LINE INDENT res . append ( u ) NEW_LINE DEDENT elif o == ' - e ' : NEW_LINE INDENT res . append ( e ) NEW_LINE DEDENT elif o == ' - b ' : NEW_LINE INDENT res . append ( b ) NEW_LINE DEDENT elif o == ' - f ' : NEW_LINE INDENT res . append ( f ) NEW_LINE DEDENT elif o == ' - d ' : NEW_LINE INDENT res . append ( d ) NEW_LINE DEDENT elif o == ' - e ' : NEW_LINE INDENT res . append ( e ) NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( res ) ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] + f [ i ] NEW_LINE DEDENT sys . stdout . write ( ' \n ' ) NEW_LINE T = len ( res ) NEW_LINE while T -- != 0 : NEW_LINE INDENT sys . stdout . write ( res [ T ] ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = ' Convert ▁ a ▁ date ▁ to ▁ a ▁ string . ' ) NEW_LINE parser . add_argument ( ' - - date ' , required = True , help = ' The ▁ date ▁ to ▁ convert . ' ) NEW_LINE parser . add_argument ( ' - - date _ format ' , required = True , help = ' The ▁ date ▁ format ▁ to ▁ use . ' ) NEW_LINE parser . add_argument ( ' - - date _ format _ version ' , required = True , help = ' The ▁ version ▁ of ▁ the ▁ date ▁ format ▁ to ▁ use . ' ) NEW_LINE args = parser . parse_args ( ) NEW_LINE s = datetime . datetime . strptime ( args . date , args . date_format ) NEW_LINE s = s . replace ( '2017' , '2018' ) NEW_LINE print ( s ) NEW_LINE DEDENT
def test_nonreapating_c_queue ( ) : NEW_LINE INDENT from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import abc NEW_LINE from collections import abc NEW_LINE from collections import deque NEW_LINE from collections import abc NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import abc NEW_LINE from collections import abc NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import abc NEW_LINE from collections import abc NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import abc NEW_LINE from collections import abc NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import abc NEW_LINE from collections import abc NEW_LINE from collections import abc NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import abc NEW_LINE from collections import abc NEW_LINE from collections import abc NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE DEDENT
def cf862B ( ) : NEW_LINE INDENT import sys NEW_LINE import pickle NEW_LINE import struct NEW_LINE import random NEW_LINE import time NEW_LINE import hashlib NEW_LINE import pickle NEW_LINE import struct NEW_LINE import random NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ GF ▁ algorithm . """ NEW_LINE val = np . arange ( 1 , 5 ) NEW_LINE range = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE c = 1 NEW_LINE for i in range ( len ( range ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT range [ i ] = 2 * range [ i ] NEW_LINE val -= range [ i ] NEW_LINE if val <= 0 : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if val > 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT if len ( args ) != 2 : NEW_LINE INDENT print ( " Usage : ▁ % s ▁ < input > " % sys . argv [ 0 ] ) NEW_LINE return NEW_LINE DEDENT ans1 = 0 NEW_LINE ans2 = int ( args [ 0 ] ) NEW_LINE temp = ans2 NEW_LINE for i in range ( len ( args ) / 2 ) : NEW_LINE INDENT e = args [ 2 * i + 1 ] NEW_LINE k = int ( args [ 2 * i + 2 ] ) NEW_LINE if e == ' + ' : NEW_LINE INDENT ans2 += k NEW_LINE ans1 += temp NEW_LINE temp = k NEW_LINE DEDENT else : NEW_LINE INDENT ans2 *= k NEW_LINE temp *= k NEW_LINE DEDENT DEDENT ans1 += temp NEW_LINE bob_ans = int ( args [ 1 ] ) NEW_LINE output = ' ' NEW_LINE if bob_ans == ans1 : NEW_LINE INDENT if bob_ans == ans2 : NEW_LINE INDENT output = ' U ' NEW_LINE DEDENT else : NEW_LINE INDENT output = ' M ' NEW_LINE DEDENT DEDENT elif bob_ans == ans2 : NEW_LINE INDENT output = ' L ' NEW_LINE DEDENT else : NEW_LINE INDENT output = ' I ' NEW_LINE DEDENT print ( output ) NEW_LINE DEDENT
def test_min_stack ( ) : NEW_LINE INDENT from sympy . utilities . randtest import default_sort_key NEW_LINE from sympy . core . function import Sum NEW_LINE from sympy . core . limits import oo NEW_LINE from sympy . core . compatibility import assuming NEW_LINE from sympy . core . compatibility import assuming NEW_LINE from sympy . core . compatibility import Wild NEW_LINE from sympy . core . function import Function NEW_LINE from sympy . core . function import Derivative NEW_LINE from sympy . core . function import Function NEW_LINE from sympy . core . compatibility import assuming NEW_LINE from sympy . core . function import Derivative NEW_LINE from sympy . core . function import Function NEW_LINE from sympy . core . function import Derivative NEW_LINE from sympy . core . function import Sum NEW_LINE from sympy . core . function import Sum NEW_LINE from sympy . core . function import Sum NEW_LINE from sympy . core . function import Sum NEW_LINE m = MinStack ( ) NEW_LINE m . push ( - 2 ) NEW_LINE m . push ( 0 ) NEW_LINE m . push ( - 3 ) NEW_LINE assert m . min ( ) == 0 NEW_LINE m . pop ( ) NEW_LINE assert m . top == 0 NEW_LINE assert m . min ( ) == 0 NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT one = [ ' ' , ' one ▁ ' , ' two ▁ ' , ' three ▁ ' , ' four ▁ ' , ' five ▁ ' , ' six ▁ ' , ' seven ▁ ' , ' eight ▁ ' , ' nine ▁ ' , ' ten ▁ ' , ' eleven ▁ ' , ' twelve ▁ ' , ' thirteen ▁ ' , ' fourteen ▁ ' , ' fifteen ▁ ' , ' sixteen ▁ ' , ' seventeen ▁ ' , ' eighteen ▁ ' , ' nineteen ▁ ' ] NEW_LINE ten = [ ' ' , ' ' , ' twenty ▁ ' , ' thirty ▁ ' , ' forty ▁ ' , ' fifty ▁ ' , ' sixty ▁ ' , ' seventy ▁ ' , ' eighty ▁ ' , ' ninety ▁ ' ] NEW_LINE def num_to_words ( n , s ) : NEW_LINE INDENT str = ' ' NEW_LINE if n > 19 : NEW_LINE INDENT str += ten [ n // 10 ] + one [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] NEW_LINE DEDENT if n != 0 : NEW_LINE INDENT str += s NEW_LINE DEDENT return str NEW_LINE DEDENT def convert_to_words ( n ) : NEW_LINE INDENT out = ' ' NEW_LINE out += num_to_words ( int ( n / 10000000 ) , ' crore ▁ ' ) NEW_LINE out += num_to_words ( int ( ( n / 100000 ) % 100 ) , ' lakh ▁ ' ) NEW_LINE out += num_to_words ( int ( ( n / 1000 ) % 100 ) , ' thousand ▁ ' ) NEW_LINE out += num_to_words ( int ( ( n / 100 ) % 10 ) , ' hundred ▁ ' ) NEW_LINE if n > 100 and n % 100 > 0 : NEW_LINE INDENT out += ' and ▁ ' NEW_LINE DEDENT out += num_to_words ( int ( n % 100 ) , ' ' ) NEW_LINE return out NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 438237764 NEW_LINE print ( convert_to_words ( n ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( a ) : NEW_LINE INDENT neg = 0 NEW_LINE tmp = a < 0 NEW_LINE while a != 0 : NEW_LINE INDENT neg += tmp NEW_LINE a += tmp NEW_LINE DEDENT return neg NEW_LINE DEDENT def are_different_sign ( a , b ) : NEW_LINE INDENT return ( ( a < 0 and b > 0 ) or ( a > 0 and b < 0 ) ) NEW_LINE DEDENT def sub ( a , b ) : NEW_LINE INDENT return a + flip_sign ( b ) NEW_LINE DEDENT def mul ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT return mul ( b , a ) NEW_LINE DEDENT sum = 0 NEW_LINE for i in abs ( b ) : NEW_LINE INDENT sum += a NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT sum = flip_sign ( sum ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def division ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT raise ZeroDivisionError NEW_LINE DEDENT quotient , dividend = 0 , 0 NEW_LINE divisor = flip_sign ( abs ( b ) ) NEW_LINE for dividend in abs ( a ) , dividend >= abs ( divisor ) : NEW_LINE INDENT quotient += 1 NEW_LINE DEDENT if are_different_sign ( a , b ) : NEW_LINE INDENT quotient = flip_sign ( quotient ) NEW_LINE DEDENT return quotient NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT print ( " Subtraction ▁ is ▁ % d " % sub ( 4 , - 2 ) ) NEW_LINE print ( " Product ▁ is ▁ % d " % mul ( - 9 , 6 ) ) NEW_LINE try : NEW_LINE INDENT print ( " Division ▁ is ▁ % d " % division ( 8 , 2 ) ) NEW_LINE DEDENT except ZeroDivisionError : NEW_LINE INDENT print ( " Exception ▁ : - ▁ Divide ▁ by ▁ 0" ) NEW_LINE DEDENT DEDENT
def test_factorial ( ) : NEW_LINE INDENT i , fact = symbols ( ' i ▁ fact ' , integer = True , positive = True ) NEW_LINE while n / i != n : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT assert fact ( 5 ) == factorial ( 5 ) NEW_LINE DEDENT
def GFG ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( number % x == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def test_b272 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE N = symbols ( ' N ' , integer = True , positive = True ) NEW_LINE stat = [ 0 ] * 30 NEW_LINE for n in range ( N ) : NEW_LINE INDENT a = symbols ( ' a ' , integer = True , positive = True ) NEW_LINE stat [ int ( a ) ] += 1 NEW_LINE DEDENT answer = 0 NEW_LINE for count in stat : NEW_LINE INDENT answer += count * ( count - 1 ) NEW_LINE DEDENT answer /= 2 NEW_LINE assert answer == 0 NEW_LINE DEDENT
def pygfG ( arr , n , k ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if arr [ i ] > arr [ i - 1 ] : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k NEW_LINE if ( arr [ i ] - arr [ i - 1 ] ) % k != 0 : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT res = res + noOfSubtraction NEW_LINE DEDENT return res NEW_LINE DEDENT
def GFG ( arr , n , X ) : NEW_LINE INDENT N = int ( math . pow ( 2 , n ) ) NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT if arr [ j ] == X : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT n = 5 NEW_LINE max , result = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j - 3 ) >= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] NEW_LINE if max < result : NEW_LINE INDENT max , result = result , max NEW_LINE DEDENT DEDENT if ( i - 3 ) >= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] NEW_LINE if max < result : NEW_LINE INDENT max , result = result , max NEW_LINE DEDENT DEDENT if ( i - 3 ) >= 0 and ( j - 3 ) >= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] NEW_LINE if max < result : NEW_LINE INDENT max , result = result , max NEW_LINE DEDENT DEDENT if ( i - 3 ) >= 0 and ( j - 1 ) <= 0 : NEW_LINE INDENT result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] NEW_LINE if max < result : NEW_LINE INDENT max , result = result , max NEW_LINE DEDENT DEDENT DEDENT return max , result NEW_LINE DEDENT
def genmodular ( n , m ) : NEW_LINE INDENT """ Generate ▁ a ▁ modular ▁ graph ▁ of ▁ n ▁ and ▁ m ▁ modular ▁ primes . STRNEWLINE STRNEWLINE ▁ > > > ▁ from ▁ sympy . ntheory . modular ▁ import ▁ genmodular STRNEWLINE ▁ > > > ▁ from ▁ sympy . ntheory . modular ▁ import ▁ modular STRNEWLINE ▁ > > > ▁ from ▁ sympy . abc ▁ import ▁ x , ▁ y STRNEWLINE ▁ > > > ▁ genmodular ( 2 , ▁ 2 ) STRNEWLINE ▁ ( 2 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ genmodular ( 2 , ▁ 2 ) STRNEWLINE ▁ ( 2 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ genmodular ( 2 , ▁ 2 ) STRNEWLINE ▁ ( 2 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ genmodular ( 2 , ▁ 2 ) STRNEWLINE ▁ ( 2 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ genmodular ( 2 , ▁ 2 ) STRNEWLINE ▁ ( 2 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ genmodular ( 2 , ▁ 2 ) STRNEWLINE ▁ ( 2 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ genmodular ( 2 , ▁ 2 ) STRNEWLINE ▁ ( 2 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ genmodular ( 2 , ▁ 2 ) STRNEWLINE ▁ ( 2 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ genmodular ( 2 , ▁ 2 ) STRNEWLINE ▁ ( 2 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ genmodular ( 2 , ▁ 2 ) STRNEWLINE ▁ ( 2 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ genmodular ( 2 , ▁ 2 ) STRNEWLINE ▁ ( 2 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ genmodular ( 2 , ▁ 2 ) STRNEWLINE ▁ ( 2 , ▁ 2 ) STRNEWLINE ▁ """ NEW_LINE MAX = 50002 NEW_LINE primes = [ ] NEW_LINE def sieve ( x , y ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ a ▁ list ▁ of ▁ n ▁ x ▁ y ▁ where ▁ x ▁ and ▁ y ▁ are ▁ integers . STRNEWLINE ▁ """ NEW_LINE is_prime = [ ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT is_prime . append ( True ) NEW_LINE DEDENT for p in range ( 2 , len ( primes ) ) : NEW_LINE INDENT if is_prime [ p ] is True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT is_prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in
def GFG ( arr , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while i >= 0 and arr [ i ] % 2 == 1 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE for j in range ( 0 , i + 1 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE input = sys . stdin . read ( ) NEW_LINE t1 = input . split ( ) NEW_LINE t2 = input . split ( ) NEW_LINE date = datetime . datetime . strptime ( t1 [ 0 ] , " % Y - % m - % dT % H : % M : % SZ " ) NEW_LINE date = date . replace ( tzinfo = pytz . utc ) NEW_LINE print ( abs ( date . year - date . month ) / ( 1000 * 60 * 60 * 24 ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s = sys . stdin . read ( ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT al = [ ] NEW_LINE c = s [ i ] NEW_LINE if c in al : al . append ( c ) NEW_LINE for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT a = s [ j ] NEW_LINE if al : NEW_LINE INDENT if al [ - 1 ] == ' Q ' and a == ' A ' : al . append ( a ) NEW_LINE if al [ - 1 ] == ' A ' and a == ' Q ' : al . append ( a ) NEW_LINE if al [ - 1 ] == ' A ' and a == ' A ' : al . append ( a ) NEW_LINE DEDENT if al [ - 1 ] == ' A ' and a == ' A ' : al . append ( a ) NEW_LINE DEDENT if len ( al ) >= 3 and al [ 0 ] == ' Q ' and al [ - 1 ] == ' Q ' : NEW_LINE INDENT count = count + len ( al ) - 3 NEW_LINE al . pop ( - 1 ) NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Main ▁ function . STRNEWLINE STRNEWLINE ▁ : return : ▁ A ▁ tuple ▁ of ▁ ( n , ▁ k ) ▁ where ▁ n ▁ is ▁ the ▁ number ▁ of ▁ nodes ▁ in ▁ the ▁ graph . STRNEWLINE ▁ """ NEW_LINE with open ( ' / proc / self / stat ' , ' r ' ) as f : NEW_LINE INDENT n , k = map ( int , f . readline ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT if 1 == n : NEW_LINE INDENT print ( ( k > a [ 0 ] ) . rstrip ( ) ) NEW_LINE return NEW_LINE DEDENT a . sort ( ) NEW_LINE ng , ok = 0 , n + 1 NEW_LINE while ok - ng > 1 : NEW_LINE INDENT mid = ( ok + ng ) // 2 NEW_LINE if is_needed ( mid , n , k , a ) : NEW_LINE INDENT ok = mid NEW_LINE DEDENT else : NEW_LINE INDENT ng = mid NEW_LINE DEDENT DEDENT print ( ng ) NEW_LINE DEDENT def is_needed ( now , final , n , k , a ) : NEW_LINE INDENT dp = [ False for i in range ( n + 1 ) ] NEW_LINE for i in range ( k - 1 , max ( k - a [ now - 1 ] , 0 ) , 0 ) : NEW_LINE INDENT if dp [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT for i in range ( n + 1 , - 1 , - 1 ) : NEW_LINE INDENT if is_needed ( now , n , k , a ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE if j + a [ i - 1 ] <= k : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_solution ( ) : NEW_LINE INDENT n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE s = symbols ( ' s ' , integer = True , positive = True ) NEW_LINE k = symbols ( ' k ' , integer = True , positive = True ) NEW_LINE count = 0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT k = s / i NEW_LINE count += k NEW_LINE s -= k * i NEW_LINE DEDENT assert count == 0 NEW_LINE DEDENT
def get_GFG ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE multiply = 0 NEW_LINE size = len ( v ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT res = carry + v [ i ] * x NEW_LINE v [ i ] = res % 10 NEW_LINE carry = res / 10 NEW_LINE DEDENT while carry != 0 : NEW_LINE INDENT v . append ( carry % 10 ) NEW_LINE carry /= 10 NEW_LINE DEDENT return sum ( v ) NEW_LINE DEDENT
def test_b436 ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ B436 ▁ algorithm ▁ in ▁ the ▁ book . STRNEWLINE ▁ """ NEW_LINE x = symbols ( ' x ' ) NEW_LINE N = symbols ( ' N ' , integer = True ) NEW_LINE M = symbols ( ' M ' , integer = True ) NEW_LINE x = symbols ( ' x ' , integer = True , cls = Dummy ) NEW_LINE answer = [ ] NEW_LINE for n in range ( N ) : NEW_LINE INDENT S = x [ n ] NEW_LINE for m in range ( M ) : NEW_LINE INDENT c = S [ m ] NEW_LINE if c == ' L ' : NEW_LINE INDENT hit = m - n NEW_LINE DEDENT elif c == ' R ' : NEW_LINE INDENT hit = m + n NEW_LINE DEDENT elif c == ' U ' : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT answer . append ( hit ) NEW_LINE DEDENT DEDENT DEDENT DEDENT output = [ ] NEW_LINE for a in answer : NEW_LINE INDENT output . append ( a + ' ▁ ' ) NEW_LINE DEDENT assert output == [ ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' ] NEW_LINE DEDENT
def test_codeforces356A ( ) : NEW_LINE INDENT f = FastReader ( ) NEW_LINE n = len ( f ) NEW_LINE left = sorted ( f . keys ( ) ) NEW_LINE answer = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT left . append ( i ) NEW_LINE DEDENT q = len ( f ) NEW_LINE while q : NEW_LINE INDENT l , r = f [ q - 1 ] , f [ q ] NEW_LINE win = f [ win - 1 ] NEW_LINE while left . ceiling ( l ) and left . ceiling ( l ) <= r : NEW_LINE INDENT curr = left . ceiling ( l ) NEW_LINE answer . append ( win ) NEW_LINE left . remove ( curr ) NEW_LINE DEDENT answer . append ( win - 1 ) NEW_LINE left . append ( win - 1 ) NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans . append ( answer [ i ] + ' ▁ ' ) NEW_LINE DEDENT assert ans == [ ] NEW_LINE class FastReader : NEW_LINE INDENT st = [ ] NEW_LINE f = FastReader ( ) NEW_LINE DEDENT next = next ( f ) NEW_LINE while not f or not f . isclosed ( ) : NEW_LINE INDENT try : NEW_LINE INDENT f . next ( ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return f NEW_LINE DEDENT
def pytime_object_to_timespec ( * args , ** kw ) : NEW_LINE INDENT import time NEW_LINE f = open ( ' / proc / self / timespec ' , ' w ' ) NEW_LINE n = len ( args ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( time . time ( ) ) NEW_LINE DEDENT dp = [ - 1 ] * ( n + 1 ) NEW_LINE del a [ - 1 ] NEW_LINE dp [ n - 1 ] = a [ - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i + 1 ] , a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] > dp [ i + 1 ] : NEW_LINE INDENT f . write ( 0 + ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT f . write ( ( dp [ i + 1 ] - a [ i ] + 1 ) + ' ▁ ' ) NEW_LINE DEDENT DEDENT f . write ( ' \n ' ) NEW_LINE f . close ( ) NEW_LINE DEDENT
def pell_number ( n ) : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT return 2 * pell ( n - 1 ) + pell ( n - 2 ) NEW_LINE DEDENT
def main ( * args ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import os NEW_LINE import time NEW_LINE n = len ( args ) NEW_LINE square = n * n NEW_LINE odd = [ ] NEW_LINE even = [ ] NEW_LINE for i in range ( 1 , square + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT even . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . append ( i ) NEW_LINE DEDENT DEDENT loop = square // n NEW_LINE div = loop // 2 NEW_LINE debug ( div ) NEW_LINE for i in range ( 1 , loop + 1 ) : NEW_LINE INDENT for j in range ( div ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT sys . stdout . write ( ' % d ▁ % d ▁ ' % ( odd . pop ( 0 ) , ( even . pop ( 0 ) ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( ' % d ▁ % d ▁ ' % ( even . pop ( 0 ) , ( odd . pop ( 0 ) ) ) ) NEW_LINE DEDENT DEDENT sys . stdout . write ( ' \n ' ) NEW_LINE DEDENT sys . stdout . close ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ FastGS ▁ algorithm . """ NEW_LINE copy_arr = np . array ( [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] ) NEW_LINE asize = np . argsort ( copy_arr ) NEW_LINE n = 5 NEW_LINE print ( ' % d ▁ ' % n ) NEW_LINE for i in range ( asize ) : NEW_LINE INDENT if np . sum ( copy_arr [ : , i ] == n ) > 0 : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while n : NEW_LINE INDENT if ( n & 1 ) == 0 : NEW_LINE INDENT count += int ( math . pow ( 2 , k ) ) NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT DEDENT
def main ( * args ) : NEW_LINE INDENT import sys NEW_LINE f = sys . stdin NEW_LINE n , m , money = args NEW_LINE min , max = int ( max ) , int ( min ) , int ( max ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT min = min ( i ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT max = max ( i ) NEW_LINE DEDENT if money % min == 0 : NEW_LINE INDENT div = money / min NEW_LINE div = div * max NEW_LINE f . write ( max ( div , money ) ) NEW_LINE DEDENT else : NEW_LINE INDENT div = money / min NEW_LINE div = ( div * max ) + ( money % min ) NEW_LINE f . write ( max ( div , money ) ) NEW_LINE DEDENT f . close ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT global maximum , x , ans NEW_LINE graph = [ ] NEW_LINE weight = [ ] NEW_LINE __builtin_popcount ( x ) NEW_LINE for i in range ( 60 ) : NEW_LINE INDENT if ( ( x >> i ) & 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT def dfs ( node , parent ) : NEW_LINE INDENT a = __builtin_popcount ( weight [ node ] + x ) NEW_LINE if maximum < a : NEW_LINE INDENT maximum = a NEW_LINE ans = node NEW_LINE DEDENT elif maximum == a : NEW_LINE INDENT ans = min ( ans , node ) NEW_LINE DEDENT for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if graph [ node ] [ i ] == parent : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( graph [ node ] [ i ] , node ) NEW_LINE DEDENT DEDENT def dfs ( node , parent ) : NEW_LINE INDENT x = 15 NEW_LINE weight . append ( 0 ) NEW_LINE weight . append ( 5 ) NEW_LINE weight . append ( 10 ) ; NEW_LINE weight . append ( 11 ) ; NEW_LINE weight . append ( 8 ) NEW_LINE weight . append ( 6 ) NEW_LINE for i in range ( 100 ) : NEW_LINE INDENT graph . append ( [ ] ) NEW_LINE DEDENT graph [ 1 ] . append ( 2 ) NEW_LINE graph [ 2 ] . append ( 3 ) NEW_LINE graph [ 2 ] . append ( 4 ) NEW_LINE graph [ 1 ] . append ( 5 ) NEW_LINE dfs ( 1 , 1 ) NEW_LINE assert ans == 1 NEW_LINE DEDENT DEDENT
def GFG ( str , freq ) : NEW_LINE INDENT MAX = 26 NEW_LINE def updateFreq ( str , freq ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ str [ i ] - ' a ' ] += 1 NEW_LINE DEDENT DEDENT def maxCount ( str , patt ) : NEW_LINE INDENT strFreq = [ ] NEW_LINE updateFreq ( str , strFreq ) NEW_LINE pattFreq = [ ] NEW_LINE updateFreq ( patt , pattFreq ) NEW_LINE ans = int ( 0 ) NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if pattFreq [ i ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT ans = min ( ans , strFreq [ i ] / pattFreq [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def findFreq ( str , patt ) : NEW_LINE INDENT str = ' geeksforgeeks ' NEW_LINE patt = ' geeks ' NEW_LINE return [ int ( x ) for x in str . split ( patt ) ] NEW_LINE DEDENT return findFreq ( str , patt ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a . append ( sys . argv [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT b . append ( sys . argv [ i ] ) NEW_LINE DEDENT a1 , b1 , ans = 0 , 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a1 , b1 , ans = a1 | a , b1 | b NEW_LINE if a1 + b1 > ans : NEW_LINE INDENT ans = a1 + b1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def test_a354 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE N = symbols ( ' N ' , integer = True , positive = True ) NEW_LINE L = symbols ( ' L ' , integer = True , positive = True ) NEW_LINE R = symbols ( ' R ' , integer = True , positive = True ) NEW_LINE QL = symbols ( ' QL ' , integer = True , positive = True ) NEW_LINE QR = symbols ( ' QR ' , integer = True , positive = True ) NEW_LINE W = [ ] NEW_LINE sum = [ ] NEW_LINE for n in range ( N ) : NEW_LINE INDENT W . append ( x ** n ) NEW_LINE sum . append ( sum [ n ] + W [ n ] ) NEW_LINE DEDENT min = S . Infinity NEW_LINE for first_r in range ( 0 , N ) : NEW_LINE INDENT l_count = first_r NEW_LINE r_count = N - l_count NEW_LINE cand = sum [ l_count ] * L + ( sum [ N ] - sum [ l_count ] ) * R NEW_LINE ll_count = max ( 0 , l_count - r_count - 1 ) NEW_LINE rrd_count = max ( 0 , r_count - l_count - 1 ) NEW_LINE cand += ll_count * QL NEW_LINE cand += rrd_count * QR NEW_LINE min = min ( cand , min ) NEW_LINE DEDENT assert min == min NEW_LINE DEDENT
def GFG ( V , M , N ) : NEW_LINE INDENT wasted_amt , amt_per_min , time_to_fill = V , M - N NEW_LINE return wasted_amt , amt_per_min , time_to_fill NEW_LINE DEDENT
def GFG ( str , n ) : NEW_LINE INDENT count0 , count1 = 0 , 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT if count0 == count1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if count0 != count1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def py_small_min ( ) : NEW_LINE INDENT import sys NEW_LINE abc = [ x for x in range ( 3 ) if x != 0 ] NEW_LINE max = sys . maxint NEW_LINE min = sys . maxint NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if max < abc [ i ] : NEW_LINE INDENT max = abc [ i ] NEW_LINE DEDENT if min > abc [ i ] : NEW_LINE INDENT min = abc [ i ] NEW_LINE DEDENT DEDENT sys . maxsize = max NEW_LINE DEDENT
def GFG ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , s ) : NEW_LINE INDENT sum += n NEW_LINE if sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ maximum ▁ absolute ▁ value ▁ of ▁ the ▁ graph . """ NEW_LINE mn = S . Infinity NEW_LINE mx = S . Infinity NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i > 0 and arr [ i ] == - 1 and arr [ i - 1 ] != - 1 : NEW_LINE INDENT mn = min ( mn , arr [ i - 1 ] ) NEW_LINE mx = max ( mx , arr [ i - 1 ] ) NEW_LINE DEDENT if i < n - 1 and arr [ i ] == - 1 and arr [ i + 1 ] != - 1 : NEW_LINE INDENT mn = min ( mn , arr [ i + 1 ] ) NEW_LINE mx = max ( mx , arr [ i + 1 ] ) NEW_LINE DEDENT DEDENT common_integer = ( mn + mx ) / 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == - 1 : NEW_LINE INDENT arr [ i ] = common_integer NEW_LINE DEDENT DEDENT max_diff = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE if diff > max_diff : NEW_LINE INDENT max_diff = diff NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE N = N + 1 NEW_LINE dp = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( 9 , 3 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 2 ] = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT
def GFG ( n , k , s ) : NEW_LINE INDENT dp = [ ] NEW_LINE max_length = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = s [ i ] - ' a ' NEW_LINE lower = max ( 0 , curr - k ) NEW_LINE upper = min ( 25 , curr + k ) NEW_LINE for j in range ( lower , upper + 1 ) : NEW_LINE INDENT dp . append ( max ( dp [ i ] , max_length [ j ] + 1 ) ) NEW_LINE DEDENT max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in dp : NEW_LINE INDENT ans = max ( i , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def GFG ( n , a ) : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT len = 2 NEW_LINE mx = int ( 0 ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] + a [ i - 2 ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = 2 NEW_LINE DEDENT mx = max ( mx , len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ subarrays ▁ in ▁ the ▁ GFG . """ NEW_LINE se = Vector ( ) NEW_LINE cnt = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if se . contains ( i ) is False : NEW_LINE INDENT se . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE se . clear ( ) NEW_LINE se . append ( i ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def GFG ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE r , i = divmod ( s , 10 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT while s != 0 : NEW_LINE INDENT r , s = divmod ( s , 10 ) NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor__ = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor__ = xor__ ^ freq [ i ] NEW_LINE if xor__ == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def test_cv_iterator ( ) : NEW_LINE INDENT f = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE g = np . array ( [ 4 , 5 , 6 ] ) NEW_LINE f = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE sum = 0 NEW_LINE arr = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if m <= sum : NEW_LINE INDENT f += sum / m NEW_LINE sum %= m NEW_LINE DEDENT out = np . array ( [ f , g , f ] ) NEW_LINE out [ 0 ] = f NEW_LINE out [ 1 ] = g NEW_LINE out [ 2 ] = f NEW_LINE out [ 3 ] = g NEW_LINE out [ 4 ] = f NEW_LINE out [ 5 ] = g NEW_LINE out [ 6 ] = f NEW_LINE out [ 7 ] = g NEW_LINE out [ 8 ] = f NEW_LINE out [ 9 ] = g NEW_LINE out [ 10 ] = f NEW_LINE out [ 11 ] = g NEW_LINE out [ 12 ] = f NEW_LINE out [ 13 ] = g NEW_LINE out [ 14 ] = f NEW_LINE out [ 15 ] = g NEW_LINE out [ 16 ] = f NEW_LINE out [ 17 ] = g NEW_LINE out [ 18 ] = f NEW_LINE out [ 19 ] = g NEW_LINE out [ 20 ] = f NEW_LINE out [ 21 ] = g NEW_LINE out [ 22 ] = f NEW_LINE out [ 23 ] = g NEW_LINE out [ 24 ] = f NEW_LINE out [ 25 ] = g NEW_LINE out [ 26 ] = f NEW_LINE out [ 27 ] = g NEW_LINE out [ 28 ] = g NEW_LINE out [ 29 ] = f NEW_LINE out [ 30 ] = g NEW_LINE out [ 31 ] = g NEW_LINE out [ 32 ] = f NEW_LINE out [ 33 ] = g NEW_LINE out [ 34 ] = f NEW_LINE out [ 35 ] = g NEW_LINE out [ 36 ] = f NEW_LINE out [ 37 ] = g NEW_LINE out [ 38 ] = f NEW_LINE out [ 39 ] = g NEW_LINE out [ 40 ] = f NEW_LINE out [ 41 ] = g NEW_LINE out [ 42 ] = f NEW_LINE out [ 43 ] = g NEW_LINE out [ 44 ] = f NEW_LINE out [ 45 ] = g NEW_LINE out [ 46 ] = f NEW_LINE out [ 47 ] = g NEW_LINE out [ 48 ] = f NEW_LINE out [ 49 ] = g NEW_LINE out [ 50 ] = f NEW_LINE out [ 51 ] = g NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT MAXN = 1000005 NEW_LINE even = [ 0 ] * MAXN NEW_LINE odd = [ 0 ] * MAXN NEW_LINE def precompute ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 1 : NEW_LINE INDENT odd [ i ] = 1 NEW_LINE DEDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT even [ i ] = even [ i ] + even [ i - 1 ] NEW_LINE odd [ i ] = odd [ i ] + odd [ i - 1 ] NEW_LINE DEDENT DEDENT def is_odd ( L , R ) : NEW_LINE INDENT cnt = odd [ R ] NEW_LINE if L > 0 : NEW_LINE INDENT cnt -= odd [ L - 1 ] NEW_LINE DEDENT if cnt == R - L + 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def perform_queries ( a , n , q , m ) : NEW_LINE INDENT precompute ( a , n ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT L , R = q [ i ] NEW_LINE if is_odd ( L , R ) : NEW_LINE INDENT print ( ' Odd ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Even ' ) NEW_LINE DEDENT DEDENT DEDENT def test_graph ( ) : NEW_LINE INDENT a = [ 2 , 1 , 5 , 7 , 6 , 8 , 9 ] NEW_LINE n = len ( a ) NEW_LINE q = [ [ 0 , 2 ] , [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 6 ] ] NEW_LINE m = len ( q ) NEW_LINE perform_queries ( a , n , q , m ) NEW_LINE DEDENT DEDENT
def test_pre422 ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import random NEW_LINE import string NEW_LINE import doctest NEW_LINE import tempfile NEW_LINE import time NEW_LINE import tempfile NEW_LINE import random NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE
def buses_between_cities ( ) : NEW_LINE INDENT f = open ( ' cities . txt ' , ' r ' ) NEW_LINE f . seek ( 0 ) NEW_LINE a = int ( f . readline ( ) ) NEW_LINE tA = int ( f . readline ( ) ) NEW_LINE f . seek ( 0 ) NEW_LINE b = int ( f . readline ( ) ) NEW_LINE tB = int ( f . readline ( ) ) NEW_LINE timing = f . readline ( ) NEW_LINE hrs = int ( timing [ : 2 ] ) NEW_LINE mins = int ( timing [ 3 : ] ) NEW_LINE sim_departure = hrs * 60 + mins NEW_LINE sim_arrival = sim_departure + tA NEW_LINE counter = 0 NEW_LINE for i in range ( 300 , 1440 , b ) : NEW_LINE INDENT bus_departure = i NEW_LINE bus_arrival = i + tB NEW_LINE if bus_departure >= sim_arrival or sim_departure >= bus_arrival : NEW_LINE INDENT continue NEW_LINE DEDENT counter += 1 NEW_LINE DEDENT f . write ( counter ) NEW_LINE f . flush ( ) NEW_LINE f . close ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT input = sys . stdin NEW_LINE n = input . readline ( ) . strip ( ) NEW_LINE out = 3 NEW_LINE good = True NEW_LINE playing = [ 1 , 2 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT win = input . readline ( ) . strip ( ) NEW_LINE if win == out : NEW_LINE INDENT good = False NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT replace = 0 NEW_LINE for j in range ( 1 , 3 ) : NEW_LINE INDENT if win != j and out != j : NEW_LINE INDENT replace = j NEW_LINE break NEW_LINE DEDENT DEDENT index = 0 NEW_LINE for j in range ( len ( playing ) ) : NEW_LINE INDENT if playing [ j ] == replace : NEW_LINE INDENT index = j NEW_LINE break NEW_LINE DEDENT DEDENT playing . pop ( index ) NEW_LINE playing . append ( out ) NEW_LINE out = replace NEW_LINE DEDENT DEDENT if good : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def GFG ( steps , n ) : NEW_LINE INDENT current_level = 0 NEW_LINE previous_level = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT previous_level = current_level NEW_LINE current_level = current_level + steps [ i ] NEW_LINE if ( previous_level < 0 and current_level >= 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = ' Generate ▁ a ▁ new ▁ Holiday ▁ from ▁ a ▁ given ▁ year . ' ) NEW_LINE parser . add_argument ( ' year ' , help = ' The ▁ year ▁ to ▁ generate ▁ a ▁ new ▁ Holiday ▁ from . ' ) NEW_LINE parser . add_argument ( ' month ' , help = ' The ▁ month ▁ to ▁ generate ▁ a ▁ new ▁ Holiday ▁ from . ' ) NEW_LINE parser . add_argument ( ' time ' , help = ' The ▁ time ▁ to ▁ generate ▁ a ▁ new ▁ Holiday ▁ from . ' ) NEW_LINE parser . add_argument ( ' value ' , help = ' The ▁ value ▁ to ▁ generate ▁ a ▁ new ▁ Holiday ▁ from . ' ) NEW_LINE args = parser . parse_args ( ) NEW_LINE n = int ( args . value ) NEW_LINE holidays = [ Holiday ( year , month , day , time , value ) for year , month , day , time in args . year . items ( ) ] NEW_LINE min = sys . maxint NEW_LINE for i in range ( 1 , 360 ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max = max ( max , holidays [ i ] . _crowded ( i ) ) NEW_LINE DEDENT min = min ( min , max ) NEW_LINE DEDENT print ( min ) NEW_LINE DEDENT
def petr_permutations ( ) : NEW_LINE INDENT import random NEW_LINE out = open ( ' . / petr _ permutations . txt ' , ' w ' ) NEW_LINE N = random . randint ( 1 , 10 ) NEW_LINE perm = [ random . randint ( 1 , 10 ) for i in range ( N ) ] NEW_LINE swaps = 0 NEW_LINE vis = [ False for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT j , cycle = perm [ i ] , perm [ i + 1 ] NEW_LINE while not vis [ j ] : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = perm [ j ] - 1 NEW_LINE cycle += 1 NEW_LINE DEDENT if cycle : NEW_LINE INDENT swaps += cycle - 1 NEW_LINE DEDENT DEDENT if swaps % 2 != N % 2 : NEW_LINE INDENT out . write ( ' Um _ nik \n ' ) NEW_LINE DEDENT else : NEW_LINE INDENT out . write ( ' Petr \n ' ) NEW_LINE DEDENT out . flush ( ) NEW_LINE DEDENT class FastScanner : NEW_LINE INDENT def __init__ ( self , f ) : NEW_LINE INDENT self . f = f NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while self . f . next ( ) is None or not self . f . next ( ) : NEW_LINE INDENT try : NEW_LINE INDENT self . f . next ( ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return self . f . next ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( self . f . next ( ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return long ( self . f . next ( ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( self . f . next ( ) ) NEW_LINE DEDENT def readNextLine ( self ) : NEW_LINE INDENT str = ' ' . join ( self . f . next ( ) ) NEW_LINE return str NEW_LINE DEDENT def readIntArray ( self , n ) : NEW_LINE INDENT a = [ ] NEW_LINE for idx in range ( n ) : NEW_LINE INDENT a . append ( nextInt ( ) ) NEW_LINE DEDENT return a NEW_LINE DEDENT DEDENT return FastScanner ( ) NEW_LINE DEDENT
def GFG ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = " " NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT if s [ i ] > s [ i + 1 ] : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT ans += s [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT ans = s [ : l - 1 ] NEW_LINE return ans NEW_LINE DEDENT
def pythree_test ( ) : NEW_LINE INDENT import sys NEW_LINE a = sys . argv [ 1 ] NEW_LINE b = sys . argv [ 2 ] NEW_LINE g = [ 0 , 0 , 2 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE if g [ a ] == g [ b ] : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = sys . maxint NEW_LINE found = False NEW_LINE sum = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE if sum == k : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif sum > k : NEW_LINE INDENT while sum > k : NEW_LINE INDENT sum = sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if sum == k : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if found : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global pr NEW_LINE global solve NEW_LINE def solve ( ) : NEW_LINE INDENT s = sys . stdin . readline ( ) . strip ( ) NEW_LINE cnt = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == '1' : cnt += 1 NEW_LINE DEDENT pr ( cnt ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT sys . stdin . close ( ) NEW_LINE pr = sys . stdout NEW_LINE solve ( ) NEW_LINE pr . close ( ) NEW_LINE sys . stdout . close ( ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT pr = sys . stdout NEW_LINE solve ( ) NEW_LINE pr . close ( ) NEW_LINE sys . stdout . close ( ) NEW_LINE DEDENT DEDENT
def GFG ( n , k ) : NEW_LINE INDENT temp = ( k & 1 ) or ( k / 2 ) NEW_LINE palindrome = int ( pow ( 10 , temp ) ) NEW_LINE palindrome += n - 1 NEW_LINE print ( palindrome ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT palindrome /= 10 NEW_LINE DEDENT while palindrome > 0 : NEW_LINE INDENT print ( palindrome % 10 ) NEW_LINE palindrome /= 10 NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT INF = sys . maxsize NEW_LINE def solve ( ) : NEW_LINE INDENT N = len ( sys . argv ) NEW_LINE X = sys . argv [ 1 ] NEW_LINE x = [ ] NEW_LINE xsum = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x . append ( sys . argv [ i ] ) NEW_LINE xsum . append ( xsum [ i ] + x [ i ] ) NEW_LINE DEDENT ans = X * N + 5 * xsum [ N ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT cost = X * i + 5 * ( xsum [ N ] - xsum [ N - i ] ) NEW_LINE for j , k in enumerate ( N - i , 1 ) : NEW_LINE INDENT if cost > ans : NEW_LINE INDENT break NEW_LINE DEDENT cost += j * ( xsum [ k ] - xsum [ max ( k - i , 0 ) ] ) NEW_LINE DEDENT ans = min ( ans , cost ) NEW_LINE DEDENT print ( ans + N * X ) NEW_LINE DEDENT solve ( ) NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import string NEW_LINE import hashlib NEW_LINE import time NEW_LINE import random NEW_LINE import hashlib NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import random NEW_LINE import hashlib NEW_LINE import time NEW_LINE import hashlib NEW_LINE import random NEW_LINE import string NEW_LINE import random NEW_LINE import hashlib NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import random NEW_LINE import hashlib NEW_LINE import time NEW_LINE import hashlib NEW_LINE import string NEW_LINE import random NEW_LINE import hashlib NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import random NEW_LINE import hashlib NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import random NEW_LINE import string NEW_LINE import random NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string
def main ( ) : NEW_LINE INDENT input = sys . stdin . readline ( ) NEW_LINE p1 = input . split ( ) NEW_LINE p2 = input . split ( ) NEW_LINE p3 = input . split ( ) NEW_LINE p4 = input . split ( ) NEW_LINE a = input . split ( ) NEW_LINE b = input . split ( ) NEW_LINE i = 0 NEW_LINE min = min ( min ( p1 , p2 ) , min ( p3 , p4 ) ) NEW_LINE c = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if i < min : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def p033 ( ) : NEW_LINE INDENT print ( [ ' p033' ] ) NEW_LINE numer = 1 NEW_LINE denom = 1 NEW_LINE for d in range ( 10 , 100 ) : NEW_LINE INDENT for n in range ( 10 , d ) : NEW_LINE INDENT n0 , n1 = n % 10 , n // 10 NEW_LINE d0 , d1 = d % 10 , d // 10 NEW_LINE if n1 == d0 and n0 * d == n * d1 or n0 == d1 and n1 * d == n * d0 : NEW_LINE INDENT numer *= n NEW_LINE denom *= d NEW_LINE DEDENT DEDENT DEDENT return str ( denom / library . gcd ( numer , denom ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 20 NEW_LINE count = 0 NEW_LINE while n : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT assert int ( count ) == n NEW_LINE DEDENT
def test_codechef ( ) : NEW_LINE INDENT import sympy NEW_LINE from sympy . abc import x , y NEW_LINE t = symbols ( ' t ' , real = True ) NEW_LINE for n in range ( 10 ) : NEW_LINE INDENT a , b , x , y = symbols ( ' a ▁ b ▁ x ▁ y ' , integer = True , cls = Dummy ) NEW_LINE ans = max ( max ( [ x , a - 1 - x ] ) * b , a * max ( [ y , b - 1 - y ] ) ) NEW_LINE assert ans == ( a * max ( [ y , x ] ) * b ) . expand ( ) NEW_LINE DEDENT DEDENT
def pyminswaps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arrpos = [ ( arr [ i ] , i ) for i in range ( n ) ] NEW_LINE arrpos . sort ( key = lambda x : x [ 1 ] ) NEW_LINE if arr [ 0 ] > arr [ 1 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif arr [ 0 ] == arr [ 1 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT vis = [ False ] * n NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if vis [ i ] or arrpos [ i ] [ 1 ] == i : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while not vis [ j ] : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = arrpos [ j ] [ 1 ] NEW_LINE cycle_size += 1 NEW_LINE DEDENT if cycle_size : NEW_LINE INDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def get_GFG ( n ) : NEW_LINE INDENT N = 1000005 NEW_LINE prime = [ False ] * N NEW_LINE sieve = [ False ] * N NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT for j in range ( i * 2 , N , i += 1 ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT sum_truncatable_primes = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT num = i NEW_LINE flag = True NEW_LINE while num > 0 : NEW_LINE INDENT if not prime [ num ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT num /= 10 NEW_LINE DEDENT num = i NEW_LINE power = 10 NEW_LINE while num / power > 0 : NEW_LINE INDENT if not prime [ num % power ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT power *= 10 NEW_LINE DEDENT if flag : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ the ▁ number ▁ of ▁ weights ▁ of ▁ the ▁ graph . STRNEWLINE ▁ """ NEW_LINE sum = 0 NEW_LINE power = 0 NEW_LINE number = 3 NEW_LINE while sum < X : NEW_LINE INDENT sum = number - 1 NEW_LINE sum /= 2 NEW_LINE power += 1 NEW_LINE number *= 3 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 1 , power + 1 ) : NEW_LINE INDENT print ( ans , end = ' ▁ ' ) NEW_LINE ans = ans * 3 NEW_LINE DEDENT DEDENT
def gf_add_ground ( A , K ) : NEW_LINE INDENT """ Add ▁ an ▁ element ▁ of ▁ ` ` A ` ` ▁ to ▁ a ▁ multivariate ▁ polynomial ▁ in ▁ ` ` GF ( p ) [ x ] ` ` . ▁ """ NEW_LINE v = [ ] NEW_LINE ans = [ ] NEW_LINE rem = 0 NEW_LINE i = 0 NEW_LINE for i in range ( len ( A ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT my = A [ i ] + K % 10 + rem NEW_LINE if my > 9 : NEW_LINE INDENT rem = 1 NEW_LINE v . append ( my % 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( my ) NEW_LINE rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT while K > 0 : NEW_LINE INDENT my = K % 10 + rem NEW_LINE v . append ( my % 10 ) NEW_LINE if my / 10 > 0 : NEW_LINE INDENT rem = 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT if rem : NEW_LINE INDENT v . append ( rem ) NEW_LINE DEDENT for j in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans . append ( v [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def GFG ( input , R , C ) : NEW_LINE INDENT for i in range ( C ) : NEW_LINE INDENT dfs ( input , ' ' , 0 , i , R , C ) NEW_LINE print ( ) NEW_LINE DEDENT def dfs ( input , res , i , j , R , C ) : NEW_LINE INDENT if i == R : NEW_LINE INDENT print ( res , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT res = res + input [ i ] [ j ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( input , res , i + 1 , k , R , C ) NEW_LINE if i + 1 == R : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def dfs ( input , res , i , j , R , C ) : NEW_LINE INDENT if i == R : NEW_LINE INDENT print ( res , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT res = res + input [ i ] [ j ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( input , res , i + 1 , k , R , C ) NEW_LINE if i + 1 == R : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def dfs ( input , res , i , j , R , C ) : NEW_LINE INDENT if i == R : NEW_LINE INDENT print ( res , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT res = res + input [ i ] [ j ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( input , res , i + 1 , k , R , C ) NEW_LINE if i + 1 == R : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def dfs ( input , res , i , j , R , C ) : NEW_LINE INDENT if i == R : NEW_LINE INDENT print ( res , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT res = res + input [ i ] [ j ] NEW_LINE for k in range ( C ) : NEW_LINE INDENT dfs ( input , res , i + 1 , k , R , C ) NEW_LINE if i + 1 == R : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import string NEW_LINE import getopt NEW_LINE global num NEW_LINE global line NEW_LINE global hotel NEW_LINE for i in range ( num ) : NEW_LINE INDENT actual = line [ i ] NEW_LINE if actual == ' L ' : NEW_LINE INDENT bb = True NEW_LINE for pos in range ( 10 , False , - 1 ) : NEW_LINE INDENT if hotel [ pos ] == 0 : NEW_LINE INDENT hotel [ pos ] = 1 NEW_LINE bb = False NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if actual == ' R ' : NEW_LINE INDENT bb = True NEW_LINE for pos in range ( 9 , False , - 1 ) : NEW_LINE INDENT if hotel [ pos ] == 0 : NEW_LINE INDENT hotel [ pos ] = 1 NEW_LINE bb = False NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT pos = int ( actual + ' ' ) NEW_LINE hotel [ pos ] = 0 NEW_LINE DEDENT DEDENT DEDENT res = [ ] NEW_LINE for x in hotel : NEW_LINE INDENT res . append ( x ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def b_Square ( ) : NEW_LINE INDENT import sys NEW_LINE import tokenize NEW_LINE import string NEW_LINE import ast NEW_LINE import ast . expr NEW_LINE import ast . stmt NEW_LINE import ast . expr NEW_LINE import ast . stmt NEW_LINE import ast . expr NEW_LINE import ast . stmt NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . stmt NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . stmt NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE import ast . expr NEW_LINE DEDENT
def precision_recall_curve ( y_true , y_pred , pos_label = 2 , average = ' weighted ' ) : NEW_LINE INDENT """ Compute ▁ Precision ▁ Recall ▁ Recall ▁ curve ▁ for ▁ classification ▁ task . STRNEWLINE STRNEWLINE ▁ Read ▁ more ▁ in ▁ the ▁ : ref : ` User ▁ Guide ▁ < precision _ recall _ curve > ` . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ pos _ label ▁ : ▁ int , ▁ optional ▁ ( default = 2 ) STRNEWLINE ▁ Position ▁ label . STRNEWLINE STRNEWLINE ▁ average ▁ : ▁ string ▁ or ▁ iterable ▁ of ▁ strings , ▁ optional ▁ ( default = ' weighted ' ) STRNEWLINE ▁ The ▁ type ▁ of ▁ floating ▁ point ▁ number ▁ for ▁ the ▁ precision ▁ curve . ▁ For ▁ more STRNEWLINE ▁ information ▁ see ▁ : func : ` average ` . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ precisioncurve ▁ : ▁ : class : ` ~ sklearn . metrics . precisioncurve . RTreeClassifier ` STRNEWLINE ▁ The ▁ precision ▁ curve . STRNEWLINE STRNEWLINE ▁ """ NEW_LINE if average == ' weighted ' : NEW_LINE INDENT y_true = np . ravel ( y_true ) NEW_LINE DEDENT if average == ' macro ' : NEW_LINE INDENT y_true = np . ravel ( y_true ) NEW_LINE DEDENT if pos_label == 2 : NEW_LINE INDENT y_true = y_true [ y_true ] NEW_LINE DEDENT if y_true . size == pos_label : NEW_LINE INDENT y_true = y_true [ y_true ] NEW_LINE DEDENT if ( ( pos_label > 1 ) and ( pos_label < 2 ) ) or ( ( pos_label < 0 ) and ( pos_label > 2 ) ) : NEW_LINE INDENT y_true = y_true [ y_true ] NEW_LINE DEDENT d = y_true / pos_label NEW_LINE for i in range ( 0 , len ( y_true ) ) : NEW_LINE INDENT y_true = y_true [ y_true ] NEW_LINE y_pred = y_pred [ y_true ] NEW_LINE if d < 0 : NEW_LINE INDENT break NEW_LINE DEDENT y_pred = y_pred [ y_pred ] NEW_LINE d = y_pred / pos_label NEW_LINE if i == 0 : NEW_LINE INDENT y_true = y_pred NEW_LINE DEDENT DEDENT return precision_recall_curve ( y_true , y_pred , average = average ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ LM ▁ root ▁ of ▁ the ▁ first ▁ degree ▁ of ▁ the ▁ first ▁ subsequence . """ NEW_LINE if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE class Node : NEW_LINE INDENT data = 0 NEW_LINE left , right = None NEW_LINE def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT class BinaryTree : NEW_LINE INDENT root = None NEW_LINE def print_specific_level_order_util ( self , root , s ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT q = Queue ( ) NEW_LINE q . put ( root . left ) NEW_LINE q . put ( root . right ) NEW_LINE first , second = None , None NEW_LINE while not q . empty ( ) : NEW_LINE INDENT first , second = q . get ( ) NEW_LINE q . put ( second . left ) NEW_LINE q . put ( first . right ) NEW_LINE q . put ( second . right ) NEW_LINE q . put ( first . left ) NEW_LINE if first . left . left : NEW_LINE INDENT q . put ( first . right ) NEW_LINE q . put ( second . left ) NEW_LINE q . put ( first . left ) NEW_LINE q . put ( second . right ) NEW_LINE DEDENT DEDENT DEDENT def print_specific_level_order ( self , root ) : NEW_LINE INDENT s = Stack ( ) NEW_LINE s . put ( root ) NEW_LINE if root . left : NEW_LINE INDENT s . put ( root . right ) NEW_LINE s . put ( root . left ) NEW_LINE DEDENT if root . left . left : NEW_LINE INDENT print_specific_level_order_util ( root , s ) NEW_LINE DEDENT while not s . empty ( ) : NEW_LINE INDENT print ( s . get ( ) . data , end = ' ▁ ' ) NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( rows ) : NEW_LINE INDENT i , j = 1 , 1 NEW_LINE for i in range ( 1 , rows ) : NEW_LINE INDENT if i == 1 or i == rows : NEW_LINE INDENT for j in range ( 1 , rows ) : NEW_LINE INDENT print ( " * " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( 1 , rows ) : NEW_LINE INDENT if j == 1 or j == rows : NEW_LINE INDENT print ( " * " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT DEDENT DEDENT def solidSquare ( rows ) : NEW_LINE INDENT i , j = 1 , 1 NEW_LINE for i in range ( 1 , rows ) : NEW_LINE INDENT for j in range ( 1 , rows ) : NEW_LINE INDENT print ( " * " ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT DEDENT def printPattern ( rows ) : NEW_LINE INDENT print ( " Solid ▁ Square : \n " ) NEW_LINE solidSquare ( rows ) NEW_LINE print ( " \n Hollow ▁ Square : \n " ) NEW_LINE hollowSquare ( rows ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT rows = 5 NEW_LINE printPattern ( rows ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' ab ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - c | - b | - a | - d ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - c : ▁ change ▁ the ▁ copyright ▁ and ▁ credits ▁ to ▁ the ▁ original ▁ license . """ % sys . argv [ 0 ] ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - c ' : NEW_LINE INDENT print ( ' change ▁ copyright ' ) NEW_LINE DEDENT elif o == ' - b ' : NEW_LINE INDENT print ( ' change ▁ alternate ▁ license ' ) NEW_LINE DEDENT elif o == ' - a ' : NEW_LINE INDENT print ( ' change ▁ main ▁ license ' ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n // 4 ) : NEW_LINE INDENT print ( ' abcd ' ) NEW_LINE DEDENT t = n % 4 NEW_LINE if t == 1 : NEW_LINE INDENT print ( ' a ' ) NEW_LINE DEDENT elif t == 2 : NEW_LINE INDENT print ( ' ab ' ) NEW_LINE DEDENT elif t == 3 : NEW_LINE INDENT print ( ' abc ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE data = [ ] NEW_LINE max_len = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT data . append ( sys . argv [ i ] ) NEW_LINE data . append ( sys . argv [ i + 1 ] ) NEW_LINE max_len += len ( data [ i ] ) NEW_LINE DEDENT sys . exit ( " % d ▁ % d " % ( n , max_len ) ) NEW_LINE dp = [ 10000 ] * ( max_len + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( max_len , i >= data [ i ] [ 0 ] , i ) : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , dp [ j - data [ i ] [ 0 ] ] + data [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( max_len , i >= 0 , i ) : NEW_LINE INDENT if max_len - i >= dp [ i ] : NEW_LINE INDENT print ( max_len - i ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE a = sys . argv [ 1 ] NEW_LINE b = sys . argv [ 2 ] NEW_LINE x = sys . argv [ 3 ] NEW_LINE if ( x < a ) or ( ( a + b ) < x ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( arr [ i ] , gcd ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT if ( n - 1 ) % 6 == 0 : NEW_LINE INDENT print ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ Player ▁ wins ▁ the ▁ game " ) NEW_LINE DEDENT DEDENT
def test_graph2 ( ) : NEW_LINE INDENT import sys NEW_LINE import networkx NEW_LINE class Graph ( networkx . Graph ) : NEW_LINE INDENT V = 1 NEW_LINE adj = [ ] NEW_LINE def __init__ ( self , v ) : NEW_LINE INDENT self . V = v NEW_LINE self . adj = [ ] NEW_LINE DEDENT def add_edge ( self , v , w ) : NEW_LINE INDENT self . adj . append ( w ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT self . adj [ s ] . append ( s ) NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 0 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 1 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 2 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 3 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 4 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 5 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 6 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 7 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 8 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 9 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 10 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 11 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 12 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 13 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 14 NEW_LINE DEDENT DEDENT
def test_graph2 ( ) : NEW_LINE INDENT import sys NEW_LINE import networkx NEW_LINE class Graph ( networkx . Graph ) : NEW_LINE INDENT V = 1 NEW_LINE adj = [ ] NEW_LINE def __init__ ( self , v ) : NEW_LINE INDENT self . V = v NEW_LINE self . adj = [ ] NEW_LINE DEDENT def add_edge ( self , v , w ) : NEW_LINE INDENT self . adj . append ( w ) NEW_LINE DEDENT def BFS ( self , s ) : NEW_LINE INDENT self . adj [ s ] . append ( s ) NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 0 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 1 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 2 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 3 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 4 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 5 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 6 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 7 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 8 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 9 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 10 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 11 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 12 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 13 NEW_LINE DEDENT def is_connected ( self , s ) : NEW_LINE INDENT return self . adj [ s ] == 14 NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ GFG ▁ algorithm . """ NEW_LINE a = 1 NEW_LINE elements = [ a ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT assert elements [ i ] == 1 NEW_LINE DEDENT DEDENT
def py2ascii ( ) : NEW_LINE INDENT import sys NEW_LINE import string NEW_LINE cs = [ ' P ' , ' R ' , ' S ' ] NEW_LINE dp = [ [ ' P ' , ' R ' , ' S ' ] , [ ' P ' , ' S ' ] ] NEW_LINE for i in range ( 1 , len ( dp [ 0 ] ) ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT dp [ j ] [ i ] = dp [ j ] [ i - 1 ] + dp [ ( j + 1 ) % 3 ] [ i - 1 ] NEW_LINE o = dp [ ( j + 1 ) % 3 ] [ i - 1 ] + dp [ j ] [ i - 1 ] NEW_LINE if o < dp [ j ] [ i ] : NEW_LINE INDENT dp [ j ] [ i ] = o NEW_LINE DEDENT DEDENT DEDENT T = sys . getrecursionlimit ( ) NEW_LINE for i in range ( 1 , T ) : NEW_LINE INDENT print ( " Case ▁ # % d : ▁ " % i ) NEW_LINE print ( solve ( ) ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT N = sys . getrecursionlimit ( ) NEW_LINE R = sys . getrecursionlimit ( ) NEW_LINE P = sys . getrecursionlimit ( ) NEW_LINE S = sys . getrecursionlimit ( ) NEW_LINE ret = None NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT c = [ ] NEW_LINE for ch in dp [ i ] [ N ] : NEW_LINE INDENT if ch == ' P ' : NEW_LINE INDENT c . append ( i ) NEW_LINE DEDENT if ch == ' R ' : NEW_LINE INDENT c . append ( i ) NEW_LINE DEDENT if ch == ' S ' : NEW_LINE INDENT c . append ( i ) NEW_LINE DEDENT DEDENT if c [ 0 ] == P and c [ 1 ] == R and c [ 2 ] == S : NEW_LINE INDENT ret = dp [ i ] [ N ] NEW_LINE DEDENT DEDENT return ret if ret else ' IMPOSSIBLE ' NEW_LINE DEDENT return ' ' NEW_LINE DEDENT
def pythree_chips ( ) : NEW_LINE INDENT scn = nx . club_tree ( ) NEW_LINE n = scn . shape [ 0 ] NEW_LINE k = scn . shape [ 1 ] NEW_LINE row = np . zeros ( ( n , k ) ) NEW_LINE col = np . zeros ( ( n , k ) ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT val = scn . sum ( ) NEW_LINE val2 = scn . sum ( ) NEW_LINE row [ val - 1 ] = True NEW_LINE col [ val2 - 1 ] = True NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if n % 2 == 1 and i == n // 2 : NEW_LINE INDENT if not row [ i ] or not col [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT elif not row [ i ] or not col [ i ] : NEW_LINE INDENT ans = ans + ( ( not row [ i ] and not col [ i ] ) and 2 or 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def test_repeat_element ( ) : NEW_LINE INDENT S = 0 NEW_LINE P = 1 NEW_LINE x , y = 1 , 1 NEW_LINE D = 0 NEW_LINE n = size - 2 , i NEW_LINE for i in range ( size ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE DEDENT S = S - n * ( n + 1 ) / 2 NEW_LINE P = P / fact ( n ) NEW_LINE D = int ( sqrt ( S ** 2 - 4 * P ) ) NEW_LINE x = ( D + S ) / 2 NEW_LINE y = ( S - D ) / 2 NEW_LINE print ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : ▁ " , x , y ) NEW_LINE print ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE count = 1 NEW_LINE isPrime = [ False ] * 10001 NEW_LINE primes = [ 0 ] * 100000 NEW_LINE sum = [ 0 ] * 100000 NEW_LINE try : NEW_LINE INDENT random . seed ( 0 ) NEW_LINE isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 0 , len ( isPrime ) * i <= len ( isPrime ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT for j in range ( i + 1 , len ( isPrime ) , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT for i in isPrime : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT primes [ count ] = i NEW_LINE sum [ count ] = sum [ count - 1 ] + primes [ count ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import numpy NEW_LINE import numpy . linalg NEW_LINE import numpy . random NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . polynomial NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . polynomial NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy
def _main ( ) : NEW_LINE INDENT sc = SparkContext ( appName = " PythonChineseExample " ) NEW_LINE sc . begin ( ) NEW_LINE try : NEW_LINE INDENT while True : NEW_LINE INDENT st = sc . readSplit ( ) NEW_LINE if st == " # " : NEW_LINE INDENT break NEW_LINE DEDENT c = sc . parallelize ( range ( len ( st ) ) , 1 ) NEW_LINE count , t = sc . runJob ( " SELECT ▁ count ( * ) ▁ FROM ▁ % s ▁ WHERE ▁ name ▁ = ▁ ' % s ' " % ( st [ 0 ] , st [ 1 ] ) ) NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if t != check ( st [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE t = check ( st [ i ] ) NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT finally : NEW_LINE INDENT sc . stop ( ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE str = sys . argv [ 1 ] NEW_LINE S = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if str [ i ] == ' S ' and str [ i + 1 ] == ' F ' : NEW_LINE INDENT S += 1 NEW_LINE DEDENT elif str [ i ] == ' F ' and str [ i + 1 ] == ' S ' : NEW_LINE INDENT S -= 1 NEW_LINE DEDENT DEDENT if S > 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def test_247 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE for i in range ( t . size ) : NEW_LINE INDENT n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE a = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = a [ i ] * a [ i ] NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT max = a [ 0 ] * a [ 1 ] NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if a [ i - 1 ] > a [ i + 1 ] : NEW_LINE INDENT if a [ i ] * a [ i - 1 ] > max : NEW_LINE INDENT max = a [ i ] * a [ i - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ i ] * a [ i + 1 ] > max : NEW_LINE INDENT max = a [ i ] * a [ i + 1 ] NEW_LINE DEDENT DEDENT DEDENT assert max == a [ 0 ] * a [ 1 ] NEW_LINE DEDENT DEDENT
def pylcm ( a , b ) : NEW_LINE INDENT """ STRNEWLINE ▁ Find ▁ the ▁ LCM ▁ of ▁ the ▁ given ▁ number ▁ of ▁ bits . STRNEWLINE STRNEWLINE ▁ : param ▁ a : STRNEWLINE ▁ : param ▁ b : STRNEWLINE ▁ : return : STRNEWLINE ▁ """ NEW_LINE return ( a * b ) / sympy . gcd ( a + ' ' , b + ' ' ) . expand ( ) NEW_LINE DEDENT
def punctuation ( c ) : NEW_LINE INDENT """ Return ▁ a ▁ string ▁ of ▁ punctuation ▁ characters . """ NEW_LINE if c . isalnum ( ) : NEW_LINE INDENT return c NEW_LINE DEDENT if c . isspace ( ) : NEW_LINE INDENT return c NEW_LINE DEDENT if c . isupper ( ) : NEW_LINE INDENT return c NEW_LINE DEDENT if c . islower ( ) : NEW_LINE INDENT return c NEW_LINE DEDENT return c NEW_LINE DEDENT
def get_gfg ( a , n , k ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m . has_key ( a [ i ] ) : NEW_LINE INDENT m [ a [ i ] ] = m [ a [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT res = sys . maxsize NEW_LINE s = m . keys ( ) NEW_LINE for temp in s : NEW_LINE INDENT if m [ temp ] == k : NEW_LINE INDENT res = min ( res , temp ) NEW_LINE DEDENT DEDENT return ( res , k ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = chr ( 64 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT if s [ i ] < c : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import struct NEW_LINE import random NEW_LINE import time NEW_LINE import sys NEW_LINE import string NEW_LINE import struct NEW_LINE alreadyA = [ ] NEW_LINE alreadyB = [ ] NEW_LINE try : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , 1000000 ) : NEW_LINE INDENT t = random . randint ( 0 , 1000000 ) NEW_LINE a = [ t ] NEW_LINE DEDENT for i in range ( len ( a ) ) : NEW_LINE INDENT pass NEW_LINE DEDENT alreadyA = [ ] NEW_LINE alreadyB = [ ] NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , 1000000 ) : NEW_LINE INDENT t = random . randint ( 0 , 1000000 ) NEW_LINE if t % 2 == 1 : NEW_LINE INDENT b = [ t ] NEW_LINE DEDENT DEDENT DEDENT except : NEW_LINE INDENT sys . exit ( " Usage : ▁ % s ▁ < input > " % sys . argv [ 0 ] ) NEW_LINE DEDENT def a ( ) : NEW_LINE INDENT for i in range ( 1 , 1000000 ) : NEW_LINE INDENT mina = sys . maxint NEW_LINE minb = sys . maxint NEW_LINE x , y = 0 , 0 NEW_LINE for j in range ( 180 , a [ i ] <= i ) : NEW_LINE INDENT mina = min ( 1 + alreadyA [ i - a [ j ] ] , mina ) NEW_LINE if a [ j ] % 2 == 1 : NEW_LINE INDENT minb = min ( 1 + alreadyB [ i - a [ j ] ] , minb ) NEW_LINE DEDENT DEDENT alreadyA . append ( mina ) NEW_LINE alreadyB . append ( minb ) NEW_LINE DEDENT DEDENT def tetrahedral ( a ) : NEW_LINE INDENT return ( a * ( a + 1 ) * ( a + 2 ) ) / 6 NEW_LINE DEDENT
def GFG ( str ) : NEW_LINE INDENT letter = 0 NEW_LINE for c in str : NEW_LINE INDENT if ( c >= ' A ' and c <= ' Z ' ) : NEW_LINE INDENT letter += 1 NEW_LINE DEDENT DEDENT return letter NEW_LINE DEDENT def countOfLetters ( str ) : NEW_LINE INDENT number = 0 NEW_LINE for c in str : NEW_LINE INDENT if c >= '0' and c <= '9' : NEW_LINE INDENT number += 1 NEW_LINE DEDENT DEDENT return number NEW_LINE DEDENT def check ( str ) : NEW_LINE INDENT if countOfLetters ( str ) == countOfNumbers ( str ) : NEW_LINE INDENT print ( " Yes \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No \n " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT str = " GeeKs01324" NEW_LINE check ( str ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE box = [ ] NEW_LINE i = 0 NEW_LINE while 1 : NEW_LINE INDENT n = sys . stdin . readline ( ) NEW_LINE if n == ' ' : NEW_LINE INDENT i -= 1 NEW_LINE print ( box [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT box . append ( n ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE for n in range ( 0 , N ) : NEW_LINE INDENT x , y = input ( ) . split ( ) NEW_LINE if x == 1 or x == 2 * N - 1 : NEW_LINE INDENT print ( " No " ) NEW_LINE break NEW_LINE DEDENT print ( " Yes " ) NEW_LINE low , high = x - 1 , x + 1 NEW_LINE deq = [ x ] NEW_LINE while low != 0 or high != 2 * N : NEW_LINE INDENT if low == 0 : NEW_LINE INDENT deq . append ( high ) NEW_LINE deq . append ( high + 1 ) NEW_LINE high += 2 NEW_LINE DEDENT elif high == 2 * N : NEW_LINE INDENT deq . append ( low ) NEW_LINE deq . append ( low - 1 ) NEW_LINE low -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT deq . append ( low ) NEW_LINE low -= 1 NEW_LINE deq . append ( high ) NEW_LINE high += 1 NEW_LINE DEDENT DEDENT for s in deq : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT MAX = 100001 NEW_LINE perfect_div = [ 0 ] * MAX NEW_LINE precompute_counts = { } NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT for j in range ( i * i , MAX , j += i * i ) : NEW_LINE INDENT yield perfect_div [ j ] NEW_LINE DEDENT DEDENT count_perfect_divisors = perfect_div [ n ] NEW_LINE for i in range ( 16 ) : NEW_LINE INDENT yield count_perfect_divisors [ i ] NEW_LINE DEDENT n = 12 NEW_LINE yield 0 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n , m = sys . argv [ 1 ] , sys . argv [ 2 ] NEW_LINE nn = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT nn += sys . stdin . read ( ) NEW_LINE DEDENT mm = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT mm += sys . stdin . read ( ) NEW_LINE DEDENT print ( nn * mm ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - d ' : NEW_LINE INDENT d = a NEW_LINE DEDENT elif o == ' - e ' : NEW_LINE INDENT e = a NEW_LINE DEDENT DEDENT for o , a in args : NEW_LINE INDENT if o == ' - d ' : NEW_LINE INDENT d = a NEW_LINE DEDENT elif o == ' - e ' : NEW_LINE INDENT e = a NEW_LINE DEDENT DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - e ' : NEW_LINE INDENT e = a NEW_LINE DEDENT DEDENT print ( ' % d ▁ % s ' % ( len ( args ) , e ) ) NEW_LINE DEDENT
def test_GFG ( h , r ) : NEW_LINE INDENT IST = ( h * r * 1.0 ) / 360 NEW_LINE int_IST = int ( IST ) NEW_LINE float_IST = int ( math . ceil ( int ( ( IST - int_IST ) * 60 ) ) ) NEW_LINE assert int_IST == float_IST NEW_LINE DEDENT
def test_GFG ( n ) : NEW_LINE INDENT theta = pi * 2 / n NEW_LINE for k in range ( n ) : NEW_LINE INDENT real = cos ( k * theta ) NEW_LINE img = sin ( k * theta ) NEW_LINE print ( ' % . 3 f ' % real ) NEW_LINE if img >= 0 : NEW_LINE INDENT print ( ' ▁ + ▁ i ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ▁ - ▁ i ▁ ' ) NEW_LINE DEDENT print ( ' % . 3 f ' % abs ( img ) ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 4 , 5 , 6 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE assert findCart ( arr1 , arr2 , n1 , n2 ) == [ 1 , 2 , 3 ] NEW_LINE DEDENT
def import ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count_left , count_right = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == s [ 0 ] : NEW_LINE INDENT count_left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == s [ n - 1 ] : NEW_LINE INDENT count_right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if s [ 0 ] == s [ n - 1 ] : NEW_LINE INDENT return ( ( count_left + 1 ) * ( count_right + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( count_left + count_right + 1 ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE SieveOfEratosthenes ( ) NEW_LINE for i in prime : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , MAX * p <= MAX ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , i += p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT SumOfKthPrimes ( arr , n , k ) NEW_LINE c = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE DEDENT
def GFG ( arr , n , k ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ False ] * ( MAX + 1 ) NEW_LINE SieveOfEratosthenes ( ) NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for p in range ( 2 , MAX * p <= MAX ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , i += p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT solve ( arr , n , k ) NEW_LINE DEDENT
def GFG ( arr , n , k ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ False ] * ( MAX + 1 ) NEW_LINE SieveOfEratosthenes ( ) NEW_LINE prime [ 1 ] = True NEW_LINE prime [ 0 ] = True NEW_LINE for p in range ( 2 , p * p <= MAX ) : NEW_LINE INDENT if prime [ p ] == False : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT DEDENT DEDENT product_of_kth_primes ( arr , n , k ) NEW_LINE c = 0 NEW_LINE product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not prime [ arr [ i ] ] : NEW_LINE INDENT c += 1 NEW_LINE if c % k == 0 : NEW_LINE INDENT product *= arr [ i ] NEW_LINE c = 0 NEW_LINE DEDENT DEDENT DEDENT print ( product ) NEW_LINE DEDENT
def pyminswaps ( diff , out , start , end ) : NEW_LINE INDENT if abs ( diff ) > ( end - start + 1 ) / 2 : NEW_LINE INDENT return NEW_LINE DEDENT if start > end : NEW_LINE INDENT if diff == 0 : NEW_LINE INDENT print ( [ ' ' ] * ( end - start + 1 ) ) NEW_LINE print ( ' ▁ ' ) NEW_LINE DEDENT return NEW_LINE DEDENT out [ start ] = '0' NEW_LINE out [ end ] = '1' NEW_LINE findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = out [ end ] = '1' NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = out [ end ] = '0' NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) NEW_LINE out [ start ] = out [ end ] = '1' NEW_LINE findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) NEW_LINE DEDENT
def test_narrow_fridge ( ) : NEW_LINE INDENT import numpy as np NEW_LINE s = np . random . uniform ( size = ( 10 , 10 ) ) NEW_LINE n , h = s . shape NEW_LINE arr = np . random . uniform ( size = ( n , n ) ) NEW_LINE overall_pq = PriorityQueue ( sorted ( arr ) ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT overall_pq . add ( arr [ i ] ) NEW_LINE pq = PriorityQueue ( sorted ( overall_pq ) ) NEW_LINE c1 , c2 = h , h NEW_LINE flag = True NEW_LINE while not pq . empty ( ) : NEW_LINE INDENT if flag : NEW_LINE INDENT if c1 >= pq . get ( ) : NEW_LINE INDENT c1 -= pq . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT flag = False NEW_LINE DEDENT else : NEW_LINE INDENT if c2 >= pq . get ( ) : NEW_LINE INDENT c2 -= pq . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT flag = True NEW_LINE DEDENT DEDENT if pq . empty ( ) : NEW_LINE INDENT ans = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT assert ans == n NEW_LINE s . close ( ) NEW_LINE DEDENT
def GFG ( data ) : NEW_LINE INDENT def printList ( node ) : NEW_LINE INDENT while node : NEW_LINE INDENT print ( node . data , " ▁ - > ▁ " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( " NULL " ) NEW_LINE DEDENT def cntNodes ( node ) : NEW_LINE INDENT if node is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + cntNodes ( node . next ) ) NEW_LINE DEDENT def updateList ( head , m ) : NEW_LINE INDENT cnt = cntNodes ( head ) NEW_LINE if cnt != m and m < cnt : NEW_LINE INDENT skip = cnt - m NEW_LINE prev = None NEW_LINE curr = head NEW_LINE while skip : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE skip -= 1 NEW_LINE DEDENT prev . next = None NEW_LINE tempHead = head NEW_LINE head = curr NEW_LINE while curr . next : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT curr . next = tempHead NEW_LINE DEDENT DEDENT printList ( head ) NEW_LINE DEDENT
def get_max_substrings ( s , k ) : NEW_LINE INDENT max_substr , n = 0 , len ( s ) NEW_LINE for c in range ( 26 ) : NEW_LINE INDENT ch = chr ( ord ( ' a ' ) + c ) NEW_LINE curr = 0 NEW_LINE for i in range ( 0 , n - k ) : NEW_LINE INDENT if s [ i ] != ch : continue NEW_LINE cnt = 0 NEW_LINE while i < n and s [ i ] == ch and cnt != k : NEW_LINE INDENT i += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE if cnt == k : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT DEDENT max_substr = max ( max_substr , curr ) NEW_LINE DEDENT return max_substr NEW_LINE DEDENT
def pyGFG ( arr , n , l , r , q ) : NEW_LINE INDENT if ( r - l + 1 ) % 2 == 0 : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT if l % 2 == 0 : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ ] NEW_LINE prefeven = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i ) % 2 == 0 : NEW_LINE INDENT prefeven . append ( arr [ i - 1 ] ^ prefeven [ i - 1 ] ) NEW_LINE prefodd . append ( prefodd [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT prefeven . append ( prefeven [ i - 1 ] ) NEW_LINE prefodd . append ( prefodd [ i - 1 ] ^ arr [ i - 1 ] ) NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i != q : NEW_LINE INDENT ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return wrapper NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans . append ( sys . argv [ i ] ) NEW_LINE DEDENT ans . sort ( ) NEW_LINE count = ans [ - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ans [ i ] < ans [ i + 1 ] : NEW_LINE INDENT count += ans [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT while ans [ i ] >= ans [ i + 1 ] : NEW_LINE INDENT ans [ i ] -= 1 NEW_LINE DEDENT if ans [ i ] > 0 : NEW_LINE INDENT count += ans [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global parser NEW_LINE parser = optparse . OptionParser ( usage = " % prog ▁ [ options ] ▁ < file > " ) NEW_LINE parser . add_option ( " - - fast " , action = " store _ true " , dest = " fast " , default = False , help = " Skip ▁ tests ▁ that ▁ are ▁ not ▁ run ▁ in ▁ a ▁ fast ▁ mode " ) NEW_LINE parser . add_option ( " - - skip " , action = " store _ true " , dest = " skip " , default = False , help = " Skip ▁ tests ▁ that ▁ are ▁ not ▁ run ▁ in ▁ a ▁ fast ▁ mode " ) NEW_LINE parser . add_option ( " - - skip - random " , action = " store _ true " , dest = " skip _ random " , default = False , help = " Skip ▁ tests ▁ that ▁ are ▁ not ▁ run ▁ in ▁ a ▁ fast ▁ mode " ) NEW_LINE parser . add_option ( " - - skip - long " , action = " store _ true " , dest = " skip _ long " , default = False , help = " Skip ▁ tests ▁ that ▁ are ▁ not ▁ run ▁ in ▁ a ▁ fast ▁ mode " ) NEW_LINE parser . add_option ( " - - skip - double " , action = " store _ true " , dest = " skip _ double " , default = False , help = " Skip ▁ tests ▁ that ▁ are ▁ not ▁ run ▁ in ▁ a ▁ fast ▁ mode " ) NEW_LINE parser . add_option ( " - - skip - string " , action = " store _ true " , dest = " skip _ string " , default = False , help = " Skip ▁ tests ▁ that ▁ are ▁ not ▁ run ▁ in ▁ a ▁ fast ▁ mode " ) NEW_LINE parser . add_option ( " - - skip - long " , action = " store _ true " , dest = " skip _ long " , default = False , help = " Skip ▁ tests ▁ that ▁ are ▁ not ▁ run ▁ in ▁ a ▁ fast ▁ mode " ) NEW_LINE parser . add_option ( " - - skip - double " , action = " store _ true " , dest = " skip _ double " , default = False , help = " Skip ▁ tests ▁ that ▁ are ▁ not ▁ run ▁ in ▁ a ▁ fast ▁ mode " ) NEW_LINE options , args = parser . parse_args ( ) NEW_LINE if len ( args ) != 0 : NEW_LINE INDENT parser . print_help (
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n , q = sys . argv [ 1 : ] NEW_LINE Stack = { } NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L = deque ( ) NEW_LINE Stack [ i ] = L NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT cmd = sys . argv [ 2 ] NEW_LINE t = sys . argv [ 3 ] NEW_LINE if cmd == 0 : NEW_LINE INDENT Stack [ t ] . append ( sys . argv [ 4 ] ) NEW_LINE DEDENT elif cmd == 1 and Stack [ t ] . size != 0 : NEW_LINE INDENT s . append ( Stack [ t ] . pop ( ) + ' \n ' ) NEW_LINE DEDENT elif cmd == 2 and Stack [ t ] . size != 0 : NEW_LINE INDENT Stack [ t ] . pop ( ) NEW_LINE DEDENT DEDENT sys . stdout . write ( s ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT def remove_min ( arr , n ) : NEW_LINE INDENT i , min_val = arr [ 0 ] , arr [ 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_val = min ( min_val , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - min_val NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT i , maxVal = arr [ 0 ] , arr [ 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT remove_min ( arr , n ) NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT arr = arr [ : n ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE modifyArray ( arr , n , k ) NEW_LINE DEDENT return arr NEW_LINE DEDENT
def GFG ( v ) : NEW_LINE INDENT ans = [ ] NEW_LINE n = len ( v ) NEW_LINE signed_area = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x0 , y0 = v [ i ] NEW_LINE x1 , y1 = v [ ( i + 1 ) % n ] NEW_LINE A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE signed_area += A NEW_LINE ans . append ( ( x0 + x1 ) * A ) NEW_LINE ans . append ( ( y0 + y1 ) * A ) NEW_LINE DEDENT signed_area *= 0.5 NEW_LINE ans = ( ans ) / ( 6 * signed_area ) NEW_LINE ans = ( ans ) / ( 6 * signed_area ) NEW_LINE return ans NEW_LINE DEDENT
def pytest_unconfigure ( config ) : NEW_LINE INDENT color = ' blue ' NEW_LINE locked = False NEW_LINE config . pluginmanager . register ( Config ( ) , ' config ' ) NEW_LINE def cleanup ( ) : NEW_LINE INDENT for line in config . pluginmanager . getPlugins ( Plugin ) : NEW_LINE INDENT next = line . split ( ' : ' ) NEW_LINE if ' lock ' in next [ 0 ] . lower ( ) : NEW_LINE INDENT locked = True NEW_LINE continue NEW_LINE DEDENT if ' unlock ' in next [ 0 ] . lower ( ) : NEW_LINE INDENT locked = False NEW_LINE continue NEW_LINE DEDENT if locked : NEW_LINE INDENT continue NEW_LINE DEDENT color = next [ 0 ] NEW_LINE DEDENT config . _pluginmanager . unregister ( Config ( ) , ' config ' ) NEW_LINE DEDENT
def pythagorean_min_operations ( ar , k ) : NEW_LINE INDENT ar . sort ( ) NEW_LINE ops_needed = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT ops_needed += ar [ k - 1 ] - ar [ i ] NEW_LINE DEDENT ans = ops_needed NEW_LINE for i in range ( k , len ( ar ) ) : NEW_LINE INDENT ops_needed = ops_needed - ( ar [ i - 1 ] - ar [ i - k ] ) NEW_LINE ops_needed += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) NEW_LINE ans = min ( ans , ops_needed ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def test_GFG ( input_char ) : NEW_LINE INDENT if ( input_char >= 65 and input_char <= 90 ) : NEW_LINE INDENT print ( " ▁ Alphabet ▁ " ) NEW_LINE DEDENT elif input_char >= 97 and input_char <= 122 : NEW_LINE INDENT print ( " ▁ Digit ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ Special ▁ Character ▁ " ) NEW_LINE DEDENT DEDENT
def test_practice2 ( ) : NEW_LINE INDENT x = Symbol ( ' x ' ) NEW_LINE n = Symbol ( ' n ' , integer = True ) NEW_LINE x = Symbol ( ' x ' , integer = True , positive = True ) NEW_LINE y = Symbol ( ' y ' , integer = True , positive = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = x + i NEW_LINE y = y + i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT d = { i + 1 : 1 } NEW_LINE flag = 0 NEW_LINE j = i NEW_LINE while flag == 0 : NEW_LINE INDENT if not d . has_key ( x [ j ] ) : NEW_LINE INDENT d [ x [ j ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE print ( x [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT j = x [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE import pickle NEW_LINE import os NEW_LINE import random NEW_LINE n = len ( sys . argv ) NEW_LINE m = len ( sys . argv ) NEW_LINE p = [ ] NEW_LINE tab = [ set ( ) for i in range ( n ) ] NEW_LINE ans = 3000003 NEW_LINE for i in range ( m ) : NEW_LINE INDENT a = sys . argv [ i ] - 1 NEW_LINE b = sys . argv [ i + 1 ] - 1 NEW_LINE for x in tab [ a ] : NEW_LINE INDENT if tab [ b ] . count ( x ) : NEW_LINE INDENT ans = min ( p [ a ] + p [ b ] + p [ x ] , ans ) NEW_LINE DEDENT DEDENT tab [ a ] . add ( b ) NEW_LINE tab [ b ] . add ( a ) NEW_LINE DEDENT if ans == 3000003 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT
def pycf67B ( ) : NEW_LINE INDENT import sys NEW_LINE import pickle NEW_LINE import os NEW_LINE import pickle NEW_LINE import pickle . dump NEW_LINE class CF67B ( object ) : NEW_LINE INDENT def __init__ ( self , f , * args , ** kwargs ) : NEW_LINE INDENT super ( CF67B , self ) . __init__ ( f , * args , ** kwargs ) NEW_LINE DEDENT def main ( self , * args , ** kwargs ) : NEW_LINE INDENT o = pickle . load ( open ( self . f , ' rb ' ) ) NEW_LINE o . main ( ) NEW_LINE o . flush ( ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " < CF67B ▁ object ▁ % s > " % self . f . __class__ . __name__ NEW_LINE DEDENT DEDENT n = len ( pickle . load ( open ( self . f , ' rb ' ) ) ) NEW_LINE k = len ( pickle . load ( open ( self . f , ' rb ' ) ) ) NEW_LINE bb = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT bb . append ( pickle . load ( open ( self . f , ' rb ' ) ) ) NEW_LINE DEDENT aa = [ ] NEW_LINE m = 0 NEW_LINE for a in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while bb [ a ] > 0 : NEW_LINE INDENT if aa [ j ] >= a + k : NEW_LINE INDENT bb [ a ] -= 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT for j_ in range ( m + 1 , j , - 1 ) : NEW_LINE INDENT aa . append ( aa [ j_ - 1 ] ) NEW_LINE DEDENT aa . append ( a ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( aa [ i ] + 1 + " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def test_b147 ( ) : NEW_LINE INDENT x = Symbol ( ' x ' ) NEW_LINE n = Symbol ( ' n ' ) NEW_LINE c = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE table = [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] , [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ] NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = x NEW_LINE DEDENT d [ ' x ' ] = x NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , c [ i - 1 ] + 1 ) : NEW_LINE INDENT cell = x [ i ] NEW_LINE d [ cell ] = ( i , j ) NEW_LINE table [ i - 1 ] [ j - 1 ] = cell NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE m = 0 NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in c [ i ] : NEW_LINE INDENT cnt += 1 NEW_LINE if table [ i ] [ j ] == cnt : NEW_LINE INDENT continue NEW_LINE DEDENT s . append ( i + 1 ) NEW_LINE s . append ( j + 1 ) NEW_LINE point = d [ cnt ] NEW_LINE s . append ( point [ 0 ] ) NEW_LINE s . append ( point [ 1 ] ) NEW_LINE tmp = table [ i ] [ j ] NEW_LINE table [ i ] [ j ] = table [ point [ 0 ] - 1 ] [ point [ 1 ] - 1 ] NEW_LINE table [ point [ 0 ] - 1 ] [ point [ 1 ] - 1 ] = tmp NEW_LINE d [ tmp ] = point NEW_LINE m += 1 NEW_LINE DEDENT DEDENT assert m == 0 NEW_LINE s = ' ' . join ( s ) NEW_LINE if m : NEW_LINE INDENT assert s == ' ' NEW_LINE DEDENT DEDENT
def import ( arr , n , x , y ) : NEW_LINE INDENT """ STRNEWLINE ▁ Import ▁ a ▁ solution ▁ to ▁ the ▁ given ▁ array ▁ of ▁ integers . STRNEWLINE ▁ """ NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT ct_x , ct_y = 0 , 0 NEW_LINE for j in range ( i , n - 1 ) : NEW_LINE INDENT if arr [ j ] == x : NEW_LINE INDENT ct_x += 1 NEW_LINE DEDENT elif arr [ j ] == y : NEW_LINE INDENT ct_y += 1 NEW_LINE DEDENT if ct_x == ct_y : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT
def test_251 ( ) : NEW_LINE INDENT x = [ 0 ] NEW_LINE t = range ( 3 ) NEW_LINE for i in t : NEW_LINE INDENT a = x [ i ] NEW_LINE if len ( a ) >= 3 : NEW_LINE INDENT z , o = 0 , 0 NEW_LINE for c in a : NEW_LINE INDENT if c == '1' : NEW_LINE INDENT o += 1 NEW_LINE DEDENT else : NEW_LINE INDENT z += 1 NEW_LINE DEDENT DEDENT if z > o : NEW_LINE INDENT assert o == 1 NEW_LINE DEDENT elif o > z : NEW_LINE INDENT assert z == 1 NEW_LINE DEDENT else : NEW_LINE INDENT assert z - 1 == 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT assert 0 NEW_LINE DEDENT DEDENT x = [ 0 ] NEW_LINE DEDENT
def coder ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import pickle NEW_LINE import math NEW_LINE import os . path NEW_LINE import pickle NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE import pickle . lexists NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE i = 0 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT assert a [ i ] == i NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT toFind = target / ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if arr [ k ] == toFind : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( " Total ▁ number ▁ of ▁ triplets ▁ found : ▁ " , totalCount ) NEW_LINE DEDENT
def test_Multiples_Of_Length ( ) : NEW_LINE INDENT class FastReader ( object ) : NEW_LINE INDENT f = open ( ' / tmp / foo . txt ' , ' r ' ) NEW_LINE tokens = [ ] NEW_LINE def readline ( self ) : NEW_LINE INDENT tokens . append ( self . f . readline ( ) ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not tokens or not tokens . pop ( ) : NEW_LINE INDENT try : NEW_LINE INDENT tokens . pop ( ) NEW_LINE DEDENT except IndexError : NEW_LINE INDENT tokens . append ( ' ' ) NEW_LINE DEDENT DEDENT return tokens NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return ' ' NEW_LINE DEDENT DEDENT t = FastReader ( ) NEW_LINE o = open ( ' / tmp / foo . txt ' , ' w ' ) NEW_LINE n = t . readline ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( t . readline ( ) ) NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT o . write ( '1 ▁ 1' ) NEW_LINE o . write ( - a [ 0 ] ) NEW_LINE o . write ( '1 ▁ 1' ) NEW_LINE o . write ( '0' ) NEW_LINE o . write ( '1 ▁ 1' ) NEW_LINE o . write ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT o . write ( '1 ▁ 1' ) NEW_LINE o . write ( - a [ 0 ] ) NEW_LINE o . write ( '1 ▁ % d ' % n ) NEW_LINE a . append ( 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT o . write ( ' % d ▁ ' % ( - n * a [ i ] + ' ▁ ' ) ) NEW_LINE DEDENT o . write ( ' \n 2 ▁ % d ' % n ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT o . write ( ( n - 1 ) * a [ i ] + ' ▁ ' ) NEW_LINE DEDENT DEDENT o . flush ( ) NEW_LINE o . close ( ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = __gcd ( result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT N = 1000 NEW_LINE v = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT v . append ( [ ] ) NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a NEW_LINE DEDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT v . append ( [ a [ i ] | a [ i + 1 ] ] ) NEW_LINE DEDENT while len ( v [ - 1 ] ) > 1 : NEW_LINE INDENT steps += 1 NEW_LINE for i in range ( 0 , len ( v [ - 1 ] ) , 2 ) : NEW_LINE INDENT if steps % 2 == 1 : NEW_LINE INDENT v [ - 1 ] . append ( v [ - 1 ] [ i ] | v [ - 1 ] [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v [ - 1 ] . append ( v [ - 1 ] [ i ] ^ v [ - 1 ] [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return v [ - 1 ] [ 0 ] NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 2 NEW_LINE assert number_cake ( n ) == 2 NEW_LINE n = 8 NEW_LINE assert number_cake ( n ) == 25 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE input = sys . stdin . read ( ) NEW_LINE result = 0 NEW_LINE p = 0 NEW_LINE g = 1 NEW_LINE for c in input : NEW_LINE INDENT if c == ' g ' : NEW_LINE INDENT if p + 1 <= g : NEW_LINE INDENT result += 1 NEW_LINE p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT g += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if p + 1 <= g : NEW_LINE INDENT p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT g += 1 NEW_LINE result -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE class solution : NEW_LINE INDENT pattern = 1 NEW_LINE DEDENT i , j , k = 0 , 1 , 1 , N NEW_LINE for i in range ( rows , 1 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sys . stdout . write ( " * " ) NEW_LINE DEDENT if i != rows : NEW_LINE INDENT for k in range ( 1 , space + 1 ) : NEW_LINE INDENT sys . stdout . write ( " ▁ " ) NEW_LINE DEDENT space = space + 2 NEW_LINE DEDENT for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if j != rows : NEW_LINE INDENT sys . stdout . write ( " * " ) NEW_LINE DEDENT DEDENT sys . stdout . write ( " \n " ) NEW_LINE DEDENT sys . stdout . write ( " \n " ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ maximum ▁ middle ▁ value ▁ of ▁ the ▁ degree ▁ of ▁ the ▁ graph . """ NEW_LINE ans = - 1 NEW_LINE low = ( n + 1 - k ) // 2 NEW_LINE high = ( n + 1 - k ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , key = itemgetter ( 1 ) ) NEW_LINE DEDENT assert ans == - 1 NEW_LINE n , k = 5 , 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE assert maximum_middle_value ( n , k , arr ) == - 1 NEW_LINE n , k = 9 , 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE assert maximum_middle_value ( n , k , arr1 ) == - 1 NEW_LINE DEDENT
def import ( root_data ) : NEW_LINE INDENT class TreeNode ( object ) : NEW_LINE INDENT def __init__ ( self , val ) : NEW_LINE INDENT self . val = val NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT def get ( self , root , sum ) : NEW_LINE INDENT result = 0 NEW_LINE cache = { } NEW_LINE cache [ 0 ] = 1 NEW_LINE self . pathSumHelper ( root , sum , 0 ) NEW_LINE return result NEW_LINE DEDENT def set ( self , root , target , soFar ) : NEW_LINE INDENT if root not in cache : NEW_LINE INDENT cache [ root ] = 1 NEW_LINE DEDENT complement = soFar + root . val - target NEW_LINE if cache . has_key ( complement ) : NEW_LINE INDENT result += cache [ complement ] NEW_LINE DEDENT cache [ soFar + root . val ] = cache . getOrDefault ( soFar + root . val , 0 ) + 1 NEW_LINE self . pathSumHelper ( root . left , target , soFar + root . val ) NEW_LINE self . pathSumHelper ( root . right , target , soFar + root . val ) NEW_LINE cache [ soFar + root . val ] = cache [ soFar + root . val ] - 1 NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def __init__ ( self , root , soFar ) : NEW_LINE INDENT self . root = root NEW_LINE self . soFar = soFar NEW_LINE DEDENT def get ( self , root , sum ) : NEW_LINE INDENT result = 0 NEW_LINE cache = { } NEW_LINE cache [ 0 ] = 1 NEW_LINE self . pathSumHelper ( root . left , target , soFar + root . val ) NEW_LINE self . pathSumHelper ( root . right , target , soFar + root . val ) NEW_LINE cache [ soFar + root . val ] = cache [ soFar + root . val ] - 1 NEW_LINE DEDENT def set ( self , root , soFar ) : NEW_LINE INDENT cache [ soFar + root . val ] = cache [ soFar + root . val ] - 1 NEW_LINE DEDENT def get ( self , root , sum ) : NEW_LINE INDENT result = 0 NEW_LINE cache = { } NEW_LINE cache [ 0 ] = 1 NEW_LINE self . pathSumHelper ( root . left , target , soFar + root . val ) NEW_LINE self . pathSumHelper ( root . right , target , soFar + root . val ) NEW_LINE cache [ soFar + root . val ] = cache [ soFar + root . val ] - 1 NEW_LINE DEDENT DEDENT return Solution ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " Case ▁ % d : " % i ) NEW_LINE msm ( sys . argv [ 1 ] , 1 ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE sosu = [ ] NEW_LINE sosu . append ( True ) NEW_LINE sosu . append ( False ) NEW_LINE for i in range ( 2 , 123456 * 2 + 1 ) : NEW_LINE INDENT if sosu [ i ] : NEW_LINE INDENT for j in range ( 2 , i * j + 1 ) : NEW_LINE INDENT sosu [ i * j ] = False NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT n = sys . stdin . readline ( ) NEW_LINE if n == ' ' : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n + 1 , n * 2 + 1 ) : NEW_LINE INDENT if sosu [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT sys . stdout . write ( count + ' \n ' ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) NEW_LINE DEDENT DEDENT return maxVal NEW_LINE DEDENT
def test_numJewelsInStones ( ) : NEW_LINE INDENT class Solution ( object ) : NEW_LINE INDENT def __init__ ( self , J , S ) : NEW_LINE INDENT self . J = J NEW_LINE self . S = S NEW_LINE DEDENT def numJewelsInStones ( self ) : NEW_LINE INDENT return self . J NEW_LINE DEDENT def isSightly ( self ) : NEW_LINE INDENT return self . S NEW_LINE DEDENT DEDENT sObj = Solution ( ) NEW_LINE J = ' aA ' NEW_LINE S = ' aAAbbbb ' NEW_LINE out = sObj . numJewelsInStones ( J , S ) NEW_LINE assert out == 0 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX , n = 100 , 10 NEW_LINE store = [ 0 ] * MAX NEW_LINE graph = np . zeros ( ( MAX , n ) ) NEW_LINE d = np . zeros ( ( MAX , n ) ) NEW_LINE def is_clique ( b ) : NEW_LINE INDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , b + 1 ) : NEW_LINE INDENT if graph [ store [ i ] ] [ store [ j ] ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT def max_cliques ( i , l ) : NEW_LINE INDENT max_ = 0 NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT store [ l ] = j NEW_LINE if is_clique ( l + 1 ) : NEW_LINE INDENT max_ = max ( max_ , l ) NEW_LINE max_ = max ( max_ , max_cliques ( j , l + 1 ) ) NEW_LINE DEDENT DEDENT return max_ NEW_LINE DEDENT edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 1 ] , [ 4 , 2 ] ] NEW_LINE size = len ( edges ) NEW_LINE n = 4 NEW_LINE for i in range ( size ) : NEW_LINE INDENT graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 NEW_LINE graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 NEW_LINE d [ edges [ i ] [ 0 ] ] += 1 NEW_LINE d [ edges [ i ] [ 1 ] ] += 1 NEW_LINE DEDENT assert max_cliques ( 0 , 1 ) == 0 NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT k = int ( math . log ( n , 2 ) / math . log ( 2 ) ) NEW_LINE return int ( math . pow ( 2 , k ) ) NEW_LINE DEDENT
def xenia_and_spies ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ a ▁ list ▁ of ▁ the ▁ Xenia ▁ and ▁ Spies ▁ of ▁ the ▁ given ▁ input . STRNEWLINE ▁ """ NEW_LINE input = open ( ' input . txt ' , ' r ' ) . read ( ) . split ( ) NEW_LINE m = int ( input [ 1 ] ) NEW_LINE s = int ( input [ 2 ] ) NEW_LINE f = int ( input [ 3 ] ) NEW_LINE max_t = - 1 NEW_LINE d = { } NEW_LINE while m > 0 : NEW_LINE INDENT mth = input [ m ] . split ( ) NEW_LINE k = int ( mth [ 0 ] ) NEW_LINE d [ k ] = [ ] NEW_LINE d [ k ] . append ( int ( mth [ 1 ] ) ) NEW_LINE d [ k ] . append ( int ( mth [ 2 ] ) ) NEW_LINE max_t = max ( max_t , k ) NEW_LINE m -= 1 NEW_LINE DEDENT actions = [ ] NEW_LINE def M ( s , f ) : NEW_LINE INDENT d = ( s < f ) + 1 NEW_LINE cur = s NEW_LINE a = - 1 NEW_LINE b = - 1 NEW_LINE for t in range ( 1 , max_t + 1 ) : NEW_LINE INDENT if d . has_key ( t ) : NEW_LINE INDENT a = d [ t ] [ 0 ] NEW_LINE b = d [ t ] [ 1 ] NEW_LINE DEDENT if d . has_key ( t ) and ( ( cur >= a and cur <= b ) or ( cur + d >= a and cur + d <= b ) ) : NEW_LINE INDENT actions . append ( ' X ' ) NEW_LINE DEDENT else : NEW_LINE INDENT actions . append ( M ( s , f ) ) NEW_LINE cur += d NEW_LINE DEDENT if cur == f : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT while cur != f : NEW_LINE INDENT actions . append ( M ( cur , f ) ) NEW_LINE cur += d NEW_LINE DEDENT print ( actions ) NEW_LINE DEDENT return actions NEW_LINE DEDENT
def test_subset_pair_not_divisible_by_K ( ) : NEW_LINE INDENT """ Test ▁ if ▁ the ▁ number ▁ of ▁ subsets ▁ of ▁ a ▁ set ▁ is ▁ not ▁ divisible ▁ by ▁ K . """ NEW_LINE arr = [ 0 ] * K NEW_LINE for i in range ( N ) : NEW_LINE INDENT f = [ 0 ] * K NEW_LINE for i in range ( K ) : NEW_LINE INDENT f [ arr [ i ] % K ] += 1 NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT f [ K / 2 ] = min ( f [ K / 2 ] , 1 ) NEW_LINE DEDENT res = min ( f [ 0 ] , 1 ) NEW_LINE for i in range ( 1 , K / 2 + 1 ) : NEW_LINE INDENT res += max ( f [ i ] , f [ K - i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT
def main ( a ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import random NEW_LINE import struct NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import struct NEW_LINE import random NEW_LINE import struct NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import
def GFG ( a , b , c ) : NEW_LINE INDENT print ( 1 , c / ( a * 1.0 ) ) NEW_LINE DEDENT
def GFG ( pos , fl , pr , bin ) : NEW_LINE INDENT if pos == len ( bin ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if memo [ pos ] [ fl ] [ pr ] != - 1 : NEW_LINE INDENT return memo [ pos ] [ fl ] [ pr ] NEW_LINE DEDENT val = 0 NEW_LINE if bin [ pos ] == '0' : NEW_LINE INDENT val = val + dp ( pos + 1 , fl , 0 , bin ) NEW_LINE DEDENT elif bin [ pos ] == '1' : NEW_LINE INDENT val = val + dp ( pos + 1 , 1 , 0 , bin ) NEW_LINE DEDENT if pr == 0 : NEW_LINE INDENT if fl == 1 : NEW_LINE INDENT val += dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT elif bin [ pos ] == '1' : NEW_LINE INDENT val += dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT DEDENT return memo [ pos ] [ fl ] [ pr ] = val NEW_LINE def findIntegers ( num ) : NEW_LINE INDENT bin = " " NEW_LINE while num > 0 : NEW_LINE INDENT if num % 2 == 1 : NEW_LINE INDENT bin += "1" NEW_LINE DEDENT else : NEW_LINE INDENT bin += "0" NEW_LINE DEDENT num /= 2 NEW_LINE DEDENT bin = reverse ( bin ) NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT for l in range ( 2 ) : NEW_LINE INDENT memo [ i ] [ j ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT return dp ( 0 , 0 , 0 , bin ) NEW_LINE DEDENT reverse ( input ) NEW_LINE a = input . split ( ) NEW_LINE l , r = len ( a ) - 1 , len ( a ) NEW_LINE for l in range ( r ) : NEW_LINE INDENT temp = a [ l ] NEW_LINE a [ l ] , a [ r ] = a [ r ] , temp NEW_LINE DEDENT return str ( a ) NEW_LINE DEDENT
def GFG ( mat , n ) : NEW_LINE INDENT N = 4 NEW_LINE MaximumDecimalValue = [ 1 ] * n NEW_LINE if mat [ 0 ] [ 0 ] == 1 : NEW_LINE INDENT dp = [ 1 ] * n NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ 0 ] [ i ] == 1 : NEW_LINE INDENT dp [ 0 ] [ i ] = int ( dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ 0 ] == 1 : NEW_LINE INDENT dp [ i ] [ 0 ] = int ( dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if mat [ i ] [ j ] == 1 : NEW_LINE INDENT dp [ i ] [ j ] = int ( max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT
def pyGFG ( n ) : NEW_LINE INDENT """ STRNEWLINE ▁ Create ▁ a ▁ hash ▁ of ▁ the ▁ given ▁ number ▁ of ▁ primes . STRNEWLINE ▁ """ NEW_LINE prev , curr = 0 , 1 NEW_LINE hash = [ prev , curr ] NEW_LINE while curr < n : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . append ( temp ) NEW_LINE prev , curr = curr , temp NEW_LINE DEDENT return hash NEW_LINE DEDENT
def genmodular ( a , n ) : NEW_LINE INDENT """ Generate ▁ a ▁ modular ▁ graph ▁ of ▁ n ▁ modular ▁ symbols . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ a ▁ : ▁ array _ like STRNEWLINE ▁ Input ▁ array . STRNEWLINE ▁ n ▁ : ▁ int STRNEWLINE ▁ Degree ▁ of ▁ the ▁ generated ▁ modular ▁ graph . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ G ▁ : ▁ NetworkX ▁ graph STRNEWLINE ▁ A ▁ modular ▁ graph . STRNEWLINE STRNEWLINE ▁ Examples STRNEWLINE ▁ - - - - - STRNEWLINE ▁ > > > ▁ from ▁ scipy . sparse ▁ import ▁ digraph STRNEWLINE ▁ > > > ▁ G = digraph ( [ [ 1 , ▁ 2 , ▁ 3 ] , ▁ [ 4 , ▁ 5 , ▁ 6 ] ] ) STRNEWLINE ▁ > > > ▁ print ( G . modular ( 2 ) ) STRNEWLINE ▁ [ 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 , ▁ 6 ] STRNEWLINE STRNEWLINE ▁ """ NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE return _genmodular_graph ( a , n ) NEW_LINE DEDENT
def max_length ( s , n ) : NEW_LINE INDENT ans = int ( s ) NEW_LINE A = [ ] NEW_LINE L = [ ] NEW_LINE R = [ ] NEW_LINE freq = [ 0 ] * ( n + 5 ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if s [ j ] - ' a ' == i : NEW_LINE INDENT count += 1 NEW_LINE DEDENT freq [ j ] = count NEW_LINE DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT L . append ( ( 2 * freq [ j - 1 ] ) - j ) NEW_LINE R . append ( ( 2 * freq [ j ] ) - j ) NEW_LINE DEDENT max_len = int ( ' ' ) NEW_LINE min_val = int ( ' ' ) NEW_LINE for j in range ( len ( L ) ) : NEW_LINE INDENT min_val = min ( min_val , L [ j ] ) NEW_LINE A . append ( min_val ) NEW_LINE l , r = 0 , j NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE if A [ mid ] <= R [ j ] : NEW_LINE INDENT max_len = max ( max_len , j - mid + 1 ) NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT DEDENT ans = max ( ans , max_len ) NEW_LINE A . reverse ( ) NEW_LINE R . reverse ( ) NEW_LINE L . reverse ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT return self . x , self . y NEW_LINE DEDENT DEDENT N = 100005 NEW_LINE gr = Vector ( N ) NEW_LINE colour = [ ] NEW_LINE edges = Vector ( ) NEW_LINE bip = False NEW_LINE def add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] . append ( y ) NEW_LINE gr [ y ] . append ( x ) NEW_LINE edges . append ( ( x , y ) ) NEW_LINE DEDENT def dfs ( x , col ) : NEW_LINE INDENT colour . append ( col ) NEW_LINE for i in gr [ x ] : NEW_LINE INDENT if colour [ i ] == - 1 : NEW_LINE INDENT dfs ( i , col ^ 1 ) NEW_LINE DEDENT elif colour [ i ] == col : NEW_LINE INDENT bip = False NEW_LINE DEDENT DEDENT DEDENT def Directed_Graph ( n , m ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT colour . append ( - 1 ) NEW_LINE DEDENT bip = True NEW_LINE dfs ( 1 , 1 ) NEW_LINE if not bip : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if colour [ edges [ i ] [ 0 ] ] == 0 : NEW_LINE INDENT del edges [ i ] NEW_LINE DEDENT print ( edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT def test_directed ( ) : NEW_LINE INDENT n , m = 4 , 3 NEW_LINE for i in range ( N ) : NEW_LINE INDENT gr = Directed_Graph ( n , m ) NEW_LINE DEDENT add_edge ( 1 , 2 ) NEW_LINE add_edge ( 1 , 3 ) NEW_LINE add_edge ( 1 , 4 ) NEW_LINE Directed_Graph ( n , m ) NEW_LINE DEDENT DEDENT
def test_ehab_odd_person ( ) : NEW_LINE INDENT f = open ( ' ehabo . txt ' , ' r ' ) NEW_LINE n = int ( f . readline ( ) . strip ( ) ) NEW_LINE line1 = f . readline ( ) . strip ( ) . split ( ) NEW_LINE arr = [ int ( x ) for x in line1 ] NEW_LINE odd , even = False , False NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even = True NEW_LINE DEDENT else : NEW_LINE INDENT odd = True NEW_LINE DEDENT ans . append ( arr [ i ] ) NEW_LINE DEDENT if odd and even : NEW_LINE INDENT ans . sort ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT assert ans [ i ] == arr [ i ] NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE o , g , x = getopt . getopt ( sys . argv [ 1 : ] , ' g : x : ' ) NEW_LINE n , borrow = 0 , 0 NEW_LINE o , g = getopt . getopt ( sys . argv [ 2 : ] , ' n : ' ) NEW_LINE for i in range ( 1 , g + 1 ) : NEW_LINE INDENT x = x + i * o NEW_LINE DEDENT borrow = x - n NEW_LINE if borrow <= 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( borrow ) NEW_LINE DEDENT DEDENT
def GFG ( k ) : NEW_LINE INDENT if k <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , k ) : NEW_LINE INDENT if k % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global a , l , ans , map NEW_LINE import string NEW_LINE import re NEW_LINE import random NEW_LINE import time NEW_LINE import sys NEW_LINE import os NEW_LINE import sys NEW_LINE import string NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys
def GFG ( ) : NEW_LINE INDENT maxn = 16 NEW_LINE dp , arr = precompute ( ) NEW_LINE dp = dp . copy ( ) NEW_LINE for i in range ( maxn ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , maxn ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT j = arr [ k ] NEW_LINE if i >= j and dp [ i - j ] != - 1 : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) ** ( 2 * n + 1 ) / 3 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = int ( sys . argv [ 1 ] ) NEW_LINE m = int ( sys . argv [ 2 ] ) NEW_LINE a = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT sum = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum . append ( a [ i ] + sum [ i - 1 ] ) NEW_LINE DEDENT d = { } NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT d [ sum [ i ] % m ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = d [ sum [ i ] % m ] NEW_LINE d [ sum [ i ] % m ] += x + 1 NEW_LINE DEDENT ans = 0 NEW_LINE if d . has_key ( 0l ) : NEW_LINE INDENT ans = d [ 0l ] NEW_LINE DEDENT for i in d : NEW_LINE INDENT if d [ i ] >= 2 : NEW_LINE INDENT for j in d [ i ] : NEW_LINE INDENT ans += j - 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def GFG ( arr , n , k ) : NEW_LINE INDENT count_one = [ int ( x ) for x in arr ] NEW_LINE sum = count_one [ 0 ] NEW_LINE if n == 1 : NEW_LINE INDENT if count_one [ 0 ] >= k : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT ans = int ( ' - 1' ) NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while i < n : NEW_LINE INDENT if k == count_one [ j ] : NEW_LINE INDENT ans = 1 NEW_LINE break NEW_LINE DEDENT elif k == count_one [ i ] : NEW_LINE INDENT ans = 1 NEW_LINE break NEW_LINE DEDENT elif sum + count_one [ i ] < k : NEW_LINE INDENT sum += count_one [ i ] NEW_LINE i += 1 NEW_LINE DEDENT elif sum + count_one [ i ] > k : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) NEW_LINE sum -= count_one [ j ] NEW_LINE j += 1 NEW_LINE DEDENT elif sum + count_one [ i ] == k : NEW_LINE INDENT ans = min ( ans , ( i - j ) + 1 ) NEW_LINE sum += count_one [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if ans != int ( ' - 1' ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def GFG ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = float ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) NEW_LINE print ( ' Loss ▁ = ▁ % s ' % str ( loss ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n , m , x = sys . argv [ 1 : ] NEW_LINE a = [ 1 for i in range ( m ) ] NEW_LINE ans1 , ans2 = 0 , 0 NEW_LINE for i in range ( x , 0 , - 1 ) : NEW_LINE INDENT ans1 += a [ i ] NEW_LINE DEDENT for i in range ( x , n ) : NEW_LINE INDENT ans2 += a [ i ] NEW_LINE DEDENT print ( min ( ans1 , ans2 ) ) NEW_LINE DEDENT
def test_a1138_SushiForTwo ( ) : NEW_LINE INDENT x = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 ] ) NEW_LINE n = len ( x ) NEW_LINE len , prev , one_seq , two_seq = 1 , 0 , 0 , 0 , 0 NEW_LINE while n : NEW_LINE INDENT x = x [ n - 1 ] NEW_LINE if x == 1 : NEW_LINE INDENT if prev == 1 : NEW_LINE INDENT one_seq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one_seq = 1 NEW_LINE DEDENT prev = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if prev == 2 : NEW_LINE INDENT two_seq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT two_seq = 1 NEW_LINE DEDENT prev = 2 NEW_LINE DEDENT if min ( one_seq , two_seq ) > len : NEW_LINE INDENT len = min ( one_seq , two_seq ) NEW_LINE DEDENT DEDENT assert len * 2 == n NEW_LINE DEDENT
def p092 ( ) : NEW_LINE INDENT print ( [ ] ) NEW_LINE def run ( ) : NEW_LINE INDENT LIMIT = library . pow ( 10 , 7 ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , LIMIT ) : NEW_LINE INDENT if is_class_89 ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT def is_class_89 ( x ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT return False NEW_LINE DEDENT except : NEW_LINE INDENT x = next_number ( x ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += ( x % 10 ) ** ( x % 10 ) NEW_LINE x /= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ fact ▁ of ▁ the ▁ degree ▁ of ▁ a ▁ polynomial . """ NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT assert fact == 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT M = 4 NEW_LINE N = 5 NEW_LINE mp = { } NEW_LINE for j in range ( N ) : NEW_LINE INDENT mp [ mat [ 0 ] [ j ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if mp [ mat [ i ] [ j ] ] != 1 and mp [ mat [ i ] [ j ] ] == i : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if i == M - 1 : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def anon_and_lines ( ) : NEW_LINE INDENT eps = 10e-9 NEW_LINE def func ( n , * args ) : NEW_LINE INDENT start = float ( n ) NEW_LINE end = float ( n ) NEW_LINE first = [ ] NEW_LINE second = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT st = np . array ( args [ i ] ) NEW_LINE a = np . array ( st ) NEW_LINE b = np . array ( st ) NEW_LINE y1 = a * ( start + eps ) + b NEW_LINE y2 = a * ( end - eps ) + b NEW_LINE first . append ( ( i + 1 , y1 , y2 ) ) NEW_LINE second . append ( ( i + 1 , y2 , y1 ) ) NEW_LINE DEDENT first . sort ( ) NEW_LINE second . sort ( ) NEW_LINE for i in first : NEW_LINE INDENT if first [ i ] [ ' id ' ] != second [ i ] [ ' id ' ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' NO ' ) NEW_LINE DEDENT class Pair ( object ) : NEW_LINE INDENT x1 , x2 = [ ] , [ ] NEW_LINE id = [ ] NEW_LINE def __init__ ( self , i , a , b ) : NEW_LINE INDENT self . x1 = a NEW_LINE self . x2 = b NEW_LINE self . id = i NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return ( ( self . x1 , self . x2 ) < ( other . x1 , other . x2 ) ) NEW_LINE DEDENT def __gt__ ( self , other ) : NEW_LINE INDENT return ( ( self . x1 , self . x2 ) > ( other . x1 , other . x2 ) ) NEW_LINE DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT return ( ( self . x1 , self . x2 ) == ( other . x1 , other . x2 ) ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' < % s ▁ % s ▁ % s > ' % ( func ( self . x1 , self . x2 ) , func ( self . x1 , self . x2 ) , func ( self . x1 , self . x2 ) ) NEW_LINE DEDENT DEDENT return Pair NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n , t , s , d NEW_LINE n = int ( sys . argv [ 1 ] ) NEW_LINE t = int ( sys . argv [ 2 ] ) NEW_LINE s = [ ] NEW_LINE d = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( sys . argv [ 1 ] ) NEW_LINE d . append ( sys . argv [ 2 ] ) NEW_LINE DEDENT sys . stdout . write ( solve ( s , d , t ) ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT
def GFG ( a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + a NEW_LINE a = a + d NEW_LINE DEDENT return sum NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT small , large = + 2147483647 , + 2147483647 NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] <= small : NEW_LINE INDENT small = arr [ i ] NEW_LINE DEDENT elif arr [ i ] <= large : NEW_LINE INDENT large = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == n : NEW_LINE INDENT print ( " No ▁ such ▁ triplet ▁ found " ) NEW_LINE return NEW_LINE DEDENT for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ j ] < large : NEW_LINE INDENT small = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( small , large , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT print ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : " ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT print ( i * i + " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE rem = [ N / K ] NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem . append ( ( N - i ) / K + 1 ) NEW_LINE DEDENT if K % 2 == 0 : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 NEW_LINE for i in range ( 1 , K / 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 NEW_LINE for i in range ( 1 , K / 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n , m = sys . argv [ 1 : ] NEW_LINE array = [ 0 ] * 20000 NEW_LINE n , m = sys . argv [ 2 : ] NEW_LINE while not ( n == 0 and m == 0 ) : NEW_LINE INDENT array = [ ] NEW_LINE for i in range ( n + m ) : NEW_LINE INDENT array . append ( sys . argv [ i ] ) NEW_LINE DEDENT array . sort ( ) NEW_LINE interval = 0 NEW_LINE nt = 0 NEW_LINE for time in array : NEW_LINE INDENT if time - nt > interval : NEW_LINE INDENT interval = time - nt NEW_LINE DEDENT nt = time NEW_LINE DEDENT print ( interval ) NEW_LINE n , m = sys . argv [ 3 : ] NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' qv ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ Usage : ▁ % s ▁ [ - v | - q | - v ] ▁ [ - v | - q ] """ % sys . argv [ 0 ] ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - v ' : NEW_LINE INDENT print ( " Verbose " ) NEW_LINE DEDENT elif o == ' - q ' : NEW_LINE INDENT print ( " Question " ) NEW_LINE DEDENT elif o == ' - v ' : NEW_LINE INDENT print ( " Version " ) NEW_LINE DEDENT elif o == ' - q ' : NEW_LINE INDENT print ( " Version ▁ without ▁ question " ) NEW_LINE DEDENT elif o == ' - v ' : NEW_LINE INDENT print ( " Verbose " ) NEW_LINE DEDENT elif o == ' - q ' : NEW_LINE INDENT print ( " Question ▁ without ▁ answer " ) NEW_LINE DEDENT elif o == ' - v ' : NEW_LINE INDENT print ( " Version ▁ without ▁ answer " ) NEW_LINE DEDENT elif o == ' - q ' : NEW_LINE INDENT print ( " Question ▁ with ▁ answer " ) NEW_LINE DEDENT elif o == ' - v ' : NEW_LINE INDENT print ( " Version ▁ with ▁ answer " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT PHI = 1.6180339 NEW_LINE f = [ 0 , 1 , 1 , 2 , 3 , 5 ] NEW_LINE fib = 5 NEW_LINE if n < 6 : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = int ( round ( fn * PHI ) ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT
def GFG ( n , k ) : NEW_LINE INDENT return ( 2 ** k ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ sum ▁ of ▁ the ▁ squares ▁ of ▁ the ▁ elements ▁ of ▁ the ▁ matrix . """ NEW_LINE n = 5 NEW_LINE if k > n : NEW_LINE INDENT return NEW_LINE DEDENT stripSum = [ [ 0 ] * n for k in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT stripSum [ 0 ] [ j ] = sum NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) NEW_LINE stripSum [ i ] [ j ] = sum NEW_LINE DEDENT DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT sum += stripSum [ i ] [ j ] NEW_LINE DEDENT print ( sum , end = ' ▁ ' ) NEW_LINE for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) NEW_LINE print ( sum , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def test_A30 ( ) : NEW_LINE INDENT A = symbols ( ' A ' , integer = True , positive = True ) NEW_LINE B = symbols ( ' B ' , integer = True , positive = True ) NEW_LINE N = symbols ( ' N ' , integer = True , positive = True ) NEW_LINE bigA = symbols ( ' bigA ' , integer = True , positive = True ) NEW_LINE bigB = symbols ( ' bigB ' , integer = True , positive = True ) NEW_LINE for x in [ - 1000 , 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 , - 1000 ,
def test_GFG ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , r + 1 , 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) NEW_LINE ans /= i NEW_LINE DEDENT assert ans == 1 NEW_LINE total_ways = ( ncr ( M , X ) * ncr ( W , Y ) ) NEW_LINE assert total_ways == ( ncr ( M , X ) * ncr ( W , Y ) ) NEW_LINE X , Y , M , W = MV . setup ( ' X , Y , M , W ' ) NEW_LINE assert total_ways == ( ncr ( X , Y ) * ncr ( W , X ) ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if n != 0 and ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT
def pythontools . choose ( n , k ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ a ▁ number ▁ of ▁ primes ▁ in ▁ a ▁ given ▁ number ▁ of ▁ integers . STRNEWLINE STRNEWLINE ▁ > > > ▁ from ▁ sympy . utilities . randtest ▁ import ▁ pythontools STRNEWLINE ▁ > > > ▁ n ▁ = ▁ 3 STRNEWLINE ▁ > > > ▁ p ▁ = ▁ pythontools . choose ( n , ▁ 2 ) STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( n ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( n ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( n ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( n ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( n ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( n ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ print ( p ) STRNEWLINE ▁ 3 STRNEWLINE ▁ """ NEW_LINE n = int ( n ) NEW_LINE P = int ( p ) NEW_LINE Even , Odd = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A =
def test_GFG ( ) : NEW_LINE INDENT a , m = symbols ( ' a ▁ m ' , integer = True , positive = True ) NEW_LINE for x in [ 1 , m ] : NEW_LINE INDENT if ( a ** x ) % m == 1 : NEW_LINE INDENT assert x == 1 NEW_LINE DEDENT DEDENT DEDENT
def GFG ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += x % 10 NEW_LINE x = x / 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT x = Symbol ( ' x ' ) NEW_LINE y = Symbol ( ' y ' ) NEW_LINE if y . is_integer : NEW_LINE INDENT assert ask ( Q . is_greater ( x , y ) , Q . is_greater ( x , y ) ) is True NEW_LINE DEDENT elif y . is_integer : NEW_LINE INDENT assert ask ( Q . is_greater ( x , y ) , Q . is_greater ( x , y ) ) is True NEW_LINE DEDENT else : NEW_LINE INDENT assert ask ( Q . is_greater ( x , y ) , Q . is_greater ( x , y ) ) is False NEW_LINE DEDENT DEDENT
def get_GFG ( str1 , str2 , n ) : NEW_LINE INDENT l , r = 0 , 0 NEW_LINE ans = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT l = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT if r < l : NEW_LINE INDENT return 26 * ( n + 1 ) NEW_LINE DEDENT elif l == r : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i - 1 ] : NEW_LINE INDENT ans -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if str1 [ i - 1 ] != str2 [ i ] : NEW_LINE INDENT ans -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
def test_solution10 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE str = [ ] NEW_LINE for z in range ( t ) : NEW_LINE INDENT n , x , m = symbols ( ' n ▁ x ▁ m ' , integer = True , positive = True ) NEW_LINE arr = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT arr . append ( [ n , x , i ] ) NEW_LINE DEDENT si = x NEW_LINE ei = x NEW_LINE for i in range ( m ) : NEW_LINE INDENT l = arr [ i ] [ 0 ] NEW_LINE r = arr [ i ] [ 1 ] NEW_LINE if ( l <= si and si <= r ) or ( l <= ei and ei <= r ) : NEW_LINE INDENT si = min ( l , si ) NEW_LINE ei = max ( r , ei ) NEW_LINE DEDENT DEDENT str . append ( ei - si + 1 ) NEW_LINE str . append ( ' ' ) NEW_LINE DEDENT assert str == [ ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' ] NEW_LINE DEDENT
def GFG ( n , l , r ) : NEW_LINE INDENT num , prev , curr = n >> ( l - 1 ) , n >> 1 NEW_LINE for i in range ( 1 , ( r - l ) + 1 ) : NEW_LINE INDENT curr = num & 1 NEW_LINE if curr == prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev , num = curr , num >> 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def eugene ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE k = len ( sys . argv ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( sys . argv [ i ] ) NEW_LINE DEDENT res = ' ' NEW_LINE o , e = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT o += 1 NEW_LINE DEDENT else : NEW_LINE INDENT e += 1 NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT l , r = divmod ( arr [ i ] , n ) NEW_LINE if ( r - l + 1 ) % 2 == 1 : NEW_LINE INDENT res += '0 \n ' NEW_LINE DEDENT else : NEW_LINE INDENT if ( r - l + 1 ) / 2 <= o and ( r - l + 1 ) / 2 <= e : NEW_LINE INDENT res += '1 \n ' NEW_LINE DEDENT else : NEW_LINE INDENT res += '0 \n ' NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT assert nth_group ( n ) == n * ( 2 ** int ( math . pow ( n , 2 ) ) + 1 ) NEW_LINE DEDENT
def ex711B ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ex711B STRNEWLINE ▁ """ NEW_LINE x = input ( ) NEW_LINE n = len ( x ) NEW_LINE magic_square = [ [ 0 ] * n for i in range ( n ) ] NEW_LINE row , column = - 1 , - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT magic_square [ i ] [ j ] = x [ i ] [ j ] NEW_LINE if magic_square [ i ] [ j ] == 0 : NEW_LINE INDENT row = i NEW_LINE column = j NEW_LINE DEDENT DEDENT DEDENT if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if row != 0 : NEW_LINE INDENT sum += magic_square [ 0 ] [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += magic_square [ 1 ] [ i ] NEW_LINE DEDENT DEDENT answer = sum NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer -= magic_square [ row ] [ i ] NEW_LINE DEDENT magic_square [ row ] [ column ] = answer NEW_LINE m = 0 NEW_LINE current_sumi , current_sumj = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT current_sumi += magic_square [ i ] [ j ] NEW_LINE current_sumj += magic_square [ j ] [ i ] NEW_LINE DEDENT if current_sumi != sum or current_sumj != sum : NEW_LINE INDENT m += 1 NEW_LINE DEDENT current_sumi = 0 NEW_LINE current_sumj = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT current_sumi += magic_square [ i ] [ i ] NEW_LINE current_sumj += magic_square [ n - i - 1 ] [ i ] NEW_LINE DEDENT if current_sumi != sum or current_sumj != sum : NEW_LINE INDENT m += 1 NEW_LINE DEDENT if m == 0 and answer > 0 : NEW_LINE INDENT print ( answer ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def test_issue_7171 ( ) : NEW_LINE INDENT x = Symbol ( ' x ' ) NEW_LINE n = Symbol ( ' n ' , integer = True ) NEW_LINE k = Symbol ( ' k ' , integer = True ) NEW_LINE arr = [ ] NEW_LINE sum1 , sum2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE sum1 = sum1 + arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT csum = 0 NEW_LINE csum = arr [ i ] + arr [ i - 1 ] NEW_LINE if k > csum : NEW_LINE INDENT arr [ i ] = arr [ i ] + k - csum NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT sum2 = sum2 + arr [ i ] NEW_LINE DEDENT assert sum2 - sum1 == 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def get_maximum_occurred_element ( L , R , n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) NEW_LINE maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ L [ i ] ] += 1 NEW_LINE arr [ R [ i ] + 1 ] -= 1 NEW_LINE if R [ i ] > maxi : maxi = R [ i ] NEW_LINE DEDENT msum = arr [ 0 ] NEW_LINE ind = 0 NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE if msum < arr [ i ] : NEW_LINE INDENT msum = arr [ i ] NEW_LINE ind = i NEW_LINE DEDENT DEDENT return ind NEW_LINE DEDENT
def test_Rough_02 ( ) : NEW_LINE INDENT x = Symbol ( ' x ' ) NEW_LINE n = Symbol ( ' n ' , integer = True ) NEW_LINE arr = [ x ** i for i in range ( n ) ] NEW_LINE count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] != arr [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT assert count == 1 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n , m NEW_LINE if n == 0 : NEW_LINE INDENT if m != 0 : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , 0 , 0 ) NEW_LINE DEDENT return NEW_LINE DEDENT if m <= n : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT m = 1 NEW_LINE DEDENT print ( n , ( m + n - 1 ) , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT print ( m , ( m + n - 1 ) , end = ' ▁ ' ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT func = lambda x : ( 1 / ( 1 + x ** 2 ) ) NEW_LINE calculate = lambda lower_limit , upper_limit , interval_limit : ( lower_limit , upper_limit ) NEW_LINE value = 0 NEW_LINE interval_size = ( upper_limit - lower_limit ) / interval_limit NEW_LINE sum = func ( lower_limit ) + func ( upper_limit ) NEW_LINE for i in range ( 1 , interval_limit ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT sum = sum + 2 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + 3 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT DEDENT assert ( 3 * interval_size / 8 ) == sum NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n , k , x , y NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , " k : x : y : " ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( msg + " \n " ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT if args == [ ] : NEW_LINE INDENT n = 1 NEW_LINE DEDENT elif args == [ " - k " , " - - k " ] : NEW_LINE INDENT k = int ( args [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT n = 1 NEW_LINE DEDENT if len ( args ) != 2 : NEW_LINE INDENT sys . exit ( 2 ) NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o in ( " - k " , " - - k " ) : NEW_LINE INDENT k = int ( a ) NEW_LINE DEDENT elif o in ( " - x " , " - - x " ) : NEW_LINE INDENT x = int ( a ) NEW_LINE DEDENT elif o in ( " - y " , " - - y " ) : NEW_LINE INDENT y = int ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . exit ( 2 ) NEW_LINE DEDENT DEDENT if n == 1 : NEW_LINE INDENT x = x * k NEW_LINE y = y * ( n - k ) NEW_LINE DEDENT else : NEW_LINE INDENT x = x * n NEW_LINE y = y * ( n - k ) NEW_LINE DEDENT sys . stdout . write ( " % d \n " % ( n ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while 1 : NEW_LINE INDENT x , h = sys . stdin . readline ( ) . split ( ) NEW_LINE if x == ' ' and h == ' ' : NEW_LINE INDENT break NEW_LINE DEDENT c = math . sqrt ( h ** 2 + ( x / 2 ) ** 2 ) NEW_LINE ans = x ** 2 + x * c / 2 ** 4 NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( msg + " \n " ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT if args == [ ] : NEW_LINE INDENT sys . stdout . write ( " No ▁ input ▁ files . \n " ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT k , i , mo = 1 , 19 NEW_LINE k = int ( args [ 0 ] ) NEW_LINE while i != k : NEW_LINE INDENT mo += 1 NEW_LINE if 10 == count ( mo ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT sys . stdout . write ( mo + " \n " ) NEW_LINE DEDENT
def pygmm_prime ( n ) : NEW_LINE INDENT import numpy as np NEW_LINE import random NEW_LINE import math NEW_LINE import sys NEW_LINE MAX = 1000000 NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE sieve = [ True for i in range ( 2 , MAX * p ) ] NEW_LINE for p in range ( 2 , MAX * p + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT print_prime_quad ( n ) NEW_LINE for i in range ( n - 7 ) : NEW_LINE INDENT if prime [ i ] and prime [ i + 2 ] and prime [ i + 6 ] and prime [ i + 8 ] : NEW_LINE INDENT print ( i , ( i + 2 ) , ( i + 6 ) , ( i + 8 ) ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 ] * MAX ] NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if x [ j - 1 ] == y [ i - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n , a , b = symbols ( ' n ▁ a ▁ b ' , integer = True , positive = True ) NEW_LINE assert find_sum ( n , a , b ) == 0 NEW_LINE DEDENT
def test_tanyaandpostcard ( ) : NEW_LINE INDENT f = py . io . TextIO ( ) NEW_LINE s1 = f . reset ( ) NEW_LINE s2 = f . reset ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE i , y , w = 0 , 0 , 0 NEW_LINE ch = None NEW_LINE for i in range ( len ( s2 ) ) : NEW_LINE INDENT a . append ( s2 [ i ] ) NEW_LINE DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT ch = s1 [ i ] NEW_LINE if a [ ch ] >= 1 : NEW_LINE INDENT a [ ch ] -= 1 NEW_LINE b . append ( 1 ) NEW_LINE y += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT ch = s1 [ i ] NEW_LINE if b [ i ] == 0 : NEW_LINE INDENT if ch <= 90 : NEW_LINE INDENT ch = chr ( int ( ch + 32 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ch = chr ( int ( ch - 32 ) ) NEW_LINE DEDENT if a [ ch ] >= 1 : NEW_LINE INDENT a [ ch ] -= 1 NEW_LINE w += 1 NEW_LINE DEDENT DEDENT DEDENT assert y == w NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 1000 NEW_LINE sequence = [ 0 ] * MAX NEW_LINE vanEckSequence ( ) NEW_LINE for i in range ( MAX - 1 ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( MAX - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if sequence [ j ] == sequence [ i ] : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT getNthTerm ( n ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 100000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) NEW_LINE vanEckSequence ( ) NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if sequence [ j ] == sequence [ i ] : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT count = 1 NEW_LINE i = n - 1 NEW_LINE while sequence [ i + 1 ] != 0 : NEW_LINE INDENT count += 1 NEW_LINE i = i - sequence [ i + 1 ] NEW_LINE DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT vanEckSequence ( ) NEW_LINE n = 5 NEW_LINE print ( getCount ( n ) ) NEW_LINE n = 11 NEW_LINE print ( getCount ( n ) ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 100000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT sequence [ i ] = 0 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if sequence [ j ] == sequence [ i ] : NEW_LINE INDENT sequence [ i + 1 ] = i - j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT nthTerm = sequence [ n - 1 ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if sequence [ i ] == nthTerm : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT vanEckSequence ( ) NEW_LINE n = 5 NEW_LINE print ( getCount ( n ) ) NEW_LINE n = 11 NEW_LINE print ( getCount ( n ) ) NEW_LINE DEDENT DEDENT
def __gcd ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import time NEW_LINE import calendar NEW_LINE import doctest NEW_LINE import os NEW_LINE import re NEW_LINE import urllib NEW_LINE import urllib . parse NEW_LINE import urllib . request NEW_LINE import urllib . response NEW_LINE import urllib . request NEW_LINE import urllib . parse NEW_LINE import urllib . response NEW_LINE import urllib . request NEW_LINE import urllib . parse NEW_LINE import urllib . parse NEW_LINE import urllib . request NEW_LINE import urllib . response NEW_LINE import urllib . parse NEW_LINE import urllib . request NEW_LINE import urllib . parse NEW_LINE import urllib . response NEW_LINE import urllib . parse NEW_LINE import urllib . request NEW_LINE import urllib . parse NEW_LINE import urllib . request NEW_LINE import urllib . parse NEW_LINE import urllib . response NEW_LINE import urllib . parse NEW_LINE import urllib . request NEW_LINE import urllib . parse NEW_LINE import urllib . response NEW_LINE import urllib . parse NEW_LINE import urllib . request NEW_LINE import urllib . parse NEW_LINE import urllib . response NEW_LINE import urllib . parse NEW_LINE import urllib . request NEW_LINE import urllib . parse NEW_LINE import urllib . response NEW_LINE import urllib . parse NEW_LINE import urllib . request NEW_LINE import urllib . response NEW_LINE import urllib . parse NEW_LINE import urllib . parse NEW_LINE import urllib . request NEW_LINE import urllib . parse NEW_LINE import urllib . response NEW_LINE import urllib . parse NEW_LINE import urllib . request NEW_LINE import urllib . response NEW_LINE import urllib . parse NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . request NEW_LINE import urllib . response NEW_LINE import urllib . parse NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . response NEW_LINE import urllib . parse NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . response NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . response NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . response NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . response NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE import urllib . error NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE import pickle NEW_LINE import queue NEW_LINE def read ( ) : NEW_LINE INDENT cnt = 0 NEW_LINE event = None NEW_LINE events = queue . Queue ( ) NEW_LINE do ( ) NEW_LINE if event == ' OUT ' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT events . put ( event ) NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT ans , s = 0 , 0 NEW_LINE while not events . empty ( ) : NEW_LINE INDENT e = events . get ( ) NEW_LINE s = ( s << 1 ) + 1 NEW_LINE if e == ' HIT ' : NEW_LINE INDENT if ( s & 8 ) > 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT s = ( s & 7 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , 16 ) : NEW_LINE INDENT if ( s & i ) >= 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT ans , s = 0 , 0 NEW_LINE while n ( ) and read ( ) : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT
def pythontools ( arr ) : NEW_LINE INDENT import math NEW_LINE import doctest NEW_LINE class solution : NEW_LINE INDENT def foot ( self , a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / float ( a ** 2 + b ** 2 + c ** 2 ) NEW_LINE x2 = a * k + x1 NEW_LINE y2 = b * k + y1 NEW_LINE z2 = c * k + z1 NEW_LINE print ( " x2 ▁ = ▁ % s " % str ( x2 ) ) NEW_LINE print ( " ▁ y2 ▁ = ▁ % s " % str ( y2 ) ) NEW_LINE print ( " ▁ z2 ▁ = ▁ % s " % str ( z2 ) ) NEW_LINE DEDENT def doit ( self , arr ) : NEW_LINE INDENT a = 1 NEW_LINE b = - 2 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE x1 = - 1 NEW_LINE y1 = 3 NEW_LINE z1 = 4 NEW_LINE foot ( a , b , c , d , x1 , y1 , z1 ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE if len ( sys . argv ) == 2 : NEW_LINE INDENT c1 = sys . argv [ 1 ] NEW_LINE c2 = sys . argv [ 2 ] NEW_LINE if c1 [ 0 ] == c2 [ - 1 ] and c2 [ 0 ] == c1 [ - 1 ] and c1 [ 1 ] == c2 [ 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT sys . exit ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ERROR " ) NEW_LINE DEDENT DEDENT
def get_minimum_ops ( ar ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE small = sorted ( ar ) NEW_LINE large = sorted ( ar ) NEW_LINE dp = [ [ abs ( ar [ 0 ] - j ) for j in range ( small , large + 1 ) ] for i in range ( 1 , n ) ] NEW_LINE for i in range ( small , large + 1 ) : NEW_LINE INDENT minimum = sys . maxint NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ j ] ) NEW_LINE dp [ i ] [ j ] = minimum + abs ( ar [ i ] - j ) NEW_LINE DEDENT DEDENT ans = sys . maxint NEW_LINE for j in range ( small , large + 1 ) : NEW_LINE INDENT ans = min ( ans , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT pi = 3.14159265 NEW_LINE assert ( a ** 2 * ( pi / 2 - 1 ) ) . ae ( pi / 2 - 1 ) NEW_LINE DEDENT
def pythree_remove_alternate ( n ) : NEW_LINE INDENT class Circular ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def removeAlternate ( self ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return 2 * removeAlternate ( n / 2 ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * removeAlternate ( ( ( n - 1 ) / 2 ) ) + 1 NEW_LINE DEDENT DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " % s " % self . n NEW_LINE DEDENT DEDENT n = 5 NEW_LINE print ( " \n % s " % removeAlternate ( n ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if n == 2 or m == 2 or n % m == 0 : NEW_LINE INDENT assert ask ( Q . prime ( n ) , Q . prime ( m ) ) NEW_LINE DEDENT else : NEW_LINE INDENT assert ask ( Q . prime ( n ) , Q . prime ( m ) ) NEW_LINE DEDENT DEDENT
def color_the_picture ( ) : NEW_LINE INDENT f = open ( ' color _ the _ picture . txt ' , ' r ' ) NEW_LINE pr = open ( ' color _ the _ picture . txt ' , ' w ' ) NEW_LINE t = int ( f . readline ( ) ) NEW_LINE while t != 0 : NEW_LINE INDENT solve ( f , pr ) NEW_LINE t -= 1 NEW_LINE DEDENT pr . flush ( ) NEW_LINE pr . close ( ) NEW_LINE return NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT positive , negative = 1 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if arr [ i ] == 1 : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT positive , negative = 1 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if arr [ i ] == 1 : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT
def pycf3 ( ) : NEW_LINE INDENT import sys NEW_LINE import tokenize NEW_LINE import doctest NEW_LINE import tempfile NEW_LINE import os NEW_LINE import random NEW_LINE import time NEW_LINE import string NEW_LINE import doctest NEW_LINE import tempfile NEW_LINE import random NEW_LINE import time NEW_LINE import string NEW_LINE import tempfile NEW_LINE import random NEW_LINE import string NEW_LINE import tempfile NEW_LINE import random NEW_LINE import time NEW_LINE import string NEW_LINE import random NEW_LINE import string NEW_LINE import tempfile NEW_LINE import random NEW_LINE import time NEW_LINE import string NEW_LINE import tempfile NEW_LINE import random NEW_LINE import string NEW_LINE import string NEW_LINE import tempfile NEW_LINE import random NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import tempfile NEW_LINE import random NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE
def main ( ) : NEW_LINE INDENT f = open ( ' / home / jdoe / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . / . / . / . / . / . / . / . / . / . / . /
def main ( arr , n ) : NEW_LINE INDENT LIS = [ ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS . append ( 1 ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return n - len NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT max_upto = [ ] NEW_LINE s = Stack ( ) NEW_LINE s . push ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while not s . empty ( ) and a [ s . pop ( ) ] < a [ i ] : NEW_LINE INDENT max_upto . append ( i - 1 ) NEW_LINE s . pop ( ) NEW_LINE DEDENT s . push ( i ) NEW_LINE DEDENT while not s . empty ( ) : NEW_LINE INDENT max_upto . append ( n - 1 ) NEW_LINE s . pop ( ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 0 , n - k ) : NEW_LINE INDENT while j < i or max_upto [ j ] < i + k - 1 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print ( a [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def p_p056 ( p ) : NEW_LINE INDENT ''' p056 ▁ : ▁ INTEGER ▁ ' + ' ▁ INTEGER ▁ ' - ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' - ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' - ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' - ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' - ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' - ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' - ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' / ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ INTEGER ▁ ' * ' ▁ ''' NEW_LINE DEDENT
def countWindowDistinct ( win , k ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ number ▁ of ▁ distinct ▁ elements ▁ in ▁ a ▁ window . STRNEWLINE STRNEWLINE ▁ : param ▁ win : ▁ A ▁ list ▁ of ▁ integers . STRNEWLINE ▁ : param ▁ k : ▁ The ▁ number ▁ of ▁ elements ▁ in ▁ the ▁ window . STRNEWLINE ▁ : return : ▁ The ▁ number ▁ of ▁ distinct ▁ elements ▁ in ▁ the ▁ window . STRNEWLINE ▁ """ NEW_LINE dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if win [ i ] == win [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT if j == i : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT DEDENT DEDENT return dist_count NEW_LINE DEDENT
def GFG ( str ) : NEW_LINE INDENT len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = str [ i ] - '0' NEW_LINE if temp % 2 == 0 : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def solution ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if index == n : NEW_LINE INDENT if cnt == k : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if dp [ index ] [ cnt ] != - 1 : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += count_ways ( index + 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * count_ways ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE return dp [ index ] [ cnt ] = ans NEW_LINE DEDENT
def get_sym ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , math . sqrt ( n ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + ( n / i ) NEW_LINE DEDENT DEDENT DEDENT return sum - n NEW_LINE DEDENT
def test_pasha_and_hamsters ( ) : NEW_LINE INDENT import numpy as np NEW_LINE import numpy . ma as ma NEW_LINE dims = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE total = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE at , pt = ma . histogram ( dims , bins = total ) NEW_LINE vals = np . zeros ( total ) NEW_LINE as = ma . array ( [ 1 , 2 , 3 ] ) NEW_LINE for i in range ( len ( as ) ) : NEW_LINE INDENT x = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE vals [ x - 1 , i ] = True NEW_LINE DEDENT s = ' ' NEW_LINE for i in range ( total ) : NEW_LINE INDENT s += ( vals [ i ] or '1' ) + ' ▁ ' NEW_LINE DEDENT assert s == ' ' NEW_LINE DEDENT
def pythree_vector ( arr , n ) : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT swap ( arr , i , ( n + ~ i + 1 ) + ~ 1 + 1 ) NEW_LINE DEDENT swap ( arr , i , j ) NEW_LINE temp = arr [ i ] NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , temp NEW_LINE return arr NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE a = 1 NEW_LINE cnt = 0 NEW_LINE flag = True NEW_LINE sum += a NEW_LINE while cnt < N : NEW_LINE INDENT nextElement = 0 NEW_LINE if flag == True : NEW_LINE INDENT nextElement = a * 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * 3 / 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT a = nextElement NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( msg + ' \n ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - d ' : NEW_LINE INDENT d = a NEW_LINE DEDENT elif o == ' - u ' : NEW_LINE INDENT u = a NEW_LINE DEDENT elif o == ' - e ' : NEW_LINE INDENT e = a NEW_LINE DEDENT else : NEW_LINE INDENT a , b = ( o , a % 2 ) NEW_LINE print ( a , b ) NEW_LINE DEDENT DEDENT return d NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT from sympy . polys . distributedmodules import gf_degree NEW_LINE sz = int ( 1e5 ) NEW_LINE is_prime = [ False ] * sz + [ False ] * sz NEW_LINE sieve = gf_degree ( [ ] , 1 , ZZ ) NEW_LINE for i in range ( 2 , sz * sz + 1 ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT is_prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT min_difference = 0 NEW_LINE for i in range ( L , R ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT fst = i NEW_LINE break NEW_LINE DEDENT DEDENT snd = 0 NEW_LINE for i in range ( fst + 1 , R ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT snd = i NEW_LINE break NEW_LINE DEDENT DEDENT if not snd : NEW_LINE INDENT return - 1 NEW_LINE DEDENT diff = snd - fst NEW_LINE left = snd + 1 NEW_LINE right = R NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT if i - snd <= diff : NEW_LINE INDENT fst = snd NEW_LINE snd = i NEW_LINE diff = snd - fst NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE pre_cnt = 0 NEW_LINE while start < n and arr [ start ] == 1 : NEW_LINE INDENT pre_cnt += 1 NEW_LINE start += 1 NEW_LINE DEDENT end = n - 1 NEW_LINE suff_cnt = 0 NEW_LINE while end >= 0 and arr [ end ] == 1 : NEW_LINE INDENT suff_cnt += 1 NEW_LINE end -= 1 NEW_LINE DEDENT if start > end : NEW_LINE INDENT return n NEW_LINE DEDENT mid_cnt = 0 NEW_LINE result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT mid_cnt += 1 NEW_LINE result = max ( result , mid_cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT mid_cnt = 0 NEW_LINE DEDENT DEDENT return max ( result , pre_cnt + suff_cnt ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT s = sys . stdin NEW_LINE d = len ( s ) NEW_LINE n = len ( s ) NEW_LINE temp = [ ] NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE c = [ ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT temp . append ( s [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT a . append ( s [ i ] ) NEW_LINE b . append ( s [ i ] ) NEW_LINE c . append ( s [ i ] ) NEW_LINE DEDENT dp = [ ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp . append ( - 1 ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= temp [ 0 ] and b [ i ] >= temp [ 0 ] : NEW_LINE INDENT dp . append ( 0 ) NEW_LINE DEDENT DEDENT for i in range ( 1 , d ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ j ] <= temp [ i ] and b [ j ] >= temp [ i ] : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if dp [ i - 1 ] [ k ] < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( c [ j ] - c [ k ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , dp [ d - 1 ] [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import getopt NEW_LINE import imp NEW_LINE import pdb NEW_LINE import pdb NEW_LINE import pdb . post_mortem NEW_LINE import pdb . set_trace NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE import pdb . set_trace ( ) NEW_LINE DEDENT
def GFG ( s ) : NEW_LINE INDENT pSq = None NEW_LINE N = None NEW_LINE for i in range ( int ( s ) ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT pSq = i NEW_LINE N = j NEW_LINE break NEW_LINE DEDENT DEDENT if pSq : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT d = s - pSq NEW_LINE P = d / ( 2.0 * N ) NEW_LINE A = N + P NEW_LINE sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) NEW_LINE return sqrt_of_s NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT n = len ( line ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE s = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( line [ i ] ) NEW_LINE b . append ( 0 ) NEW_LINE DEDENT tem = 1 NEW_LINE q = 0 NEW_LINE while q != n : NEW_LINE INDENT s += 1 NEW_LINE if tem == 1 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= q and b [ i ] == 0 : NEW_LINE INDENT b . append ( 1 ) NEW_LINE q += 1 NEW_LINE DEDENT DEDENT tem = 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] <= q and b [ i ] == 0 : NEW_LINE INDENT b . append ( 1 ) NEW_LINE q += 1 NEW_LINE DEDENT DEDENT tem = 1 NEW_LINE DEDENT DEDENT sys . stdout . write ( " % d \n " % s ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while True : NEW_LINE INDENT r = sys . stdin . readline ( ) NEW_LINE n = r . rstrip ( ) NEW_LINE if r == ' ' : NEW_LINE INDENT break NEW_LINE DEDENT field = [ 0 ] * 40 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xl = r . rstrip ( ) NEW_LINE xr = r . rstrip ( ) NEW_LINE h = r . rstrip ( ) NEW_LINE for j in range ( xl + 20 , xr + 20 ) : NEW_LINE INDENT field [ j ] = max ( field [ j ] , h ) NEW_LINE DEDENT DEDENT min_time = INF NEW_LINE for i in range ( len ( field ) ) : NEW_LINE INDENT min_time = min ( min_time , cross_time ( i - 20 , field [ i ] , r ) ) NEW_LINE min_time = min ( min_time , cross_time ( i + 1 - 20 , field [ i ] , r ) ) NEW_LINE DEDENT print ( min_time ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = len ( sys . argv ) NEW_LINE list = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT list . append ( sys . argv [ i ] ) NEW_LINE DEDENT find ( list ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global num NEW_LINE if not sys . argv [ 1 : ] : NEW_LINE INDENT sys . exit ( __doc__ ) NEW_LINE DEDENT if len ( sys . argv ) == 1 : NEW_LINE INDENT num = sys . argv [ 1 ] NEW_LINE DEDENT if not sys . argv [ 2 : ] : NEW_LINE INDENT sys . exit ( __doc__ ) NEW_LINE DEDENT def read ( ) : NEW_LINE INDENT if sys . argv [ 2 ] : NEW_LINE INDENT num = sys . argv [ 2 ] NEW_LINE DEDENT if not sys . argv [ 3 ] : NEW_LINE INDENT sys . exit ( __doc__ ) NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT table = [ 0 , 1 , 2 , 3 , 5 , 7 , 8 , 9 ] NEW_LINE s = oct ( num ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT num2 = int ( ' ' . join ( [ ' % 02x ' % c for c in s [ i ] ] ) , 8 ) NEW_LINE print ( table [ num2 ] ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT num2 = int ( ' ' . join ( [ ' % 02x ' % c for c in s [ i ] ] ) , 8 ) NEW_LINE print ( table [ num2 ] ) NEW_LINE DEDENT DEDENT sys . exit ( solve ( ) ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ ] NEW_LINE inc = [ ] NEW_LINE dec = inc + [ arr [ 0 ] ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif arr [ j ] < arr [ i ] and flag == 1 : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT result = int ( ' ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if result < inc [ i ] : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if result < dec [ i ] : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def generate_arr ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return arr NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] & arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev & arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev & arr [ n - 1 ] NEW_LINE return arr NEW_LINE DEDENT
def pyGFG ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return arr NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE return arr NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev + arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev + arr [ n - 1 ] NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ triplets ▁ in ▁ the ▁ GFG . """ NEW_LINE A , B , C = symbols ( ' A , B , C ' ) NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert count_triplets ( A , B , C ) == 3 NEW_LINE assert
def test_GFG ( ) : NEW_LINE INDENT MAX = 100000 NEW_LINE prime = [ True ] * MAX + 1 NEW_LINE SieveOfEratosthenes ( ) NEW_LINE for i in range ( MAX + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , MAX * p + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT smallest_prime = int ( math . pow ( 10 , d - 1 ) ) NEW_LINE r = int ( math . pow ( 10 , d ) - 1 ) NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import os NEW_LINE import string NEW_LINE import time NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , f ) : NEW_LINE INDENT self . f = f NEW_LINE self . n = int ( self . f . readline ( ) ) NEW_LINE self . m = int ( self . f . readline ( ) ) NEW_LINE self . tir = [ ] NEW_LINE self . tir . append ( INF ) NEW_LINE self . tir . append ( 0 ) NEW_LINE self . d = [ ] NEW_LINE self . c = [ ] NEW_LINE for line in open ( self . f , ' r ' ) : NEW_LINE INDENT line = line . strip ( ) NEW_LINE n = int ( line ) NEW_LINE m = int ( line ) NEW_LINE tir . append ( min ( tir [ i + 1 ] [ j ] , tir [ i + 1 ] [ j + 1 ] + d [ j ] * c [ i ] ) ) NEW_LINE DEDENT self . tir . append ( tir [ 0 ] [ 0 ] ) NEW_LINE self . tir . append ( tir [ 0 ] [ 1 ] ) NEW_LINE d = [ ] NEW_LINE c = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d . append ( int ( line [ 0 ] ) ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT c . append ( int ( line [ 1 ] ) ) NEW_LINE DEDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT tir [ i ] [ j ] = min ( tir [ i + 1 ] [ j ] , tir [ i + 1 ] [ j + 1 ] + d [ j ] * c [ i ] ) NEW_LINE DEDENT DEDENT self . tir . append ( tir [ 0 ] [ 0 ] ) NEW_LINE self . tir . append ( tir [ 0 ] [ 1 ] ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT input = sys . stdin NEW_LINE n = int ( input [ 1 ] ) NEW_LINE k = int ( input [ 2 ] ) NEW_LINE x = input [ 3 ] NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( input [ i ] ) NEW_LINE DEDENT for i in range ( len ( arr ) - k , len ( arr ) ) : NEW_LINE INDENT arr [ i ] = x NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def test_automatic_door ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ the ▁ automatic ▁ door ▁ function . STRNEWLINE ▁ """ NEW_LINE n = Symbol ( ' n ' ) NEW_LINE m = Symbol ( ' m ' ) NEW_LINE a = Symbol ( ' a ' ) NEW_LINE d = Symbol ( ' d ' ) NEW_LINE arr = [ Symbol ( ' arr ' ) for i in range ( m ) ] NEW_LINE count = 0 NEW_LINE time = 0 NEW_LINE x = d / a + 1 NEW_LINE y = d - ( x - 1 ) * a NEW_LINE if y < 0 : NEW_LINE INDENT y = 0 NEW_LINE DEDENT last = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT b = max ( [ ( arr [ i ] - 1 ) / a , n ] ) NEW_LINE c = b - time NEW_LINE k = c / x NEW_LINE count += k NEW_LINE time += k * x NEW_LINE if k != 0 : NEW_LINE INDENT while i < m and arr [ i ] <= time * a + y : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if i >= m : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE last = arr [ i ] + d NEW_LINE if time < n : NEW_LINE INDENT last = min ( last , ( time + 1 ) * a + d ) NEW_LINE DEDENT while i < m and arr [ i ] <= last : NEW_LINE INDENT i += 1 NEW_LINE DEDENT time = max ( time , min ( n , last / a ) ) NEW_LINE DEDENT if time < n : NEW_LINE INDENT count += ( n - time + x - 1 ) / x NEW_LINE DEDENT assert count == 0 NEW_LINE DEDENT
def test_PA_tricky_sum ( ) : NEW_LINE INDENT data = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE data = data . T NEW_LINE t = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE sum , valu , result = pa . tricky_sum ( data , t ) NEW_LINE for p in range ( t ) : NEW_LINE INDENT n1 = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE sum = n1 * ( n1 + 1 ) / 2 NEW_LINE for i in range ( 1 , n1 + 1 , 2 ) : NEW_LINE INDENT valu += i NEW_LINE DEDENT result = sum - ( valu * 2 ) NEW_LINE data . T . append ( result ) NEW_LINE data . T . append ( valu ) NEW_LINE valu = 0 NEW_LINE DEDENT data . T . append ( sum ) NEW_LINE data . T . append ( valu ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s = sys . stdin . read ( ) NEW_LINE ar = [ ] NEW_LINE for ch in s : NEW_LINE INDENT ar . append ( ch - 97 ) NEW_LINE DEDENT cntod = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( ar [ i ] % 2 ) != 0 : NEW_LINE INDENT cntod += 1 NEW_LINE DEDENT DEDENT if cntod == 0 : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT else : NEW_LINE INDENT if cntod % 2 == 0 : NEW_LINE INDENT print ( " Second " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT DEDENT DEDENT
def pythontag_reverse ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while n != 0 : NEW_LINE INDENT rev = ( rev * 10 ) + ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT disp ( row_no = 0 , block = 1 ) NEW_LINE row = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 81 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 99 , 100 , 101 , 102 , 103 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 115 , 116 , 117 , 118 , 119 , 120 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 , 115 , 101 , 110 , 112 ,
def GFG ( s ) : NEW_LINE INDENT bin = [ '000' , '001' , '010' , '011' , '100' , '101' , "110' , "111' ] NEW_LINE binary = ' ' NEW_LINE for c in s : NEW_LINE INDENT binary += bin [ c - '0' ] NEW_LINE DEDENT binary = binary [ : : - 1 ] NEW_LINE count , prev = 1 , - 1 , i , 0 NEW_LINE for i in range ( len ( binary ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if binary [ i ] == '1' : NEW_LINE INDENT count = max ( count , j - prev ) NEW_LINE prev = j NEW_LINE DEDENT DEDENT return count , prev NEW_LINE DEDENT
def GFG ( s , n , k ) : NEW_LINE INDENT return ( s [ 0 ] , s [ 1 ] , s [ 2 ] ) NEW_LINE DEDENT
def GFG ( arr , freq , n ) : NEW_LINE INDENT sum , frequency_sum = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + float ( freq [ i ] ) / arr [ i ] NEW_LINE frequency_sum = frequency_sum + freq [ i ] NEW_LINE DEDENT return ( frequency_sum / sum ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if a < 0 and n < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a ** 2 * n ) / float ( 4 * tan ( ( 180 / n ) * pi / 180 ) ) NEW_LINE assert A == 1 NEW_LINE DEDENT
def class Solution ( a , b ) : NEW_LINE INDENT if a == 0 : return b NEW_LINE if b == 0 : return a NEW_LINE if a == b : return a NEW_LINE if a > b : return __gcd ( a - b , b ) NEW_LINE return __gcd ( a , b - a ) NEW_LINE DEDENT def lcm ( a , b ) : return ( a / __gcd ( a , b ) ** 2 ) NEW_LINE def getMinValue ( c ) : NEW_LINE INDENT ans = sys . maxint NEW_LINE for i in range ( 1 , math . sqrt ( c ) ) : NEW_LINE INDENT if c % i == 0 and lcm ( i , c / i ) == c : ans = min ( ans , max ( i , c / i ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT with open ( ' . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . / . /
def main ( ) : NEW_LINE INDENT import sys NEW_LINE start = long ( sys . argv [ 1 ] ) NEW_LINE ratio = long ( sys . argv [ 2 ] ) NEW_LINE max = long ( sys . argv [ 3 ] ) NEW_LINE m = len ( sys . argv ) NEW_LINE bad = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT bad . append ( long ( sys . argv [ i ] ) ) NEW_LINE DEDENT if abs ( start ) > max : NEW_LINE INDENT print ( '0' ) NEW_LINE return NEW_LINE DEDENT if start == 0 : NEW_LINE INDENT if bad : NEW_LINE INDENT print ( '0' ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' inf ' ) NEW_LINE return NEW_LINE DEDENT DEDENT if ratio == 1 : NEW_LINE INDENT if bad : NEW_LINE INDENT print ( '0' ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' inf ' ) NEW_LINE return NEW_LINE DEDENT DEDENT if ratio == - 1 : NEW_LINE INDENT if bad and bad [ start ] * ( - 1 ) : NEW_LINE INDENT print ( '0' ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' inf ' ) NEW_LINE return NEW_LINE DEDENT DEDENT if ratio == 0 : NEW_LINE INDENT if bad : NEW_LINE INDENT print ( ' inf ' ) NEW_LINE return NEW_LINE DEDENT elif bad : NEW_LINE INDENT print ( '0' ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( '1' ) NEW_LINE return NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE while abs ( start ) <= max : NEW_LINE INDENT if bad : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT start *= ratio NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import re NEW_LINE import os NEW_LINE import tempfile NEW_LINE import atexit NEW_LINE import subprocess NEW_LINE import re NEW_LINE import tempfile NEW_LINE import atexit NEW_LINE import os NEW_LINE import tempfile NEW_LINE import atexit NEW_LINE import re NEW_LINE import tempfile NEW_LINE import atexit NEW_LINE import re NEW_LINE import tempfile NEW_LINE import atexit NEW_LINE import re NEW_LINE import tempfile NEW_LINE import atexit NEW_LINE import re NEW_LINE import atexit NEW_LINE import tempfile NEW_LINE import atexit NEW_LINE import re NEW_LINE import atexit NEW_LINE import re NEW_LINE import tempfile NEW_LINE import atexit NEW_LINE import re NEW_LINE import atexit NEW_LINE import re NEW_LINE import tempfile NEW_LINE import atexit NEW_LINE import re NEW_LINE import atexit NEW_LINE import re NEW_LINE import tempfile NEW_LINE import atexit NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import atexit NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re
def test_fibonacci ( ) : NEW_LINE INDENT fibo = 2.078087F * float ( log ( n ) ) + 1.672276F NEW_LINE assert round ( fibo , 5 ) == fibo NEW_LINE DEDENT
def pyGFG ( str1 , str2 ) : NEW_LINE INDENT n1 , n2 = len ( str1 ) , len ( str2 ) NEW_LINE if n1 < n2 : NEW_LINE INDENT return True NEW_LINE DEDENT if n2 < n1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if str1 [ i ] < str2 [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT elif str1 [ i ] > str2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def find_diff ( str1 , str2 ) : NEW_LINE INDENT if is_smaller ( str1 , str2 ) : NEW_LINE INDENT t = str1 NEW_LINE str1 , str2 = str2 , t NEW_LINE DEDENT str = " " NEW_LINE n1 , n2 = len ( str1 ) , len ( str2 ) NEW_LINE str1 = [ str [ i ] for i in range ( n1 ) ] NEW_LINE str2 = [ str [ i ] for i in range ( n2 ) ] NEW_LINE carry = 0 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT sub = ( int ( str1 [ i ] - '0' ) - int ( str2 [ i ] - '0' ) - carry ) NEW_LINE if sub < 0 : NEW_LINE INDENT sub = sub + 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT str += chr ( sub + '0' ) NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT sub = ( int ( str1 [ i ] - '0' ) - carry ) NEW_LINE if sub < 0 : NEW_LINE INDENT sub = sub + 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT str += chr ( sub + '0' ) NEW_LINE DEDENT return [ str [ i ] for i in range ( n1 ) ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT str1 = "978" NEW_LINE str2 = "12977" NEW_LINE print ( find_diff ( str1 , str2 ) ) NEW_LINE s1 = "100" NEW_LINE s2 = "1000000" NEW_LINE print ( find_diff ( s1 , s2 ) ) NEW_LINE DEDENT
def GFG ( s1 , s2 ) : NEW_LINE INDENT c0 , c1 = 0 , 0 NEW_LINE for c in s1 : NEW_LINE INDENT if c == '0' and s2 [ c ] == '1' : c0 += 1 NEW_LINE elif c == '1' and s2 [ c ] == '0' : c1 += 1 NEW_LINE DEDENT ans = c0 / 2 + c1 / 2 NEW_LINE if c0 % 2 == 0 and c1 % 2 == 0 : NEW_LINE INDENT return ans NEW_LINE DEDENT elif ( c0 + c1 ) % 2 == 0 : NEW_LINE INDENT return ans + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n NEW_LINE x = [ ] NEW_LINE for o , a in getopt . getopt ( sys . argv [ 1 : ] , " n : " ) : NEW_LINE INDENT if o == ' - n ' : NEW_LINE INDENT n = int ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT x . append ( a ) NEW_LINE DEDENT DEDENT all = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT all += x [ i ] NEW_LINE DEDENT seg = SegmentTree ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre = seg . query ( 0 , x [ i ] ) NEW_LINE seg . set ( x [ i ] , pre + x [ i ] ) NEW_LINE DEDENT fix = seg . query ( 0 , n + 1 ) NEW_LINE print ( all - fix ) NEW_LINE class SegmentTree : NEW_LINE INDENT n = 1 NEW_LINE val = [ ] NEW_LINE def set ( self , n ) : NEW_LINE INDENT while self . n < n : NEW_LINE INDENT self . n *= 2 NEW_LINE DEDENT self . val = [ ] NEW_LINE DEDENT def query ( self , k , l ) : NEW_LINE INDENT k += n - 1 NEW_LINE self . val . append ( l ) NEW_LINE while k > 0 : NEW_LINE INDENT k = ( k - 1 ) // 2 NEW_LINE self . val . append ( max ( self . val [ 2 * k + 1 ] , self . val [ 2 * k + 2 ] ) ) NEW_LINE DEDENT DEDENT def query ( self , a , b ) : NEW_LINE INDENT return self . val [ 0 ] NEW_LINE DEDENT def query ( self , a , b , l , r , k ) : NEW_LINE INDENT if r <= a or b <= l : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif a <= l <= b : NEW_LINE INDENT return self . val [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT vl = self . query ( a , b , l , ( l + r ) // 2 , 2 * k + 1 ) NEW_LINE vr = self . query ( a , b , ( l + r ) // 2 , r , 2 * k + 2 ) NEW_LINE return max ( vl , vr ) NEW_LINE DEDENT DEDENT DEDENT
def test_a376_Lever_Round221 ( ) : NEW_LINE INDENT s = input ( " Enter ▁ a ▁ string ▁ to ▁ test : ▁ " ) NEW_LINE s = s . strip ( ) NEW_LINE s = s . split ( " ^ " ) NEW_LINE part = s . count ( " ^ " ) NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE for i in range ( part ) : NEW_LINE INDENT if s [ i ] <= '9' and s [ i ] >= '1' : NEW_LINE INDENT left += ( part - i ) * ( s [ i ] - '0' ) NEW_LINE DEDENT DEDENT for j in range ( part + 1 , len ( s ) ) : NEW_LINE INDENT if s [ j ] <= '9' and s [ j ] >= '1' : NEW_LINE INDENT right += ( j - part ) * ( s [ j ] - '0' ) NEW_LINE DEDENT DEDENT if left == right : NEW_LINE INDENT assert " balance " in s NEW_LINE DEDENT elif left < right : NEW_LINE INDENT assert " right " in s NEW_LINE DEDENT elif right < left : NEW_LINE INDENT assert " left " in s NEW_LINE DEDENT DEDENT
def test_gf_gf_normal ( ) : NEW_LINE INDENT """ Test ▁ normal ▁ primes . """ NEW_LINE prime = [ False ] * n NEW_LINE for i in range ( 3 , n // 2 , 2 ) : NEW_LINE INDENT if prime [ i // 2 ] == False : NEW_LINE INDENT for j in range ( i * i , n , i * 2 ) : NEW_LINE INDENT prime [ j // 2 ] = True NEW_LINE DEDENT DEDENT DEDENT assert '2 ▁ ' in prime NEW_LINE for i in range ( 3 , n // 2 , 2 ) : NEW_LINE INDENT if prime [ i // 2 ] == False : NEW_LINE INDENT assert i == n // 2 NEW_LINE DEDENT DEDENT DEDENT
def test_word ( ) : NEW_LINE INDENT f = py . io . TextIO ( encoding = ' utf - 8' ) NEW_LINE word = f . readline ( ) NEW_LINE uppercase = 0 NEW_LINE lowercase = 0 NEW_LINE for ch in word : NEW_LINE INDENT if ord ( ch ) < 128 : NEW_LINE INDENT uppercase += 1 NEW_LINE DEDENT else : NEW_LINE INDENT lowercase += 1 NEW_LINE DEDENT DEDENT if uppercase > lowercase : NEW_LINE INDENT assert word . upper ( ) == lowercase NEW_LINE DEDENT elif lowercase > uppercase : NEW_LINE INDENT assert word . lower ( ) == lowercase NEW_LINE DEDENT else : NEW_LINE INDENT assert word . lower ( ) == lowercase NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 3 , 2 , 3 , 4 , 4 ] NEW_LINE assert frequencyOfSmallest ( N , arr ) == 0 NEW_LINE DEDENT
def GFG ( A , B , n , m ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if A [ i ] == B [ j ] : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE if j == m : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i = i - j + 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def problem_b ( ) : NEW_LINE INDENT scn = nx . club_shortest_path ( nx . DiGraph ( ) , 1 ) NEW_LINE n = scn . size NEW_LINE arr = [ scn [ i ] for i in range ( n ) ] NEW_LINE ans = arr [ 0 ] + 1 NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT ans += abs ( arr [ i ] - arr [ i - 1 ] ) + 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def GFG ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE MOD = 1000000007 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = ( res * n ) % MOD NEW_LINE DEDENT return res NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT N = 0 NEW_LINE MOD = 1000000007L NEW_LINE TOKENS = [ ' A ' , ' C ' , ' G ' , ' T ' ] NEW_LINE memo = { } NEW_LINE for i in range ( len ( sys . argv ) ) : NEW_LINE INDENT sys . argv [ i ] = ' ' NEW_LINE N = sys . argv [ i ] NEW_LINE sys . argv [ i ] = ' ' NEW_LINE memo [ i ] = { } NEW_LINE DEDENT def calc ( ) : NEW_LINE INDENT return dfs ( 0 , ' TTT ' ) NEW_LINE DEDENT def is_ok ( last4 ) : NEW_LINE INDENT if last4 in memo : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT vals = last4 [ i + 1 : i + 2 ] NEW_LINE vals = vals [ i + 1 : i + 2 ] NEW_LINE s = ' ' . join ( vals ) NEW_LINE if s in memo : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( current , last3 ) : NEW_LINE INDENT if this . memo [ current ] . has_key ( last3 ) : NEW_LINE INDENT return ( this . memo [ current ] [ last3 ] ) NEW_LINE DEDENT if current == N : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for c in TOKENS : NEW_LINE INDENT if is_ok ( last3 + c ) : NEW_LINE INDENT result = ( result + dfs ( current + 1 , last3 [ 1 : last3 [ 0 ] ] ) ) % MOD NEW_LINE DEDENT DEDENT memo [ current ] [ last3 ] = result NEW_LINE return result NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT ins = Main ( ) NEW_LINE print ( ins . calc ( ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def pytest_unconfigure ( config ) : NEW_LINE INDENT config . pluginmanager . register ( TestUndo , " undo " ) NEW_LINE config . pluginmanager . register ( TestRedo , " redo " ) NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , pluginmanager ) : NEW_LINE INDENT self . _plugin = pluginmanager NEW_LINE DEDENT def pytest_sessionstart ( session ) : NEW_LINE INDENT try : NEW_LINE INDENT value = int ( session . config . option . undo . value ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT if value == 1 : NEW_LINE INDENT self . _plugin . undo . value = 0 NEW_LINE DEDENT else : NEW_LINE INDENT self . _plugin . undo . value = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT config . addinivalue_line ( " markers " , " undo ▁ finished " ) NEW_LINE config . addinivalue_line ( " markers " , " redo ▁ finished " ) NEW_LINE config . addinivalue_line ( " markers " , " undo ▁ finished " ) NEW_LINE config . addinivalue_line ( " markers " , " redo ▁ finished " ) NEW_LINE config . addinivalue_line ( " markers " , " undo ▁ finished " ) NEW_LINE config . addinivalue_line ( " markers " , " redo ▁ finished " ) NEW_LINE config . addinivalue_line ( " markers " , " undo ▁ finished " ) NEW_LINE config . addinivalue_line ( " markers " , " redo ▁ finished " ) NEW_LINE config . addinivalue_line ( " markers " , " redo ▁ finished " ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX = 100 NEW_LINE binomial_coeff = [ 1 ] * MAX NEW_LINE C = [ 1 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , max ( i , k ) ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT assert C [ k ] == 1 NEW_LINE sum_ofproduct = binomial_coeff ( 2 * n , n - 1 ) NEW_LINE assert sum_ofproduct == MAX NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT f = QQ . old_poly_ring ( x , y ) NEW_LINE string1 = f . ideal ( x , y ) NEW_LINE assert f . ideal ( x , y ) . is_univariate is True NEW_LINE string2 = f . ideal ( x , y ) NEW_LINE assert f . ideal ( x , y ) . is_univariate is True NEW_LINE print ( " Are ▁ both ▁ strings ▁ same : ▁ " ) NEW_LINE if string1 == string2 == True : NEW_LINE INDENT assert " Yes " in f . ideal ( x , y ) . is_univariate is True NEW_LINE DEDENT else : NEW_LINE INDENT assert " No " in f . ideal ( x , y ) . is_univariate is False NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT max_val = sum ( [ i for i in range ( 0 , max_val + 1 ) if i < max_val ] ) NEW_LINE prime = Vector ( max_val + 1 ) NEW_LINE for i in range ( max_val + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , max_val * p <= max_val + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val , p + 1 ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count * ( count - 1 ) ) / 2 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT max_val = sum ( [ i for i in range ( 0 , max_val + 1 ) if i < max_val ] ) NEW_LINE prime = Vector ( max_val + 1 ) NEW_LINE for i in range ( max_val + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE prime [ 2 ] = False NEW_LINE for p in range ( 2 , max_val * p <= max_val + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT maximum = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT maximum = max ( maximum , i ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT
def pypyx053 ( ) : NEW_LINE INDENT return p013 ( ) . run ( ) NEW_LINE DEDENT def test_p013 ( ) : NEW_LINE INDENT assert p013 ( ) . run ( ) == '484819191955444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444
def test_GFG ( ) : NEW_LINE INDENT arr = np . array ( [ 2 , - 6 , 3 , 5 , 1 ] ) NEW_LINE n = len ( arr ) NEW_LINE assert np . all ( arr == n ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while i < n - 1 and arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' s + ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ Usage : ▁ % s ▁ < file > ▁ < file > """ % sys . argv [ 0 ] ) NEW_LINE return NEW_LINE DEDENT A = [ ] NEW_LINE B = [ ] NEW_LINE for o , a in opts : NEW_LINE INDENT if o == ' - s ' : NEW_LINE INDENT A . append ( a ) NEW_LINE DEDENT elif o == ' - e ' : NEW_LINE INDENT B . append ( a ) NEW_LINE DEDENT elif o == ' - d ' : NEW_LINE INDENT D . append ( a ) NEW_LINE DEDENT elif o == ' - l ' : NEW_LINE INDENT L . append ( a ) NEW_LINE DEDENT elif o == ' - - help ' : NEW_LINE INDENT print ( __doc__ ) NEW_LINE print ( """ ▁ ▁ - h , ▁ - - help """ ) NEW_LINE print ( """ ▁ ▁ - s ▁ < file > ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁
def GFG ( a , b , n ) : NEW_LINE INDENT z = 0 NEW_LINE if n % 6 == 1 : NEW_LINE INDENT z = a NEW_LINE DEDENT elif n % 6 == 2 : NEW_LINE INDENT z = b NEW_LINE DEDENT elif n % 6 == 3 : NEW_LINE INDENT z = b - a NEW_LINE DEDENT elif n % 6 == 4 : NEW_LINE INDENT z = - a NEW_LINE DEDENT elif n % 6 == 5 : NEW_LINE INDENT z = - b NEW_LINE DEDENT if n % 6 == 0 : NEW_LINE INDENT z = - ( b - a ) NEW_LINE DEDENT return z NEW_LINE DEDENT
def get_group_lengths ( s , num ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while num : NEW_LINE INDENT if ( num & 1 ) == 1 : NEW_LINE INDENT res += s [ i ] - '0' NEW_LINE DEDENT i += 1 NEW_LINE num = num >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def get_gfg ( cost , n ) : NEW_LINE INDENT dp1 , dp2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT assert count_multiples ( 25 ) == 0 NEW_LINE DEDENT
def pygfG ( str1 , k ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE str = str1 . split ( ' ▁ ' ) NEW_LINE start = 0 NEW_LINE max_len = 0 NEW_LINE ch = None NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE freq [ ch - ' a ' ] += 1 NEW_LINE if freq [ ch - ' a ' ] > k : NEW_LINE INDENT if max_len < ( i - start ) : NEW_LINE INDENT max_len = i - start NEW_LINE DEDENT while freq [ ch - ' a ' ] > k : NEW_LINE INDENT freq [ str [ start ] - ' a ' ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT if max_len < ( n - start ) : NEW_LINE INDENT max_len = n - start NEW_LINE DEDENT return max_len NEW_LINE DEDENT
def class6 ( arg ) : NEW_LINE INDENT n = arg . count ( ' A ' ) NEW_LINE ch = [ ] NEW_LINE s1 , s2 = 0 , 0 NEW_LINE i , j , flag , dif = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = arg [ i ] NEW_LINE temp1 = s1 + x NEW_LINE temp2 = s2 + y NEW_LINE if abs ( temp1 - s2 ) <= 500 : NEW_LINE INDENT s1 += x NEW_LINE ch . append ( ' A ' ) NEW_LINE continue NEW_LINE DEDENT if abs ( temp2 - s1 ) <= 500 : NEW_LINE INDENT s2 += y NEW_LINE ch . append ( ' G ' ) NEW_LINE continue NEW_LINE DEDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' ' . join ( ch ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
def to_hex ( num ) : NEW_LINE INDENT hex_map = "0123456789abcdef " NEW_LINE if num == 0 : NEW_LINE INDENT return "0" NEW_LINE DEDENT res = " " NEW_LINE while num != 0 and len ( res ) < 8 : NEW_LINE INDENT res = hex_map [ num & 15 ] + res NEW_LINE num = num >> 4 NEW_LINE DEDENT return res NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n , count NEW_LINE n = int ( sys . argv [ 1 ] ) NEW_LINE count = int ( sys . argv [ 2 ] ) NEW_LINE print ( ' Island ▁ is ▁ % d ' % n ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Island ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE print ( ' Count ▁ is ▁ % d ' % count ) NEW_LINE DEDENT
def GFG ( str1 , str2 ) : NEW_LINE INDENT count1 , count2 = [ 0 ] * 26 , [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ str1 [ i ] - ' a ' ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ str2 [ i ] - ' a ' ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result += chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def GFG ( x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( x >> ( ret + 1 ) ) : NEW_LINE INDENT ret += 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def xorRange ( l , r ) : NEW_LINE INDENT max_bit = msb ( r ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , max_bit + 1 ) : NEW_LINE INDENT if ( l / mul ) * mul == ( r / mul ) * mul : NEW_LINE INDENT if ( ( l & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE continue NEW_LINE DEDENT odd_c = 0 NEW_LINE if ( ( l & ( 1 << i ) ) != 0 ) and l % 2 == 1 : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( ( r & ( 1 << i ) ) != 0 ) and r % 2 == 0 : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if odd_c != 0 : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) / 2 NEW_LINE if l % 2 == 1 and r % 2 == 1 : NEW_LINE INDENT zero_bit_cnt += 1 NEW_LINE DEDENT if zero_bit_cnt % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT l , r = 1 , 4 NEW_LINE print ( xorRange ( l , r ) ) NEW_LINE DEDENT DEDENT
def GFG ( s , i ) : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT if s [ i ] == ' a ' : NEW_LINE INDENT q1 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while 1 : NEW_LINE INDENT n = input ( ) . count ( " Enter ▁ n " ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT m = [ 0 ] * 10000 NEW_LINE t = [ 1 ] * 10000 NEW_LINE a , b = divmod ( n , 10000 ) NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ 0 ] = t [ 0 ] NEW_LINE t [ 0 ] = 1 NEW_LINE a , b = divmod ( a , 10000 ) NEW_LINE for j in range ( 0 , a * b , a ) : NEW_LINE INDENT for k in range ( 0 , max ) : NEW_LINE INDENT if t [ k ] : NEW_LINE INDENT m [ j + k ] += t [ k ] NEW_LINE DEDENT DEDENT DEDENT max += a * b NEW_LINE t = m [ 0 ] NEW_LINE DEDENT s = sys . stdout . getvalue ( ) . count ( " \n " ) NEW_LINE for i in range ( s ) : NEW_LINE INDENT print ( m [ sys . stdout . getvalue ( ) . find ( " \n " ) + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( T , K ) : NEW_LINE INDENT minutes = ( ( T [ 0 ] - '0' ) * 10 + T [ 1 ] - '0' ) * 60 + ( ( T [ 3 ] - '0' ) * 10 + T [ 4 ] - '0' ) NEW_LINE minutes += K NEW_LINE hour = ( minutes / 60 ) % 24 NEW_LINE min = minutes % 60 NEW_LINE if hour < 10 : NEW_LINE INDENT print ( '0' + hour + ' : ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( hour + ' : ' ) NEW_LINE DEDENT if min < 10 : NEW_LINE INDENT print ( '0' + min ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = len ( str ( x ) ) NEW_LINE max_prod , max_sum = [ int ( i ) for i in range ( n - m ) ] NEW_LINE for i in range ( n + m ) : NEW_LINE INDENT product , sum = 1 , 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( str ( j ) - '0' ) NEW_LINE sum = sum + ( str ( j ) - '0' ) NEW_LINE DEDENT max_prod = max ( max_prod , product ) NEW_LINE max_sum = max ( max_sum , sum ) NEW_LINE DEDENT assert max ( max_prod ) == max_prod NEW_LINE assert max ( max_sum ) == max_sum NEW_LINE DEDENT
def GFG ( x , y , z ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return ( x , z ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( y , z ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE x = sys . argv [ 1 : ] NEW_LINE ji = sys . argv [ 2 : ] NEW_LINE shu = [ ] NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT shu . append ( i ) NEW_LINE DEDENT shu . sort ( ) NEW_LINE l1 = 0 NEW_LINE l2 = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT s1 = i * 2 + 1 NEW_LINE s2 = i * 2 + 2 NEW_LINE id = shu [ i ] NEW_LINE if id != s1 : NEW_LINE INDENT l1 = l1 + abs ( s1 - id ) NEW_LINE DEDENT if id != s2 : NEW_LINE INDENT l2 = l2 + abs ( s2 - id ) NEW_LINE DEDENT DEDENT min = min ( l1 , l2 ) NEW_LINE print ( min ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global parents , weight , rank NEW_LINE n = len ( sys . argv ) NEW_LINE q = len ( sys . argv ) NEW_LINE parents = [ ] NEW_LINE weight = [ ] NEW_LINE rank = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT parents . append ( i ) NEW_LINE DEDENT type , x , y , z = getopt . getopt ( sys . argv [ 1 : ] , " q : " ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT type , x , y , z = getopt . getopt ( sys . argv [ 2 : ] , " q : " ) NEW_LINE if type == 0 : NEW_LINE INDENT z = sys . stdin . read ( ) NEW_LINE relate ( x , y , z ) NEW_LINE DEDENT else : NEW_LINE INDENT diff ( x , y ) NEW_LINE DEDENT DEDENT def find ( x ) : NEW_LINE INDENT if x == parents [ x ] : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT r = find ( parents [ x ] ) NEW_LINE weight [ x ] += weight [ parents [ x ] ] NEW_LINE return parents [ x ] = r NEW_LINE DEDENT DEDENT def weight ( x ) : NEW_LINE INDENT find ( x ) NEW_LINE return weight [ x ] NEW_LINE DEDENT def relate ( x , y , z ) : NEW_LINE INDENT z += weight ( x ) NEW_LINE z -= weight ( y ) NEW_LINE x = find ( x ) NEW_LINE y = find ( y ) NEW_LINE if x == y : NEW_LINE INDENT return NEW_LINE DEDENT if rank [ x ] < rank [ y ] : NEW_LINE INDENT tmp = x NEW_LINE x , y = y , tmp NEW_LINE z = - z NEW_LINE DEDENT if rank [ x ] == rank [ y ] : NEW_LINE INDENT rank [ x ] += 1 NEW_LINE DEDENT parents [ y ] = x NEW_LINE weight [ y ] = z NEW_LINE DEDENT def diff ( x , y ) : NEW_LINE INDENT if find ( x ) == find ( y ) : NEW_LINE INDENT print ( weight ( y ) - weight ( x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ? " ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT A , B , M = symbols ( ' A , B , M ' ) NEW_LINE assert gf_degree ( A ) == 6 NEW_LINE assert gf_degree ( B ) == 15 NEW_LINE assert gf_degree ( M ) == 3 NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( math . log10 ( n ) ) NEW_LINE a = [ 0 ] * ( d + 2 ) NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + int ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT p = int ( math . ceil ( math . pow ( 10 , d ) ) ) NEW_LINE msd = n // p NEW_LINE if msd == 4 : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if msd > 4 : NEW_LINE INDENT return ( msd - 1 ) * a [ d ] + p + count_numbers_with_4 ( n % p ) NEW_LINE DEDENT return ( msd ) * a [ d ] + count_numbers_with_4 ( n % p ) NEW_LINE DEDENT
def test_vfe ( ) : NEW_LINE INDENT x = Symbol ( ' x ' ) NEW_LINE y = Symbol ( ' y ' ) NEW_LINE seq = [ x , y , y - x ] NEW_LINE i = 2 NEW_LINE while not ( seq [ i ] == y and seq [ i - 1 ] == x or seq [ i ] == 0 and seq [ i - 1 ] == 0 ) : NEW_LINE INDENT seq . append ( seq [ i ] - seq [ i - 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT k = Symbol ( ' k ' , integer = True ) NEW_LINE i -= 1 NEW_LINE k = k % i NEW_LINE if k == 0 : NEW_LINE INDENT k = i NEW_LINE DEDENT assert ( ( seq [ k - 1 ] % 1000000007 ) + 1000000007 ) % 1000000007 == seq [ k ] NEW_LINE DEDENT
def test_solution ( ) : NEW_LINE INDENT class INT : NEW_LINE INDENT data = 0 NEW_LINE DEDENT def find_post_order_util ( pre , n , minval , maxval , pre_index ) : NEW_LINE INDENT if pre_index . data == n : NEW_LINE INDENT return NEW_LINE DEDENT if pre [ pre_index . data ] < minval or pre [ pre_index . data ] > maxval : NEW_LINE INDENT return NEW_LINE DEDENT val = pre [ pre_index . data ] NEW_LINE pre_index . data += 1 NEW_LINE find_post_order_util ( pre , n , minval , val , pre_index ) NEW_LINE find_post_order_util ( pre , n , val , maxval , pre_index ) NEW_LINE print ( val , end = ' ' ) NEW_LINE DEDENT def find_post_order ( pre , n ) : NEW_LINE INDENT pre_index = INT ( 0 ) NEW_LINE find_post_order_util ( pre , n , int ( minval ) , int ( maxval ) , pre_index ) NEW_LINE DEDENT def find_post_order ( pre , n ) : NEW_LINE INDENT pre_index = INT ( 0 ) NEW_LINE find_post_order_util ( pre , n , int ( minval ) , int ( maxval ) , pre_index ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT if k <= 0 or k >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = set ( [ arr [ i ] for i in range ( n ) ] ) NEW_LINE if len ( s ) <= k : NEW_LINE INDENT return 0 NEW_LINE DEDENT return len ( s ) - k NEW_LINE DEDENT
def _250B ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import string NEW_LINE import pickle NEW_LINE import struct NEW_LINE import time NEW_LINE import random NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , n * i <= n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT return ( flag == 1 and True or False ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = ' Generate ▁ a ▁ sentence ▁ of ▁ words ▁ from ▁ a ▁ sentence ▁ of ▁ words ' ) NEW_LINE parser . add_argument ( ' - N ' , ' - - N ' , type = int , help = ' Number ▁ of ▁ words ▁ to ▁ generate ' ) NEW_LINE parser . add_argument ( ' previous ' , type = str , help = ' The ▁ previous ▁ word ' ) NEW_LINE parser . add_argument ( ' next ' , type = str , help = ' The ▁ next ▁ word ' ) NEW_LINE used_words = set ( ) NEW_LINE used_words . add ( previous ) NEW_LINE while N > 1 : NEW_LINE INDENT next = parser . parse_args ( ) [ - 1 ] NEW_LINE if not ( ( previous [ - 1 ] == next [ 0 ] ) and used_words . add ( next ) ) : NEW_LINE INDENT print ( ' No ' ) NEW_LINE parser . print_help ( ) NEW_LINE return NEW_LINE DEDENT previous = next NEW_LINE N -= 1 NEW_LINE DEDENT parser . print_help ( ) NEW_LINE print ( ' Yes ' ) NEW_LINE DEDENT
def GFG ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT
def test_GFG ( arr ) : NEW_LINE INDENT """ Test ▁ the ▁ segregation ▁ of ▁ the ▁ generators ▁ of ▁ a ▁ function . """ NEW_LINE type0 = 0 NEW_LINE type1 = len ( arr ) - 1 NEW_LINE while type0 < type1 : NEW_LINE INDENT if arr [ type0 ] == 1 : NEW_LINE INDENT arr [ type1 ] = arr [ type1 ] + arr [ type0 ] NEW_LINE arr [ type0 ] = arr [ type1 ] - arr [ type0 ] NEW_LINE arr [ type1 ] = arr [ type1 ] - arr [ type0 ] NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE d = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d . append ( sys . argv [ i ] ) NEW_LINE DEDENT d . sort ( ) NEW_LINE ans = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if d [ i ] != d [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT
def pyShortestKingPath ( ) : NEW_LINE INDENT s = input ( " Enter ▁ a ▁ string : ▁ " ) NEW_LINE s1 = input ( " Enter ▁ a ▁ string : ▁ " ) NEW_LINE c = s . split ( ) NEW_LINE c1 = s1 . split ( ) NEW_LINE diff = c1 [ 0 ] - c [ 0 ] NEW_LINE dif = c1 [ 1 ] - c [ 1 ] NEW_LINE n = abs ( diff ) NEW_LINE m = abs ( dif ) NEW_LINE ans = " " NEW_LINE while diff != 0 or dif != 0 : NEW_LINE INDENT if diff > 0 : NEW_LINE INDENT ans += " R " NEW_LINE diff -= 1 NEW_LINE DEDENT if diff < 0 : NEW_LINE INDENT ans += " L " NEW_LINE diff += 1 NEW_LINE DEDENT if dif > 0 : NEW_LINE INDENT ans += " U " NEW_LINE dif -= 1 NEW_LINE DEDENT if dif < 0 : NEW_LINE INDENT ans += " D " NEW_LINE dif += 1 NEW_LINE DEDENT ans += " \n " NEW_LINE DEDENT print ( max ( n , m ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE h , w = sys . argv [ 1 : ] NEW_LINE total = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT x = sys . stdin . readline ( ) NEW_LINE total += x * ( i + 1 ) * ( h - i ) * ( j + 1 ) * ( w - j ) NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE DEDENT
def okabeandfuturegadgetlaboratory ( ) : NEW_LINE INDENT fin = open ( ' okabeandfuturegadgetlaboratory . txt ' , ' r ' ) NEW_LINE n = int ( fin . readline ( ) ) NEW_LINE lab = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT st = fin . readline ( ) . split ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT lab . append ( int ( st [ 0 ] ) ) NEW_LINE DEDENT DEDENT ans = True NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( n ) : NEW_LINE INDENT if lab [ x ] [ y ] != 1 : NEW_LINE INDENT cur = lab [ x ] [ y ] NEW_LINE is_valid = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if lab [ x ] [ i ] + lab [ j ] [ y ] == cur : NEW_LINE INDENT is_valid = True NEW_LINE break NEW_LINE DEDENT DEDENT if is_valid : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not is_valid : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if not ans : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans and " Yes " or " No " ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE x , y = sys . argv [ 1 : ] NEW_LINE print_bin ( fill_zero ( long ( x & y ) ) ) NEW_LINE print_bin ( fill_zero ( long ( x | y ) ) ) NEW_LINE print_bin ( fill_zero ( long ( x ^ y ) ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE x = sys . stdin . read ( 32 ) NEW_LINE print_bin ( fill_zero ( long ( x ) ) ) NEW_LINE print_bin ( fill_zero ( long ( ~ x ) ) ) NEW_LINE print_bin ( fill_zero ( long ( x << 1 ) ) ) NEW_LINE print_bin ( fill_zero ( long ( x >> 1 ) ) ) NEW_LINE DEDENT
def py ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE M = 5 NEW_LINE def main ( ) : NEW_LINE INDENT s = getopt . getopt ( sys . argv [ 1 : ] , ' m ' ) NEW_LINE ma = [ ] NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT s = s [ i : i + M ] NEW_LINE try : ma . append ( int ( s [ : i ] ) ) NEW_LINE except : pass NEW_LINE DEDENT sys . argv = [ ' - m ' , ' - - ' ] NEW_LINE ans = 0.0 NEW_LINE for i in range ( 0 , M - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , M - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , M ) : NEW_LINE INDENT ans += ma [ i ] * ma [ j ] * ma [ k ] NEW_LINE DEDENT DEDENT DEDENT sys . argv = [ ' - m ' , ' - - ' ] NEW_LINE DEDENT
def test_intercepted_message ( ) : NEW_LINE INDENT """ Test ▁ that ▁ the ▁ message ▁ is ▁ intercepted . """ NEW_LINE app = flask . Flask ( __name__ ) NEW_LINE total_first_files = app . config . get ( ' TRAILBACK _ FIRST _ FILES ' , 10 ) NEW_LINE total_second_files = app . config . get ( ' TRAILBACK _ SECOND _ FILES ' , 10 ) NEW_LINE first_files = [ ] NEW_LINE second_files = [ ] NEW_LINE for i in range ( total_first_files ) : NEW_LINE INDENT first_files . append ( i ) NEW_LINE DEDENT for i in range ( total_second_files ) : NEW_LINE INDENT second_files . append ( i ) NEW_LINE DEDENT assert len ( _intercepted_message ( first_files , second_files ) ) == total_first_files + total_second_files NEW_LINE DEDENT
def pythontag_in_dir ( path ) : NEW_LINE INDENT """ STRNEWLINE ▁ Given ▁ a ▁ path ▁ to ▁ a ▁ Python ▁ module , ▁ return ▁ the ▁ path ▁ to ▁ its ▁ . py ▁ file . STRNEWLINE ▁ """ NEW_LINE path = os . path . abspath ( path ) NEW_LINE for op , _ , filenames in os . walk ( path ) : NEW_LINE INDENT for filename in filenames : NEW_LINE INDENT if op == ' ? ' : NEW_LINE INDENT break NEW_LINE DEDENT if op == ' + ' : NEW_LINE INDENT yield op , os . path . join ( path , filename ) NEW_LINE DEDENT if op == ' - ' : NEW_LINE INDENT yield op , os . path . join ( path , filename ) NEW_LINE DEDENT if op == ' * ' : NEW_LINE INDENT yield op , os . path . join ( path , filename ) NEW_LINE DEDENT if op == ' / ' : NEW_LINE INDENT yield op , os . path . join ( path , filename ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT stdscr = stdscr . clear ( ) NEW_LINE N = len ( sys . argv ) NEW_LINE A = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT A . append ( sys . argv [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i == N - 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif A [ i ] == A [ i + 1 ] : NEW_LINE INDENT pass NEW_LINE DEDENT elif A [ i ] < A [ i + 1 ] : NEW_LINE INDENT while A [ i ] <= A [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE if i == N - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT while A [ i ] >= A [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE if i == N - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ pairs ▁ of ▁ symbols ▁ in ▁ the ▁ GFG . """ NEW_LINE MAX = 256 NEW_LINE count_pairs = [ 0 ] * MAX NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT count_pairs [ s [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += count_pairs [ i ] * count_pairs [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import numpy NEW_LINE class solution : NEW_LINE INDENT prime = [ False ] * 100006 NEW_LINE def SieveOfEratosthenes ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , n * p + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def sortedArray ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == False : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == True : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v [ j ] , end = ' ▁ ' ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT solution ( ) NEW_LINE DEDENT
def get_gcdfibonaccifreq ( arr , max_element ) : NEW_LINE INDENT """ STRNEWLINE ▁ Given ▁ a ▁ list ▁ of ▁ integers , ▁ create ▁ a ▁ hash ▁ of ▁ the ▁ frequency ▁ of ▁ the ▁ given STRNEWLINE ▁ element , ▁ and ▁ return ▁ the ▁ frequency ▁ of ▁ the ▁ element . STRNEWLINE ▁ """ NEW_LINE hash = set ( ) NEW_LINE create_hash ( hash , list ( arr ) . max ( ) . get ( ) ) NEW_LINE i = 0 NEW_LINE m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m . has_key ( arr [ i ] ) : NEW_LINE INDENT m [ arr [ i ] ] = m [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT gcd = 0 NEW_LINE for key , value in m . items ( ) : NEW_LINE INDENT if hash . has_key ( key ) : NEW_LINE INDENT gcd = __gcd ( gcd , value ) NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT
def GFG ( a ) : NEW_LINE INDENT R = a * float ( 2.0 - math . sqrt ( 2 ) ) NEW_LINE area = float ( ( 3.14 * R ** 2 ) / 2.0 ) NEW_LINE return area NEW_LINE DEDENT
def GFG ( a , b , c , d , x , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT for l in range ( n ) : NEW_LINE INDENT if ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT from sympy . polys . distributedmodules import gf_degree NEW_LINE from sympy . polys . domains import ZZ NEW_LINE from sympy . polys . densebasic import DMP NEW_LINE from sympy . polys . domains import QQ NEW_LINE from sympy . polys . distributedmodules import DMP NEW_LINE N = len ( ZZ . map ( [ 1 , 2 , 3 ] ) ) NEW_LINE H = [ [ QQ ( 1 , 2 ) ] , [ QQ ( 1 , 2 ) ] ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT yield ( lambda : H [ i ] [ s - 1 ] [ 0 ] for s in range ( 26 ) ] NEW_LINE DEDENT m = len ( ZZ . map ( [ 1 , 2 , 3 ] ) ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT l , r , n = ZZ . map ( [ 1 , 2 , 3 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT sum += H [ r ] [ i ] - H [ l - 1 ] [ i ] NEW_LINE if sum >= n : NEW_LINE INDENT print ( ( ' a ' , i ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE test_cases = getopt . getopt ( sys . argv [ 1 : ] , ' i : ' ) NEW_LINE for i in test_cases : NEW_LINE INDENT activating = int ( i ) NEW_LINE placing = int ( i ) NEW_LINE input = sys . stdin . readline ( ) NEW_LINE res = 0 NEW_LINE if placing >= activating : NEW_LINE INDENT for i in input : NEW_LINE INDENT if i == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT res += activating NEW_LINE while i < len ( input ) and input [ i ] == '1' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT diff = activating / placing NEW_LINE first_one = - 1 NEW_LINE for i in input : NEW_LINE INDENT if i == '1' : NEW_LINE INDENT first_one = i NEW_LINE break NEW_LINE DEDENT DEDENT if first_one == - 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT array = [ ] NEW_LINE last_one = first_one NEW_LINE for i in range ( first_one + 1 , len ( input ) ) : NEW_LINE INDENT if input [ i ] == '1' : NEW_LINE INDENT array . append ( i - last_one - 1 ) NEW_LINE last_one = i NEW_LINE DEDENT DEDENT res1 = 0 NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT first = array [ i ] NEW_LINE if first <= diff : NEW_LINE INDENT res1 += ( first ) * placing NEW_LINE DEDENT else : NEW_LINE INDENT res1 += activating NEW_LINE DEDENT DEDENT res1 += activating NEW_LINE print ( res1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_223 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE for j in range ( t . size ) : NEW_LINE INDENT x = symbols ( ' x ' , integer = True , positive = True ) NEW_LINE if x == 1 : NEW_LINE INDENT assert '2' in t NEW_LINE DEDENT elif x == 2 : NEW_LINE INDENT assert '1' in t NEW_LINE DEDENT elif x % 3 == 0 : NEW_LINE INDENT assert x / 3 == t NEW_LINE DEDENT else : NEW_LINE INDENT assert x / 3 + 1 == t NEW_LINE DEDENT DEDENT DEDENT
def test_b999 ( ) : NEW_LINE INDENT f = open ( ' b999 . txt ' , ' r ' ) NEW_LINE t = int ( f . readline ( ) ) NEW_LINE str = f . readline ( ) NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT if t % i == 0 : NEW_LINE INDENT str = reverse ( str , i - 1 ) NEW_LINE DEDENT DEDENT assert str == reverse ( str , last ) NEW_LINE arr = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT arr . append ( str [ i ] ) NEW_LINE DEDENT counter_up , counter_down = 0 , last NEW_LINE for i in range ( 0 , last // 2 ) : NEW_LINE INDENT del arr [ counter_up : counter_down ] NEW_LINE counter_up += 1 NEW_LINE counter_down -= 1 NEW_LINE DEDENT result = ' ' NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] ) == abs ( arr [ j ] ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT if len ( v ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in v : NEW_LINE INDENT print ( - v [ i ] , v [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT if not isinstance ( n , int ) or n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT assert n * n == n NEW_LINE DEDENT
def get_GFG ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while h > l : NEW_LINE INDENT if str [ l ] != str [ h -- ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = len ( str ( num ) ) NEW_LINE sumofdigit = [ num [ 0 ] - '0' for num in range ( 1 , n ) ] NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = num [ i ] - '0' NEW_LINE sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a , b , n = symbols ( ' a ▁ b ▁ n ' , integer = True , positive = True ) NEW_LINE ans = 0 NEW_LINE ans += n * ( a / n ) ** ( b / n ) NEW_LINE ans += ( a / n ) ** ( b % n ) NEW_LINE ans += ( a % n ) ** ( b / n ) NEW_LINE ans += ( ( a % n ) + ( b % n ) ) / n NEW_LINE assert find_count_of_pairs ( a , b , n ) == ans NEW_LINE DEDENT
def p071 ( ) : NEW_LINE INDENT print ( [ ' p071 . py ' , ' p071 . c ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h ' , ' p071 . h
def GFG ( n ) : NEW_LINE INDENT c = [ 1 ] * 100 NEW_LINE coef ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ 1 + i ] = 1 NEW_LINE for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT c [ j ] = c [ j - 1 ] - c [ j ] NEW_LINE DEDENT DEDENT DEDENT isPrime ( n ) NEW_LINE c [ 0 ] += 1 NEW_LINE c [ n ] -= 1 NEW_LINE i = n NEW_LINE while ( i ) : NEW_LINE INDENT c [ i ] = c [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT return i NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT min = sys . maxint NEW_LINE counter = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] > min : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT if arr [ i ] <= min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE N = len ( sys . argv ) NEW_LINE x = sys . argv [ 1 ] NEW_LINE sweet = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = sys . argv [ i ] NEW_LINE sweet . append ( a ) NEW_LINE DEDENT sweet . sort ( ) NEW_LINE num = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if x - sweet [ num ] >= 0 : NEW_LINE INDENT x = x - sweet [ num ] NEW_LINE num += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( num == N ) : NEW_LINE INDENT num -= 1 NEW_LINE DEDENT print ( num ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT leer = input ( ) NEW_LINE casos , x , y , conta , cont = leer NEW_LINE casos = len ( casos ) NEW_LINE for i in range ( casos ) : NEW_LINE INDENT x , y = leer NEW_LINE if x > 0 : conta += 1 NEW_LINE else : cont += 1 NEW_LINE DEDENT if conta > 1 and cont > 1 : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT with open ( ' . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . / . / . / . / . . / . . / . . / . / . / . /
def test_GFG ( ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 1 , 5 ] NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT if arr [ i ] != i + 1 : NEW_LINE INDENT while arr [ i ] != i + 1 : NEW_LINE INDENT temp = 0 NEW_LINE temp = arr [ arr [ i ] - 1 ] NEW_LINE arr [ arr [ i ] - 1 ] = arr [ i ] NEW_LINE arr [ i ] = temp NEW_LINE count += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def pyp500 ( ) : NEW_LINE INDENT print ( [ ' pyp500 . py ' , ' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
def GFG ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE DEDENT set_bit_no = XOR & ~ ( XOR - 1 ) NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) > 0 : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ unique ▁ pair ▁ is ▁ ( % d , ▁ % d ) " % ( x , y ) ) NEW_LINE DEDENT
def valeraX ( ) : NEW_LINE INDENT cs = CustomScanner ( ) NEW_LINE n = cs . count ( ' \n ' ) NEW_LINE xch , nxch = ' \ u0000' , ' \ u0000' NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = cs . next ( ) NEW_LINE if i == 0 : NEW_LINE INDENT xch = line [ 0 ] NEW_LINE nxch = line [ 1 ] NEW_LINE DEDENT if xch == nxch : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE return NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if j == i or j == n - i - 1 : NEW_LINE INDENT if line [ j ] != xch : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE return NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if line [ j ] != nxch : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' YES ' ) NEW_LINE DEDENT class CustomScanner : NEW_LINE INDENT f = open ( ' / proc / self / stdin ' , ' r ' ) NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE while 1 : NEW_LINE INDENT lines = sys . stdin . readline ( ) . split ( ' \n ' ) NEW_LINE lines = lines [ : - 1 ] NEW_LINE for line in lines : NEW_LINE INDENT now = line [ : - 1 ] NEW_LINE if now != ' @ ' : NEW_LINE INDENT sys . stdout . write ( now ) NEW_LINE DEDENT else : NEW_LINE INDENT i = 0 NEW_LINE num = line [ i ] - '0' NEW_LINE i += 1 NEW_LINE if 0 <= num <= 9 : NEW_LINE INDENT now = line [ i ] NEW_LINE for j in range ( num ) : NEW_LINE INDENT sys . stdout . write ( now ) NEW_LINE DEDENT DEDENT DEDENT DEDENT sys . stdout . write ( ' \n ' ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mp . has_key ( i ) : NEW_LINE INDENT mp [ i ] = mp [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] = 1 NEW_LINE DEDENT DEDENT for x , y in mp . items ( ) : NEW_LINE INDENT if x >= n / 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import pickle NEW_LINE import struct NEW_LINE import time NEW_LINE import random NEW_LINE import pickle NEW_LINE import struct NEW_LINE import struct NEW_LINE import pickle NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE import struct NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT do_it ( ) NEW_LINE n = input ( ) NEW_LINE while n != - 1 : NEW_LINE INDENT rad = 0 NEW_LINE hyp = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT rad += math . atan ( 1 / hyp ) NEW_LINE hyp = math . sqrt ( hyp * hyp + 1 ) NEW_LINE DEDENT print ( hyp * math . cos ( rad ) ) NEW_LINE print ( hyp * math . sin ( rad ) ) NEW_LINE n = input ( ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 ] NEW_LINE i = 0 NEW_LINE while i < n and arr [ i ] <= 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT count , curr = 0 , 1 NEW_LINE while count < k and i < n : NEW_LINE INDENT if arr [ i ] != curr : NEW_LINE INDENT print ( curr , end = ' ▁ ' ) NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT curr += 1 NEW_LINE DEDENT while count < k : NEW_LINE INDENT print ( curr , end = ' ▁ ' ) NEW_LINE curr += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
def pyGFG ( a , n ) : NEW_LINE INDENT mpp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE for j in range ( 1 , n * j <= num ) : NEW_LINE INDENT if num % j == 0 : NEW_LINE INDENT if j != 1 : NEW_LINE INDENT if mpp . has_key ( j ) : mpp [ j ] = mpp [ j ] + 1 NEW_LINE else : mpp [ j ] = 1 NEW_LINE DEDENT if ( num / j ) != j : NEW_LINE INDENT if mpp . has_key ( num / j ) : mpp [ num / j ] = mpp [ num / j ] + 1 NEW_LINE else : mpp [ num / j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT maxi = 0 NEW_LINE for k , v in mpp . items ( ) : NEW_LINE INDENT maxi = max ( v ) NEW_LINE DEDENT for k , v in mpp . items ( ) : NEW_LINE INDENT if v == maxi : NEW_LINE INDENT print ( k , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def pycf1146B ( ) : NEW_LINE INDENT import sys NEW_LINE import string NEW_LINE import re NEW_LINE import doctest NEW_LINE import tempfile NEW_LINE import os NEW_LINE import re NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE import re NEW_LINE import tempfile NEW_LINE import re NEW_LINE DEDENT
def voting ( ) : NEW_LINE INDENT f = FScanner ( ) NEW_LINE out = open ( ' voting . txt ' , ' w ' ) NEW_LINE n = f . count ( ' \n ' ) NEW_LINE ans , max = 0 , 0 NEW_LINE a = [ 0 ] * 1000001 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b = f . count ( ' \n ' ) NEW_LINE a [ b ] += 1 NEW_LINE if a [ b ] > max : NEW_LINE INDENT max = a [ b ] NEW_LINE ans = b NEW_LINE DEDENT DEDENT out . write ( ans ) NEW_LINE out . close ( ) NEW_LINE class FScanner : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT s = ' ' NEW_LINE next = ' ' NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not s . endswith ( ' \n ' ) : NEW_LINE INDENT try : NEW_LINE INDENT s = s [ : - 1 ] NEW_LINE DEDENT except IndexError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return int ( next ( ) ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return long ( next ( ) ) NEW_LINE DEDENT DEDENT return FScanner ( ) NEW_LINE DEDENT
def GFG ( str ) : NEW_LINE INDENT if str [ 0 ] >= ' A ' and str [ 0 ] <= ' Z ' : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def GFG ( prev_avg , x , n ) : NEW_LINE INDENT return ( prev_avg * n + x ) / ( n + 1 ) NEW_LINE DEDENT
def p050 ( ) : NEW_LINE INDENT print ( [ ' p050' , ' p051' , ' p052' , ' p053' , ' p054' , ' p055' , ' p056' , ' p057' , ' p058' , ' p059' , ' p0510' , ' p0511' , ' p0512' , ' p0513' , ' p0514' , ' p0515' , ' p0516' , ' p0517' , ' p0518' , ' p0519' , ' p0520' , ' p0521' , ' p0522' , ' p0522' , ' p0523' , ' p0524' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ' p0526' , ] ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT max = 0 NEW_LINE lst = [ 1 ] NEW_LINE lst . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] and lst [ i ] < lst [ j ] + 1 : NEW_LINE INDENT lst [ i ] , lst [ j ] = lst [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max < lst [ i ] : NEW_LINE INDENT max = lst [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE a = sys . argv [ 1 ] NEW_LINE b = sys . argv [ 2 ] NEW_LINE k = int ( math . log10 ( b ) ) + 1 NEW_LINE a = int ( a * math . pow ( 10 , k ) + b ) NEW_LINE yono = math . sqrt ( a ) NEW_LINE if yono - math . ceil ( yono ) == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT A = [ - 1 , - 1 , 6 , 1 , 9 , 3 , 2 , - 1 , 4 , - 1 ] NEW_LINE G = [ [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] ] NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if G [ i ] : NEW_LINE INDENT A [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] = - 1 NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import doctest NEW_LINE import tempfile NEW_LINE global systemin NEW_LINE global log NEW_LINE global result NEW_LINE global systemin NEW_LINE global log NEW_LINE global result NEW_LINE global systemin NEW_LINE global log NEW_LINE global result NEW_LINE global systemin NEW_LINE global log NEW_LINE global result NEW_LINE systemin = sys . stdin . readline ( ) NEW_LINE sys . stdin . close ( ) NEW_LINE systemin = sys . stdin . readline ( ) NEW_LINE sys . stdin . close ( ) NEW_LINE result = sys . stdin . readline ( ) NEW_LINE sys . stdin . close ( ) NEW_LINE log = sys . stdout . readline ( ) NEW_LINE sys . stdout . close ( ) NEW_LINE systemin = sys . stdout . readline ( ) NEW_LINE sys . stdout . close ( ) NEW_LINE result = sys . stdout . readline ( ) NEW_LINE sys . stdout . close ( ) NEW_LINE systemin = sys . stdout . readline ( ) NEW_LINE sys . stdout . close ( ) NEW_LINE DEDENT
def GFG ( head_ref , new_data ) : NEW_LINE INDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( data = new_data , prev = None , next = ( head_ref , ) ) NEW_LINE if ( head_ref ) : NEW_LINE INDENT ( head_ref , ) = ( head_ref , ) NEW_LINE DEDENT ( head_ref , ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT def make_oddnode ( head_ref , A , n ) : NEW_LINE INDENT ptr = head_ref NEW_LINE next = None NEW_LINE i = 0 NEW_LINE while ptr : NEW_LINE INDENT next = ptr . next NEW_LINE if ptr . data % 2 == 0 : NEW_LINE INDENT ptr . data = A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ptr = next NEW_LINE DEDENT return head_ref NEW_LINE DEDENT def print_list ( head ) : NEW_LINE INDENT while head : NEW_LINE INDENT print ( head . data , end = ' ▁ ' ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def print_list ( head ) : NEW_LINE INDENT arr = [ 3 , 5 , 23 , 17 , 1 ] NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 9 ) NEW_LINE head = push ( head , 6 ) NEW_LINE n = len ( arr ) NEW_LINE print ( " Original ▁ List : ▁ " ) NEW_LINE print_list ( head ) NEW_LINE print ( ) NEW_LINE head = make_oddnode ( head , arr , n ) NEW_LINE print ( " New ▁ odd ▁ List : ▁ " ) NEW_LINE print_list ( head ) NEW_LINE DEDENT DEDENT
def import ( ) : NEW_LINE INDENT f = sys . stdin NEW_LINE line = ' ' NEW_LINE dp = [ [ 11 , 331 ] , [ 331 , 11 ] , [ 331 , 11 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ 331 , 331 ] , [ ] , [ ] , [ ] ] NEW_LINE for i in range ( 11 , 331 + 1 ) : NEW_LINE INDENT f . append
def genmodular ( n ) : NEW_LINE INDENT mod = 1000000007 NEW_LINE fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res ** i NEW_LINE DEDENT return res NEW_LINE def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT def powmod ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT pt = powmod ( a , n / 2 ) NEW_LINE pt = ( pt * pt ) % mod NEW_LINE if n % 2 == 1 : NEW_LINE INDENT return ( pt * a ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return pt NEW_LINE DEDENT DEDENT def CountSubset ( arr , n ) : NEW_LINE INDENT ans = powmod ( 2 , n - 1 ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while j < n and arr [ j ] == arr [ i ] : NEW_LINE INDENT r = n - 1 - j NEW_LINE l = i NEW_LINE ans = ( ans + nCr ( l + r , l ) ) % mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubset ( arr , n ) ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 1000001 NEW_LINE primeUpto = [ 0 ] * MAX NEW_LINE SieveOfEratosthenes ( ) NEW_LINE isPrime = [ 1 ] * MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT isPrime [ i ] = 1 NEW_LINE DEDENT isPrime [ 0 ] = isPrime [ 1 ] = 0 NEW_LINE for i in range ( 2 , i * MAX ) : NEW_LINE INDENT if isPrime [ i ] == 1 : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT primeUpto [ i ] = primeUpto [ i - 1 ] NEW_LINE if isPrime [ i ] == 1 : NEW_LINE INDENT primeUpto [ i ] += 1 NEW_LINE DEDENT DEDENT return primeUpto NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i ) < n and ( n % i ) > 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i * i ) > n : NEW_LINE INDENT i = n NEW_LINE DEDENT return ( 1 + ( n - i ) / 2 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' a ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a | - - a """
def test_A_find_divisible ( ) : NEW_LINE INDENT f = symbols ( ' f ' , integer = True , positive = True ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE l , r = symbols ( ' l , r ' , integer = True , positive = True ) NEW_LINE assert A . find_divisible ( f , t ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , positive = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , negative = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , negative = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , positive = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , negative = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , negative = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , positive = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , negative = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , negative = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , positive = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , positive = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , negative = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , negative = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , positive = True ) == ( l , r ) NEW_LINE assert A . find_divisible ( f , t , positive
def p249 ( ) : NEW_LINE INDENT print ( [ ] ) NEW_LINE def run ( ) : NEW_LINE INDENT is_prime = library . list_primality ( LIMIT * LIMIT / 2 ) NEW_LINE num_subsets = [ 1 ] * LIMIT * LIMIT / 2 NEW_LINE max_sum = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if not is_prime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT max_sum += i NEW_LINE for j in range ( max_sum , i - i , - 1 ) : NEW_LINE INDENT temp = num_subsets [ j ] + num_subsets [ j - i ] NEW_LINE if temp < MODULUS : NEW_LINE INDENT num_subsets [ j ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT num_subsets [ j ] = temp - MODULUS NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( len ( num_subsets ) ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT sum = ( sum + num_subsets [ i ] ) % MODULUS NEW_LINE DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT return run NEW_LINE DEDENT
def GFG ( row_num ) : NEW_LINE INDENT count = 0 NEW_LINE while row_num > 0 : NEW_LINE INDENT count += row_num & 1 NEW_LINE row_num >>= 1 NEW_LINE DEDENT return ( 1 << count ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while V >= deno [ i ] : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def p_p052 ( p ) : NEW_LINE INDENT ''' p052 ▁ : ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁ INTEGER ▁
def import ( ) : NEW_LINE INDENT import numpy NEW_LINE class solution : NEW_LINE INDENT def count ( arr , n , x ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT ans = long ( math . pow ( 2 , n ) - 1 ) NEW_LINE return ans NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % x == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = long ( math . pow ( 2 , count ) - 1 ) NEW_LINE return ans NEW_LINE DEDENT def __repr__ ( ) : NEW_LINE INDENT return ' % s ( % s ) ' % ( solution ( ) . __name__ , solution ( ) . __qualname__ ) NEW_LINE DEDENT DEDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE return ' % s ( % s ) ' % ( solution ( ) . __name__ , solution ( ) . __qualname__ ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE assert find_ele ( arr , n ) == 1 NEW_LINE DEDENT
def GFG ( str_a , str_b ) : NEW_LINE INDENT m1 = [ ] NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT m1 . append ( str_b [ i ] ) NEW_LINE DEDENT for i in range ( 256 ) : NEW_LINE INDENT m1 . append ( str_a [ i ] ) NEW_LINE DEDENT for i in range ( len ( m1 ) ) : NEW_LINE INDENT if m1 [ i ] == 1 : NEW_LINE INDENT return chr ( i ) NEW_LINE DEDENT DEDENT return ord ( ' \0' ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , " a : b : " ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - a ' : NEW_LINE INDENT if a == ' - - all ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - yes ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - no ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - yes - no ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - yes - no ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - no - yes ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - yes - no ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - yes - no ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - yes - no - no ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - yes - no - no ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - yes - no - no - yes ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - yes - no - no ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - yes - no - no ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - yes - no - no - no - yes ' : NEW_LINE INDENT print ( " all " ) NEW_LINE DEDENT elif a == ' - - all - yes - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no - no -
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while True : NEW_LINE INDENT n = input ( ) NEW_LINE if n == ' ' : NEW_LINE INDENT sys . exit ( ) NEW_LINE DEDENT conv = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT conv . append ( i ) NEW_LINE DEDENT before = input ( ) NEW_LINE after = input ( ) NEW_LINE seq = [ before ] NEW_LINE depth = 0 NEW_LINE convertable = False NEW_LINE bfs : NEW_LINE INDENT while not seq : NEW_LINE INDENT depth += 1 NEW_LINE size = len ( seq ) NEW_LINE for q in range ( size ) : NEW_LINE INDENT poll = seq . pop ( q ) NEW_LINE for i in range ( conv ) : NEW_LINE INDENT test = poll . replace ( conv [ i ] , conv [ i ] ) NEW_LINE if test == poll : NEW_LINE INDENT continue NEW_LINE DEDENT elif test == after : NEW_LINE INDENT convertable = True NEW_LINE break NEW_LINE DEDENT elif len ( test ) <= len ( after ) : NEW_LINE INDENT seq . append ( test ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if convertable : NEW_LINE INDENT print ( depth ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def pythontools . solve ( HastaLaVistaLa ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE scn = sys . stdin NEW_LINE s = [ ] NEW_LINE out = [ ] NEW_LINE def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for tests in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT out . append ( " " ) NEW_LINE out . append ( " " ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n = scn . readline ( ) NEW_LINE a = [ scn . readline ( ) for i in range ( n ) ] NEW_LINE freq = [ 0 ] * 1010 NEW_LINE can = ( n + 1 ) NEW_LINE for i in a : NEW_LINE INDENT freq [ i ] += 1 NEW_LINE if freq [ i ] > can / 2 : NEW_LINE INDENT s . append ( " NO " ) NEW_LINE return NEW_LINE DEDENT DEDENT s . append ( " YES " ) NEW_LINE DEDENT return s NEW_LINE DEDENT
def AAB ( arr1 , n1 , arr2 , n2 ) : NEW_LINE INDENT max1 = int ( 0 ) NEW_LINE max2 = int ( 0 ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if arr1 [ i ] > max1 : NEW_LINE INDENT max1 = arr1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( n2 ) : NEW_LINE INDENT if arr2 [ i ] > max2 : NEW_LINE INDENT max2 = arr2 [ i ] NEW_LINE DEDENT DEDENT return max1 + max2 NEW_LINE DEDENT
def GFG ( op , n , k ) : NEW_LINE INDENT i , count = 0 , 0 NEW_LINE nVal = 0 NEW_LINE min = sys . maxint NEW_LINE for i in range ( n ) : NEW_LINE INDENT nVal += op [ i ] NEW_LINE min = min ( min , nVal ) NEW_LINE if ( k + nVal ) <= 0 : NEW_LINE INDENT return ( i + 1 , - 1 ) NEW_LINE DEDENT DEDENT if nVal >= 0 : NEW_LINE INDENT return ( - 1 , 0 ) NEW_LINE DEDENT times = ( k - abs ( min ) ) / abs ( nVal ) NEW_LINE k = ( k - ( times * abs ( nVal ) ) ) NEW_LINE count = ( times * n ) NEW_LINE while k > 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT k = k + op [ i ] NEW_LINE count += 1 NEW_LINE if k <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def GFG ( x ) : NEW_LINE INDENT pref = np . zeros ( 100010 ) NEW_LINE is_perfect_cube = np . round ( np . cbrt ( x ) ) NEW_LINE if cr * cr * cr == float ( x ) : NEW_LINE INDENT return x NEW_LINE DEDENT return 0 NEW_LINE def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100000 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + is_perfect_cube ( i ) NEW_LINE DEDENT DEDENT def print_sum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] NEW_LINE print ( sum , end = ' ▁ ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT compute ( ) NEW_LINE Q = 4 NEW_LINE arr = [ [ 1 , 10 ] , [ 1 , 100 ] , [ 2 , 25 ] , [ 4 , 50 ] ] NEW_LINE for i in range ( Q ) : NEW_LINE INDENT print_sum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global N , R , L , po , c NEW_LINE now = 0 NEW_LINE index = 0 NEW_LINE for line in sys . stdin : NEW_LINE INDENT line = line . strip ( ) NEW_LINE d = int ( line ) - 1 NEW_LINE t = int ( line ) NEW_LINE x = int ( line ) NEW_LINE c [ index ] += t - now NEW_LINE po [ d ] += x NEW_LINE now = t NEW_LINE if x > 0 : NEW_LINE INDENT if d == index : NEW_LINE INDENT continue NEW_LINE DEDENT if po [ index ] < po [ d ] : NEW_LINE INDENT index = d NEW_LINE DEDENT elif po [ index ] == po [ d ] and index > d : NEW_LINE INDENT index = d NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if d != index : NEW_LINE INDENT continue NEW_LINE DEDENT maxp = int ( line ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT if maxp < po [ j ] : NEW_LINE INDENT maxp = po [ j ] NEW_LINE index = j NEW_LINE DEDENT DEDENT DEDENT DEDENT c [ index ] += L - now NEW_LINE ans = 0 NEW_LINE max = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if c [ i ] > max : NEW_LINE INDENT max = c [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT print ( ans + 1 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 3 NEW_LINE print ( n , " th ▁ Centered " , " cube ▁ number : ▁ " , repr ( n ) ) NEW_LINE assert centered_cube ( n ) == n NEW_LINE n = 10 NEW_LINE print ( n , " th ▁ Centered " , " cube ▁ number : ▁ " , repr ( n ) ) NEW_LINE assert centered_cube ( n ) == n NEW_LINE DEDENT
def ▁ pre132 ( ) : ENDCOM # ▁ import ▁ sys , ▁ os , ▁ re , ▁ string , ▁ tokenize , ▁ _ _ builtin _ _ ENDCOM # ▁ import ▁ time , ▁ time , ▁ datetime , ▁ datetime , ▁ datetime , ▁ time , ▁ time ENDCOM # ▁ import ▁ sys , ▁ os , ▁ re , ▁ string , ▁ _ _ builtin _ _ ENDCOM # ▁ import ▁ time , ▁ time , ▁ datetime , ▁ datetime , ▁ time , ▁ time ENDCOM # ▁ import ▁ sys , ▁ re , ▁ string , ▁ _ _ builtin _ _ ENDCOM # ▁ import ▁ time , ▁ time , ▁ datetime , ▁ datetime , ▁ time , ▁ time , ▁ time , ▁ time ENDCOM # ▁ import ▁ re , ▁ string , ▁ _ _ builtin _ _ ENDCOM # ▁ import ▁ sys , ▁ re , ▁ time , ▁ datetime , ▁ datetime , ▁ datetime , ▁ time , ▁ time , ▁ time , ▁ time ENDCOM # ▁ import ▁ re , ▁ string , ▁ _ _ builtin _ _ ENDCOM # ▁ import ▁ re , ▁ time , ▁ datetime , ▁ datetime , ▁ datetime , ▁ time , ▁ time , ▁ time , ▁ time ENDCOM # ▁ import ▁ re , ▁ string , ▁ _ _ builtin _ _ ENDCOM # ▁ import ▁ re , ▁ time , ▁ datetime , ▁ datetime , ▁ datetime , ▁ time , ▁ time , ▁ time , ▁ time , ▁ time ENDCOM # ▁ import ▁ re , ▁ string , ▁ _ _ builtin _ _ ENDCOM # ▁ import ▁ re , ▁ time , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ time , ▁ time , ▁ time , ▁ time , ▁ time , ▁ time , ▁ time , ▁ time , ▁ time , ▁ time ENDCOM # ▁ import ▁ re , ▁ string , ▁ _ _ builtin _ _ ENDCOM # ▁ import ▁ re , ▁ time , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime , ▁ datetime
def test_GFG ( ) : NEW_LINE INDENT nth , i = symbols ( ' n ▁ i ' , integer = True , positive = True ) NEW_LINE for n in [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 ] : NEW_LINE INDENT assert nth_term ( n , i ) == nth NEW_LINE DEDENT DEDENT
def test_ispower ( ) : NEW_LINE INDENT assert ispower ( 10 , 1 ) is True NEW_LINE assert ispower ( 1 , 20 ) is True NEW_LINE assert ispower ( 2 , 128 ) is True NEW_LINE assert ispower ( 2 , 30 ) is True NEW_LINE DEDENT
def test_power ( ) : NEW_LINE INDENT assert is_power ( 10 , 1 ) NEW_LINE assert is_power ( 1 , 20 ) NEW_LINE assert is_power ( 2 , 128 ) NEW_LINE assert is_power ( 2 , 30 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = [ 4 , 21 , 5 , 3 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE assert minimum_value ( arr , n , k ) == 0 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE N = int ( sys . argv [ 1 ] ) NEW_LINE vs = set ( ) NEW_LINE indeg = { } NEW_LINE outdeg = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT u , d , rel = ' u ' , ' d ' , ' rel ' NEW_LINE u = ' u ' + u NEW_LINE d = ' d ' + d NEW_LINE vs . add ( u ) NEW_LINE vs . add ( d ) NEW_LINE indeg [ u ] = set ( ) NEW_LINE indeg [ d ] = set ( ) NEW_LINE outdeg [ u ] = set ( ) NEW_LINE outdeg [ d ] = set ( ) NEW_LINE if rel == ' lock ' : NEW_LINE INDENT indeg [ u ] . add ( d ) NEW_LINE outdeg [ d ] . add ( u ) NEW_LINE DEDENT else : NEW_LINE INDENT indeg [ d ] . add ( u ) NEW_LINE outdeg [ u ] . add ( d ) NEW_LINE DEDENT DEDENT que = Queue ( ) NEW_LINE for v in indeg : NEW_LINE INDENT if len ( indeg [ v ] ) == 0 : NEW_LINE INDENT que . put ( v ) NEW_LINE DEDENT DEDENT while not que . empty ( ) : NEW_LINE INDENT u = que . get ( ) NEW_LINE for v in outdeg [ u ] : NEW_LINE INDENT indeg [ v ] . remove ( u ) NEW_LINE if len ( indeg [ v ] ) == 0 : NEW_LINE INDENT que . put ( v ) NEW_LINE DEDENT DEDENT vs . remove ( u ) NEW_LINE DEDENT print ( len ( vs ) if len ( vs ) > 0 else 0 ) NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) / 2 NEW_LINE if N == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n NEW_LINE global a NEW_LINE global k NEW_LINE global v NEW_LINE n = len ( sys . argv ) NEW_LINE a = min ( n , 4 ) NEW_LINE num = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num . append ( sys . argv [ i ] ) NEW_LINE DEDENT num . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( a ) : NEW_LINE INDENT for j in range ( a ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT ans . append ( int ( str ( num [ i ] ) + str ( num [ j ] ) ) ) NEW_LINE DEDENT ans . sort ( ) NEW_LINE print ( ans [ 2 ] ) NEW_LINE DEDENT DEDENT
def run ( Z ) : NEW_LINE INDENT f = open ( Z , ' r ' ) NEW_LINE op = [ ] NEW_LINE stz = [ ] NEW_LINE T = int ( f . readline ( ) ) NEW_LINE while T : NEW_LINE INDENT n = int ( f . readline ( ) ) NEW_LINE stz = f . readline ( ) NEW_LINE a = [ int ( stz . split ( ) [ 0 ] ) for i in range ( n << 2 ) ] NEW_LINE yes = True NEW_LINE a . sort ( ) NEW_LINE area = a [ 0 ] * a [ - 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lf , rg = i * 2 , 4 * n - ( i * 2 ) - 1 NEW_LINE if ( a [ lf ] != a [ lf + 1 ] ) or ( a [ rg ] != a [ rg - 1 ] ) or ( a [ lf ] * a [ rg ] != area ) : NEW_LINE INDENT yes = False NEW_LINE break NEW_LINE DEDENT DEDENT if yes : NEW_LINE INDENT op . append ( ' YES \n ' ) NEW_LINE DEDENT else : NEW_LINE INDENT op . append ( ' NO \n ' ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( op ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mp . has_key ( i ) : NEW_LINE INDENT mp [ i ] = mp [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i , frequency in mp . items ( ) : NEW_LINE INDENT x = i NEW_LINE frequency = frequency . value NEW_LINE if x <= frequency : NEW_LINE INDENT ans += ( frequency - x ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += frequency NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def delete_n ( inp , del ) : NEW_LINE INDENT in_num = 1234 NEW_LINE inp = str ( inp ) NEW_LINE del in_num NEW_LINE print ( ' num _ after _ deleting _ from _ starting ▁ ' + str ( from_start ( inp , del ) ) ) NEW_LINE print ( ' num _ after _ deleting _ from _ ending ▁ ' + str ( from_end ( inp , del ) ) ) NEW_LINE def from_start ( inp , del ) : NEW_LINE INDENT try : NEW_LINE INDENT inp1 = inp [ : del - 1 ] NEW_LINE inp2 = inp [ del : len ( inp ) ] NEW_LINE return inp1 + inp2 NEW_LINE DEDENT except : NEW_LINE INDENT return ' Check ▁ Input ' NEW_LINE DEDENT DEDENT def from_end ( inp , del ) : NEW_LINE INDENT try : NEW_LINE INDENT inp1 = inp [ : del ] NEW_LINE inp2 = inp [ len ( inp ) - del + 1 : ] NEW_LINE return inp1 + inp2 NEW_LINE DEDENT except : NEW_LINE INDENT return ' Check ▁ Input ' NEW_LINE DEDENT DEDENT return from_start , from_end NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT x = 0 NEW_LINE for n in range ( n , - 1 , - 1 ) : NEW_LINE INDENT no = x NEW_LINE prev_dig = 11 NEW_LINE flag = True NEW_LINE while no != 0 : NEW_LINE INDENT if prev_dig < no % 10 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev_dig = no % 10 NEW_LINE no //= 10 NEW_LINE DEDENT if flag == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def main ( * args ) : NEW_LINE INDENT import sys NEW_LINE f = sys . stdout NEW_LINE x1 , y1 , x2 , y2 = args NEW_LINE if x1 == x2 : NEW_LINE INDENT dif = abs ( y1 - y2 ) NEW_LINE f . write ( ( x1 + dif ) + ' ▁ ' + y1 + ' ▁ ' + ( x1 + dif ) + ' ▁ ' + y2 ) NEW_LINE DEDENT elif y1 == y2 : NEW_LINE INDENT dif = abs ( x1 - x2 ) NEW_LINE f . write ( ( x1 , y1 + dif ) + ' ▁ ' + ( x2 , y2 + dif ) ) NEW_LINE DEDENT elif abs ( x1 - x2 ) == abs ( y1 - y2 ) : NEW_LINE INDENT f . write ( x1 + ' ▁ ' + y2 + ' ▁ ' + x2 + ' ▁ ' + y1 ) NEW_LINE DEDENT else : NEW_LINE INDENT f . write ( - 1 ) NEW_LINE DEDENT f . close ( ) NEW_LINE DEDENT
def get_bus_game ( x_needed , x_available , y_needed , y_available ) : NEW_LINE INDENT f = open ( " / proc / meminfo " , " r " ) NEW_LINE x = int ( f . readline ( ) ) NEW_LINE y = int ( f . readline ( ) ) NEW_LINE turn = 0 NEW_LINE while True : NEW_LINE INDENT if turn % 2 == 0 : NEW_LINE INDENT if can_take ( 2 , x , 2 , y ) : NEW_LINE INDENT x -= 2 NEW_LINE y -= 2 NEW_LINE DEDENT elif can_take ( 1 , x , 12 , y ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 12 NEW_LINE DEDENT elif can_take ( 0 , x , 22 , y ) : NEW_LINE INDENT y -= 22 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Hanako " ) NEW_LINE return NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if can_take ( 0 , x , 22 , y ) : NEW_LINE INDENT y -= 22 NEW_LINE DEDENT elif can_take ( 1 , x , 12 , y ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 12 NEW_LINE DEDENT elif can_take ( 2 , x , 2 , y ) : NEW_LINE INDENT x -= 2 NEW_LINE y -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Ciel " ) NEW_LINE return NEW_LINE DEDENT DEDENT turn += 1 NEW_LINE DEDENT DEDENT
def test_DZYLovesChessboard ( ) : NEW_LINE INDENT f = FastReader ( ) NEW_LINE out = open ( ' input . txt ' , ' w ' ) NEW_LINE n , m = f . read ( ) . split ( ' \n ' ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( f . read ( ) . split ( ) [ 0 ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT w = i % 2 == 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT w = not w NEW_LINE if arr [ i ] [ j ] == ' . ' : NEW_LINE INDENT out . write ( w and ' W ' or ' B ' ) NEW_LINE DEDENT else : NEW_LINE INDENT out . write ( ' - ' ) NEW_LINE DEDENT DEDENT out . write ( ' \n ' ) NEW_LINE DEDENT out . close ( ) NEW_LINE class FastReader : NEW_LINE INDENT f = open ( ' input . txt ' , ' r ' ) NEW_LINE st = [ ] NEW_LINE def readline ( ) : NEW_LINE INDENT while st == [ ] or not st : NEW_LINE INDENT try : NEW_LINE INDENT st . append ( f . readline ( ) ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT def next ( ) : NEW_LINE INDENT return None NEW_LINE DEDENT def readline ( ) : NEW_LINE INDENT return ' ' NEW_LINE DEDENT def next ( ) : NEW_LINE INDENT return ' ' NEW_LINE DEDENT def readline ( ) : NEW_LINE INDENT return ' ' NEW_LINE DEDENT DEDENT f . close ( ) NEW_LINE DEDENT
def test_flippinggame ( ) : NEW_LINE INDENT import sys NEW_LINE if sys . platform == ' win32' : NEW_LINE INDENT n = int ( sys . argv [ 1 ] ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT max = int ( sys . argv [ 1 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT x = 0 NEW_LINE brr = [ ] NEW_LINE for k in arr : NEW_LINE INDENT brr . append ( k ) NEW_LINE DEDENT for k in range ( i , j ) : NEW_LINE INDENT if brr [ k ] == 0 : NEW_LINE INDENT brr . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT brr . append ( 0 ) NEW_LINE DEDENT DEDENT count = checKNo ( brr ) NEW_LINE if count > max : NEW_LINE INDENT max = count NEW_LINE DEDENT DEDENT DEDENT if n == 1 : NEW_LINE INDENT if arr [ 0 ] == 1 : NEW_LINE INDENT assert 0 NEW_LINE DEDENT else : NEW_LINE INDENT assert 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT assert max == 1 NEW_LINE DEDENT DEDENT DEDENT
def test_countdistict_subarray ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ countdistic ▁ subarray . STRNEWLINE ▁ """ NEW_LINE vis = { } NEW_LINE for key in range ( n ) : NEW_LINE INDENT vis [ arr [ key ] ] = 1 NEW_LINE DEDENT k = len ( vis ) NEW_LINE vis . clear ( ) NEW_LINE ans , right , window = 0 , 0 , 0 , 0 NEW_LINE for left in range ( n ) : NEW_LINE INDENT while right < n and window < k : NEW_LINE INDENT vis [ arr [ right ] ] = vis [ arr [ right ] ] + 1 NEW_LINE if vis [ arr [ right ] ] == 1 : NEW_LINE INDENT window += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if window == k : NEW_LINE INDENT ans += ( n - right + 1 ) NEW_LINE DEDENT vis [ arr [ left ] ] = vis [ arr [ left ] ] - 1 NEW_LINE if vis [ arr [ left ] ] == 0 : NEW_LINE INDENT window -= 1 NEW_LINE DEDENT DEDENT return ans , right , window NEW_LINE DEDENT
def test_cv_max ( ) : NEW_LINE INDENT f = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE s = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE max = 0 NEW_LINE while n > 0 : NEW_LINE INDENT f = f [ : n ] NEW_LINE t = f [ n : ] NEW_LINE if max < f + t : NEW_LINE INDENT max = f + t NEW_LINE DEDENT DEDENT o = [ max ( max , s ) ] NEW_LINE assert o == [ max ( max , s ) ] NEW_LINE assert o == [ max ( max , s ) ] NEW_LINE assert o == [ max ( max , s ) , max ( max , s ) ] NEW_LINE assert o == [ max ( max , s ) , max ( max , s ) , max ( max , s ) ] NEW_LINE assert o == [ max ( max , s ) , max ( max , s ) , max ( max , s ) , max ( max , s ) ] NEW_LINE assert o == [ max ( max , s ) , max ( max , s ) , max ( max , s ) , max ( max , s ) ] NEW_LINE assert o == [ max ( max , s ) , max ( max , s ) , max ( max , s ) , max ( max , s ) ] NEW_LINE assert o == [ max ( max , s ) , max ( max , s ) , max ( max , s ) , max ( max , s ) , max ( max , s ) ] NEW_LINE assert o == [ max ( max , s ) , max ( max , s ) , max ( max , s ) , max ( max , s ) , max ( max , s ) ] NEW_LINE assert o == [ max ( max , s ) , max ( max , s ) , max ( max , s ) , max ( max , s ) , max ( max , s ) , max ( max , s ) , max ( max , s ) , max ( max , s ) ] NEW_LINE DEDENT
def pyGFG ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n * i <= n , 2 ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def reverse_k_element_queue ( k ) : NEW_LINE INDENT queue = [ ] NEW_LINE queue . append ( 0 ) NEW_LINE queue . append ( 1 ) NEW_LINE queue . append ( 2 ) NEW_LINE queue . append ( 3 ) NEW_LINE queue . append ( 4 ) NEW_LINE queue . append ( 5 ) NEW_LINE queue . append ( 6 ) NEW_LINE queue . append ( 7 ) NEW_LINE queue . append ( 8 ) NEW_LINE queue . append ( 9 ) NEW_LINE queue . append ( 10 ) NEW_LINE queue . append ( 11 ) NEW_LINE queue . append ( 12 ) NEW_LINE queue . append ( 13 ) NEW_LINE queue . append ( 14 ) NEW_LINE queue . append ( 15 ) NEW_LINE queue . append ( 16 ) NEW_LINE queue . append ( 17 ) NEW_LINE queue . append ( 18 ) NEW_LINE queue . append ( 19 ) NEW_LINE queue . append ( 20 ) NEW_LINE queue . append ( 21 ) NEW_LINE queue . append ( 22 ) NEW_LINE queue . append ( 23 ) NEW_LINE queue . append ( 24 ) NEW_LINE queue . append ( 25 ) NEW_LINE queue . append ( 26 ) NEW_LINE queue . append ( 27 ) NEW_LINE queue . append ( 28 ) NEW_LINE queue . append ( 29 ) NEW_LINE queue . append ( 30 ) NEW_LINE queue . append ( 31 ) NEW_LINE queue . append ( 32 ) NEW_LINE queue . append ( 33 ) NEW_LINE queue . append ( 34 ) NEW_LINE queue . append ( 35 ) NEW_LINE queue . append ( 36 ) NEW_LINE queue . append ( 37 ) NEW_LINE queue . append ( 38 ) NEW_LINE queue . append ( 39 ) NEW_LINE queue . append ( 40 ) NEW_LINE queue . append ( 41 ) NEW_LINE queue . append ( 42 ) NEW_LINE queue . append ( 43 ) NEW_LINE queue . append ( 44 ) NEW_LINE queue . append ( 45 ) NEW_LINE queue . append ( 46 ) NEW_LINE queue . append ( 47 ) NEW_LINE queue . append ( 48 ) NEW_LINE queue . append ( 49 ) NEW_LINE queue . append ( 50 ) NEW_LINE queue . append ( 51 ) NEW_LINE queue . append ( 52 ) NEW_LINE queue . append ( 53 ) NEW_LINE queue . append ( 54 ) NEW_LINE queue . append ( 55 ) NEW_LINE queue . append ( 56 ) NEW_LINE queue . append ( 57 ) NEW_LINE queue . append ( 58 ) NEW_LINE queue . append ( 59 ) NEW_LINE queue . append ( 60 ) NEW_LINE queue . append ( 61 ) NEW_LINE queue . append ( 62 ) NEW_LINE queue . append ( 63 ) NEW_LINE queue . append ( 64 ) NEW_LINE queue . append ( 65 ) NEW_LINE queue . append ( 66 ) NEW_LINE queue . append ( 67 ) NEW_LINE queue . append ( 72 ) NEW_LINE queue . append ( 72 ) NEW_LINE queue . append
def ideone ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE n = int ( sys . argv [ 1 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = - int ( sys . argv [ i ] ) NEW_LINE for x in sys . argv [ i + 1 : ] . strip ( ) . split ( ) : NEW_LINE INDENT sum += int ( x ) NEW_LINE DEDENT if sum % 2 == 0 : NEW_LINE INDENT print ( ' maomao90' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' errorgorn ' ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( k + 1 ) & k ) == 0 : NEW_LINE INDENT return k // 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def class Solution ( num ) : NEW_LINE INDENT low = 1 NEW_LINE high = num NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if mid * mid == num : NEW_LINE INDENT return True NEW_LINE DEDENT elif mid * mid < num : NEW_LINE INDENT low = int ( mid + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT high = int ( mid - 1 ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE a = sys . argv [ 1 ] NEW_LINE b = sys . argv [ 2 ] NEW_LINE c = sys . argv [ 3 ] NEW_LINE result = " No " NEW_LINE if max ( a , max ( b , c ) ) * 2 == a + b + c : NEW_LINE INDENT result = " Yes " NEW_LINE DEDENT print ( result ) NEW_LINE class Scanner : NEW_LINE INDENT def __init__ ( self , f ) : NEW_LINE INDENT self . f = f NEW_LINE DEDENT def scan ( self , f ) : NEW_LINE INDENT self . f = self . f . read ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . f . readline ( ) NEW_LINE DEDENT DEDENT return Scanner ( sys . stdin ) NEW_LINE DEDENT
def test_problem_5 ( ) : NEW_LINE INDENT input = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE n1 = len ( input ) NEW_LINE arr = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT n2 = input [ i ] NEW_LINE arr . append ( n2 ) NEW_LINE sum += float ( arr [ i ] ) NEW_LINE DEDENT summ = sum NEW_LINE summ /= float ( n1 ) NEW_LINE nos = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] == summ : NEW_LINE INDENT nos += 1 NEW_LINE DEDENT DEDENT print ( nos ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if float ( arr [ i ] ) == summ : NEW_LINE INDENT print ( ( i + 1 ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = ' Process ▁ Queue ▁ example ' ) NEW_LINE parser . add_argument ( ' size ' , type = int , help = ' Size ▁ of ▁ the ▁ queue . ' ) NEW_LINE parser . add_argument ( ' quantum ' , type = int , help = ' quantum ▁ of ▁ the ▁ queue . ' ) NEW_LINE parser . add_argument ( ' - - sum ' , type = int , help = ' Sum ▁ of ▁ the ▁ queue . ' ) NEW_LINE parser . add_argument ( ' - - queue ' , type = int , help = ' Queue ▁ to ▁ process . ' ) NEW_LINE parser . add_argument ( ' - - queue - name ' , type = str , help = ' Queue ▁ name ▁ to ▁ process . ' ) NEW_LINE parser . add_argument ( ' - - queue - name ' , type = str , help = ' Queue ▁ name ▁ to ▁ process ▁ to . ' ) NEW_LINE parser . add_argument ( ' - - queue - name ' , type = str , help = ' Queue ▁ name ▁ to ▁ process ▁ to . ' ) NEW_LINE parser . add_argument ( ' - - queue - name ' , type = str , help = ' Queue ▁ name ▁ to ▁ process ▁ to . ' ) NEW_LINE parser . add_argument ( ' - - queue - name ' , type = str , help = ' Queue ▁ name ▁ to ▁ process ▁ to . ' ) NEW_LINE parser . add_argument ( ' - - queue - name ' , type = str , help = ' Queue ▁ name ▁ to ▁ process ▁ to . ' ) NEW_LINE parser . add_argument ( ' - - queue - name ' , type = str , help = ' Queue ▁ name ▁ to ▁ process ▁ to . ' ) NEW_LINE parser . add_argument ( ' - - queue - name ' , type = str , help = ' Queue ▁ name ▁ to ▁ process ▁ to . ' ) NEW_LINE parser . add_argument ( ' - - queue - name ' , type = str , help = ' Queue ▁ name ▁ to ▁ process ▁ to . ' ) NEW_LINE parser . add_argument ( ' - - queue - name ' , type = str , help = ' Queue ▁ name ▁ to ▁ process ▁ to . ' ) NEW_LINE parser . add_argument ( ' - - queue - name ' , type = str , help = ' Queue ▁ name ▁ to ▁ process ▁ to . ' ) NEW_LINE parser . add_argument ( ' - - queue - name ' , type = str , help = ' Queue ▁ name ▁ to ▁ process ▁ to . '
def test_GFG ( ) : NEW_LINE INDENT for i in range ( rotations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left , right = ranges [ i ] NEW_LINE if left <= index and right >= index : NEW_LINE INDENT if index == left : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT MAXN = 1000001 NEW_LINE spf = [ 0 ] * MAXN NEW_LINE hash1 = [ 0 ] * MAXN NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , i * MAXN ) : NEW_LINE INDENT if spf [ i ] == i : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if spf [ j ] == j : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT temp = 0 NEW_LINE while x != 1 : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if x % temp == 0 : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x / spf [ x ] NEW_LINE DEDENT while x % temp == 0 : NEW_LINE INDENT x = x / temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( x ) : NEW_LINE INDENT temp = 0 NEW_LINE while x != 1 : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if x % temp == 0 and hash1 [ temp ] > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT while x % temp == 0 : NEW_LINE INDENT x = x / temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if check ( arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if hasValidNum ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def pythree_solution ( a , n ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ True ▁ if ▁ the ▁ number ▁ of ▁ times ▁ a ▁ is ▁ found ▁ in ▁ the ▁ given ▁ array . STRNEWLINE ▁ """ NEW_LINE freq = { } NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] = freq [ a [ i ] ] if i != 0 else 0 NEW_LINE sum += a [ i ] NEW_LINE DEDENT if sum % 2 == 0 : NEW_LINE INDENT if freq [ sum / 2 ] != 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def GFG ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE return area NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE n = 0 NEW_LINE a = [ [ ] for i in range ( 4 ) ] NEW_LINE for i , j in enumerate ( sys . argv [ 1 : ] ) : NEW_LINE INDENT if i == 2 and j != 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT a [ i ] . append ( j ) NEW_LINE DEDENT print ( " + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
def test_codeforces ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE n = symbols ( ' n ' ) NEW_LINE if ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT assert codeforces ( x ) == ' YES ' NEW_LINE DEDENT else : NEW_LINE INDENT assert codeforces ( x ) == ' NO ' NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n < 10 : NEW_LINE INDENT return False NEW_LINE DEDENT prodOdd , prodEven = 1 , 1 NEW_LINE while n > 0 : NEW_LINE INDENT digit = n % 10 NEW_LINE prodOdd *= digit NEW_LINE n /= 10 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT digit = n % 10 NEW_LINE prodEven *= digit NEW_LINE n /= 10 NEW_LINE DEDENT if prodEven == prodOdd : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while 1 : NEW_LINE INDENT n = input ( " Enter ▁ n ▁ ( or ▁ quit ) : ▁ " ) NEW_LINE if n == ' quit ' : break NEW_LINE key = [ ] NEW_LINE str = sys . stdin . readline ( ) . split ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT key . append ( int ( str [ i ] ) ) NEW_LINE DEDENT c = sys . stdin . readline ( ) . split ( ) NEW_LINE key_count = 0 NEW_LINE for i in range ( len ( c ) ) : NEW_LINE INDENT for j in key [ key_count ] : NEW_LINE INDENT if c [ i ] == 97 : NEW_LINE INDENT c [ i ] = 90 NEW_LINE DEDENT elif c [ i ] == 65 : NEW_LINE INDENT c [ i ] = 122 NEW_LINE DEDENT else : NEW_LINE INDENT c [ i ] -= 1 NEW_LINE DEDENT DEDENT if key_count == len ( key ) - 1 : NEW_LINE INDENT key_count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT key_count += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( c ) ) : NEW_LINE INDENT print ( c [ i ] ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT if arr [ r ] == 1 : NEW_LINE INDENT assert ' odd ' in arr NEW_LINE DEDENT else : NEW_LINE INDENT assert ' even ' in arr NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT f = open ( ' / proc / cpuinfo ' , ' r ' ) NEW_LINE try : NEW_LINE INDENT lines = f . readlines ( ) NEW_LINE split = lines . split ( ) NEW_LINE w , h , x , y , r = split NEW_LINE if ( x - r >= 0 ) and ( x + r <= w ) and ( y - r >= 0 ) and ( y + r <= h ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT finally : NEW_LINE INDENT f . close ( ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def test_gf_gf_composite_product ( ) : NEW_LINE INDENT """ Test ▁ composite ▁ product ▁ of ▁ polynomials . """ NEW_LINE max_val = gf_max_val ( [ 1 ] , ZZ ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if prime [ p ] is True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not prime [ i ] : NEW_LINE INDENT product *= i NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global verbose , verbose , header_list NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , " hv " ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - h | - v ] ▁ [ - d | - - debug ] """ % sys . argv [ 0 ] ) NEW_LINE print ( """ ▁ ▁ - h , ▁ - v , ▁ - - help """ ) NEW_LINE print ( """ ▁ ▁ - d , ▁ - - debug """ ) NEW_LINE print ( """ ▁ ▁ - v , ▁ - - verbose """ ) NEW_LINE print ( """ ▁ ▁ - v ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁
def main ( ) : NEW_LINE INDENT strarr = [ ' FILIPINO ' , ' JAPANESE ' , ' KOREAN ' ] NEW_LINE s = input ( ) NEW_LINE t = len ( s ) NEW_LINE index_word = 0 NEW_LINE for i in range ( t ) : NEW_LINE INDENT s1 = s [ i ] NEW_LINE if s1 . endswith ( ' po ' ) : NEW_LINE INDENT index_word = 0 NEW_LINE DEDENT elif s1 . endswith ( ' mnida ' ) : NEW_LINE INDENT index_word = 2 NEW_LINE DEDENT else : NEW_LINE INDENT index_word = 1 NEW_LINE DEDENT print ( strarr [ index_word ] ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n , left , right ) : NEW_LINE INDENT k = right - left NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 NEW_LINE return ans NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ greatest ▁ factorial ▁ minimization ▁ of ▁ the ▁ polynomials . """ NEW_LINE n , a , b , c = symbols ( ' n ▁ a ▁ b ▁ c ' , integer = True , positive = True ) NEW_LINE maxVal = 0 NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if math . floor ( z ) == math . ceil ( z ) : NEW_LINE INDENT x = i / a NEW_LINE y = j / b NEW_LINE maxVal = max ( maxVal , x + y + int ( z ) ) NEW_LINE DEDENT DEDENT DEDENT assert maxfactorial ( n ) == maxVal NEW_LINE DEDENT
def _main ( a ) : NEW_LINE INDENT """ STRNEWLINE ▁ Main ▁ function ▁ to ▁ sort ▁ a ▁ list ▁ of ▁ integers . STRNEWLINE ▁ """ NEW_LINE for i in range ( len ( a ) - 1 ) : NEW_LINE INDENT for j in range ( len ( a ) - 1 , i , - 1 ) : NEW_LINE INDENT if a [ j ] > a [ j - 1 ] : NEW_LINE INDENT t = a [ j ] NEW_LINE a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j - 1 ] NEW_LINE a [ j - 1 ] , a [ j - 1 ] = t NEW_LINE DEDENT DEDENT DEDENT def print_hill ( a ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE DEDENT DEDENT hills = [ ] NEW_LINE inp = open ( ' / proc / cpuinfo ' , ' r ' ) NEW_LINE bre = re . compile ( ' ^ ( \d + ) : ▁ ( \d + ) : ▁ ( \d + ) $ ' ) NEW_LINE n = None NEW_LINE for line in inp : NEW_LINE INDENT num = line . split ( ) NEW_LINE n = int ( num [ 0 ] ) NEW_LINE hills . append ( n ) NEW_LINE DEDENT sort ( hills ) NEW_LINE print_hill ( hills ) NEW_LINE DEDENT
def get_number_of_possible_pallindrome ( str , n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE size = len ( sys . argv ) NEW_LINE arr = [ ] NEW_LINE for i in range ( 1 , size + 1 ) : NEW_LINE INDENT arr . append ( sys . argv [ i ] ) NEW_LINE DEDENT print ( split ( arr , 1 , size ) ) NEW_LINE DEDENT
def pygfg ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT
def pycf1672b ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . stdin . readline ( ) NEW_LINE while t : NEW_LINE INDENT s = t . rstrip ( ) NEW_LINE a , b = 0 , 0 NEW_LINE f = True NEW_LINE for ch in s : NEW_LINE INDENT if ch == ' A ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE if a < b : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE f = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if f : NEW_LINE INDENT if b != 0 and s [ - 1 ] == ' B ' : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def get_first_substring ( s ) : NEW_LINE INDENT n , c = len ( s ) , 0 NEW_LINE s1 , s2 = ' ' , ' ' NEW_LINE mpp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] in [ ' ▁ ' , ' # ' ] : NEW_LINE INDENT s1 = s [ c : i ] NEW_LINE mpp [ s1 ] = 1 NEW_LINE c = i + 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' ▁ ' : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if s [ i ] == ' ▁ ' : NEW_LINE INDENT break NEW_LINE DEDENT s1 = s [ i : j - i + 1 ] NEW_LINE s2 = s1 NEW_LINE s1 = reverse ( s1 ) NEW_LINE if mpp . has_key ( s1 ) : NEW_LINE INDENT return s2 NEW_LINE DEDENT DEDENT DEDENT return ' - 1' NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 44522255 NEW_LINE assert count_consecutive ( n ) == 0 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ degree ▁ of ▁ the ▁ first ▁ degree . """ NEW_LINE interiorAngle , exteriorAngle = ( n - 2 ) * 180 / n , 360 / n NEW_LINE assert interiorAngle == - 2 * n NEW_LINE assert exteriorAngle == - n NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT smallest = int ( math . ceil ( math . sqrt ( math . pow ( 10 , n - 1 ) ) ) ) NEW_LINE print ( smallest , end = ' ▁ ' ) NEW_LINE largest = int ( math . ceil ( math . sqrt ( math . pow ( 10 , n ) ) ) - 1 ) NEW_LINE print ( largest , end = ' ▁ ' ) NEW_LINE DEDENT
def test_A ( ) : NEW_LINE INDENT raises ( ValueError , lambda : solve ( [ 1 , 2 , 3 ] ) ) NEW_LINE f = symbols ( ' f ' , integer = True ) NEW_LINE def solve ( ) : NEW_LINE INDENT f = symbols ( ' f ' , integer = True ) NEW_LINE t = symbols ( ' t ' , integer = True ) NEW_LINE while t : NEW_LINE INDENT n = symbols ( ' n ' , integer = True ) NEW_LINE message = [ x for x in solve ( f ) if x . is_integer ] NEW_LINE assert message == [ ' ( n , ▁ t ) ' ] NEW_LINE DEDENT DEDENT def identify_message ( message , n ) : NEW_LINE INDENT del message [ : n ] NEW_LINE left_symbols = 0 NEW_LINE for character in message : NEW_LINE INDENT if character == ' ) ' : NEW_LINE INDENT left_symbols += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT assert left_symbols > ( n - left_symbols ) NEW_LINE DEDENT DEDENT
def test_akarshanand2810 ( ) : NEW_LINE INDENT solve ( ) NEW_LINE sc = SparkContext ( " local [ 2 ] " ) NEW_LINE out = sc . parallelize ( [ 1 , 2 , 3 ] ) . toDF ( ) NEW_LINE n = sc . sc . parallelize ( range ( 3 ) ) . count ( ) NEW_LINE arr = sc . parallelize ( range ( 3 ) ) . toArray ( ) NEW_LINE cnt = 0 NEW_LINE idx = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE idx . append ( i ) NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE for index in idx : NEW_LINE INDENT if arr [ index ] == ' a ' : NEW_LINE INDENT arr [ index ] = ' b ' NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = ' a ' NEW_LINE DEDENT DEDENT out . append ( StructType ( [ StructField ( " a " , IntegerType ( ) , ArrayType ( IntegerType ( ) , IntegerType ( ) ) , StructField ( " b " , IntegerType ( ) , ArrayType ( IntegerType ( ) , IntegerType ( ) ) , StructField ( " c " , IntegerType ( ) , IntegerType ( ) ) , StructField ( " d " , IntegerType ( ) , IntegerType ( ) ) ] ) ) NEW_LINE out . append ( StructType ( [ StructField ( " a " , IntegerType ( ) , ArrayType ( IntegerType ( ) , IntegerType ( ) ) , StructField ( " b " , IntegerType ( ) , IntegerType ( ) ) , StructField ( " c " , IntegerType ( ) , IntegerType ( ) ) , StructField ( " d " , IntegerType ( ) , IntegerType ( ) ) ] ) ) NEW_LINE DEDENT
def GFG ( a , n ) : NEW_LINE INDENT discard_count = 0 NEW_LINE power ( a , n ) NEW_LINE if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n / 2 ) NEW_LINE p = p * p NEW_LINE if n % 2 == 1 : NEW_LINE INDENT p = p * a NEW_LINE DEDENT return p NEW_LINE DEDENT def solve ( i , n , sum , k , a , prefix ) : NEW_LINE INDENT if sum > k : NEW_LINE INDENT discard_count += power ( 2 , n - i ) NEW_LINE return NEW_LINE DEDENT if i == n : NEW_LINE INDENT return NEW_LINE DEDENT rem = prefix [ - 1 ] - prefix [ i ] NEW_LINE if sum + a [ i ] + rem > k : NEW_LINE INDENT solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) NEW_LINE DEDENT if sum + rem > k : NEW_LINE INDENT solve ( i + 1 , n , sum , k , a , prefix ) NEW_LINE DEDENT DEDENT def count_subsequences ( arr , n , K ) : NEW_LINE INDENT sum = 0.0 NEW_LINE k = float ( math . log ( K , 2 ) ) NEW_LINE prefix = [ ] NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( float ( math . log ( arr [ i ] , 2 ) ) ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT prefix . append ( a [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix . append ( prefix [ - 1 ] + a [ i ] ) NEW_LINE DEDENT total = power ( 2 , n ) - 1 NEW_LINE if sum <= k : NEW_LINE INDENT return int ( total ) NEW_LINE DEDENT solve ( 0 , n , 0.0 , k , a , prefix ) NEW_LINE return int ( total - discard_count ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 4 , 8 , 7 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( count_subsequences ( arr , n , k ) ) NEW_LINE DEDENT
def GFG ( data ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT data = data NEW_LINE left = None NEW_LINE right = None NEW_LINE DEDENT def newNode ( data ) : NEW_LINE INDENT node = Node ( ) NEW_LINE node . data = data NEW_LINE node . left = None NEW_LINE node . right = None NEW_LINE return node NEW_LINE DEDENT def inorder ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( root . left ) NEW_LINE print ( root . data , end = ' ▁ ' ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT def isIdentical ( root1 , root2 ) : NEW_LINE INDENT if root1 is None and root2 is None : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif root1 is not None and root2 is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif root1 is None and root2 is not None : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if root1 . data == root2 . data and isIdentical ( root1 . left , root2 . left ) == 1 and isIdentical ( root1 . right , root2 . right ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT root1 = newNode ( 5 ) NEW_LINE root2 = newNode ( 5 ) NEW_LINE root1 . left = newNode ( 3 ) NEW_LINE root1 . right = newNode ( 8 ) NEW_LINE root1 . left . left = newNode ( 2 ) NEW_LINE root1 . left . right = newNode ( 4 ) NEW_LINE root2 . left = newNode ( 3 ) NEW_LINE root2 . right = newNode ( 8 ) NEW_LINE root2 . left . left = newNode ( 2 ) NEW_LINE root2 . left . right = newNode ( 4 ) NEW_LINE if isIdentical ( root1 , root2 ) == 1 : NEW_LINE INDENT print ( " Both ▁ BSTs ▁ are ▁ identical " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " BSTs ▁ are ▁ not ▁ identical " ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE arr = sys . argv [ 1 : ] NEW_LINE left_j = [ ] NEW_LINE right_i = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT left_j . append ( left_j [ i - 1 ] ) NEW_LINE if arr [ i - 1 ] == ' J ' : NEW_LINE INDENT left_j [ i ] += 1 NEW_LINE DEDENT right_i . append ( right_i [ n - i + 1 ] ) NEW_LINE if arr [ n - i ] == ' I ' : NEW_LINE INDENT right_i [ n - i + 1 ] += 1 NEW_LINE DEDENT DEDENT sum_i = 0 NEW_LINE sum_j = 0 NEW_LINE max_o = 0 NEW_LINE total = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT tmp = 0 NEW_LINE if arr [ i - 1 ] == ' O ' : NEW_LINE INDENT tmp = left_j [ i - 1 ] * right_i [ i + 1 ] NEW_LINE total += tmp NEW_LINE sum_j += ( left_j [ i - 1 ] + 1 ) * right_i [ i + 1 ] NEW_LINE sum_i += left_j [ i - 1 ] * ( right_i [ i + 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = left_j [ i - 1 ] * right_i [ i ] NEW_LINE DEDENT max_o = max ( max_o , tmp ) NEW_LINE DEDENT total += max_o NEW_LINE total = max ( total , sum_j ) NEW_LINE total = max ( total , sum_i ) NEW_LINE print ( total ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' d ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT if len ( args ) != 2 : NEW_LINE INDENT print ( " Usage : ▁ Dise ▁ < surface > ▁ < order > " ) NEW_LINE return NEW_LINE DEDENT if args [ 0 ] == ' - d ' : NEW_LINE INDENT dice1 = Dise ( ) NEW_LINE dice1 . SetSurface ( surface = args [ 1 ] ) NEW_LINE dice1 . SetDice ( 1 , 2 , 3 ) NEW_LINE dice1 . RollDice ( order = args [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dise = Dise ( ) NEW_LINE surface = [ ] NEW_LINE top , bottom , right , left , front , back = dice1 . SetSurface ( ) NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT surface . append ( int ( i ) ) NEW_LINE DEDENT DEDENT def SetDice ( top , front , right ) : NEW_LINE INDENT top = top - 1 NEW_LINE front = front - 1 NEW_LINE right = right - 1 NEW_LINE bottom = 5 - ( top - 1 ) NEW_LINE back = 5 - ( front - 1 ) NEW_LINE left = 5 - ( right - 1 ) NEW_LINE DEDENT def RollDice ( RollString ) : NEW_LINE INDENT for i in range ( len ( RollString ) ) : NEW_LINE INDENT if RollString [ i ] == ' W ' : NEW_LINE INDENT bottom = Left NEW_LINE left = Top NEW_LINE top = 5 - Bottom NEW_LINE right = 5 - Left NEW_LINE DEDENT elif RollString [ i ] == ' S ' : NEW_LINE INDENT bottom = Front NEW_LINE front = Top NEW_LINE top = 5 - Bottom NEW_LINE Back = 5 - Front NEW_LINE DEDENT elif RollString [ i ] == ' E ' : NEW_LINE INDENT bottom = Right NEW_LINE right = Top NEW_LINE top = 5 - Bottom NEW_LINE left = 5 - Right NEW_LINE DEDENT else : NEW_LINE INDENT bottom = Back NEW_LINE Back = Top NEW_LINE Top = 5 - Bottom NEW_LINE Front = 5 - Back NEW_LINE DEDENT DEDENT print ( surface [ top ] ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT class node : NEW_LINE INDENT data = 0 NEW_LINE next = None NEW_LINE DEDENT def add ( data ) : NEW_LINE INDENT newnode = node ( ) NEW_LINE newnode . data = data NEW_LINE newnode . next = None NEW_LINE return newnode NEW_LINE DEDENT def print_arr ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def findlength ( head ) : NEW_LINE INDENT curr = head NEW_LINE cnt = 0 NEW_LINE while curr : NEW_LINE INDENT cnt += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT return cnt NEW_LINE DEDENT def convert_arr ( head ) : NEW_LINE INDENT len = findlength ( head ) NEW_LINE arr = [ 0 ] * len ( head ) NEW_LINE index = 0 NEW_LINE curr = head NEW_LINE while curr : NEW_LINE INDENT arr [ index ] = curr . data NEW_LINE curr = curr . next NEW_LINE DEDENT print_arr ( arr , len ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT head = node ( ) NEW_LINE head = add ( 1 ) NEW_LINE head . next = add ( 2 ) NEW_LINE head . next . next = add ( 3 ) NEW_LINE head . next . next . next = add ( 4 ) NEW_LINE head . next . next . next . next = add ( 5 ) NEW_LINE convert_arr ( head ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE for i in range ( 0 , 9 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT
def pythree_class_29 ( arg ) : NEW_LINE INDENT import sys NEW_LINE t = sys . getrecursionlimit ( ) NEW_LINE while t : NEW_LINE INDENT n = len ( t ) NEW_LINE st = set ( ) NEW_LINE i , flag = 0 , 0 NEW_LINE a = [ ] NEW_LINE vis = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( t [ i ] ) NEW_LINE val = ( i + a [ i ] ) % n NEW_LINE if val < 0 : val += n NEW_LINE vis . add ( int ( val ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if vis [ i ] == 0 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def minMoves ( nums ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ minimum ▁ number ▁ of ▁ moves ▁ in ▁ the ▁ given ▁ list . STRNEWLINE ▁ """ NEW_LINE if len ( nums ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT nums = sorted ( nums ) NEW_LINE min_num = nums [ 0 ] NEW_LINE ans = 0 NEW_LINE for num in nums [ 1 : ] : NEW_LINE INDENT ans += num - min_num NEW_LINE DEDENT return ans NEW_LINE DEDENT
def pytime_compare ( a , b ) : NEW_LINE INDENT a , b = map ( int , a . split ( ' . ' ) ) NEW_LINE if a <= 0 and b >= 0 or a <= 0 and b >= 0 : NEW_LINE INDENT return ' Zero ' NEW_LINE DEDENT elif a < 0 and b < 0 : NEW_LINE INDENT return ( ( b - a + 1 ) % 2 == 0 ) NEW_LINE DEDENT elif a > 0 and b > 0 : NEW_LINE INDENT return ' Positive ' NEW_LINE DEDENT return ' Negative ' NEW_LINE DEDENT
def geeks ( n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX_CHAR = 256 NEW_LINE def maximum_chars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE first_ind = [ - 1 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT first_ind [ i ] = i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT first_ind [ str [ i ] ] = i NEW_LINE DEDENT return res NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT first_ind [ str [ 0 ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind [ 0 ] - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT
def test_kefa_and_company ( ) : NEW_LINE INDENT f = open ( ' kefa . txt ' , ' r ' ) NEW_LINE lines = f . readlines ( ) NEW_LINE n = int ( lines [ 0 ] ) NEW_LINE k = int ( lines [ 1 ] ) NEW_LINE pf = [ ] NEW_LINE list = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT input = lines [ i ] . strip ( ) . split ( ) NEW_LINE money = int ( input [ 0 ] ) NEW_LINE friend = int ( input [ 1 ] ) NEW_LINE list . append ( Kefa ( money , friend ) ) NEW_LINE DEDENT list . sort ( key = KefaCmp ) NEW_LINE ans = 0 NEW_LINE s , e = 0 , 0 NEW_LINE sum = 0 NEW_LINE while e < n : NEW_LINE INDENT if list [ e ] [ ' money ' ] - list [ s ] [ ' money ' ] < k : NEW_LINE INDENT sum += list [ e ] [ ' friend ' ] NEW_LINE e += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= list [ s ] [ ' friend ' ] NEW_LINE s += 1 NEW_LINE DEDENT ans = max ( ans , sum ) NEW_LINE DEDENT assert ans == 0 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = 5 NEW_LINE assert findArea ( a ) == 5 NEW_LINE assert findVolume ( a ) == 5 NEW_LINE DEDENT
def p205 ( ) : NEW_LINE INDENT print ( np . sum ( np . array ( [ 0 , 1 , 1 , 1 , 1 ] ) ) ) NEW_LINE PYRAMIDAL_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE CUBIC_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE nine_pyramidal_pdf = [ 1 ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT nine_pyramidal_pdf = convolve ( nine_pyramidal_pdf , PYRAMIDAL_DIE_PDF ) NEW_LINE DEDENT sixc_pyramidal_pdf = [ 1 ] NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT sixc_pyramidal_pdf = convolve ( sixc_pyramidal_pdf , CUBIC_DIE_PDF ) NEW_LINE DEDENT numer = 0 NEW_LINE for i in range ( len ( nine_pyramidal_pdf ) ) : NEW_LINE INDENT numer += float ( nine_pyramidal_pdf [ i ] ) * sum ( sixc_pyramidal_pdf [ i ] ) NEW_LINE DEDENT denom = float ( sum ( nine_pyramidal_pdf [ i ] ) * sum ( sixc_pyramidal_pdf [ i ] ) ) NEW_LINE return ' % .7f ' % float ( numer / denom ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT N = 6 NEW_LINE Even = N // 2 NEW_LINE Odd = N - Even NEW_LINE assert Even * Odd == 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT N , M , s = symbols ( ' N ▁ M ▁ s ' , integer = True , positive = True ) NEW_LINE assert solve ( M * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N * N
def test_GFG ( ) : NEW_LINE INDENT if not isinstance ( a , int ) : NEW_LINE INDENT return NEW_LINE DEDENT assert gcd ( b % a , a ) == gcd ( a , b ) NEW_LINE assert lcm ( a , b ) == ( a * b ) / gcd ( a , b ) NEW_LINE assert count_pairs ( arr , n ) == 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT assert ans == 0 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT input = sys . stdin NEW_LINE list = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT _l = input . readline ( ) NEW_LINE list . append ( _l ) NEW_LINE sum += _l NEW_LINE DEDENT i , j , k = 0 , 0 , 0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT for j in range ( i + 1 , 5 ) : NEW_LINE INDENT for k in range ( j + 1 , 6 ) : NEW_LINE INDENT sum1 = list [ i ] + list [ j ] + list [ k ] NEW_LINE if sum1 == sum - sum1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT
def _GFG ( number ) : NEW_LINE INDENT counter = 0 NEW_LINE while number > 0 : NEW_LINE INDENT if number % 2 == 1 : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT number = number / 2 NEW_LINE DEDENT return counter NEW_LINE DEDENT
def test_CF_1712_A ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE while t . is_integer : NEW_LINE INDENT n , k = t . as_coeff_Mul ( ) NEW_LINE a = [ i for i in range ( n ) ] NEW_LINE counter = 0 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if a [ i ] <= k : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT assert counter == 1 NEW_LINE DEDENT DEDENT
def test_python_application_38 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE num1 = symbols ( ' num1 ' ) NEW_LINE num2 = symbols ( ' num2 ' ) NEW_LINE counter = 0 NEW_LINE while num1 != 0 and num2 != 0 : NEW_LINE INDENT if num1 == 1 and num2 == 1 : NEW_LINE INDENT break NEW_LINE DEDENT if num1 <= num2 : NEW_LINE INDENT num1 += 1 NEW_LINE num2 -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT num1 -= 2 NEW_LINE num2 += 1 NEW_LINE DEDENT counter += 1 NEW_LINE DEDENT assert counter == 1 NEW_LINE DEDENT
def py2int ( arr , queries ) : NEW_LINE INDENT """ STRNEWLINE ▁ Convert ▁ a ▁ list ▁ of ▁ integers ▁ to ▁ a ▁ list ▁ of ▁ integers . STRNEWLINE STRNEWLINE ▁ > > > ▁ py2int ( [1,2,3 ] , ▁ [ 4,5,6 ] ) STRNEWLINE ▁ [ 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 , ▁ 6 ] STRNEWLINE ▁ """ NEW_LINE res , q = [ ] , [ ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT arr [ i ] ^= arr [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( queries ) ) : NEW_LINE INDENT q = queries [ i ] NEW_LINE res . append ( q [ 0 ] > 0 and arr [ q [ 0 ] - 1 ] ^ arr [ q [ 1 ] ] or arr [ q [ 1 ] ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def GFG ( str , k ) : NEW_LINE INDENT expand = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while i < len ( str ) and str [ i ] >= ' a ' and str [ i ] <= ' z ' : NEW_LINE INDENT temp += str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while i < len ( str ) and str [ i ] >= '1' and str [ i ] <= '9' : NEW_LINE INDENT freq = freq * 10 + str [ i ] - '0' NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT DEDENT if freq == 0 : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if ( a + b + c ) % 2 != 0 or a + b < c : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) / 2 NEW_LINE sign = n + 1 % 2 if n % 2 else 1 NEW_LINE result_sum = sign * abs_sum NEW_LINE return result_sum NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = [ - 6 , - 3 , - 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Before ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT sortSquares ( arr ) NEW_LINE print ( " " ) NEW_LINE print ( " After ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def test_CP19 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE n , t , k , pos = symbols ( ' n ▁ t ▁ k ' , integer = True , positive = True ) NEW_LINE n = int ( n ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT arr . append ( x [ i ] ) NEW_LINE DEDENT while pos < t : NEW_LINE INDENT k = pos + arr [ - 1 ] NEW_LINE pos = k NEW_LINE DEDENT if pos == t : NEW_LINE INDENT assert ' YES ' in arr NEW_LINE DEDENT else : NEW_LINE INDENT assert ' NO ' in arr NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT f = sys . stdin NEW_LINE N = int ( f . readline ( ) ) NEW_LINE a = [ ] NEW_LINE f . readline ( ) NEW_LINE for line in f : NEW_LINE INDENT a . append ( int ( line . strip ( ) ) ) NEW_LINE DEDENT indeg = [ ] NEW_LINE used = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT indeg [ ( i + a [ i ] ) % N ] += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT j = i NEW_LINE while not used and indeg [ j ] == 0 : NEW_LINE INDENT used . append ( True ) NEW_LINE j = ( j + a [ j ] ) % N NEW_LINE indeg [ j ] -= 1 NEW_LINE DEDENT DEDENT print ( sum ( indeg ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if isinstance ( num , int ) : NEW_LINE INDENT c = ( - 2 * num ) NEW_LINE b , a = 1 , 1 NEW_LINE d = ( b ** 2 ) - ( 4 * a ** 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT d = ( - 2 * num ) - ( 2 * a ** 2 ) NEW_LINE DEDENT root1 = ( - b + float ( ' inf ' ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - float ( ' inf ' ) ) / ( 2 * a ) NEW_LINE if root1 and math . floor ( root1 ) == root1 : NEW_LINE INDENT return True NEW_LINE DEDENT if root2 and math . floor ( root2 ) == root2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT k , d = 4 , 4 NEW_LINE print ( ' % d ' % k ) NEW_LINE if d == 0 and k != 1 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d ) NEW_LINE k -= 1 NEW_LINE while k -- > 0 : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT N = 3 NEW_LINE rotate_matrix ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( mat ( i , j ) , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE p = sys . argv [ 1 ] NEW_LINE print ( p / 500 * 500 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ multiplication ▁ of ▁ the ▁ polynomials ▁ of ▁ degree ▁ 3 . """ NEW_LINE n = 1 NEW_LINE while n != 0 : NEW_LINE INDENT n = n * ( n % 10 ) NEW_LINE n = n / 10 NEW_LINE DEDENT assert n == 4513 NEW_LINE DEDENT
def pystones ( loops = LOOPS ) : NEW_LINE INDENT import pystones NEW_LINE def pystones ( loops = LOOPS ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT slot = pystones ( loops , pystones ) NEW_LINE if slot . pystones ( loops ) < 0 : NEW_LINE INDENT break NEW_LINE DEDENT time . sleep ( 0.001 ) NEW_LINE DEDENT return slot NEW_LINE DEDENT class Slot ( pystones ) : NEW_LINE INDENT def pystones ( loops = LOOPS ) : NEW_LINE INDENT b , r , g , c , s , t = pystones ( loops , pystones ) NEW_LINE return ( 100 + slot . _benefit - slot . _lost ) / ( b - g - c ) NEW_LINE DEDENT def pystones ( loops = LOOPS ) : NEW_LINE INDENT b , r , g , c , s , t = pystones ( loops , pystones ) NEW_LINE return ( 100 + slot . _greenwall - slot . _lost ) / ( b - c ) NEW_LINE DEDENT def pystones ( loops = LOOPS ) : NEW_LINE INDENT r , g , b , s , t = pystones ( loops , pystones ) NEW_LINE return ( 100 + slot . _atooine - slot . _lost ) / ( b - c ) NEW_LINE DEDENT def pystones ( loops = LOOPS ) : NEW_LINE INDENT r , g , b , s , t = pystones ( loops , pystones ) NEW_LINE return ( 100 + slot . _greenwall - slot . _lost ) / ( b - c ) NEW_LINE DEDENT def pystones ( loops = LOOPS ) : NEW_LINE INDENT r , g , b , s , t = pystones ( loops , pystones ) NEW_LINE return ( 100 + slot . _atooine - slot . _lost ) / ( b - c ) NEW_LINE DEDENT DEDENT return Slot ( ) NEW_LINE DEDENT
def colored ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import getopt NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import sys NEW_LINE import os . path NEW_LINE import sys NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE import sys NEW_LINE
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ length ▁ of ▁ the ▁ GFG . """ NEW_LINE PI = 3.14159265 NEW_LINE assert ( ( 2 * PI * r ) + 6 * r ) == PI NEW_LINE DEDENT
def GFG ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num / 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT
def add_strings ( num1 , num2 ) : NEW_LINE INDENT result = [ ] NEW_LINE carry = 0 NEW_LINE for i , j in enumerate ( num1 ) : NEW_LINE INDENT x = i if i < 0 else num1 [ i ] - '0' NEW_LINE y = j if j < 0 else num2 [ j ] - '0' NEW_LINE result . append ( ( x + y + carry ) % 10 ) NEW_LINE carry = ( x + y + carry ) / 10 NEW_LINE DEDENT return result . reverse ( ) . encode ( ' utf - 8' ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , n * i <= n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if i * i != n : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT DEDENT if sum == n and n != 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT for x in range ( 2 , math . sqrt ( n ) + 1 ) : NEW_LINE INDENT p = x NEW_LINE while p <= n : NEW_LINE INDENT p = p * x NEW_LINE if p == n : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT for x in range ( 2 , math . sqrt ( n ) ) : NEW_LINE INDENT y = 2 NEW_LINE p = math . pow ( x , y ) NEW_LINE while p <= n and p > 0 : NEW_LINE INDENT if p == n : NEW_LINE INDENT return True NEW_LINE DEDENT y += 1 NEW_LINE p = math . pow ( x , y ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE class Solution ( object ) : NEW_LINE INDENT def __gcd ( self , a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return __gcd ( b , a % b ) NEW_LINE DEDENT def find_two_numbers ( self , sum , gcd ) : NEW_LINE INDENT if __gcd ( gcd , sum - gcd ) == gcd and sum != gcd : NEW_LINE INDENT print ( " a ▁ = ▁ % d , ▁ b ▁ = ▁ % d " % ( min ( gcd , sum - gcd ) , int ( sum - min ( gcd , sum - gcd ) ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT sum = 8 NEW_LINE gcd = 2 NEW_LINE find_two_numbers ( sum , gcd ) NEW_LINE DEDENT
def robot_cleaner ( m , n , rb , cb , rd , cd ) : NEW_LINE INDENT t = 0 NEW_LINE dr = 1 NEW_LINE dc = 1 NEW_LINE while True : NEW_LINE INDENT if rb == rd or cb == cd : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE if ( rb + dr ) <= 0 or ( rb + dr > m ) : NEW_LINE INDENT dr *= - 1 NEW_LINE DEDENT if ( cb + dc ) <= 0 or ( cb + dc > n ) : NEW_LINE INDENT dc *= - 1 NEW_LINE DEDENT rb += dr NEW_LINE cb += dc NEW_LINE DEDENT DEDENT
def pythontag_in_parallel ( ) : NEW_LINE INDENT import sys NEW_LINE n = int ( sys . argv [ 1 ] ) NEW_LINE a = int ( sys . argv [ 2 ] ) NEW_LINE b = int ( sys . argv [ 3 ] ) NEW_LINE c = int ( sys . argv [ 4 ] ) NEW_LINE d = int ( sys . argv [ 5 ] ) NEW_LINE ans1 , ans2 = 100000 , 1000000 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if a * i >= n : NEW_LINE INDENT ans1 = i * b NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if c * i >= n : NEW_LINE INDENT ans2 = i * d NEW_LINE break NEW_LINE DEDENT DEDENT assert min ( ans2 , ans1 ) == min ( ans1 , ans2 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ pairs ▁ of ▁ bits ▁ in ▁ the ▁ GFG . """ NEW_LINE n = 0 NEW_LINE while n : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def test_gf_center_hexadecagonal_num ( ) : NEW_LINE INDENT assert gf_center_hexadecagonal_num ( [ ] , 11 , ZZ ) == 8 NEW_LINE assert gf_center_hexadecagonal_num ( [ 1 ] , 11 , ZZ ) == 8 NEW_LINE assert gf_center_hexadecagonal_num ( [ 1 , 2 ] , 11 , ZZ ) == 8 NEW_LINE assert gf_center_hexadecagonal_num ( [ 1 , 2 , 3 ] , 11 , ZZ ) == 8 NEW_LINE assert gf_center_hexadecagonal_num ( [ 1 , 2 , 3 ] , 11 , ZZ ) == 8 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE Q , H , S , D , N = sys . argv [ 1 : ] NEW_LINE one_price = min ( min ( Q * 4 , H * 2 ) , S ) NEW_LINE if float ( one_price ) <= float ( D / 2 ) : NEW_LINE INDENT print ( N * one_price ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( N / 2 ) * D + ( N % 2 ) * one_price ) NEW_LINE DEDENT DEDENT
def GFG ( L , R , K ) : NEW_LINE INDENT if K == 9 : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers // 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if rem1 == K : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT a , b = line . split ( ) NEW_LINE c , d = a . split ( ) NEW_LINE e , f = b . split ( ) NEW_LINE y = min ( c , b ) NEW_LINE x = a NEW_LINE if y + x <= d : NEW_LINE INDENT print ( y * f + x * e ) NEW_LINE DEDENT elif f >= e : NEW_LINE INDENT print ( min ( y , d ) * f + ( d - min ( y , d ) ) * e ) NEW_LINE DEDENT elif e >= f : NEW_LINE INDENT print ( min ( x , d ) * e + ( d - min ( x , d ) ) * f ) NEW_LINE DEDENT DEDENT DEDENT
def get_GFG ( A ) : NEW_LINE INDENT ans = 2 NEW_LINE n = len ( A ) NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT llap = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT llap . append ( 2 ) NEW_LINE DEDENT A . sort ( ) NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while i >= 0 and k < n : NEW_LINE INDENT if A [ i ] + A [ k ] == 2 * A [ j ] : NEW_LINE INDENT llap [ j ] = max ( llap [ k ] + 1 , llap [ j ] ) NEW_LINE ans = max ( ans , llap [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT elif A [ i ] + A [ k ] < 2 * A [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT max_freq = - 1 NEW_LINE freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT a0 = arr [ i ] - ( i ) * d NEW_LINE if freq . has_key ( a0 ) : NEW_LINE INDENT freq [ a0 ] = freq [ a0 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a0 ] = 1 NEW_LINE DEDENT if freq [ a0 ] > max_freq : NEW_LINE INDENT max_freq = freq [ a0 ] NEW_LINE DEDENT DEDENT return ( n - max_freq ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global verbose , verbose , ansprice NEW_LINE n = len ( sys . argv ) NEW_LINE vec = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT vec . append ( sys . argv [ i ] ) NEW_LINE DEDENT ans = 500 NEW_LINE ansprice = 20000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT fl = 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if vec [ i ] [ 0 ] < vec [ j ] [ 0 ] and vec [ i ] [ 1 ] < vec [ j ] [ 1 ] and vec [ i ] [ 2 ] < vec [ j ] [ 2 ] : fl = 0 NEW_LINE DEDENT if fl == 1 : NEW_LINE INDENT if vec [ i ] [ 3 ] < ansprice : NEW_LINE INDENT ansprice = vec [ i ] [ 3 ] NEW_LINE ans = i + 1 NEW_LINE DEDENT DEDENT DEDENT sys . stdout . write ( ans ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = np . array ( [ 1 , 5 ] ) NEW_LINE b = np . array ( [ 1 , 1 , 2 ] ) NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if a [ i ] + y < b [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT if b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def GFG ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT
def test_B ( ) : NEW_LINE INDENT f = QQ . old_poly_ring ( x , y ) NEW_LINE g = QQ . old_poly_ring ( x , y ) NEW_LINE n = f . numer NEW_LINE s = f . denom NEW_LINE a = [ i for i in range ( n ) if i != 0 ] NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . numer ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . numer ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE g . add ( f . denom ( s ) ) NEW_LINE
def get_gfg ( s ) : NEW_LINE INDENT cnt , maxi = 1 , 1 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] != s [ i - 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) NEW_LINE return maxi NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT main = unittest . main ( ) NEW_LINE main . setUp ( ) NEW_LINE k = os . urandom ( 50 ) NEW_LINE n = 50 NEW_LINE sum = k // n NEW_LINE amari = k % n NEW_LINE a = [ i + sum for i in range ( n ) ] NEW_LINE for i in range ( amari ) : NEW_LINE INDENT a . append ( sum ) NEW_LINE DEDENT print ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] + ( i == n - 1 ) ) NEW_LINE DEDENT main . tearDown ( ) NEW_LINE DEDENT
def GFG ( digits ) : NEW_LINE INDENT first = int ( ( pow ( 10 , digits ) - 1 ) / 9 ) NEW_LINE second = int ( ( pow ( 9 , digits ) - 1 ) / 8 ) NEW_LINE return 9 * ( first - second ) NEW_LINE def toInt ( char ) : NEW_LINE INDENT return int ( char ) - 48 NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT k = len ( num ) NEW_LINE total = zeroUpto ( k - 1 ) NEW_LINE nonZero = 0 NEW_LINE for i in num : NEW_LINE INDENT if i == '0' : NEW_LINE INDENT nonZero -= 1 NEW_LINE break NEW_LINE DEDENT nonZero += ( toInt ( i ) - 1 ) * ( pow ( 9 , k - 1 - i ) ) NEW_LINE DEDENT no , remaining , calculatedUpto = 0 , 0 , 0 , 0 NEW_LINE for i in num : NEW_LINE INDENT no = no * 10 + ( toInt ( i ) ) NEW_LINE if i != 0 : NEW_LINE INDENT calculatedUpto = calculatedUpto * 10 + 9 NEW_LINE DEDENT DEDENT remaining = no - calculatedUpto NEW_LINE ans = zeroUpto ( k - 1 ) + ( remaining - nonZero - 1 ) NEW_LINE return ans NEW_LINE DEDENT def countOne ( num ) : NEW_LINE INDENT k = len ( num ) NEW_LINE total = zeroUpto ( k ) NEW_LINE nonZero = 0 NEW_LINE for i in num : NEW_LINE INDENT if i == '0' : NEW_LINE INDENT nonZero -= 1 NEW_LINE break NEW_LINE DEDENT nonZero += ( toInt ( i ) - 1 ) * ( pow ( 9 , k - 1 - i ) ) NEW_LINE DEDENT nonZero = ( nonZero - nonZero ) NEW_LINE ans = zeroUpto ( k - 1 ) + ( remaining - nonZero - 1 ) NEW_LINE return ans NEW_LINE DEDENT def countTwo ( num ) : NEW_LINE INDENT k = len ( num ) NEW_LINE total = zeroUpto ( k ) NEW_LINE nonZero = 0 NEW_LINE for i in num : NEW_LINE INDENT if i == '0' : NEW_LINE INDENT nonZero -= 1 NEW_LINE break NEW_LINE DEDENT nonZero += ( toInt ( i ) - 1 ) * ( pow ( 9 , k - 1 - i ) ) NEW_LINE DEDENT nonZero = ( nonZero - nonZero ) NEW_LINE ans = zeroUpto ( k ) + ( total - nonZero - 1 ) * ( pow ( 9 , k - 1 - i ) ) NEW_LINE return ans NEW_LINE DEDENT def countThree ( num ) : NEW_LINE INDENT nonZero = 0 NEW_LINE for i in num : NEW_LINE INDENT nonZero += 1 NEW_LINE DEDENT return nonZero NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = float ( a * sqrt ( 2 ) ) / 3 NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = float ( 3.14 * pow ( r , 2 ) * h ) NEW_LINE assert V == [ - 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1
def genprimelist ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n * i <= n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT assert gf_degree ( [ ] ) == 0 NEW_LINE assert gf_degree ( [ 1 ] ) == 1 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert
def GFG ( p , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE a = sys . stdin . readline ( ) . rstrip ( ' \n ' ) NEW_LINE b = sys . stdin . readline ( ) . rstrip ( ' \n ' ) NEW_LINE if a > b : NEW_LINE INDENT sys . stdout . write ( ' > ' ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT sys . stdout . write ( ' = ' ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( ' < ' ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT from sympy . polys . distributedmodules import GFG NEW_LINE volume = ( l * b * h ) / 2 NEW_LINE assert volume == volume NEW_LINE DEDENT
def test_practice462b ( ) : NEW_LINE INDENT f = open ( ' / home / jekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekek
def p045 ( ) : NEW_LINE INDENT print ( [ ' p045 . py ' , ' p045 . h ' , ' p045 . c ' , ' p045 . d ' , ' p045 . e ' , ' p045 . f ' , ' p045 . g ' , ' p045 . h ' , ' p045 . i ' , ' p045 . j ' , ' p045 . k ' , ' p045 . l ' , ' p045 . m ' , ' p045 . n ' , ' p045 . o ' , ' p045 . p ' , ' p045 . q ' , ' p045 . r ' , ' p045 . s ' , ' p045 . t ' , ' p045 . u ' , ' p045 . v ' , ' p045 . w ' , ' p045 . x ' , ' p045 . y ' , ' p045 . z ' , ' p045 . w ' , ' p045 . x ' , ' p045 . y ' , ' p045 . z ' , ' p045 . w ' , ' p045 . x ' , ' p045 . y ' , ' p045 . z ' , ' p045 . w ' , ' p045 . x ' , ' p045 . y ' , ' p045 . z ' , ' p045 . w ' , ' p045 . x ' , ' p045 . y ' , ' p045 . z ' , ' p045 . w ' , ' p045 . x ' , ' p045 . y ' , ' p045 . z ' , ' p045 . w ' , ' p045 . x ' , ' p045 . y ' , ' p045 . z ' , ' p045 . w ' , ' p045 . x ' , ' p045 . y ' , ' p045 . z ' , ' p045 . w ' , ' p045 . x ' , ' p045 . y ' , ' p045 . z ' , ' p045 . w ' , ] ) NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT if N < 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr = [ False ] * ( N + 1 ) NEW_LINE prod , res = 1 , 0 NEW_LINE for p in range ( 2 , N * p + 1 ) : NEW_LINE INDENT if arr [ p ] == False : NEW_LINE INDENT for i in range ( p * 2 , N , p ) : NEW_LINE INDENT arr [ i ] = True NEW_LINE DEDENT prod *= p NEW_LINE if prod > N : NEW_LINE INDENT return res NEW_LINE DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ greatest ▁ factorial ▁ minimization ▁ of ▁ a ▁ polynomial . """ NEW_LINE m = symbols ( ' m ' , integer = True , positive = True ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT m = max ( a [ i ] , m ) NEW_LINE DEDENT assert checkdivisors ( m ) == 1 NEW_LINE X = max_element ( a ) NEW_LINE b = [ ] NEW_LINE for i in range ( 1 , X * X ) : NEW_LINE INDENT if X % i == 0 : NEW_LINE INDENT b . append ( i ) NEW_LINE if X / i != i : NEW_LINE INDENT b . append ( X / i ) NEW_LINE DEDENT DEDENT DEDENT if len ( b ) != n : NEW_LINE INDENT return False NEW_LINE DEDENT a = sorted ( a ) NEW_LINE b = sorted ( b ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] != a [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def test ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE subarray ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j ) : NEW_LINE INDENT print ( arr [ k ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT input = sys . stdin NEW_LINE tc = int ( input . readline ( ) ) NEW_LINE work : NEW_LINE INDENT while tc : NEW_LINE INDENT n = input . readline ( ) NEW_LINE x = long ( n ) NEW_LINE y = long ( n ) NEW_LINE if n % 6 == 0 : NEW_LINE INDENT x = min ( x , n // 6 ) NEW_LINE y = max ( y , n // 6 ) NEW_LINE DEDENT if n % 6 == 2 and n != 2 : NEW_LINE INDENT x = min ( x , ( ( n // 6 ) - 1 ) + 2 ) NEW_LINE y = max ( y , ( ( n // 6 ) - 1 ) + 2 ) NEW_LINE DEDENT if n % 6 == 4 and n != 4 : NEW_LINE INDENT x = min ( x , n // 6 + 1 ) NEW_LINE y = max ( y , n // 6 + 1 ) NEW_LINE DEDENT if n % 4 == 0 : NEW_LINE INDENT x = min ( x , n // 4 ) NEW_LINE y = max ( y , n // 4 ) NEW_LINE DEDENT if n % 4 == 2 and n != 2 : NEW_LINE INDENT x = min ( x , ( n // 4 ) - 1 + 1 ) NEW_LINE y = max ( y , ( n // 4 ) - 1 + 1 ) NEW_LINE DEDENT if x != long ( n ) and y != long ( n ) : NEW_LINE INDENT print ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = np . array ( [ 3 , 5 , 6 , 1 ] ) NEW_LINE n = len ( arr ) NEW_LINE assert max_sum ( arr , n ) == 3 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1 , 4 , 5 ] ) NEW_LINE a = np . array ( [ 1 , 3 , 2 , 1
def test_GFG ( ) : NEW_LINE INDENT arr = np . array ( [ 53 , 28 , 143 , 5 ] ) NEW_LINE n = len ( arr ) NEW_LINE assert find_answer ( n , arr ) == 0 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE assert find_sum ( arr , n ) == 1 NEW_LINE DEDENT
def pyGFG ( root ) : NEW_LINE INDENT class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT def __reduce__ ( self ) : NEW_LINE INDENT return ( self . data , self . left , self . right ) NEW_LINE DEDENT def __mul__ ( self , rhs ) : NEW_LINE INDENT if rhs . left is None : NEW_LINE INDENT return rhs NEW_LINE DEDENT q = [ rhs ] NEW_LINE result = None NEW_LINE while not q : NEW_LINE INDENT temp = q . pop ( ) NEW_LINE q . extend ( temp ) NEW_LINE if temp . left is not None : NEW_LINE INDENT q . append ( temp . left ) NEW_LINE if temp . left . left is None and temp . left . right is None : NEW_LINE INDENT result = temp . left NEW_LINE DEDENT DEDENT if temp . right is not None : NEW_LINE INDENT q . append ( temp . right ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def __div__ ( self , other ) : NEW_LINE INDENT return self . data / other . data NEW_LINE DEDENT def __truediv__ ( self , other ) : NEW_LINE INDENT return self . data / other . data NEW_LINE DEDENT def __floordiv__ ( self , other ) : NEW_LINE INDENT return self . data / other . data NEW_LINE DEDENT def __mod__ ( self , other ) : NEW_LINE INDENT return self . data % other . data NEW_LINE DEDENT def __powered__ ( self , other ) : NEW_LINE INDENT return self . data % other . data NEW_LINE DEDENT def __mod__ ( self , other ) : NEW_LINE INDENT return self . data % other . data NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT return self . data <= other . data NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT return self . data >= other . data NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT return self . data != other . data NEW_LINE DEDENT def __hash__ ( self ) : NEW_LINE INDENT return hash ( self . data ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def pyGFG ( root ) : NEW_LINE INDENT class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT def __reduce__ ( self ) : NEW_LINE INDENT return ( self . data , self . left , self . right ) NEW_LINE DEDENT def __mul__ ( self , rhs ) : NEW_LINE INDENT if rhs . left is not None : NEW_LINE INDENT return rhs . left NEW_LINE DEDENT if rhs . right is not None : NEW_LINE INDENT return rhs . right NEW_LINE DEDENT if rhs . left . right is not None and rhs . left . right is None : NEW_LINE INDENT return rhs . left . right NEW_LINE DEDENT return None NEW_LINE DEDENT def __div__ ( self , rhs ) : NEW_LINE INDENT return rhs . left / rhs . right NEW_LINE DEDENT def __truediv__ ( self , rhs ) : NEW_LINE INDENT return rhs . left / rhs . right NEW_LINE DEDENT def __floordiv__ ( self , rhs ) : NEW_LINE INDENT return rhs . left / rhs . right NEW_LINE DEDENT def __mod__ ( self , rhs ) : NEW_LINE INDENT return rhs . left % rhs . right NEW_LINE DEDENT def __pow__ ( self , rhs ) : NEW_LINE INDENT return rhs . left ** rhs . right NEW_LINE DEDENT def __exquo__ ( self , rhs ) : NEW_LINE INDENT return rhs . left ** rhs . right NEW_LINE DEDENT def __div__ ( self , rhs ) : NEW_LINE INDENT return rhs . left / rhs . right NEW_LINE DEDENT def __pow__ ( self , rhs ) : NEW_LINE INDENT return rhs . left ** rhs . right NEW_LINE DEDENT def __mod__ ( self , rhs ) : NEW_LINE INDENT return rhs . left % rhs . right NEW_LINE DEDENT def __floordiv__ ( self , rhs ) : NEW_LINE INDENT return rhs . left / rhs . right NEW_LINE DEDENT def __truediv__ ( self , rhs ) : NEW_LINE INDENT return rhs . left / rhs . right NEW_LINE DEDENT def __div__ ( self , rhs ) : NEW_LINE INDENT return rhs . left / rhs . right NEW_LINE DEDENT def __le__ ( self , rhs ) : NEW_LINE INDENT return rhs . left <= rhs . right NEW_LINE DEDENT def __ge__ ( self , rhs ) : NEW_LINE INDENT return rhs . left >= rhs . right NEW_LINE DEDENT def __ne__ ( self , rhs ) : NEW_LINE INDENT return rhs . left != rhs . right NEW_LINE DEDENT DEDENT return GFG ( root ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT s = sys . stdin NEW_LINE n = len ( s ) NEW_LINE arr = [ 2 ] * n + [ 1 ] * n NEW_LINE for i in range ( 2 , len ( arr ) ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] NEW_LINE DEDENT print ( arr [ n ] ) NEW_LINE DEDENT
def __gcd ( a , b ) : NEW_LINE INDENT if a == 0 : return b NEW_LINE if b == 0 : return a NEW_LINE if a == b : return a NEW_LINE if a > b : return __gcd ( a - b , b ) NEW_LINE return __gcd ( a , b - a ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE current_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i - 1 ] < arr [ i ] : NEW_LINE INDENT current_sum = current_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT max_sum = max ( max_sum , current_sum ) NEW_LINE current_sum = arr [ i ] NEW_LINE DEDENT DEDENT return max ( max_sum , current_sum ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ degree ▁ of ▁ the ▁ first ▁ two ▁ of ▁ the ▁ first ▁ two ▁ of ▁ the ▁ second . """ NEW_LINE a , b = symbols ( ' a ▁ b ' , integer = True , cls = Dummy ) NEW_LINE while b is not None : NEW_LINE INDENT t = b NEW_LINE b , a = a % b , t NEW_LINE DEDENT assert a == b NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT stdscr = stdscr . stdscr ( ) NEW_LINE a = stdscr . getkey ( ) NEW_LINE while a != ' q ' : NEW_LINE INDENT X , Y , W , H , N = stdscr . getkey ( ) NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x , y = stdscr . getkey ( ) NEW_LINE if ( X <= x <= X + W ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT
def GFG ( n1 ) : NEW_LINE INDENT l = len ( n1 ) NEW_LINE if n1 == '0' : NEW_LINE INDENT return 0 NEW_LINE DEDENT if l % 3 == 1 : NEW_LINE INDENT n1 = '00' + n1 NEW_LINE l += 2 NEW_LINE DEDENT elif l % 3 == 2 : NEW_LINE INDENT n1 = '0' + n1 NEW_LINE l += 1 NEW_LINE DEDENT n = n1 . split ( ' ▁ ' ) NEW_LINE gSum = 0 NEW_LINE while l != 0 : NEW_LINE INDENT gvalue = 0 NEW_LINE if l == 2 : NEW_LINE INDENT gvalue = ( int ( n [ ( l - 2 ) ] ) - 48 ) * 100 + ( int ( n [ ( l - 1 ) ] ) - 48 ) * 10 NEW_LINE DEDENT elif l == 1 : NEW_LINE INDENT gvalue = ( int ( n [ ( l - 1 ) ] ) - 48 ) * 100 NEW_LINE DEDENT else : NEW_LINE INDENT gvalue = ( int ( n [ ( l - 3 ) ] ) - 48 ) * 100 + ( int ( n [ ( l - 2 ) ] ) - 48 ) * 10 + ( int ( n [ ( l - 1 ) ] ) - 48 ) * 1 NEW_LINE DEDENT l = l - 3 NEW_LINE gSum = gSum + gvalue NEW_LINE DEDENT if gSum >= 1000 : NEW_LINE INDENT return ( divisibleby37 ( str ( gSum ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( gSum % 37 == 0 ) NEW_LINE DEDENT DEDENT
def py2ascii ( ) : NEW_LINE INDENT import sys NEW_LINE import io NEW_LINE import os NEW_LINE import struct NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import tempfile NEW_LINE import doctest NEW_LINE import tempfile NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import tempfile NEW_LINE import string NEW_LINE import tempfile NEW_LINE import random NEW_LINE import string NEW_LINE import string NEW_LINE import random NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE
def get_lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m
def squares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base / 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT square = 0 NEW_LINE mean = 0 NEW_LINE root = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT square += math . pow ( arr [ i ] , 2 ) NEW_LINE DEDENT mean = ( square / float ( n ) ) NEW_LINE root = float ( math . sqrt ( mean ) ) NEW_LINE return root NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE M = sys . argv [ 1 ] NEW_LINE N = sys . argv [ 2 ] NEW_LINE P = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT P . append ( sys . stdin . read ( ) ) NEW_LINE DEDENT P . sort ( ) NEW_LINE dp = [ sys . maxint ] * ( M + 10001 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT C = sys . stdin . read ( ) NEW_LINE E = sys . stdin . read ( ) NEW_LINE for j in range ( len ( dp ) - 1 , - C >= 0 , - E ) : NEW_LINE INDENT if dp [ j - C ] == sys . maxint : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ j ] = min ( dp [ j ] , dp [ j - C ] + E ) NEW_LINE DEDENT DEDENT sum = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT sum . append ( sum [ i ] + P [ M - 1 - i ] ) NEW_LINE DEDENT for i in range ( M + 1 , len ( sum ) ) : NEW_LINE INDENT sum . append ( sum [ M ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( sum [ 0 ] ) : NEW_LINE INDENT if dp [ i ] == sys . maxint : NEW_LINE INDENT continue NEW_LINE DEDENT ans = max ( ans , sum [ i ] - dp [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n NEW_LINE global array NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT getopt . getopt ( sys . argv [ 1 : ] , " n : a : " , [ " node = " , " parent = " , " left = " , " right = " ] ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " node ▁ % d : ▁ key ▁ = ▁ % d , ▁ " % ( i , array [ i ] ) ) NEW_LINE if i / 2 > 0 : NEW_LINE INDENT print ( " parent ▁ key ▁ = ▁ % d , ▁ " % array [ i / 2 ] ) NEW_LINE DEDENT if 2 * i <= n : NEW_LINE INDENT print ( " left ▁ key ▁ = ▁ % d , ▁ " % array [ 2 * i ] ) NEW_LINE DEDENT if ( 2 * i + 1 ) <= n : NEW_LINE INDENT print ( " right ▁ key ▁ = ▁ % d , ▁ " % array [ 2 * i + 1 ] ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
def GFG ( arr ) : NEW_LINE INDENT n , m = 6 , 6 NEW_LINE dp = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT m1 , m2 , m3 = 0 , 0 , 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( j / ( m / 3 ) ) == 0 : NEW_LINE INDENT m1 = max ( m1 , arr [ i ] [ j ] ) NEW_LINE DEDENT elif ( j / ( m / 3 ) ) == 1 : NEW_LINE INDENT m2 = max ( m2 , arr [ i ] [ j ] ) NEW_LINE DEDENT elif ( j / ( m / 3 ) ) == 2 : NEW_LINE INDENT m3 = max ( m3 , arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT dp . append ( max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ) NEW_LINE dp . append ( max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ) NEW_LINE dp . append ( max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ) NEW_LINE DEDENT print ( max ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) + " \n " ) NEW_LINE DEDENT
def GFG ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y1 , y3 ) NEW_LINE x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE if x5 > x6 or y5 > y6 : NEW_LINE INDENT print ( " No ▁ intersection " ) NEW_LINE return NEW_LINE DEDENT print ( " ( " + str ( x5 ) + " , ▁ " + str ( y5 ) + " ) ▁ " ) NEW_LINE print ( " ( " + str ( x6 ) + " , ▁ " + str ( y6 ) + " ) ▁ " ) NEW_LINE x7 = x5 NEW_LINE y7 = y6 NEW_LINE print ( " ( " + str ( x7 ) + " , ▁ " + str ( y7 ) + " ) ▁ " ) NEW_LINE x8 = x6 NEW_LINE y8 = y5 NEW_LINE print ( " ( " + str ( x8 ) + " , ▁ " + str ( y8 ) + " ) ▁ " ) NEW_LINE DEDENT
def test_424_a ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE sys . argv = [ ' - - n ' , ' - - s ' , ' - - sitting ' , ' - - standing ' ] + sys . argv NEW_LINE s = sys . argv [ 1 : ] NEW_LINE sittingToStanding = 0 NEW_LINE sitting , standing = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' x ' : NEW_LINE INDENT sitting += 1 NEW_LINE DEDENT else : NEW_LINE INDENT standing += 1 NEW_LINE DEDENT DEDENT sittingToStanding = ( sitting - standing ) / 2 NEW_LINE assert abs ( sittingToStanding ) < 1e-10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' x ' and sittingToStanding > 0 : NEW_LINE INDENT print ( ' X ' ) NEW_LINE sittingToStanding -= 1 NEW_LINE DEDENT elif s [ i ] == ' X ' and sittingToStanding < 0 : NEW_LINE INDENT print ( ' x ' ) NEW_LINE sittingToStanding += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
def class1 ( arg ) : NEW_LINE INDENT import sys NEW_LINE import tokenize NEW_LINE import string NEW_LINE import tokenize NEW_LINE import tokenize . tokentype as tokentype NEW_LINE class FastReader ( tokenize . TokenReader ) : NEW_LINE INDENT f = tokenize . StringIO ( ) NEW_LINE tokens = tokenize . generate_tokens ( lambda : tokentype . readline ( ) ) NEW_LINE def next ( self ) : NEW_LINE INDENT while self . f . readline ( ) or not self . tokens : NEW_LINE INDENT try : NEW_LINE INDENT self . tokens = self . tokens . next ( ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return self . tokens NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT str = self . f . readline ( ) NEW_LINE if not str : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return str NEW_LINE DEDENT DEDENT DEDENT class Scanner ( object ) : NEW_LINE INDENT def __init__ ( self , filename = None ) : NEW_LINE INDENT self . filename = filename NEW_LINE self . lines = [ ] NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT if not self . lines or not self . filename : NEW_LINE INDENT return NEW_LINE DEDENT self . lines . append ( self . filename ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT if not self . lines : NEW_LINE INDENT return NEW_LINE DEDENT self . lines . pop ( 0 ) NEW_LINE DEDENT DEDENT class Scanner ( Scanner ) : NEW_LINE INDENT def __init__ ( self , filename = None ) : NEW_LINE INDENT self . filename = filename NEW_LINE self . lines = [ ] NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT if not self . lines : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return self . lines . pop ( 0 ) NEW_LINE DEDENT DEDENT def readline ( self ) : NEW_LINE INDENT if not self . lines : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return self . lines . pop ( 0 ) NEW_LINE DEDENT DEDENT DEDENT class Scanner ( Scanner ) : NEW_LINE INDENT def __init__ ( self , filename = None ) : NEW_LINE INDENT self . filename = filename NEW_LINE self . lines = [ ] NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT if not self . lines : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return self . lines . pop ( 0 ) NEW_LINE DEDENT DEDENT DEDENT class Scanner ( Scanner ) : NEW_LINE INDENT def __init__ ( self , filename = None ) : NEW_LINE INDENT self . filename = filename NEW_LINE self . lines = [ ] NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT if not self . lines : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return self . lines . pop ( 0 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( W , wt , val , n ) : NEW_LINE INDENT maxratio = float ( ' inf ' ) NEW_LINE maxindex = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( val [ i ] / wt [ i ] ) > maxratio : NEW_LINE INDENT maxratio = ( val [ i ] / wt [ i ] ) NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT return ( W * maxratio , maxindex ) NEW_LINE DEDENT
def pyGFG ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE v1 = Vector ( ) NEW_LINE v2 = Vector ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT index , i , j = 0 , 0 , 0 NEW_LINE flag = False NEW_LINE if arr [ 0 ] % 2 == 0 : NEW_LINE INDENT flag = True NEW_LINE DEDENT while index < n : NEW_LINE INDENT if flag == True : NEW_LINE INDENT arr [ index ] = int ( v1 [ i ] ) NEW_LINE i += 1 NEW_LINE index += 1 NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = int ( v2 [ j ] ) NEW_LINE j += 1 NEW_LINE index += 1 NEW_LINE flag = not flag NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE A = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE B = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE C = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE if A <= C and B >= C : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def get_GFG ( n ) : NEW_LINE INDENT binary_num = [ 0 ] * 32 NEW_LINE i = 0 NEW_LINE while n > 0 : NEW_LINE INDENT binary_num [ i ] = n % 2 NEW_LINE n = n / 2 NEW_LINE i += 1 NEW_LINE DEDENT binary = " " NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT binary += str ( binary_num [ j ] ) NEW_LINE DEDENT return binary NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += ( arr [ i ] & 1 ) NEW_LINE DEDENT assert min ( x ) == n - x NEW_LINE DEDENT
def find_kth_largest ( nums , k ) : NEW_LINE INDENT """ STRNEWLINE ▁ Find ▁ the ▁ Kth ▁ largest ▁ of ▁ the ▁ given ▁ number ▁ of ▁ numbers . STRNEWLINE ▁ """ NEW_LINE shuffle ( nums ) NEW_LINE k = len ( nums ) - k NEW_LINE lo = 0 NEW_LINE hi = len ( nums ) - 1 NEW_LINE while lo < hi : NEW_LINE INDENT def exch ( a , lo , hi ) : NEW_LINE INDENT if a [ lo ] < a [ hi ] : lo = a [ lo ] + 1 NEW_LINE elif a [ hi ] > a [ lo ] : hi = a [ hi ] - 1 NEW_LINE else : break NEW_LINE DEDENT return a [ lo ] NEW_LINE DEDENT def exch ( a , lo , hi ) : NEW_LINE INDENT if a [ lo ] < a [ hi ] : hi = a [ hi ] + 1 NEW_LINE elif a [ hi ] > a [ lo ] : lo = a [ lo ] - 1 NEW_LINE else : break NEW_LINE DEDENT def exch ( a , lo , hi ) : NEW_LINE INDENT tmp = a [ i ] NEW_LINE a [ i ] , a [ j ] = a [ j ] , a [ j ] NEW_LINE a [ j ] = tmp NEW_LINE DEDENT def less ( v , w ) : NEW_LINE INDENT return v < w NEW_LINE DEDENT def shuffle ( a ) : NEW_LINE INDENT random . shuffle ( a ) NEW_LINE for ind in range ( 1 , len ( a ) ) : NEW_LINE INDENT r = random . randint ( 0 , ind + 1 ) NEW_LINE exch ( a [ ind ] , r ) NEW_LINE DEDENT DEDENT sObj = Solution ( ) NEW_LINE nums = [ 3 , 2 , 1 , 5 , 6 , 4 ] NEW_LINE k = 2 NEW_LINE out = sObj . find_kth_largest ( nums , k ) NEW_LINE print ( out ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT temp = n NEW_LINE while n : NEW_LINE INDENT k = n % 10 NEW_LINE if temp % k == 0 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n /= 10 NEW_LINE DEDENT return " NO " NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT k = int ( n % 10 ) NEW_LINE sum += k NEW_LINE n /= 10 NEW_LINE DEDENT if temp % sum == 0 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT return " NO " NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT s = sys . stdin NEW_LINE a = s . readline ( ) NEW_LINE b = s . readline ( ) NEW_LINE answer = " " NEW_LINE naa = len ( a ) NEW_LINE nab = len ( b ) NEW_LINE i = 0 NEW_LINE if naa == nab : NEW_LINE INDENT if a == b : NEW_LINE INDENT answer = " EQUAL " NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( naa ) : NEW_LINE INDENT q = a [ i ] + 0 NEW_LINE l = b [ i ] - 0 NEW_LINE if q > l : NEW_LINE INDENT answer = " GREATER " NEW_LINE break NEW_LINE DEDENT elif q < l : NEW_LINE INDENT answer = " LESS " NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT elif naa > nab : NEW_LINE INDENT answer = " GREATER " NEW_LINE DEDENT elif naa < nab : NEW_LINE INDENT answer = " LESS " NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT
def GFG ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE max_size = min ( l , b ) NEW_LINE total_area = 0 NEW_LINE for i in range ( 1 , max_size + 1 ) : NEW_LINE INDENT total_squares = ( l - size + 1 ) * ( b - size + 1 ) NEW_LINE area = total_squares * size * size NEW_LINE total_area += area NEW_LINE size += 1 NEW_LINE DEDENT return total_area NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT print ( '1' ) NEW_LINE return NEW_LINE DEDENT if N == 2 or N == 3 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE return NEW_LINE DEDENT even , odd = - 1 , - 1 NEW_LINE if N % 2 == 0 : NEW_LINE INDENT even , odd = N , N - 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd , even = N , N - 1 NEW_LINE DEDENT while odd >= 1 : NEW_LINE INDENT print ( odd ) NEW_LINE print ( ' ▁ ' ) NEW_LINE odd = odd - 2 NEW_LINE DEDENT while even >= 2 : NEW_LINE INDENT print ( even ) NEW_LINE print ( ' ▁ ' ) NEW_LINE even = even - 2 NEW_LINE DEDENT DEDENT
def find_min_equal_sums ( a , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum1 , sum2 = 0 , 0 NEW_LINE min = sys . maxint NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE sum2 = sum - sum1 NEW_LINE if abs ( sum1 - sum2 ) < min : NEW_LINE INDENT min = abs ( sum1 - sum2 ) NEW_LINE DEDENT if min == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( i ) NEW_LINE parts = [ ] NEW_LINE mod = n % 3 NEW_LINE if mod == 1 : NEW_LINE INDENT for j in range ( n // 3 ) : NEW_LINE INDENT parts . append ( 12 ) NEW_LINE DEDENT parts . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( n // 3 ) : NEW_LINE INDENT parts . append ( 21 ) NEW_LINE DEDENT if mod == 2 : NEW_LINE INDENT parts . append ( 2 ) NEW_LINE DEDENT DEDENT sys . argv [ 1 : ] = parts NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEW_LINE N = len ( a ) NEW_LINE assert find_optimal ( a , N ) == 0 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT f = open ( sys . argv [ 1 ] ) NEW_LINE data = f . read ( ) NEW_LINE tasks = list ( map ( int , data . split ( ) ) ) NEW_LINE task_list = Queue . Queue ( ) NEW_LINE events = PriorityQueue ( tasks [ 0 ] ) NEW_LINE task_dur = [ ] NEW_LINE for i in range ( tasks [ 0 ] ) : NEW_LINE INDENT task_input = list ( map ( int , data . split ( ) ) ) NEW_LINE task_dur . append ( task_input [ 1 ] ) NEW_LINE events . add ( task_input [ 0 ] * 2 + 1 ) NEW_LINE DEDENT sol = [ ] NEW_LINE next_task = 0 NEW_LINE while events : NEW_LINE INDENT event = events . pop ( ) NEW_LINE time = event [ 0 ] // 2 NEW_LINE if event [ 1 ] % 2 == 0 : NEW_LINE INDENT task_id = task_list . pop ( ) NEW_LINE sol . append ( time ) NEW_LINE if not task_list : NEW_LINE INDENT events . append ( ( time + task_dur [ task_list . index ( task ) ] ) * 2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT task = next_task += 1 NEW_LINE if len ( task_list ) <= tasks [ 1 ] : NEW_LINE INDENT task_list . append ( task ) NEW_LINE if len ( task_list ) == 1 : NEW_LINE INDENT events . append ( ( time + task_dur [ task ] ) * 2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT sol . append ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( sum ( sol ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE while t : NEW_LINE INDENT n , m = t . split ( ' ▁ ' ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT if n > m : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE continue NEW_LINE DEDENT a . sort ( ) NEW_LINE ans = a [ - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE if i > 0 : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT DEDENT if ans <= m : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] < a [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def ▁ pre5 ( ) : ENDCOM # ▁ import ▁ sys , ▁ os , ▁ time , ▁ string , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random ENDCOM # ▁ import ▁ time , ▁ random , ▁ time , ▁ time ENDCOM # ▁ import ▁ string , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random ENDCOM # ▁ import ▁ time , ▁ string , ▁ time , ▁ time ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ string , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ string , ▁ random , ▁ string ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ string , ▁ random , ▁ string ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random ENDCOM # ▁ import ▁ string ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ string ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ string , ▁ random , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random , ▁ random ENDCOM # ▁ import ▁ random , ▁ string , ▁ random , ▁ random , ▁ random ENDCOM #
def main1 ( ) : NEW_LINE INDENT import sys NEW_LINE arr = [ ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT DEDENT if arr [ 0 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 0 ] [ 1 ] == 1 or arr [ 0 ] [ 2 ] == 1 or arr [ 0 ] [ 0 ] == 1 or arr [ 1 ] [ 0 ] == 1 or arr [ 2 ] [ 1 ] == 1 or arr [ 3 ] [ 2 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 1 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 1 ] [ 1 ] == 1 or arr [ 1 ] [ 2 ] == 1 or arr [ 1 ] [ 0 ] == 1 or arr [ 2 ] [ 0 ] == 1 or arr [ 3 ] [ 1 ] == 1 or arr [ 0 ] [ 2 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 2 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 2 ] [ 1 ] == 1 or arr [ 2 ] [ 2 ] == 1 or arr [ 0 ] [ 0 ] == 1 or arr [ 3 ] [ 0 ] == 1 or arr [ 0 ] [ 2 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT if arr [ 3 ] [ 3 ] == 1 : NEW_LINE INDENT if arr [ 3 ] [ 1 ] == 1 or arr [ 3 ] [ 2 ] == 1 or arr [ 0 ] [ 0 ] == 1 or arr [ 1 ] [ 1 ] == 1 or arr [ 0 ] [ 0 ] == 1 or arr [ 0 ] [ 0 ] == 1 or arr [ 1 ] [ 2 ] == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT N = 10000 NEW_LINE MOD = 1000000007 NEW_LINE F = np . zeros ( ( N , N ) ) NEW_LINE def precompute ( ) : NEW_LINE INDENT F [ 1 : ] = 2 NEW_LINE F [ 2 : ] = 3 NEW_LINE F [ 3 : ] = 4 NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 8 NEW_LINE precompute ( ) NEW_LINE print ( F [ n ] ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def py ( z ) : NEW_LINE INDENT i , j , k , c , t , b = z NEW_LINE s = [ ] NEW_LINE for ( t , c ) in zip ( t , c ) : NEW_LINE INDENT for ( b , c ) in zip ( b , c ) : NEW_LINE INDENT for ( i , j ) in zip ( i , j ) : NEW_LINE INDENT b += c if t == i else 1 NEW_LINE DEDENT DEDENT DEDENT return b NEW_LINE DEDENT
def pylis_ceil ( A , l , r , key ) : NEW_LINE INDENT while r - l > 1 : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if A [ m ] >= key : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT s = sys . stdin NEW_LINE N = len ( s ) NEW_LINE ban = [ s [ i ] for i in range ( N ) ] NEW_LINE ban . sort ( ) NEW_LINE print ( ( ban [ N - 1 ] - ban [ 0 ] + 1 ) / 2 ) NEW_LINE DEDENT
def p074 ( n ) : NEW_LINE INDENT print ( [ n ] ) NEW_LINE def factorial ( n ) : NEW_LINE INDENT return library . pow ( 10 , 6 ) NEW_LINE DEDENT def factorial ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( LIMIT ) : NEW_LINE INDENT if get_chain_length ( n ) == 60 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT def factorial ( n ) : NEW_LINE INDENT seen = set ( ) NEW_LINE while True : NEW_LINE INDENT if not seen . add ( n ) : NEW_LINE INDENT return len ( seen ) NEW_LINE DEDENT n = factorialize ( n ) NEW_LINE DEDENT DEDENT FACTORIAL = [ 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 ] NEW_LINE def factorialize ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT sum += FACTORIAL [ n % 10 ] NEW_LINE DEDENT return sum NEW_LINE DEDENT return factorial NEW_LINE DEDENT
def colour_visible ( height , colour , K ) : NEW_LINE INDENT arr = [ 0 ] * K + [ 0 ] * K NEW_LINE visible = 0 NEW_LINE max = height [ K - 1 ] NEW_LINE arr [ colour [ K - 1 ] ] = 1 NEW_LINE for i in range ( K - 2 , - 1 , - 1 ) : NEW_LINE INDENT if height [ i ] > max : NEW_LINE INDENT max = height [ i ] NEW_LINE arr [ colour [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT visible += 1 NEW_LINE DEDENT DEDENT return visible NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT i = math . log ( n ) / math . log ( 8 ) NEW_LINE return ( i - math . floor ( i ) < 0.000001 ) NEW_LINE DEDENT
def test_solution ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ solution ▁ to ▁ the ▁ Kronecker ▁ Forest ▁ algorithm . STRNEWLINE ▁ """ NEW_LINE f = nx . complete_graph ( 5 ) NEW_LINE for t in range ( 5 ) : NEW_LINE INDENT a , b = f ( t ) NEW_LINE res = min ( ( a + b ) / 4 , min ( a , b ) ) NEW_LINE assert_equal ( res , ( 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global maxes NEW_LINE global verbose NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , " hb " ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - h | - b | - b | - b ] ▁ < filename > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE while t : NEW_LINE INDENT n = len ( t ) NEW_LINE l = [ ] NEW_LINE r = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( t [ i ] ) NEW_LINE r . append ( t [ i ] ) NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s < r : NEW_LINE INDENT if l [ i ] > s : NEW_LINE INDENT s = l [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT s += 1 NEW_LINE DEDENT sys . stdout . write ( s + " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( 0 + " ▁ " ) NEW_LINE DEDENT DEDENT sys . stdout . write ( " \n " ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 7 NEW_LINE m = 4 NEW_LINE assert count_ways ( n , m ) == n + m NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT print ( n + n / 2 ) NEW_LINE for i in range ( 2 , n + 2 , 2 ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 1 , n + 2 , 2 ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 2 , 2 ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT bfo = open ( ' / proc / cpuinfo ' , ' r ' ) NEW_LINE str = bfo . read ( ) NEW_LINE res = 0 NEW_LINE han = 0 NEW_LINE ni_beki = 1 NEW_LINE ruijyo = 0 NEW_LINE if str == ' ' : NEW_LINE INDENT sys . exit ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res = int ( str ) NEW_LINE for i in range ( 1 ) : NEW_LINE INDENT han = ( res >> ruijyo ) % 2 NEW_LINE if han == 0 : NEW_LINE INDENT res = ( res % ni_beki ) + 1 NEW_LINE i = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT ni_beki = ni_beki * 2 NEW_LINE ruijyo += 1 NEW_LINE DEDENT DEDENT sys . exit ( res ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = ' Generate ▁ a ▁ binary ▁ file ▁ from ▁ a ▁ set ▁ of ▁ binary ▁ data ' ) NEW_LINE parser . add_argument ( ' - - binary ' , required = True , help = ' The ▁ binary ▁ file ▁ to ▁ generate ▁ a ▁ binary ▁ file ▁ from ' ) NEW_LINE parser . add_argument ( ' - - binary - file ' , required = True , help = ' The ▁ binary ▁ file ▁ to ▁ generate ▁ a ▁ binary ▁ file ▁ from ' ) NEW_LINE parser . add_argument ( ' - - binary - file ' , required = True , help = ' The ▁ binary ▁ file ▁ to ▁ generate ▁ a ▁ binary ▁ file ▁ from ' ) NEW_LINE parser . add_argument ( ' - - binary - file ' , required = True , help = ' The ▁ binary ▁ file ▁ to ▁ generate ▁ a ▁ binary ▁ file ▁ from ' ) NEW_LINE parser . add_argument ( ' - - binary - file ' , required = True , help = ' The ▁ binary ▁ file ▁ to ▁ generate ▁ a ▁ binary ▁ file ▁ from ' ) NEW_LINE parser . add_argument ( ' - - binary - file ' , required = True , help = ' The ▁ binary ▁ file ▁ to ▁ generate ▁ a ▁ binary ▁ file ▁ from ' ) NEW_LINE parser . add_argument ( ' - - binary - file ' , required = True , help = ' The ▁ binary ▁ file ▁ to ▁ generate ▁ a ▁ binary ▁ file ▁ from ' ) NEW_LINE parser . add_argument ( ' - - binary - file ' , required = True , help = ' The ▁ binary ▁ file ▁ to ▁ generate ▁ a ▁ binary ▁ file ▁ from ' ) NEW_LINE parser . add_argument ( ' - - binary - file ' , required = True , help
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while True : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count = { 0 : 0 , 1 : 0 } NEW_LINE used = [ ] NEW_LINE for x in range ( 1 , a + 1 ) : NEW_LINE INDENT if y != x : NEW_LINE INDENT y = x + 1 NEW_LINE DEDENT if y != x and y != b : NEW_LINE INDENT y = y + 1 NEW_LINE DEDENT if y != x and y != b : NEW_LINE INDENT y = y + 1 NEW_LINE DEDENT if y != x and y != b : NEW_LINE INDENT y = y + 1 NEW_LINE DEDENT if y != x and y != b : NEW_LINE INDENT y = y + 1 NEW_LINE DEDENT if y != x and y != b : NEW_LINE INDENT sorted = sorted ( y ) NEW_LINE if used [ sorted ] == 1 : NEW_LINE INDENT return NEW_LINE DEDENT used [ sorted ] += 1 NEW_LINE count [ 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def gen2int ( ind , cnt , last , a , n , k , dp ) : NEW_LINE INDENT if cnt == k : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ind == n : NEW_LINE INDENT return int ( - 1e9 ) NEW_LINE DEDENT if dp [ ind ] [ cnt ] != - 1 : NEW_LINE INDENT return dp [ ind ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( ind , n ) : NEW_LINE INDENT if cnt % 2 == 0 : NEW_LINE INDENT ans = max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) NEW_LINE DEDENT DEDENT return dp [ ind ] [ cnt ] = ans NEW_LINE DEDENT
def test_A ( ) : NEW_LINE INDENT f = open ( ' / tmp / A . txt ' , ' r ' ) NEW_LINE lines = f . readlines ( ) NEW_LINE n = int ( lines [ 0 ] ) NEW_LINE tokens = lines [ 1 : ] NEW_LINE arr = [ ] NEW_LINE non_int = 0 NEW_LINE sum_before , sum = 0 , 0 NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT num = float ( tokens [ i ] ) NEW_LINE sum_before += num NEW_LINE if num != math . floor ( num ) : NEW_LINE INDENT non_int += 1 NEW_LINE DEDENT sum += math . floor ( num ) NEW_LINE arr . append ( num ) NEW_LINE DEDENT max_sum = min ( n , non_int ) + sum NEW_LINE min_sum = max ( 0 , non_int - n ) + sum NEW_LINE ans = None NEW_LINE if min_sum > sum_before : NEW_LINE INDENT ans = ( min_sum - sum_before ) NEW_LINE DEDENT elif max_sum < sum_before : NEW_LINE INDENT ans = ( sum_before - max_sum ) NEW_LINE DEDENT else : NEW_LINE INDENT x = sum_before - math . floor ( sum_before ) NEW_LINE ans = min ( 1 - x , x ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def GFG ( bin ) : NEW_LINE INDENT if bin == '00' : NEW_LINE INDENT return 0 NEW_LINE DEDENT if bin == '01' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if bin == '10' : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT def is_divisible_by_5 ( bin ) : NEW_LINE INDENT l = len ( bin ) NEW_LINE if l % 2 != 0 : NEW_LINE INDENT bin = '0' + bin NEW_LINE DEDENT odd_sum , even_sum = 0 , 0 NEW_LINE is_odd_digit = 1 NEW_LINE for i in range ( 0 , len ( bin ) , 2 ) : NEW_LINE INDENT if is_odd_digit != 0 : NEW_LINE INDENT odd_sum += equivalent_base4 ( bin [ i : i + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT even_sum += equivalent_base4 ( bin [ i : i + 2 ] ) NEW_LINE DEDENT is_odd_digit ^= 1 NEW_LINE DEDENT if abs ( odd_sum - even_sum ) % 5 == 0 : NEW_LINE INDENT return ' Yes ' NEW_LINE DEDENT return ' No ' NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT bin = '10000101001' NEW_LINE print ( is_divisible_by_5 ( bin ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE queue = [ ] NEW_LINE d = { } NEW_LINE d [ 0 ] = 0 NEW_LINE d [ 1 ] = 1 NEW_LINE d [ 2 ] = 2 NEW_LINE d [ 3 ] = 3 NEW_LINE d [ 4 ] = 4 NEW_LINE d [ 5 ] = 5 NEW_LINE d [ 6 ] = 6 NEW_LINE d [ 7 ] = 7 NEW_LINE d [ 8 ] = 8 NEW_LINE d [ 9 ] = 9 NEW_LINE d [ 10 ] = 10 NEW_LINE d [ 11 ] = 11 NEW_LINE d [ 12 ] = 12 NEW_LINE d [ 13 ] = 13 NEW_LINE d [ 14 ] = 14 NEW_LINE d [ 15 ] = 15 NEW_LINE d [ 16 ] = 16 NEW_LINE d [ 17 ] = 17 NEW_LINE d [ 18 ] = 18 NEW_LINE d [ 19 ] = 19 NEW_LINE d [ 20 ] = 20 NEW_LINE d [ 21 ] = 21 NEW_LINE d [ 22 ] = 22 NEW_LINE d [ 23 ] = 23 NEW_LINE d [ 24 ] = 24 NEW_LINE d [ 25 ] = 25 NEW_LINE d [ 26 ] = 26 NEW_LINE d [ 27 ] = 27 NEW_LINE d [ 28 ] = 28 NEW_LINE d [ 29 ] = 29 NEW_LINE d [ 30 ] = 30 NEW_LINE d [ 31 ] = 31 NEW_LINE d [ 32 ] = 32 NEW_LINE d [ 33 ] = 33 NEW_LINE d [ 34 ] = 34 NEW_LINE d [ 35 ] = 35 NEW_LINE d [ 36 ] = 36 NEW_LINE d [ 37 ] = 37 NEW_LINE d [ 38 ] = 38 NEW_LINE d [ 39 ] = 39 NEW_LINE d [ 40 ] = 40 NEW_LINE d [ 41 ] = 41 NEW_LINE d [ 42 ] = 42 NEW_LINE d [ 43 ] = 43 NEW_LINE d [ 44 ] = 44 NEW_LINE d [ 45 ] = 45 NEW_LINE d [ 46 ] = 46 NEW_LINE d [ 47 ] = 47 NEW_LINE d [ 48 ] = 48 NEW_LINE d [ 49 ] = 49 NEW_LINE d [ 50 ] = 50 NEW_LINE d [ 51 ] = 51 NEW_LINE d [ 52 ] = 52 NEW_LINE d [ 53 ] = 53 NEW_LINE d [ 54 ] = 54 NEW_LINE d [ 55 ] = 55 NEW_LINE d [ 56 ] = 56 NEW_LINE d [ 57 ] = 57 NEW_LINE d [ 58 ] = 58 NEW_LINE d [ 59 ] = 58 NEW_LINE d [ 60 ] = 60 NEW_LINE d [ 61 ] = 61 NEW_LINE d [ 62 ] = 62 NEW_LINE d [ 63 ] = 63 NEW_LINE d [ 64 ] = 64 NEW_LINE d [ 65 ] = 65 NEW_LINE d [ 66 ] = 66 NEW_LINE d [ 67 ] = 67 NEW_LINE d [ 68 ] = 67 NEW_LINE d [ 69 ] = 69 NEW_LINE
def py_smallest_number ( arr , ops , idx ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ smallest ▁ number ▁ of ▁ elements ▁ in ▁ arr . STRNEWLINE ▁ """ NEW_LINE min = np . inf NEW_LINE arr = np . array ( arr ) NEW_LINE ops = [ ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT ops . append ( i ) NEW_LINE DEDENT util . sort ( arr , ops , 0 ) NEW_LINE print ( min ) NEW_LINE return min NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT from sympy . polys . distributedmodules import gf_degree NEW_LINE MAX = 1005 NEW_LINE SieveOfEratosthenes ( ) NEW_LINE primes = [ True for i in range ( MAX ) ] NEW_LINE for p in primes : NEW_LINE INDENT if p == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime = False NEW_LINE DEDENT DEDENT DEDENT for p in primes : NEW_LINE INDENT if prime : NEW_LINE INDENT primes . insert ( 0 , p ) NEW_LINE DEDENT DEDENT minimum_squared_free_divisors = [ ] NEW_LINE for i in range ( 0 , len ( primes ) , 2 ) : NEW_LINE INDENT if primes [ i ] * primes [ i ] <= N : NEW_LINE INDENT if N % primes [ i ] == 0 : NEW_LINE INDENT tmp = 0 NEW_LINE while N % primes [ i ] == 0 : NEW_LINE INDENT tmp += 1 NEW_LINE N /= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE DEDENT DEDENT if max_count == 0 : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE x = sys . argv [ 1 ] NEW_LINE a = sys . argv [ 2 ] NEW_LINE b = sys . argv [ 3 ] NEW_LINE print ( ( x - a ) % b ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE k = len ( sys . argv ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( sys . argv [ i ] ) NEW_LINE DEDENT idx = k - 1 NEW_LINE flag = True NEW_LINE while idx < n : NEW_LINE INDENT if arr [ idx ] != arr [ k - 1 ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT idx += 1 NEW_LINE DEDENT if not flag : NEW_LINE INDENT sys . stdout . write ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT i = k - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if arr [ i ] != arr [ k - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT sys . stdout . write ( i + 1 ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT
def get_GFG ( A , n ) : NEW_LINE INDENT S = set ( ) NEW_LINE for t in A : NEW_LINE INDENT S . add ( t ) NEW_LINE DEDENT max_len , x , y = 0 , A [ n ] + A [ n ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x , y = A [ j ] , A [ i ] + A [ j ] NEW_LINE length = 3 NEW_LINE while S . add ( y ) and ( y != S . last ( ) ) : NEW_LINE INDENT z = x + y NEW_LINE x , y = y , z NEW_LINE max_len = max ( max_len , yield length ) NEW_LINE DEDENT DEDENT DEDENT return max_len >= 3 NEW_LINE DEDENT
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT cnt = 0 NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT sum = a [ i ] + b [ j ] NEW_LINE if s . intersection ( sum ) == False : NEW_LINE INDENT cnt += 1 NEW_LINE s . add ( sum ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def GFG ( arr , x , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = math . sqrt ( arr [ i ] ) NEW_LINE if math . floor ( y ) == math . ceil ( y ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if sum % x == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE pque = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pque . append ( PriorityQueue ( cmp ( i , 0 ) ) ) NEW_LINE DEDENT q = sys . stdin . readline ( ) . split ( ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT command = sys . argv [ i ] NEW_LINE t = sys . argv [ i + 1 ] NEW_LINE try : NEW_LINE INDENT x = int ( command ) NEW_LINE pque [ t ] . append ( x ) NEW_LINE DEDENT except : NEW_LINE INDENT print ( " Error ▁ while ▁ parsing ▁ command ▁ line ▁ arguments " ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = [ 10 , - 10 , 20 , - 40 ] NEW_LINE n = len ( a ) NEW_LINE assert ask ( Q . is_prime ( a [ 0 ] ) , Q . is_prime ( a [ 1 ] ) ) NEW_LINE min_sum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT min_sum += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT assert ask ( Q . is_prime ( a [ 0 ] ) , Q . is_prime ( a [ 1 ] ) ) NEW_LINE max_sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT max_sum += abs ( a [ n - 1 - i ] - a [ i ] ) NEW_LINE DEDENT assert ask ( Q . is_prime ( a [ 0 ] ) , Q . is_prime ( a [ 1 ] ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - d | - e | - u | - t ] ▁ [ - d | - e | - u | - t ] """ % sys . argv [ 0 ] ) NEW_LINE print ( """ ▁ - d ▁ : ▁ decode ▁ ASCII ▁ strings ▁ and ▁ exit ▁ with ▁ - u ▁ if ▁ not ▁ - - """ ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - e ' : NEW_LINE INDENT print ( '0' ) NEW_LINE break NEW_LINE DEDENT if o == ' - d ' : NEW_LINE INDENT print ( '1' ) NEW_LINE break NEW_LINE DEDENT if o == ' - u ' : NEW_LINE INDENT print ( '0' ) NEW_LINE break NEW_LINE DEDENT if o == ' - t ' : NEW_LINE INDENT print ( ' decode ▁ ASCII ▁ strings ▁ and ▁ exit ▁ with ▁ - - ' ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT sum = 0 NEW_LINE fsm = fsm . fsm NEW_LINE a = fsm . a NEW_LINE state_list = fsm . state_list NEW_LINE cnt4 = 0 NEW_LINE cnt2 = 0 NEW_LINE work = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT state_list . append ( fsm . state [ i ] ) NEW_LINE work = state_list [ i ] % 4 NEW_LINE if work == 0 : NEW_LINE INDENT cnt4 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT work = state_list [ i ] % 2 NEW_LINE if work == 0 : NEW_LINE INDENT cnt2 += 1 NEW_LINE DEDENT DEDENT DEDENT work = a / 2 NEW_LINE if work <= cnt4 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT work = a - ( cnt4 * 2 ) NEW_LINE if ( work == 0 ) | ( cnt2 == 0 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT if work == cnt2 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT print ( " No " ) NEW_LINE DEDENT
def pyGFG ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ - i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE ans = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s2 = s [ - 1 ] + s2 NEW_LINE s2 = s2 [ : - 1 ] NEW_LINE if ( s == [ ] if s2 != [ ] else not s ) and isPalindrome ( s2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def solve ( s ) : NEW_LINE INDENT if len ( s ) <= 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt = [ 0 ] * 25 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ s [ i ] - ' a ' ] += 1 NEW_LINE DEDENT if sum ( cnt ) >= ( len ( s ) - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ans ( s ) or 1 ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT s = ' nolon ' NEW_LINE print ( solve ( s ) ) NEW_LINE DEDENT
def count_numbers ( k , n ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ number ▁ of ▁ numbers ▁ in ▁ the ▁ given ▁ k - th ▁ order . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ k ▁ : ▁ int STRNEWLINE ▁ The ▁ order ▁ of ▁ the ▁ numbers ▁ in ▁ the ▁ given ▁ k - th ▁ order . STRNEWLINE ▁ n ▁ : ▁ int STRNEWLINE ▁ The ▁ order ▁ of ▁ the ▁ numbers ▁ in ▁ the ▁ given ▁ k - th ▁ order . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ n ▁ : ▁ int STRNEWLINE ▁ The ▁ number ▁ of ▁ numbers ▁ in ▁ the ▁ given ▁ k - th ▁ order . STRNEWLINE STRNEWLINE ▁ Examples STRNEWLINE ▁ - - - - - STRNEWLINE ▁ > > > ▁ from ▁ sympy . ntheory . factorint ▁ import ▁ count _ numbers STRNEWLINE ▁ > > > ▁ count _ numbers ( 10 , ▁ 3 ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ count _ numbers ( 10 , ▁ 3 ) STRNEWLINE ▁ 2 STRNEWLINE ▁ > > > ▁ count _ numbers ( 10 , ▁ 3 ) STRNEWLINE ▁ 1 STRNEWLINE ▁ """ NEW_LINE k = int ( k ) NEW_LINE n = int ( n ) NEW_LINE return n + 1 NEW_LINE DEDENT
def gfG ( n , arr , cost ) : NEW_LINE INDENT sum , total_cost = 0 , 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT total_cost += cost * sum NEW_LINE arr [ n - 1 ] += sum NEW_LINE total_cost += ( 2 * cost * arr [ n - 1 ] ) NEW_LINE return total_cost NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE main = sys . argv [ 1 ] NEW_LINE main . teamFormationMake ( ) NEW_LINE return NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' i : o : ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( ' ERROR : ▁ % s \n ' % msg ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - i ' : NEW_LINE INDENT for n in a : NEW_LINE INDENT if n not in ( ' - o ' , ' - - output ' ) : NEW_LINE INDENT sys . stdout . write ( ' ERROR : ▁ % s \n ' % n ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT elif n == n - 1 : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT sys . stdout . write ( ' \n ' ) NEW_LINE DEDENT
def b1593 ( ) : NEW_LINE INDENT t = sys . stdin . readline ( ) NEW_LINE while t : NEW_LINE INDENT s = t . rstrip ( ) NEW_LINE ans = 0 NEW_LINE list = [ ] NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ch = s [ i ] NEW_LINE if len ( list ) == 0 : NEW_LINE INDENT if ch in [ '0' , '5' ] : NEW_LINE INDENT list . append ( ch + ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT found = False NEW_LINE for str in list : NEW_LINE INDENT if int ( ch + str ) % 25 == 0 : NEW_LINE INDENT found = True NEW_LINE ans += len ( list ) - 1 NEW_LINE break NEW_LINE DEDENT DEDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT if ch in [ '0' , '5' ] : NEW_LINE INDENT list . append ( ch + ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT t = sys . stdin . readline ( ) NEW_LINE DEDENT
def import ( data ) : NEW_LINE INDENT import sys NEW_LINE class Node : NEW_LINE INDENT data = data NEW_LINE left = right = None NEW_LINE DEDENT class GFG : NEW_LINE INDENT def insert ( self , root , data ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT if data < root . data : NEW_LINE INDENT root . left = self . insert ( root . left , data ) NEW_LINE DEDENT if data > root . data : NEW_LINE INDENT root . right = self . insert ( root . right , data ) NEW_LINE DEDENT return root NEW_LINE DEDENT def inOrder ( root ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT inOrder ( root . left ) NEW_LINE print ( root . data , end = ' ▁ ' ) NEW_LINE inOrder ( root . right ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 2 , 5 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE root = None NEW_LINE for i in range ( n ) : NEW_LINE INDENT root = self . insert ( root , arr [ i ] ) NEW_LINE DEDENT inOrder ( root ) NEW_LINE DEDENT DEDENT
def GFG ( str , k ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE hash = [ ] NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash . append ( str [ i ] - ' a ' ) NEW_LINE DEDENT res = ' ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if hash [ str [ i ] - ' a ' ] >= k : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def LongestCommonSubSequence ( X , Y , m , n ) : NEW_LINE INDENT LCStuff = [ [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0
def test_GFG ( ) : NEW_LINE INDENT x = 1223355 NEW_LINE assert len ( GFG ( x ) ) == 2 NEW_LINE assert len ( GFG ( x , 0 ) ) == 2 NEW_LINE assert len ( GFG ( x , 1 ) ) == 2 NEW_LINE assert len ( GFG ( x , 2 ) ) == 2 NEW_LINE assert len ( GFG ( x , 3 ) ) == 2 NEW_LINE assert len ( GFG ( x , 4 ) ) == 2 NEW_LINE assert len ( GFG ( x , 5 ) ) == 2 NEW_LINE assert len ( GFG ( x , 6 ) ) == 2 NEW_LINE assert len ( GFG ( x , 7 ) ) == 2 NEW_LINE assert len ( GFG ( x , 8 ) ) == 2 NEW_LINE assert len ( GFG ( x , 9 ) ) == 2 NEW_LINE assert len ( GFG ( x , 10 ) ) == 2 NEW_LINE assert len ( GFG ( x , 11 ) ) == 2 NEW_LINE assert len ( GFG ( x , 12 ) ) == 2 NEW_LINE assert len ( GFG ( x , 13 ) ) == 2 NEW_LINE assert len ( GFG ( x , 14 ) ) == 2 NEW_LINE assert len ( GFG ( x , 15 ) ) == 2 NEW_LINE assert len ( GFG ( x , 16 ) ) == 2 NEW_LINE assert len ( GFG ( x , 17 ) ) == 2 NEW_LINE assert len ( GFG ( x , 18 ) ) == 2 NEW_LINE assert len ( GFG ( x , 19 ) ) == 2 NEW_LINE assert len ( GFG ( x , 20 ) ) == 2 NEW_LINE assert len ( GFG ( x , 21 ) ) == 2 NEW_LINE assert len ( GFG ( x , 22 ) ) == 2 NEW_LINE assert len ( GFG ( x , 23 ) ) == 2 NEW_LINE assert len ( GFG ( x , 24 ) ) == 2 NEW_LINE assert len ( GFG ( x , 25 ) ) == 2 NEW_LINE assert len ( GFG ( x , 26 ) ) == 2 NEW_LINE assert len ( GFG ( x , 27 ) ) == 2 NEW_LINE assert len ( GFG ( x , 28 ) ) == 2 NEW_LINE assert len ( GFG ( x , 29 ) ) == 2 NEW_LINE assert len ( GFG ( x , 30 ) ) == 2 NEW_LINE assert len ( GFG ( x , 31 ) ) == 2 NEW_LINE assert len ( GFG ( x , 32 ) ) == 2 NEW_LINE assert len ( GFG ( x , 33 ) ) == 2 NEW_LINE DEDENT
def pyGFG ( arr , n ) : NEW_LINE INDENT max , len , max_index = 1 , 1 , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ i - 1 ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if max < len : NEW_LINE INDENT max = len NEW_LINE max_index = i - max NEW_LINE DEDENT len = 1 NEW_LINE DEDENT DEDENT if max < len : NEW_LINE INDENT max = len NEW_LINE max_index = n - max NEW_LINE DEDENT for i in range ( max_index , max + max_index ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n NEW_LINE global m NEW_LINE n = 0 NEW_LINE m = 0 NEW_LINE for line in sys . stdin : NEW_LINE INDENT if line . startswith ( " # " ) : NEW_LINE INDENT continue NEW_LINE DEDENT n += 1 NEW_LINE m += 1 NEW_LINE DEDENT sys . exit ( n ) NEW_LINE DEDENT
def program ( ) : NEW_LINE INDENT sf = sys . stdin NEW_LINE t = 1 NEW_LINE for t1 in range ( t ) : NEW_LINE INDENT n , m = sf . readline ( ) . split ( ) NEW_LINE p = [ ] NEW_LINE hash = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT p . append ( sf . readline ( ) ) NEW_LINE hash . append ( p [ i ] ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT l , r , x = sf . readline ( ) . split ( ) NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE x -= 1 NEW_LINE ind = x NEW_LINE if ind < l or ind > r : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT hash1 = [ ] NEW_LINE for j in range ( l ) : NEW_LINE INDENT hash1 . append ( p [ j ] ) NEW_LINE DEDENT for j in range ( r + 1 , n ) : NEW_LINE INDENT hash1 . append ( p [ j ] ) NEW_LINE DEDENT cnt = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if hash1 [ j ] == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if j == hash [ x ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dif1 = ind - l + 1 NEW_LINE if dif1 != cnt : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = [ - 6 , 10 , - 3 , 10 , - 2 ] NEW_LINE b = [ ] NEW_LINE S = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( res ) NEW_LINE res += a [ i ] NEW_LINE S += a [ i ] NEW_LINE res = max ( res , - S ) NEW_LINE DEDENT ans = S NEW_LINE ans = max ( ans , res ) NEW_LINE g = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT g -= a [ i ] NEW_LINE ans = max ( ans , g + b [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def test_a1452 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' , real = True ) NEW_LINE while t . is_real : NEW_LINE INDENT a = [ symbols ( ' a ' , real = True ) for i in range ( 2 ) ] NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] == a [ 1 ] : NEW_LINE INDENT assert 2 * a [ 0 ] == 2 * a [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT assert 2 * a [ 1 ] - 1 == 2 * a [ 0 ] NEW_LINE DEDENT DEDENT x = symbols ( ' x ' , real = True ) NEW_LINE t = symbols ( ' t ' , real = True ) NEW_LINE while t . is_integer : NEW_LINE INDENT a = [ symbols ( ' a ' , integer = True ) for i in range ( 2 ) ] NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] == a [ 1 ] : NEW_LINE INDENT assert 2 * a [ 0 ] == 2 * a [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT assert 2 * a [ 1 ] - 1 == 2 * a [ 0 ] NEW_LINE DEDENT DEDENT x = symbols ( ' x ' , real = True ) NEW_LINE t = symbols ( ' t ' , integer = True ) NEW_LINE while t . is_integer : NEW_LINE INDENT a = [ symbols ( ' a ' , integer = True ) for i in range ( 2 ) ] NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] == a [ 1 ] : NEW_LINE INDENT assert 2 * a [ 0 ] == 2 * a [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT assert 2 * a [ 1 ] - 1 == 2 * a [ 0 ] NEW_LINE DEDENT DEDENT x = symbols ( ' x ' , real = True ) NEW_LINE t = symbols ( ' t ' , integer = True ) NEW_LINE assert t . is_integer is False NEW_LINE DEDENT
def GFG ( str , x ) : NEW_LINE INDENT n = ( len ( str ) - x ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT for i in range ( n + x - 1 , - n , - 1 ) : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT for i in range ( n + x , len ( str ) ) : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT
def GFG ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 1 ] * n for i in range ( n ) ] NEW_LINE for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if str [ i ] == str [ j ] and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif str [ i ] == str [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT if ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def p_test ( p ) : NEW_LINE INDENT ''' test ▁ : ▁ ID ▁ EQUALS ▁ expr ''' NEW_LINE p [ 0 ] = ( ' test ' , p [ 2 ] ) NEW_LINE t = len ( p ) NEW_LINE while t -- : NEW_LINE INDENT n = p [ 1 ] NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( p [ 3 ] ) NEW_LINE DEDENT curr = arr [ - 1 ] NEW_LINE c = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] <= curr : NEW_LINE INDENT curr = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT DEDENT
def p_p187 ( p ) : NEW_LINE INDENT print ( ast . parse ( p ) ) NEW_LINE LIMIT = library . pow ( 10 , 8 ) - 1 NEW_LINE count = 0 NEW_LINE primes = library . list_primes ( LIMIT / 2 ) NEW_LINE for i , sqrt in enumerate ( library . sqrt ( LIMIT ) ) : NEW_LINE INDENT end = bisect . bisect ( primes , LIMIT / primes [ i ] ) NEW_LINE if end >= 0 : NEW_LINE INDENT end += 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = - end - 1 NEW_LINE DEDENT count += end - i NEW_LINE DEDENT return str ( count ) NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE M = 20 NEW_LINE dp = { } NEW_LINE d , K = 1 , 1 NEW_LINE def count ( pos , cnt , tight , nonz , num ) : NEW_LINE INDENT if pos == len ( num ) : NEW_LINE INDENT if cnt == K : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = ( ( tight != 0 ) and 9 or num [ pos ] ) NEW_LINE for dig in range ( 0 , limit ) : NEW_LINE INDENT curr_cnt = cnt NEW_LINE if dig == d : NEW_LINE INDENT if d != 0 or ( d == 0 and nonz != 0 ) : NEW_LINE INDENT curr_cnt += 1 NEW_LINE DEDENT DEDENT curr_tet = tight NEW_LINE if dig < num [ pos ] : NEW_LINE INDENT curr_tet = 1 NEW_LINE DEDENT ans += count ( pos + 1 , curr_cnt , curr_tet , ( dig != 0 ) , num ) NEW_LINE DEDENT return dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT num = [ ] NEW_LINE while x != 0 : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT del num NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( 2 ) : NEW_LINE INDENT for l in range ( 2 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT return count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT L , R = 11 , 100 NEW_LINE d = 2 NEW_LINE K = 1 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE DEDENT DEDENT
def test_test1 ( ) : NEW_LINE INDENT x = Symbol ( ' x ' ) NEW_LINE y = Symbol ( ' y ' ) NEW_LINE assert x . is_integer is True NEW_LINE assert x . is_rational is True NEW_LINE assert x . is_algebraic is True NEW_LINE assert x . is_transcendental is True NEW_LINE assert x . is_real is True NEW_LINE assert x . is_complex is True NEW_LINE assert x . is_noninteger is True NEW_LINE assert x . is_integer is False NEW_LINE assert x . is_rational is False NEW_LINE assert x . is_algebraic is False NEW_LINE assert x . is_transcendental is False NEW_LINE assert x . is_real is False NEW_LINE assert x . is_complex is False NEW_LINE assert x . is_noninteger is False NEW_LINE assert x . is_integer is False NEW_LINE assert x . is_rational is False NEW_LINE assert x . is_algebraic is False NEW_LINE assert x . is_transcendental is False NEW_LINE assert x . is_real is False NEW_LINE assert x . is_complex is False NEW_LINE assert x . is_noninteger is False NEW_LINE assert x . is_integer is False NEW_LINE assert x . is_rational is False NEW_LINE assert x . is_algebraic is False NEW_LINE assert x . is_transcendental is False NEW_LINE assert x . is_real is False NEW_LINE assert x . is_complex is False NEW_LINE assert x . is_noninteger is False NEW_LINE assert x . is_integer is False NEW_LINE assert x . is_rational is False NEW_LINE assert x . is_algebraic is False NEW_LINE assert x . is_complex is False NEW_LINE assert x . is_noninteger is False NEW_LINE assert x . is_integer is False NEW_LINE assert x . is_rational is False NEW_LINE assert x . is_algebraic is False NEW_LINE assert x . is_transcendental is False NEW_LINE assert x . is_noninteger is False NEW_LINE assert x . is_integer is False NEW_LINE assert x . is_rational is False NEW_LINE assert x . is_noninteger is False NEW_LINE assert x . is_rational is False NEW_LINE assert x . is_algebraic is False NEW_LINE assert x . is_transcendental is False NEW_LINE assert x . is_noninteger is False NEW_LINE assert x . is_real is False NEW_LINE assert x . is_complex is False NEW_LINE assert x . is_noninteger is False NEW_LINE assert x . is_rational is False NEW_LINE assert x . is_real is False NEW_LINE assert x . is_complex is False NEW_LINE assert x . is_noninteger is False NEW_LINE DEDENT
def get_GFG ( arr , n , num , i , j ) : NEW_LINE INDENT if i >= 0 and arr [ i ] > num : NEW_LINE INDENT return False NEW_LINE DEDENT if j < n and arr [ j ] > num : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def is_trough ( arr , n , num , i , j ) : NEW_LINE INDENT if i >= 0 and arr [ i ] < num : NEW_LINE INDENT return False NEW_LINE DEDENT if j < n and arr [ j ] < num : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def print_peeks_troughs ( arr , n ) : NEW_LINE INDENT print ( " Peaks ▁ : ▁ " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if is_peak ( arr , n , arr [ i ] , i - 1 , i + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE print ( " Troughs ▁ : ▁ " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if is_trough ( arr , n , arr [ i ] , i - 1 , i + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( i ) : NEW_LINE INDENT return 1 + ( i >> 31 ) - ( - i >> 31 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = [ 0 , 5 , 5 , 5 , 4 ] NEW_LINE x = 5 NEW_LINE n = len ( a ) NEW_LINE assert frequency ( a , n , x ) == 0 NEW_LINE DEDENT
def main ( num ) : NEW_LINE INDENT num = abs ( num ) NEW_LINE str = num + ' ' NEW_LINE ch_arr = str . split ( ) NEW_LINE hs = set ( ) NEW_LINE for ch in ch_arr : NEW_LINE INDENT hs . add ( ch ) NEW_LINE DEDENT str_len = len ( str ) NEW_LINE hs_len = len ( hs ) NEW_LINE if hs_len <= str_len / 2 or hs_len == str_len : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n * i <= n , 6 ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def p_p065 ( p ) : NEW_LINE INDENT """ p065 ▁ : ▁ DIVIDE """ NEW_LINE p [ 0 ] = p [ 1 ] / p [ 2 ] NEW_LINE n = p [ 1 ] NEW_LINE d = p [ 2 ] NEW_LINE for i in range ( 99 , - 1 , - 1 ) : NEW_LINE INDENT temp = eval ( ' % s ▁ * ▁ % s ▁ + ▁ % s ' % ( _continued_fraction_term ( i ) , n , d ) ) NEW_LINE d = n NEW_LINE n = temp NEW_LINE DEDENT sum = 0 NEW_LINE while not n . is_infinite ( ) : NEW_LINE INDENT divrem = n . divide_and_remainder ( ) NEW_LINE sum += divrem [ 1 ] . value NEW_LINE n = divrem [ 0 ] NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT
def __gcd ( n , x , y , z ) : NEW_LINE INDENT if not b : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT MAXN = 100001 NEW_LINE prime = [ False ] * MAXN NEW_LINE SieveOfEratosthenes ( ) NEW_LINE for i in prime : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAXN * p ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , MAXN , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT common_prime = int ( __gcd ( a , b ) ) NEW_LINE for i in range ( 2 , ( gcd ( a , b ) ) ) : NEW_LINE INDENT if prime [ i ] and gcd ( a , b ) % i == 0 : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT __gcd ( a , b ) NEW_LINE if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return __gcd ( b % a , a ) NEW_LINE DEDENT
def py ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT n = len ( args ) NEW_LINE s , l , p = [ ] , [ ] , [ ] NEW_LINE for o , a in opts : NEW_LINE INDENT if o == ' - - n ' : n = int ( a ) NEW_LINE if o == ' - - s ' : s = a NEW_LINE if o == ' - - l ' : l = a NEW_LINE if o == ' - - p ' : p = a NEW_LINE if o == ' - - d ' : d = a NEW_LINE if o == ' - - d ' : d = a NEW_LINE if o == ' - - d - e ' : d = a NEW_LINE if o == ' - - d - f ' : d = a NEW_LINE if o == ' - - d - h ' : d = a NEW_LINE if o == ' - - d - l ' : d = a NEW_LINE if o == ' - - d - f ' : d = a NEW_LINE if o == ' - - d - h ' : d = a NEW_LINE if o == ' - - d - f ' : d = a NEW_LINE if o == ' - - d - e ' : d = a NEW_LINE if o == ' - - d - f ' : d = a NEW_LINE if o == ' - - d - l ' : d = a NEW_LINE if o == ' - - d - f ' : d = a NEW_LINE if o == ' - - d - h ' : d = a NEW_LINE if o == ' - - d - f ' : d = a NEW_LINE if o == ' - - d - e ' : d = a NEW_LINE if o == ' - - d - f ' : d = a NEW_LINE if o == ' - - d - h ' : d = a NEW_LINE if o == ' - - d - f ' : d = a NEW_LINE if o == ' - - d - h ' : d = a NEW_LINE if o == ' - - d - f ' : d = a NEW_LINE if o == ' - - d - f ' : d = a NEW_LINE if o == ' - - d - f ' : d = a NEW_LINE DEDENT if not args : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in args : NEW_LINE INDENT print ( i
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT g = getopt . getopt ( sys . argv [ 1 : ] , ' a ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT a = 0 NEW_LINE o = 0 NEW_LINE for w in g [ 1 : ] : NEW_LINE INDENT if w == p : NEW_LINE INDENT continue NEW_LINE DEDENT r = max_matching ( w , v ) NEW_LINE a += r // 2 NEW_LINE o += r % 2 NEW_LINE DEDENT return 2 * a + min ( 1 , o ) + 1 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT N , M = 205 , 205 NEW_LINE grid = [ [ 0 ] * M ] * M NEW_LINE t = time . time ( ) NEW_LINE while t > 0 : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n , m = int ( time . time ( ) ) , int ( time . time ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = input ( ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT grid [ i ] [ j ] = line [ j ] - '0' NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( m - 1 ) : NEW_LINE INDENT sum = grid [ i ] [ j ] + grid [ i + 1 ] [ j ] + grid [ i ] [ j + 1 ] + grid [ i + 1 ] [ j + 1 ] NEW_LINE if sum == 3 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE tc = 1 NEW_LINE while tc : NEW_LINE INDENT n , k = sys . argv [ 1 : ] NEW_LINE len = [ len ( s ) for s in sys . argv [ 2 : ] ] NEW_LINE s = ' ' NEW_LINE min , max = 0 , 0 NEW_LINE for s in sys . argv [ 2 : ] : NEW_LINE INDENT s = s . strip ( ) NEW_LINE len . append ( len ) NEW_LINE DEDENT p = sys . argv [ 3 : ] NEW_LINE plen = len ( p ) NEW_LINE kk = k NEW_LINE s = p . strip ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if len ( s ) == plen : NEW_LINE INDENT min += 1 NEW_LINE break NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE min += 1 NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT k = kk NEW_LINE min += 5 NEW_LINE DEDENT DEDENT k = kk NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( len ( s ) == plen and len ( s [ i + 1 ] ) > plen ) : NEW_LINE INDENT max += 1 NEW_LINE break NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT k -= 1 NEW_LINE max += 1 NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT k = kk NEW_LINE max += 5 NEW_LINE DEDENT DEDENT if len ( s ) == plen : NEW_LINE INDENT max += 1 NEW_LINE DEDENT sys . stdout . write ( min + ' ▁ ' + max ) NEW_LINE DEDENT sys . stdout . flush ( ) NEW_LINE DEDENT
def test_test ( ) : NEW_LINE INDENT f = np . random . RandomState ( 0 ) NEW_LINE word1 = f . randn ( 5 , 5 ) . astype ( ' float32' ) . astype ( ' float32' ) NEW_LINE word2 = f . randn ( 5 , 5 ) . astype ( ' float32' ) . astype ( ' float32' ) NEW_LINE word3 = f . randn ( 5 , 5 ) . astype ( ' float32' ) . astype ( ' float32' ) NEW_LINE perm1 = word1 + word2 + word3 NEW_LINE perm2 = word1 + word3 + word2 NEW_LINE perm3 = word2 + word1 + word3 NEW_LINE perm4 = word2 + word3 + word1 NEW_LINE perm5 = word3 + word2 + word1 NEW_LINE perm6 = word3 + word1 + word2 NEW_LINE students = f . randn ( 5 , 5 ) NEW_LINE f . shuffle ( ) NEW_LINE for i in range ( students ) : NEW_LINE INDENT test_case = f . randn ( 5 , 5 ) . astype ( ' float32' ) NEW_LINE if test_case in perm1 or test_case in perm2 or test_case in perm3 or test_case in perm4 or test_case in perm5 or test_case in perm6 : NEW_LINE INDENT print ( ' ACC ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' WA ' ) NEW_LINE DEDENT DEDENT DEDENT
def test_A ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE cases = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE for caze in range ( 1 , cases + 1 ) : NEW_LINE INDENT N , L = symbols ( ' N , L ' ) NEW_LINE need , have = set ( [ ] ) , set ( [ ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = x [ i ] NEW_LINE tmp2 = 0 NEW_LINE for j in range ( L ) : NEW_LINE INDENT if tmp [ j ] == '1' : NEW_LINE INDENT tmp2 |= ( 1 << j ) NEW_LINE DEDENT DEDENT have . add ( tmp2 ) NEW_LINE DEDENT last_needed = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = x [ i ] NEW_LINE tmp2 = 0 NEW_LINE for j in range ( L ) : NEW_LINE INDENT if tmp [ j ] == '1' : NEW_LINE INDENT tmp2 |= ( 1 << j ) NEW_LINE DEDENT DEDENT need . add ( tmp2 ) NEW_LINE last_needed = tmp2 NEW_LINE DEDENT ans = L + 1 NEW_LINE for elem in have : NEW_LINE INDENT flip = last_needed ^ elem NEW_LINE got = set ( [ e ^ flip for e in need ] ) NEW_LINE if got == have : NEW_LINE INDENT ans = min ( ans , key = lambda x : x . bit_length ( ) ) NEW_LINE DEDENT DEDENT assert ans == L NEW_LINE DEDENT DEDENT
def maxAreaOfIsland ( grid ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ maximum ▁ area ▁ of ▁ Island , ▁ 0 ▁ if ▁ the ▁ grid ▁ is ▁ empty . STRNEWLINE ▁ """ NEW_LINE dr = [ 1 , - 1 , 0 , 0 ] NEW_LINE dc = [ 0 , 0 , 1 , - 1 ] NEW_LINE ans = 0 NEW_LINE for r0 in range ( len ( grid ) ) : NEW_LINE INDENT for c0 in range ( len ( grid [ 0 ] ) ) : NEW_LINE INDENT if grid [ r0 ] [ c0 ] == 1 : NEW_LINE INDENT shape = 0 NEW_LINE stack = [ [ r0 , c0 ] ] NEW_LINE grid [ r0 ] [ c0 ] = 0 NEW_LINE while not stack . empty ( ) : NEW_LINE INDENT node = stack . pop ( ) NEW_LINE r , c = node [ 0 ] , node [ 1 ] NEW_LINE shape += 1 NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT nr = r + dr [ k ] NEW_LINE nc = c + dc [ k ] NEW_LINE if 0 <= nr < len ( grid ) and 0 <= nc < len ( grid [ 0 ] ) and grid [ nr ] [ nc ] == 1 : NEW_LINE INDENT stack . append ( ( nr , nc ) ) NEW_LINE grid [ nr ] [ nc ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = max ( ans , shape ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def GFG ( x , y , n ) : NEW_LINE INDENT sum1 = int ( ( pow ( x , 2 ) * ( pow ( x , 2 * n ) - 1 ) ) / ( pow ( x , 2 ) - 1 ) ) NEW_LINE sum2 = int ( ( x * y * ( pow ( x , n ) * pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) NEW_LINE return sum1 , sum2 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 3 NEW_LINE assert find_sum ( n ) == 3 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 687 NEW_LINE assert gf_degree ( n ) == 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 687 NEW_LINE assert gf_degree ( n ) == 1 NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT class Node : NEW_LINE INDENT data = 0 NEW_LINE next = 0 NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref , new_node ) NEW_LINE ( head_ref , new_node ) = new_node NEW_LINE return head_ref , new_node NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n * i <= n , 6 ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def delete_non_prime_nodes ( head_ref ) : NEW_LINE INDENT ptr = head_ref NEW_LINE while ptr and not is_prime ( ptr . data ) : NEW_LINE INDENT temp = ptr NEW_LINE ptr = ptr . next NEW_LINE DEDENT head_ref = ptr NEW_LINE if not ptr : NEW_LINE INDENT return None NEW_LINE DEDENT curr = ptr . next NEW_LINE while curr : NEW_LINE INDENT if not is_prime ( curr . data ) : NEW_LINE INDENT ptr . next = curr . next NEW_LINE curr = ptr . next NEW_LINE DEDENT else : NEW_LINE INDENT ptr = curr NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT return head_ref NEW_LINE DEDENT def print_list ( head ) : NEW_LINE INDENT while head : NEW_LINE INDENT print ( head . data , end = ' ▁ ' ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 17 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 16 ) NEW_LINE head = push ( head , 15 ) NEW_LINE print ( " Original ▁ List : ▁ " ) NEW_LINE print_list ( head ) NEW_LINE head = delete_non_prime_nodes ( head ) NEW_LINE print ( " \n Modified ▁ List : ▁ " ) NEW_LINE print_list ( head ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( msg + ' \n ' ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT N , M , L = int ( args [ 0 ] ) , int ( args [ 1 ] ) NEW_LINE cs = [ ] NEW_LINE for i in range ( N * M ) : NEW_LINE INDENT cs . append ( [ ] ) NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT D , A , K , T = divmod ( D , N - 1 ) NEW_LINE start = D * N + A NEW_LINE cs [ start ] . append ( ( K << 16 ) | T ) NEW_LINE DEDENT dp = [ ] NEW_LINE for i in range ( L + 1 ) : NEW_LINE INDENT for j in range ( L ) : NEW_LINE INDENT for c in cs [ i ] : NEW_LINE INDENT len = c >> 16 NEW_LINE t = c & 0xFFFF NEW_LINE dp . append ( max ( dp [ j + 1 ] [ i + len ] , dp [ j ] [ i ] + t ) ) NEW_LINE DEDENT DEDENT for j in range ( 0 , L + 1 ) : NEW_LINE INDENT dp . append ( max ( dp [ j ] [ i + 1 ] , dp [ j ] [ i ] ) ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 0 , L + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ N * M ] ) NEW_LINE DEDENT sys . stdout . write ( ans + ' \n ' ) NEW_LINE DEDENT
def test_main ( ) : NEW_LINE INDENT from sympy . abc import n , m NEW_LINE boxs = [ ] NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE boxs . append ( Box ( ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE h , w = sys . argv [ 1 : ] NEW_LINE list = [ ] NEW_LINE max = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT arr = sys . stdin . readline ( ) . split ( ) NEW_LINE for j in range ( w ) : NEW_LINE INDENT if arr [ j ] == ' . ' : NEW_LINE INDENT continue NEW_LINE DEDENT for x in list : NEW_LINE INDENT hh = x // w NEW_LINE ww = x % w NEW_LINE max = max ( max , abs ( i - hh ) + abs ( j - ww ) ) NEW_LINE DEDENT list . append ( i * w + j ) NEW_LINE DEDENT DEDENT sys . stdout . write ( max ) NEW_LINE DEDENT
def GFG ( str ) : NEW_LINE INDENT if len ( str ) > 26 : NEW_LINE INDENT print ( ' IMPOSSIBLE ' ) NEW_LINE DEDENT else : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT hash [ str [ i ] - ' a ' ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if hash [ str [ i ] - ' a ' ] > 1 : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT if hash [ j ] == 0 : NEW_LINE INDENT hash [ str [ i ] - ' a ' ] -= 1 NEW_LINE str = str [ : i ] + chr ( j + ' a ' ) + str [ i + 1 : ] NEW_LINE hash [ j ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( str ) NEW_LINE DEDENT DEDENT
def GFG ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_0 = [ 0 ] * ( n + 2 ) NEW_LINE pre_count_1 = [ 0 ] * ( n + 1 ) NEW_LINE post_count_0 = [ 0 ] * ( n + 2 ) NEW_LINE pre_count_0 [ 0 ] = 0 NEW_LINE post_count_0 [ n + 1 ] = 0 NEW_LINE pre_count_1 [ 0 ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pre_count_0 [ j ] = pre_count_0 [ j - 1 ] NEW_LINE pre_count_1 [ j ] = pre_count_1 [ j - 1 ] NEW_LINE post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] NEW_LINE if s [ j - 1 ] == '0' : NEW_LINE INDENT pre_count_0 [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre_count_1 [ j ] += 1 NEW_LINE DEDENT if s [ n - j ] == '0' : NEW_LINE INDENT post_count_0 [ n - j + 1 ] += 1 NEW_LINE DEDENT DEDENT if pre_count_0 [ n ] == n or pre_count_0 [ n ] == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , 0 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT prime = [ False for i in range ( 2 , N + 1 , 2 ) ] NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if prime [ i ] == False : NEW_LINE INDENT s = [ i for i in range ( i , N * i , 2 ) if prime [ i * j ] == False ] NEW_LINE for j in range ( i , N * i , 2 ) : NEW_LINE INDENT if prime [ i * j ] == False : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s . append ( i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT generatePrimeFactors ( N ) NEW_LINE print ( " Factor ▁ Power " ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while N > 1 : NEW_LINE INDENT N /= s [ N ] NEW_LINE if curr == s [ N ] : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT print ( curr , ' \ t ' , cnt ) NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT
def GFG ( a , n ) : NEW_LINE INDENT hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while num != 0 : NEW_LINE INDENT hash [ i ] [ num % 10 ] = 1 NEW_LINE num /= 10 NEW_LINE DEDENT DEDENT longest = int ( ' - 1' ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT if hash [ i ] [ j ] == 1 & hash [ i + 1 ] [ j ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if j == 10 : NEW_LINE INDENT longest = max ( longest , count + 1 ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT longest = max ( longest , count + 1 ) NEW_LINE return longest NEW_LINE DEDENT
def test_1196A_ThreePilesOfCandies ( ) : NEW_LINE INDENT input = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE test = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE while test : NEW_LINE INDENT a , b , c = input NEW_LINE result = ( a + b + c ) / 2 NEW_LINE print ( result ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT c = [ ] NEW_LINE v = [ ] NEW_LINE while x % 2 == 0 : NEW_LINE INDENT c . append ( c ) NEW_LINE x /= 2 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = [ ] NEW_LINE while x % 3 == 0 : NEW_LINE INDENT c . append ( c ) NEW_LINE x /= 3 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = [ ] NEW_LINE while x % 7 == 0 : NEW_LINE INDENT c . append ( c ) NEW_LINE x /= 7 NEW_LINE DEDENT v . append ( c ) NEW_LINE v . append ( x ) NEW_LINE return v NEW_LINE DEDENT
def genGFG ( N ) : NEW_LINE INDENT N = 1000001 NEW_LINE c , n , m , a , b = N NEW_LINE dfs ( a , b , v , vis ) NEW_LINE vis [ a ] = 1 NEW_LINE c += 1 NEW_LINE for i in v [ a ] : NEW_LINE INDENT if vis [ i ] == 0 and i != b : NEW_LINE INDENT dfs ( i , b , v , vis ) NEW_LINE DEDENT DEDENT Calculate ( v ) NEW_LINE ans1 = n - c - 1 NEW_LINE del vis [ a ] NEW_LINE del vis [ b ] NEW_LINE ans2 = n - c - 1 NEW_LINE print ( ans1 * ans2 , end = ' ▁ ' ) NEW_LINE DEDENT
def B_Nirvana ( ) : NEW_LINE INDENT import sys NEW_LINE import tokenize NEW_LINE import string NEW_LINE import random NEW_LINE import time NEW_LINE import string NEW_LINE import random NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import
def test_helloworld ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE a = symbols ( ' a ' , integer = True , positive = True ) NEW_LINE b = symbols ( ' b ' , integer = True , positive = True ) NEW_LINE res = a NEW_LINE while a >= b : NEW_LINE INDENT res += ( a / b ) NEW_LINE a = ( a / b ) + ( a % b ) NEW_LINE DEDENT assert res == a NEW_LINE DEDENT
def get_gcd ( n ) : NEW_LINE INDENT """ Return ▁ the ▁ gcd ▁ of ▁ the ▁ given ▁ integer . """ NEW_LINE sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n / 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def pylint_power ( a ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ power ▁ of ▁ a ▁ number . STRNEWLINE STRNEWLINE ▁ > > > ▁ pylint _ power ( 10 ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ pylint _ power ( 10 ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ pylint _ power ( 10 ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ pylint _ power ( 10 ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ pylint _ power ( 10 ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ pylint _ power ( 10 ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ pylint _ power ( 10 ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ pylint _ power ( 10 ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ pylint _ power ( 10 ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ pylint _ power ( 10 ) STRNEWLINE ▁ 3 STRNEWLINE ▁ > > > ▁ pylint _ power ( 10 ) STRNEWLINE ▁ 3 STRNEWLINE ▁ """ NEW_LINE a = long ( a ) NEW_LINE res = 0 NEW_LINE while a > 0 : NEW_LINE INDENT res += 1 NEW_LINE a = a / 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
def main ( request , response ) : NEW_LINE INDENT headers = [ ( " Content - type " , " text / plain " ) ] NEW_LINE content = " " NEW_LINE response . headers . set ( " Content - Length " , len ( content ) ) NEW_LINE response . headers . set ( " Content - Type " , " text / plain " ) NEW_LINE response . headers . set ( " Access - Control - Allow - Origin " , " * " ) NEW_LINE response . headers . set ( " Access - Control - Allow - Methods " , " GET , ▁ POST , ▁ PUT , ▁ DELETE " ) NEW_LINE response . headers . set ( " Access - Control - Allow - Headers " , " x - user - agent " ) NEW_LINE response . headers . set ( " Access - Control - Allow - Methods " , " OPTIONS , ▁ PATCH , ▁ POST , ▁ PUT " ) NEW_LINE response . headers . set ( " Access - Control - Allow - Headers " , " x - user - agent " ) NEW_LINE response . headers . set ( " Access - Control - Expose - Headers " , " x - user - agent " ) NEW_LINE response . headers . set ( " Access - Control - Allow - Methods " , " OPTIONS , ▁ PATCH , ▁ POST " ) NEW_LINE response . headers . set ( " Access - Control - Expose - Headers " , " x - user - agent " ) NEW_LINE response . headers . set ( " Access - Control - Allow - Headers " , " x - user - agent " ) NEW_LINE response . headers . set ( " Access - Control - Expose - Headers " , " x - user - agent " ) NEW_LINE response . headers . set ( " Access - Control - Allow - Methods " , " OPTIONS , ▁ PATCH , ▁ POST , ▁ PUT " ) NEW_LINE response . headers . set ( " Access - Control - Expose - Headers " , " x - user - agent " ) NEW_LINE response . headers . set ( " Access - Control - Allow - Headers " , " x - user - agent " ) NEW_LINE response . headers . set ( " Access - Control - Expose - Headers " , " x - user - agent " ) NEW_LINE response . headers . set ( " Access - Control - Allow - Methods " , " OPTIONS , ▁ PATCH , ▁ PUT , ▁ DELETE " ) NEW_LINE response . headers . set ( " Access - Control - Expose - Headers " , " x - user - agent " ) NEW_LINE response . headers . set ( " Access - Control - Allow - Methods " , " OPTIONS " ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ degree ▁ of ▁ the ▁ first ▁ degree ▁ of ▁ the ▁ first ▁ group . """ NEW_LINE sr = sqrt ( x ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE assert ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT
def test_iter_allocate_output_iterator ( ) : NEW_LINE INDENT s = '111111101010101111100101001111111 ▁ 100000100000000001010110001000001 ▁ 101110100110110000011010001011101 ▁ 101110101011001001111101001011101 ▁ 101110101100011000111100101011101 ▁ 10000010101011010000101000001 ▁ 111111101010101010101010101111111 ▁ 000000001111101111100111100000000 ▁ 100010111100100001011110111111001 ▁ 110111001111111100100001000101100 ▁ 011100111010000101000111010001010 ▁ 011110000110001111110101100000011 ▁ 111111111111111000111001001011000 ▁ 11100001011101001101001101100 ▁ 101010100010110010110101010000010 ▁ 101100000101010001111101000000000 ▁ 000010100011001101000111101011010 ▁ 101001001111101111000101010001110 ▁ 101101111111000100100001110001000 ▁ 000010011000100110000011010000010 ▁ 001101101001101110010010011011000 ▁ 011101011010001000111101010100110 ▁ 111010100110011101001101000001110 ▁ 110001010010101111000101111111000 ▁ 001000111011100001010110111110000 ▁ 000000001110010110100010100010110 ▁ 111111101000101111000110101011010 ▁ 100000100111010101111100100011011 ▁ 101110101001010000101000111111000 ▁ 101110100011010010010111011010 ▁ 101110100100011011110101110000 ▁ 100000100110011001111100100111100000 ▁ 111111101101000101001101110010001' NEW_LINE it = iter ( s ) NEW_LINE x , y = next ( it ) NEW_LINE assert x == 42 NEW_LINE assert y == 42 NEW_LINE DEDENT
def test_new_class_37 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE p = symbols ( ' p ' , integer = True , positive = True ) NEW_LINE while t . is_positive : NEW_LINE INDENT n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE count = 0 NEW_LINE x = n NEW_LINE if n < 10 : NEW_LINE INDENT assert n in t NEW_LINE continue NEW_LINE DEDENT while x in t : NEW_LINE INDENT count += 1 NEW_LINE x /= 10 NEW_LINE DEDENT first = 0 NEW_LINE while count > 0 : NEW_LINE INDENT first = first * 10 + 1 NEW_LINE count -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE if first <= n : NEW_LINE INDENT sum += n / first NEW_LINE DEDENT first /= 10 NEW_LINE while first : NEW_LINE INDENT sum += 9 NEW_LINE first /= 10 NEW_LINE DEDENT assert sum in t NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ symbolic ▁ representation ▁ of ▁ the ▁ GFG . """ NEW_LINE n = 1 NEW_LINE for i in range ( 2 , n ** 2 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT n = sum ( [ i + n // i for i in range ( n ) ] ) NEW_LINE DEDENT DEDENT assert n == 1 NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n , 1 ) NEW_LINE assert are_equivalent ( n
def test_GFG ( ) : NEW_LINE INDENT x = 5 NEW_LINE assert find_y ( x ) == 5 NEW_LINE DEDENT
def GFG ( n , m ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT a = input ( " Enter ▁ n ▁ of ▁ the ▁ matrix : ▁ " ) NEW_LINE n = len ( a ) NEW_LINE A = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT A . append ( a [ i ] ) NEW_LINE DEDENT minj = None NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT minj = i NEW_LINE c = 0 NEW_LINE for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT if A [ j ] < A [ minj ] : NEW_LINE INDENT minj = j NEW_LINE c = 1 NEW_LINE DEDENT DEDENT if c == 1 : NEW_LINE INDENT x = A [ i ] NEW_LINE A [ i ] , A [ minj ] = A [ minj ] , A [ minj ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] ) NEW_LINE if i < n - 1 : NEW_LINE INDENT print ( " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE print ( count ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global w , h , v NEW_LINE w = int ( sys . argv [ 1 ] ) NEW_LINE h = int ( sys . argv [ 2 ] ) NEW_LINE map = [ [ 0 ] * ( h + 2 ) , [ 0 ] * ( w + 2 ) ] NEW_LINE v = [ [ 0 ] * ( h + 2 ) , [ 0 ] * ( w + 2 ) ] NEW_LINE for i in range ( 1 , h + 1 ) : NEW_LINE INDENT for j in range ( 1 , w + 1 ) : NEW_LINE INDENT map [ i ] [ j ] = sys . argv [ 3 ] == 1 NEW_LINE DEDENT DEDENT print ( slove ( 0 , 0 ) ) NEW_LINE DEDENT
def test_prepformerge ( ) : NEW_LINE INDENT f = BytesIO ( ) NEW_LINE f . seek ( 0 ) NEW_LINE n = int ( f . readline ( ) ) NEW_LINE lists = [ ] NEW_LINE a = [ ] NEW_LINE f . seek ( 0 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a . append ( int ( f . readline ( ) ) ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT start = [ a [ i ] ] NEW_LINE lists . append ( start ) NEW_LINE DEDENT else : NEW_LINE INDENT lo = 0 NEW_LINE hi = len ( lists ) - 1 NEW_LINE if lists [ hi ] [ lists [ hi ] [ - 1 ] ] > a [ i ] : NEW_LINE INDENT start = [ a [ i ] ] NEW_LINE lists . append ( start ) NEW_LINE DEDENT else : NEW_LINE INDENT while lo != hi : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE if lists [ mid ] [ lists [ mid ] [ - 1 ] ] < a [ i ] : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT lists [ lo ] . append ( a [ i ] ) NEW_LINE DEDENT DEDENT DEDENT for lis in lists : NEW_LINE INDENT for i in range ( len ( lis ) ) : NEW_LINE INDENT print ( lis [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = float ( ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ) NEW_LINE return A NEW_LINE DEDENT
def GFG ( arr , length , s ) : NEW_LINE INDENT for i in range ( 1 , ( pow ( 2 , length ) ) + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( ( i >> j ) & 1 ) % 2 == 1 : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT DEDENT if sum == s : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' NO ' ) NEW_LINE DEDENT
def GFG ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE fre = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT fre [ s [ i ] - ' a ' ] += 1 NEW_LINE DEDENT str = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if fre [ i ] % k == 0 : NEW_LINE INDENT x = fre [ i ] / k NEW_LINE while x != 0 : NEW_LINE INDENT str += chr ( i + ' a ' ) NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while 1 : NEW_LINE INDENT n = input ( ) . count ( " > " ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT dp = np . zeros ( ( n + 1 , 25 ) ) NEW_LINE dp [ 0 ] [ 0 ] = 1.0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 24 ) : NEW_LINE INDENT pp = math . pow ( 2.0 , j ) NEW_LINE dp [ i + 1 ] [ j + 1 ] += dp [ i ] [ j ] * 1.0 / pp NEW_LINE dp [ i + 1 ] [ 0 ] += dp [ i ] [ j ] * ( 1.0 - ( 1.0 / pp ) ) NEW_LINE sum += j * dp [ i ] [ j ] * ( 1.0 - ( 1.0 / pp ) ) NEW_LINE DEDENT DEDENT for j in range ( 25 ) : NEW_LINE INDENT sum += j * dp [ n ] [ j ] NEW_LINE DEDENT print ( " % .20f " % sum ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE for c in sys . argv [ 1 : ] : NEW_LINE INDENT a , b , n = c . split ( ' ▁ ' ) NEW_LINE c = eval ( float ( a ) / b ) NEW_LINE f = [ ] NEW_LINE idx = c . find ( " . " ) NEW_LINE f . append ( eval ( c [ idx - 1 ] ) ) NEW_LINE for i in range ( 1 , min ( 200 , len ( c [ idx + 1 ] ) + 1 ) ) : NEW_LINE INDENT f . append ( eval ( c [ idx + i ] ) ) NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += f [ i ] NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( sys . argv [ i ] ) NEW_LINE DEDENT sys . argv = a NEW_LINE nodec = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT nodec = False NEW_LINE DEDENT DEDENT if nodec : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT m = 500 NEW_LINE l , r = 1 , 210000 NEW_LINE mid = 2 NEW_LINE dec = [ ] NEW_LINE out : NEW_LINE INDENT while r - l > 1 : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE dec = [ ] NEW_LINE del dec [ 0 ] NEW_LINE nout : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] and a [ i ] - 1 < m : NEW_LINE INDENT if dec [ a [ i ] - 1 ] < mid : NEW_LINE INDENT dec [ a [ i ] - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = a [ i ] - 1 NEW_LINE while pos > 0 : NEW_LINE INDENT dec [ pos - 1 ] += 1 NEW_LINE for j in range ( pos , m ) : NEW_LINE INDENT dec [ j ] = 1 NEW_LINE DEDENT if dec [ pos - 1 ] <= mid : NEW_LINE INDENT continue nout NEW_LINE DEDENT pos -= 1 NEW_LINE DEDENT l = mid NEW_LINE continue out NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( a [ i ] - 1 , m ) : NEW_LINE INDENT dec [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT r = mid NEW_LINE DEDENT print ( r ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global verbose NEW_LINE global recurse NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , " r " , [ " recurse " ] ) NEW_LINE DEDENT except getopt . error , msg : NEW_LINE INDENT sys . stdout . write ( msg + " \n " ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT if args == [ ] : NEW_LINE INDENT sys . stdout . write ( " No ▁ input ▁ files . \n " ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT N = int ( args [ 0 ] ) NEW_LINE K = int ( args [ 1 ] ) NEW_LINE if N == 0 and K == 0 : NEW_LINE INDENT return NEW_LINE DEDENT args = args [ : N ] NEW_LINE bloodAmt = [ ] NEW_LINE for o , a in opts : NEW_LINE INDENT if o == ' - r ' : NEW_LINE INDENT recurse = a NEW_LINE DEDENT elif o == ' - c ' : NEW_LINE INDENT recurse = None NEW_LINE DEDENT elif o == ' - d ' : NEW_LINE INDENT recurse = None NEW_LINE DEDENT elif o == ' - - recurse ' : NEW_LINE INDENT recurse = True NEW_LINE DEDENT elif o == ' - - recurse - amount ' : NEW_LINE INDENT recurse = int ( a ) NEW_LINE DEDENT elif o == ' - - recurse - amount - list ' : NEW_LINE INDENT recurse = int ( a ) NEW_LINE DEDENT elif o == ' - - recurse - amount - list ' : NEW_LINE INDENT recurse = int ( a ) NEW_LINE DEDENT DEDENT for i in range ( K ) : NEW_LINE INDENT if bloodAmt [ i ] < 0 : NEW_LINE INDENT print ( " No " ) NEW_LINE break NEW_LINE DEDENT if i == K - 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT DEDENT
def get_max_freq ( s , a , b ) : NEW_LINE INDENT fre = [ 0 ] * 10 NEW_LINE n = len ( s ) NEW_LINE if a > b : NEW_LINE INDENT temp = a NEW_LINE a , b = b , temp NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT fre [ s [ i ] - '0' ] += 1 NEW_LINE DEDENT if fre [ a ] == 0 and fre [ b ] == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif fre [ a ] >= fre [ b ] : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n == 0 or ( n & ( n - 1 ) ) == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT b = 4 NEW_LINE set_bit , prev = 1 , 0 NEW_LINE for i in range ( 1 , b * 8 ) : NEW_LINE INDENT prev += 1 NEW_LINE if ( n & set_bit ) == set_bit : NEW_LINE INDENT set_bit = set_bit << 1 NEW_LINE break NEW_LINE DEDENT set_bit = set_bit << 1 NEW_LINE DEDENT max0 , cur = int ( prev ) , prev NEW_LINE for j in range ( i + 1 , b * 8 ) : NEW_LINE INDENT cur += 1 NEW_LINE if ( n & set_bit ) == set_bit : NEW_LINE INDENT if max0 < ( cur - prev - 1 ) : NEW_LINE INDENT max0 , cur = cur - prev - 1 , cur NEW_LINE DEDENT prev , cur = cur , cur NEW_LINE DEDENT set_bit = set_bit << 1 NEW_LINE DEDENT return max0 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ sum ▁ of ▁ the ▁ powers ▁ of ▁ the ▁ polynomials ▁ of ▁ the ▁ form STRNEWLINE ▁ ( n , ▁ k ) . STRNEWLINE STRNEWLINE ▁ > > > ▁ from ▁ sympy . polys . distributedmodules ▁ import ▁ GFG STRNEWLINE ▁ > > > ▁ from ▁ sympy . polys . domains ▁ import ▁ ZZ STRNEWLINE ▁ > > > ▁ from ▁ sympy . polys . densebasic ▁ import ▁ dmp _ GFG STRNEWLINE ▁ > > > ▁ f ▁ = ▁ ZZ . map ( [ [ 1 , ▁ 2 ] , ▁ [ 3 , ▁ 4 ] ] ) STRNEWLINE ▁ > > > ▁ g ▁ = ▁ ZZ . map ( [ [ 1 , ▁ 2 ] , ▁ [ 3 , ▁ 4 ] ] ) STRNEWLINE ▁ > > > ▁ dmp _ GFG ( f , ▁ g ) STRNEWLINE ▁ ( 1 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ dmp _ GFG ( f , ▁ ZZ ( 2 ) , ▁ ZZ ( 3 ) ) STRNEWLINE ▁ ( 1 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ dmp _ GFG ( f , ▁ ZZ ( 4 ) , ▁ ZZ ( 2 ) ) STRNEWLINE ▁ ( 1 , ▁ 2 ) STRNEWLINE ▁ > > > ▁ dmp _ GFG ( f , ▁ ZZ ( 5 ) , ▁ ZZ ( 2 ) ) STRNEWLINE ▁ ( 1 , ▁ 2 ) STRNEWLINE ▁ """ NEW_LINE n , k = symbols ( ' n ▁ k ' , integer = True , cls = Dummy ) NEW_LINE sum , num = dmp_gf_power ( f , n , k , K ) NEW_LINE assert sum == num NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT A = 2 NEW_LINE B = 5 NEW_LINE C = 7 NEW_LINE D = 8 NEW_LINE rslt = xandYandZintercept ( A , B , C , D ) NEW_LINE assert np . allclose ( rslt , [ [ 0 , 1 , 2 ] , [ 3 , 4 , 5 ] , [ 6 , 7 , 8 ] ] ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT l = [ ] NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += abs ( a [ i ] ) NEW_LINE if a [ i ] >= 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE l . append ( i ) NEW_LINE DEDENT DEDENT assert s == 0 NEW_LINE for i in l : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def GFG ( str ) : NEW_LINE INDENT MAX = 1000 NEW_LINE def replace_spaces ( str ) : NEW_LINE INDENT space_count , i = 0 , 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] == ' ▁ ' : NEW_LINE INDENT space_count += 1 NEW_LINE DEDENT DEDENT while str [ i - 1 ] == ' ▁ ' : NEW_LINE INDENT space_count -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT new_length = i + space_count * 2 NEW_LINE if new_length > MAX : NEW_LINE INDENT return str NEW_LINE DEDENT index = new_length - 1 NEW_LINE new_str = str [ : index ] NEW_LINE str = str [ index : ] NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if new_str [ j ] == ' ▁ ' : NEW_LINE INDENT str [ index ] = '0' NEW_LINE str [ index - 1 ] = '2' NEW_LINE str [ index - 2 ] = ' % ' NEW_LINE index = index - 3 NEW_LINE DEDENT else : NEW_LINE INDENT str [ index ] = new_str [ j ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT def replace_string ( str ) : NEW_LINE INDENT str = ' Mr ▁ John ▁ Smith ▁ ' . join ( str ) NEW_LINE str = replace_spaces ( str ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import doctest NEW_LINE import os NEW_LINE import tempfile NEW_LINE import time NEW_LINE import re NEW_LINE import string NEW_LINE import doctest NEW_LINE class B ( object ) : NEW_LINE INDENT def doIt ( self ) : NEW_LINE INDENT n = len ( self . str ) NEW_LINE self . str = self . str [ : n ] NEW_LINE ctr = self . str [ n : ] NEW_LINE m = len ( self . str ) NEW_LINE num = n NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT s . append ( ctr [ i ] ) NEW_LINE DEDENT elif m < num : NEW_LINE INDENT if ctr [ i ] == '0' : NEW_LINE INDENT s . append ( 1 ) NEW_LINE m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ctr [ i ] == '0' : NEW_LINE INDENT s . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( 0 ) NEW_LINE DEDENT DEDENT num -= 1 NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT m = n NEW_LINE while n != 0 : NEW_LINE INDENT r = n % 10 NEW_LINE if r : NEW_LINE INDENT if ( m % r ) != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n /= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def main ( agrs ) : NEW_LINE INDENT a = int ( agrs [ 0 ] ) NEW_LINE b = int ( agrs [ 1 ] ) NEW_LINE if a == b : NEW_LINE INDENT print ( a * 10 + 1 , ( a * 10 + 2 ) ) NEW_LINE DEDENT elif a + 1 == b : NEW_LINE INDENT print ( a , b ) NEW_LINE DEDENT elif a + 1 == b * 10 : NEW_LINE INDENT print ( a , b * 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def test_python_application_115 ( ) : NEW_LINE INDENT import sys NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE DEDENT
def test_hw19 ( ) : NEW_LINE INDENT f = BytesIO ( ) NEW_LINE try : NEW_LINE INDENT f . read ( ) NEW_LINE DEDENT finally : NEW_LINE INDENT f . close ( ) NEW_LINE DEDENT i = int ( str ( f . read ( ) ) ) NEW_LINE if len ( f . read ( 1 ) ) > 1 and ( int ( str ( f . read ( 1 ) ) ) * 10 + i ) % 4 == 0 : NEW_LINE INDENT assert 4 == i NEW_LINE DEDENT elif len ( f . read ( 1 ) ) == 1 and i % 4 == 0 : NEW_LINE INDENT assert 4 == i NEW_LINE DEDENT else : NEW_LINE INDENT assert 0 NEW_LINE DEDENT DEDENT
def test_pre5 ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import string NEW_LINE import random NEW_LINE import string . ascii_lowercase NEW_LINE import string . digits NEW_LINE import string . ascii_uppercase NEW_LINE import string . ascii_lowercase NEW_LINE import string . digits NEW_LINE import string . ascii_lowercase NEW_LINE import string . digits NEW_LINE import string . ascii_uppercase NEW_LINE import string . ascii_lowercase NEW_LINE import string . digits NEW_LINE import string . ascii_uppercase NEW_LINE import string . digits NEW_LINE import string . ascii_lowercase NEW_LINE import string . digits NEW_LINE import string . ascii_uppercase NEW_LINE import string . digits NEW_LINE import string . ascii_lowercase NEW_LINE import string . digits NEW_LINE import string . ascii_lowercase NEW_LINE import string . digits NEW_LINE import string . ascii_uppercase NEW_LINE import string . digits NEW_LINE import string . ascii_lowercase NEW_LINE import string . digits NEW_LINE import string . ascii_uppercase NEW_LINE import string . digits NEW_LINE import string . ascii_lowercase NEW_LINE import string . digits NEW_LINE import string . ascii_lowercase NEW_LINE import string . digits NEW_LINE import string . ascii_uppercase NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE import string . digits NEW_LINE DEDENT
def test_B940 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE N = symbols ( ' N ' , integer = True , positive = True ) NEW_LINE K = symbols ( ' K ' , integer = True , positive = True ) NEW_LINE A = symbols ( ' A ' , integer = True , positive = True ) NEW_LINE B = symbols ( ' B ' , integer = True , positive = True ) NEW_LINE cost = 0 NEW_LINE while N != 1 : NEW_LINE INDENT if N < K : NEW_LINE INDENT cost += ( N - 1 ) * A NEW_LINE break NEW_LINE DEDENT r = N % K NEW_LINE cost += r * A NEW_LINE N -= r NEW_LINE if B >= ( N - N / K ) * A : NEW_LINE INDENT cost += ( N - 1 ) * A NEW_LINE break NEW_LINE DEDENT cost += B NEW_LINE N /= K NEW_LINE DEDENT assert cost == 0 NEW_LINE DEDENT
def test_gfg ( ) : NEW_LINE INDENT class GfG ( object ) : NEW_LINE INDENT def digsum ( self ) : NEW_LINE INDENT sum = 0 NEW_LINE while self . n or sum > 9 : NEW_LINE INDENT if self . n == 0 : NEW_LINE INDENT self . n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum += self . n % 10 NEW_LINE self . n /= 10 NEW_LINE DEDENT DEDENT DEDENT assert gfg ( ) == 0 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n , m = sys . argv [ 1 ] , sys . argv [ 2 ] NEW_LINE a , b = sys . argv [ 3 ] , sys . argv [ 4 ] NEW_LINE dp = [ [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m
def test_GFG ( ) : NEW_LINE INDENT n = 5 NEW_LINE assert n == 1 NEW_LINE assert n == 2 NEW_LINE assert n == 3 NEW_LINE assert n == 4 NEW_LINE assert n == 5 NEW_LINE assert n == 6 NEW_LINE assert n == 7 NEW_LINE assert n == 8 NEW_LINE assert n == 9 NEW_LINE assert n == 10 NEW_LINE assert n == 11 NEW_LINE assert n == 12 NEW_LINE assert n == 13 NEW_LINE assert n == 14 NEW_LINE assert n == 15 NEW_LINE assert n == 16 NEW_LINE assert n == 17 NEW_LINE assert n == 18 NEW_LINE assert n == 19 NEW_LINE assert n == 20 NEW_LINE assert n == 21 NEW_LINE assert n == 22 NEW_LINE assert n == 23 NEW_LINE assert n == 24 NEW_LINE assert n == 25 NEW_LINE assert n == 26 NEW_LINE assert n == 27 NEW_LINE assert n == 28 NEW_LINE assert n == 29 NEW_LINE assert n == 30 NEW_LINE assert n == 31 NEW_LINE assert n == 32 NEW_LINE assert n == 33 NEW_LINE assert n == 34 NEW_LINE assert n == 35 NEW_LINE assert n == 36 NEW_LINE assert n == 37 NEW_LINE assert n == 38 NEW_LINE assert n == 39 NEW_LINE assert n == 40 NEW_LINE assert n == 41 NEW_LINE assert n == 42 NEW_LINE assert n == n == n NEW_LINE assert n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n == n
def test_GFG ( ) : NEW_LINE INDENT arr = [ int ( i ) for i in range ( 10 ) ] NEW_LINE minvalue = min ( arr ) ; NEW_LINE xornum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xornum ^= ( minvalue ) ^ arr [ i ] NEW_LINE minvalue += 1 NEW_LINE DEDENT return xornum ^ minvalue NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE if n % 2 == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res . append ( chr ( 48 + i + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( chr ( 48 + i ) ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res . append ( chr ( 48 + i + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( chr ( 48 + i ) ) NEW_LINE DEDENT DEDENT res . append ( chr ( 48 + n - 2 ) ) NEW_LINE res . append ( chr ( 48 + n ) ) NEW_LINE res . append ( chr ( 48 + n - 1 ) ) NEW_LINE DEDENT res . append ( ' \ 0' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] ) NEW_LINE DEDENT DEDENT
def pygeeks ( a , n , K ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ number ▁ of ▁ elements ▁ in ▁ a ▁ and ▁ n ▁ in ▁ the ▁ graph . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ a ▁ : ▁ array _ like STRNEWLINE ▁ Input ▁ array . STRNEWLINE ▁ n ▁ : ▁ int STRNEWLINE ▁ Number ▁ of ▁ elements ▁ in ▁ the ▁ graph . STRNEWLINE ▁ K ▁ : ▁ int STRNEWLINE ▁ Number ▁ of ▁ elements ▁ in ▁ the ▁ graph . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ n ▁ : ▁ int STRNEWLINE ▁ Number ▁ of ▁ elements ▁ in ▁ the ▁ graph . STRNEWLINE STRNEWLINE ▁ See ▁ Also STRNEWLINE ▁ - - - - - STRNEWLINE ▁ pygeeks STRNEWLINE STRNEWLINE ▁ Examples STRNEWLINE ▁ - - - - - STRNEWLINE ▁ > > > ▁ from ▁ scipy . sparse ▁ import ▁ csr _ matrix , ▁ digraph STRNEWLINE ▁ > > > ▁ a ▁ = ▁ np . arange ( 4 ) STRNEWLINE ▁ > > > ▁ a [ 0 , ▁ 0 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 1 , ▁ 1 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 2 , ▁ 2 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 3 , ▁ 3 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 4 , ▁ 4 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 5 , ▁ 5 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 6 , ▁ 6 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 7 , ▁ 7 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 8 , ▁ 8 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 9 , ▁ 9 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 10 , ▁ 10 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 11 , ▁ 11 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 12 , ▁ 12 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 13 , ▁ 13 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 14 , ▁ 14 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 15 , ▁ 15 ] ▁ = ▁ 1 STRNEWLINE ▁ > > > ▁ a [ 16 , ▁ 16 ] ▁ = ▁ 1 STRNEWLINE ▁ """ NEW_LINE K = 3 NEW_LINE a = a .
def import ( ) : NEW_LINE INDENT import sys NEW_LINE h , w = sys . argv [ 1 ] NEW_LINE grid = [ ] NEW_LINE B , W = Boolean ( ) , Boolean ( ) NEW_LINE count_b , count_w = 0 , 0 NEW_LINE dx = [ 1 , - 1 , 0 , 0 ] NEW_LINE dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE from_to , to_to = sys . argv [ 2 : ] NEW_LINE count_grid = 0 NEW_LINE def solve ( ) : NEW_LINE INDENT f = sys . stdin . readline ( ) NEW_LINE while w != ' ' : NEW_LINE INDENT h , w = sys . argv [ 1 ] , sys . argv [ 2 ] NEW_LINE grid . append ( f . split ( ) ) NEW_LINE DEDENT count_b = 0 NEW_LINE count_w = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if grid [ i ] [ j ] == ' . ' : NEW_LINE INDENT B = False NEW_LINE W = False NEW_LINE count_grid = 0 NEW_LINE dfs ( j , i ) NEW_LINE if B and not W : NEW_LINE INDENT count_b += count_grid NEW_LINE DEDENT if not B and W : NEW_LINE INDENT count_w += count_grid NEW_LINE DEDENT DEDENT DEDENT print ( count_b , count_w ) NEW_LINE w = sys . argv [ 2 ] NEW_LINE DEDENT DEDENT def dfs ( x , y ) : NEW_LINE INDENT grid [ y ] [ x ] = ' x ' NEW_LINE count_grid += 1 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT nx = x + dx [ i ] NEW_LINE ny = y + dy [ i ] NEW_LINE if nx < w and nx >= 0 and ny < h and ny >= 0 : NEW_LINE INDENT if grid [ ny ] [ nx ] == ' B ' : NEW_LINE INDENT B = True NEW_LINE DEDENT elif grid [ ny ] [ nx ] == ' W ' : NEW_LINE INDENT W = True NEW_LINE DEDENT elif grid [ ny ] [ nx ] == ' . ' : NEW_LINE INDENT dfs ( nx , ny ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def test_vfe ( ) : NEW_LINE INDENT f = Poly ( x ** 2 + x + 1 , x ) NEW_LINE t = f . t NEW_LINE while t : NEW_LINE INDENT n = f . n NEW_LINE if 360 % ( 180 - n ) == 0 : NEW_LINE INDENT assert ' YES ' in f . as_expr ( ) NEW_LINE DEDENT else : NEW_LINE INDENT assert ' NO ' not in f . as_expr ( ) NEW_LINE DEDENT DEDENT DEDENT
def p_p493 ( p ) : NEW_LINE INDENT """ p493 ▁ : ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁ INTEGER ▁ ' : ' ▁
def exquo ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Compute ▁ the ▁ quotient ▁ of ▁ the ▁ landings ▁ of ▁ the ▁ current ▁ landings . STRNEWLINE ▁ """ NEW_LINE data = pd . read_csv ( ' landings _ data . csv ' , index_col = 0 ) NEW_LINE landings = data . index NEW_LINE time = data . columns [ ' time ' ] NEW_LINE minutes = [ ] NEW_LINE for i in range ( landings ) : NEW_LINE INDENT hours = data . index [ ' hours ' ] * 60 NEW_LINE minute = data . index [ ' minutes ' ] NEW_LINE minutes . append ( minute + hours ) NEW_LINE DEDENT if time + 1 <= minutes [ 0 ] : NEW_LINE INDENT print ( 0 , 0 , 0 ) NEW_LINE return NEW_LINE DEDENT for i in range ( landings - 1 ) : NEW_LINE INDENT if minutes [ i + 1 ] - minutes [ i ] >= 2 * time + 2 : NEW_LINE INDENT flight = minutes [ i ] + time + 1 NEW_LINE h = flight // 60 NEW_LINE m = flight % 60 NEW_LINE print ( h , m ) NEW_LINE return NEW_LINE DEDENT DEDENT flight = minutes [ landings - 1 ] + time + 1 NEW_LINE h = flight // 60 NEW_LINE m = flight % 60 NEW_LINE print ( h , m ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE k = len ( sys . argv ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT A = sys . argv [ i ] NEW_LINE B = sys . argv [ i + 1 ] NEW_LINE if B == 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE print ( A , A * B , ( B + 1 ) * A ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE from numpy . core import zeros NEW_LINE from numpy . testing import assert_equal , assert_array_equal NEW_LINE from numpy . testing . assert_equal import assert_equal NEW_LINE from numpy . testing . assert_array_equal import assert_array_equal NEW_LINE from numpy . testing . assert_equal import assert_equal NEW_LINE from numpy . testing . assert_equal import assert_equal NEW_LINE from numpy . testing import assert_equal NEW_LINE from numpy . testing import assert_equal NEW_LINE from numpy . testing import assert_equal NEW_LINE from numpy . testing import assert_equal NEW_LINE from numpy . testing import assert_raises NEW_LINE from numpy . testing import assert_raises NEW_LINE from numpy . testing import assert_raises NEW_LINE from numpy . testing import assert_equal NEW_LINE from numpy . testing import assert_raises NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_equal NEW_LINE from numpy . testing import assert_almost_equal NEW_LINE from numpy . testing import assert_raises NEW_LINE from numpy . testing import assert_raises NEW_LINE from numpy . testing import assert_raises NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import assert_raises NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE from numpy . testing import debug NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT print ( " The ▁ array ▁ should ▁ have " " ▁ atleast ▁ 4 ▁ elements " ) NEW_LINE DEDENT table1 = np . zeros ( ( n + 1 , n ) ) NEW_LINE table2 = np . zeros ( ( n , n ) ) NEW_LINE table3 = np . zeros ( ( n - 1 , n - 1 ) ) NEW_LINE table4 = np . zeros ( ( n - 2 , n - 2 ) ) NEW_LINE table1 [ : , 0 ] = np . inf NEW_LINE table2 [ : , 1 ] = np . inf NEW_LINE table3 [ : , 2 ] = np . inf NEW_LINE table4 [ : , 3 ] = np . inf NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT assert 3 * i ** ( i - 1 ) + 1 == 1 NEW_LINE DEDENT DEDENT
def main ( * args ) : NEW_LINE INDENT import sys NEW_LINE import string NEW_LINE import getopt NEW_LINE import re NEW_LINE import os NEW_LINE import ast NEW_LINE import ast . nodes NEW_LINE import ast . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes NEW_LINE import ast . nodes . nodes . nodes NEW_LINE DEDENT
def code_ninety_seven ( ) : NEW_LINE INDENT input = sys . stdin . readline ( ) NEW_LINE m = input . find ( ' Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ be ▁ tested . ' ) NEW_LINE n = input . find ( ' Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ be ▁ tested . ' ) NEW_LINE array_one = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT data = ' ' NEW_LINE if input . find ( ' Enter ▁ the ▁ string ▁ to ▁ be ▁ tested . ' ) != - 1 : NEW_LINE INDENT data = input . split ( ) [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT array_one . append ( data [ j ] ) NEW_LINE DEDENT DEDENT sumr = 0 NEW_LINE sumc = 0 NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if array_one [ i ] [ j ] == 66 : NEW_LINE INDENT sumr += i + 1 NEW_LINE count1 += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if array_one [ i ] [ j ] == 66 : NEW_LINE INDENT sumc += j + 1 NEW_LINE count2 += 1 NEW_LINE DEDENT DEDENT DEDENT print ( sumr / count1 , sumc / count2 ) NEW_LINE DEDENT
def GFG ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE if n == 0 : return NEW_LINE principalMin , principalMax = mat [ 0 ] , mat [ 0 ] [ 0 ] NEW_LINE secondaryMin , secondaryMax = mat [ n - 1 ] , mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT if mat [ i ] [ j ] < principalMin : principalMin = mat [ i ] [ j ] NEW_LINE if mat [ i ] [ j ] > principalMax : principalMax = mat [ i ] [ j ] NEW_LINE DEDENT if ( i + j ) == ( n - 1 ) : NEW_LINE INDENT if mat [ i ] [ j ] < secondaryMin : secondaryMin = mat [ i ] [ j ] NEW_LINE if mat [ i ] [ j ] > secondaryMax : secondaryMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ ▁ " + principalMin ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) NEW_LINE DEDENT
def GFG ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE if n == 0 : return NEW_LINE principalMin , principalMax = mat [ 0 ] , mat [ 0 ] [ 0 ] NEW_LINE secondaryMin , secondaryMax = mat [ n - 1 ] , mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] < principalMin : principalMin = mat [ i ] [ i ] NEW_LINE if mat [ i ] [ i ] > principalMax : principalMax = mat [ i ] [ i ] NEW_LINE if mat [ n - 1 - i ] [ i ] < secondaryMin : secondaryMin = mat [ n - 1 - i ] [ i ] NEW_LINE if mat [ n - 1 - i ] [ i ] > secondaryMax : secondaryMax = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ ▁ " + principalMin ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT print ( ' Invalid ▁ Input ' ) NEW_LINE return - 1 NEW_LINE DEDENT sum , count = 0 , 0 NEW_LINE while n >= 1 : NEW_LINE INDENT count += 1 NEW_LINE sum += n NEW_LINE n = n - 2 NEW_LINE DEDENT assert sum / count == 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT print ( ' Invalid ▁ Input ' ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 1 ) // 2 NEW_LINE DEDENT
def get_gfg ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE DEDENT count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while us . intersection ( curr_ele ) == True : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while us . intersection ( curr_ele ) == True : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count , ( us , curr_ele ) ) NEW_LINE DEDENT
def get_left_most_zero ( zero ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ left ▁ most ▁ zero ▁ of ▁ the ▁ given ▁ queue . STRNEWLINE ▁ """ NEW_LINE if not zero : NEW_LINE INDENT return - 1 NEW_LINE DEDENT zero . pop ( ) NEW_LINE return 0 NEW_LINE DEDENT def get_left_most_one ( one ) : NEW_LINE INDENT if not one : NEW_LINE INDENT return - 1 NEW_LINE DEDENT one . pop ( ) NEW_LINE return 1 NEW_LINE DEDENT def get_left_most_element ( zero , one ) : NEW_LINE INDENT if not zero and not one : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif not zero : NEW_LINE INDENT one . pop ( ) NEW_LINE return 1 NEW_LINE DEDENT elif not one : NEW_LINE INDENT zero . pop ( ) NEW_LINE return 0 NEW_LINE DEDENT res = ( zero . pop ( ) , one . pop ( ) ) NEW_LINE if res == 0 : NEW_LINE INDENT zero . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT one . pop ( ) NEW_LINE DEDENT return res NEW_LINE DEDENT perform_queries ( arr , n , queries , q ) NEW_LINE DEDENT
def GFG ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) NEW_LINE print ( val * ( x < 0 ) + 1 , 0 , end = ' ▁ ' ) NEW_LINE print ( '0 ▁ ' + val * ( y < 0 ) ) NEW_LINE DEDENT
def get_sum ( a , n ) : NEW_LINE INDENT P = [ a [ 0 ] ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = P [ - 1 ] NEW_LINE hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ P [ i ] ] = 1 NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( 1 , n * i + 1 ) : NEW_LINE INDENT if S % i == 0 : NEW_LINE INDENT pres = True NEW_LINE div1 , div2 = i , S // i NEW_LINE for j in range ( div1 , S , i + 1 ) : NEW_LINE INDENT if hash [ j ] is None or hash [ j ] != 1 : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if pres and div1 != S : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT pres = True NEW_LINE for j in range ( S // i , S , i + 1 ) : NEW_LINE INDENT if hash [ j ] is None or hash [ j ] != 1 : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if pres and div2 != S : NEW_LINE INDENT res . add ( div2 ) NEW_LINE DEDENT DEDENT DEDENT if len ( res ) == 0 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT DEDENT
def pyGFG ( greater , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp . append ( i ) NEW_LINE DEDENT arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = n - greater [ i ] - i NEW_LINE arr . append ( temp [ k ] ) NEW_LINE temp . pop ( k ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def practice ( ) : NEW_LINE INDENT scn = input ( ) NEW_LINE s , p = scn . split ( ) NEW_LINE k , x , y , ans = scn . split ( ) NEW_LINE a , b = scn . split ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT p = scn . split ( ) NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ j ] == p [ 0 ] : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif s [ j ] == p [ 1 ] : NEW_LINE INDENT y += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += min ( x , y ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE DEDENT DEDENT ans += min ( x , y ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def get_radius ( houses , heaters ) : NEW_LINE INDENT heaters = sorted ( heaters ) NEW_LINE result = int ( - 1 ) NEW_LINE for house in houses : NEW_LINE INDENT index = bisect . bisect_left ( heaters , house ) NEW_LINE if index < 0 : NEW_LINE INDENT index = - ( index + 1 ) NEW_LINE DEDENT dist1 = index - 1 >= 0 and house - heaters [ index - 1 ] or int ( - 1 ) NEW_LINE dist2 = index < len ( heaters ) and heaters [ index ] - house or int ( - 1 ) NEW_LINE result = max ( result , min ( dist1 , dist2 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def p130 ( n ) : NEW_LINE INDENT print ( [ ' p130 ▁ run ' , n ] ) NEW_LINE DEDENT
def test_solution ( num , x , k , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT r = int ( math . floor ( math . pow ( num , 1.0 / n ) ) ) NEW_LINE for i in range ( k + 1 , r + 1 ) : NEW_LINE INDENT a = x - int ( math . pow ( i , n ) ) NEW_LINE if a >= 0 : NEW_LINE INDENT check_recursive ( num , x - int ( math . pow ( i , n ) ) , i , n ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( msg + ' \n ' ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT if args == [ ] : NEW_LINE INDENT if opts == ' - - help ' : NEW_LINE INDENT usage ( ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if opts == ' - - input ' : NEW_LINE INDENT input ( ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT DEDENT if not args : NEW_LINE INDENT if opts == ' - - output ' : NEW_LINE INDENT output ( ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT DEDENT if not args : NEW_LINE INDENT return NEW_LINE DEDENT if not output : NEW_LINE INDENT output ( ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT if not input : NEW_LINE INDENT input ( ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT if not output : NEW_LINE INDENT output ( ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT plus = input ( ) NEW_LINE if not plus : NEW_LINE INDENT plus ( ) NEW_LINE DEDENT if not plus : NEW_LINE INDENT plus ( ) NEW_LINE DEDENT if not output : NEW_LINE INDENT output ( ) NEW_LINE DEDENT return plus , output NEW_LINE DEDENT
def main ( agrs ) : NEW_LINE INDENT import sys NEW_LINE out = sys . stdout NEW_LINE n = len ( agrs ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE total = 0 NEW_LINE for i in agrs : NEW_LINE INDENT a . append ( i ) NEW_LINE b . append ( i ) NEW_LINE total += b [ i ] / 2.0 NEW_LINE DEDENT dp = [ [ - 1 ] * 10001 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT del dp [ i ] NEW_LINE DEDENT dp [ 0 ] [ 0 ] = total NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for k in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , 10001 ) : NEW_LINE INDENT if dp [ k ] [ j ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ k + 1 ] [ j + a [ i ] ] = float ( max ( dp [ k + 1 ] [ j + a [ i ] ] , dp [ k ] [ j ] + b [ i ] / 2.0 ) ) NEW_LINE DEDENT DEDENT DEDENT max = 0 NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT max = 0 NEW_LINE for j in range ( 0 , 10001 ) : NEW_LINE INDENT max = float ( max ( max , min ( dp [ k ] [ j ] , j ) ) ) NEW_LINE DEDENT out . write ( " % d ▁ " % max ) NEW_LINE DEDENT out . flush ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE rand = random . Random ( ) NEW_LINE n = rand . randint ( 1 , 1000 ) NEW_LINE print ( solve ( n ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def import ( n , m , a ) : NEW_LINE INDENT import numpy as np NEW_LINE class solution ( object ) : NEW_LINE INDENT def __init__ ( self , n , m , a ) : NEW_LINE INDENT self . n = n NEW_LINE self . m = m NEW_LINE self . a = a NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' % s ( % s , % s , % s ) ' % ( self . n , self . m , self . a , self . n ) NEW_LINE DEDENT DEDENT arr = np . arange ( 6 ) NEW_LINE print ( Squares ( arr , n , m , a ) ) NEW_LINE DEDENT
def test_two_regular_polygons ( ) : NEW_LINE INDENT f = Poly ( x ** 2 + x + 1 , x ) NEW_LINE t = Poly ( x ** 2 + x + 1 , x ) NEW_LINE while t : NEW_LINE INDENT n , m = f . degree ( ) , Poly ( x ** 2 + x + 1 , x ) NEW_LINE assert ( n % m ) == 0 NEW_LINE DEDENT DEDENT
def GFG ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , j ** 2 ) : NEW_LINE INDENT if j ** 2 * j == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE oddList = [ ] NEW_LINE evenList = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT v = sys . argv [ i ] NEW_LINE if i % 2 == 1 : NEW_LINE INDENT oddList . append ( v ) NEW_LINE DEDENT if i % 2 == 0 : NEW_LINE INDENT evenList . append ( v ) NEW_LINE DEDENT DEDENT maxOdd , maxEven , secondmaxOdd , secondmaxEven , countOdd , countEven = 0 , 0 , 0 , 0 , 0 NEW_LINE for i in range ( 1 , 100001 ) : NEW_LINE INDENT maxOdd = max ( oddList [ i ] , maxOdd ) NEW_LINE maxEven = max ( evenList [ i ] , maxEven ) NEW_LINE DEDENT oddnum , evennum = 0 , 0 , 0 NEW_LINE for i in range ( 1 , 100001 ) : NEW_LINE INDENT if oddList [ i ] == maxOdd : NEW_LINE INDENT oddnum = i NEW_LINE countOdd += 1 NEW_LINE DEDENT if evenList [ i ] == maxEven : NEW_LINE INDENT evennum = i NEW_LINE countEven += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT if oddList [ i ] != maxOdd : NEW_LINE INDENT secondmaxOdd = max ( oddList [ i ] , secondmaxOdd ) NEW_LINE DEDENT if evenList [ i ] != maxEven : NEW_LINE INDENT secondmaxEven = max ( evenList [ i ] , secondmaxEven ) NEW_LINE DEDENT DEDENT if countOdd >= 2 : NEW_LINE INDENT secondmaxOdd = maxOdd NEW_LINE DEDENT if countEven >= 2 : NEW_LINE INDENT secondmaxEven = maxEven NEW_LINE DEDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT if oddList [ i ] == maxOdd : NEW_LINE INDENT oddnum = i NEW_LINE DEDENT if evenList [ i ] == maxEven : NEW_LINE INDENT evennum = i NEW_LINE DEDENT DEDENT if oddnum == evennum : NEW_LINE INDENT if maxOdd > maxEven : NEW_LINE INDENT maxEven = secondmaxEven NEW_LINE DEDENT elif maxOdd < maxEven : NEW_LINE INDENT maxOdd = secondmaxOdd NEW_LINE DEDENT else : NEW_LINE INDENT maxEven = max ( secondmaxOdd , secondmaxEven ) NEW_LINE DEDENT DEDENT ans = n - maxOdd - maxEven NEW_LINE if ans == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT
def GFG ( str , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT print ( str [ i : j ] ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT assert angleextcycquad ( z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z ) NEW_LINE assert angleextcycquad ( - z ) == ( - z , - z
def GFG ( str , patt ) : NEW_LINE INDENT min_index = int ( str ) NEW_LINE m = len ( str ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if patt [ i ] == str [ j ] and j < min_index : NEW_LINE INDENT min_index = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if min_index != int ( m ) : NEW_LINE INDENT print ( " Minimum ▁ Index ▁ Character ▁ = ▁ " + str [ min_index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ character ▁ present " ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE for args , opts , args in getopt . getopt ( sys . argv [ 1 : ] , ' ' ) : NEW_LINE INDENT for o , a in opts : NEW_LINE INDENT if o == ' - h ' : NEW_LINE INDENT print ( ' \n ' ) NEW_LINE return NEW_LINE DEDENT DEDENT if o == ' - v ' : NEW_LINE INDENT print ( ' \n ' ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' \n Poor ▁ Alex ' ) NEW_LINE DEDENT
def gen2 ( n , k ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 1 NEW_LINE while n / i > 0 : NEW_LINE INDENT temp = ( n / ( i * 10 ) ) ** i + ( n % i ) NEW_LINE i *= 10 NEW_LINE ans = max ( ans , temp ) NEW_LINE DEDENT n = ans NEW_LINE DEDENT return n NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT log = logging . getLogger ( __name__ ) NEW_LINE result = sys . stdout NEW_LINE parser = argparse . ArgumentParser ( description = ' Generate ▁ a ▁ simple ▁ histogram ▁ of ▁ a ▁ random ▁ number ▁ of ▁ values . ' ) NEW_LINE parser . add_argument ( ' N ' , type = int , help = ' The ▁ number ▁ of ▁ values ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - M ' , type = int , help = ' The ▁ number ▁ of ▁ values ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - L ' , type = int , help = ' The ▁ number ▁ of ▁ values ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - s ' , type = int , help = ' The ▁ number ▁ of ▁ values ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - f ' , type = int , help = ' The ▁ number ▁ of ▁ values ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - s0 ' , type = int , help = ' The ▁ number ▁ of ▁ values ▁ to ▁ generate . ' ) NEW_LINE args = parser . parse_args ( ) NEW_LINE N = args . N NEW_LINE M = args . M NEW_LINE w = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = int ( random . uniform ( 0 , N ) ) NEW_LINE L = int ( random . uniform ( 0 , N ) ) NEW_LINE for j in range ( L ) : NEW_LINE INDENT w . append ( 1 ) NEW_LINE DEDENT DEDENT t = [ ] NEW_LINE s = 0 NEW_LINE f = 0 NEW_LINE s0 = 0 NEW_LINE i = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if f == 0 and w [ i ] == 1 : NEW_LINE INDENT s = i NEW_LINE f = 1 NEW_LINE DEDENT elif f == 1 and w [ i ] == 0 : NEW_LINE INDENT f = 0 NEW_LINE if s == 0 : s0 = i NEW_LINE else : t . append ( i - s ) NEW_LINE DEDENT DEDENT if f == 1 : t [ i - s + s0 ] += 1 NEW_LINE elif s0 != 0 : t . append ( s0 ) NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT if t [ i ] > 0 : result . write ( i , t [ i ] ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT io = sys . stdin NEW_LINE n = io . readline ( ) . rstrip ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a . append ( io . readline ( ) ) NEW_LINE DEDENT sum = 0 NEW_LINE now = 0 NEW_LINE border = 1 NEW_LINE end = 0 NEW_LINE ans_p = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE end = border - sum NEW_LINE if border > 0 : NEW_LINE INDENT if now < end : NEW_LINE INDENT ans_p += abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if now > end : NEW_LINE INDENT ans_p += abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT border = - border NEW_LINE DEDENT sum = 0 NEW_LINE now = 0 NEW_LINE border = - 1 NEW_LINE end = 0 NEW_LINE ans_m = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE end = border - sum NEW_LINE if border > 0 : NEW_LINE INDENT if now < end : NEW_LINE INDENT ans_m += abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if now > end : NEW_LINE INDENT ans_m += abs ( now - end ) NEW_LINE now = end NEW_LINE DEDENT DEDENT border = - border NEW_LINE DEDENT print ( min ( ans_p , ans_m ) ) NEW_LINE DEDENT
def AAA ( N ) : NEW_LINE INDENT if N <= 10 : NEW_LINE INDENT ans , fac = 0 , 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT return int ( ans % 100 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT binary_number = "1001" NEW_LINE print ( int ( binary_number , 2 ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = x ** 2 + y ** 2 + z ** 2 NEW_LINE if math . ceil ( a ) == 1 and math . floor ( a ) == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE MOD = 10000007 NEW_LINE result = [ ] NEW_LINE fact = [ 0 ] * MAX + [ 1 ] * MAX NEW_LINE def pre_compute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) ** i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) ** ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def perform_queries ( q , n ) : NEW_LINE INDENT pre_compute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT assert result [ q [ i ] ] == fact [ q [ i ] ] NEW_LINE DEDENT DEDENT def test_gf_gf_list ( ) : NEW_LINE INDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE perform_queries ( q , n ) NEW_LINE DEDENT DEDENT
def test_D ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE T = symbols ( ' T ' ) NEW_LINE while T : NEW_LINE INDENT n = symbols ( ' n ' ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT a . sort ( ) NEW_LINE mini = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = a [ i ] - a [ i - 1 ] NEW_LINE mini = mini + ( - 1 ) * diff * i NEW_LINE ans += mini NEW_LINE DEDENT assert ans == a [ n - 1 ] NEW_LINE DEDENT DEDENT
def pythree_binary_search ( arr , size ) : NEW_LINE INDENT """ STRNEWLINE ▁ Search ▁ for ▁ a ▁ binary ▁ element ▁ in ▁ a ▁ given ▁ array . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ arr ▁ : ▁ array _ like STRNEWLINE ▁ The ▁ array ▁ to ▁ search ▁ in . STRNEWLINE ▁ size ▁ : ▁ int STRNEWLINE ▁ The ▁ size ▁ of ▁ the ▁ array ▁ to ▁ search . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ j ▁ : ▁ int STRNEWLINE ▁ The ▁ index ▁ of ▁ the ▁ element ▁ in ▁ arr ▁ that ▁ is ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ size . STRNEWLINE ▁ """ NEW_LINE j , i = 0 , 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] <= 0 : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT
def get_GFG ( n ) : NEW_LINE INDENT mod = 1000000007 NEW_LINE def digitnumber ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 9 NEW_LINE DEDENT if n % 2 != 0 : NEW_LINE INDENT temp = digitnumber ( ( n - 1 ) / 2 ) % mod NEW_LINE return ( 9 * ( temp ** 2 ) % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitnumber ( n / 2 ) % mod NEW_LINE return ( temp ** 2 ) % mod NEW_LINE DEDENT DEDENT def count_excluding ( n , d ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return ( 9 * digitnumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitnumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT def count_included ( n , d ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return ( 9 * digitnumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitnumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT def count_excluded ( n , d ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return ( 9 * digitnumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitnumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT def count_included ( n , d ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return ( 9 * digitnumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitnumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT def count_excluded ( n , d ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return ( 9 * digitnumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitnumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT def count_included ( n , d ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return ( 9 * digitnumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitnumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT return count_excluded ( n , d ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' i : ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - i | - o | - - index ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁
def test_GFG ( ) : NEW_LINE INDENT h1 = int ( str ( x ) [ 0 ] ) - '0' NEW_LINE h2 = int ( str ( x ) [ 1 ] ) - '0' NEW_LINE hh = h1 * 10 + h2 NEW_LINE Meridien = ' ' NEW_LINE if hh < 12 : NEW_LINE INDENT Meridien = ' AM ' NEW_LINE DEDENT else : NEW_LINE INDENT Meridien = ' PM ' NEW_LINE DEDENT hh %= 12 NEW_LINE if hh == 0 : NEW_LINE INDENT print ( '12' ) NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str ( i ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( hh ) NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str ( i ) ) NEW_LINE DEDENT DEDENT print ( ' ▁ ' . join ( Meridien ) ) NEW_LINE DEDENT
def GFG ( s , k ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != s [ i % k ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def GFG ( a , b ) : NEW_LINE INDENT return ( a > b ) NEW_LINE DEDENT def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT i , w = 0 , W NEW_LINE K = [ [ 0 ] * ( n + 1 ) ] * ( W + 1 ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for w in range ( 0 , W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE print ( res ) NEW_LINE w = W NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if res == K [ i - 1 ] [ w ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] + " ▁ " ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE z = n * 2 NEW_LINE c = 0 NEW_LINE arr = [ ] NEW_LINE ff = [ ] NEW_LINE ss = [ ] NEW_LINE while n : NEW_LINE INDENT ff . append ( sys . argv [ 0 ] ) NEW_LINE ss . append ( sys . argv [ 0 ] ) NEW_LINE DEDENT pp = len ( ff ) NEW_LINE for i in range ( pp ) : NEW_LINE INDENT for j in range ( pp ) : NEW_LINE INDENT if ff [ i ] == ss [ j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ FastICG ▁ algorithm . """ NEW_LINE elements = [ ] NEW_LINE indices = [ ] NEW_LINE temp , i = 0 , 0 NEW_LINE j , ind , start , end = 0 , 0 , 0 NEW_LINE for i in range ( 0 , n , 3 ) : NEW_LINE INDENT elements . append ( arr [ i ] ) NEW_LINE indices . append ( i ) NEW_LINE ind += 1 NEW_LINE DEDENT if k < elements [ 0 ] : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , ind + 1 ) : NEW_LINE INDENT if k < elements [ i ] : NEW_LINE INDENT start , end = indices [ i - 1 ] , indices [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT if k == arr [ i ] : NEW_LINE INDENT j = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if j == 1 : NEW_LINE INDENT print ( " Found ▁ at ▁ index ▁ " + str ( i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT upper_limit = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT upper_limit *= 10 NEW_LINE upper_limit += 9 NEW_LINE DEDENT lower_limit = 1 + upper_limit / 10 NEW_LINE max_product = 0 NEW_LINE for i in range ( upper_limit , lower_limit , - 1 ) : NEW_LINE INDENT for j in range ( i , lower_limit , - 1 ) : NEW_LINE INDENT product = i * j NEW_LINE if product < max_product : NEW_LINE INDENT break NEW_LINE DEDENT number = product NEW_LINE reverse = 0 NEW_LINE while number != 0 : NEW_LINE INDENT reverse = reverse * 10 + number % 10 NEW_LINE number /= 10 NEW_LINE DEDENT if product == reverse and product > max_product : NEW_LINE INDENT max_product = product NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT
def main ( dp , a ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( dp ) - 1 NEW_LINE while True : NEW_LINE INDENT if dp [ start ] >= a : NEW_LINE INDENT return start NEW_LINE DEDENT elif dp [ end ] <= a : NEW_LINE INDENT return end NEW_LINE DEDENT else : NEW_LINE INDENT if start + 1 == end : NEW_LINE INDENT return end NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if dp [ mid ] == a : NEW_LINE INDENT return mid NEW_LINE DEDENT elif dp [ mid ] > a : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def test_fastfood_Restaurant ( ) : NEW_LINE INDENT import random NEW_LINE test = random . randrange ( 1 , 10 ) NEW_LINE while test : NEW_LINE INDENT a , b , c = test NEW_LINE if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT assert 0 NEW_LINE DEDENT else : NEW_LINE INDENT if b > c and b > a : NEW_LINE INDENT k = a NEW_LINE a , b , c = b , c NEW_LINE DEDENT if c > b and c > a : NEW_LINE INDENT k = a NEW_LINE a , c , c = c , c NEW_LINE DEDENT res = 0 NEW_LINE if a >= 1 : NEW_LINE INDENT a -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if b >= 1 : NEW_LINE INDENT b -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if c >= 1 : NEW_LINE INDENT c -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if a >= 1 and b >= 1 : NEW_LINE INDENT a -= 1 NEW_LINE b -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if a >= 1 and c >= 1 : NEW_LINE INDENT a -= 1 NEW_LINE c -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if c >= 1 and b >= 1 : NEW_LINE INDENT c -= 1 NEW_LINE b -= 1 NEW_LINE res += 1 NEW_LINE DEDENT if a >= 1 and b >= 1 and c >= 1 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT assert res == 1 NEW_LINE DEDENT DEDENT DEDENT
def test_solution788_a ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import string NEW_LINE import time NEW_LINE import doctest NEW_LINE import os NEW_LINE import tempfile NEW_LINE import hashlib NEW_LINE import random NEW_LINE import pickle NEW_LINE import tempfile NEW_LINE import time NEW_LINE import pickle NEW_LINE import os NEW_LINE import pickle NEW_LINE import random NEW_LINE import time NEW_LINE import pickle NEW_LINE import os NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE DEDENT
def maximum_xor ( arr , n ) : NEW_LINE INDENT """ STRNEWLINE ▁ Compute ▁ the ▁ maximum ▁ XOR ▁ of ▁ two ▁ arrays . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ arr ▁ : ▁ array _ like STRNEWLINE ▁ Input ▁ array . STRNEWLINE ▁ n ▁ : ▁ int STRNEWLINE ▁ Number ▁ of ▁ elements ▁ to ▁ be ▁ compared . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ ans ▁ : ▁ int STRNEWLINE ▁ Maximum ▁ XOR ▁ of ▁ two ▁ arrays . STRNEWLINE STRNEWLINE ▁ Examples STRNEWLINE ▁ - - - - - STRNEWLINE ▁ > > > ▁ from ▁ scipy . linalg ▁ import ▁ solve STRNEWLINE ▁ > > > ▁ solve ( [ [ 1 , ▁ 2 ] , ▁ [ 3 , ▁ 4 ] ] ) STRNEWLINE ▁ [ 1 , ▁ 2 , ▁ 3 ] STRNEWLINE ▁ > > > ▁ solve ( [ [ 1 , ▁ 2 ] , ▁ [ 3 , ▁ 4 ] ] ) STRNEWLINE ▁ [ 1 , ▁ 2 , ▁ 3 ] STRNEWLINE ▁ > > > ▁ solve ( [ [ 1 , ▁ 2 ] , ▁ [ 3 , ▁ 4 ] ] ) STRNEWLINE ▁ [ 1 , ▁ 2 , ▁ 3 ] STRNEWLINE ▁ > > > ▁ solve ( [ [ 1 , ▁ 2 ] , ▁ [ 3 , ▁ 4 ] ] ) STRNEWLINE ▁ [ 1 , ▁ 2 , ▁ 3 ] STRNEWLINE ▁ > > > ▁ solve ( [ [ 1 , ▁ 2 ] , ▁ [ 3 , ▁ 4 ] ] ) STRNEWLINE ▁ [ 1 , ▁ 2 , ▁ 3 ] STRNEWLINE ▁ > > > ▁ solve ( [ [ 1 , ▁ 2 ] , ▁ [ 3 , ▁ 4 ] ] ) STRNEWLINE ▁ [ 1 , ▁ 2 , ▁ 3 ] STRNEWLINE ▁ > > > ▁ solve ( [ [ 1 , ▁ 2 ] , ▁ [ 3 , ▁ 4 ] ] ) STRNEWLINE ▁ [ 1 , ▁ 2 , ▁ 3 ] STRNEWLINE ▁ """ NEW_LINE sForward , sBackward = [ ] , [ ] NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while not sForward and arr [ i ] < arr [ sForward [ i ] ] : NEW_LINE INDENT ans = max ( ans , arr [ i ] ^ arr [ sForward [ i ] ] ) NEW_LINE sForward . pop ( ) NEW_LINE DEDENT sForward . append ( i ) NEW_LINE while not sBackward and arr [ n - i - 1 ] < arr [ sBackward [ i ] ] : NEW_LINE INDENT ans = max ( ans , arr [ n - i -
def import ( n ) : NEW_LINE INDENT hexaDeciNum = [ ] NEW_LINE i = 0 NEW_LINE while n != 0 : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if temp < 10 : NEW_LINE INDENT hexaDeciNum . append ( chr ( temp + 48 ) ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum . append ( chr ( temp + 55 ) ) NEW_LINE i += 1 NEW_LINE DEDENT n = n / 16 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( hexaDeciNum [ j ] ) NEW_LINE DEDENT DEDENT
def pymatlab ( ) : NEW_LINE INDENT import numpy as np NEW_LINE import sys NEW_LINE import numpy . linalg NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma . mcode NEW_LINE import numpy . ma . mcode NEW_LINE import numpy . ma . mcode NEW_LINE import numpy . ma . mcode NEW_LINE import numpy . ma . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode . mcode . mcode NEW_LINE import numpy . ma . mcode . mcode . mcode . mcode . mcode NEW_LINE
def main ( ) : NEW_LINE INDENT import sys NEW_LINE sys . stdout = sys . stderr NEW_LINE while 1 : NEW_LINE INDENT R , C = read_csv ( sys . stdin ) NEW_LINE if R == 0 and C == 0 : NEW_LINE INDENT break NEW_LINE DEDENT hm = { } NEW_LINE for i in range ( R ) : NEW_LINE INDENT lines = read_csv ( sys . stdin ) NEW_LINE for j in range ( C ) : NEW_LINE INDENT c = lines [ j ] NEW_LINE if c == ' _ ' : NEW_LINE INDENT continue NEW_LINE DEDENT hm [ c ] = ( i , j ) NEW_LINE DEDENT DEDENT lines = read_csv ( sys . stdin ) NEW_LINE iPos = 0 NEW_LINE jPos = 0 NEW_LINE count = len ( lines ) NEW_LINE for i in range ( len ( lines ) ) : NEW_LINE INDENT loc = hm [ lines [ i ] ] NEW_LINE count += abs ( iPos - loc [ ' i ' ] ) + abs ( jPos - loc [ ' j ' ] ) NEW_LINE iPos = loc [ ' i ' ] NEW_LINE jPos = loc [ ' j ' ] NEW_LINE DEDENT sys . stdout . write ( count ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT m = re . compile ( r ' ( . * ) \ . ( . * ) $ ' ) NEW_LINE m . run ( ) NEW_LINE DEDENT
def GFG ( str ) : NEW_LINE INDENT num , res = 0 , 0 NEW_LINE for c in str : NEW_LINE INDENT if ord ( c ) < 128 : NEW_LINE INDENT num = num * 10 + ( ord ( c ) - ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , num ) NEW_LINE num = 0 NEW_LINE DEDENT DEDENT return max ( res , num ) NEW_LINE DEDENT
def GFG ( arr ) : NEW_LINE INDENT max = 50009 NEW_LINE sum = [ 0 ] * max NEW_LINE index_1 , index_2 , index_3 , index = 0 , 0 , 0 , 0 NEW_LINE k , i = 1 , 0 , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ k ] NEW_LINE DEDENT ans = - ( 1e15 ) NEW_LINE index_1 = index_2 = index_3 = - 1 NEW_LINE for l in range ( 0 , n ) : NEW_LINE INDENT index = 0 NEW_LINE vmin = ( 1e15 ) NEW_LINE for r in range ( l , n ) : NEW_LINE INDENT if sum [ r ] < vmin : NEW_LINE INDENT vmin = sum [ r ] NEW_LINE index = r NEW_LINE DEDENT if sum [ l ] + sum [ r ] - vmin > ans : NEW_LINE INDENT ans = sum [ l ] + sum [ r ] - vmin NEW_LINE index_1 = l NEW_LINE index_2 = index NEW_LINE index_3 = r NEW_LINE DEDENT DEDENT DEDENT print ( index_1 , index_2 , index_3 ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ar [ i ] NEW_LINE DEDENT if sum % n == 0 : NEW_LINE INDENT return sum / n NEW_LINE DEDENT else : NEW_LINE INDENT A , B = sum // n + 1 , sum // n + 1 NEW_LINE ValueA , ValueB = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) NEW_LINE ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) NEW_LINE DEDENT if ValueA < ValueB : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT return B NEW_LINE DEDENT DEDENT DEDENT
def p_main ( p ) : NEW_LINE INDENT ''' main ▁ : ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁ int ▁
def py2exe_options ( ) : NEW_LINE INDENT parser = optparse . OptionParser ( ) NEW_LINE parser . add_option ( ' - s ' , ' - - script ' , dest = ' script ' , help = ' Path ▁ to ▁ Python ▁ executable ' ) NEW_LINE parser . add_option ( ' - t ' , ' - - type ' , dest = ' type ' , help = ' Type ▁ of ▁ the ▁ script ' ) NEW_LINE parser . add_option ( ' - v ' , ' - - verbose ' , dest = ' verbose ' , help = ' Verbose ▁ output ' ) NEW_LINE parser . add_option ( ' - - no - headers ' , dest = ' no _ headers ' , help = ' Do ▁ not ▁ include ▁ headers ▁ in ▁ the ▁ output ' ) NEW_LINE parser . add_option ( ' - - no - script ' , dest = ' no _ script ' , help = ' Do ▁ not ▁ include ▁ the ▁ script ' ) NEW_LINE parser . add_option ( ' - - no - header ' , dest = ' no _ header ' , help = ' Do ▁ not ▁ include ▁ the ▁ header ' ) NEW_LINE parser . add_option ( ' - - no - version ' , dest = ' no _ version ' , help = ' Do ▁ not ▁ include ▁ the ▁ version ' ) NEW_LINE parser . add_option ( ' - - no - comment ' , dest = ' no _ comment ' , help = ' Do ▁ not ▁ include ▁ the ▁ comment ' ) NEW_LINE parser . add_option ( ' - - no - stamp ' , dest = ' stamp ' , help = ' Path ▁ to ▁ touch ▁ on ▁ success ' ) NEW_LINE parser . add_option ( ' - - no - user ' , dest = ' no _ user ' , help = ' Do ▁ not ▁ include ▁ the ▁ stamp ' ) NEW_LINE parser . add_option ( ' - - no - stamp ' , dest = ' stamp ' , help = ' Path ▁ to ▁ touch ▁ on ▁ failure ' ) NEW_LINE return parser NEW_LINE DEDENT
def find_nth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for curr in range ( 19 , 9 ) : NEW_LINE INDENT sum = 0 NEW_LINE for x in range ( curr , 0 , 10 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE DEDENT if sum == 10 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == n : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT DEDENT
def get_gf_nth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for curr in range ( 1 , 10 ) : NEW_LINE INDENT sum = 0 NEW_LINE for x in range ( curr , 0 , 10 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE DEDENT if sum == 10 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == n : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT DEDENT
def GFG ( N , S ) : NEW_LINE INDENT count_elements = 0 NEW_LINE curr_sum = 0 NEW_LINE while curr_sum <= S : NEW_LINE INDENT curr_sum += N NEW_LINE N -= 1 NEW_LINE count_elements += 1 NEW_LINE DEDENT return count_elements NEW_LINE DEDENT
def pyGFG ( str , pattern , n , m ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return ( n , 0 ) NEW_LINE DEDENT lookup = [ False ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT del lookup [ i ] NEW_LINE DEDENT lookup [ 0 ] = True NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if pattern [ j - 1 ] == ' * ' : NEW_LINE INDENT lookup [ 0 ] = lookup [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if pattern [ j - 1 ] == ' * ' : NEW_LINE INDENT lookup [ i ] = lookup [ i ] [ j - 1 ] or lookup [ i - 1 ] [ j ] NEW_LINE DEDENT elif pattern [ j - 1 ] == ' ? ' or str [ i - 1 ] == pattern [ j - 1 ] : NEW_LINE INDENT lookup [ i ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return lookup [ n ] NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE N = 1000001 NEW_LINE p = [ True ] * N NEW_LINE p [ 0 ] = p [ 1 ] = False NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if p [ i ] : NEW_LINE INDENT for j in range ( i + i , N , i ) : NEW_LINE INDENT p [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT a , b = divmod ( sys . stdin . read ( N ) , sys . stdin . read ( N ) ) NEW_LINE if ( a | b ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT sa = [ ] NEW_LINE sb = [ ] NEW_LINE k = 2 NEW_LINE while a > 1 : NEW_LINE INDENT if p [ k ] and a % k == 0 : NEW_LINE INDENT a //= k NEW_LINE sa . append ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT k = 2 NEW_LINE while b > 1 : NEW_LINE INDENT if p [ k ] and b % k == 0 : NEW_LINE INDENT b //= k NEW_LINE sb . append ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT pa = sa . pop ( ) NEW_LINE sa . remove ( pa ) NEW_LINE pb = sb . pop ( ) NEW_LINE sb . remove ( pb ) NEW_LINE for x in sa : NEW_LINE INDENT pa -= x NEW_LINE DEDENT for x in sb : NEW_LINE INDENT pb -= x NEW_LINE DEDENT print ( pa > pb , ' a ' , ' b ' ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 3 NEW_LINE k = 3 NEW_LINE ans = nCr ( n + k - 1 , k ) + nCr ( k - 1 , n - 1 ) NEW_LINE assert ans == nCr ( n + k - 1 , k ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( sys . argv [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE min = sys . maxint NEW_LINE ans = None NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sa = abs ( a [ - 1 ] - a [ i ] ** 2 ) NEW_LINE if sa < min : NEW_LINE INDENT min = sa NEW_LINE ans = a [ i ] NEW_LINE DEDENT DEDENT sys . stdout . write ( a [ - 1 ] + " ▁ " ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a , b = symbols ( ' a ▁ b ' , cls = Dummy ) NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( b % a , a ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == a NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b ) == b NEW_LINE assert gf_gcd ( a , b )
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n NEW_LINE global A , B , C NEW_LINE n = len ( sys . argv ) NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT A . append ( sys . argv [ i ] ) NEW_LINE C [ A [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , 10000 ) : NEW_LINE INDENT C [ i ] = C [ i - 1 ] + C [ i ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT B [ C [ A [ i ] ] - 1 ] = A [ i ] NEW_LINE C [ A [ i ] ] -= 1 NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT sys . stdout . write ( B [ i ] ) NEW_LINE sys . stdout . write ( " ▁ " ) NEW_LINE DEDENT print ( " % d ▁ % d \n " % ( n , B [ n - 1 ] ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE s = sys . argv [ 1 ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '8' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( min ( count , n // 11 ) ) NEW_LINE DEDENT
def GFG ( n , b ) : NEW_LINE INDENT unit_digit , sum = 0 , 0 NEW_LINE while n : NEW_LINE INDENT unit_digit = n % b NEW_LINE sum += unit_digit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT i , c0 , c5 = symbols ( ' i ▁ c ▁ s ' , integer = True , positive = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c5 += 1 NEW_LINE DEDENT DEDENT c5 = int ( floor ( c5 / 9 ) ) * 9 NEW_LINE if c0 == 0 : NEW_LINE INDENT assert - 1 == F ( 5 ) == F ( 5 ) NEW_LINE DEDENT elif c5 == 0 : NEW_LINE INDENT assert 0 == F ( 5 ) == F ( 5 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( c5 ) : NEW_LINE INDENT assert 5 == F ( 5 ) == F ( 5 ) NEW_LINE DEDENT for i in range ( c0 ) : NEW_LINE INDENT assert 0 == F ( 5 ) == F ( 5 ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if i + j + k + l == n : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ minutes ▁ in ▁ a ▁ GFG . """ NEW_LINE Min , S1 = symbols ( ' Min ▁ S1' , integer = True , positive = True ) NEW_LINE assert number_of_minutes ( S , S1 ) == Min NEW_LINE DEDENT
def test_codechef_submission ( ) : NEW_LINE INDENT import numpy as np NEW_LINE import pickle NEW_LINE n , m , k = 100 , 100 , 10 NEW_LINE b = [ ] NEW_LINE if n < k : NEW_LINE INDENT print ( n ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b . append ( i ) NEW_LINE DEDENT d = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT d . append ( b [ i + 1 ] - b [ i ] - 1 ) NEW_LINE DEDENT d . sort ( ) NEW_LINE sum = b [ - 1 ] - b [ 0 ] + 1 NEW_LINE for i in range ( len ( d ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum -= d [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT number_of_bits = int ( math . floor ( math . log ( n , 2 ) / math . log ( 2 , 2 ) ) ) + 1 NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ n NEW_LINE DEDENT
def test_new_class_27 ( ) : NEW_LINE INDENT f = Function ( ' f ' ) NEW_LINE t = Symbol ( ' t ' ) NEW_LINE while t : NEW_LINE INDENT w , h , n = f ( t ) NEW_LINE sheet = 1 NEW_LINE while w % 2 == 0 : NEW_LINE INDENT w /= 2 NEW_LINE sheet *= 2 NEW_LINE DEDENT while h % 2 == 0 : NEW_LINE INDENT h /= 2 NEW_LINE sheet *= 2 NEW_LINE DEDENT if sheet >= n : NEW_LINE INDENT assert ' YES ' == f ( w ) NEW_LINE DEDENT else : NEW_LINE INDENT assert ' NO ' == f ( h ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( ' ( % d , % d ▁ ) ' % ( int ( 2 * x2 - x1 ) , int ( 2 * y2 - y1 ) ) ) NEW_LINE DEDENT
def py ( z ) : NEW_LINE INDENT s = z . copy ( ) NEW_LINE for n , m , a , b , i in s : NEW_LINE INDENT assert ( m - 1 - max ( abs ( ( a = s [ i ] - m ) > 0 and n % 2 > 0 ) , abs ( ( b = s [ i ] - m ) > 0 and n % 2 > 0 ) ) % 3 + 1 == 0 NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT if not isinstance ( x , ( int , long ) ) or not isinstance ( y , ( int , long ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if x >= 2 * y : NEW_LINE INDENT x = x % ( 2 * y ) NEW_LINE DEDENT elif y >= 2 * x : NEW_LINE INDENT y = y % ( 2 * x ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT assert x == 12 NEW_LINE assert y == 5 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT with open ( ' input . txt ' , ' r ' ) as f : NEW_LINE INDENT n = len ( f . read ( ) ) NEW_LINE v = [ ] NEW_LINE set = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( i ) NEW_LINE set . add ( v [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT swap ( v , int ( random . uniform ( 0 , ( i - 1 ) ) ) , i ) NEW_LINE DEDENT v . sort ( ) NEW_LINE ans = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d = v [ j ] - v [ i ] NEW_LINE if set . intersection ( v [ i ] - d ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt , cur = 2 , v [ j ] NEW_LINE while set . intersection ( cur + d ) : NEW_LINE INDENT cur += d NEW_LINE cnt += 1 NEW_LINE DEDENT ans = max ( ans , cnt ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def test_a1569 ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE cases = random . randint ( 1 , 10 ) NEW_LINE while cases : NEW_LINE INDENT flag = False NEW_LINE letters = random . choice ( string . ascii_lowercase ) NEW_LINE ab = string . join ( letters , ' ▁ ' ) NEW_LINE for i in range ( 1 , len ( letters ) ) : NEW_LINE INDENT if ab [ i - 1 ] != ab [ i ] : NEW_LINE INDENT flag = True NEW_LINE print ( ( i , i + 1 ) ) NEW_LINE break NEW_LINE DEDENT DEDENT if flag == False : NEW_LINE INDENT print ( ' - 1 ▁ ' , ' - 1' ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT mod = 1000000007 NEW_LINE inv2 = 500000004 NEW_LINE modulo = int ( num ) NEW_LINE res = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + int ( num [ i ] ) - '0' ) % mod NEW_LINE DEDENT assert res == 0 NEW_LINE def find_sum ( L , R ) : NEW_LINE INDENT a , b , l , r , ret = modulo ( L ) NEW_LINE return ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod NEW_LINE DEDENT assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE assert find_sum ( L , R ) == ( ( 1 , 1 ) , ( 1 , 1 ) ) NEW_LINE DEDENT
def GFG ( l , r , a , k ) : NEW_LINE INDENT if k < 1 or l + 1 == r : NEW_LINE INDENT return NEW_LINE DEDENT k -= 2 NEW_LINE mid = ( l + r ) // 2 NEW_LINE temp = a [ mid - 1 ] NEW_LINE a [ mid - 1 ] = a [ mid ] NEW_LINE a [ mid ] = temp NEW_LINE unsort ( l , mid , a , k ) NEW_LINE unsort ( mid , r , a , k ) NEW_LINE DEDENT
def test_GFG ( lower_limit , upper_limit , freq , n ) : NEW_LINE INDENT mid , freq = lower_limit NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum , freq_sum = gf_mean ( mid , freq , n ) NEW_LINE assert sum / freq_sum == 0 NEW_LINE DEDENT assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( lower_limit ) == n NEW_LINE assert len ( upper_limit ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( freq ) == n NEW_LINE assert len ( freq ) == n NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE assert gcd ( a , b ) == b NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a , b = symbols ( ' a ▁ b ' , real = True ) NEW_LINE assert rectanglearea ( a , b ) == - 1 NEW_LINE assert rectanglearea ( 2 * a * b ) == 2 * a * b NEW_LINE DEDENT
def test_CF427_1 ( ) : NEW_LINE INDENT N = symbols ( ' N ' , integer = True , positive = True ) NEW_LINE MOD = int ( 1e9 + 7 ) NEW_LINE f = Function ( ' f ' ) NEW_LINE g = Function ( ' g ' ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE while t : NEW_LINE INDENT n , a , b = f ( t ) NEW_LINE if n < a : NEW_LINE INDENT g ( n ) NEW_LINE continue NEW_LINE DEDENT if a == b : NEW_LINE INDENT if n % a == 0 : NEW_LINE INDENT g ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT g ( n ) NEW_LINE DEDENT continue NEW_LINE DEDENT x = b / ( b - a ) NEW_LINE if n > x * a : NEW_LINE INDENT g ( x ) NEW_LINE continue NEW_LINE DEDENT low = 1 NEW_LINE high = x + 1 NEW_LINE ans = 1 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if mid * a < n : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT DEDENT if n > ( ans - 1 ) * b and n < ans * a : NEW_LINE INDENT g ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT g ( n ) NEW_LINE DEDENT DEDENT g ( ) NEW_LINE DEDENT
def GFG ( x ) : NEW_LINE INDENT return ( x * ( x + 1 ) ) / 2 NEW_LINE DEDENT
def GFG ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if k < 0 : NEW_LINE INDENT return - 10000000 NEW_LINE DEDENT if n < 0 or m < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT try : NEW_LINE INDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if arr1 [ n - 1 ] == arr2 [ m - 1 ] : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import numpy NEW_LINE N = numpy . arange ( 0 , 10 ) NEW_LINE d = numpy . arange ( 0 , 10 ) NEW_LINE x = numpy . arange ( 0 , 10 ) NEW_LINE ans = numpy . zeros ( ( N , N ) ) NEW_LINE while N > 0.5 : NEW_LINE INDENT adnum = numpy . arange ( d + x * ( N - 0.5 ) , N - 0.5 ) NEW_LINE ans = ans + adnum NEW_LINE d = ( N + 1.0 ) * d / N + ( 5.0 * x ) / ( 2.0 * N ) NEW_LINE x = ( 1.0 + ( 2.0 / N ) ) * x NEW_LINE del N NEW_LINE DEDENT format = ' % . * f ' % ( N , N ) NEW_LINE print ( format . format ( ans ) ) NEW_LINE DEDENT
def genprimelist ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , n * p + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n , - 2 , - 1 ) : NEW_LINE INDENT if prime [ i ] == True : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT N = 25 NEW_LINE print ( ' Prime ▁ number ▁ in ▁ reverse ▁ order ' ) NEW_LINE if N == 1 : NEW_LINE INDENT print ( ' No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range ' ) NEW_LINE DEDENT else : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT
def test_GFG ( min_stars , p_height ) : NEW_LINE INDENT p_space = p_height - 1 NEW_LINE i , j , k , n , x = symbols ( ' i , j , k , n , x ' ) NEW_LINE x = 1 NEW_LINE for i in range ( p_height ) : NEW_LINE INDENT for j in range ( p_space , i > 0 , - 1 ) : NEW_LINE INDENT assert x == 1 NEW_LINE DEDENT for k in range ( min_stars ) : NEW_LINE INDENT assert x == 1 NEW_LINE DEDENT for n in range ( ( p_height + p_height - 2 ) , x , - 1 ) : NEW_LINE INDENT assert x == 1 NEW_LINE DEDENT for k in range ( min_stars ) : NEW_LINE INDENT assert x == 1 NEW_LINE DEDENT min_stars = min_stars + 2 NEW_LINE x = x + 2 NEW_LINE assert x == 1 NEW_LINE DEDENT DEDENT
def test_b629 ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ B629 ▁ algorithm ▁ in ▁ the ▁ book . STRNEWLINE ▁ """ NEW_LINE n = symbols ( ' n ' , integer = True ) NEW_LINE FfriendPerDay = [ 0 ] * 367 NEW_LINE MfriendPerDay = [ 0 ] * 367 NEW_LINE answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = symbols ( ' c ' , integer = True ) NEW_LINE a = symbols ( ' a ' , integer = True ) NEW_LINE b = symbols ( ' b ' , integer = True ) NEW_LINE for j in range ( a , b + 1 ) : NEW_LINE INDENT if c == ' M ' : NEW_LINE INDENT MfriendPerDay [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT FfriendPerDay [ j ] += 1 NEW_LINE DEDENT if MfriendPerDay [ j ] < FfriendPerDay [ j ] : NEW_LINE INDENT if MfriendPerDay [ j ] > answer : NEW_LINE INDENT answer = MfriendPerDay [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if FfriendPerDay [ j ] > answer : NEW_LINE INDENT answer = FfriendPerDay [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT assert answer * 2 == answer NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE assert distancesum ( x , y , n ) == 0 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ calculation ▁ of ▁ the ▁ nth ▁ order ▁ polynomial ▁ of ▁ the ▁ nth ▁ order ▁ group . """ NEW_LINE phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ calculation ▁ of ▁ the ▁ nth ▁ order ▁ polynomial ▁ of ▁ the ▁ nth ▁ order ▁ group . """ NEW_LINE phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 + sqrt ( 5 ) ) / 2 NEW_LINE assert ( integrate ( phi , ( x , 0 , 1 ) ) == 1 +
def GFG ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 NEW_LINE return int ( round ( pow ( phi , n ) / sqrt ( 5 ) ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT input = sys . stdin NEW_LINE n = len ( input ) NEW_LINE q = n NEW_LINE s = input [ : n ] NEW_LINE str = s [ n : ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT l = input [ n - 1 ] NEW_LINE r = input [ n - 1 ] NEW_LINE c1 = input [ 0 ] [ 0 ] NEW_LINE c2 = input [ 0 ] [ 1 ] NEW_LINE start = l NEW_LINE end = r NEW_LINE while start <= end : NEW_LINE INDENT if str [ start ] == c1 : NEW_LINE INDENT str [ start ] = c2 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT DEDENT for c in str : NEW_LINE INDENT print ( c ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT
def pythree_string ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( str1 ) - 1 and str1 [ i ] == str2 [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if str1 [ i ] > str2 [ i ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if str1 [ i ] < str2 [ i ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE a = sys . argv [ 1 ] NEW_LINE b = sys . argv [ 2 ] NEW_LINE ans = getNum ( a , b ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def test_a1133 ( ) : NEW_LINE INDENT x1 = Symbol ( " x " ) NEW_LINE y1 = Symbol ( " y " ) NEW_LINE x2 = Symbol ( " x " , positive = True ) NEW_LINE y2 = Symbol ( " y " , positive = True ) NEW_LINE x3 = Symbol ( " x " , negative = True ) NEW_LINE y3 = Symbol ( " y " , negative = True ) NEW_LINE assert "3" in str ( x1 ) NEW_LINE assert ( x1 + x2 - x3 ) == ( y1 + y2 - y3 ) NEW_LINE assert ( x3 + x2 - x1 ) == ( y3 + y2 - y1 ) NEW_LINE assert ( x1 + x3 - x2 ) == ( y1 + y3 - y2 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE f = open ( ' / proc / cpuinfo ' , ' w ' ) NEW_LINE t = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE while t : NEW_LINE INDENT n = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE s = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE tmp = [ ] NEW_LINE freq = [ 0 ] * 26 NEW_LINE freq [ s [ i ] - ' a ' ] += 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ s [ i ] - ' a ' ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in freq [ i ] : NEW_LINE INDENT tmp . append ( chr ( ord ( ' a ' ) + i ) + " " ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != tmp [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT f . write ( " % d \n " % count ) NEW_LINE DEDENT f . close ( ) NEW_LINE DEDENT
def GFG ( n , d ) : NEW_LINE INDENT n /= d NEW_LINE return ( n ) * ( 1 + n ) * d / 2 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . stdin NEW_LINE while t : NEW_LINE INDENT n = t . readline ( ) NEW_LINE s = t . readline ( ) NEW_LINE f = sys . stdin . buffer NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = f . readline ( ) NEW_LINE f = sys . stdin . buffer NEW_LINE sum += f . readline ( ) NEW_LINE DEDENT if t <= sum : NEW_LINE INDENT print ( " OK " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( t - sum ) NEW_LINE DEDENT t = sys . stdin . readline ( ) NEW_LINE DEDENT DEDENT
def GFG ( num ) : NEW_LINE INDENT fact = 1 NEW_LINE while num > 1 : NEW_LINE INDENT fact *= num NEW_LINE num -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT
def ques ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = sys . argv [ i ] NEW_LINE b = sys . argv [ i + 1 ] NEW_LINE if abs ( a - b ) == 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT DEDENT
def test_codechef ( ) : NEW_LINE INDENT import sympy NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE assert codechef ( t ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 2 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 3 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 4 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 5 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 6 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 7 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 8 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 9 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 10 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 11 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 12 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 13 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 14 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 16 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 17 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 18 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 19 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 20 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 21 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 22 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 23 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 24 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 25 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 26 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 27 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 28 ) == ( t , 0 ) NEW_LINE assert codechef ( t ** 29 ) ==
def GFG ( n , arr , ** kwargs ) : NEW_LINE INDENT count = [ 1 ] * ( n + 1 ) NEW_LINE if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT no_ways = 0 NEW_LINE for j in range ( len ( arr ) ) : NEW_LINE INDENT if i - arr [ j ] >= 0 : NEW_LINE INDENT no_ways += count [ i - arr [ j ] ] NEW_LINE DEDENT count [ i ] = no_ways NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import doctest NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy . linalg NEW_LINE import numpy . random NEW_LINE import numpy . testing NEW_LINE import numpy . testing NEW_LINE import numpy . testing NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE import numpy . testing . main NEW_LINE DEDENT
def test_practice_1 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' ) NEW_LINE while t != 0 : NEW_LINE INDENT a , b , c = symbols ( ' a ▁ b ▁ c ' , integer = True ) NEW_LINE if a == b and c == b : NEW_LINE INDENT assert 0 == sum ( [ a - b , b - c , c - a ] ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = abs ( a - b ) + abs ( b - c ) + abs ( c - a ) NEW_LINE sum -= 4 NEW_LINE assert max ( [ sum , sum ] ) == max ( [ sum , sum ] ) NEW_LINE DEDENT DEDENT DEDENT
def test_cf709_a ( ) : NEW_LINE INDENT f = Function ( ' f ' ) NEW_LINE n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE b = symbols ( ' b ' , integer = True , positive = True ) NEW_LINE d = symbols ( ' d ' , integer = True , positive = True ) NEW_LINE a , sum , count = f ( n ) . subs ( n , 1 ) . as_coeff_Mul ( ) NEW_LINE assert count == 1 NEW_LINE f = Function ( ' f ' ) NEW_LINE n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE b = symbols ( ' b ' , integer = True , positive = True ) NEW_LINE d = symbols ( ' d ' , integer = True , positive = True ) NEW_LINE a , sum , count = f ( n ) . subs ( n , 1 ) . as_coeff_Mul ( ) NEW_LINE assert count == 1 NEW_LINE f = Function ( ' f ' ) NEW_LINE n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE b = symbols ( ' b ' , integer = True , positive = True ) NEW_LINE d = symbols ( ' d ' , integer = True , positive = True ) NEW_LINE a , sum , count = f ( n ) . subs ( n , 1 ) . as_coeff_Mul ( ) NEW_LINE assert count == 1 NEW_LINE f = Function ( ' f ' ) NEW_LINE n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE b = symbols ( ' b ' , integer = True , positive = True ) NEW_LINE d = symbols ( ' d ' , integer = True , positive = True ) NEW_LINE a , sum , count = f ( n ) . subs ( n , 1 ) . as_coeff_Mul ( ) NEW_LINE assert count == 1 NEW_LINE f = Function ( ' f ' ) NEW_LINE n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE b = symbols ( ' b ' , integer = True , positive = True ) NEW_LINE d = symbols
def main ( arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return binary_search ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binary_search ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE Xor = Xor ^ arr [ i ] NEW_LINE DEDENT if Sum == Xor : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE x = [ False ] * 10000001 NEW_LINE def main ( ) : NEW_LINE INDENT f = sys . stdin NEW_LINE out = [ ] NEW_LINE tk = f . readline ( ) NEW_LINE n , m , k = Int ( tk . split ( ) ) NEW_LINE tk = f . readline ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT x [ Int ( tk . split ( ) [ 0 ] ) ] = True NEW_LINE DEDENT pos = 1 NEW_LINE while k : NEW_LINE INDENT if x [ pos ] : NEW_LINE INDENT print ( pos ) NEW_LINE return NEW_LINE DEDENT tk = f . readline ( ) NEW_LINE a , b = Int ( tk . split ( ) [ 0 ] ) , Int ( tk . split ( ) [ 1 ] ) NEW_LINE pos = ( pos , a , b ) NEW_LINE DEDENT print ( pos ) NEW_LINE DEDENT def Int ( s ) : NEW_LINE INDENT return int ( s ) NEW_LINE DEDENT def Lon ( s ) : NEW_LINE INDENT return long ( s ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT cntEven , cntOdd = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT cntEven += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 NEW_LINE DEDENT DEDENT evenPairs = 0 NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) NEW_LINE oddPairs = 0 NEW_LINE oddPairs += ( cntEven * cntOdd ) NEW_LINE print ( " Odd ▁ pairs ▁ = ▁ " , oddPairs ) NEW_LINE print ( " Even ▁ pairs ▁ = ▁ " , evenPairs ) NEW_LINE DEDENT
def _min_broadcast_range ( houses , towers ) : NEW_LINE INDENT n , m = len ( houses ) , len ( towers ) NEW_LINE left_tower = np . inf NEW_LINE right_tower = towers [ 0 ] NEW_LINE j , k = 0 , 0 NEW_LINE min_range = 0 NEW_LINE while j < n : NEW_LINE INDENT if houses [ j ] < right_tower : NEW_LINE INDENT left = houses [ j ] - left_tower NEW_LINE right = right_tower - houses [ j ] NEW_LINE local_max = left < right NEW_LINE if local_max > min_range : NEW_LINE INDENT min_range = local_max NEW_LINE DEDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT left_tower = towers [ k ] NEW_LINE if k < m - 1 : NEW_LINE INDENT k += 1 NEW_LINE right_tower = towers [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT right_tower = np . inf NEW_LINE DEDENT DEDENT DEDENT return min_range NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT assert ( 1 - divisor ** ( num / divisor ) ) == 1 NEW_LINE DEDENT
def test_tennis ( ) : NEW_LINE INDENT x = Symbol ( ' x ' ) NEW_LINE y = Symbol ( ' y ' ) NEW_LINE res , cnt1 , cnt2 = [ ] , [ ] , [ ] NEW_LINE n , m , z = symbols ( ' n ▁ m ▁ z ' , integer = True ) NEW_LINE for i in range ( m , z + 1 , m ) : NEW_LINE INDENT for j in range ( n , z + 1 , n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT DEDENT assert res == [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' aJ0181 ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - - no - input ' : NEW_LINE INDENT continue NEW_LINE DEDENT if o == ' - a ' : NEW_LINE INDENT if a == ' - - input ' : NEW_LINE INDENT continue NEW_LINE DEDENT if a == ' - b ' : NEW_LINE INDENT if b == ' - - output ' : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT elif o == ' - c ' : NEW_LINE INDENT if c == ' - - input ' : NEW_LINE INDENT continue NEW_LINE DEDENT if c == ' - b ' : NEW_LINE INDENT if b == ' - - output ' : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT elif c == ' - c ' : NEW_LINE INDENT if c == ' - - input ' : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def pytime_func ( ) : NEW_LINE INDENT import time NEW_LINE import numpy as np NEW_LINE import numpy . linalg NEW_LINE import numpy . random as np NEW_LINE class Stuff ( object ) : NEW_LINE INDENT def __init__ ( self , v , w ) : NEW_LINE INDENT self . v = v NEW_LINE self . w = w NEW_LINE self . performance = 1.0 * v / w NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT if self . performance < other . performance : NEW_LINE INDENT return 1 NEW_LINE DEDENT if self . performance > other . performance : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT DEDENT class Main ( object ) : NEW_LINE INDENT def __init__ ( self , v , w ) : NEW_LINE INDENT self . v = v NEW_LINE self . w = w NEW_LINE DEDENT def __reduce__ ( self ) : NEW_LINE INDENT return ( lambda x : np . reduce_sum ( x . v * self . v , self . v , self . v ) , lambda x , y : np . reduce_sum ( y * self . v , self . v , self . v ) ) NEW_LINE DEDENT def __reduce__ ( self ) : NEW_LINE INDENT return ( lambda x , y : np . reduce_sum ( x . v * self . v , self . v , self . v ) , lambda x , y : np . reduce_sum ( y * self . v , self . v , self . v ) ) NEW_LINE DEDENT def __reduce__ ( self ) : NEW_LINE INDENT return ( lambda x , y : np . reduce_sum ( x . v * self . v , self . v , self . v ) , lambda x , y : np . reduce_sum ( y * self . v , self . v , self . v ) ) NEW_LINE DEDENT def __reduce__ ( self ) : NEW_LINE INDENT return ( lambda x , y : np . reduce_sum ( x . v * self . v , self . v , self . v ) , lambda x , y : np . reduce_sum ( y * self . v , self . v , self . v ) ) NEW_LINE DEDENT def __reduce__ ( self ) : NEW_LINE INDENT return ( lambda x , y : np . reduce_sum ( x . v * self . v , self . v , self . v ) , lambda x , y : np . reduce_sum ( y * self . v , self . v , self . v ) ) NEW_LINE DEDENT DEDENT res = 0 NEW_LINE while w and not self . q : NEW_LINE INDENT s = self . q . pop ( ) NEW_LINE if w >= s . performance
def GFG ( arr , n ) : NEW_LINE INDENT ones , twos = 0 , 0 NEW_LINE common_bit_mask = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones , twos NEW_LINE DEDENT
def gen2int ( arr , n ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq [ arr [ i ] ] if i != 0 else 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) NEW_LINE DEDENT elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def test_CF_1447B_numbers_box ( ) : NEW_LINE INDENT data = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE count = data . shape [ 0 ] NEW_LINE for i in range ( count ) : NEW_LINE INDENT n , m = data . shape NEW_LINE arr = np . zeros ( ( n * m , n * m ) , dtype = int ) NEW_LINE nagivitetimes = 0 NEW_LINE min_num = np . inf NEW_LINE sum_num = 0 NEW_LINE for j in range ( len ( arr ) ) : NEW_LINE INDENT arr [ j ] = data [ j ] NEW_LINE if arr [ j ] < 0 : NEW_LINE INDENT arr [ j ] = 0 - arr [ j ] NEW_LINE nagivitetimes += 1 NEW_LINE sum_num += arr [ j ] NEW_LINE if min_num > arr [ j ] : min_num = arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT sum_num += arr [ j ] NEW_LINE if min_num > arr [ j ] : min_num = arr [ j ] NEW_LINE DEDENT DEDENT if nagivitetimes % 2 == 0 : NEW_LINE INDENT assert sum_num == 0 NEW_LINE DEDENT else : NEW_LINE INDENT assert sum_num - min_num * 2 == 0 NEW_LINE DEDENT DEDENT DEDENT
def pythager_make_ap ( arr , n ) : NEW_LINE INDENT initial_term , common_difference = 0 , 0 NEW_LINE if n == 3 : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) / 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( initial_term + ( i * common_difference ) , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n ) : NEW_LINE INDENT if ( y + x ) % ( y ^ x ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 15 NEW_LINE assert count_pairs ( n ) == 0 NEW_LINE DEDENT
def longest_palindrome ( s ) : NEW_LINE INDENT count = [ 0 ] * 128 NEW_LINE for c in s : NEW_LINE INDENT count [ c ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for v in count : NEW_LINE INDENT ans += v / 2 ** 2 NEW_LINE if ans % 2 == 0 and v % 2 == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def GFG ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if k > n - k : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def ex8 ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE count = 0 NEW_LINE flag = 0 NEW_LINE s = [ ] NEW_LINE for i in range ( 0 , len ( sys . argv ) ) : NEW_LINE INDENT s . append ( ' ▁ ' . join ( sys . argv [ i ] ) ) NEW_LINE DEDENT for i in range ( 0 , len ( sys . argv ) ) : NEW_LINE INDENT res = ' ' NEW_LINE count = 0 NEW_LINE for q in range ( 1 , 12 ) : NEW_LINE INDENT if s [ i ] [ q ] == ' X ' : NEW_LINE INDENT res = ' ▁ 1x12' NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( 2 , 6 ) : NEW_LINE INDENT flag = 0 NEW_LINE if 12 % j == 0 : NEW_LINE INDENT for k in range ( 1 , 12 / j ) : NEW_LINE INDENT flag = 0 NEW_LINE for p in range ( k , 12 , 12 / j ) : NEW_LINE INDENT if s [ i ] [ p ] == ' O ' : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT count += 1 NEW_LINE res += ' ▁ ' + str ( j ) + ' x ' + str ( 12 / j ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT flag = 0 NEW_LINE for l in range ( 1 , 12 ) : NEW_LINE INDENT if s [ i ] [ l ] == ' O ' : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT res += ' ▁ 12x1' NEW_LINE count += 1 NEW_LINE DEDENT print ( count , res ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy . linalg NEW_LINE import numpy . random NEW_LINE import numpy . testing NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE import numpy . testing . assert_equal NEW_LINE
def GFG ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 9 ) : NEW_LINE INDENT s = [ ] NEW_LINE if i <= n : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while not s : NEW_LINE INDENT tp = s . pop ( ) NEW_LINE s . append ( tp ) NEW_LINE for j in range ( tp % 10 , 9 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if x <= n : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def GFG ( cost , N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 0 ] = cost [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + cost [ i ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , dp [ i ] [ j - 1 ] ) + cost [ i ] NEW_LINE DEDENT DEDENT return float ( dp [ N - 1 ] [ N - 1 ] ) / ( 2 * N - 1 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE sieve_prime = [ 0 ] * ( MAX + 4 ) NEW_LINE sieve_count = [ 0 ] * ( MAX + 4 ) NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if sieve_prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if sieve_prime [ j ] == 0 : NEW_LINE INDENT sieve_prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT assert form_sieve ( ) == [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ]
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n , k , t , u , v , l NEW_LINE n = int ( sys . argv [ 1 ] ) NEW_LINE k = int ( sys . argv [ 2 ] ) NEW_LINE t = int ( sys . argv [ 3 ] ) NEW_LINE u = int ( sys . argv [ 4 ] ) NEW_LINE v = int ( sys . argv [ 5 ] ) NEW_LINE l = int ( sys . argv [ 6 ] ) NEW_LINE d = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT d . append ( sys . argv [ i ] ) NEW_LINE DEDENT d . reverse ( ) NEW_LINE pos , c , nk = 0 , 0 , 0 NEW_LINE tm = 0 NEW_LINE while pos < l : NEW_LINE INDENT if pos < d [ c ] : NEW_LINE INDENT if nk > 0 : NEW_LINE INDENT nk -= 1 NEW_LINE x = min ( l , pos + t * v ) NEW_LINE tm += ( x - pos ) / float ( v ) NEW_LINE pos = x NEW_LINE DEDENT else : NEW_LINE INDENT tm += ( d [ c ] - pos ) / float ( u ) NEW_LINE pos = d [ c ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if d [ c ] == pos : NEW_LINE INDENT x = min ( l , pos + t * v ) NEW_LINE tm += ( x - pos ) / float ( v ) NEW_LINE pos = x NEW_LINE yield pos NEW_LINE c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if nk < k : NEW_LINE INDENT c += 1 NEW_LINE nk += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = min ( l , d [ c ] + t * v ) NEW_LINE tm += ( x - pos ) / float ( v ) NEW_LINE pos = x NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( tm ) NEW_LINE DEDENT
def GFG ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE answer = 0 NEW_LINE prefix = [ 0 ] * n NEW_LINE suffix = [ 0 ] * n NEW_LINE seen = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = ( i - 1 >= 0 and prefix [ i - 1 ] or 0 ) NEW_LINE if seen [ s [ i ] - ' a ' ] == 0 : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev NEW_LINE DEDENT seen [ s [ i ] - ' a ' ] = 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT seen [ i ] = 0 NEW_LINE DEDENT suffix [ n - 1 ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] NEW_LINE if seen [ s [ i ] - ' a ' ] == 0 : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev NEW_LINE DEDENT seen [ s [ i ] - ' a ' ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if prefix [ i ] == suffix [ i ] : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def p_p121 ( p ) : NEW_LINE INDENT ''' p121 ▁ : ▁ p121 _ list ▁ p121 _ list ▁ COMMA ▁ p121 _ list ▁ ''' NEW_LINE p [ 0 ] = [ p [ 1 ] ] NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE num = { } NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT b . append ( i ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num [ b [ i ] ] += 1 NEW_LINE DEDENT ss = " " NEW_LINE ans = 0 NEW_LINE st = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT st [ i ] = True NEW_LINE s = [ ] NEW_LINE x = b [ i ] NEW_LINE sss = [ i ] NEW_LINE s . reverse ( ) NEW_LINE s = 1 NEW_LINE while not st [ x ] and num [ x ] == 1 and x != 0 and a [ x ] != 1 : NEW_LINE INDENT sss = [ x ] NEW_LINE s . reverse ( ) NEW_LINE st [ x ] = True NEW_LINE x = b [ x ] NEW_LINE s += 1 NEW_LINE DEDENT if s > ans : NEW_LINE INDENT ans = s NEW_LINE ss = s . reverse ( ) . encode ( ' utf - 8' ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE print ( ss ) NEW_LINE DEDENT
def py2int ( ) : NEW_LINE INDENT import sys NEW_LINE arr1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] NEW_LINE arr2 = [ 2 , 3 , 8 , 13 ] NEW_LINE def merge ( m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j , last = arr1 [ m - 1 ] , arr2 [ i ] NEW_LINE for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT arr1 [ j + 1 ] , arr1 [ j ] = arr1 [ j ] , arr1 [ i ] NEW_LINE DEDENT if j != m - 2 or last > arr2 [ i ] : NEW_LINE INDENT arr1 [ j + 1 ] , arr2 [ i ] = arr2 [ i ] , arr2 [ i ] NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT merge ( len ( arr1 ) , len ( arr2 ) ) NEW_LINE print ( " After ▁ Merging ▁ \n First ▁ Array : ▁ " ) NEW_LINE print ( sorted ( arr1 ) ) NEW_LINE print ( " Second ▁ Array : ▁ " ) NEW_LINE print ( sorted ( arr2 ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if not isinstance ( a , int ) : NEW_LINE INDENT return NEW_LINE DEDENT assert gcd ( b % a , a ) == gcd ( b , a ) NEW_LINE assert same_remainder ( a , gcd ( b , c ) ) == gcd ( c , a ) NEW_LINE a1 , b1 , c1 = ( b - a ) , ( c - b ) , ( c - a ) NEW_LINE assert same_remainder ( a1 , gcd ( b1 , c1 ) ) == gcd ( b1 , c1 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global verbose , fp , join , verbose NEW_LINE if verbose > 0 : NEW_LINE INDENT initReader ( ) NEW_LINE a = nextLong ( ) NEW_LINE b = nextLong ( ) NEW_LINE c = nextLong ( ) NEW_LINE d = nextLong ( ) NEW_LINE an = [ a , b , c ] NEW_LINE an . sort ( ) NEW_LINE ans = 0 NEW_LINE if an [ 1 ] - an [ 0 ] < d : NEW_LINE INDENT ans += ( d - an [ 1 ] + an [ 0 ] ) NEW_LINE DEDENT if an [ 2 ] - an [ 1 ] < d : NEW_LINE INDENT ans += ( d - an [ 2 ] + an [ 1 ] ) NEW_LINE DEDENT fp . write ( ans ) NEW_LINE fp . close ( ) NEW_LINE DEDENT global reader NEW_LINE global tokenizer NEW_LINE global fp NEW_LINE global initReader NEW_LINE if not initReader ( ) : NEW_LINE INDENT initReader ( ) NEW_LINE DEDENT fp = open ( join ( join ( dirname ( __file__ ) , ' . . ' ) , ' r ' ) ) NEW_LINE tokenizer = open ( join ( dirname ( __file__ ) , ' tokenizer . txt ' ) ) NEW_LINE fp = open ( join ( dirname ( __file__ ) , ' tokenizer . txt ' ) , ' w ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE fp . write ( ' ' ) NEW_LINE DEDENT
def GFG ( n , parts , next_part ) : NEW_LINE INDENT if parts == 0 and n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n <= 0 or parts <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ n ] [ next_part ] [ parts ] != - 1 : NEW_LINE INDENT return dp [ n ] [ next_part ] [ parts ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( next_part , n + 1 ) : NEW_LINE INDENT ans += count_ways_util ( n - i , parts - 1 , i ) NEW_LINE DEDENT return ( dp [ n ] [ next_part ] [ parts ] , ans ) NEW_LINE DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if ( a + b ) % 2 == 0 : NEW_LINE INDENT return ( ( a + b ) / 2 ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def GFG ( x , y , z ) : NEW_LINE INDENT N = 101 NEW_LINE mod = int ( 1e9 + 7 ) NEW_LINE exactsum = [ 0 ] * N NEW_LINE exactnum = [ 0 ] * N NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 NEW_LINE exactnum [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 0 , x ) : NEW_LINE INDENT for j in range ( 0 , y ) : NEW_LINE INDENT for k in range ( 0 , z ) : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] % mod NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT CHARS = 26 NEW_LINE def is_valid_string ( str ) : NEW_LINE INDENT freq = [ 0 ] * CHARS NEW_LINE for c in str : NEW_LINE INDENT freq [ c - ' a ' ] += 1 NEW_LINE DEDENT i , freq1 , count_freq1 = 0 , 0 , 0 NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT freq1 , count_freq1 = freq [ i ] , 1 NEW_LINE break NEW_LINE DEDENT DEDENT j , freq2 , count_freq2 = 0 , 0 , 0 NEW_LINE for j in range ( i + 1 , CHARS ) : NEW_LINE INDENT if freq [ j ] != 0 : NEW_LINE INDENT if freq [ j ] == freq1 : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1 NEW_LINE freq2 = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , CHARS ) : NEW_LINE INDENT if freq [ k ] != 0 : NEW_LINE INDENT if freq [ k ] == freq1 : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT if freq [ k ] == freq2 : NEW_LINE INDENT count_freq2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if count_freq1 > 1 and count_freq2 > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def is_valid_string ( str ) : NEW_LINE INDENT return ( str . find ( ' abcbc ' ) != - 1 ) NEW_LINE DEDENT def is_valid_string ( str ) : NEW_LINE INDENT return ( str . find ( ' abcba ' ) != - 1 ) NEW_LINE DEDENT def is_valid_string ( str ) : NEW_LINE INDENT return ( str . find ( ' abcba ' ) != - 1 ) NEW_LINE DEDENT def is_valid_string ( str ) : NEW_LINE INDENT return ( str . find ( ' abcba ' ) != - 1 ) NEW_LINE DEDENT def is_valid_string ( str ) : NEW_LINE INDENT return ( str . find ( ' abcba ' ) != - 1 ) NEW_LINE DEDENT def is_valid_string ( str ) : NEW_LINE INDENT return ( str . find ( ' abcba ' ) != - 1 ) NEW_LINE DEDENT def is_valid_string ( str ) : NEW_LINE INDENT return ( str . find ( ' abcba ' ) != - 1 ) NEW_LINE DEDENT def is_valid_string ( str ) : NEW_LINE INDENT return ( str . find ( ' abcba ' ) != - 1 ) NEW_LINE DEDENT return is_valid_string , is_valid_string , is_valid_string NEW_LINE
def test_codechef ( ) : NEW_LINE INDENT import sys NEW_LINE import doctest NEW_LINE import os NEW_LINE import tempfile NEW_LINE t = sys . argv [ 1 ] NEW_LINE while t : NEW_LINE INDENT s = sys . stdin . readline ( ) NEW_LINE ch = s . split ( ' \n ' ) NEW_LINE for i in range ( len ( ch ) ) : NEW_LINE INDENT if ( i + 1 ) % 2 != 0 : NEW_LINE INDENT if ch [ i ] != ' a ' : NEW_LINE INDENT ch [ i ] = ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT ch [ i ] = ' b ' NEW_LINE DEDENT DEDENT elif ( i + 1 ) % 2 == 0 : NEW_LINE INDENT if ch [ i ] != ' z ' : NEW_LINE INDENT ch [ i ] = ' z ' NEW_LINE DEDENT else : NEW_LINE INDENT ch [ i ] = ' y ' NEW_LINE DEDENT DEDENT DEDENT s = str ( ch ) NEW_LINE assert s == ' ' NEW_LINE DEDENT DEDENT
def GFG ( A , B ) : NEW_LINE INDENT number_of_subsequences = 1 NEW_LINE sizeOfB = len ( B ) NEW_LINE sizeOfA = len ( A ) NEW_LINE inf = 1000000 NEW_LINE next = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( sizeOfB ) : NEW_LINE INDENT for j in range ( sizeOfB ) : NEW_LINE INDENT next [ i ] [ j ] = inf NEW_LINE DEDENT DEDENT for i in range ( sizeOfB ) : NEW_LINE INDENT next [ B [ i ] - ' a ' ] [ i ] = i NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( sizeOfB - 2 , - 1 , - 1 ) : NEW_LINE INDENT if next [ i ] [ j ] == inf : NEW_LINE INDENT next [ i ] [ j ] = next [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT pos = 0 NEW_LINE i = 0 NEW_LINE while i < sizeOfA : NEW_LINE INDENT if pos == 0 and next [ A [ i ] - ' a ' ] [ pos ] == inf : NEW_LINE INDENT number_of_subsequences = - 1 NEW_LINE break NEW_LINE DEDENT elif pos < sizeOfB and next [ A [ i ] - ' a ' ] [ pos ] < inf : NEW_LINE INDENT nextIndex = next [ A [ i ] - ' a ' ] [ pos ] + 1 NEW_LINE pos = nextIndex NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number_of_subsequences += 1 NEW_LINE pos = 0 NEW_LINE DEDENT DEDENT return number_of_subsequences NEW_LINE DEDENT
def main ( rgs ) : NEW_LINE INDENT """ STRNEWLINE ▁ Main ▁ function ▁ for ▁ the ▁ algorithm ▁ of ▁ the ▁ algorithm ▁ of ▁ the ▁ input ▁ file . STRNEWLINE ▁ """ NEW_LINE f = open ( rgs , ' r ' ) NEW_LINE stringBuilder = [ ] NEW_LINE t = int ( f . readline ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a = f . readline ( ) . split ( ) NEW_LINE row = int ( a [ 0 ] ) NEW_LINE col = int ( a [ 1 ] ) NEW_LINE ans = [ ] NEW_LINE ansarray = [ ] NEW_LINE p = 0 NEW_LINE rowarray = [ 0 , 0 , row - 1 , row - 1 ] NEW_LINE colarray = [ 0 , col - 1 , 0 , col - 1 ] NEW_LINE for j in range ( row ) : NEW_LINE INDENT for k in range ( col ) : NEW_LINE INDENT dis = 0 NEW_LINE for l in range ( 4 ) : NEW_LINE INDENT dis = max ( dis , abs ( rowarray [ l ] - j ) + abs ( colarray [ l ] - k ) ) NEW_LINE DEDENT ansarray . append ( dis ) NEW_LINE DEDENT DEDENT ansarray . sort ( ) NEW_LINE for j in range ( len ( ansarray ) ) : NEW_LINE INDENT ans . append ( ansarray [ j ] + " ▁ " ) NEW_LINE DEDENT stringBuilder . append ( ans ) NEW_LINE DEDENT print ( stringBuilder ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT print ( '1' , end = ' ▁ ' ) NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT rank = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT rank += 1 NEW_LINE DEDENT DEDENT print ( rank , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE h = sys . argv [ 1 ] NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( sys . argv [ i ] ) NEW_LINE b . append ( sys . argv [ i + 1 ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE ans = sys . maxint NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT h -= b [ i - 1 ] NEW_LINE DEDENT cnt = 0 NEW_LINE if h > 0 : NEW_LINE INDENT cnt = ( h + a [ - 1 ] - 1 ) / a [ - 1 ] NEW_LINE DEDENT ans = min ( ans , cnt + i ) NEW_LINE DEDENT sys . stdout . write ( ans ) NEW_LINE DEDENT
def test_digits ( ) : NEW_LINE INDENT n = 15 NEW_LINE k = 4 NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert firstkdigits ( n , k ) == n NEW_LINE assert
def main ( ) : NEW_LINE INDENT r = requests . get ( ' http : / / www . google . com / ' ) NEW_LINE try : NEW_LINE INDENT m , n = re . findall ( r ' ( \d + ) ' , r . text ) NEW_LINE if m < n : NEW_LINE INDENT t = m NEW_LINE m , n = re . findall ( r ' ( \d + ) ' , r . text ) NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT t , n = re . findall ( r ' ( \d + ) ' , r . text ) NEW_LINE m , n = re . findall ( r ' ( \d + ) ' , r . text ) NEW_LINE DEDENT print ( m , n ) NEW_LINE DEDENT except requests . ConnectionError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s = sys . stdin . read ( ) NEW_LINE a = [ 0 ] * 26 NEW_LINE sum = 0 NEW_LINE for i in s : NEW_LINE INDENT a [ i - ' a ' ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT sum += a [ i ] % 2 NEW_LINE DEDENT print ( sum / 2 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT i , len , temp , comp = 0 , 0 , 0 , 0 NEW_LINE temp = num NEW_LINE while True : NEW_LINE INDENT len += 1 NEW_LINE num , temp = num / 10 , temp NEW_LINE if abs ( num ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT num , temp = temp , temp NEW_LINE comp = int ( pow ( 10 , len ) - num ) NEW_LINE assert comp == 0 NEW_LINE DEDENT
def test_gf_count_unset_bits ( ) : NEW_LINE INDENT x = ZZ . map ( [ 1 , 2 , 3 ] ) NEW_LINE n = ZZ . map ( [ 1 , 2 , 3 ] ) NEW_LINE assert gf_count_unset_bits ( x , n ) == 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ minOperations ▁ function . """ NEW_LINE maxi , result = 0 , 0 NEW_LINE freq = np . zeros ( 1000001 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x ] += 1 NEW_LINE DEDENT maxi = np . max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def get_total_ways ( N , M , X ) : NEW_LINE INDENT dp = [ ] NEW_LINE if X == 1 : NEW_LINE INDENT dp . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp . append ( 0 ) NEW_LINE DEDENT if X == 1 : NEW_LINE INDENT dp . append ( 0 ) NEW_LINE dp . append ( M - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp . append ( 1 ) NEW_LINE dp . append ( ( M - 2 ) ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] [ 1 ] ) NEW_LINE dp . append ( dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] NEW_LINE DEDENT
def get_minnum ( a , b , c ) : NEW_LINE INDENT if c < a or c > b : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b / c ) ** 2 ) + c NEW_LINE return x NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE s = sys . argv [ 1 : ] NEW_LINE x = 0 NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' I ' : x += 1 NEW_LINE else : x -= 1 NEW_LINE max = max ( max , x ) NEW_LINE DEDENT sys . exit ( max ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while True : NEW_LINE INDENT ans = 0 NEW_LINE n , m = sys . stdin . readline ( ) . split ( ) NEW_LINE al = [ ] NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT al . append ( ( sys . stdin . readline ( ) , i ) ) NEW_LINE DEDENT al . sort ( ) NEW_LINE while not al : NEW_LINE INDENT st = al . pop ( 0 ) NEW_LINE m -= st . d NEW_LINE if m <= 0 : NEW_LINE INDENT ans -= m * st . p NEW_LINE break NEW_LINE DEDENT DEDENT while not al : NEW_LINE INDENT st = al . pop ( 0 ) NEW_LINE ans += st . d * st . p NEW_LINE DEDENT sys . stdout . write ( ans ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE front = PriorityQueue ( ) NEW_LINE back = PriorityQueue ( ) NEW_LINE arr = [ ] NEW_LINE front_sum = 0 NEW_LINE back_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = sys . argv [ i ] NEW_LINE front_sum += x NEW_LINE front . add ( x ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr . append ( sys . argv [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = sys . argv [ i ] NEW_LINE back_sum += x NEW_LINE back . add ( - x ) NEW_LINE DEDENT values = [ front_sum , - back_sum ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT front_sum += arr [ i ] NEW_LINE front . add ( arr [ i ] ) NEW_LINE front_sum -= front . pop ( ) NEW_LINE values [ i + 1 ] += front_sum NEW_LINE back_sum += arr [ n - i - 1 ] NEW_LINE back . add ( - arr [ n - i - 1 ] ) NEW_LINE back_sum += back . pop ( ) NEW_LINE values [ n - i - 1 ] -= back_sum NEW_LINE DEDENT max = long ( 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max = max ( max , values [ i ] ) NEW_LINE DEDENT print ( max ) NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT arr = [ 1 , 5 , 6 ] NEW_LINE countWays = [ 1 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( len ( arr ) ) : NEW_LINE INDENT if i >= arr [ j ] : NEW_LINE INDENT countWays [ i ] += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT DEDENT return countWays NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return number_of_ways ( x - 1 ) + ( x - 1 ) * number_of_ways ( x - 2 ) NEW_LINE DEDENT DEDENT
def GFG ( a , n ) : NEW_LINE INDENT hm = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm . append ( a [ i ] ) NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if hm [ a [ i ] ] != 0 : NEW_LINE INDENT print ( a [ i ] , " - > " , cumul ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT
def test_gf_gf_add_subs_range ( ) : NEW_LINE INDENT flag = False NEW_LINE possible_a , possible_b , possible_c = gf_add_subs_range ( [ 1 , 2 , 3 ] , [ 1 , 2 , 3 ] , ZZ ) NEW_LINE numbers_in_range = ( R - 1 , R - 1 ) NEW_LINE if numbers_in_range < 3 : NEW_LINE INDENT flag = False NEW_LINE DEDENT elif numbers_in_range > 3 : NEW_LINE INDENT flag = True NEW_LINE if L % 2 : NEW_LINE INDENT L += 1 NEW_LINE DEDENT possible_a , possible_b , possible_c = gf_add_subs_range ( [ 1 , 2 , 3 ] , [ 1 , 2 , 3 ] , ZZ ) NEW_LINE DEDENT else : NEW_LINE INDENT if not ( L % 2 ) : NEW_LINE INDENT flag = True NEW_LINE possible_a , possible_b , possible_c = gf_add_subs_range ( [ 1 , 2 , 3 ] , [ 1 , 2 , 3 ] , ZZ ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT assert gf_add_subs_range ( [ 1 , 2 , 3 ] , [ 1 , 2 , 3 ] , ZZ ) == [ 1 , 2 , 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT assert gf_add_subs_range ( [ 1 , 2 , 3 ] , [ 1 , 2 , 3 ] , ZZ ) == [ 1 , 2 , 3 ] NEW_LINE DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT alphabets = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE conversion = ' ' NEW_LINE s2 = ' ' NEW_LINE for i in str1 : NEW_LINE INDENT s2 += alphabets [ charset . index ( i ) ] NEW_LINE DEDENT return s2 NEW_LINE DEDENT
def pythree_integers ( count , a , n , num , k ) : NEW_LINE INDENT """ STRNEWLINE ▁ Generate ▁ a ▁ set ▁ of ▁ integers ▁ from ▁ a ▁ list ▁ of ▁ integers . STRNEWLINE STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Permutation STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ from ▁ sympy . combinatorics . partitions ▁ import ▁ Partition STRNEWLINE ▁ > > > ▁ print ( partition ( 3 , ▁ a , ▁ n , ▁ num , ▁ k ) ) STRNEWLINE ▁ > > >
def GFG ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while x : NEW_LINE INDENT prod *= ( x % 10 ) NEW_LINE x /= 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT MAX = 100005 NEW_LINE isPrime = [ False ] * MAX NEW_LINE sieveOfEratostheneses = [ False ] * MAX NEW_LINE isPrime [ 1 ] = True NEW_LINE for i in range ( 2 , i * 2 < MAX ) : NEW_LINE INDENT if not isPrime [ i ] : NEW_LINE INDENT for j in range ( 2 * i , MAX , i += 1 ) : NEW_LINE INDENT isPrime [ j ] = True NEW_LINE DEDENT DEDENT DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while num : NEW_LINE INDENT if not isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT num = num + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT minNumber = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if not isPrime [ sum ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( sum ) NEW_LINE return num - sum NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT MAX = 25 NEW_LINE get_min_sum , max_bit , sum , ans = 0 , 0 , 0 , 0 NEW_LINE for d in range ( n ) : NEW_LINE INDENT e , f = arr [ d ] , 0 NEW_LINE while e : NEW_LINE INDENT rem = e % 2 NEW_LINE e , f = e // 2 , f % 2 NEW_LINE if rem == 1 : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = int ( pow ( 2 , d ) ) NEW_LINE if bits_count [ d ] > n // 2 : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans NEW_LINE sum = sum + arr [ d ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def _70B ( ) : NEW_LINE INDENT import sys NEW_LINE import tokenize NEW_LINE import doctest NEW_LINE import os NEW_LINE import tempfile NEW_LINE import re NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import os NEW_LINE import sys NEW_LINE import tempfile NEW_LINE import re NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import re NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import re NEW_LINE import sys NEW_LINE import tempfile NEW_LINE import re NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import re NEW_LINE import sys NEW_LINE import tempfile NEW_LINE import re NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import re NEW_LINE import sys NEW_LINE import tempfile NEW_LINE import re NEW_LINE import subprocess NEW_LINE import re NEW_LINE import sys NEW_LINE import tempfile NEW_LINE import re NEW_LINE import subprocess NEW_LINE import re NEW_LINE import sys NEW_LINE import tempfile NEW_LINE import re NEW_LINE import subprocess NEW_LINE import tempfile NEW_LINE import re NEW_LINE import sys NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE
def test_mikeand_shortcuts ( ) : NEW_LINE INDENT f = open ( ' / tmp / mikeand _ shortcuts . txt ' , ' r ' ) NEW_LINE out = [ ] NEW_LINE tk = f . readline ( ) NEW_LINE n = int ( tk . split ( ) [ 0 ] ) NEW_LINE a = [ ] NEW_LINE tk = f . readline ( ) NEW_LINE for i in tk : NEW_LINE INDENT a . append ( int ( i ) - 1 ) NEW_LINE DEDENT g = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT g . append ( [ ] ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] != i : NEW_LINE INDENT g [ i ] . append ( a [ i ] ) NEW_LINE DEDENT g [ i ] . append ( i + 1 ) NEW_LINE g [ i + 1 ] . append ( i ) NEW_LINE DEDENT if a [ n - 1 ] != n - 1 : NEW_LINE INDENT g [ n - 1 ] . append ( a [ n - 1 ] ) NEW_LINE DEDENT dist = [ ] NEW_LINE del dist [ 0 ] NEW_LINE dist . append ( 0 ) NEW_LINE q = Queue ( ) NEW_LINE q . put ( 0 ) NEW_LINE while not q . empty ( ) : NEW_LINE INDENT u = q . get ( ) NEW_LINE for v in g [ u ] : NEW_LINE INDENT if dist [ v ] == - 1 : NEW_LINE INDENT q . put ( v ) NEW_LINE dist [ v ] = dist [ u ] + 1 NEW_LINE DEDENT DEDENT DEDENT out . append ( dist [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT out . append ( " % d " % dist [ i ] ) NEW_LINE DEDENT print ( out ) NEW_LINE DEDENT
def test_strange_birth_day ( ) : NEW_LINE INDENT n = np . random . randint ( 1 , 10 , size = ( 10 , 10 ) ) NEW_LINE m = np . random . randint ( 1 , 10 , size = ( 10 , 10 ) ) NEW_LINE n = n . astype ( int ) NEW_LINE ans = 0 NEW_LINE j = 0 NEW_LINE for i in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT k = n [ i ] NEW_LINE if k in m : NEW_LINE INDENT if m [ k ] > m [ j ] : NEW_LINE INDENT ans += m [ j ] NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += m [ k ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i <= j : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count >= i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global verbose , recurse , verbose , recurse NEW_LINE opts , args = getopt . getopt ( sys . argv [ 1 : ] , " p : r : " , [ " recurse " , " rev " ] ) NEW_LINE if opts == [ ] : NEW_LINE INDENT usage ( ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT if recurse : NEW_LINE INDENT recurse = 1 NEW_LINE DEDENT else : NEW_LINE INDENT recurse = 0 NEW_LINE DEDENT for o , a , b in opts : NEW_LINE INDENT if o == ' - p ' : NEW_LINE INDENT sys . stdout . write ( recurse ) NEW_LINE DEDENT elif o == ' - r ' : NEW_LINE INDENT temp = os . path . join ( os . path . dirname ( __file__ ) , a ) NEW_LINE temp . reverse ( ) NEW_LINE sys . stdout . write ( temp ) NEW_LINE DEDENT else : NEW_LINE INDENT p = o NEW_LINE sys . stdout . write ( p ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( A , n ) : NEW_LINE INDENT dp = [ [ 0 ] * 2000 for i in range ( n ) ] NEW_LINE flag = 1 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT for i in range ( - sum , sum + 1 ) : NEW_LINE INDENT try : NEW_LINE INDENT dp [ 0 ] [ i ] = int ( A [ i ] ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , sum + 1 ) : NEW_LINE INDENT try : NEW_LINE INDENT dp [ flag ] [ j ] = int ( A [ i - 1 ] ) NEW_LINE if j - A [ i - 1 ] <= sum and j - A [ i - 1 ] >= - sum : NEW_LINE INDENT dp [ flag ] [ j ] = dp [ flag ^ 1 ] [ j - A [ i - 1 ] ] NEW_LINE DEDENT if j + A [ i - 1 ] <= sum and j + A [ i - 1 ] >= - sum and dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] != int ( A [ i - 1 ] ) : NEW_LINE INDENT dp [ flag ] [ j ] = min ( dp [ flag ] [ j ] , dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] + 1 ) NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT flag = flag ^ 1 NEW_LINE DEDENT for i in range ( 0 , sum + 1 ) : NEW_LINE INDENT if dp [ flag ^ 1 ] [ i ] != int ( A [ i ] ) : NEW_LINE INDENT return dp [ flag ^ 1 ] [ i ] NEW_LINE DEDENT DEDENT return n - 1 NEW_LINE DEDENT
def pydot ( ) : NEW_LINE INDENT import numpy as np NEW_LINE eps = 1e-10 NEW_LINE np . random . seed ( 0 ) NEW_LINE x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = np . random . uniform ( size = ( 10 , 10 ) ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT vax = x2 - x1 , y2 - y1 , x3 - x1 , y3 - y1 , x4 - x1 , y4 - y1 NEW_LINE vbx = x4 - x3 , y4 - y3 NEW_LINE if abs ( vax * vbx + vay * vby ) < eps : NEW_LINE INDENT return ' YES ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' NO ' NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' aJ0221 ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - a ' : NEW_LINE INDENT if a == ' - - all ' : NEW_LINE INDENT print ( ' all ' ) NEW_LINE DEDENT elif o == ' - - all ' : NEW_LINE INDENT print ( ' all ' ) NEW_LINE DEDENT elif o == ' - - all ' : NEW_LINE INDENT print ( ' all ' ) NEW_LINE DEDENT elif o == ' - - all ' : NEW_LINE INDENT print ( ' all ' ) NEW_LINE DEDENT elif o == ' - - all ' : NEW_LINE INDENT print ( ' all ' ) NEW_LINE DEDENT DEDENT DEDENT def get_talk ( num ) : NEW_LINE INDENT user = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT input = input ( ) NEW_LINE talk = get_talk ( i ) NEW_LINE if input == talk and m - cnt > 1 : NEW_LINE INDENT person = [ ] NEW_LINE cnt += 1 NEW_LINE DEDENT user = get_user ( user ) NEW_LINE DEDENT i = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if person [ i ] == False : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT for i in range ( i + 1 , m ) : NEW_LINE INDENT if person [ i ] == False : NEW_LINE INDENT print ( ' ▁ ' + str ( i + 1 ) ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT get_talk ( num ) NEW_LINE return NEW_LINE DEDENT
def GFG ( n , r ) : NEW_LINE INDENT l = [ [ ] for i in range ( 1001 ) ] NEW_LINE initialize ( ) NEW_LINE l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT nCr = l [ n ] [ r ] NEW_LINE return nCr NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE a = sys . argv [ 1 ] NEW_LINE b = sys . argv [ 2 ] NEW_LINE c = sys . argv [ 3 ] NEW_LINE d = sys . argv [ 4 ] NEW_LINE array = [ ] NEW_LINE for i in range ( a , b ) : NEW_LINE INDENT array . append ( i ) NEW_LINE DEDENT for i in range ( c , d ) : NEW_LINE INDENT array . append ( i ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 101 ) : NEW_LINE INDENT if array [ i ] == 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT sys . exit ( ans ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE assert GFG ( a , b , n , m ) == [ 2 , 3 ] NEW_LINE DEDENT
def problemB ( a , d , c ) : NEW_LINE INDENT i = d NEW_LINE j = c NEW_LINE mid = a [ ( d + c ) / 2 ] NEW_LINE while i <= j : NEW_LINE INDENT while a [ i ] < mid : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while a [ j ] > mid : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if i <= j : NEW_LINE INDENT tg = a [ i ] NEW_LINE a [ i ] , a [ j ] = a [ j ] , tg NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT if d < j : NEW_LINE INDENT quickSort ( a , d , j ) NEW_LINE DEDENT if i < c : NEW_LINE INDENT quickSort ( a , i , c ) NEW_LINE DEDENT DEDENT
def pytestcapi ( ) : NEW_LINE INDENT import sys NEW_LINE import doctest NEW_LINE T = sys . version_info [ : 2 ] NEW_LINE while T : NEW_LINE INDENT n = len ( sys . modules ) NEW_LINE c = getattr ( sys . modules [ __name__ ] , ' _ _ doc _ _ ' , None ) NEW_LINE del sys . modules [ __name__ ] NEW_LINE for m in sys . modules . values ( ) : NEW_LINE INDENT if m . __doc__ is None or m . __doc__ . startswith ( ' > > > ▁ ' ) : NEW_LINE INDENT print ( m ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def codforce ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ number ▁ of ▁ occurrences ▁ of ▁ the ▁ character ▁ in ▁ the ▁ string . STRNEWLINE ▁ """ NEW_LINE str = input ( ) NEW_LINE n = len ( str ) NEW_LINE s = " " NEW_LINE while n > 0 : NEW_LINE INDENT x = n % 2 NEW_LINE n /= 2 NEW_LINE s += x + " " NEW_LINE DEDENT ans = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == '1' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def test_b148 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE VP = symbols ( ' VP ' , real = True ) NEW_LINE VD = symbols ( ' VD ' , real = True ) NEW_LINE T = symbols ( ' T ' , real = True ) NEW_LINE F = symbols ( ' F ' , real = True ) NEW_LINE C = symbols ( ' C ' , real = True ) NEW_LINE if VD <= VP : NEW_LINE INDENT assert '0' in str ( x ) NEW_LINE return NEW_LINE DEDENT answer = 0 NEW_LINE start = T NEW_LINE while True : NEW_LINE INDENT x = start * VP / ( VD - VP ) NEW_LINE if ( start + x ) * VP >= C : NEW_LINE INDENT break NEW_LINE DEDENT start += 2 * x + F NEW_LINE answer += 1 NEW_LINE DEDENT assert answer == 0 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE t = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE x = LocalTime ( int ( s ) , int ( s ) ) NEW_LINE y = LocalTime ( int ( t ) , int ( t ) ) NEW_LINE print ( x - y . hour , y - y . minute ) NEW_LINE DEDENT
def GFG ( a , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] * a [ i - 1 ] < 0 : NEW_LINE INDENT cnt += 1 NEW_LINE longest = max ( longest , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT DEDENT return longest NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT sqa = int ( math . pow ( a , 2 ) ) NEW_LINE sqb = int ( math . pow ( b , 2 ) ) NEW_LINE sqc = int ( math . pow ( c , 2 ) ) NEW_LINE if sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb : NEW_LINE INDENT print ( " Right - angled ▁ Triangle " ) NEW_LINE DEDENT elif sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb : NEW_LINE INDENT print ( " Obtuse - angled ▁ Triangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Acute - angled ▁ Triangle " ) NEW_LINE DEDENT DEDENT
def GFG ( s , n ) : NEW_LINE INDENT global max NEW_LINE global count_subsequence NEW_LINE count_subsequence = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT try : NEW_LINE INDENT count_subsequence += 1 NEW_LINE result += C NEW_LINE DEDENT except : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def _main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE MAX = 100 NEW_LINE def check ( n , x , y , h ) : NEW_LINE INDENT try : NEW_LINE INDENT n , x , y , h = getopt . getopt ( sys . argv [ 1 : ] , " x : y : h " , [ " help " , " count " , " max " ] ) NEW_LINE DEDENT except getopt . GetoptError : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , MAX ) : NEW_LINE INDENT ch = check ( n , x , y , h , i , j ) NEW_LINE if ch : NEW_LINE INDENT print ( i , j , ch ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def count ( n , x , y , h , cx , cy ) : NEW_LINE INDENT ch = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if h : NEW_LINE INDENT ch = abs ( x [ i ] - cx ) + abs ( y [ i ] - cy ) + h [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if h [ i ] != max ( ch - abs ( x [ i ] - cx ) - abs ( y [ i ] - cy ) , 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return ch NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while n : NEW_LINE INDENT largest = int ( math . cbrt ( n ) ) NEW_LINE n -= ( largest * largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' a ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - a ' : NEW_LINE INDENT num = int ( a ) NEW_LINE DEDENT elif o == ' - a ' : NEW_LINE INDENT time = float ( a ) NEW_LINE DEDENT elif o == ' - a ' : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT num = 1 NEW_LINE DEDENT elif num > 1 : NEW_LINE INDENT num = 1 NEW_LINE DEDENT elif num < 0 : NEW_LINE INDENT num = - 1 NEW_LINE DEDENT elif num > 1 : NEW_LINE INDENT num = - num NEW_LINE DEDENT DEDENT elif o == ' - a ' : NEW_LINE INDENT if time == 0 : NEW_LINE INDENT time = float ( a ) NEW_LINE DEDENT elif time > 1 : NEW_LINE INDENT time = - time NEW_LINE DEDENT DEDENT elif o == ' - a ' : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT num = 1 NEW_LINE DEDENT elif num > 1 : NEW_LINE INDENT num = - num NEW_LINE DEDENT elif num < 0 : NEW_LINE INDENT num = - num NEW_LINE DEDENT DEDENT elif o == ' - a ' : NEW_LINE INDENT if time == 0 : NEW_LINE INDENT time = float ( a ) NEW_LINE DEDENT elif time > 1 : NEW_LINE INDENT time = - time NEW_LINE DEDENT DEDENT elif o == ' - a ' : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT num = 1 NEW_LINE DEDENT elif num > 1 : NEW_LINE INDENT num = - num NEW_LINE DEDENT elif num < 0 : NEW_LINE INDENT num = - num NEW_LINE DEDENT DEDENT elif o == ' - a ' : NEW_LINE INDENT if time == 0 : NEW_LINE INDENT time = float ( a ) NEW_LINE DEDENT elif time > 1 : NEW_LINE INDENT time = - time NEW_LINE DEDENT DEDENT elif o == ' - a ' : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT num = 1 NEW_LINE DEDENT elif num > 1 : NEW_LINE INDENT num = - num NEW_LINE DEDENT elif num < 0 : NEW_LINE INDENT num = - num NEW_LINE DEDENT DEDENT elif o == ' - a ' : NEW_LINE INDENT if time == 0 : NEW_LINE INDENT time = float ( a ) NEW_LINE DEDENT elif time > 1 : NEW_LINE INDENT time = - time NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE arr = [ ] NEW_LINE mx , mn , mx_count , mn_count = sys . argv [ 1 : ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( sys . argv [ i ] ) NEW_LINE mx , mn = max ( arr ) , min ( arr ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == mx : NEW_LINE INDENT mx_count += 1 NEW_LINE DEDENT if arr [ i ] == mn : NEW_LINE INDENT mn_count += 1 NEW_LINE DEDENT DEDENT if mx != mn : NEW_LINE INDENT print ( mx - mn , mx_count * mn_count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( mx - mn , mx_count * ( mx_count - 1 ) / 2 ) NEW_LINE DEDENT DEDENT
def GFG ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT x = int ( i ) NEW_LINE if i % x == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE N = len ( sys . argv ) NEW_LINE A = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT A . append ( sys . argv [ i ] ) NEW_LINE DEDENT print ( check ( A ) or " YES " ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if not N : NEW_LINE INDENT return 1 NEW_LINE DEDENT if N < 10 : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( [ max_prod ( N / 10 ) ** ( N % 10 ) , max_prod ( N / 10 - 1 ) ** 9 ] ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n NEW_LINE global sugoroku NEW_LINE input_sugoroku ( ) NEW_LINE solve_sugoroku ( ) NEW_LINE def solve_sugoroku ( ) : NEW_LINE INDENT dice = 0 NEW_LINE safes = sugoroku . split ( '0' ) NEW_LINE for i in safes : NEW_LINE INDENT dice = max ( dice , i ) NEW_LINE DEDENT print ( dice + 1 ) NEW_LINE DEDENT def input_sugoroku ( ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( sys . stdin . read ( ) ) NEW_LINE DEDENT sugoroku = ' ' . join ( s ) NEW_LINE DEDENT DEDENT
def test_practice2 ( ) : NEW_LINE INDENT x = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE y = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE t = np . arange ( len ( x ) ) NEW_LINE while t : NEW_LINE INDENT n = len ( x ) NEW_LINE x = np . array ( [ x [ i ] for i in range ( n ) ] ) NEW_LINE y = np . array ( [ y [ i ] for i in range ( n ) ] ) NEW_LINE t1 , t2 = 0 , 0 NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT x1 , y1 = x [ t1 ] , y [ t2 ] NEW_LINE if x1 == 0 : NEW_LINE INDENT y [ t2 ] = y1 ** 2 NEW_LINE DEDENT else : NEW_LINE INDENT x [ t1 ] = x1 ** 2 NEW_LINE DEDENT DEDENT np . sort ( x ) NEW_LINE np . sort ( y ) NEW_LINE sum = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum += np . sqrt ( x [ i ] + y [ i ] ) NEW_LINE DEDENT assert_almost_equal ( sum , np . sqrt ( x [ i ] ** 2 + y [ i ] ** 2 ) ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count /= i NEW_LINE DEDENT return count NEW_LINE DEDENT
def reduce_string ( s , l ) : NEW_LINE INDENT count , steps = 1 , 0 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT steps += ( count // 2 ) NEW_LINE count = 1 NEW_LINE DEDENT DEDENT steps += count // 2 NEW_LINE return steps NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE read = sys . stdin . readline ( ) NEW_LINE a , b , n = read . split ( ' ▁ ' ) NEW_LINE if b >= a : NEW_LINE INDENT print ( ' Impossible ' ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' ' NEW_LINE honest = get_honest ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += q ( honest , i ) if q ( honest , i ) else '1' NEW_LINE DEDENT print ( ' ! ▁ ' + ans ) NEW_LINE DEDENT def get_honest ( ) : NEW_LINE INDENT dis = b + 1 NEW_LINE list = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not list : NEW_LINE INDENT list . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT if q ( list [ - 1 ] , i ) : NEW_LINE INDENT list . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT list . pop ( ) NEW_LINE dis -= 1 NEW_LINE DEDENT DEDENT if len ( list ) >= dis : NEW_LINE INDENT return list . pop ( ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT q ( a , b ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE f = sys . stdout NEW_LINE x , y , a , b = sys . argv [ 1 : ] NEW_LINE res = [ ] NEW_LINE for i in range ( a , x + 1 ) : NEW_LINE INDENT for j in range ( b , y + 1 ) : NEW_LINE INDENT if i <= j : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( i + 1 , j ) NEW_LINE DEDENT DEDENT f . write ( ' \n ' . join ( res ) ) NEW_LINE for str in res : NEW_LINE INDENT f . write ( str ) NEW_LINE DEDENT f . close ( ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT mod = 1000000007L NEW_LINE mult = ( ( a % mod ) ** 2 ) % mod NEW_LINE ans , cnt = 0 , 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n , mod = n // 2 , mod NEW_LINE DEDENT if cnt % 2 == 1 : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT for i in range ( 3 , math . sqrt ( n ) , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n , mod = n // i , mod NEW_LINE DEDENT if cnt % 2 == 1 : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT ans = mult ( ans , ( 2 , ) ) NEW_LINE DEDENT return ans % mod NEW_LINE DEDENT
def test_cf32a ( ) : NEW_LINE INDENT input = BytesIO ( ) NEW_LINE s = input . getvalue ( ) NEW_LINE str = " " NEW_LINE for c in s : NEW_LINE INDENT if c == ' . ' : NEW_LINE INDENT str += 0 NEW_LINE DEDENT else : NEW_LINE INDENT if c == ' - ' and s [ - 1 ] == ' . ' : NEW_LINE INDENT str += 1 NEW_LINE DEDENT else : NEW_LINE INDENT str += 2 NEW_LINE DEDENT i = 1 NEW_LINE DEDENT DEDENT assert str == " \xEF\xBB\xBF " NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT min_ele = arr [ 0 ] NEW_LINE max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT min_ele = min ( min_ele , arr [ i ] ) NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT return ( max_ele - min_ele ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT a , b , c , N = input ( ) NEW_LINE while True : NEW_LINE INDENT a , b , c = next ( input ( ) ) NEW_LINE if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT sys . exit ( 0 ) NEW_LINE DEDENT N = int ( N ) NEW_LINE checking = [ 0 ] * ( a + b + c ) NEW_LINE temp = [ ] NEW_LINE del checking [ : ] NEW_LINE for j in range ( 2 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT a1 , b1 , c1 , check = next ( input ( ) ) NEW_LINE if check == 1 : NEW_LINE INDENT checking [ a1 - 1 ] = 1 NEW_LINE checking [ b1 - 1 ] = 1 NEW_LINE checking [ c1 - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp . append ( a1 ) NEW_LINE temp . append ( b1 ) NEW_LINE temp . append ( c1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if not temp : NEW_LINE INDENT break NEW_LINE DEDENT a2 , b2 , c2 = temp . pop ( ) NEW_LINE if checking [ a2 - 1 ] + checking [ b2 - 1 ] + checking [ c2 - 1 ] == 2 : NEW_LINE INDENT if checking [ a2 - 1 ] != 1 : NEW_LINE INDENT checking [ a2 - 1 ] = 3 NEW_LINE DEDENT elif checking [ b2 - 1 ] != 1 : NEW_LINE INDENT checking [ b2 - 1 ] = 3 NEW_LINE DEDENT else : NEW_LINE INDENT checking [ c2 - 1 ] = 3 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for contents in checking : NEW_LINE INDENT result = None NEW_LINE if contents == 3 : NEW_LINE INDENT result = 0 NEW_LINE DEDENT elif contents == 0 : NEW_LINE INDENT result = 2 NEW_LINE DEDENT else : NEW_LINE INDENT result = 1 NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ MGFG ▁ algorithm . """ NEW_LINE count_a = { } NEW_LINE count_b = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count_a . has_key ( i ) : NEW_LINE INDENT count_a [ i ] = count_a [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_a [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if count_b . has_key ( i ) : NEW_LINE INDENT count_b [ i ] = count_b [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_b [ i ] = 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE s = count_a . keys ( ) NEW_LINE for x in s : NEW_LINE INDENT if count_b . has_key ( x ) : NEW_LINE INDENT res += min ( count_b [ x ] , count_a [ x ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def get_GFG ( pos , first_d , last_d , tight , num ) : NEW_LINE INDENT M = 20 NEW_LINE dp = { } NEW_LINE def count ( pos , first_d , last_d , tight , num ) : NEW_LINE INDENT if pos == len ( num ) : NEW_LINE INDENT if first_d == last_d : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if dp [ pos ] [ first_d ] [ last_d ] [ tight ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ first_d ] [ last_d ] [ tight ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = ( tight == 1 and 9 or num [ pos ] ) NEW_LINE for dig in range ( 0 , limit ) : NEW_LINE INDENT curr_first = first_d NEW_LINE if pos == 0 : NEW_LINE INDENT curr_first = dig NEW_LINE DEDENT if curr_first == 0 and dig != 0 : NEW_LINE INDENT curr_first = dig NEW_LINE DEDENT curr_till = tight NEW_LINE if dig < num [ pos ] : NEW_LINE INDENT curr_till = 1 NEW_LINE DEDENT ans += count ( pos + 1 , curr_first , dig , curr_till , num ) NEW_LINE DEDENT return dp [ pos ] [ first_d ] [ last_d ] [ tight ] = ans NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT num = [ ] NEW_LINE while x > 0 : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT del num NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( M ) : NEW_LINE INDENT for l in range ( 2 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] [ l ] = - 1 NEW_LINE DEDENT DEDENT DEDENT return count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT L , R = 2 , 60 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE L , R = 1 , 1000 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE DEDENT DEDENT
def python_application_125 ( ) : NEW_LINE INDENT data = input ( ' Enter ▁ your ▁ number : ▁ ' ) NEW_LINE num = int ( data ) NEW_LINE old = - 1 NEW_LINE ans = 0 NEW_LINE for i in range ( num ) : NEW_LINE INDENT s = input ( ' Enter ▁ a ▁ number : ▁ ' ) NEW_LINE if s == 1 : NEW_LINE INDENT if old >= 0 : NEW_LINE INDENT ans *= ( i - old ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT old = i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def genbit ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while x > 0 : NEW_LINE INDENT x /= 2 NEW_LINE ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def check ( d , x ) : NEW_LINE INDENT if bit ( x / d ) <= bit ( d ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT bs = int ( math . sqrt ( n ) ) NEW_LINE l , r = 1 , int ( math . sqrt ( n ) ) NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if check ( m , n ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if not check ( l , n ) : NEW_LINE INDENT return l + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return l NEW_LINE DEDENT DEDENT count_divisor = n - bs + 1 NEW_LINE def main ( ) : NEW_LINE INDENT n = 5 NEW_LINE print ( count_divisor ( n ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ minimalSteps ▁ of ▁ the ▁ GFG . """ NEW_LINE dp = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp . append ( int ( i ) ) NEW_LINE DEDENT s1 , s2 = " " , " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 ] NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if s1 == s2 : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ - 1 ] NEW_LINE DEDENT
def GFG ( num , dig , base ) : NEW_LINE INDENT if dig == 1 and num < base : NEW_LINE INDENT return True NEW_LINE DEDENT if dig > 1 and num >= base : NEW_LINE INDENT return check_util ( num // base , -- dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT getMin = arr [ i ] NEW_LINE while i <= j : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return minVal NEW_LINE getMax = arr [ i ] NEW_LINE while i <= j : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return maxVal NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE n = len ( sys . argv ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( sys . argv [ i ] ) NEW_LINE DEDENT s = sys . stdin . readline ( ) NEW_LINE sum = 0 NEW_LINE for ch in s : NEW_LINE INDENT if ch == ' B ' : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT DEDENT ans = sum NEW_LINE sum1 = sum NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum1 -= a [ i ] NEW_LINE DEDENT ans = max ( ans , sum1 ) NEW_LINE DEDENT sum1 = sum NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == ' A ' : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum1 -= a [ i ] NEW_LINE DEDENT ans = max ( ans , sum1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE while n -- : NEW_LINE INDENT xa , ya , xb , yb , xc , yc , xd , yd = sys . argv [ n ] NEW_LINE katamukiab = ( yb - ya ) / ( xb - xa ) NEW_LINE katamukicd = ( yd - yc ) / ( xd - xc ) NEW_LINE if katamukiab == katamukicd : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n , a , b ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return b NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return ( a ^ b ) NEW_LINE DEDENT return nth_xor_fib ( n % 3 , a , b ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE card1 , card2 = sys . argv [ 1 : ] NEW_LINE player1 , player2 = sys . argv [ 2 : ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT card1 = card1 . split ( ) NEW_LINE card2 = card2 . split ( ) NEW_LINE if card1 [ 0 ] >= card2 [ 0 ] : NEW_LINE INDENT player1 += 3 NEW_LINE DEDENT elif card1 [ 0 ] <= card2 [ 0 ] : NEW_LINE INDENT player2 += 3 NEW_LINE DEDENT elif card1 [ 0 ] == card2 [ 0 ] : NEW_LINE INDENT player1 += 1 NEW_LINE player2 += 1 NEW_LINE DEDENT DEDENT print ( player1 , player2 ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = float ( 1.268 * a ) NEW_LINE A = float ( 0.70477 * pow ( h , 2 ) ) NEW_LINE assert A == 1 NEW_LINE DEDENT
def p073 ( ) : NEW_LINE INDENT print ( [ ' p073' ] ) NEW_LINE return str ( stern_brocot_count ( 1 , 3 , 1 , 2 ) ) NEW_LINE DEDENT
def pyfill ( n ) : NEW_LINE INDENT import sys NEW_LINE import numpy NEW_LINE import numpy . random NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE import numpy . ma . marray NEW_LINE
def GFG ( prime , n ) : NEW_LINE INDENT prime = [ False for i in range ( 2 , n + 1 ) ] NEW_LINE prime = [ False for i in range ( 2 , n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT sum_prime = int ( pow ( 10 , d ) ) - 1 NEW_LINE prime = [ True for i in range ( 2 , n + 1 ) ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT sieve ( prime , max_prime = max_prime ) NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , max_prime + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT prime = [ False , False ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT sum_prime = int ( pow ( 2 , d ) - 1 ) NEW_LINE prime = [ True for i in range ( 2 , maxVal + 1 ) ] NEW_LINE sieve ( prime , max_primes = max_primes ) NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , maxVal + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def test_CF ( ) : NEW_LINE INDENT f = py . io . TextIO ( ) NEW_LINE f . reset ( ) NEW_LINE test = [ ] NEW_LINE for t in range ( test ) : NEW_LINE INDENT n , k = divmod ( t , 1000 ) NEW_LINE list = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v = int ( i ) NEW_LINE list . append ( v ) NEW_LINE DEDENT list . sort ( ) NEW_LINE div = 1 NEW_LINE count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum += list [ i ] NEW_LINE if sum / ( div * 1.0 ) >= k : NEW_LINE INDENT count += 1 NEW_LINE div += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT f . write ( " % d \n " % count ) NEW_LINE DEDENT f . close ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import time NEW_LINE import datetime NEW_LINE import calendar NEW_LINE import sys NEW_LINE import doctest NEW_LINE import pytz NEW_LINE import pytz NEW_LINE import pytz . timezone NEW_LINE import pytz . utc NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE import pytz . timezone NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ partitions ▁ of ▁ a ▁ group . """ NEW_LINE ans , max_so_far = [ 0 , 0 , 2 , 3 , 4 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if max_so_far == i : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ contiguous ▁ groups . """ NEW_LINE current_max , max_so_far = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT current_max = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current_max += 1 NEW_LINE max_so_far = max ( current_max , max_so_far ) NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if h < 0 and r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( h * r * float ( sqrt ( 2 ) ) ) / ( h + float ( sqrt ( 2 ) * r ) ) NEW_LINE assert a == 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import numpy as np NEW_LINE import random NEW_LINE import scipy as sp NEW_LINE import numpy as np NEW_LINE import scipy . stats as sp NEW_LINE import scipy . stats as sp NEW_LINE import numpy as np NEW_LINE import scipy . optimize as sp NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import norm NEW_LINE from scipy . stats import stats NEW_LINE from scipy . stats import stats NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = input ( ) NEW_LINE for i in range ( 1 , len ( n ) ) : NEW_LINE INDENT if n [ i ] != '0' : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( len ( n ) ) : NEW_LINE INDENT sum += n [ j ] - '0' NEW_LINE DEDENT print ( sum ) NEW_LINE return NEW_LINE DEDENT DEDENT if n [ 0 ] == '1' : NEW_LINE INDENT print ( 10 ) NEW_LINE return NEW_LINE DEDENT print ( n [ 0 ] ) NEW_LINE DEDENT
def geeks ( n ) : NEW_LINE INDENT while n : NEW_LINE INDENT if ( n % 10 ) % 2 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT n /= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT if ( n % 10 ) % 2 != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT n /= 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT i , j , k = symbols ( ' i ▁ j ▁ k ' , integer = True , positive = True ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT assert gf_lcm ( i , j ) == i * j + j * i + i * i + i * j + j * j + i * i + j * i + i * j + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j * i + j
def the_best_gift ( arr , n ) : NEW_LINE INDENT f = open ( ' data / data / the _ best _ gift . txt ' , ' r ' ) NEW_LINE lines = f . readlines ( ) NEW_LINE n = int ( n ) NEW_LINE m = int ( m ) NEW_LINE arr = np . zeros ( m ) NEW_LINE lines = f . readlines ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ int ( str ( i ) ) - 1 ] += 1 NEW_LINE DEDENT print ( get_number_of_ways2 ( arr , n ) ) NEW_LINE def get_number_of_ways1 ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT count = count + ( arr [ i ] * ( n - arr [ i ] ) ) NEW_LINE DEDENT return count / 2 NEW_LINE DEDENT sum_natual = ( ( n * ( n + 1l ) ) / 2 ) NEW_LINE def get_number_of_ways2 ( arr , n ) : NEW_LINE INDENT t = sum_natual ( n ) NEW_LINE for x in arr : NEW_LINE INDENT t -= sum_natual ( x ) NEW_LINE DEDENT return t NEW_LINE DEDENT return get_number_of_ways1 ( arr , n ) NEW_LINE DEDENT
def GFG ( k , n ) : NEW_LINE INDENT f1 , f2 , f3 = 0 , 1 , 0 NEW_LINE i = 2 NEW_LINE while i != 0 : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 , f2 , f3 = f2 , f3 NEW_LINE if f2 % k == 0 : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s = sys . stdin . readline ( ) NEW_LINE n = 0 NEW_LINE c = ' ' NEW_LINE ans = [ ] NEW_LINE e = [ False for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if e [ int ( s [ i ] ) - 97 ] == False : NEW_LINE INDENT n += 1 NEW_LINE DEDENT e [ int ( s [ i ] ) - 97 ] = True NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT c = 0 NEW_LINE DEDENT else : NEW_LINE INDENT c = len ( s ) - 2 NEW_LINE if s [ 0 ] == s [ len ( s ) - 1 ] : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT DEDENT if c % 2 == 0 : NEW_LINE INDENT ans = ' Second ' NEW_LINE DEDENT else : NEW_LINE INDENT ans = ' First ' NEW_LINE DEDENT print ( ans ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT
def get_graphs_number_of_moves ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( k - 1 , n ) : NEW_LINE INDENT if arr [ i ] != arr [ k - 1 ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] != arr [ k - 1 ] : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT
def import ( x , y , p ) : NEW_LINE INDENT """ STRNEWLINE ▁ Import ▁ a ▁ Python ▁ 2 ▁ or ▁ 3 ▁ compatible ▁ version ▁ of ▁ a ▁ Python ▁ 2 ▁ or ▁ 3 ▁ compatible ▁ version . STRNEWLINE ▁ """ NEW_LINE res = 1 NEW_LINE x = x % p NEW_LINE while y : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT fileobj = sys . stdin NEW_LINE fileobj . close ( ) NEW_LINE f = open ( fileobj , ' r ' ) NEW_LINE out = sys . stdout NEW_LINE solver = TaskA ( ) NEW_LINE solver . solve ( 1 , f , out ) NEW_LINE out . close ( ) NEW_LINE DEDENT class TaskA : NEW_LINE INDENT def solve ( self , test_number , f , out ) : NEW_LINE INDENT t = f . readline ( ) NEW_LINE s = f . readline ( ) NEW_LINE q = f . readline ( ) NEW_LINE sum = 0 NEW_LINE while s < t : NEW_LINE INDENT s = s * q NEW_LINE sum += 1 NEW_LINE DEDENT out . write ( sum ) NEW_LINE DEDENT DEDENT class InputReader : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT DEDENT class InputWriter : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT DEDENT class InputReader ( InputWriter ) : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return f . readline ( ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE s = n - 2 NEW_LINE print ( s * s ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ identicalrows ▁ in ▁ a ▁ GFG . """ NEW_LINE count = 0 NEW_LINE for mat in np . array ( [ [ 1 , 1 , 1 ] , [ 1 , 2 , 3 ] , [ 5 , 5 , 5 ] ] ) : NEW_LINE INDENT hs = set ( [ mat ] ) NEW_LINE if len ( hs ) == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT b = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if not b : NEW_LINE INDENT b . append ( a [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT start , end = 0 , len ( b ) - 1 NEW_LINE pos = 0 NEW_LINE while start <= end : NEW_LINE INDENT mid = start + ( end - start ) // 2 NEW_LINE if b [ mid ] == a [ j ] : NEW_LINE INDENT b . append ( ( max ( 0 , mid + 1 ) , a [ j ] ) ) NEW_LINE break NEW_LINE DEDENT elif b [ mid ] > a [ j ] : NEW_LINE INDENT pos = end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = start = mid + 1 NEW_LINE DEDENT if start > end : NEW_LINE INDENT pos = start NEW_LINE b . append ( ( max ( 0 , pos ) , a [ j ] ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def count_total_distinct ( str ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ number ▁ of ▁ distinct ▁ items ▁ in ▁ the ▁ given ▁ string . STRNEWLINE ▁ """ NEW_LINE cnt = 0 NEW_LINE items = set ( ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE ans = set ( ) NEW_LINE for j in range ( i , len ( str ) ) : NEW_LINE INDENT temp = temp + str [ j ] NEW_LINE ans . add ( str [ j ] ) NEW_LINE if not items . intersection ( temp ) : NEW_LINE INDENT items . add ( temp ) NEW_LINE cnt += len ( ans ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT digits = int ( math . log10 ( n ) ) NEW_LINE n = int ( n / int ( math . pow ( 10 , digits ) ) ) NEW_LINE assert n == 98562 NEW_LINE DEDENT
def import ( a , n ) : NEW_LINE INDENT import numpy NEW_LINE class solution : NEW_LINE INDENT def remove_zeros ( self , a , n ) : NEW_LINE INDENT ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != 0 : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT if ind == - 1 : NEW_LINE INDENT print ( " Array ▁ has ▁ leading ▁ zeros ▁ only " ) NEW_LINE return NEW_LINE DEDENT b = [ a [ ind + i ] for i in range ( n - ind ) ] NEW_LINE for i in range ( n - ind ) : NEW_LINE INDENT print ( b [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def print_zeros ( self , a ) : NEW_LINE INDENT a = [ 0 , 0 , 0 , 1 , 2 , 0 , 3 ] NEW_LINE n = len ( a ) NEW_LINE remove_zeros ( a , n ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def find_maxm ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mp . has_key ( arr [ i ] ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for x , freq in mp . items ( ) : NEW_LINE INDENT value = x [ 0 ] NEW_LINE freq = x [ 1 ] NEW_LINE if value == freq : NEW_LINE INDENT ans = max ( ans , value ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT N = len ( sys . argv ) NEW_LINE DEDENT except : NEW_LINE INDENT N = 1 NEW_LINE DEDENT arr = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT arr . append ( sys . argv [ i ] ) NEW_LINE DEDENT tsk = Task ( ) NEW_LINE sys . stdout . write ( tsk . solve ( arr ) ) NEW_LINE def solve ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE sorted = sorted ( arr ) NEW_LINE total = long ( n * ( n + 1 ) ) / 2 NEW_LINE l , r = 0 , n - 1 NEW_LINE while l < r : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE target = sorted [ mid ] NEW_LINE cur = 0 NEW_LINE cnt = 0 NEW_LINE bit = [ 0 ] * 2 + [ 0 ] * 2 NEW_LINE for x in range ( n + 1 , len ( bit ) , 2 ) : NEW_LINE INDENT bit [ x ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT cur += arr [ i ] <= target NEW_LINE for x in range ( cur + n + 1 , len ( bit ) , 2 ) : NEW_LINE INDENT bit [ x ] += 1 NEW_LINE DEDENT for x in range ( cur + n , 0 , - 1 ) : NEW_LINE INDENT cnt += bit [ x ] NEW_LINE DEDENT DEDENT if cnt >= total // 2 + 1 : NEW_LINE INDENT r = mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return sorted [ l ] NEW_LINE DEDENT
def gf_gf_sum ( f , p , K ) : NEW_LINE INDENT """ STRNEWLINE ▁ Compute ▁ sum ▁ of ▁ square - free ▁ numbers ▁ in ▁ ` ` GF ( p ) [ x ] ` ` . STRNEWLINE STRNEWLINE ▁ Examples STRNEWLINE ▁ = = = = = STRNEWLINE STRNEWLINE ▁ > > > ▁ from ▁ sympy . polys . domains ▁ import ▁ ZZ STRNEWLINE ▁ > > > ▁ from ▁ sympy . polys . galoistools ▁ import ▁ gf _ gf _ sum STRNEWLINE STRNEWLINE ▁ > > > ▁ gf _ gf _ sum ( [3 , ▁ 2 , ▁ 4 ] , ▁ 5 , ▁ ZZ ) STRNEWLINE ▁ [ 3 , ▁ 2 , ▁ 4 ] STRNEWLINE STRNEWLINE ▁ """ NEW_LINE ans = [ ] NEW_LINE while f [ - 1 ] != 0 : NEW_LINE INDENT ans . append ( f [ - 1 ] % 10 ) NEW_LINE f = f [ : - 1 ] NEW_LINE DEDENT return gf_sum ( f , p , K ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT std_in = np . array ( [ 35.5 , 37.5 , 40 , 43 , 50 , 55 , 70 ] ) NEW_LINE ca = np . array ( [ 71 , 77 , 83 , 89 , 105 , 116 , 148 ] ) NEW_LINE c = [ ' AAA ' , ' AA ' , ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' NA ' ] NEW_LINE for i in std_in : NEW_LINE INDENT a = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 ] ) NEW_LINE b = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 ] ) NEW_LINE ar = 100 NEW_LINE br = 100 NEW_LINE for i in ca : NEW_LINE INDENT if i > a : NEW_LINE INDENT ar = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in cb : NEW_LINE INDENT if i > b : NEW_LINE INDENT br = i NEW_LINE break NEW_LINE DEDENT DEDENT ans = max ( ar , br ) NEW_LINE if ans == 100 : NEW_LINE INDENT ans = len ( c ) - 1 NEW_LINE DEDENT print ( c [ ans ] ) NEW_LINE DEDENT DEDENT
def test_q1 ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE while t : NEW_LINE INDENT a , b , c , d = symbols ( ' a ▁ b ▁ c ▁ d ' , integer = True , positive = True ) NEW_LINE res = max ( c - 1 , a - c ) + max ( d - 1 , b - d ) NEW_LINE assert res == max ( a - c , b - d ) NEW_LINE DEDENT DEDENT
def A_Remove_Smallest ( ) : NEW_LINE INDENT sn = input ( ) NEW_LINE t = len ( sn ) NEW_LINE while t : NEW_LINE INDENT n = sn . pop ( ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( sn . pop ( ) ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] - arr [ i ] ) <= 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == n - 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT accuracy , denominator , sinx , sinval = ( 0.0001 , 0.0001 , 0.0001 ) NEW_LINE n = n * float ( 3.142 / 180.0 ) NEW_LINE x1 = n NEW_LINE sinx = n NEW_LINE sinval = float ( math . sin ( n ) ) NEW_LINE i = 1 NEW_LINE do : NEW_LINE INDENT denominator = 2 ** i * ( 2 * i + 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE sinx = sinx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT while accuracy <= sinval - sinx : NEW_LINE INDENT pass NEW_LINE DEDENT assert sinx == n NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE pro = 1 NEW_LINE for i in arr : NEW_LINE INDENT pro = pro * i NEW_LINE DEDENT return pro NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global flag , n , counter NEW_LINE flag = [ ] NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , " qv " ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( msg ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - v ' : NEW_LINE INDENT flag . append ( '1' ) NEW_LINE DEDENT elif o == ' - q ' : NEW_LINE INDENT flag . append ( '0' ) NEW_LINE DEDENT elif o == ' - v ' : NEW_LINE INDENT flag . append ( '0' ) NEW_LINE DEDENT elif o == ' - - verbose ' : NEW_LINE INDENT counter = 1 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] != True : NEW_LINE INDENT counter = 0 NEW_LINE break NEW_LINE DEDENT DEDENT sys . stdout . write ( " % d \n " % counter ) NEW_LINE DEDENT elif o == ' - - verbose ' : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] != False : NEW_LINE INDENT counter = 1 NEW_LINE break NEW_LINE DEDENT DEDENT sys . stdout . write ( " % d \n " % counter ) NEW_LINE DEDENT elif o == ' - - verbose ' : NEW_LINE INDENT counter = 1 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] == True : NEW_LINE INDENT counter = 0 NEW_LINE break NEW_LINE DEDENT DEDENT sys . stdout . write ( " % d \n " % counter ) NEW_LINE DEDENT elif o == ' - - verbose ' : NEW_LINE INDENT sum = [ '0' ] * 64 NEW_LINE big = [ '2' ] * 64 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if flag [ i ] : NEW_LINE INDENT sum [ i ] = sum [ i ] + big [ i ] NEW_LINE DEDENT DEDENT sys . stdout . write ( " % d \n " % sum ) NEW_LINE DEDENT DEDENT DEDENT
def gf_gf_int ( f , p , K ) : NEW_LINE INDENT """ STRNEWLINE ▁ Compute ▁ the ▁ nth ▁ order ▁ polynomial ▁ of ▁ ` ` GF ( p ) [ x ] ` ` . STRNEWLINE STRNEWLINE ▁ Examples STRNEWLINE ▁ = = = = = STRNEWLINE STRNEWLINE ▁ > > > ▁ from ▁ sympy . polys . domains ▁ import ▁ ZZ STRNEWLINE ▁ > > > ▁ from ▁ sympy . polys . galoistools ▁ import ▁ gf _ gf _ int STRNEWLINE STRNEWLINE ▁ > > > ▁ gf _ gf _ int ( [3 , ▁ 2 , ▁ 4 ] , ▁ 5 , ▁ ZZ ) STRNEWLINE ▁ [ 1 , ▁ 2 , ▁ 4 , ▁ 5 ] STRNEWLINE STRNEWLINE ▁ """ NEW_LINE count = 0 NEW_LINE while f : NEW_LINE INDENT count += 1 NEW_LINE f = gf_strip ( f ) NEW_LINE DEDENT incl = f [ 0 ] NEW_LINE excl = 0 NEW_LINE excl_new = [ ] NEW_LINE for i in range ( 1 , p ) : NEW_LINE INDENT excl_new . append ( ( incl , excl ) ) NEW_LINE incl = excl + f [ 1 ] NEW_LINE excl = excl_new [ 0 ] NEW_LINE DEDENT return ( ( incl , excl ) , ( incl , excl_new ) ) NEW_LINE DEDENT
def test_python_application_70 ( ) : NEW_LINE INDENT import sys NEW_LINE import doctest NEW_LINE num = 0 NEW_LINE counter = 0 NEW_LINE fine = 0 NEW_LINE arr = [ ] NEW_LINE for i in range ( num ) : NEW_LINE INDENT s = sys . stdin . readline ( ) NEW_LINE arr . append ( s ) NEW_LINE DEDENT for i in range ( num ) : NEW_LINE INDENT for k in range ( num ) : NEW_LINE INDENT if arr [ k ] [ i ] == ' C ' : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT fine += ( counter * ( counter - 1 ) ) / 2 NEW_LINE counter = 0 NEW_LINE DEDENT for i in range ( num ) : NEW_LINE INDENT for k in range ( num ) : NEW_LINE INDENT if arr [ i ] [ k ] == ' C ' : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT fine += ( counter * ( counter - 1 ) ) / 2 NEW_LINE counter = 0 NEW_LINE DEDENT assert fine == 0 NEW_LINE DEDENT
def GFG ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return 0 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return find_min_index ( arr , low , mid - 1 ) NEW_LINE DEDENT return find_min_index ( arr , mid + 1 , high ) NEW_LINE DEDENT binary_search ( arr , l , h , x ) NEW_LINE while l <= h : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] <= x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT return h NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT f = lambda x , y : y - 2 * x ** 2 + 1 NEW_LINE v = y - 2 * x ** 2 + 1 NEW_LINE predict ( x , y , h ) NEW_LINE y1p = y + h * f ( x , y ) NEW_LINE return y1p NEW_LINE def correct ( x , y , x1 , y1 , h ) : NEW_LINE INDENT e = 0.00001 NEW_LINE y1c = y1 NEW_LINE while abs ( y1c - y1 ) > e : NEW_LINE INDENT y1 = y1c NEW_LINE y1c = y + 0.5 * h * ( f ( x , y ) + f ( x1 , y1 ) ) NEW_LINE DEDENT return y1c NEW_LINE DEDENT def print_final_values ( x , xn , y , h ) : NEW_LINE INDENT while x < xn : NEW_LINE INDENT x1 = x + h NEW_LINE y1p = predict ( x , y , h ) NEW_LINE y1c = correct ( x , y , x1 , y1p , h ) NEW_LINE x = x1 NEW_LINE y = y1c NEW_LINE DEDENT print ( " The ▁ final ▁ value ▁ of ▁ y ▁ at ▁ x ▁ = ▁ % d ▁ is ▁ : ▁ % s " % ( int ( x ) , str ( y ) ) ) NEW_LINE DEDENT def test_polynomial_1 ( ) : NEW_LINE INDENT x , y = 0 , 0.5 NEW_LINE xn = 1 NEW_LINE h = 0.2 NEW_LINE print_final_values ( x , xn , y , h ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if j == 1 or ( ( i == 0 or i == n - 1 ) and ( j > 1 and j < n - 2 ) ) or ( j == n - 2 and i != 0 and i != n - 1 ) : NEW_LINE INDENT print ( " * " , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def GFG ( n , k ) : NEW_LINE INDENT total = 0 NEW_LINE i = 1 NEW_LINE while total < k : NEW_LINE INDENT total = total + n - i NEW_LINE i += 1 NEW_LINE DEDENT first_y_position = i - 1 NEW_LINE second_y_position = k - ( total - n + first_y_position ) NEW_LINE for j in range ( 1 , first_y_position ) : NEW_LINE INDENT print ( ' x ' , end = ' ▁ ' ) NEW_LINE DEDENT print ( ' y ' , end = ' ▁ ' ) NEW_LINE j = first_y_position + 1 NEW_LINE while second_y_position > 1 : NEW_LINE INDENT print ( ' x ' , end = ' ▁ ' ) NEW_LINE second_y_position -= 1 NEW_LINE j += 1 NEW_LINE DEDENT print ( ' y ' , end = ' ▁ ' ) NEW_LINE while j < n : NEW_LINE INDENT print ( ' x ' , end = ' ▁ ' ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT
def GFG ( n , k ) : NEW_LINE INDENT C = [ 1 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT
def test_product_except_self ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ product ▁ except ▁ self ▁ for ▁ all ▁ numbers ▁ in ▁ the ▁ list . STRNEWLINE ▁ """ NEW_LINE n = len ( nums ) NEW_LINE res = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] * nums [ i - 1 ] NEW_LINE DEDENT right = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT res [ i ] *= right NEW_LINE right *= nums [ i ] NEW_LINE DEDENT return res , right NEW_LINE DEDENT
def GFG ( s , k ) : NEW_LINE INDENT curr_str = s [ : k ] NEW_LINE lex_min = curr_str NEW_LINE lex_max = curr_str NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT curr_str = curr_str [ 1 : k ] + s [ i ] NEW_LINE if lex_max < curr_str : NEW_LINE INDENT lex_max = curr_str NEW_LINE DEDENT if lex_min > curr_str : NEW_LINE INDENT lex_min = curr_str NEW_LINE DEDENT DEDENT print ( lex_min ) NEW_LINE print ( lex_max ) NEW_LINE DEDENT
def test_cf840_basic ( ) : NEW_LINE INDENT import sympy NEW_LINE from sympy . abc import n NEW_LINE a = sympy . polys . densebasic . CF840A ( n ) NEW_LINE b = sympy . polys . densebasic . CF840B ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = sympy . polys . densebasic . CF840C ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b [ i ] = sympy . polys . densebasic . CF840D ( i ) NEW_LINE b [ i ] = i NEW_LINE DEDENT a . sort ( key = lambda x : x [ 1 ] ) NEW_LINE b . sort ( key = lambda x : x [ 0 ] ) NEW_LINE cmp = sympy . polys . densebasic . CF840C ( n ) NEW_LINE if cmp == 0 : NEW_LINE INDENT return sympy . polys . densebasic . CF840D ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT return cmp NEW_LINE DEDENT res = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT e = b [ i ] NEW_LINE res . append ( a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def genmodular ( arg ) : NEW_LINE INDENT """ Generate ▁ a ▁ modular ▁ sequence ▁ of ▁ integers . """ NEW_LINE INT_BITS = 32 NEW_LINE for i in range ( INT_BITS - 1 , - 1 , - 1 ) : NEW_LINE INDENT max_ind = index = 0 NEW_LINE max_ele = sys . maxint NEW_LINE for j in range ( index , n ) : NEW_LINE INDENT if ( arg [ j ] & ( 1 << i ) ) != 0 and arg [ j ] > max_ele : NEW_LINE INDENT max_ele = arg [ j ] NEW_LINE max_ind = j NEW_LINE DEDENT DEDENT if max_ele == - 2147483648 : NEW_LINE INDENT continue NEW_LINE DEDENT temp = arg [ index ] NEW_LINE arg [ index ] = arg [ max_ind ] NEW_LINE arg [ max_ind ] = temp NEW_LINE max_ind = index NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j != max_ind and ( arg [ j ] & ( 1 << i ) ) != 0 : NEW_LINE INDENT arg [ j ] = arg [ j ] ^ arg [ max_ind ] NEW_LINE DEDENT DEDENT index += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res ^= arg [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global number NEW_LINE global wooden NEW_LINE number = 0 NEW_LINE wooden = [ ] NEW_LINE for i in range ( 0 , len ( sys . argv ) ) : NEW_LINE INDENT each = sys . argv [ i ] NEW_LINE wooden . append ( each ) NEW_LINE DEDENT height = [ ] NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( sys . argv ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE for j in range ( i + 1 , len ( sys . argv ) ) : NEW_LINE INDENT if sys . argv [ i ] == sys . argv [ j ] : NEW_LINE INDENT sys . argv [ i ] = sys . argv [ j ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT height . append ( count ) NEW_LINE DEDENT DEDENT index = 0 NEW_LINE max = height [ 0 ] NEW_LINE for i in range ( 0 , len ( sys . argv ) ) : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if max < height [ i ] : NEW_LINE INDENT max = height [ i ] NEW_LINE DEDENT DEDENT sys . stdout . write ( " % d ▁ % d \n " % ( max , index ) ) NEW_LINE DEDENT
def import ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE import numpy as np NEW_LINE class Main ( object ) : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def __int__ ( self ) : NEW_LINE INDENT return self . n NEW_LINE DEDENT def __float__ ( self ) : NEW_LINE INDENT return self . n NEW_LINE DEDENT def __bool__ ( self ) : NEW_LINE INDENT return self . n NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT return self . n <= other . n NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT return self . n >= other . n NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT return self . n != other . n NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return self . n < other . n NEW_LINE DEDENT def __gt__ ( self , other ) : NEW_LINE INDENT return self . n > other . n NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT return self . n <= other . n NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT return self . n >= other . n NEW_LINE DEDENT DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE return [ Main ( arr , n ) for arr in arr ] NEW_LINE DEDENT
def first_uniq_char ( s ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ s [ i ] - ' a ' ] += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if freq [ s [ i ] - ' a ' ] == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
def check_stack_permutation ( ip , op , n ) : NEW_LINE INDENT input = Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT input . put ( ip [ i ] ) NEW_LINE DEDENT output = Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT output . put ( op [ i ] ) NEW_LINE DEDENT temp_stack = Stack ( ) NEW_LINE while not input . empty ( ) : NEW_LINE INDENT ele = input . get ( ) NEW_LINE if ele == output . get ( ) : NEW_LINE INDENT output . put ( ele ) NEW_LINE while not temp_stack . empty ( ) : NEW_LINE INDENT if temp_stack . peek ( ) == output . get ( ) : NEW_LINE INDENT temp_stack . pop ( ) NEW_LINE output . put ( ele ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT temp_stack . push ( ele ) NEW_LINE DEDENT DEDENT return ( input . empty ( ) and temp_stack . empty ( ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s = sys . stdin . readline ( ) NEW_LINE t = sys . stdin . readline ( ) NEW_LINE l = len ( s ) NEW_LINE ans = True NEW_LINE for i in range ( l ) : NEW_LINE INDENT if s . find ( s [ i ] , i + 1 ) != t . find ( t [ i ] , i + 1 ) : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT sys . stdout . write ( ans and " Yes " or " No " ) NEW_LINE DEDENT
def import ( n , d ) : NEW_LINE INDENT import sys NEW_LINE class solution : NEW_LINE INDENT def getSum ( self ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 10 == d : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT n , d = 30 , 3 NEW_LINE print ( getSum ( n ) ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE while t : NEW_LINE INDENT st = sys . stdin . readline ( ) NEW_LINE end = sys . stdin . readline ( ) NEW_LINE n = sys . stdin . readline ( ) NEW_LINE m = sys . stdin . readline ( ) NEW_LINE sum = 0 NEW_LINE if st > end : NEW_LINE INDENT temp = end NEW_LINE end = st NEW_LINE st = temp NEW_LINE DEDENT if n + m <= st : NEW_LINE INDENT sum = end - st NEW_LINE DEDENT elif n + m >= st and n - m < st : NEW_LINE INDENT sum = end - n - m NEW_LINE DEDENT elif n - m >= st and n <= end - m : NEW_LINE INDENT sum = end - st - 2 * m NEW_LINE DEDENT elif n - m < end and n + m >= end : NEW_LINE INDENT sum = n - m - st NEW_LINE DEDENT else : NEW_LINE INDENT sum = end - st NEW_LINE DEDENT if sum < 0 : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT DEDENT
def test_codechef ( ) : NEW_LINE INDENT import sympy NEW_LINE from sympy . abc import n NEW_LINE assert codechef ( n ) == ( n , 0 ) NEW_LINE assert codechef ( n + 1 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 2 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 3 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 4 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 5 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 6 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 7 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 8 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 9 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 10 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 11 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 12 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 13 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 14 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 15 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 16 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 17 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 18 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 19 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 20 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 21 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 22 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 23 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 24 ) == ( n , 0 ) NEW_LINE assert codechef ( n + 25 ) == ( n ,
def get_GFG ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def ishu ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT
def GFG ( r , d ) : NEW_LINE INDENT PI = 3.14 NEW_LINE R = d / PI NEW_LINE R += math . pow ( r , 2 ) NEW_LINE R = math . sqrt ( R ) NEW_LINE area = PI * math . pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 5 NEW_LINE s = 11 NEW_LINE assert minimum_numbers ( n , s ) == 1 NEW_LINE DEDENT
def count_triplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE end , start , mid = n - 1 , n - 1 , n - 1 , n - 1 NEW_LINE for end in range ( n - 1 , 2 , - 1 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while start < mid : NEW_LINE INDENT prod = arr [ end ] * arr [ start ] * arr [ mid ] NEW_LINE if prod > m : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif prod < m : NEW_LINE INDENT start += 1 NEW_LINE DEDENT elif prod == m : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT a , b , c = 0 , 1 , 1 NEW_LINE res = 1 NEW_LINE while c < n : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a , b , c = b , c NEW_LINE DEDENT return res NEW_LINE DEDENT
def GFG ( ch ) : NEW_LINE INDENT try : NEW_LINE INDENT if ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT return False NEW_LINE DEDENT isSatisfied = False NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if not isVowel ( str ( i ) ) and not isVowel ( str ( i - 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if isVowel ( str ( i ) ) and not isVowel ( str ( i - 1 ) ) and not isVowel ( str ( i + 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def GFG ( m , n ) : NEW_LINE INDENT ans , i = 0.0 , 0 NEW_LINE for i in range ( m , 0 , - 1 ) : NEW_LINE INDENT ans += ( pow ( i / m , n ) - pow ( ( i - 1 ) / m , n ) ) ** i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT prod = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT prod *= i NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT
def p019 ( ) : NEW_LINE INDENT print ( [ ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ' p019' , ] ) NEW_LINE DEDENT
def GFG ( d ) : NEW_LINE INDENT class Date ( object ) : NEW_LINE INDENT d , m , y = d NEW_LINE DEDENT month_days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE count_leap = 1 NEW_LINE if d . m <= 2 : NEW_LINE INDENT years = d . y NEW_LINE DEDENT else : NEW_LINE INDENT years = d . m - 1 NEW_LINE DEDENT return years / 4 - years / 100 + years / 400 NEW_LINE DEDENT
def genNumbers ( n ) : NEW_LINE INDENT st = set ( ) NEW_LINE def generateNumbers ( n , num , a , b ) : NEW_LINE INDENT if num > 0 and num < n : NEW_LINE INDENT st . add ( num ) NEW_LINE DEDENT if num >= n : NEW_LINE INDENT return NEW_LINE DEDENT if num * 10 + a > num : NEW_LINE INDENT generateNumbers ( n , num * 10 + a , a , b ) NEW_LINE DEDENT generateNumbers ( n , num * 10 + b , a , b ) NEW_LINE DEDENT def printNumbers ( n ) : NEW_LINE INDENT for i in range ( 0 , 9 ) : NEW_LINE INDENT for j in range ( i + 1 , 9 ) : NEW_LINE INDENT generateNumbers ( n , 0 , i , j ) NEW_LINE DEDENT DEDENT print ( " The ▁ numbers ▁ are : ▁ " ) NEW_LINE print ( st ) NEW_LINE st = set ( ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 12 NEW_LINE printNumbers ( n ) NEW_LINE DEDENT DEDENT
def progress_bar ( ) : NEW_LINE INDENT import sys NEW_LINE n = sys . argv [ 1 ] NEW_LINE k = sys . argv [ 2 ] NEW_LINE t = sys . argv [ 3 ] NEW_LINE temp = ( t * k * n ) / 100.0 NEW_LINE x = 0 NEW_LINE while temp - k >= 0 : NEW_LINE INDENT temp -= k NEW_LINE x += 1 NEW_LINE DEDENT for i in range ( x ) : NEW_LINE INDENT sys . stdout . write ( k + " ▁ " ) NEW_LINE DEDENT if temp != 0 : NEW_LINE INDENT sys . stdout . write ( int ( temp ) + " ▁ " ) NEW_LINE x += 1 NEW_LINE DEDENT for i in range ( x , n ) : NEW_LINE INDENT sys . stdout . write ( 0 ) NEW_LINE DEDENT sys . stdout . write ( " \n " ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT N , Q = ni . read ( ) . split ( ' ▁ ' ) NEW_LINE if ( N | Q ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT seq = [ ] NEW_LINE d = { } NEW_LINE for i in range ( 1 , 100 ) : NEW_LINE INDENT d [ i ] = 0 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT M , seq = ni . read ( ) . split ( ' ▁ ' ) NEW_LINE d [ i ] = d [ i ] + 1 NEW_LINE DEDENT max = 0 NEW_LINE idx = 0 NEW_LINE for key in d : NEW_LINE INDENT n = d [ key ] NEW_LINE if n >= Q : NEW_LINE INDENT if max < n : NEW_LINE INDENT idx = key NEW_LINE max = n NEW_LINE DEDENT DEDENT DEDENT print ( idx ) NEW_LINE DEDENT main ( ) NEW_LINE DEDENT
def test_oddoccurance ( ) : NEW_LINE INDENT i = 0 NEW_LINE res = 0 NEW_LINE for i in range ( ar_size ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def GFG ( x , k ) : NEW_LINE INDENT rslt = ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) NEW_LINE return rslt NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT isPrime = [ False ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , n * p + 1 ) : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE isPrime = [ False ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT x = n // i NEW_LINE if isPrime [ i ] and isPrime [ x ] and x != i and x * i == n : NEW_LINE INDENT print ( i , x ) NEW_LINE flag = 1 NEW_LINE return flag NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ found " ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 39 NEW_LINE findPrimePair ( n ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a , b = symbols ( ' a ▁ b ' , integer = True , positive = True ) NEW_LINE g = ( 2 * a + b ) / ( a + b ) NEW_LINE assert gcd ( g , a ) == g NEW_LINE a , b = symbols ( ' a ▁ b ' , integer = True , positive = True ) NEW_LINE g = ( 2 * a + b ) / ( a + b ) NEW_LINE assert gcd ( g , a ) == g NEW_LINE a , b = symbols ( ' a ▁ b ' , integer = True , positive = True ) NEW_LINE g = ( 2 * a + b ) / ( a + b ) NEW_LINE assert gcd ( g , a ) == g NEW_LINE a , b = symbols ( ' a ▁ b ' , integer = True , positive = True ) NEW_LINE g = ( 2 * a + b ) / ( a + b ) NEW_LINE assert gcd ( g , a ) == g NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a , b = symbols ( ' a ▁ b ' , integer = True , positive = True ) NEW_LINE g = ( 2 * a + b ) / ( a + b ) NEW_LINE assert gcd ( g , a ) == g NEW_LINE a , b = symbols ( ' a ▁ b ' , integer = True , positive = True ) NEW_LINE g = ( 2 * a + b ) / ( a + b ) NEW_LINE assert gcd ( g , a ) == g NEW_LINE a , b = symbols ( ' a ▁ b ' , integer = True , positive = True ) NEW_LINE g = ( 2 * a + b ) / ( a + b ) NEW_LINE assert gcd ( g , a ) == g NEW_LINE a , b = symbols ( ' a ▁ b ' , integer = True , positive = True ) NEW_LINE g = ( 2 * a + b ) / ( a + b ) NEW_LINE assert gcd ( g , a ) == g NEW_LINE DEDENT
def p174 ( ) : NEW_LINE INDENT print ( [ ' p174 . py ' , ' p174 . c ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ' p174 . h ' , ] ) NEW_LINE DEDENT
def binary_removal ( s ) : NEW_LINE INDENT one = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT if s [ i - 1 ] == '1' : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ i - 1 ] == '0' and one > 0 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( ' YES ' ) NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT maxm = - 1 NEW_LINE cnt = 0 NEW_LINE while N != 0 : NEW_LINE INDENT if ( N & 1 ) == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE N >>= 1 NEW_LINE maxm = max ( maxm , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT maxm = max ( maxm , cnt ) NEW_LINE cnt = 0 NEW_LINE N >>= 1 NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT
def get_longest_seq ( a , n ) : NEW_LINE INDENT max_idx , max_len , curr_len , curr_idx = 0 , 0 , 0 , 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if a [ k ] > 0 : NEW_LINE INDENT curr_len += 1 NEW_LINE if curr_len == 1 : NEW_LINE INDENT curr_idx = k NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if curr_len > max_len : NEW_LINE INDENT max_len = curr_len NEW_LINE max_idx = curr_idx NEW_LINE DEDENT curr_len = 0 NEW_LINE DEDENT DEDENT if max_len : NEW_LINE INDENT print ( " Index ▁ : ▁ " + str ( max_idx ) ) NEW_LINE print ( " ▁ , Length ▁ : ▁ " + str ( max_len ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ positive ▁ sequence ▁ detected . " ) NEW_LINE DEDENT return max_idx , max_len , curr_len , curr_idx NEW_LINE DEDENT
def Linked_list_2D_Matrix ( ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT data = 0 NEW_LINE right = 0 NEW_LINE down = 0 NEW_LINE DEDENT def construct ( arr , i , j , m , n ) : NEW_LINE INDENT if i > n - 1 or j > m - 1 : NEW_LINE INDENT return None NEW_LINE DEDENT temp = Node ( ) NEW_LINE temp . data = arr [ i ] [ j ] NEW_LINE temp . right = construct ( arr , i , j + 1 , m , n ) NEW_LINE temp . down = construct ( arr , i + 1 , j , m , n ) NEW_LINE return temp NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT Rp = None NEW_LINE Dp = head NEW_LINE while Dp : NEW_LINE INDENT Rp = Dp NEW_LINE while Rp : NEW_LINE INDENT print ( Rp . data , end = ' ▁ ' ) NEW_LINE Rp = Rp . right NEW_LINE DEDENT print ( ) NEW_LINE Dp = Dp . down NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o in ( ' - d ' , ' - - debug ' ) : NEW_LINE INDENT if a == ' - d ' : NEW_LINE INDENT debug ( ) NEW_LINE DEDENT DEDENT DEDENT print ( ' % d ▁ of ▁ % d ▁ is ▁ a ▁ permutation ▁ of ▁ % d ▁ elements ' % ( len ( args ) , len ( args ) , len ( args ) ) ) NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE if N % 2 == 0 : NEW_LINE INDENT ans = ( N / 2 ) * 6 + ( N / 2 ) * 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N / 2 + 1 ) * 6 + ( N / 2 ) * 2 NEW_LINE DEDENT print ( ans , end = ' ▁ ' ) NEW_LINE DEDENT
def GFG ( a , b , c , d ) : NEW_LINE INDENT if a == b and a == c and a == d and c == d and b == c and b == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == b and c == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == d and c == b : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == c and d == b : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def GFG ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) NEW_LINE an = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m NEW_LINE DEDENT value = [ ] NEW_LINE for i , cur in enumerate ( an ) : NEW_LINE INDENT if value [ cur ] == 0 : NEW_LINE INDENT value . append ( i ) NEW_LINE DEDENT cur = ( cur * an ) % m NEW_LINE DEDENT for i , cur in enumerate ( b ) : NEW_LINE INDENT if value [ cur ] > 0 : NEW_LINE INDENT ans = value [ cur ] * n - i NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT if ans < m : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def find_minimum_cost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ind == ( n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif dp [ ind ] != - 1 : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = int ( 0 ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ind + i < n : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + find_minimum_cost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return dp [ ind ] = ans NEW_LINE DEDENT DEDENT
def __gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT mod = 998244353 NEW_LINE nchoosek = [ ] NEW_LINE for i in range ( 4001 ) : NEW_LINE INDENT nchoosek . append ( nchoosek [ i ] [ i ] = 1 ) NEW_LINE DEDENT for i in range ( 2 , len ( nchoosek ) ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT nchoosek [ i ] [ j ] = ( nchoosek [ i - 1 ] [ j ] + nchoosek [ i - 1 ] [ j - 1 ] ) % mod NEW_LINE DEDENT DEDENT data = input ( ) NEW_LINE k = int ( data ) NEW_LINE n = int ( data ) NEW_LINE for i in range ( 2 , 2 * k ) : NEW_LINE INDENT pairs = 0 NEW_LINE if i > k : NEW_LINE INDENT pairs = k - i // 2 NEW_LINE DEDENT else : NEW_LINE INDENT pairs = ( i - 1 ) // 2 NEW_LINE DEDENT active = k - 2 * pairs NEW_LINE if i % 2 == 0 : NEW_LINE INDENT active -= 1 NEW_LINE DEDENT times2 = 1 NEW_LINE total = 0 NEW_LINE for j in range ( 0 , pairs ) : NEW_LINE INDENT choice = times2 * nchoosek [ pairs ] [ j ] % mod NEW_LINE times2 = times2 * 2 % mod NEW_LINE if active + j - 1 < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT total += choice * nchoosek [ n + active - 1 ] [ active + j - 1 ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT total += choice * nchoosek [ n + active - 2 ] [ active + j - 1 ] NEW_LINE DEDENT total %= mod NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( msg + " \n " ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT N = len ( args ) NEW_LINE total = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT money = float ( args [ i ] ) NEW_LINE A = args [ i ] NEW_LINE B = ' JPY ' NEW_LINE if A == B : NEW_LINE INDENT total += money NEW_LINE DEDENT else : NEW_LINE INDENT total += money * 380000 NEW_LINE DEDENT DEDENT sys . stdout . write ( total + " \n " ) NEW_LINE DEDENT
def get_count ( arr , n , num1 , num2 ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == num1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i >= n - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT j = 0 NEW_LINE for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT if arr [ j ] == num2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == i : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = ' Generate ▁ a ▁ simple ▁ histogram ▁ from ▁ a ▁ comma - separated ▁ list ▁ of ▁ numbers ' ) NEW_LINE parser . add_argument ( ' - n ' , ' - - n ' , type = int , help = ' number ▁ of ▁ points ▁ to ▁ generate ' ) NEW_LINE parser . add_argument ( ' - a ' , ' - - a ' , type = int , help = ' number ▁ of ▁ points ▁ to ▁ generate ' ) NEW_LINE parser . add_argument ( ' - b ' , ' - - b ' , type = int , help = ' number ▁ of ▁ points ▁ to ▁ generate ' ) NEW_LINE parser . add_argument ( ' - c ' , ' - - c ' , type = int , help = ' number ▁ of ▁ points ▁ to ▁ generate ' ) NEW_LINE parser . add_argument ( ' - d ' , ' - - d ' , type = int , help = ' number ▁ of ▁ points ▁ to ▁ generate ' ) NEW_LINE parser . add_argument ( ' - h ' , ' - - h ' , type = int , help = ' generate ▁ a ▁ histogram ' ) NEW_LINE parser . add_argument ( ' - i ' , ' - - i ' , type = int , help = ' generate ▁ a ▁ histogram ' ) NEW_LINE parser . add_argument ( ' - v ' , ' - - v ' , type = int , help = ' generate ▁ a ▁ histogram ' ) NEW_LINE args = parser . parse_args ( ) NEW_LINE if args . n is None : NEW_LINE INDENT parser . print_help ( ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT arr = [ ] NEW_LINE for i in range ( args . n ) : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE min = int ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , args . n ) : NEW_LINE INDENT min = min ( min , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT args . h = min NEW_LINE args . v = arr NEW_LINE args . b = arr NEW_LINE args . c = arr NEW_LINE args . d = arr NEW_LINE args . h = args . h NEW_LINE args . v = args . v NEW_LINE args . c = args . c NEW_LINE args . d = args . d NEW_LINE DEDENT
def count_set_bits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE set_bits = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT set_bits [ i ] = set_bits [ i / 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT set_bits [ i ] = set_bits [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT cnt = cnt + set_bits [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def p_p179 ( p ) : NEW_LINE INDENT ''' p179 ▁ : ▁ INTEGER ▁ ' ( ' ▁ INTEGER ▁ ' ) ' ▁ ''' NEW_LINE p [ 0 ] = int ( p [ 1 ] ) NEW_LINE LIMIT = library . pow ( 10 , 7 ) NEW_LINE num_divisors = [ ] NEW_LINE p [ 0 ] = int ( p [ 1 ] ) NEW_LINE for i in range ( 2 , len ( p ) ) : NEW_LINE INDENT for j in range ( i * 2 , len ( p ) , i ) : NEW_LINE INDENT num_divisors . append ( j ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( 2 , len ( p ) - 1 ) : NEW_LINE INDENT if p [ i ] == p [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return str ( count ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT arr [ 0 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum - arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT min , second_min , max , second_max = ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE min , second_max = ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT second_max = max NEW_LINE max = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second_max : NEW_LINE INDENT second_max = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < min : NEW_LINE INDENT second_min = min NEW_LINE min = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < second_min : NEW_LINE INDENT second_min = arr [ i ] NEW_LINE DEDENT DEDENT diff = min ( max - second_min , second_max - min ) NEW_LINE return diff NEW_LINE DEDENT
def helloworld ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE num = random . randint ( 1 , 10 ) NEW_LINE pairs = [ [ random . randint ( 1 , 10 ) , random . randint ( 1 , 10 ) ] , [ random . randint ( 1 , 10 ) , random . randint ( 1 , 10 ) ] ] NEW_LINE common_factors = set ( ) NEW_LINE for i in range ( num ) : NEW_LINE INDENT X = pairs [ 0 ] [ i ] NEW_LINE for k in range ( 2 , int ( math . ceil ( math . sqrt ( X ) ) ) + 1 ) : NEW_LINE INDENT if X % k == 0 : NEW_LINE INDENT while X % k == 0 : NEW_LINE INDENT X /= k NEW_LINE DEDENT common_factors . add ( k ) NEW_LINE DEDENT DEDENT if X != 1 : NEW_LINE INDENT common_factors . add ( X ) NEW_LINE DEDENT DEDENT for val in common_factors : NEW_LINE INDENT works = True NEW_LINE for i in range ( len ( pairs ) ) : NEW_LINE INDENT if pairs [ i ] [ 0 ] % val > 0 and pairs [ i ] [ 1 ] % val > 0 : NEW_LINE INDENT works = False NEW_LINE break NEW_LINE DEDENT DEDENT if works : NEW_LINE INDENT print ( val ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT f = open ( ' / proc / cpuinfo ' , ' r ' ) NEW_LINE buf = f . read ( ) NEW_LINE f . close ( ) NEW_LINE while not buf . startswith ( '0' ) : NEW_LINE INDENT n = int ( buf ) NEW_LINE parts = buf . split ( ' : ' ) NEW_LINE a = [ int ( p ) for p in parts ] NEW_LINE a . sort ( ) NEW_LINE end = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 1 NEW_LINE j = a [ i ] NEW_LINE i += 1 NEW_LINE while i < len ( a ) and j == a [ i ] : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT if count > n // 2 : NEW_LINE INDENT print ( a [ i - 1 ] ) NEW_LINE end = True NEW_LINE DEDENT if end : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not end : NEW_LINE INDENT print ( ' NO ▁ COLOR ' ) NEW_LINE DEDENT DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT return ( n if n == 1 or n == 0 else 1 ) * factorial ( n - 1 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT f = open ( ' . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . /
def test_er ( ) : NEW_LINE INDENT f = open ( ' data / er . txt ' , ' r ' ) NEW_LINE out = open ( ' data / er . txt ' , ' w ' ) NEW_LINE solver = TaskB ( ) NEW_LINE solver . solve ( f , out ) NEW_LINE out . close ( ) NEW_LINE DEDENT class TaskB ( object ) : NEW_LINE INDENT def __init__ ( self , f , out ) : NEW_LINE INDENT self . f = f NEW_LINE self . out = out NEW_LINE DEDENT def solve ( self , f , out ) : NEW_LINE INDENT f . readline ( ) NEW_LINE n = int ( f . readline ( ) ) NEW_LINE a = [ ] NEW_LINE sumA = [ ] NEW_LINE sumB = [ ] NEW_LINE a . append ( sumA ) NEW_LINE a . append ( sumB ) NEW_LINE a . append ( [ 0 ] * n ) NEW_LINE f . readline ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a . append ( [ int ( f . readline ( ) ) , i ] ) NEW_LINE sumA . append ( sumA [ i - 1 ] + a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sumB . append ( [ int ( f . readline ( ) ) , i ] ) NEW_LINE DEDENT f . readline ( ) NEW_LINE m = int ( f . readline ( ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT f . readline ( ) NEW_LINE type , l , r = int ( f . readline ( ) ) NEW_LINE if type == 1 : NEW_LINE INDENT out . append ( sumA [ r ] - sumA [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT out . append ( sumB [ r ] - sumB [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def find_minimum_x ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if len ( st ) == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if len ( st ) == 2 : NEW_LINE INDENT it = st . pop ( ) NEW_LINE el1 = it . pop ( ) NEW_LINE el2 = it . pop ( ) NEW_LINE if ( el2 - el1 ) % 2 == 0 : NEW_LINE INDENT return ( el2 - el1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( el2 - el1 ) NEW_LINE DEDENT DEDENT if len ( st ) == 3 : NEW_LINE INDENT it = st . pop ( ) NEW_LINE el1 = it . pop ( ) NEW_LINE el2 = it . pop ( ) NEW_LINE el3 = it . pop ( ) NEW_LINE if ( el2 - el1 ) == ( el3 - el2 ) : NEW_LINE INDENT return el2 - el1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT
def test_gfg ( ) : NEW_LINE INDENT r = n , v , u NEW_LINE m = int ( sqrt ( k ) + 1 ) NEW_LINE for i in range ( 2 , m and k > 1 ) : NEW_LINE INDENT if i == m : i = k NEW_LINE for u , v in itertools . combinations ( k , i ) : NEW_LINE INDENT k //= i NEW_LINE DEDENT if v : NEW_LINE INDENT t = n NEW_LINE while t : NEW_LINE INDENT t //= i NEW_LINE u += t NEW_LINE DEDENT r = min ( r , u / v ) NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT
def GFG ( a , b , x , y ) : NEW_LINE INDENT if x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT N = 1000 NEW_LINE count = ( 2 * N ) + 1 NEW_LINE freq = [ 0 ] * ( size ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x + N ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if freq [ i ] > 0 : NEW_LINE INDENT ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 NEW_LINE for j in range ( i + 2 , 2001 , 2 ) : NEW_LINE INDENT if freq [ j ] > 0 and ( freq [ ( i + j ) / 2 ] > 0 ) : NEW_LINE INDENT ans += ( freq [ i ] * freq [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT sum , n = 0 , n NEW_LINE getAvg = sum NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( int ( arr [ i ] ) ) NEW_LINE print ( " Average ▁ of ▁ % d ▁ numbers ▁ is ▁ % f " % ( i + 1 , avg ) ) NEW_LINE DEDENT return NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX = 10000 NEW_LINE s = set ( ) NEW_LINE SieveOfEratosthenes ( ) NEW_LINE prime = [ True for i in range ( MAX ) ] NEW_LINE for p in range ( 2 , MAX * 2 ) : NEW_LINE INDENT if prime [ p ] is True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT product = product * p NEW_LINE s . add ( product + 1 ) NEW_LINE DEDENT DEDENT is_euclid = set ( ) . intersection ( s ) NEW_LINE n = 31 NEW_LINE if is_euclid : NEW_LINE INDENT assert ' YES ' == product NEW_LINE DEDENT else : NEW_LINE INDENT assert ' NO ' == product NEW_LINE DEDENT n = 42 NEW_LINE if is_euclid : NEW_LINE INDENT assert ' YES ' == product NEW_LINE DEDENT else : NEW_LINE INDENT assert ' NO ' == product NEW_LINE DEDENT DEDENT
def test_SS ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE n = symbols ( ' n ' , integer = True ) NEW_LINE b = symbols ( ' b ' , integer = True ) NEW_LINE arr = [ ] NEW_LINE v = [ ] NEW_LINE odd , even , count = divmod ( n , 2 ) NEW_LINE for i in arr : NEW_LINE INDENT v . append ( abs ( arr [ i ] - arr [ i - 1 ] ) ) NEW_LINE DEDENT for i in arr : NEW_LINE INDENT if i != 0 and odd == even : NEW_LINE INDENT v . append ( abs ( arr [ i ] - arr [ i - 1 ] ) ) NEW_LINE DEDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT v . sort ( ) NEW_LINE for i in v : NEW_LINE INDENT if b >= v [ i ] : NEW_LINE INDENT count += 1 NEW_LINE b -= v [ i ] NEW_LINE DEDENT DEDENT assert count == 0 NEW_LINE DEDENT
def GFG ( str ) : NEW_LINE INDENT i , g , gk , gks = 0 , 0 , 0 , 0 NEW_LINE for c in str : NEW_LINE INDENT if c == ' g ' : g += 1 NEW_LINE elif c == ' k ' : NEW_LINE INDENT if g > 0 : NEW_LINE INDENT g -= 1 NEW_LINE gk += 1 NEW_LINE DEDENT DEDENT elif c == ' s ' : NEW_LINE INDENT if gk > 0 : NEW_LINE INDENT gk -= 1 NEW_LINE gks += 1 NEW_LINE DEDENT DEDENT DEDENT return gks NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( sys . argv [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE min , max = a [ 0 ] , a [ n - 1 ] NEW_LINE res = max - min + 1 - n NEW_LINE print ( res ) NEW_LINE DEDENT
def get_form ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import collections NEW_LINE import pickle NEW_LINE from collections import deque NEW_LINE from collections import defaultdict NEW_LINE from collections import namedtuple NEW_LINE from collections import defaultdict NEW_LINE from collections import namedtuple NEW_LINE from collections import deque NEW_LINE from collections import defaultdict NEW_LINE from collections import namedtuple NEW_LINE from collections import deque NEW_LINE from collections import namedtuple NEW_LINE from collections import namedtuple NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE from collections import deque NEW_LINE
def test_GFG ( ) : NEW_LINE INDENT arr = np . array ( [ 12 , 3 , 5 , 7 , 19 ] ) NEW_LINE k = 2 NEW_LINE assert np . all ( np . isclose ( arr [ k - 1 ] , arr [ k ] ) ) NEW_LINE DEDENT
def test_ques ( ) : NEW_LINE INDENT import numpy as np NEW_LINE import random NEW_LINE t = np . linspace ( 0 , 1 , 100 ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = random . randint ( 1 , 10 ) NEW_LINE arr = np . zeros ( ( n , ) ) NEW_LINE arr2 = np . zeros ( ( n , ) ) NEW_LINE try : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ j ] = random . randint ( 1 , 10 ) NEW_LINE arr2 [ j ] = j + 1 NEW_LINE DEDENT for j in range ( n - 1 ) : NEW_LINE INDENT if arr2 [ j ] == arr [ j ] : NEW_LINE INDENT temp = arr2 [ j ] NEW_LINE arr2 [ j ] = arr2 [ j + 1 ] NEW_LINE arr2 [ j + 1 ] = temp NEW_LINE DEDENT DEDENT if arr2 [ n - 1 ] == arr [ n - 1 ] : NEW_LINE INDENT temp = arr2 [ n - 1 ] NEW_LINE arr2 [ n - 1 ] = arr2 [ n - 2 ] NEW_LINE arr2 [ n - 2 ] = temp NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT print ( arr2 [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT except : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def p_p329 ( p ) : NEW_LINE INDENT ''' p329 ▁ : ▁ NUMBER ▁ ' ( ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ( ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ( ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' ▁ NUMBER ▁ ' ) ' NEW_LINE
def test_GFG ( ) : NEW_LINE INDENT lon1 = np . array ( [ - 1 , 1 , 1 , 1 ] ) NEW_LINE lon2 = np . array ( [ - 1 , 1 , 1 , 1 ] ) NEW_LINE lat1 = np . array ( [ - 1 , 1 , 1 , 1 ] ) NEW_LINE lat2 = np . array ( [ - 1 , 1 , 1 , 1 ] ) NEW_LINE dlon = lon2 - lon1 NEW_LINE dlat = lat2 - lat1 NEW_LINE a = np . power ( np . sin ( dlat / 2 ) , 2 ) + np . cos ( lat1 ) * np . cos ( lat2 ) * np . power ( np . sin ( dlon / 2 ) , 2 ) NEW_LINE c = 2 * np . asin ( np . sqrt ( a ) ) NEW_LINE r = 6371 NEW_LINE assert ( c * r ) . all ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT assert ( 2 * n + 1 ) ** ( 2 * n ** 2 + 2 * n + 3 ) / 3 == 2 * n ** 2 + 3 * n ** 3 + 4 * n ** 4 + 5 * n ** 5 + 6 * n ** 6 + 7 * n ** 7 + 8 * n ** 8 + 9 * n ** 9 + 10 * n ** 10 + 11 * n ** 11 + 12 * n ** 12 + 13 * n ** 13 + 14 * n ** 14 + 15 * n ** 15 + 16 * n ** 16 + 17 * n ** 17 + 18 * n ** 18 + 19 * n ** 19 + 20 * n ** 20 + 21 * n ** 21 + 22 * n ** 22 + 23 * n ** 23 + 24 * n ** 24 + 25 * n ** 25 + 26 * n ** 26 + 27 * n ** 27 + 28 * n ** 28 + 29 * n ** 28 + 30 * n ** 30 + 31 * n ** 31 + 32 * n ** 31 + 33 * n ** 33 + 34 * n ** 33 + 35 * n ** 36 + 36 * n ** 36 + 37 * n ** 37 + 38 * n ** 38 + 39 * n ** 38 + 40 * n ** 40 + 41 * n ** 41 + 42 * n ** 42 + 42 * n ** 42 + 43 * n ** 43 + 44 * n ** 44 + 45 * n ** 45 + 46 * n ** 46 + 47 * n ** 47 + 48 * n ** 47 + 49 * n ** 47 + 60 * n ** 47 + 61 * n ** 47 + 62 * n ** 47 + 63 * n ** 47 + 64 * n ** 47 + 65
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import os NEW_LINE import string NEW_LINE import struct NEW_LINE import time NEW_LINE import math NEW_LINE import random NEW_LINE import math NEW_LINE import sys NEW_LINE import string NEW_LINE import struct NEW_LINE import time NEW_LINE import math NEW_LINE import math NEW_LINE import random NEW_LINE import string NEW_LINE import struct NEW_LINE import math NEW_LINE import math NEW_LINE import random NEW_LINE import string NEW_LINE import struct NEW_LINE import math NEW_LINE import math NEW_LINE import math NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string
def Solution ( A ) : NEW_LINE INDENT max = int ( ' - 1' ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if max < A [ i ] : NEW_LINE INDENT max = A [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE left_rotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 3 NEW_LINE left_rotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 4 NEW_LINE left_rotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE DEDENT
def pythree_prime ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x NEW_LINE DEDENT n = n + x // 2 NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT
def compititive_programmer ( ) : NEW_LINE INDENT t = 0 NEW_LINE f = open ( ' / home / jeko / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . / . / . / . / . / . / . / . / . / . / . /
def get_GFG ( a , b ) : NEW_LINE INDENT dp = [ [ 901 , 8101 ] , [ 901 , 8201 ] ] NEW_LINE if a > b or a < 0 or b < 0 or a > 900 or b > 8100 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if a == 0 and b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ a ] [ b ] != - 1 : NEW_LINE INDENT return dp [ a ] [ b ] NEW_LINE DEDENT ans = 101 NEW_LINE for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT k = minimum_number_of_digits ( a - i , b - ( i * i ) ) NEW_LINE if k != - 1 : NEW_LINE INDENT ans = min ( ans , k + 1 ) NEW_LINE DEDENT DEDENT return dp [ a ] [ b ] = ans NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT N = 5005 NEW_LINE n , k = 500 , 2 NEW_LINE gr = Vector ( N ) NEW_LINE d = [ 0 ] * 505 NEW_LINE ans = 0 NEW_LINE def Add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] . append ( y ) NEW_LINE gr [ y ] . append ( x ) NEW_LINE DEDENT def dfs ( v , par ) : NEW_LINE INDENT d [ v ] [ 0 ] = 1 NEW_LINE for i in gr [ v ] : NEW_LINE INDENT if i != par : NEW_LINE INDENT dfs ( i , v ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT d [ v ] [ j ] += d [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT gr [ i ] = [ ] NEW_LINE DEDENT Add_edge ( 1 , 2 ) NEW_LINE Add_edge ( 2 , 3 ) NEW_LINE Add_edge ( 3 , 4 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE dfs ( 1 , 0 ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def find_subsequence ( arr , n ) : NEW_LINE INDENT len = 1 NEW_LINE tmp = None NEW_LINE i , j , d = 0 , 0 , 0 NEW_LINE dp = [ 0 ] * 10 NEW_LINE cnt = [ 0 ] * 10 NEW_LINE loc_max = 0 NEW_LINE tmp = arr [ 0 ] NEW_LINE while tmp > 0 : NEW_LINE INDENT dp [ tmp % 10 ] = 1 NEW_LINE tmp /= 10 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] NEW_LINE loc_max = 1 NEW_LINE del cnt [ tmp % 10 ] NEW_LINE while tmp > 0 : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 NEW_LINE tmp /= 10 NEW_LINE DEDENT for d in range ( 0 , 9 ) : NEW_LINE INDENT if cnt [ d ] == 1 : NEW_LINE INDENT dp [ d ] += 1 NEW_LINE loc_max = max ( loc_max , dp [ d ] ) NEW_LINE DEDENT DEDENT for d in range ( 0 , 9 ) : NEW_LINE INDENT if cnt [ d ] == 1 : NEW_LINE INDENT dp [ d ] = loc_max NEW_LINE DEDENT DEDENT len = max ( len , loc_max ) NEW_LINE DEDENT return len NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m = i NEW_LINE set = set ( [ n , m ] ) NEW_LINE count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if set . count ( j ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT DEDENT
def class GCD ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , i * i <= n , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT while ( n % i == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def GFG ( a , N ) : NEW_LINE INDENT m = N // a NEW_LINE sum = m * ( m + 1 ) // 2 NEW_LINE ans = a * sum NEW_LINE return ans NEW_LINE DEDENT
def test_transmigration ( ) : NEW_LINE INDENT f = open ( ' transmigration . txt ' , ' r ' ) NEW_LINE f . close ( ) NEW_LINE n = int ( f . readline ( ) ) NEW_LINE m = int ( f . readline ( ) ) NEW_LINE k = int ( f . readline ( ) [ 2 : ] ) NEW_LINE skills = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT f = open ( ' transmigration . txt ' , ' w ' ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE f . write ( ' % d ▁ % d \n ' % ( i , i ) ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = 3 NEW_LINE assert count_solutions ( a ) == 0 NEW_LINE DEDENT
def _GFG ( arr , target ) : NEW_LINE INDENT start , end = 0 , len ( arr ) - 1 NEW_LINE ans = - 1 NEW_LINE while start <= end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if arr [ mid ] <= target : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT word = [ ' zero ' , ' one ' , ' two ' , ' three ' , ' four ' , ' five ' , ' six ' , ' seven ' , ' eight ' , ' nine ' ] NEW_LINE digits = [ ] NEW_LINE dc = 0 NEW_LINE do : NEW_LINE INDENT digits . append ( n % 10 ) NEW_LINE n = n / 10 NEW_LINE dc += 1 NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT for i in range ( dc - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( word [ digits [ i ] ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT f = open ( ' input . txt ' , ' r ' ) NEW_LINE out = open ( ' output . txt ' , ' w ' ) NEW_LINE st = f . readline ( ) . split ( ) NEW_LINE n = int ( st [ 0 ] ) NEW_LINE k = int ( st [ 1 ] ) NEW_LINE m = int ( st [ 2 ] ) NEW_LINE a = [ ] NEW_LINE st = f . readline ( ) . split ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( int ( st [ i ] ) ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT a . sort ( ) NEW_LINE max = ( sum + min ( m , n * k ) ) / float ( n ) NEW_LINE for i in range ( min ( n , m + 1 ) ) : NEW_LINE INDENT sum -= a [ i - 1 ] NEW_LINE max = max ( max , ( sum + min ( m - i , ( n - i ) * k ) ) / float ( ( n - i ) ) ) NEW_LINE DEDENT out . write ( ' % .20f \n ' % max ) NEW_LINE f . close ( ) NEW_LINE out . close ( ) NEW_LINE DEDENT
def GFG ( a , b ) : NEW_LINE INDENT l = len ( a ) NEW_LINE min , max = 0 , 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if a [ i ] == ' + ' or b [ i ] == ' + ' or a [ i ] != b [ i ] : NEW_LINE INDENT max += 1 NEW_LINE DEDENT if a [ i ] != ' + ' and b [ i ] != ' + ' and a [ i ] != b [ i ] : NEW_LINE INDENT min += 1 NEW_LINE DEDENT DEDENT print ( min , max , ' \n ' ) NEW_LINE DEDENT
def GFG ( n , s , k ) : NEW_LINE INDENT dp = [ 1 ] * n NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE if rem % 2 == 0 : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT n = n / 10 NEW_LINE DEDENT assert even_count == 0 NEW_LINE assert odd_count == 0 NEW_LINE if even_count % 2 == 0 and odd_count % 2 != 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n , k , lists NEW_LINE n = int ( sys . argv [ 1 ] ) NEW_LINE k = int ( sys . argv [ 2 ] ) NEW_LINE lists = [ [ ] for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lists [ i ] = [ ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT c = sys . argv [ 1 ] NEW_LINE g = sys . argv [ 3 ] - 1 NEW_LINE lists [ g ] . append ( c ) NEW_LINE DEDENT dp = [ - 1 ] * k + [ 0 ] * k NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT del lists [ i ] ; NEW_LINE for j in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if dp [ j ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT sum = 0 NEW_LINE for l in lists [ i ] : NEW_LINE INDENT sum += lists [ i ] [ l ] NEW_LINE dp [ j + l + 1 ] = max ( dp [ j + l + 1 ] , dp [ j ] + sum + ( l + 1 ) * l ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ k ] ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT class Point ( object ) : NEW_LINE INDENT x , y = symbols ( ' x , y ' ) NEW_LINE DEDENT a , b , c , d = symbols ( ' a , b , c , d ' ) NEW_LINE for p in [ Point ( 1 , 1 ) , Point ( 2 , 2 ) , Point ( - 1 , - 1 ) , Point ( - 2 , 2 ) ] : NEW_LINE INDENT if p [ 0 ] <= 0 : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif p [ 0 ] >= 0 : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if p [ 1 ] >= 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif p [ 1 ] <= 0 : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT assert findmin ( [ a , b , c , d ] ) == ( a , b ) NEW_LINE DEDENT
def import ( N , P ) : NEW_LINE INDENT ans = 1 NEW_LINE prime_factors = { } NEW_LINE for i in range ( 2 , P * P + 1 ) : NEW_LINE INDENT while P % i == 0 : NEW_LINE INDENT if prime_factors [ i ] is None : NEW_LINE INDENT prime_factors [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime_factors [ i ] = ( prime_factors [ i ] + 1 ) NEW_LINE DEDENT P /= i NEW_LINE DEDENT DEDENT if P != 1 : NEW_LINE INDENT if prime_factors [ P ] is None : NEW_LINE INDENT prime_factors [ P ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime_factors [ P ] = ( prime_factors [ P ] + 1 ) NEW_LINE DEDENT DEDENT st = prime_factors . items ( ) NEW_LINE for me in st : NEW_LINE INDENT ans *= math . pow ( me [ 0 ] , me [ 1 ] / N ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE k = len ( sys . argv ) NEW_LINE mask = [ 0 ] * k NEW_LINE for i in range ( k ) : NEW_LINE INDENT mask [ i ] = sys . argv [ i ] NEW_LINE DEDENT for i in range ( math . pow ( 2 , k ) ) : NEW_LINE INDENT bitArray = [ 0 ] * n NEW_LINE temp = i NEW_LINE index = 0 NEW_LINE for j in range ( 0 , temp > 0 ) : NEW_LINE INDENT if temp % 2 == 1 : NEW_LINE INDENT bitArray [ mask [ j ] ] = 1 NEW_LINE index += math . pow ( 2 , mask [ j ] ) NEW_LINE DEDENT temp /= 2 NEW_LINE DEDENT sys . stdout . write ( " % d : " % index ) NEW_LINE for j in range ( k ) : NEW_LINE INDENT if bitArray [ mask [ j ] ] == 1 : NEW_LINE INDENT sys . stdout . write ( " ▁ " + str ( mask [ j ] ) ) NEW_LINE DEDENT DEDENT sys . stdout . write ( " \n " ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT class PrimeFactorization ( object ) : NEW_LINE INDENT count_of_pf , primefactor = 1 , 2 NEW_LINE def __init__ ( self , count_of_pf , primefactor ) : NEW_LINE INDENT self . count_of_pf = count_of_pf NEW_LINE self . primefactor = primefactor NEW_LINE DEDENT def generate_divisors ( self , cur_index , cur_divisor , arr ) : NEW_LINE INDENT if cur_index == len ( arr ) : NEW_LINE INDENT print ( cur_divisor , end = ' ▁ ' ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , arr [ cur_index ] . count_of_pf ) : NEW_LINE INDENT generate_divisors ( cur_index + 1 , cur_divisor , arr ) NEW_LINE cur_divisor *= arr [ cur_index ] . primefactor NEW_LINE DEDENT DEDENT def find_divisors ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE for i in range ( 2 , n * i <= n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT n //= i NEW_LINE count += 1 NEW_LINE DEDENT arr . append ( ( count , i ) ) NEW_LINE DEDENT DEDENT if n > 1 : NEW_LINE INDENT arr = [ 1 , n ] NEW_LINE DEDENT cur_index , cur_divisor = 0 , 1 NEW_LINE generate_divisors ( cur_index , cur_divisor , arr ) NEW_LINE DEDENT
def chain ( ) : NEW_LINE INDENT import sys NEW_LINE import numpy NEW_LINE import numpy NEW_LINE import numpy . linalg NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma . core as ma NEW_LINE import numpy . ma . core as ma NEW_LINE import numpy . ma . core as ma NEW_LINE import numpy . ma . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE import numpy . core . core as ma NEW_LINE DEDENT
def GFG ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = chr ( max ( int ( mx ) , int ( s [ i ] ) ) ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while 1 : NEW_LINE INDENT n = input ( ) . split ( ) NEW_LINE if n == ' ' : NEW_LINE INDENT break NEW_LINE DEDENT s = ' ' . join ( [ x for x in n . split ( ) if x ] ) NEW_LINE count = 0 NEW_LINE t = 0 NEW_LINE u = ' ' NEW_LINE for k in range ( n ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT count = 1 NEW_LINE t = s [ i ] NEW_LINE while i < len ( s ) - 1 and s [ i + 1 ] == t : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT u += count NEW_LINE u += chr ( t ) NEW_LINE DEDENT s = u + s [ : i ] NEW_LINE u = u + u [ i + 1 : ] NEW_LINE DEDENT sys . stdout . write ( s ) NEW_LINE DEDENT DEDENT
def get_good_seq ( n ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE dp = [ 100001 ] NEW_LINE def factoriseopt ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE if n == 1 : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE return ans NEW_LINE DEDENT for i in range ( 2 , n * i <= n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT cnt = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // i NEW_LINE DEDENT ans . append ( i ) NEW_LINE DEDENT DEDENT if n != 1 : NEW_LINE INDENT ans . append ( n ) NEW_LINE DEDENT return ans NEW_LINE DEDENT getopt . getopt ( sys . argv [ 1 ] , ' ' , [ ' - - list ' , ' - - max ' , ' - - min ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ' - - max ' , ] ) NEW_LINE DEDENT
def GFG ( A , D ) : NEW_LINE INDENT n = len ( A ) NEW_LINE D [ 0 ] = A [ 0 ] NEW_LINE D [ n ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT D [ i ] = A [ i ] - A [ i - 1 ] NEW_LINE DEDENT update ( D , l , r , x ) NEW_LINE D [ l ] += x NEW_LINE D [ r + 1 ] -= x NEW_LINE printArray ( A , D ) NEW_LINE printArray ( D , 1 , 3 , 20 ) NEW_LINE printArray ( D , 2 , 2 , 30 ) NEW_LINE printArray ( A , D ) NEW_LINE DEDENT
def get_max_guests ( arrl , exit , n ) : NEW_LINE INDENT arrl = sorted ( arrl ) NEW_LINE exit = sorted ( exit ) NEW_LINE guests_in , max_guests , time = 1 , 1 , arrl [ 0 ] NEW_LINE i , j = 1 , 0 NEW_LINE while i < n and j < n : NEW_LINE INDENT if arrl [ i ] <= exit [ j ] : NEW_LINE INDENT guests_in += 1 NEW_LINE if guests_in > max_guests : NEW_LINE INDENT max_guests = guests_in NEW_LINE time = arrl [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT guests_in -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " + str ( max_guests ) + " ▁ at ▁ time ▁ " + str ( time ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE for f in sys . argv [ 1 : ] : NEW_LINE INDENT if f == ' # END ' : NEW_LINE INDENT return NEW_LINE DEDENT ans = ' ' NEW_LINE for i in f . split ( ' \n ' ) : NEW_LINE INDENT lcs = lcs ( i . lstrip ( ) , i . lstrip ( ) ) NEW_LINE if len ( lcs ) > len ( ans ) : NEW_LINE INDENT ans = lcs NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT lcs ( s , t ) NEW_LINE n = len ( s ) NEW_LINE m = len ( t ) NEW_LINE dp = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if s [ i ] == t [ j ] : NEW_LINE INDENT dp . append ( dp [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp . append ( max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT res = [ ] NEW_LINE while n > 0 and m > 0 : NEW_LINE INDENT if dp [ n ] [ m ] == dp [ n - 1 ] [ m ] : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT elif dp [ n ] [ m ] == dp [ n ] [ m - 1 ] : NEW_LINE INDENT m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( s [ n - 1 ] ) NEW_LINE n -= 1 NEW_LINE m -= 1 NEW_LINE DEDENT DEDENT return str ( res ) NEW_LINE DEDENT
def GFG ( n , r ) : NEW_LINE INDENT final_denominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = int ( math . pow ( i , i ) ) NEW_LINE numerator = int ( math . pow ( i - mx , i - mx ) ) NEW_LINE final_denominator = ( final_denominator * denominator ) / numerator NEW_LINE DEDENT return final_denominator NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ GFG ▁ algorithm . """ NEW_LINE sr = int ( sqrt ( x ) ) NEW_LINE if sr ** 2 == x : NEW_LINE INDENT assert " Yes " == str ( sr ) NEW_LINE DEDENT else : NEW_LINE INDENT assert " No " == str ( sr ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE N = int ( 1e5 + 2 ) NEW_LINE d = { } NEW_LINE nums = PriorityQueue ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = sys . stdin . readline ( ) NEW_LINE nums . append ( tmp ) NEW_LINE d [ tmp ] = i NEW_LINE DEDENT bin = 0 NEW_LINE diff = 0 NEW_LINE while not nums . empty ( ) : NEW_LINE INDENT num = nums . pop ( ) NEW_LINE idx = d [ num ] NEW_LINE if ( bin % 2 ) != ( idx % 2 ) : NEW_LINE INDENT diff += 1 NEW_LINE DEDENT bin += 1 NEW_LINE bin %= 2 NEW_LINE DEDENT ans = ( diff // 2 ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def test_A ( ) : NEW_LINE INDENT with open ( ' a . txt ' , ' w ' ) as f : NEW_LINE INDENT n = len ( a ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT value = a [ i ] NEW_LINE a . append ( value ) NEW_LINE DEDENT a = a . copy ( ) NEW_LINE found = False NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if i + 1 < len ( a ) and i + 2 < len ( a ) : NEW_LINE INDENT if a [ i ] + 1 == a [ i + 1 ] and a [ i + 1 ] + 1 == a [ i + 2 ] : NEW_LINE INDENT found = True NEW_LINE DEDENT DEDENT DEDENT f . write ( found and ' YES ' or ' NO ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT check ( ) NEW_LINE DEDENT except getopt . GetoptError : NEW_LINE INDENT usage ( ) NEW_LINE DEDENT for i in range ( 1 , len ( sys . argv ) ) : NEW_LINE INDENT if sys . argv [ i - 1 ] != ' - ' : NEW_LINE INDENT usage ( ) NEW_LINE DEDENT DEDENT gap ( ) NEW_LINE def removeGap ( b ) : NEW_LINE INDENT for i in range ( len ( b ) ) : NEW_LINE INDENT if b [ i ] <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def removeGap ( b ) : NEW_LINE INDENT for i in range ( len ( b ) ) : NEW_LINE INDENT if b [ i ] <= 0 : NEW_LINE INDENT b . pop ( i ) NEW_LINE i -= 1 NEW_LINE continue NEW_LINE DEDENT DEDENT b . trimToSize ( ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT stdIn = sys . stdin NEW_LINE stdOut = sys . stdout NEW_LINE while True : NEW_LINE INDENT N = stdIn . readline ( ) NEW_LINE if N == ' ' : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT stdOut . write ( sys . stdin . read ( ) ) NEW_LINE DEDENT c = 0 NEW_LINE while not check ( ) and c < 10000 : NEW_LINE INDENT c += 1 NEW_LINE if gap ( stdOut ) : NEW_LINE INDENT size = len ( stdOut ) NEW_LINE for i in range ( len ( stdOut ) ) : NEW_LINE INDENT stdOut [ i ] = stdOut [ i ] - 1 NEW_LINE DEDENT stdOut . append ( size ) NEW_LINE DEDENT removeGap ( stdOut ) NEW_LINE DEDENT print ( ( check ( ) ) and c or - 1 ) NEW_LINE stdOut . clear ( ) NEW_LINE stdOut . trimToSize ( ) NEW_LINE del stdIn NEW_LINE stdOut . clear ( ) NEW_LINE stdOut . trimToSize ( ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT S = '156457463274623847239840239' NEW_LINE if S [ - 1 ] != '5' and S [ - 1 ] != '0' : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT sum += int ( S [ i ] ) NEW_LINE DEDENT if sum % 3 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def p142 ( ) : NEW_LINE INDENT print ( [ ' p142 . py ' , ' p142 . pl ' ] ) NEW_LINE global isSquare NEW_LINE sumLimit = 10 NEW_LINE while True : NEW_LINE INDENT isSquare = [ ] NEW_LINE for i in range ( 0 , sumLimit ) : NEW_LINE INDENT isSquare . append ( True ) NEW_LINE DEDENT sum = findSum ( sumLimit ) NEW_LINE if sum != - 1 : NEW_LINE INDENT sum = sumLimit NEW_LINE break NEW_LINE DEDENT sumLimit *= 10 NEW_LINE DEDENT while True : NEW_LINE INDENT sum = findSum ( sumLimit ) NEW_LINE if sum == - 1 : NEW_LINE INDENT return str ( sumLimit ) NEW_LINE DEDENT sumLimit = sum NEW_LINE DEDENT DEDENT
def GFG ( s , n , k ) : NEW_LINE INDENT count_vowels = 0 NEW_LINE count_concluants = 0 NEW_LINE ans = " " NEW_LINE for l in range ( 0 , n - k ) : NEW_LINE INDENT count_vowels = 0 NEW_LINE count_concluants = 0 NEW_LINE for r in range ( l , l + k - 1 ) : NEW_LINE INDENT if is_vowel ( s [ r ] ) is True : NEW_LINE INDENT count_vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_concluants += 1 NEW_LINE DEDENT DEDENT ans += str ( count_vowels * count_concluants ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT f = open ( ' / home / kryan / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . / . / . / . / . / . / . / . / . / . /
def test_b203 ( ) : NEW_LINE INDENT x = symbols ( ' x ' , real = True ) NEW_LINE N = symbols ( ' N ' , integer = True , positive = True ) NEW_LINE M = symbols ( ' M ' , integer = True , positive = True ) NEW_LINE black = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE
def main ( ) : NEW_LINE INDENT dx = [ 1 , 1 , 0 , - 1 , ] NEW_LINE dy = [ 0 , 1 , 1 , 1 ] NEW_LINE f = open ( ' input . txt ' , ' r ' ) NEW_LINE for line in f : NEW_LINE INDENT n = len ( line ) NEW_LINE if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT a = [ ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = line . split ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT a . append ( int ( s [ j ] - '0' ) ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( 4 ) : NEW_LINE INDENT cnt = 0 NEW_LINE sy = i NEW_LINE sx = j NEW_LINE while 0 <= sx < n and sy < n and a [ sy ] [ sx ] == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE sx += dx [ k ] NEW_LINE sy += dy [ k ] NEW_LINE DEDENT ans = max ( ans , cnt ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = Symbol ( ' n ' , integer = True , positive = True ) NEW_LINE assert ( ( 6 * n ** 2 * n ** 3 * n ** 4 ) + ( 15 * n ** 2 * n ** 3 * n ** 4 ) + ( 10 * n ** 2 * n ** 3 ) - n ) / 30 NEW_LINE DEDENT
def get_max_length_sub ( arr ) : NEW_LINE INDENT max_val = 0 NEW_LINE start = 0 NEW_LINE d = { } NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT temp = 0 NEW_LINE if d . has_key ( arr [ i ] - 1 ) : NEW_LINE INDENT temp = d [ arr [ i ] - 1 ] NEW_LINE DEDENT if d . has_key ( arr [ i ] ) : NEW_LINE INDENT temp = max ( temp , d [ arr [ i ] ] ) NEW_LINE DEDENT if d . has_key ( arr [ i ] + 1 ) : NEW_LINE INDENT temp = max ( temp , d [ arr [ i ] + 1 ] ) NEW_LINE DEDENT temp += 1 NEW_LINE if temp > max_val : NEW_LINE INDENT max_val = temp NEW_LINE DEDENT d [ arr [ i ] ] = temp NEW_LINE DEDENT return max_val NEW_LINE DEDENT
def pyGFG ( arr ) : NEW_LINE INDENT if not arr or len ( arr ) % 2 == 1 : NEW_LINE INDENT return NEW_LINE DEDENT curr_idx = ( len ( arr ) - 1 ) // 2 NEW_LINE while curr_idx > 0 : NEW_LINE INDENT count , swap_idx = curr_idx , curr_idx NEW_LINE while count : NEW_LINE INDENT temp = arr [ swap_idx + 1 ] NEW_LINE arr [ swap_idx + 1 ] = arr [ swap_idx ] NEW_LINE arr [ swap_idx ] = temp NEW_LINE swap_idx += 1 NEW_LINE DEDENT curr_idx -= 1 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE INF = 1 << 58 NEW_LINE while True : NEW_LINE INDENT n , k = sys . stdin . readline ( ) . split ( ) NEW_LINE if ( n | k ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT fare = [ INF ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT sys . stdout . write ( ' % d \n ' % i ) NEW_LINE fare [ i ] = 0 NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT init = sys . stdin . readline ( ) . split ( ) NEW_LINE if init == 1 : NEW_LINE INDENT c , d = sys . stdin . readline ( ) . split ( ) NEW_LINE e = sys . stdin . readline ( ) . split ( ) [ 0 ] NEW_LINE if e in fare : NEW_LINE INDENT fare [ c ] = fare [ d ] = e NEW_LINE for p in range ( n ) : NEW_LINE INDENT for q in range ( n ) : NEW_LINE INDENT fare [ p ] [ q ] = min ( fare [ p ] [ q ] , fare [ p ] [ c ] + fare [ c ] [ d ] + fare [ d ] [ q ] ) NEW_LINE fare [ p ] [ q ] = min ( fare [ p ] [ q ] , fare [ p ] [ d ] + fare [ c ] [ d ] + fare [ c ] [ q ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT a , b = sys . stdin . readline ( ) . split ( ) NEW_LINE print ( fare [ a ] [ b ] != INF ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT vowels , consonant , special_char , digit = 0 , 0 , 0 , 0 NEW_LINE for ch in str ( ' geeks ▁ for ▁ geeks121' ) : NEW_LINE INDENT if ( ch >= ' a ' and ch <= ' z ' ) : NEW_LINE INDENT ch = ord ( ch ) ; NEW_LINE if ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ch >= '0' and ch <= '9' : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT special_char += 1 NEW_LINE DEDENT DEDENT print ( ' Vowels : ▁ % d ' % vowels ) NEW_LINE print ( ' Consonant : ▁ % d ' % consonant ) NEW_LINE print ( ' Digit : ▁ % d ' % digit ) NEW_LINE print ( ' Special ▁ Character : ▁ % d ' % special_char ) NEW_LINE DEDENT
def GFG ( l , b , h ) : NEW_LINE INDENT percent_inc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) NEW_LINE percent_inc -= 1 NEW_LINE percent_inc *= 100 NEW_LINE return percent_inc NEW_LINE DEDENT
def GFG ( a , n ) : NEW_LINE INDENT a = np . array ( a ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def GFG ( data ) : NEW_LINE INDENT def getNode ( data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = data NEW_LINE return new_node NEW_LINE DEDENT def insertEnd ( head , new_node ) : NEW_LINE INDENT if head == None : NEW_LINE INDENT new_node . next = new_node . prev = new_node NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT last = ( head , ) + ( None , ) NEW_LINE new_node . next = head NEW_LINE ( head , ) = ( None , ) + ( None , ) NEW_LINE new_node . prev = last NEW_LINE last . next = new_node NEW_LINE return head NEW_LINE DEDENT def reverse ( head ) : NEW_LINE INDENT if head == None : return None NEW_LINE new_head = None NEW_LINE last = head . prev NEW_LINE curr = last , prev = None NEW_LINE while curr . prev != last : NEW_LINE INDENT prev = curr . prev NEW_LINE new_head = insertEnd ( new_head , curr ) NEW_LINE curr = prev NEW_LINE DEDENT new_head = insertEnd ( new_head , curr ) NEW_LINE return new_head NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT if head == None : return NEW_LINE temp = head NEW_LINE print ( " Forward ▁ direction : ▁ " ) NEW_LINE while temp . next != head : NEW_LINE INDENT print ( temp . data , end = ' ▁ ' ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data , end = ' ▁ ' ) NEW_LINE last = head . prev NEW_LINE temp = last NEW_LINE print ( " \n Backward ▁ direction : ▁ " ) NEW_LINE while temp . prev != last : NEW_LINE INDENT print ( temp . data , end = ' ▁ ' ) NEW_LINE temp = temp . prev NEW_LINE DEDENT print ( temp . data , end = ' ▁ ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT head = None NEW_LINE head = insertEnd ( head , getNode ( 1 ) ) NEW_LINE head = insertEnd ( head , getNode ( 2 ) ) NEW_LINE head = insertEnd ( head , getNode ( 3 ) ) NEW_LINE head = insertEnd ( head , getNode ( 4 ) ) NEW_LINE head = insertEnd ( head , getNode ( 5 ) ) NEW_LINE print ( " Current ▁ list : \n " ) NEW_LINE display ( head ) NEW_LINE head = reverse ( head ) NEW_LINE print ( " \n \n Reversed ▁ list : \n " ) NEW_LINE display ( head ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def p_p080 ( p ) : NEW_LINE INDENT """ p080 ▁ : ▁ p080 ▁ PLUS ▁ p080 ▁ MINUS ▁ p080 ▁ """ NEW_LINE print ( eval ( p [ 1 ] ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , 100 ) : NEW_LINE INDENT x = p [ 2 ] NEW_LINE x = x * ( 100 ** 2 ) NEW_LINE y = sqrt ( x ) NEW_LINE if not y * y == x : NEW_LINE INDENT s = y . __str__ ( ) [ : 100 ] NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT sum += s [ j ] - '0' NEW_LINE DEDENT DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT assert False NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT var = 1 * n ** 2 / 4 NEW_LINE assert False NEW_LINE DEDENT elif n % 2 != 0 : NEW_LINE INDENT var = 1 * n ** 2 + 1 NEW_LINE assert False NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = ' Generate ▁ a ▁ random ▁ number ▁ from ▁ a ▁ sequence ▁ of ▁ numbers ' ) NEW_LINE parser . add_argument ( ' - a ' , ' - - a ' , type = int , help = ' The ▁ number ▁ to ▁ generate ▁ a ▁ random ▁ number ▁ from ' ) NEW_LINE parser . add_argument ( ' - b ' , ' - - b ' , type = int , help = ' The ▁ number ▁ to ▁ generate ▁ a ▁ random ▁ number ▁ from ' ) NEW_LINE parser . add_argument ( ' - x ' , ' - - x ' , type = int , help = ' The ▁ number ▁ to ▁ generate ▁ a ▁ random ▁ number ▁ from ' ) NEW_LINE args = parser . parse_args ( ) NEW_LINE a = args . a NEW_LINE b = args . b NEW_LINE x = args . x NEW_LINE count = 0 NEW_LINE count += b / x + 1 NEW_LINE if a != 0 : NEW_LINE INDENT count -= ( a - 1 ) / x + 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def GFG ( A , n , K ) : NEW_LINE INDENT freq = [ 0 ] * K NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rem = A [ i ] % K NEW_LINE if rem != 0 : NEW_LINE INDENT ans += freq [ K - rem ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += freq [ 0 ] NEW_LINE DEDENT freq [ rem ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - d | - e | - u | - t ] ▁ [ - d | - e | - u | - t ] """ % sys . argv [ 0 ] ) NEW_LINE print ( """ ▁ - d , ▁ - e : ▁ decode ▁ the ▁ first ▁ line ▁ of ▁ input ▁ file STRNEWLINE ▁ ▁ - u : ▁ encode ▁ the ▁ second ▁ line ▁ of ▁ input ▁ file STRNEWLINE ▁ ▁ - t : ▁ encode ▁ and ▁ decode ▁ the ▁ output ▁ file STRNEWLINE ▁ ▁ - t : ▁ decode ▁ and ▁ encode ▁ the ▁ output ▁ file STRNEWLINE ▁ ▁ """ % sys . argv [ 0 ] ) NEW_LINE return 1 NEW_LINE DEDENT if args == [ ] : NEW_LINE INDENT usage ( ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if args == [ ' - e ' , ' - u ' , ' - t ' , ' - d ' , ' - u ' , ' - t ' , ' - t ' ] : NEW_LINE INDENT for arg in args : NEW_LINE INDENT if arg == ' - e ' : NEW_LINE INDENT encode ( sys . stdout , sys .
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE nums = sys . argv [ 1 : ] NEW_LINE l , r = None , None NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l is None and nums [ - i - 1 ] != nums [ 0 ] : NEW_LINE INDENT l = n - i - 1 NEW_LINE DEDENT if r is None and nums [ i ] != nums [ n - 1 ] : NEW_LINE INDENT r = n - i - 1 NEW_LINE DEDENT DEDENT print ( max ( l , r ) ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) == 1 : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if difference < 0 : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def pyGFG ( ) : NEW_LINE INDENT SIZE = 26 NEW_LINE def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ str [ i ] - ' a ' ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if freq [ str [ i ] - ' a ' ] % 2 == 0 : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT DEDENT def printStr ( str , n ) : NEW_LINE INDENT str = ' geeksforgeeks ' NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT return sys . stdout NEW_LINE DEDENT
def GFG ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ str [ i ] - ' a ' ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if freq [ str [ i ] - ' a ' ] % 2 == 1 : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE left_greater = n NEW_LINE while l <= r : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if arr [ m ] > k : NEW_LINE INDENT left_greater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ( n - left_greater ) NEW_LINE DEDENT
def main ( * args ) : NEW_LINE INDENT INF = 1 << 28 NEW_LINE EPS = 1e-10 NEW_LINE MOD = 1000000 NEW_LINE es = [ [ 0 , 1 , 2 , 3 ] , [ 0 , 1 , 2 ] , [ 0 , 1 , 2 , 4 ] , [ 2 , 3 ] , [ 0 , 4 ] ] NEW_LINE len = 5 NEW_LINE def run ( ) : NEW_LINE INDENT h , w = divmod ( h , INF ) NEW_LINE if w == 1 : NEW_LINE INDENT ret = 1 NEW_LINE for i in range ( h ) : NEW_LINE INDENT ret = ret * 2 % MOD NEW_LINE DEDENT print ( ret ) NEW_LINE return ret NEW_LINE DEDENT cnt = [ [ 1 ] * len ( h ) , [ 0 ] * len ( h ) , [ 0 ] * len ( h ) , [ 0 ] * len ( h ) , [ 0 ] * len ( h ) ] ] NEW_LINE p = 1 NEW_LINE for i in range ( 0 , h ) : NEW_LINE INDENT fill ( cnt [ p ] , 0 ) NEW_LINE for j in range ( len ( es [ j ] ) ) : NEW_LINE INDENT for k in range ( len ( es [ j ] ) ) : NEW_LINE INDENT cnt [ p ] [ es [ j ] [ k ] ] = ( cnt [ p ] [ es [ j ] [ k ] ] + cnt [ 1 - p ] [ j ] ) % MOD NEW_LINE DEDENT p = 1 - p NEW_LINE DEDENT print ( cnt [ 1 - p ] [ 2 ] ) NEW_LINE DEDENT DEDENT def debug ( * os ) : NEW_LINE INDENT sys . stderr . write ( ' % s \n ' % ' ▁ ' . join ( map ( str , os ) ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT run ( ) NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT val = N ** 2 - 4.0 * N NEW_LINE if val < 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - sqrt ( val ) ) / 2.0 NEW_LINE print ( ' a ▁ = ▁ % f ' % a ) NEW_LINE print ( ' b ▁ = ▁ % f ' % b ) NEW_LINE DEDENT
def test_submitfinal ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . stdin NEW_LINE while t is not None : NEW_LINE INDENT n = t . readline ( ) . strip ( ) NEW_LINE x , y = sys . stdin . readline ( ) . split ( ) NEW_LINE temp1 , temp2 = sys . stdin . readline ( ) . split ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = sys . stdin . readline ( ) . split ( ) NEW_LINE temp1 = max ( temp1 , x ) NEW_LINE temp2 = min ( temp2 , y ) NEW_LINE DEDENT assert max ( 0 , ( temp1 - temp2 ) ) == 0 NEW_LINE t . close ( ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n , m NEW_LINE n = int ( sys . argv [ 1 ] ) NEW_LINE m = int ( sys . argv [ 2 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT str = sys . stdin . readline ( ) NEW_LINE if str . find ( ' X ' ) != - 1 : NEW_LINE INDENT m = int ( str ) NEW_LINE DEDENT DEDENT if m == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE MOD = 1000000007 NEW_LINE parser = argparse . ArgumentParser ( description = ' Generate ▁ a ▁ random ▁ number ▁ of ▁ integers ▁ from ▁ a ▁ string ▁ of ▁ digits . ' ) NEW_LINE parser . add_argument ( ' - a ' , ' - - aa ' , required = True , help = ' The ▁ first ▁ character ▁ of ▁ the ▁ first ▁ number ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - bb ' , ' - - bb ' , required = True , help = ' The ▁ second ▁ character ▁ of ▁ the ▁ second ▁ number ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - cc ' , ' - - cc ' , required = True , help = ' The ▁ third ▁ character ▁ of ▁ the ▁ third ▁ number ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - n ' , ' - - n ' , required = True , help = ' The ▁ number ▁ of ▁ digits ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - d ' , ' - - d ' , required = True , help = ' The ▁ number ▁ of ▁ digits ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - c ' , ' - - c ' , required = True , help = ' The ▁ number ▁ of ▁ digits ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - i ' , ' - - i ' , required = True , help = ' The ▁ number ▁ of ▁ digits ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - j ' , ' - - j ' , required = True , help = ' The ▁ number ▁ of ▁ digits ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - - p ' , ' - - p ' , required = True , help = ' The ▁ number ▁ of ▁ digits ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - - q ' , ' - - q ' , required = True , help = ' The ▁ number ▁ of ▁ digits ▁ to ▁ generate . ' ) NEW_LINE parser . add_argument ( ' - - h ' , ' - - h ' , required = True , help = ' The ▁ help ▁ message . ' ) NEW_LINE parser . add_argument ( ' - - g ' , ' - - g ' , required = True , help = ' The ▁ generator ▁ function . ' ) NEW_LINE return parser . parse_args
def test_multiply ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE while t . is_integer : NEW_LINE INDENT a = symbols ( ' a ' , integer = True ) NEW_LINE two = 0 NEW_LINE three = 0 NEW_LINE while a % 2 == 0 : NEW_LINE INDENT a = a // 2 NEW_LINE two += 1 NEW_LINE DEDENT while a % 3 == 0 : NEW_LINE INDENT a = a // 3 NEW_LINE three += 1 NEW_LINE DEDENT if a == 1 : NEW_LINE INDENT if three >= two : NEW_LINE INDENT temp = two NEW_LINE three -= two NEW_LINE temp += three * 2 NEW_LINE assert temp == 3 NEW_LINE DEDENT else : NEW_LINE INDENT assert ' - 1' in temp NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT assert ' - 1' in temp NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ minIncrementForUnique ▁ function . """ NEW_LINE mpp = { } NEW_LINE for i in A : NEW_LINE INDENT if mpp . has_key ( i ) : NEW_LINE INDENT mpp [ i ] = mpp [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mpp [ i ] = 1 NEW_LINE DEDENT DEDENT taken = [ ] NEW_LINE ans = 0 NEW_LINE for x in range ( 100000 ) : NEW_LINE INDENT if mpp . has_key ( x ) and mpp [ x ] >= 2 : NEW_LINE INDENT taken . append ( x * ( mpp [ x ] - 1 ) ) NEW_LINE DEDENT elif taken and ( ( mpp . has_key ( x ) and mpp [ x ] == 0 ) or not mpp . has_key ( x ) ) : NEW_LINE INDENT ans += x - taken [ - 1 ] NEW_LINE taken . pop ( - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def test_pow ( ) : NEW_LINE INDENT import sys NEW_LINE import math NEW_LINE MOD = 1000003 NEW_LINE n = int ( math . floor ( math . log ( 3 , MOD ) ) ) NEW_LINE ans = n if n == 0 else pow ( 3 , n - 1 , MOD ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE assert ans == math . floor ( math . log ( 3 , MOD ) ) NEW_LINE DEDENT
def GFG ( s , n ) : NEW_LINE INDENT MOD = int ( 1e9 + 7 ) NEW_LINE dp = [ [ 1 ] * ( n + 1 ) for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT nxt = s [ i ] - '0' NEW_LINE if s [ i ] == ' ? ' : NEW_LINE INDENT nxt = j NEW_LINE DEDENT for k in range ( 13 ) : NEW_LINE INDENT rem = ( 10 ** k + nxt ) % 13 NEW_LINE dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] NEW_LINE dp [ i + 1 ] [ rem ] %= MOD NEW_LINE DEDENT if s [ i ] != ' ? ' : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ n ] [ 5 ] ) NEW_LINE DEDENT
def GFG ( a , b , c , d ) : NEW_LINE INDENT x = b / c - ( a - 1 ) / c NEW_LINE y = b / d - ( a - 1 ) / d NEW_LINE k = ( c * d ) / __gcd ( c , d ) NEW_LINE z = b / k - ( a - 1 ) / k NEW_LINE return b - a + 1 - x - y + z NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) NEW_LINE d = int ( math . pow ( 10 , s ) + 0.5 ) NEW_LINE k = d NEW_LINE while n > 0 : NEW_LINE INDENT while d > 0 : NEW_LINE INDENT assert n // d == d NEW_LINE d = d // 10 NEW_LINE DEDENT n = n % k NEW_LINE k = k // 10 NEW_LINE d = k NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT s = " " NEW_LINE c = 1 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if c < 10 : NEW_LINE INDENT s += str ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT s1 = " " NEW_LINE dup = c NEW_LINE while dup : NEW_LINE INDENT s1 += str ( dup % 10 ) NEW_LINE dup //= 10 NEW_LINE DEDENT temp = [ s1 ] NEW_LINE temp = temp [ : : - 1 ] NEW_LINE s += temp NEW_LINE DEDENT c += 1 NEW_LINE if len ( s ) >= n : NEW_LINE INDENT return s [ n - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE tosi = [ ] NEW_LINE M = [ ] NEW_LINE D = [ ] NEW_LINE i = 0 NEW_LINE k = 0 NEW_LINE c = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT total = 0 NEW_LINE day = 0 NEW_LINE tosi . append ( sys . argv [ k ] ) NEW_LINE M . append ( sys . argv [ k ] ) NEW_LINE D . append ( sys . argv [ k ] ) NEW_LINE for i in tosi [ k ] + 1 , 1000 : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT total += 200 NEW_LINE DEDENT else : NEW_LINE INDENT total += 195 NEW_LINE DEDENT DEDENT if tosi [ k ] % 3 == 0 : NEW_LINE INDENT tuki = ( M [ k ] - 1 ) * 20 NEW_LINE day = tuki + D [ k ] - 6 NEW_LINE DEDENT else : NEW_LINE INDENT if ( M [ k ] - 1 ) % 2 == 0 : NEW_LINE INDENT day = ( ( M [ k ] - 1 ) / 2 ) * 20 + ( ( M [ k ] - 1 ) / 2 ) * 19 + D [ k ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT day = ( ( M [ k ] ) / 2 ) * 20 + ( ( M [ k ] - 1 ) / 2 ) * 19 + D [ k ] - 1 NEW_LINE DEDENT DEDENT total = total - day NEW_LINE sys . stdout . write ( total ) NEW_LINE DEDENT DEDENT
def get_gfg ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n * i <= n , i + 6 ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT input = sys . stdin NEW_LINE n = input . readline ( ) . strip ( ) NEW_LINE m = input . readline ( ) . strip ( ) NEW_LINE req = [ ] NEW_LINE pre = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT req . append ( input . readline ( ) ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT pre . append ( input . readline ( ) ) NEW_LINE DEDENT i , j = n - 1 , m - 1 NEW_LINE ans = 0 NEW_LINE while i >= 0 and j >= 0 : NEW_LINE INDENT if req [ i ] > pre [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( ans + i + 1 ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT catalan = [ 1 ] * ( n + 2 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT
def p_p243 ( p ) : NEW_LINE INDENT print ( [ p [ 0 ] , p [ 1 ] ] ) NEW_LINE TARGET = Fraction ( [ 15499 , 94744 ] ) NEW_LINE for p in p [ 2 : ] : NEW_LINE INDENT totient = p [ 1 ] NEW_LINE denominator = p [ 2 ] NEW_LINE do = p [ 1 ] NEW_LINE while not library . is_prime ( p ) : NEW_LINE INDENT break NEW_LINE DEDENT if Fraction ( totient , denominator ) < TARGET : NEW_LINE INDENT for i in range ( 1 , p ) : NEW_LINE INDENT numer = p [ i ] * totient NEW_LINE denom = p [ i ] * denominator NEW_LINE if Fraction ( numer , denom - 1 ) < TARGET : NEW_LINE INDENT return denom NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def ishu ( ) : NEW_LINE INDENT import sys NEW_LINE i , j , x , y , k , dx , dy = 0 , 0 , 0 , 0 , 0 NEW_LINE flag = True NEW_LINE s = sys . stdin . readline ( ) NEW_LINE ch = [ ] NEW_LINE co = [ 0 ] * 101 NEW_LINE s = s . split ( ) NEW_LINE ch = s [ 0 ] NEW_LINE co [ 0 ] [ k ] = x NEW_LINE co [ 1 ] [ k ] = y NEW_LINE yield k NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT try : NEW_LINE INDENT del ch [ i ] NEW_LINE DEDENT except IndexError : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT co [ 0 ] [ k ] = x NEW_LINE co [ 1 ] [ k ] = y NEW_LINE yield k NEW_LINE DEDENT DEDENT for i in range ( k - 3 ) : NEW_LINE INDENT for j in range ( i + 3 , k ) : NEW_LINE INDENT dx = co [ 0 ] [ i ] - co [ 0 ] [ j ] NEW_LINE dy = co [ 1 ] [ i ] - co [ 1 ] [ j ] NEW_LINE if dx < 0 : NEW_LINE INDENT dx *= ( - 1 ) NEW_LINE DEDENT if dy < 0 : NEW_LINE INDENT dy *= ( - 1 ) NEW_LINE DEDENT if ( dx <= 1 and dy == 0 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( ' OK ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' BUG ' ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , math . sqrt ( n ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res *= ( 2 ** n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE for tc in range ( t ) : NEW_LINE INDENT n = int ( tc ) NEW_LINE print ( solve ( n ) ) NEW_LINE DEDENT sys . exit ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( sys . argv [ i ] ) NEW_LINE DEDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = gcd ( ans , a [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def test_b975 ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ the ▁ B975 ▁ algorithm . STRNEWLINE ▁ """ NEW_LINE a = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] , [ 10 , 11 , 12 ] ] ) NEW_LINE max = 0 NEW_LINE for i in range ( 14 ) : NEW_LINE INDENT a [ i ] = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] , [ 10 , 11 , 12 ] ] ) NEW_LINE DEDENT stones = a [ : : - 1 ] NEW_LINE remainder = stones / 14 NEW_LINE score = ( remainder % 2 == 0 ) NEW_LINE for i in range ( 1 , 14 ) : NEW_LINE INDENT count = a [ ( from + i ) % 14 ] + ( stones + 14 - i ) / 14 NEW_LINE if count % 2 == 0 : NEW_LINE INDENT score += count NEW_LINE DEDENT DEDENT max = max ( score ) NEW_LINE DEDENT
def GFG ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT
def GFG ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = float ( 1.73 * a ) NEW_LINE return d NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ GF ▁ algorithm . """ NEW_LINE data = ' helloABworldABGfG ' NEW_LINE if len ( data ) < 2 : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while j < len ( data ) - 1 : NEW_LINE INDENT if data [ j ] == ' A ' and data [ j + 1 ] == ' B ' : NEW_LINE INDENT j = j + 2 NEW_LINE data [ i ] = ' C ' NEW_LINE continue NEW_LINE DEDENT data [ i ] = data [ j ] NEW_LINE DEDENT if j == len ( data ) - 1 : NEW_LINE INDENT data [ i ] = data [ j ] NEW_LINE DEDENT data [ i ] = ' ▁ ' NEW_LINE data [ len ( data ) - 1 ] = ' ▁ ' NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT for i in range ( 1 , len ( str ( ' A ' ) ) ) : NEW_LINE INDENT if str [ i - 1 ] == ' A ' and str [ i ] == ' B ' : NEW_LINE INDENT str [ i - 1 ] = ' C ' NEW_LINE j = 0 NEW_LINE for j in range ( i , len ( str ) - 1 ) : NEW_LINE INDENT str [ j ] = str [ j + 1 ] NEW_LINE DEDENT str [ j ] = ' ▁ ' NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def p128 ( cls ) : NEW_LINE INDENT print ( cls . run ( ) ) NEW_LINE TARGET = 2000 NEW_LINE def run ( ) : NEW_LINE INDENT count = 2 NEW_LINE for ring in range ( 2 , 10 ) : NEW_LINE INDENT if ( long ( ring * 12 + 5 ) > sys . maxsize ) : NEW_LINE INDENT raise OverflowError NEW_LINE DEDENT if library . is_prime ( ring * 6 - 1 ) and library . is_prime ( ring * 6 + 1 ) and library . is_prime ( ring * 12 + 5 ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return long ( ring * ( ring - 1 ) * 3 + 2 ) NEW_LINE DEDENT DEDENT if library . is_prime ( ring * 6 - 1 ) and library . is_prime ( ring * 6 + 5 ) and library . is_prime ( ring * 12 - 7 ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return long ( ring * ( ring + 1 ) * 3 + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return run NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n , m = sys . argv [ 1 : ] NEW_LINE c = 0 NEW_LINE for i in range ( 0 , max ( n , m ) ) : NEW_LINE INDENT for j in range ( 0 , max ( n , m ) ) : NEW_LINE INDENT if ( i * i ) + j == n and i + ( j * j ) == m : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT sys . exit ( c ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 2346 NEW_LINE assert digits ( n ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert digits ( n / 10 ) == n NEW_LINE assert
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ symbolic ▁ representation ▁ of ▁ the ▁ GFG . """ NEW_LINE maxx = max ( [ d1 , max ( d2 , d3 ) for d1 , d2 , d3 in zip ( [ 1 , 2 , 3 ] , [ 4 , 5 ] ) ] ) NEW_LINE sum = ( d1 + d2 + d3 ) NEW_LINE if 2 * maxx > sum or sum % 2 == 1 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE return NEW_LINE DEDENT x1 , y1 = symbols ( ' x1 , y1 ' ) NEW_LINE x2 , y2 = symbols ( ' x2 , y2 ' ) NEW_LINE x3 , y3 = symbols ( ' x3 , y3 ' ) NEW_LINE print ( ' ( % s , ▁ % s ) , ▁ ( % s , ▁ % s ) ▁ and ▁ ( % s , ▁ % s ) ' % ( x1 , y1 , x2 , y2 , x3 , y3 ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE distributed_balls = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = [ str ( i ) - ' a ' for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if a [ i ] > k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
def lesson ( * args ) : NEW_LINE INDENT import sys NEW_LINE import time NEW_LINE import string NEW_LINE import datetime NEW_LINE import time NEW_LINE import doctest NEW_LINE import os NEW_LINE import re NEW_LINE import re NEW_LINE import sys NEW_LINE import string NEW_LINE import time NEW_LINE import doctest NEW_LINE import string NEW_LINE import re NEW_LINE import re NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string NEW_LINE import string
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE e = [ ] NEW_LINE i = 0 NEW_LINE p = 0 NEW_LINE k = 0 NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT e . append ( getopt . getopt ( sys . argv [ 1 : ] , " e : " ) [ 0 ] ) NEW_LINE DEDENT for i in range ( 12 ) : NEW_LINE INDENT for j in range ( 12 - i ) : NEW_LINE INDENT if e [ j ] < e [ j + 1 ] : NEW_LINE INDENT y = e [ j ] NEW_LINE e [ j ] = e [ j + 1 ] NEW_LINE e [ j + 1 ] = y NEW_LINE DEDENT DEDENT DEDENT for u in range ( 3 ) : NEW_LINE INDENT for k in range ( 4 ) : NEW_LINE INDENT i = u * 4 NEW_LINE if e [ i ] == e [ i + 1 ] and e [ i + 2 ] == e [ i + 3 ] and e [ i ] == e [ i + 2 ] and e [ i + 1 ] == e [ i + 3 ] and e [ i ] == e [ i + 3 ] and e [ i + 1 ] == e [ i + 2 ] : NEW_LINE INDENT p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 0 NEW_LINE DEDENT DEDENT DEDENT if p == 12 : NEW_LINE INDENT sys . stdout . write ( " yes \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( " no \n " ) NEW_LINE DEDENT DEDENT
def pyGFG ( arr , low , high ) : NEW_LINE INDENT R = 4 NEW_LINE C = 4 NEW_LINE first = 0 NEW_LINE if high >= low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid == 0 or arr [ mid - 1 ] == 0 ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] == 0 : NEW_LINE INDENT return first ( arr , ( mid + 1 , high ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return first ( arr , low , ( mid - 1 , low ) ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n , k = 10 , 2 NEW_LINE if bitAtGivenPosSetOrUnset ( n , k ) == 1 : NEW_LINE INDENT assert ' Set ' in str ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT assert ' Unset ' in str ( n ) NEW_LINE DEDENT DEDENT
def test_MammothsGenomeDecoding ( ) : NEW_LINE INDENT f = open ( ' data / MammothsGenomeDecoding . txt ' , ' r ' ) NEW_LINE n = int ( f . read ( ) ) NEW_LINE if n % 4 != 0 : NEW_LINE INDENT print ( ' = = = ' ) NEW_LINE return NEW_LINE DEDENT themost = n / 4 NEW_LINE numA = 0 NEW_LINE numG = 0 NEW_LINE numC = 0 NEW_LINE numT = 0 NEW_LINE numQM = 0 NEW_LINE lines = f . readlines ( ) NEW_LINE s = ' ' . join ( lines ) NEW_LINE for line in s : NEW_LINE INDENT if line . startswith ( ' A ' ) : NEW_LINE INDENT numA += 1 NEW_LINE DEDENT elif line . startswith ( ' G ' ) : NEW_LINE INDENT numG += 1 NEW_LINE DEDENT elif line . startswith ( ' C ' ) : NEW_LINE INDENT numC += 1 NEW_LINE DEDENT elif line . startswith ( ' T ' ) : NEW_LINE INDENT numT += 1 NEW_LINE DEDENT else : NEW_LINE INDENT numQM += 1 NEW_LINE DEDENT DEDENT if numA > themost or numC > themost or numG > themost or numT > themost : NEW_LINE INDENT print ( ' = = = ' ) NEW_LINE return NEW_LINE DEDENT for j in range ( numQM ) : NEW_LINE INDENT for i in range ( len ( lines ) ) : NEW_LINE INDENT if lines [ i ] . startswith ( ' ? ' ) : NEW_LINE INDENT if numA < themost : NEW_LINE INDENT lines [ i ] = lines [ i + 1 ] + ' A ' NEW_LINE numA += 1 NEW_LINE DEDENT elif numC < themost : NEW_LINE INDENT lines [ i ] = lines [ i + 1 ] + ' C ' ; NEW_LINE numC += 1 NEW_LINE DEDENT elif numG < themost : NEW_LINE INDENT lines [ i ] = lines [ i + 1 ] + ' G ' ; NEW_LINE numG += 1 NEW_LINE DEDENT elif numT < themost : NEW_LINE INDENT lines [ i ] = lines [ i + 1 ] + ' T ' ; NEW_LINE numT += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( s ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while 1 : NEW_LINE INDENT from sympy . core . compatibility import iterable NEW_LINE if not iterable : NEW_LINE INDENT break NEW_LINE DEDENT pos = [ 0 ] * 9 NEW_LINE DEDENT start = len ( sys . argv ) - 1 NEW_LINE end = len ( sys . argv ) - 1 NEW_LINE not start < end NEW_LINE pos [ start ] = 1 NEW_LINE next = [ ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT for i in range ( 9 ) : NEW_LINE INDENT next . append ( 0 ) NEW_LINE DEDENT for i in range ( 9 ) : NEW_LINE INDENT if i % 3 != 0 and not not i - 1 : NEW_LINE INDENT next [ - 1 ] += pos [ i ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next [ - 1 ] += pos [ i ] / 4 NEW_LINE DEDENT if i % 3 != 2 and not not i + 1 : NEW_LINE INDENT next [ - 1 ] += pos [ i ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next [ i ] += pos [ i ] / 4 NEW_LINE DEDENT if i / 3 != 0 and not not i - 3 : NEW_LINE INDENT next [ - 3 ] += pos [ i ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next [ i ] += pos [ i ] / 4 NEW_LINE DEDENT if i / 3 != 2 and not not i + 3 : NEW_LINE INDENT next [ - 3 ] += pos [ i ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next [ i ] += pos [ i ] / 4 NEW_LINE DEDENT if i / 3 != 2 and not not i + 3 : NEW_LINE INDENT next [ - 3 ] += pos [ i ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next [ i ] += pos [ i ] / 4 NEW_LINE DEDENT if i % 3 != 0 and not not i - 3 : NEW_LINE INDENT next [ - 3 ] += pos [ i ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next [ i ] += pos [ i ] / 4 NEW_LINE DEDENT if i % 3 != 2 and not not i + 3 : NEW_LINE INDENT next [ - 3 ] += pos [ i ] / 4 NEW_LINE DEDENT else : NEW_LINE INDENT next [ i ] += pos [ i ] / 4 NEW_LINE DEDENT DEDENT tmp = next NEW_LINE next = pos NEW_LINE pos = tmp NEW_LINE DEDENT print ( " % .8f " % pos [ end ] ) NEW_LINE DEDENT
def sol ( argc ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = ' Sol ▁ program ' ) NEW_LINE parser . add_argument ( ' - l ' , ' - - long ' , type = int , default = 1 , help = ' Number ▁ of ▁ long ▁ to ▁ run ' ) NEW_LINE parser . add_argument ( ' - r ' , ' - - radius ' , type = int , default = 1 , help = ' Number ▁ of ▁ radius ▁ to ▁ run ' ) NEW_LINE args = parser . parse_args ( argc ) NEW_LINE l = int ( args . long ) NEW_LINE r = int ( args . radius ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , r ) : NEW_LINE INDENT for j in range ( 1 , j * i <= r , 3 ) : NEW_LINE INDENT if i * j >= l : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE N = len ( sys . argv ) NEW_LINE K = len ( sys . argv ) NEW_LINE sys . argv = sys . argv + [ ' - N ' , ' - K ' , ' - K ' , ' - N ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K ' , ' - K '
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ if ▁ the ▁ generators ▁ are ▁ the ▁ same . """ NEW_LINE sum1 , sum2 , mul1 , mul2 = 0 , 0 , 1 , 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE mul1 *= a [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT sum2 += b [ i ] NEW_LINE mul2 *= b [ i ] NEW_LINE DEDENT return ( ( sum1 == sum2 ) , ( mul1 == mul2 ) ) NEW_LINE DEDENT
def GFG ( str1 , str2 ) : NEW_LINE INDENT MAX_CHAR = 26 NEW_LINE present = [ 0 ] * MAX_CHAR NEW_LINE l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT present [ str1 [ i ] - ' a ' ] = 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT if present [ str2 [ i ] - ' a ' ] == 1 or present [ str2 [ i ] - ' a ' ] == - 1 : NEW_LINE INDENT present [ str2 [ i ] - ' a ' ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT present [ str2 [ i ] - ' a ' ] = 2 NEW_LINE DEDENT DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if present [ i ] == 1 or present [ i ] == 2 : NEW_LINE INDENT print ( chr ( i + ' a ' ) + " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT if ( x - circle_x ) ** 2 + ( y - circle_y ) ** 2 <= rad ** 2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def GFG ( arr , n , x ) : NEW_LINE INDENT sum = 0 NEW_LINE largestDivisible , minimum = - 1 , arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if arr [ i ] % x == 0 and largestDivisible < arr [ i ] : NEW_LINE INDENT largestDivisible , arr [ i ] = arr [ i ] , arr [ i ] NEW_LINE DEDENT if arr [ i ] < minimum : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if largestDivisible == - 1 : NEW_LINE INDENT return sum NEW_LINE DEDENT sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) NEW_LINE return min ( sum , sumAfterOperation ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT nth = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT nth = 2 ** ( ( n * n ) - n ) NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( 2 ** n * n ) - n NEW_LINE DEDENT return nth NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT data = [ ] NEW_LINE iterator = iter ( data ) NEW_LINE scan = Scanner ( ) NEW_LINE n = scan . next ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cmd = scan . next ( ) NEW_LINE try : NEW_LINE INDENT iterator . append ( scan . next ( ) ) NEW_LINE iterator . previous ( ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT d = scan . next ( ) NEW_LINE if d : NEW_LINE INDENT for j in range ( d ) : NEW_LINE INDENT iterator . next ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( d ) : NEW_LINE INDENT iterator . previous ( ) NEW_LINE DEDENT DEDENT DEDENT except StopIteration : NEW_LINE INDENT iterator . next ( ) NEW_LINE iterator . previous ( ) NEW_LINE break NEW_LINE DEDENT DEDENT for i in data : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
def test_c1029_a ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE k = symbols ( ' k ' , integer = True , positive = True ) NEW_LINE s = symbols ( ' s ' , integer = True , positive = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ 0 ] == s [ - i ] : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT s = [ s [ - i ] for i in range ( k ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT s [ i ] = s [ ans ] NEW_LINE DEDENT assert s == ans NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT class Node : NEW_LINE INDENT data = 0 NEW_LINE left , right = None , None NEW_LINE DEDENT class INT : NEW_LINE INDENT a = 0 NEW_LINE def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " % s ▁ " % self . data NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return " % s ▁ " % self . data NEW_LINE DEDENT def __len__ ( self ) : NEW_LINE INDENT return len ( self . left ) NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT return len ( other . left ) <= len ( other . right ) NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT return len ( other . left ) >= len ( other . right ) NEW_LINE DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT return len ( self . left ) == len ( other . left ) NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT return len ( self . right ) != len ( other . right ) NEW_LINE DEDENT def __hash__ ( self ) : NEW_LINE INDENT return hash ( self . data ) NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT return len ( other . left ) <= len ( other . right ) NEW_LINE DEDENT def __gt__ ( self , other ) : NEW_LINE INDENT return len ( other . left ) > len ( other . right ) NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT return len ( self . left ) >= len ( other . right ) NEW_LINE DEDENT def __len__ ( self ) : NEW_LINE INDENT return len ( self . left ) NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT return len ( other . left ) <= len ( other . right ) NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT return len ( other . left ) >= len ( other . right ) NEW_LINE DEDENT DEDENT def con_binary_tree ( pre , pre_m , pre_index , l , h , size ) : NEW_LINE INDENT pre_index = [ 0 ] * size NEW_LINE pre_m = [ 0 ] * size NEW_LINE pre_index = [ 0 ] * size NEW_LINE pre_m = [ 0 ] * size NEW_LINE pre_index = [ 0 ] * size NEW_LINE pre_index = [ 0 ] * size NEW_LINE pre_m = [ 0 ] * size NEW_LINE pre_index = [ 0 ] * size NEW_LINE pre_index = [ 0 ] * size NEW_LINE return Node ( ) NEW_LINE DEDENT def test_con_binary_tree ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def GFG ( str , pat ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 ] * ( no_of_chars ) NEW_LINE hash_str = [ 0 ] * no_of_chars NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT hash_pat [ pat [ i ] ] += 1 NEW_LINE DEDENT start , start_index , min_len = 0 , int ( 0 ) NEW_LINE count = 0 NEW_LINE for j in range ( len1 ) : NEW_LINE INDENT hash_str [ str [ j ] ] += 1 NEW_LINE if hash_pat [ str [ j ] ] != 0 and hash_str [ str [ j ] ] <= hash_pat [ str [ j ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] or hash_pat [ str [ start ] ] == 0 : NEW_LINE INDENT if hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] : NEW_LINE INDENT hash_str [ str [ start ] ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if start_index == - 1 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT return str [ start_index : start_index + min_len ] NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT p = Point2 ( line [ 0 ] , line [ 1 ] ) NEW_LINE judge = False NEW_LINE if ( ccw ( p [ 0 ] , p [ 3 ] , p [ 1 ] ) > 0 and ccw ( p [ 1 ] , p [ 3 ] , p [ 2 ] ) > 0 and ccw ( p [ 2 ] , p [ 3 ] , p [ 0 ] ) > 0 ) : NEW_LINE INDENT judge = True NEW_LINE DEDENT print ( judge and " YES " or " NO " ) NEW_LINE DEDENT class Point2 : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE DEDENT def ccw ( p1 , p2 , p3 ) : NEW_LINE INDENT return ( p2 [ 1 ] - p1 [ 1 ] ) * ( p3 [ 0 ] - p1 [ 0 ] ) - ( p3 [ 1 ] - p1 [ 1 ] ) * ( p2 [ 0 ] - p1 [ 0 ] ) NEW_LINE DEDENT class Point2 ( Point2 ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE DEDENT def ccw ( p1 , p2 , p3 ) : NEW_LINE INDENT return ( p2 [ 1 ] - p1 [ 1 ] ) * ( p3 [ 0 ] - p1 [ 0 ] ) - ( p3 [ 1 ] - p1 [ 1 ] ) * ( p2 [ 0 ] - p1 [ 0 ] ) NEW_LINE DEDENT def ccw ( p1 , p2 , p3 ) : NEW_LINE INDENT return ( p3 [ 0 ] - p1 [ 0 ] ) * ( p2 [ 1 ] - p1 [ 1 ] ) NEW_LINE DEDENT def ccw ( p1 , p2 , p3 ) : NEW_LINE INDENT return ( p3 [ 0 ] - p1 [ 0 ] ) * ( p2 [ 1 ] - p1 [ 1 ] ) NEW_LINE DEDENT def ccw ( p1 , p2 , p3 ) : NEW_LINE INDENT return ( p3 [ 0 ] - p1 [ 0 ] ) * ( p2 [ 1 ] - p1 [ 1 ] ) NEW_LINE DEDENT DEDENT
def PolandBoardAndGame ( ) : NEW_LINE INDENT import sys NEW_LINE n , m = sys . argv [ 1 : ] NEW_LINE if n > m : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT elif m > n : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT dem = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if d . has_key ( i ) : NEW_LINE INDENT dem += 1 NEW_LINE DEDENT DEDENT if dem % 2 == 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX = 100005 NEW_LINE v = add_primes ( ) NEW_LINE prime = [ True for p in range ( 2 , n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def py_small_science ( ) : NEW_LINE INDENT import numpy as np NEW_LINE science = [ ] NEW_LINE minsc = 100 NEW_LINE sumsc = 0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT science . append ( np . random . randint ( minsc , size = science [ i ] ) ) NEW_LINE minsc = min ( minsc , science [ i ] ) NEW_LINE sumsc += science [ i ] NEW_LINE DEDENT sumsc -= minsc NEW_LINE sumso = np . zeros ( science [ 0 ] ) NEW_LINE x = np . arange ( science [ 0 ] ) NEW_LINE if sumso < x : NEW_LINE INDENT sumso = x NEW_LINE DEDENT return sumsc , sumso NEW_LINE DEDENT
def test_bear_and_game1 ( ) : NEW_LINE INDENT sc = InputReader ( sys . stdin ) NEW_LINE n = sc . read ( ) NEW_LINE array = [ sc . read ( ) for i in range ( 100 ) ] NEW_LINE flag = 15 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if array [ i ] <= flag : NEW_LINE INDENT flag = array [ i ] + 15 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT result = min ( flag , 90 ) NEW_LINE fileobj = sys . stdout NEW_LINE out = sys . stdout NEW_LINE out . write ( result ) NEW_LINE out . close ( ) NEW_LINE DEDENT
def genGFG ( index , evenSum , oddSum , tight ) : NEW_LINE INDENT v = [ ] NEW_LINE dp = [ 18 , 180 , 180 , 2 ] NEW_LINE memo = [ 0 , 0 , 0 , 1 ] NEW_LINE if index in v : NEW_LINE INDENT if evenSum > oddSum : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if dp [ index ] [ evenSum ] [ oddSum ] [ tight ] != - 1 : NEW_LINE INDENT return dp [ index ] [ evenSum ] [ oddSum ] [ tight ] NEW_LINE DEDENT limit = ( tight or 0 ) NEW_LINE ans = 0 NEW_LINE for d in range ( 0 , limit ) : NEW_LINE INDENT currTight = 0 NEW_LINE if d == v [ index ] : NEW_LINE INDENT currTight = tight NEW_LINE DEDENT if d % 2 != 0 : NEW_LINE INDENT ans += memo [ index + 1 , evenSum , oddSum + d , currTight ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += memo [ index + 1 , evenSum + d , oddSum , currTight ] NEW_LINE DEDENT DEDENT dp [ index ] [ evenSum ] [ oddSum ] [ tight ] = ans NEW_LINE return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s = sys . stdin . read ( ) NEW_LINE c = [ ] NEW_LINE b = True NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT c . append ( i ) NEW_LINE DEDENT DEDENT loop : NEW_LINE INDENT for i in range ( 2 ) : NEW_LINE INDENT for j in range ( i + 1 , 3 ) : NEW_LINE INDENT if c [ i ] [ 0 ] - c [ j ] [ 0 ] == c [ i ] [ 1 ] - c [ j ] [ 1 ] and c [ i ] [ 1 ] - c [ j ] [ 1 ] == c [ i ] [ 2 ] - c [ j ] [ 2 ] : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT b = False NEW_LINE break loop NEW_LINE DEDENT DEDENT DEDENT loop : NEW_LINE INDENT for i in range ( 2 ) : NEW_LINE INDENT for j in range ( i + 1 , 3 ) : NEW_LINE INDENT if c [ 0 ] [ i ] - c [ 0 ] [ j ] == c [ 1 ] [ i ] - c [ 1 ] [ j ] and c [ 1 ] [ i ] - c [ 1 ] [ j ] == c [ 2 ] [ i ] - c [ 2 ] [ j ] : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT b = False NEW_LINE break loop NEW_LINE DEDENT DEDENT DEDENT if b : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE t = sys . argv [ 1 ] NEW_LINE while t : NEW_LINE INDENT n = t . pop ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT flag = True NEW_LINE b . append ( a ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] != 0 and b [ i - 1 ] - a [ i ] >= 0 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = b [ i - 1 ] + a [ i ] NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT sys . stdout . write ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sys . stdout . write ( b [ i ] + " ▁ " ) NEW_LINE DEDENT sys . stdout . write ( " \n " ) NEW_LINE DEDENT DEDENT sys . stdout . flush ( ) NEW_LINE DEDENT
def p218 ( cls ) : NEW_LINE INDENT return cls ( ) NEW_LINE DEDENT
def GFG ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE input = sys . argv [ 1 : ] NEW_LINE n = int ( input [ 0 ] ) NEW_LINE c = long ( input [ 1 ] ) NEW_LINE forward_max = [ ] NEW_LINE backwards_max = [ ] NEW_LINE positions = [ ] NEW_LINE values = [ ] NEW_LINE positions . append ( 0 ) NEW_LINE values . append ( 0 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT input = sys . stdin . readline ( ) NEW_LINE positions . append ( int ( input [ 0 ] ) ) NEW_LINE values . append ( int ( input [ 1 ] ) ) NEW_LINE DEDENT max = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum += values [ i ] NEW_LINE max = max + sum - positions [ i ] NEW_LINE forward_max . append ( max ) NEW_LINE DEDENT max = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT sum += values [ i ] NEW_LINE max = max + sum - ( c - positions [ i ] ) NEW_LINE backwards_max . append ( max ) NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT res = max ( res , forward_max [ i ] ) NEW_LINE if i != n : NEW_LINE INDENT res = max ( res , forward_max [ i ] - ( positions [ i ] ) + backwards_max [ i + 1 ] ) NEW_LINE DEDENT res = max ( res , backwards_max [ i ] ) NEW_LINE if i != 0 : NEW_LINE INDENT res = max ( res , backwards_max [ i ] - ( c - positions [ i ] ) + forwards_max [ i - 1 ] ) NEW_LINE DEDENT DEDENT sys . stdout . write ( res ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 42 NEW_LINE l , r = 2 , 5 NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n & num ) == ( n & num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE assert ( n ^ num ) == ( n ^ num ) NEW_LINE DEDENT
def GFG ( a , n ) : NEW_LINE INDENT positive , negative , zero = 0 , 0 , 0 NEW_LINE step = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT elif a [ i ] < 0 : NEW_LINE INDENT negative += 1 NEW_LINE step = step + ( - 1 - a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT positive += 1 NEW_LINE step = step + ( a [ i ] - 1 ) NEW_LINE DEDENT DEDENT if negative % 2 == 0 : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT if zero > 0 : NEW_LINE INDENT step = step + zero NEW_LINE DEDENT else : NEW_LINE INDENT step = step + 2 NEW_LINE DEDENT DEDENT return step NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE number , start , end = sys . argv [ 1 : ] NEW_LINE arr = [ ] NEW_LINE str = sys . stdin . readline ( ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT arr . append ( str [ i ] - '0' ) NEW_LINE DEDENT if arr [ start ] == arr [ end ] : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ start ] - arr [ end ] ) ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE while t : NEW_LINE INDENT n = len ( sys . argv ) NEW_LINE num = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num . append ( sys . argv [ i ] ) NEW_LINE DEDENT num . sort ( ) NEW_LINE print ( num [ - 1 ] + num [ - 2 ] ) NEW_LINE DEDENT DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return __gcd ( b , a % b ) NEW_LINE DEDENT
def GFG ( s , a ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] - '0' < a [ s [ i ] - '0' ] : NEW_LINE INDENT j = i NEW_LINE while j < n and ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) : NEW_LINE INDENT s [ j ] = chr ( ord ( '0' ) + a [ s [ j ] - '0' ] ) NEW_LINE j += 1 NEW_LINE DEDENT return str ( s ) NEW_LINE DEDENT DEDENT return str ( s ) NEW_LINE DEDENT
def get_GFG ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE n = int ( n ) NEW_LINE return n NEW_LINE
def main ( ) : NEW_LINE INDENT import sys NEW_LINE x , y = 0 , 0 NEW_LINE t = 0 NEW_LINE n = len ( sys . argv ) NEW_LINE str = sys . argv [ 1 ] NEW_LINE l = [ ] NEW_LINE l . append ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] != '4' and l [ i ] != '7' : t = 1 NEW_LINE DEDENT if t == 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n // 2 ) : x = x + ord ( l [ i ] ) NEW_LINE for i in range ( n - 1 , ( n // 2 ) - 1 ) : y = y + ord ( l [ i ] ) NEW_LINE if x == y : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE mid_value = arr [ mid ] NEW_LINE if mid == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT leftindex = min ( mid - 1 , mid_value ) NEW_LINE left = binarySearch ( arr , low , leftindex ) NEW_LINE if left >= 0 : NEW_LINE INDENT return left NEW_LINE DEDENT rightindex = max ( mid + 1 , mid_value ) NEW_LINE right = binarySearch ( arr , rightindex , high ) NEW_LINE return right NEW_LINE DEDENT
def get_GFG ( n ) : NEW_LINE INDENT MAX = 10000 NEW_LINE prodDig = [ 0 ] * MAX NEW_LINE def get_digit_product ( x ) : NEW_LINE INDENT if x < 10 : NEW_LINE INDENT return x NEW_LINE DEDENT if prodDig [ x ] != 0 : NEW_LINE INDENT return prodDig [ x ] NEW_LINE DEDENT prod = ( x % 10 ) * get_digit_product ( x / 10 ) NEW_LINE return ( prodDig [ x ] , prod ) NEW_LINE DEDENT def find_seed ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , n // 2 ) : NEW_LINE INDENT if i * get_digit_product ( i ) == n : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT if len ( res ) == 0 : NEW_LINE INDENT print ( " NO ▁ seed ▁ exists " ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT def find_seed ( n ) : NEW_LINE INDENT n = 138 NEW_LINE find_seed ( n ) NEW_LINE DEDENT return ( find_seed ( n ) , find_seed ( n ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT f = open ( ' . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . /
def pythagen_poly ( n , mid ) : NEW_LINE INDENT if n > ( mid ** 2 ) : NEW_LINE INDENT return ( n - ( mid ** 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( mid ** 2 ) - n ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n , m = sys . argv [ 1 ] , sys . argv [ 2 ] NEW_LINE a = range ( 105 ) NEW_LINE max = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT a [ i ] = a [ i ] NEW_LINE if i > 0 and a [ i ] > a [ max ] : max = i NEW_LINE DEDENT ansmax = a [ max ] + m NEW_LINE for i in range ( 0 , m - 1 ) : NEW_LINE INDENT min = 0 NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT if j > 0 and a [ j ] < a [ min ] : min = j NEW_LINE DEDENT a [ min ] += 1 NEW_LINE DEDENT max = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ max ] : max = i NEW_LINE DEDENT ansmin = a [ max ] NEW_LINE print ( ansmin , ansmax ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT m0 , t , q = symbols ( ' m0 , t , q ' , integer = True ) NEW_LINE x0 , x1 = 0 , 1 NEW_LINE if m == 1 : NEW_LINE INDENT return x0 , x1 NEW_LINE DEDENT while a > 1 : NEW_LINE INDENT q , t , m = a // m , a % m , a % m NEW_LINE a , t , x0 = t , x0 - q * x0 , t NEW_LINE x1 , x0 = x0 , x1 - q * x0 NEW_LINE DEDENT if x1 < 0 : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 , x0 NEW_LINE DEDENT
def import ( arrgs ) : NEW_LINE INDENT import sys NEW_LINE import re NEW_LINE class solution : NEW_LINE INDENT compare = lambda a , b : a > b NEW_LINE def find_max_OR ( arr , n ) : NEW_LINE INDENT temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , temp NEW_LINE DEDENT DEDENT DEDENT max_OR = arr [ 0 ] NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( max_OR | arr [ i ] ) > max_OR : NEW_LINE INDENT max_OR = max_OR | arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 ] , n , ZZ ) == 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 12 NEW_LINE assert aliquot_sum ( n ) == 0 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ pentagon ▁ pyramidal ▁ algorithm . """ NEW_LINE n = 4 NEW_LINE assert len ( pentagon_pyramidal ( n ) ) == n NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 6 NEW_LINE assert fifth_power_sum ( n ) == 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 4 NEW_LINE assert squaresum ( n ) == n NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 ] , n , ZZ ) == 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 10 NEW_LINE assert sum_of_series ( n ) == n NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def test_gf_gf_sum ( ) : NEW_LINE INDENT assert gf_gf_sum ( [ ] , 11 , ZZ ) == [ ] NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == [ 1 ] NEW_LINE assert gf_gf_sum ( [ 1 , 2 , 3 ] , 11 , ZZ ) == [ 1 , 2 , 3 ] NEW_LINE assert gf_gf_sum ( [ 1 , 2 , 3 ] , 11 , ZZ ) == [ 1 , 2 , 3 ] NEW_LINE assert gf_gf_sum ( [ 1 , 2 , 3 ] , 11 , ZZ ) == [ 1 , 2 , 3 ] NEW_LINE assert gf_gf_sum ( [ 1 , 2 , 3 ] , 11 , ZZ ) == [ 1 , 2 , 3 ] NEW_LINE assert gf_gf_sum ( [ 1 , 2 , 3 ] , 11 , ZZ ) == [ 1 , 2 , 3 ] NEW_LINE assert gf_gf_sum ( [ 1 , 2 , 3 ] , 11 , ZZ ) == [ 1 , 2 , 3 ] NEW_LINE assert gf_gf_sum ( [ 1 , 2 , 3 ] , 11 , ZZ ) == [ 1 , 2 , 3 ] NEW_LINE assert gf_gf_sum ( [ 1 , 2 , 3 ] , 11 , ZZ ) == [ 1 , 2 , 3 ] NEW_LINE assert gf_gf_sum ( [ 1 , 2 , 3 ] , 11 , ZZ ) == [ 1 , 2 , 3 ] NEW_LINE assert gf_gf_sum ( [ 1 , 2 , 3 ] , 11 , ZZ ) == [ 1 , 2 , 3 ] NEW_LINE assert gf_gf_sum ( [ 1 , 2 ,
def test_GFG ( ) : NEW_LINE INDENT assert squaresum ( 8 ) == 8 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 2 NEW_LINE assert AvgofSquareN ( n ) == n NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 3 NEW_LINE assert find_sum ( n ) == 2 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ leading ▁ zeros ▁ in ▁ a ▁ GFG . """ NEW_LINE n = 8 NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n ) == [ 1 ] NEW_LINE assert solve ( n )
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - d ' : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT f = True NEW_LINE for j in range ( len ( p ) ) : NEW_LINE INDENT f &= i % p [ j ] != 0 NEW_LINE if not f : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT p . append ( i ) NEW_LINE DEDENT DEDENT DEDENT while True : NEW_LINE INDENT n = input ( ) . split ( ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += p [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT sys . exit ( 0 ) NEW_LINE DEDENT def debug ( * os ) : NEW_LINE INDENT sys . stderr . write ( ' % s \n ' % ' ▁ ' . join ( map ( str , os ) ) ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT assert int ( f_g ( 4 ) ) == 4 NEW_LINE assert int ( f_g ( 15 ) ) == 15 NEW_LINE DEDENT
def Optimal_BST2 ( keys , freq , n ) : NEW_LINE INDENT cost = [ 0 ] * n + [ 0 ] * n + [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT cost [ i ] [ i ] = freq [ i ] NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 0 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE cost [ i ] [ j ] = sys . maxsize NEW_LINE for r in range ( i , j + 1 ) : NEW_LINE INDENT c = ( ( r > i ) and cost [ i ] [ r - 1 ] or 0 ) + ( ( r < j ) and cost [ r + 1 ] [ j ] or 0 ) + sum ( freq , i , j ) NEW_LINE if c < cost [ i ] [ j ] : NEW_LINE INDENT cost [ i ] [ j ] = c NEW_LINE DEDENT DEDENT DEDENT DEDENT return cost [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def GFG ( x , y , z ) : NEW_LINE INDENT if x > z : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) / y NEW_LINE ans = div * y + x NEW_LINE return ans NEW_LINE DEDENT
def code_forces ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle . dump NEW_LINE BUFFERSIZE = 512000 NEW_LINE def solve ( ) : NEW_LINE INDENT n = len ( sys . argv ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ sys . argv [ i ] ] = i NEW_LINE DEDENT last_loc = d [ 1 ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT new_loc = d [ i ] NEW_LINE ans += abs ( last_loc - new_loc ) NEW_LINE last_loc = new_loc NEW_LINE DEDENT sys . stdout . write ( ans ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT in . init ( sys . stdin ) NEW_LINE solve ( ) NEW_LINE out . close ( ) NEW_LINE DEDENT class in : NEW_LINE INDENT def __init__ ( self , input ) : NEW_LINE INDENT self . input = input NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . input . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . input . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . input . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . input . readline ( ) NEW_LINE DEDENT DEDENT def next ( self ) : NEW_LINE INDENT while not self . input . done ( ) : NEW_LINE INDENT self . input . readline ( ) NEW_LINE DEDENT return self . input . readline ( ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return sys . stdin . readline ( ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return sys . stdin . readline ( ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT return sys . stdin . readline ( ) NEW_LINE DEDENT DEDENT
def genomial_coeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( n + 1 ) + [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) + 1 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT
def GFG ( ch ) : NEW_LINE INDENT try : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT return None NEW_LINE DEDENT vowelPairs = [ ] NEW_LINE for i in range ( len ( ch ) - 1 ) : NEW_LINE INDENT if isVowel ( ch [ i ] ) and isVowel ( ch [ i + 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT scn = getopt . getopt ( sys . argv [ 1 : ] , ' w ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( msg + ' \n ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' w ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' h ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' ? ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' - ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' - - ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' - - ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' - - ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' - - ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' - - ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' - - ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' - - ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' - - ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' - - ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' - - ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if scn == ' - - ' : NEW_LINE INDENT sys . stdout . write ( ' ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT sys . exit ( 1 ) NEW_LINE DEDENT
def GFG ( s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE for i in range ( 0 , N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if s2 [ i + j ] != s1 [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == M : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT angle = 65 NEW_LINE z = angle_oncircumference ( angle ) NEW_LINE assert z == angle NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ subarrays ▁ of ▁ 0 ▁ only . """ NEW_LINE count1 , count0 = 0 , 0 NEW_LINE number1 , number0 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number1 += ( count1 ) * ( count1 + 1 ) / 2 NEW_LINE count1 = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number0 += ( count0 ) * ( count0 + 1 ) / 2 NEW_LINE count0 = 0 NEW_LINE DEDENT DEDENT if count1 : NEW_LINE INDENT number1 += ( count1 ) * ( count1 + 1 ) / 2 NEW_LINE DEDENT if count0 : NEW_LINE INDENT number0 += ( count0 ) * ( count0 + 1 ) / 2 NEW_LINE DEDENT print ( " Count ▁ of ▁ subarrays ▁ of ▁ 0 ▁ only : ▁ " , number0 ) NEW_LINE print ( " \n Count ▁ of ▁ subarrays ▁ of ▁ 1 ▁ only : ▁ " , number1 ) NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE x = N NEW_LINE if N > 0 : NEW_LINE INDENT while x > 0 and flag == 1 : NEW_LINE INDENT digit = x % 10 NEW_LINE if digit != 1 and digit != 3 : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT x = x / 10 NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE DEDENT return NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT i , mx = symbols ( ' i ▁ mx ' , integer = True , cls = Dummy ) NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT assert mx == i NEW_LINE mx -= 1 NEW_LINE DEDENT for i in range ( 1 , mx ) : NEW_LINE INDENT assert i == mx NEW_LINE DEDENT DEDENT
def the_rank ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ rank ▁ of ▁ the ▁ rank ▁ of ▁ the ▁ matrix . STRNEWLINE ▁ """ NEW_LINE n = len ( np . arange ( 0 , n + 1 ) ) NEW_LINE ans = 0 NEW_LINE rank = 1 NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = np . arange ( 0 , n + 1 ) NEW_LINE b = np . arange ( 0 , n + 1 ) NEW_LINE c = np . arange ( 0 , n + 1 ) NEW_LINE d = np . arange ( 0 , n + 1 ) NEW_LINE sum = a + b + c + d NEW_LINE arr . append ( sum ) NEW_LINE DEDENT for j in arr : NEW_LINE INDENT if arr [ 0 ] < j : NEW_LINE INDENT rank += 1 NEW_LINE DEDENT DEDENT print ( rank ) NEW_LINE return ans NEW_LINE DEDENT
def get_GFG ( s1 , s2 ) : NEW_LINE INDENT mp = { } NEW_LINE for c in s1 : NEW_LINE INDENT mp [ c ] = mp [ c ] if c in mp else 1 NEW_LINE DEDENT for c in s2 : NEW_LINE INDENT if mp [ c ] > 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def test_practice ( ) : NEW_LINE INDENT x = Symbol ( ' x ' ) NEW_LINE t = Symbol ( ' t ' , integer = True ) NEW_LINE while t . is_integer is True : NEW_LINE INDENT n = Symbol ( ' n ' , integer = True ) NEW_LINE a = Symbol ( ' a ' , integer = True ) NEW_LINE b = Symbol ( ' b ' , integer = True ) NEW_LINE c = Symbol ( ' c ' , integer = True ) NEW_LINE d = Symbol ( ' d ' , integer = True ) NEW_LINE flag = False NEW_LINE k = n * ( a - b ) NEW_LINE m = n * ( a + b ) NEW_LINE if k > ( c + d ) or m < ( c - d ) : NEW_LINE INDENT assert False NEW_LINE DEDENT else : NEW_LINE INDENT assert True NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE assert len ( arr ) == n NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT assert arr [ i ] == arr [ i ] NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT N = 3 NEW_LINE max_path_sum = [ 0 , 0 , 0 ] NEW_LINE for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , ( n - 2 ) // 2 ) : NEW_LINE INDENT if arr [ 2 * i + 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT if 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def GFG ( arr , i , n ) : NEW_LINE INDENT if i > ( n - 2 ) / 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and is_heap ( arr , 2 * i + 1 , n ) and is_heap ( arr , 2 * i + 2 , n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global ax , ay , bx , by , cx , cy NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , " ax : ay : bx : by : cx : cy " ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - a ' : NEW_LINE INDENT ax = a NEW_LINE DEDENT if o == ' - x ' : NEW_LINE INDENT bx = a NEW_LINE DEDENT if o == ' - y ' : NEW_LINE INDENT by = a NEW_LINE DEDENT if o == ' - c ' : NEW_LINE INDENT cx = a NEW_LINE DEDENT if o == ' - r ' : NEW_LINE INDENT cy = a NEW_LINE DEDENT DEDENT if args and not args [ 0 ] : NEW_LINE INDENT print ( " Usage : " , sys . argv [ 0 ] , " - a ▁ [ ax ] ▁ [ ay ] ▁ [ bx | by | cx ] " ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if not args : NEW_LINE INDENT ax = bx NEW_LINE ay = by NEW_LINE DEDENT if not args : NEW_LINE INDENT cx = cy NEW_LINE bx = by NEW_LINE by = cx NEW_LINE cx = cy NEW_LINE DEDENT print ( ( ( bx - ax ) * ( cy - ay ) == ( cx - ax ) * ( by - ay ) ) or ( ( ax - bx ) * ( ax - bx ) + ( ay - by ) * ( ay - by ) != ( cx - bx ) * ( cx - bx ) + ( cy - by ) * ( cy - by ) ) ) and ( ( ax - bx ) * ( ax - bx ) + ( ay - by ) * ( ay - by ) ) ) and ( ( cx - bx ) * ( cx - bx ) + ( cy - by ) * ( cy - by ) ) ) and ( ( bx - by ) * ( bx - by ) + ( cx - bx ) ) and ( ( cy - by ) * ( cy - by ) + ( bx - by ) ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT min_num = int ( arr [ 0 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == min_num : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return n - cnt NEW_LINE DEDENT
def py2k ( x , y ) : NEW_LINE INDENT ans = 0 NEW_LINE m = { } NEW_LINE while x % y != 0 : NEW_LINE INDENT x , y = divmod ( x , y ) NEW_LINE ans += 1 NEW_LINE if m . has_key ( x ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT m [ x ] = 1 NEW_LINE x = x * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT remainder = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 NEW_LINE DEDENT return ( remainder , arr [ n ] ) NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT N , K = sys . argv [ 1 : ] NEW_LINE DEDENT except : NEW_LINE INDENT sys . exit ( " Usage : ▁ import ▁ < N > ▁ < K > " ) NEW_LINE DEDENT ans = 0 NEW_LINE vec = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT vec . append ( [ 0 ] * N ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT a = sys . argv [ 2 ] - 1 NEW_LINE if i != 0 : NEW_LINE INDENT vec [ a ] . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT if a != 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT dfs ( 0 , 0 ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def class Test ( ) : NEW_LINE INDENT for a , b in itertools . combinations ( range ( a , b + 1 ) , 2 ) : NEW_LINE INDENT for j in range ( 1 , j ** 2 ) : NEW_LINE INDENT if j ** 2 * j == i : NEW_LINE INDENT print ( j ** 2 * j + 1 , end = ' ▁ ▁ ' ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 6 NEW_LINE d = 4 NEW_LINE assert n == 1 NEW_LINE assert d == 1 NEW_LINE DEDENT
def test_pre598 ( ) : NEW_LINE INDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastReader ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT class FastWriter ( object ) : NEW_LINE INDENT f = StringIO ( ) NEW_LINE DEDENT DEDENT assert FastReader ( ) . f == FastReader ( ) . f NEW_LINE DEDENT
def test_code_force ( ) : NEW_LINE INDENT f = BytesIO ( ) NEW_LINE s = f . getvalue ( ) NEW_LINE sr = re . compile ( r ' ( ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) \ . ( [ a - z ] + ) ' ) NEW_LINE assert s == sr NEW_LINE DEDENT
def GFG ( x ) : NEW_LINE INDENT cr = int ( math . cbrt ( x ) ) NEW_LINE return ( cr * cr * cr == x ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = int ( sys . argv [ 1 ] ) NEW_LINE s = sys . stdin . readline ( ) NEW_LINE t = sys . stdin . readline ( ) NEW_LINE sys . stdin . close ( ) NEW_LINE result = 2 ** n NEW_LINE for i in range ( n ) : NEW_LINE INDENT foot = t [ : n - i ] NEW_LINE if s . endswith ( foot ) : NEW_LINE INDENT result -= len ( foot ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def graph ( v ) : NEW_LINE INDENT import sys NEW_LINE import networkx NEW_LINE class Graph ( networkx . Graph ) : NEW_LINE INDENT V = None NEW_LINE adj = [ ] NEW_LINE def __init__ ( self , v ) : NEW_LINE INDENT self . V = v NEW_LINE self . adj = [ ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj . append ( w ) NEW_LINE DEDENT def DFSUtil ( self , v , visited = False ) : NEW_LINE INDENT visited [ v ] = True NEW_LINE print ( v , end = ' ▁ ' ) NEW_LINE i = self . adj [ v ] NEW_LINE for n in i : NEW_LINE INDENT if not visited [ n ] : NEW_LINE INDENT DFSUtil ( n , visited ) NEW_LINE DEDENT DEDENT DEDENT def DFS ( self ) : NEW_LINE INDENT visited = [ False ] * V NEW_LINE DFSUtil ( self ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT g = Graph ( 4 ) NEW_LINE g . addEdge ( 0 , 1 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . addEdge ( 1 , 2 ) NEW_LINE g . addEdge ( 2 , 0 ) NEW_LINE g . addEdge ( 2 , 3 ) NEW_LINE g . addEdge ( 3 , 3 ) NEW_LINE print ( ' Following ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) ' ) NEW_LINE g . DFS ( 2 ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT import numpy as np NEW_LINE import random NEW_LINE import math NEW_LINE from genmsg . msg_loader import MsgNotFound NEW_LINE from genmsg . msg_parser import MsgContext NEW_LINE msg_context = MsgContext . create_default ( ) NEW_LINE x = np . random . random ( ( 10 , 10 ) ) NEW_LINE arr = np . random . random ( ( 10 , 10 ) ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT val = math . pow ( float ( x ) , float ( i ) ) NEW_LINE msg_context . set_float ( ' val ' , val ) NEW_LINE DEDENT for i in range ( 0 , 9 ) : NEW_LINE INDENT print ( ' % d ▁ ' % i ) NEW_LINE DEDENT DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE import os NEW_LINE import pickle NEW_LINE import math NEW_LINE import os . path NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE import pickle NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( sys . argv [ i ] ) NEW_LINE print ( max_left ( n ) ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE hs = set ( ) NEW_LINE a = sys . argv [ 1 ] NEW_LINE for i in a : NEW_LINE INDENT hs . add ( i ) NEW_LINE DEDENT b = sys . argv [ 2 ] NEW_LINE for i in b : NEW_LINE INDENT hs . add ( i ) NEW_LINE DEDENT if len ( hs ) == n : NEW_LINE INDENT print ( " I ▁ become ▁ the ▁ guy . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Oh , ▁ my ▁ keyboard ! " ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT m , n = 6 , 4 NEW_LINE linear_check ( ar , m ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT matched = True NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ar [ i ] [ j ] != arr [ j ] : NEW_LINE INDENT matched = False NEW_LINE break NEW_LINE DEDENT DEDENT if matched : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT
def test_candy_and_friend ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' ) NEW_LINE while t : NEW_LINE INDENT n = symbols ( ' n ' ) NEW_LINE a = [ ] NEW_LINE sum , count = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( i ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT if sum % n == 0 : NEW_LINE INDENT div = sum / n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > div : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT assert count == 1 NEW_LINE DEDENT else : NEW_LINE INDENT assert - 1 == count NEW_LINE DEDENT t = t . subs ( n , 1 ) NEW_LINE DEDENT DEDENT
def test_main ( ) : NEW_LINE INDENT """ Test ▁ the ▁ main ▁ function . """ NEW_LINE main = partial ( solve , N = N ) NEW_LINE def solve_d ( ) : NEW_LINE INDENT t = np . linspace ( 0 , 1 , N ) NEW_LINE sum_t = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT t [ i ] = np . random . randint ( 0 , 1 , N ) * 2 NEW_LINE sum_t += t [ i ] NEW_LINE DEDENT v = np . random . randint ( 0 , 1 , N ) * 2 NEW_LINE tmp_v = np . random . randint ( 0 , 1 , N ) * 2 NEW_LINE tmp_t = 0 NEW_LINE max_v = np . zeros ( sum_t + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT max_v [ tmp_t ] = v [ i ] < tmp_v [ i ] NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE for t_ind in range ( t [ i ] ) : NEW_LINE INDENT max_v [ ++ tmp_t ] = v [ i ] < tmp_v [ i + 1 ] NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE DEDENT DEDENT tmp_v = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT max_v [ tmp_t ] = v [ i ] < tmp_v [ i ] NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE for t_ind in range ( t [ i ] ) : NEW_LINE INDENT back_v = v [ i ] < tmp_v [ i + 1 ] NEW_LINE del tmp_t NEW_LINE max_v [ tmp_t ] = max_v [ tmp_t ] < back_v [ tmp_t ] NEW_LINE tmp_v = max_v [ tmp_t ] NEW_LINE DEDENT DEDENT answer = 0 NEW_LINE for i in range ( sum_t ) : NEW_LINE INDENT answer += ( max_v [ i ] + max_v [ i + 1 ] ) NEW_LINE DEDENT assert_almost_equal ( answer * 0.125 , 1.25 ) NEW_LINE DEDENT
def import ( n ) : NEW_LINE INDENT import numpy as np NEW_LINE class solution : NEW_LINE INDENT def nth_term ( n ) : NEW_LINE INDENT return 2 ** int ( np . power ( n , 2 ) ) + 4 * n - 2 NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 4 NEW_LINE return np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 ] ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def import ( n ) : NEW_LINE INDENT import numpy as np NEW_LINE class solution : NEW_LINE INDENT def nth_term ( n ) : NEW_LINE INDENT return 7 * int ( np . power ( n , 2 ) ) - 7 * n + 7 NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 4 NEW_LINE return np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 ] ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def import ( n ) : NEW_LINE INDENT import numpy as np NEW_LINE class solution : NEW_LINE INDENT def nth_term ( n ) : NEW_LINE INDENT return 5 * int ( np . power ( n , 2 ) ) - 5 * n NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nth_term ( N ) ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def import ( n ) : NEW_LINE INDENT import numpy as np NEW_LINE class solution : NEW_LINE INDENT def nth_term ( n ) : NEW_LINE INDENT return int ( math . pow ( n , 2 ) ) + 2 * n + 2 NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nth_term ( N ) ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def pythterm ( n ) : NEW_LINE INDENT import math NEW_LINE class solution : NEW_LINE INDENT def nthterm ( n ) : NEW_LINE INDENT return 2 ** int ( math . pow ( n , 3 ) ) + int ( math . pow ( n , 2 ) ) NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 3 NEW_LINE print ( nthterm ( N ) ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def import ( n ) : NEW_LINE INDENT import numpy as np NEW_LINE class solution : NEW_LINE INDENT def nth_term ( n ) : NEW_LINE INDENT return 2 ** int ( np . power ( n , 2 ) - n - 1 ) NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nth_term ( N ) ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def import ( n ) : NEW_LINE INDENT import numpy as np NEW_LINE class solution : NEW_LINE INDENT def nth_term ( n ) : NEW_LINE INDENT return int ( math . pow ( n , 2 ) - 2 * n + 2 ) NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nth_term ( N ) ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def import ( n ) : NEW_LINE INDENT import numpy as np NEW_LINE class solution : NEW_LINE INDENT def nth_term ( n ) : NEW_LINE INDENT return 3 * int ( np . power ( n , 2 ) + n - 2 ) NEW_LINE DEDENT def main ( arr ) : NEW_LINE INDENT N = 4 NEW_LINE print ( nth_term ( N ) ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def pyshashwat ( ) : NEW_LINE INDENT n1 = int ( os . urandom ( 4 ) ) NEW_LINE n2 = int ( os . urandom ( 4 ) ) NEW_LINE x = abs ( n1 ) + abs ( n2 ) NEW_LINE if n1 >= 0 and n2 >= 0 : NEW_LINE INDENT return 0 , x , x , 0 NEW_LINE DEDENT elif n1 < 0 and n2 >= 0 : NEW_LINE INDENT return - x , 0 , 0 NEW_LINE DEDENT elif n1 < 0 and n2 < 0 : NEW_LINE INDENT return - x , 0 , 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 , - x , x , 0 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Main ▁ function . STRNEWLINE STRNEWLINE ▁ : return : ▁ None STRNEWLINE ▁ """ NEW_LINE with open ( ' / proc / cpuinfo ' , ' r ' ) as f : NEW_LINE INDENT s = f . readline ( ) NEW_LINE DEDENT K = int ( s . split ( ) [ 0 ] ) NEW_LINE subs = set ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT index = i NEW_LINE for j in range ( K ) : NEW_LINE INDENT if index + 1 + j <= len ( s ) : NEW_LINE INDENT subs . add ( s [ index : index + 1 + j ] ) NEW_LINE DEDENT DEDENT DEDENT subs2 = [ s [ i : i + K ] for i in range ( K ) ] NEW_LINE subs2 . sort ( ) NEW_LINE print ( subs2 [ K - 1 ] ) NEW_LINE DEDENT
def pythree_iter ( N ) : NEW_LINE INDENT class Solution ( object ) : NEW_LINE INDENT memo = [ ] NEW_LINE def fib ( self ) : NEW_LINE INDENT if N in self . memo : NEW_LINE INDENT return self . memo [ N ] NEW_LINE DEDENT for i in range ( len ( self . memo ) , N + 1 ) : NEW_LINE INDENT self . memo [ N ] = self . memo [ i - 1 ] + self . memo [ i - 2 ] NEW_LINE DEDENT return self . memo [ N ] NEW_LINE DEDENT DEDENT sObj = Solution ( ) NEW_LINE N = 2 NEW_LINE out = sObj . fib ( N ) NEW_LINE print ( out ) NEW_LINE DEDENT
def test_forbidden_subsequence ( ) : NEW_LINE INDENT import sys NEW_LINE import doctest NEW_LINE t = sys . getframe ( 1 ) NEW_LINE while t . f_back is not None : NEW_LINE INDENT alph = [ 0 ] * 26 NEW_LINE s = t . f_code . co_filename NEW_LINE abc = t . f_code . co_varnames [ 0 ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT alph [ s [ i ] - ' a ' ] += 1 NEW_LINE DEDENT if abc == ' abc ' and ( alph [ 0 ] > 0 and alph [ 1 ] > 0 and alph [ 2 ] > 0 ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT while alph [ 2 ] > 0 : NEW_LINE INDENT res . append ( chr ( 2 + ' a ' ) ) NEW_LINE alph [ 2 ] -= 1 NEW_LINE DEDENT while alph [ 1 ] > 0 : NEW_LINE INDENT res . append ( chr ( 1 + ' a ' ) ) NEW_LINE alph [ 1 ] -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT while alph [ i ] > 0 : NEW_LINE INDENT res . append ( chr ( i + ' a ' ) ) NEW_LINE alph [ i ] -= 1 NEW_LINE DEDENT DEDENT DEDENT sys . stdout . write ( ' \n ' . join ( res ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT while alph [ i ] > 0 : NEW_LINE INDENT res . append ( chr ( i + ' a ' ) ) NEW_LINE alph [ i ] -= 1 NEW_LINE DEDENT DEDENT sys . stdout . write ( ' \n ' . join ( res ) ) NEW_LINE DEDENT DEDENT sys . stdout . flush ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT import math NEW_LINE pi = 3.142 NEW_LINE cos_x_serties_sum = math . cos ( pi / 180.0 ) NEW_LINE res = 1 NEW_LINE sign , fact , pow = 1 , 1 , 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign , fact = sign * - 1 , fact * ( 2 * i - 1 ) * ( 2 * i ) NEW_LINE pow = pow * x ** i NEW_LINE res = res + sign * pow / fact NEW_LINE DEDENT return res NEW_LINE DEDENT
def GFG ( N , S ) : NEW_LINE INDENT i = ( ( ( float ( N ) * float ( N + 1 ) ) / 4 ) - ( float ( S + 1 ) / 2 ) ) NEW_LINE return i NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ GFG ▁ algorithm . """ NEW_LINE K , dig0 , dig1 = symbols ( ' K ▁ dig0' , integer = True , positive = True ) NEW_LINE if K == 2 : NEW_LINE INDENT if sum ( dig0 ) % 3 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT sum = sum ( dig0 ) NEW_LINE numberofgroups = ( K - 3 ) // 4 NEW_LINE remnumberofdigits = ( K - 3 ) % 4 NEW_LINE sum += ( numberofgroups * 20 ) NEW_LINE for i in range ( remnumberofdigits ) : NEW_LINE INDENT temp = ( 2 * temp ) % 10 NEW_LINE sum += temp NEW_LINE DEDENT if sum % 3 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def test_codechef ( ) : NEW_LINE INDENT try : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE n = symbols ( ' n ' ) NEW_LINE a = [ 0 , 1 , 2 , 3 ] NEW_LINE b = [ 0 , 0 , 1 , 2 , 3 ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = symbols ( ' a ' , integer = True ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b [ i ] = symbols ( ' b ' , integer = True ) NEW_LINE DEDENT b . sort ( ) NEW_LINE ans = b [ - 1 ] + b [ - 2 ] NEW_LINE if sum <= ans : NEW_LINE INDENT assert ' YES ' in ans NEW_LINE DEDENT else : NEW_LINE INDENT assert ' NO ' in ans NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def GFG ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( s ) - 3 ) : NEW_LINE INDENT c , l , a , p = 0 , 0 , 0 , 0 NEW_LINE for j in range ( i , i + 4 ) : NEW_LINE INDENT try : NEW_LINE INDENT c += 1 NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if c == 1 and l == 1 and a == 1 and p == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT x , y = symbols ( ' x , y ' ) NEW_LINE assert count_steps ( x , y ) == x / y NEW_LINE assert count_steps ( y , x % y ) == x / y NEW_LINE DEDENT
def GFG ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ Area ▁ of ▁ the ▁ GF ▁ G ▁ function . """ NEW_LINE P , B , H = 3 , 4 , 5 NEW_LINE assert area_inscribed ( P , B , H ) == ( ( P + B - H ) ** 2 + ( P + B - H ) ** 2 + ( P + B - H ) ** 2 ) NEW_LINE DEDENT
def py2exe_options ( ) : NEW_LINE INDENT parser = optparse . OptionParser ( ) NEW_LINE parser . add_option ( ' - N ' , ' - - no - replace ' , action = ' store _ false ' , dest = ' replace ' , default = True , help = ' Do ▁ not ▁ replace ▁ the ▁ source ▁ code ▁ of ▁ the ▁ generated ▁ code ' ) NEW_LINE parser . add_option ( ' - M ' , ' - - module - name ' , action = ' store ' , dest = ' module _ name ' , default = ' ' , help = ' Name ▁ of ▁ the ▁ module ▁ to ▁ compile ' ) NEW_LINE parser . add_option ( ' - - compile - only ' , action = ' store _ true ' , dest = ' compile _ only ' , default = False , help = ' Do ▁ not ▁ compile ▁ the ▁ code ▁ of ▁ the ▁ generated ▁ code ' ) NEW_LINE parser . add_option ( ' - - verbose ' , action = ' store _ true ' , dest = ' verbose ' , default = False , help = ' Verbose ▁ output ' ) NEW_LINE options , args = parser . parse_args ( ) NEW_LINE if not args : NEW_LINE INDENT parser . print_help ( ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT replaces = [ ] NEW_LINE for line in args : NEW_LINE INDENT replaces . append ( line . replace ( ' \n ' , ' ' ) ) NEW_LINE DEDENT M = len ( args ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT c = args [ i ] NEW_LINE sys . stdout . write ( replaces [ c ] or c ) NEW_LINE DEDENT sys . stdout . write ( ' \n ' ) NEW_LINE return options , replaces NEW_LINE DEDENT
def get_count ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = n - 1 - upper_bound ( v , n , v [ i ] - 1 ) NEW_LINE if tmp == v [ i ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT count_of_two , count_of_five = 0 , 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT val = i NEW_LINE while val % 2 == 0 and val > 0 : NEW_LINE INDENT val /= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while val % 5 == 0 and val > 0 : NEW_LINE INDENT val /= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT
def GfG ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while n : NEW_LINE INDENT if n % 10 != 0 : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n /= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE import ast NEW_LINE import ast NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk NEW_LINE import ast . walk
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT scn = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - d | - e | - u | - t | - b | - u | - t | - b ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - d , ▁ - e : ▁ decode ▁ ASCII ▁ strings STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - u : ▁ encode ▁ ASCII ▁ strings STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - t : ▁ encode ▁ and ▁ decode ▁ Unicode ▁ strings STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ """ % sys . argv [ 0 ] ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT args = scn [ 1 : ] NEW_LINE if args == [ ' - e ' , ' - u ' , ' - t ' , ' - b ' , ' - t ' ] : NEW_LINE INDENT for arg in args : NEW_LINE INDENT if arg == ' - d ' : NEW_LINE INDENT decode ( ) NEW_LINE DEDENT elif arg == ' - e ' : NEW_LINE INDENT encode ( ) NEW_LINE DEDENT DEDENT DEDENT if args == [ ' - d ' , ' - u ' , ' - t ' , ' - b ' , ' - t ' ] : NEW_LINE INDENT for arg in args : NEW_LINE INDENT if arg == ' - e ' : NEW_LINE INDENT encode ( ) NEW_LINE DEDENT elif arg == ' - d ' : NEW_LINE INDENT decode ( ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT sys . stdout . write ( ' Usage : ▁ % s ▁ - e | - u | - t | - b | - u \n ' % sys . argv [ 0 ] ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT asd = 0 NEW_LINE for arg in args : NEW_LINE INDENT if arg == ' - e ' : NEW_LINE INDENT encode ( ) NEW_LINE DEDENT elif arg == ' - d ' : NEW_LINE INDENT decode ( ) NEW_LINE DEDENT DEDENT sys . stdout . write ( ' % s \n ' %
def test_vasyah_the_hipster ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ the ▁ vasya ▁ hipster ▁ algorithm . STRNEWLINE ▁ """ NEW_LINE x = symbols ( ' x ' ) NEW_LINE a , b = symbols ( ' a ▁ b ' , cls = Dummy ) NEW_LINE count = 0 NEW_LINE while True : NEW_LINE INDENT if a > 0 and b > 0 : NEW_LINE INDENT count += 1 NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ans = a / 2 + b / 2 NEW_LINE assert count == ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT osr = open ( ' / proc / self / stat ' , ' w ' ) NEW_LINE o = open ( ' / proc / self / stat ' , ' a ' ) NEW_LINE fr = open ( ' / proc / self / stat ' , ' r ' ) NEW_LINE n , m = fr . read ( ) . split ( ' ▁ ' ) NEW_LINE for i in range ( m - ( n % m ) ) : NEW_LINE INDENT o . write ( int ( n / m ) + ' ▁ ' ) NEW_LINE DEDENT for i in range ( int ( m - ( n % m ) ) , m ) : NEW_LINE INDENT o . write ( int ( math . ceil ( n / m ) ) + ' ▁ ' ) NEW_LINE DEDENT o . close ( ) NEW_LINE class FastReader : NEW_LINE INDENT def readline ( self ) : NEW_LINE INDENT return ' ' NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT line = self . readline ( ) NEW_LINE if not line or not line [ 0 ] : NEW_LINE INDENT return line NEW_LINE DEDENT DEDENT return line NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return line NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return line NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return line NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return line NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return line NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return line NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return line NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return line NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return line NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return line NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return line NEW_LINE DEDENT DEDENT class Pair : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . x NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . y NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . x NEW_LINE DEDENT DEDENT class Compare : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . x NEW_LINE DEDENT DEDENT return Compare ( ) NEW_LINE DEDENT
def GFG ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE arr1 = [ ] NEW_LINE arr2 = [ ] NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT set_bits = int ( s1 [ i ] ) NEW_LINE arr1 . append ( set_bits ) NEW_LINE DEDENT for i in range ( 7 ) : NEW_LINE INDENT set_bits = int ( s2 [ i ] ) NEW_LINE arr2 . append ( set_bits ) NEW_LINE DEDENT for i in range ( 1 , 6 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def GFG ( i , sum , cnt , a , n ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT if sum == 0 and cnt > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE ans += count_sub_seq ( i + 1 , sum , cnt , a , n ) NEW_LINE ans += count_sub_seq ( i + 1 , sum + a [ i ] , cnt + 1 , a , n ) NEW_LINE return ans NEW_LINE DEDENT
def py_descr ( ) : NEW_LINE INDENT reader = csv . reader ( sys . stdin ) NEW_LINE n = reader . next ( ) NEW_LINE s = [ ] NEW_LINE new_s = [ ] NEW_LINE input = reader . next ( ) NEW_LINE s = input . split ( ) NEW_LINE mid = ( n - 1 ) // 2 NEW_LINE counter = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = i + 1 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT new_s . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT new_s . append ( s [ mid + counter ] ) NEW_LINE DEDENT if counter >= 0 : NEW_LINE INDENT counter = counter - temp NEW_LINE DEDENT else : NEW_LINE INDENT counter = counter + temp NEW_LINE DEDENT DEDENT print ( ' ' . join ( new_s ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE a = int ( sys . argv [ 1 ] ) NEW_LINE n = int ( sys . argv [ 2 ] ) NEW_LINE m = int ( sys . argv [ 3 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , pow ( i + a , n ) ) : NEW_LINE INDENT x = int ( pow ( i + a , n ) ) NEW_LINE y = get_count ( x ) NEW_LINE if y == i : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def main ( arr , n , key ) : NEW_LINE INDENT pivot = findPivot ( arr , 0 , n - 1 ) NEW_LINE if pivot == - 1 : NEW_LINE INDENT return binarySearch ( arr , 0 , n - 1 , key ) NEW_LINE DEDENT if arr [ pivot ] == key : NEW_LINE INDENT return pivot NEW_LINE DEDENT if arr [ 0 ] <= key : NEW_LINE INDENT return binarySearch ( arr , 0 , pivot - 1 , key ) NEW_LINE DEDENT return binarySearch ( arr , pivot + 1 , n - 1 , key ) NEW_LINE DEDENT
def test_hoc_python ( ) : NEW_LINE INDENT import sys NEW_LINE n , mod = 1000000007 , 1 NEW_LINE n = int ( n ) NEW_LINE res = 0 NEW_LINE c = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] , [ 1 , 1 ] ] NEW_LINE for i in range (
def a843 ( ) : NEW_LINE INDENT import sys NEW_LINE N = len ( sys . argv ) NEW_LINE P = [ ] NEW_LINE for n in range ( N ) : NEW_LINE INDENT P . append ( ( n , sys . argv [ n ] ) ) NEW_LINE DEDENT P . sort ( ) NEW_LINE output = [ ] NEW_LINE lineCount = 0 NEW_LINE used = [ ] NEW_LINE for n in range ( N ) : NEW_LINE INDENT if not used [ n ] : NEW_LINE INDENT lineCount += 1 NEW_LINE count = 0 NEW_LINE pos = n NEW_LINE line = ' ' NEW_LINE while not used [ pos ] : NEW_LINE INDENT count += 1 NEW_LINE used [ pos ] = True NEW_LINE line += ' ▁ ' * ( pos + 1 ) NEW_LINE pos = P [ pos ] [ 0 ] NEW_LINE DEDENT output . append ( count ) NEW_LINE output . append ( line ) NEW_LINE output . append ( ' ' ) NEW_LINE DEDENT DEDENT print ( lineCount ) NEW_LINE print ( output ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import string NEW_LINE import os NEW_LINE import re NEW_LINE import ast NEW_LINE import ast . nodes NEW_LINE import ast . nodes NEW_LINE import ast . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE DEDENT
def p090 ( ) : NEW_LINE INDENT print ( p090 ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( ( 1 , 10 ) ) : NEW_LINE INDENT for j in range ( i , ( 1 , 10 ) ) : NEW_LINE INDENT if int ( i ) == 6 and int ( j ) == 6 and is_arranged_valid ( i , j ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return str ( count ) NEW_LINE DEDENT
def main ( argv ) : NEW_LINE INDENT global total_vertex NEW_LINE global adj_list NEW_LINE global graph NEW_LINE total_vertex = 0 NEW_LINE adj_list = [ ] NEW_LINE for i in range ( total_vertex ) : NEW_LINE INDENT tmp = [ ] NEW_LINE idx1 = i - 1 NEW_LINE degree = i NEW_LINE for j in range ( degree ) : NEW_LINE INDENT idx2 = i - 1 NEW_LINE tmp . append ( idx2 ) NEW_LINE DEDENT adj_list . append ( tmp ) NEW_LINE DEDENT graph . print_adj_matrix ( ) NEW_LINE adj_list = [ ] NEW_LINE for i in range ( total_vertex ) : NEW_LINE INDENT vertexes = this . adj_list [ i ] NEW_LINE for j in range ( total_vertex ) : NEW_LINE INDENT if vertexes . count ( j ) : NEW_LINE INDENT adj_list [ i ] [ j ] = 1 NEW_LINE print ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT adj_list [ i ] [ j ] = 0 NEW_LINE print ( '0' ) NEW_LINE DEDENT if j != total_vertex - 1 : NEW_LINE INDENT print ( ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE n , m = sys . argv [ 1 : ] NEW_LINE pic = [ ] NEW_LINE temp = ' ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = sys . stdin . readline ( ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT pic . append ( temp [ j ] ) NEW_LINE DEDENT DEDENT inc , inc1 = 0 , 0 NEW_LINE comeIn = [ ] NEW_LINE if n > 1 or m > 1 : NEW_LINE INDENT for x in range ( n - 1 ) : NEW_LINE INDENT for y in range ( m - 1 ) : NEW_LINE INDENT for i in range ( x , 2 + x ) : NEW_LINE INDENT for j in range ( y , 2 + y ) : NEW_LINE INDENT if pic [ i ] [ j ] == ' f ' and comeIn [ 0 ] == False : NEW_LINE INDENT inc += 1 NEW_LINE comeIn . append ( True ) NEW_LINE DEDENT elif pic [ i ] [ j ] == ' a ' and comeIn [ 1 ] == False : NEW_LINE INDENT inc += 1 NEW_LINE comeIn . append ( True ) NEW_LINE DEDENT elif pic [ i ] [ j ] == ' c ' and comeIn [ 2 ] == False : NEW_LINE INDENT inc += 1 NEW_LINE comeIn . append ( True ) NEW_LINE DEDENT elif pic [ i ] [ j ] == ' e ' and comeIn [ 3 ] == False : NEW_LINE INDENT inc += 1 NEW_LINE comeIn . append ( True ) NEW_LINE DEDENT DEDENT DEDENT if inc == 4 : NEW_LINE INDENT inc1 += 1 NEW_LINE DEDENT inc = 0 NEW_LINE del comeIn [ 0 ] NEW_LINE del comeIn [ 1 ] NEW_LINE del comeIn [ 2 ] NEW_LINE del comeIn [ 3 ] NEW_LINE DEDENT DEDENT print ( inc1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT sys . exit ( 0 ) NEW_LINE DEDENT
def test_AlternatingCurrent ( ) : NEW_LINE INDENT f = open ( ' / tmp / foo . txt ' , ' r ' ) NEW_LINE in_str = f . read ( ) . strip ( ) . split ( ' \n ' ) NEW_LINE stk = [ ] NEW_LINE for c in in_str : NEW_LINE INDENT if stk == [ ] : NEW_LINE INDENT stk . append ( c ) NEW_LINE continue NEW_LINE DEDENT top = stk [ 0 ] NEW_LINE if top == c : NEW_LINE INDENT stk . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( c ) NEW_LINE DEDENT DEDENT if stk == [ ] : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global X , Y , E NEW_LINE x , y = [ ] , [ ] NEW_LINE g = { } NEW_LINE vis = [ ] NEW_LINE match_to = [ ] NEW_LINE def dfs ( ) : NEW_LINE INDENT x = [ ] NEW_LINE y = [ ] NEW_LINE g = { } NEW_LINE for i in range ( X + Y ) : NEW_LINE INDENT g [ i ] = [ ] NEW_LINE DEDENT for i in range ( E ) : NEW_LINE INDENT x . append ( i ) NEW_LINE y . append ( i + X ) NEW_LINE g [ x ] . append ( y ) NEW_LINE g [ y ] . append ( x ) NEW_LINE DEDENT vis = [ ] NEW_LINE match_to = [ ] NEW_LINE del match_to NEW_LINE match = 0 NEW_LINE for i in range ( X ) : NEW_LINE INDENT del vis [ i ] NEW_LINE if dfs ( ) : NEW_LINE INDENT match += 1 NEW_LINE DEDENT DEDENT print ( match ) NEW_LINE DEDENT def dfs ( v ) : NEW_LINE INDENT if v in g : NEW_LINE INDENT return True NEW_LINE DEDENT for u in g [ v ] : NEW_LINE INDENT if vis [ u ] : NEW_LINE INDENT continue NEW_LINE DEDENT vis [ u ] = True NEW_LINE if dfs ( match_to [ u ] ) : NEW_LINE INDENT match_to [ u ] = v NEW_LINE match_to [ v ] = u NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX = 100 NEW_LINE count_mountains ( a [ : ] , n = 2 ) NEW_LINE A = [ [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 0 ] ] NEW_LINE count = 0 NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT for j in range ( n + 2 ) : NEW_LINE INDENT if ( i == 0 ) or ( j == 0 ) or ( i == n + 1 ) or ( j == n + 1 ) : NEW_LINE INDENT A [ i ] [ j ] = int ( a [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT N = 100005 NEW_LINE d , pre = [ ] , [ ] NEW_LINE Positive_Divisors ( ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , j * j <= i ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if d [ i ] == d [ i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre . append ( ans ) NEW_LINE DEDENT return pre NEW_LINE DEDENT
def test_solution ( ) : NEW_LINE INDENT s = sympy . parse ( ' test . txt ' ) NEW_LINE t = s . symbols NEW_LINE m = s . symbols . size NEW_LINE memory = [ 0 ] * m NEW_LINE alloc_idx = 0 NEW_LINE for j in range ( t ) : NEW_LINE INDENT try : NEW_LINE INDENT n = s . symbols [ ' n ' ] NEW_LINE len = 0 NEW_LINE can_alloc = False NEW_LINE for i in range ( m ) : NEW_LINE INDENT if memory [ i ] == 0 : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = 0 NEW_LINE DEDENT if len == n : NEW_LINE INDENT can_alloc = True NEW_LINE len = i - n + 1 NEW_LINE break NEW_LINE DEDENT DEDENT if can_alloc : NEW_LINE INDENT alloc_idx += 1 NEW_LINE for i in range ( len , len + n ) : NEW_LINE INDENT memory [ i ] = alloc_idx NEW_LINE DEDENT assert alloc_idx == len ( memory ) NEW_LINE DEDENT else : NEW_LINE INDENT assert ' NULL ' in memory NEW_LINE DEDENT DEDENT except IndexError : NEW_LINE INDENT assert ' NULL ' in memory NEW_LINE DEDENT DEDENT s . symbols = memory NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT P = ( len ( x ) * n ) NEW_LINE A = len ( x ) / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE area = ( P * A ) / 2 NEW_LINE assert area == area NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE assert area == area * 2 NEW_LINE DEDENT
def GFG ( str , n ) : NEW_LINE INDENT MAX = 256 NEW_LINE last_non_repeated = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ str [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if freq [ ch ] == 1 : NEW_LINE INDENT return ( " % s " % ch ) NEW_LINE DEDENT DEDENT return " - 1" NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE n = len ( sys . argv ) NEW_LINE a , b = getopt . getopt ( sys . argv [ 1 : ] , ' a ' , [ ' left ' , ' right ' ] ) NEW_LINE left , right = int ( a [ 0 ] ) , int ( a [ 1 ] ) NEW_LINE left = min ( left , left ) NEW_LINE right = max ( right , right ) NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == left and b [ i ] == right : NEW_LINE INDENT ans = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT sys . stdout . write ( ans ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT
def GFG ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x ) ) NEW_LINE DEDENT
def pyGFG ( arr , i , curr , n , m ) : NEW_LINE INDENT max_n = 300 NEW_LINE max_m = 300 NEW_LINE dp = [ [ 0 ] * max_n , [ 0 ] * max_m , [ 0 ] * max_n , [ 0 ] * max_m ] NEW_LINE v = [ False ] * max_n , [ False ] * max_m , [ False ] * max_n , [ False ] * max_m ] NEW_LINE if i == n : NEW_LINE INDENT if curr == m : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if v [ i ] : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] = True NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) NEW_LINE r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) NEW_LINE dp [ i ] [ curr ] = l NEW_LINE if r != - 1 : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT
def GFG ( arr , i , curr , n , m ) : NEW_LINE INDENT max_n = 20 NEW_LINE max_m = 64 NEW_LINE dp = [ [ 0 ] * max_n , [ 0 ] * max_m , [ 0 ] * max_n , [ 0 ] * max_m ] NEW_LINE v = [ [ 0 ] * max_n , [ 0 ] * max_m , [ 0 ] * max_n , [ 0 ] * max_m ] NEW_LINE def find_len ( arr , i , curr , n , m ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT if curr == m : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if v [ i ] [ curr ] : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = True NEW_LINE l = find_len ( arr , i + 1 , curr , n , m ) NEW_LINE r = find_len ( arr , i + 1 , curr | arr [ i ] , n , m ) NEW_LINE dp [ i ] [ curr ] = l NEW_LINE if r != - 1 : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT def find_len ( arr , i , curr , n , m ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT if curr == m : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT elif v [ i ] [ curr ] : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT elif v [ i ] [ curr ] : NEW_LINE INDENT return v [ i ] [ curr ] NEW_LINE DEDENT elif v [ i ] [ curr ] : NEW_LINE INDENT return v [ i ] [ curr ] NEW_LINE DEDENT elif v [ i ] [ curr ] : NEW_LINE INDENT return v [ i ] [ curr ] NEW_LINE DEDENT elif v [ i ] [ curr ] : NEW_LINE INDENT return v [ i ] [ curr ] NEW_LINE DEDENT elif v [ i ] [ curr ] : NEW_LINE INDENT return v [ i ] [ curr ] NEW_LINE DEDENT elif v [ i ] [ curr ] : NEW_LINE INDENT return v [ i ] [ curr ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return find_len ( arr , i , 0 , n , m ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT n = line . strip ( ) NEW_LINE if n == ' ' : NEW_LINE INDENT return NEW_LINE DEDENT cost = { } NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a , b = line . split ( ) NEW_LINE c = int ( a ) NEW_LINE cost [ a ] [ b ] = cost [ b ] [ a ] = c NEW_LINE ans += cost [ a ] [ b ] * 2 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT reaf = 0 NEW_LINE ii , jj = 0 , 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if cost [ i ] [ j ] > 0 or cost [ i ] [ j ] == - 1 : NEW_LINE INDENT reaf += 1 NEW_LINE ii = i NEW_LINE jj = j NEW_LINE DEDENT DEDENT if i != 1 and reaf == 1 : NEW_LINE INDENT ans -= cost [ ii ] [ jj ] * 2 NEW_LINE cost [ ii ] [ jj ] = cost [ jj ] [ ii ] = - 1 NEW_LINE DEDENT DEDENT print ( ans - max ( 1 ) ) NEW_LINE DEDENT def max ( m ) : NEW_LINE INDENT cut = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if cost [ m ] [ i ] > 0 : NEW_LINE INDENT cost [ i ] [ m ] = 0 NEW_LINE cut = max ( cut , cost [ m ] [ i ] + max ( i ) ) NEW_LINE DEDENT DEDENT return cut NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( msg + " \n " ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT N = 0 NEW_LINE for i in range ( 3 , len ( S ) - 1 ) : NEW_LINE INDENT ans += int ( pow ( 3 , i ) - 3 * int ( pow ( 2 , i ) ) + 3 ) NEW_LINE DEDENT ans += f ( 3 * int ( pow ( 10 , len ( S ) - 1 ) ) , len ( S ) - 2 ) NEW_LINE ans += f ( 5 * int ( pow ( 10 , len ( S ) - 1 ) ) , len ( S ) - 2 ) NEW_LINE ans += f ( 7 * int ( pow ( 10 , len ( S ) - 1 ) ) , len ( S ) - 2 ) NEW_LINE sys . stdout . write ( ans + " \n " ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = np . array ( [ 10 , 100 , 300 , 200 , 1000 , 20 , 30 ] ) NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE assert min_diff ( arr , n , k ) == 0 NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE n = 0 NEW_LINE t = [ ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT n -= 1 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT t . append ( i ) NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE DEDENT solve ( ) NEW_LINE L , R = 0 , 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if L < t [ i ] : NEW_LINE INDENT L , R = t [ i ] , L NEW_LINE DEDENT elif R < t [ i ] : NEW_LINE INDENT R , L , R = t [ i ] , R NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT return " YES " NEW_LINE DEDENT
def test_problem_1455b ( ) : NEW_LINE INDENT x = Symbol ( ' x ' ) NEW_LINE val = 0 NEW_LINE turn = 0 NEW_LINE while val < x : NEW_LINE INDENT val += turn + 1 NEW_LINE turn += 1 NEW_LINE DEDENT if val == x : NEW_LINE INDENT assert turn == 0 NEW_LINE DEDENT elif val == x + 1 : NEW_LINE INDENT assert turn == 1 NEW_LINE DEDENT else : NEW_LINE INDENT assert turn == 0 NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = np . array ( [ 10 , 15 , 15 , 17 , 18 , 21 ] ) NEW_LINE n = len ( arr ) NEW_LINE assert np . allclose ( np . dot ( arr , arr ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE assert np . allclose ( np . dot ( arr , arr . T ) , np . eye ( n ) ) NEW_LINE DEDENT
def p204 ( cls ) : NEW_LINE INDENT print ( cls . run ( ) ) NEW_LINE return str ( cls . count ( 0 , 1 ) ) NEW_LINE DEDENT
def get_maximum_xor ( n , l , r ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( int ( math . log ( r ) / math . log ( 2 ) ) , - 1 , - 1 ) : NEW_LINE INDENT if ( n & ( 1 << i ) ) > 0 : NEW_LINE INDENT if ( x > r ) or ( x + ( 1 << i ) - 1 < l ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( x ^ ( 1 << i ) ) <= r : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT DEDENT return n ^ x NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr = [ False ] * N + 5 NEW_LINE for i in range ( 3 , N ** 2 , 2 ) : NEW_LINE INDENT if not arr [ i ] : NEW_LINE INDENT for j in range ( i * i , N , i ) : NEW_LINE INDENT arr [ j ] = True NEW_LINE DEDENT DEDENT DEDENT prime = [ 2 ] * N + 5 NEW_LINE for i in range ( 3 , N , 2 ) : NEW_LINE INDENT if not arr [ i ] : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT DEDENT i , ans = 0 , 1 NEW_LINE while ans * prime [ i ] <= N and i < len ( prime ) : NEW_LINE INDENT ans *= prime [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT bit = str ( n ) NEW_LINE bit1 = [ bit ] NEW_LINE bit1 = bit1 [ 0 ] NEW_LINE zero = 0 NEW_LINE for i in range ( 64 ) : NEW_LINE INDENT if bit1 [ i ] == '0' : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT assert zero == 0 NEW_LINE DEDENT
def test_shopping ( ) : NEW_LINE INDENT """ Test ▁ the ▁ shopping ▁ algorithm . """ NEW_LINE one = number_one + number_two + number_three NEW_LINE two = 2 * ( number_one + number_two ) NEW_LINE three = 2 * ( number_one + number_three ) NEW_LINE four = 2 * ( number_two + number_three ) NEW_LINE assert numpy . min ( numpy . minimum ( one , two ) ) == numpy . min ( three , four ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE tc = 0 NEW_LINE work : NEW_LINE INDENT n = sys . argv [ 1 ] NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( sys . argv [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT class FastScanner : NEW_LINE INDENT f = open ( ' ' , ' r ' ) NEW_LINE tokens = [ ] NEW_LINE next = ' ' NEW_LINE def readline ( self ) : NEW_LINE INDENT while not tokens : NEW_LINE INDENT try : NEW_LINE INDENT tokens . append ( next ( ) ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT tokens . append ( next ( ) ) NEW_LINE DEDENT DEDENT return tokens NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT tokens . append ( next ( ) ) NEW_LINE DEDENT DEDENT return FastScanner ( sys . stdin , sys . stdout , ' ' , ' ' ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = P [ j ] - ' a ' NEW_LINE sum += Q [ pos ] - '0' NEW_LINE s += P [ j ] NEW_LINE if sum <= K : NEW_LINE INDENT S . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT
def GFG ( string ) : NEW_LINE INDENT str = string . split ( ' ▁ ' ) NEW_LINE n = len ( str ) NEW_LINE even , index = int ( str [ 0 ] ) , 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] - '0' ) % 2 == 0 : NEW_LINE INDENT even = ( str [ i ] - '0' ) NEW_LINE index = i NEW_LINE DEDENT if even <= ( str [ n - 1 ] - '0' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if even == int ( str [ 0 ] ) : NEW_LINE INDENT return str NEW_LINE DEDENT swap ( str [ index : index + n - 1 ] ) NEW_LINE return str NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT div = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n * i <= n + 1 ) : NEW_LINE INDENT div . append ( i * j ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def py2int ( ) : NEW_LINE INDENT import sys NEW_LINE a , b = 0 , 0 NEW_LINE ans = 0 NEW_LINE ss = ' ' NEW_LINE aa , bb = ' ' , ' ' NEW_LINE mm = [ 0 ] * 200005 NEW_LINE def main ( ) : NEW_LINE INDENT f = sys . stdin NEW_LINE ss = f . readline ( ) NEW_LINE aa = ss . split ( ) NEW_LINE a = len ( ss ) NEW_LINE ss = f . readline ( ) NEW_LINE bb = ss . split ( ) NEW_LINE b = len ( ss ) NEW_LINE for i in range ( 1 , b + 1 ) : NEW_LINE INDENT mm [ i ] = mm [ i - 1 ] + bb [ i - 1 ] - '0' NEW_LINE DEDENT for i in range ( 0 , a + 1 ) : NEW_LINE INDENT if aa [ i ] == '0' : NEW_LINE INDENT ans += long ( mm [ b - a + i + 1 ] ) - mm [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += long ( b - a + 1 - ( mm [ b - a + i + 1 ] - mm [ i ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def get_GFG ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ ] NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index . append ( n ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = str [ i ] NEW_LINE yield count [ x ] , i NEW_LINE if count [ x ] == 1 and x != ' ▁ ' : NEW_LINE INDENT index . append ( i ) NEW_LINE DEDENT if count [ x ] == 2 : NEW_LINE INDENT index . append ( n ) NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE for i in range ( MAX_CHAR and index [ i ] != n ) : NEW_LINE INDENT print ( str [ index [ i ] ] ) NEW_LINE DEDENT DEDENT
def GFG ( x , k , m ) : NEW_LINE INDENT result = x NEW_LINE k -= 1 NEW_LINE while k : NEW_LINE INDENT result = int ( pow ( result , x ) ) NEW_LINE if result > m : NEW_LINE INDENT result %= m NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT s = str ( n ) NEW_LINE res = " " NEW_LINE for c in s : NEW_LINE INDENT if c in [ '1' , '3' , '5' , '7' , '9' ] : NEW_LINE INDENT res += c NEW_LINE DEDENT if len ( res ) == 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if len ( res ) == 2 : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def test_dup_count_complex_roots_gcd ( ) : NEW_LINE INDENT R , x = ring ( " x " , ZZ ) NEW_LINE f = x ** 5 + x ** 4 + x ** 3 + x ** 2 + x + 1 NEW_LINE g = x ** 6 + x ** 5 + x ** 4 + x ** 3 + x ** 2 + 1 NEW_LINE h = x ** 6 + x ** 5 + x ** 4 + x ** 3 + x ** 2 + 1 NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 1 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 2 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 3 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 4 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 5 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 6 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 7 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 8 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 9 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 10 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 11 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 12 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 13 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 14 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 15 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 16 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 17 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 18 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) == ( 1 , 19 ) NEW_LINE assert R . dup_count_complex_roots ( f , g , h ) ==
def py ( ) : NEW_LINE INDENT import sys NEW_LINE import tokenize NEW_LINE import doctest NEW_LINE import tempfile NEW_LINE import os NEW_LINE import re NEW_LINE import tempfile NEW_LINE class Main : NEW_LINE INDENT def __init__ ( self , file = sys . stdin ) : NEW_LINE INDENT self . file = file NEW_LINE self . tokenizer = tokenize . generate_tokens ( lambda : sys . stdin . readline ( ) ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT while not self . tokenizer . next : NEW_LINE INDENT self . tokenizer . next ( ) NEW_LINE DEDENT return self . tokenizer . next ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . tokenizer . next ( ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT return self . tokenizer . next ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT return self . tokenizer . next ( ) NEW_LINE DEDENT def close ( self ) : NEW_LINE INDENT self . tokenizer . close ( ) NEW_LINE DEDENT DEDENT sc = SparkContext ( ) NEW_LINE out = tempfile . NamedTemporaryFile ( ) NEW_LINE TT = sc . _jvm . org . apache . spark . sql . streaming . StreamingResultSet ( sc . parallelize ( [ ( 1 , 2 , 3 ) ] , 1 ) ) NEW_LINE while TT . next ( ) : NEW_LINE INDENT set = set ( ) NEW_LINE n = sc . parallelize ( [ 1 , 2 , 3 ] , 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT set . add ( sc . randomSymbol ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT out . write ( max ( i + 1 , len ( set ) ) + " ▁ " ) NEW_LINE DEDENT DEDENT out . flush ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( m + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 ) NEW_LINE assert ( n * ( 1 + an ) ) / 2 == 1 + ( n - 1 ) * ( n + 1 )
def main ( ) : NEW_LINE INDENT import sys NEW_LINE h , w = sys . argv [ 1 : ] NEW_LINE field = [ ] NEW_LINE orbs = [ ] NEW_LINE ingots = [ ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT field . append ( sys . argv [ 2 ] ) NEW_LINE for j in range ( w - 1 , - 1 , - 1 ) : NEW_LINE INDENT orbs . append ( orbs [ i ] [ j ] ) NEW_LINE if field [ i ] [ j ] == ' O ' : NEW_LINE INDENT orbs [ i ] [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for j in range ( w ) : NEW_LINE INDENT for i in range ( h - 1 , - 1 , - 1 ) : NEW_LINE INDENT ingots . append ( ingots [ i + 1 ] [ j ] ) NEW_LINE if field [ i ] [ j ] == ' I ' : NEW_LINE INDENT ingots [ i ] [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT total = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if field [ i ] [ j ] == ' J ' : NEW_LINE INDENT total += orbs [ i ] [ j ] * ingots [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( total ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ divisors ▁ of ▁ the ▁ polynomials . """ NEW_LINE n , k = 12 , 3 NEW_LINE assert count_divisors ( n , k ) == n NEW_LINE assert count_divisors ( n , k ) == k * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors ( n , k ) == k * n * n NEW_LINE assert count_divisors (
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ divisors ▁ of ▁ the ▁ polynomials . """ NEW_LINE n , k = 12 , 3 NEW_LINE assert count_divisors ( n , k ) == n NEW_LINE DEDENT
def GFG ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y : NEW_LINE INDENT if y % 2 == 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def test_integer_points ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' , integer = True ) NEW_LINE out = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = symbols ( ' n ' , integer = True ) NEW_LINE p2 = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT p2 += ( x % 2 + 1 ) % 2 NEW_LINE DEDENT m = symbols ( ' m ' , integer = True ) NEW_LINE q2 = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT q2 += ( x % 2 + 1 ) % 2 NEW_LINE DEDENT out . append ( ( p2 , q2 ) ) NEW_LINE DEDENT for i in range ( t ) : NEW_LINE INDENT assert simplify ( out [ i ] ) == simplify ( x ** 2 ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT if len ( n ) < 2 : NEW_LINE INDENT print ( ' Invalid ▁ ' ) NEW_LINE return 0 NEW_LINE DEDENT min_val , max_val = int ( n [ 0 ] ) , int ( n [ 1 ] ) NEW_LINE for i in range ( n [ 0 ] ) : NEW_LINE INDENT if ( arr [ i ] - i ) > max_val : NEW_LINE INDENT max_val , min_val = arr [ i ] - i , arr [ i ] NEW_LINE DEDENT if ( arr [ i ] - i ) < min_val : NEW_LINE INDENT min_val , max_val = arr [ i ] - i , arr [ i ] NEW_LINE DEDENT DEDENT return ( max_val - min_val ) , ( min_val - max_val ) NEW_LINE DEDENT
def test_b1150 ( ) : NEW_LINE INDENT f = open ( ' b1150 . txt ' , ' r ' ) NEW_LINE n = int ( f . readline ( ) ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = f . readline ( ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT arr . append ( line [ k ] + ' ' ) NEW_LINE DEDENT DEDENT print ( solve ( arr , n ) ) NEW_LINE DEDENT
def GFG ( m , n ) : NEW_LINE INDENT count = [ [ 0 ] * m for i in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE while t : NEW_LINE INDENT n = len ( t ) NEW_LINE a = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( t [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT if sum % n != 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT sum /= n NEW_LINE flag = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == sum : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( n , k ) : NEW_LINE INDENT if ( n >> ( k - 1 ) ) == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def set_kth_bit ( n , k ) : NEW_LINE INDENT return ( ( 1 << ( k - 1 ) ) | n ) NEW_LINE DEDENT def all_bits_are_set ( n ) : NEW_LINE INDENT if ( ( n + 1 ) & n ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def bits_are_in_alt_order ( n ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) NEW_LINE return all_bits_are_set ( num ) NEW_LINE DEDENT bits_are_in_alt_patrnl_in_given_range ( n , l , r ) : NEW_LINE INDENT num , left_shift = set_kth_bit ( n , ( r + 1 ) ) NEW_LINE num , right_shift = set_kth_bit ( n , ( l - 1 ) ) NEW_LINE num , left_shift = set_kth_bit ( n , ( r - 1 ) ) NEW_LINE num , right_shift = set_kth_bit ( n , ( l + 1 ) ) NEW_LINE return bits_are_in_alt_order ( num ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 18 NEW_LINE l , r = 1 , 3 NEW_LINE if bits_are_in_alt_patrnl_in_given_range ( n , l , r ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT n , x , y = symbols ( ' n ▁ x ▁ y ' , integer = True , positive = True ) NEW_LINE assert factorial ( n ) <= 1 NEW_LINE assert n * factorial ( n - 1 ) == 1 NEW_LINE assert nCr ( n , r ) == factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) NEW_LINE assert NumberOfWays ( n , x , y ) == nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) NEW_LINE DEDENT
def get_common_prefix ( str1 , str2 ) : NEW_LINE INDENT result = " " NEW_LINE n1 , n2 = len ( str1 ) , len ( str2 ) NEW_LINE for i , j in enumerate ( str1 ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT break NEW_LINE DEDENT result += str1 [ i ] NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE N = len ( sys . argv ) NEW_LINE a = [ ] NEW_LINE for i in range ( N * 3 ) : NEW_LINE INDENT a . append ( sys . argv [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( N , 3 * N , 2 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sys . stdout . write ( sum ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE N = len ( sys . argv ) NEW_LINE a = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT a . append ( sys . argv [ i ] ) NEW_LINE DEDENT sys . argv = sys . argv [ : ] NEW_LINE count = 0 NEW_LINE valid = True NEW_LINE current = 1 NEW_LINE while valid : NEW_LINE INDENT count += 1 NEW_LINE current = a [ current ] NEW_LINE if current == 2 : NEW_LINE INDENT valid = False NEW_LINE DEDENT if count == N : NEW_LINE INDENT count = 0 NEW_LINE valid = False NEW_LINE DEDENT DEDENT if count == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT DEDENT
def p301 ( ) : NEW_LINE INDENT print ( [ ] ) NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return str ( a ) NEW_LINE DEDENT
def test_GFG ( arr , low , high , freq ) : NEW_LINE INDENT if arr [ low ] == arr [ high ] : NEW_LINE INDENT freq [ arr [ low ] ] += high - low + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE find_frequency_util ( arr , low , mid , freq ) NEW_LINE find_frequency_util ( arr , mid + 1 , high , freq ) NEW_LINE DEDENT find_frequency ( arr , 0 , n = len ( arr ) - 1 ) NEW_LINE for i in range ( 0 , arr [ - 1 ] + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT print ( " Element ▁ % d ▁ occurs ▁ % d ▁ times " % ( i , freq [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT
def p_p070 ( p ) : NEW_LINE INDENT print ( ast . p070 ( ) ) NEW_LINE def f ( ) : NEW_LINE INDENT LIMIT = library . pow ( 10 , 7 ) NEW_LINE DEDENT def g ( ) : NEW_LINE INDENT min_numer = 1 NEW_LINE min_denom = 0 NEW_LINE totients = library . list_totients ( LIMIT - 1 ) NEW_LINE for n in totients : NEW_LINE INDENT tot = totients [ n ] NEW_LINE if ( long ( n ) * min_denom < long ( min_numer * tot ) and has_same_digits ( n , tot ) ) : NEW_LINE INDENT min_numer = n NEW_LINE min_denom = tot NEW_LINE DEDENT DEDENT if min_denom == 0 : NEW_LINE INDENT raise Exception ( " Not ▁ found " ) NEW_LINE DEDENT return str ( min_numer ) NEW_LINE DEDENT def has_same_digits ( x , y ) : NEW_LINE INDENT xdigits = str ( x ) . split ( " . " ) NEW_LINE ydigits = str ( y ) . split ( " . " ) NEW_LINE xdigits . sort ( ) NEW_LINE ydigits . sort ( ) NEW_LINE return all ( xdigits == ydigits ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = [ 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 ] NEW_LINE b = [ 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE assert intersection ( a , b , n , m ) == [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE assert find_min ( a , n ) == 0 NEW_LINE DEDENT
def import ( arr , n ) : NEW_LINE INDENT class solution : NEW_LINE INDENT def gcd ( self , a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT if n < 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectSquare ( arr , n ) : NEW_LINE INDENT minPerfectSq = 0 NEW_LINE lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectSq = int ( lcm ) NEW_LINE cnt = 0 NEW_LINE while lcm > 1 and lcm % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT if cnt % 2 != 0 : NEW_LINE INDENT minPerfectSq *= 2 NEW_LINE DEDENT i = 3 NEW_LINE while lcm > 1 : NEW_LINE INDENT cnt = 0 NEW_LINE while lcm % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= i NEW_LINE DEDENT if cnt % 2 != 0 : NEW_LINE INDENT minPerfectSq *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectSq NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectSquare ( arr , n ) ) NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def cfg ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE fast , slow = 0 , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] - arr [ i - 1 ] == 1 : NEW_LINE INDENT fast += 1 NEW_LINE DEDENT else : NEW_LINE INDENT len = fast - slow + 1 NEW_LINE result += len * ( len - 1 ) / 2 NEW_LINE fast , slow = i , i NEW_LINE DEDENT DEDENT if fast != slow : NEW_LINE INDENT len = fast - slow + 1 NEW_LINE result += len * ( len - 1 ) / 2 NEW_LINE DEDENT return result NEW_LINE DEDENT
def class1 ( arg ) : NEW_LINE INDENT input = sys . stdin NEW_LINE t = input ( ) NEW_LINE while t : NEW_LINE INDENT n = input ( ) NEW_LINE ans = 0 NEW_LINE flag = 0 NEW_LINE while n : NEW_LINE INDENT x = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT temp = n / 2 NEW_LINE if n % 4 == 0 and n > 8 : NEW_LINE INDENT temp = n - 1 NEW_LINE x += 1 NEW_LINE DEDENT n = temp NEW_LINE if flag == 0 : NEW_LINE INDENT flag = 1 NEW_LINE if x > 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += temp NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if flag == 0 : NEW_LINE INDENT n = n - 1 NEW_LINE ans += 1 NEW_LINE flag = 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = n - 1 NEW_LINE flag = 0 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - d | - e | - u | - t ] ▁ [ - d | - e | - u | - t ] """ % sys . argv [ 0 ] ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - d | - e | - u | - t | - t ] ▁ [ - d | - e | - u | - t ] """ % sys . argv [ 0 ] ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - d | - e | - u | - t | - t ] ▁ [ - d | - e | - u | - t ] """ % sys . argv [ 0 ] ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - d | - e | - u | - t ] ▁ [ - d | - e | - u ] """ % sys . argv [ 0 ] ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - d | - e | - u | - t ] ▁ [ - d | - e | - u ] """ % sys . argv [ 0 ] ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - d | - e | - u | - t ] ▁ [ - d | - e | - u ] """ % sys . argv [ 0 ] ) NEW_LINE print ( """ """ ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT d = None NEW_LINE e = None NEW_LINE u = None NEW_LINE for o , a in opts : NEW_LINE INDENT if o == ' - d ' : d = a NEW_LINE elif o == ' - e ' : e = a NEW_LINE DEDENT if not d : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( """ No ▁ data ▁ found ▁ for ▁ % s . """ % o ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if not u : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( """ No ▁ data ▁ found ▁ for ▁ % s . """ % o ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT for arg in args : NEW_LINE INDENT if arg not in d : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( arg ) NEW_LINE DEDENT DEDENT DEDENT
def find_substring ( str ) : NEW_LINE INDENT """ Find ▁ the ▁ substring ▁ of ▁ a ▁ string . """ NEW_LINE n = len ( str ) NEW_LINE dist_count = 0 NEW_LINE visited = [ False ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if visited [ str [ i ] ] == False : NEW_LINE INDENT visited [ str [ i ] ] = True NEW_LINE dist_count += 1 NEW_LINE DEDENT DEDENT start , start_index = 0 , - 1 NEW_LINE min_len = sys . maxint NEW_LINE count = 0 NEW_LINE curr_count = [ 0 ] * n NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count [ str [ j ] ] += 1 NEW_LINE if curr_count [ str [ j ] ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == dist_count : NEW_LINE INDENT while curr_count [ str [ start ] ] > 1 : NEW_LINE INDENT if curr_count [ str [ start ] ] > 1 : NEW_LINE INDENT curr_count [ str [ start ] ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT return str [ start_index : start_index + min_len ] NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE A = sys . argv [ 1 ] NEW_LINE B = sys . argv [ 2 ] NEW_LINE C = sys . argv [ 3 ] NEW_LINE D = sys . argv [ 4 ] NEW_LINE E = sys . argv [ 5 ] NEW_LINE F = sys . argv [ 6 ] NEW_LINE water = 0 NEW_LINE suger = 0 NEW_LINE watmax = 0 NEW_LINE sugmax = 0 NEW_LINE maxnodo = 100 * E / ( 100 + E ) NEW_LINE nodo = 0 NEW_LINE nodomax = 0 NEW_LINE for a in range ( 0 , F // 100 , A ) : NEW_LINE INDENT for b in range ( 0 , F // 100 , B ) : NEW_LINE INDENT for c in range ( 0 , F // 100 , C ) : NEW_LINE INDENT for d in range ( 0 , F // 100 , D ) : NEW_LINE INDENT water = 100 * a + 100 * b NEW_LINE suger = c + d NEW_LINE if water == 0 or water + suger > F : NEW_LINE INDENT break NEW_LINE DEDENT nodo = 100 * suger / ( water + suger ) NEW_LINE if nodo >= nodomax and nodo <= maxnodo : NEW_LINE INDENT watmax = water NEW_LINE sugmax = suger NEW_LINE nodomax = nodo NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ( watmax , sugmax ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE before = None NEW_LINE while True : NEW_LINE INDENT if not sys . stdin . isatty ( ) : NEW_LINE INDENT break NEW_LINE DEDENT lines = sys . stdin . readlines ( ) NEW_LINE inner = [ int ( line ) for line in lines ] NEW_LINE if before is None : NEW_LINE INDENT before = inner NEW_LINE DEDENT else : NEW_LINE INDENT tmp = [ ] NEW_LINE for i in range ( len ( before ) ) : NEW_LINE INDENT if i < len ( tmp ) : NEW_LINE INDENT if tmp [ i ] < before [ i ] + inner [ i ] : NEW_LINE INDENT tmp . append ( before [ i ] + inner [ i ] ) NEW_LINE DEDENT DEDENT if before [ i ] > tmp [ - 1 ] : NEW_LINE INDENT if ( i - 1 ) < len ( tmp ) and ( i - 1 ) >= 0 : NEW_LINE INDENT if tmp [ i - 1 ] < before [ i ] + inner [ i - 1 ] : NEW_LINE INDENT tmp . append ( before [ i ] + inner [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if ( i + 1 ) < len ( tmp ) : NEW_LINE INDENT if tmp [ i + 1 ] < before [ i ] + inner [ i + 1 ] : NEW_LINE INDENT tmp . append ( before [ i ] + inner [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT before = tmp NEW_LINE DEDENT DEDENT print ( before ) NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT even , odd = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT print ( ( even ) * ( n - 1 ) ) NEW_LINE print ( ( odd ) * ( n - 1 ) ) NEW_LINE DEDENT
def test_a1613 ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ the ▁ calculation ▁ of ▁ the ▁ power ▁ function ▁ of ▁ the ▁ two ▁ numbers . STRNEWLINE ▁ """ NEW_LINE power = [ 1 , 10 , 100 , 1000 , 10000 , 100000 ] NEW_LINE s = numpy . random . RandomState ( 0 ) NEW_LINE noOfComparison = len ( s ) NEW_LINE for i in range ( noOfComparison ) : NEW_LINE INDENT x1 , p1 , x2 , p2 = s [ i ] NEW_LINE compare ( x1 , p1 , x2 , p2 ) NEW_LINE DEDENT def compare ( x1 , p1 , x2 , p2 ) : NEW_LINE INDENT if p1 == p2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT xx1 = x1 NEW_LINE xx2 = x2 NEW_LINE while xx1 % 10 == 0 : NEW_LINE INDENT xx1 /= 10 NEW_LINE p1 += 1 NEW_LINE DEDENT while xx2 % 10 == 0 : NEW_LINE INDENT xx2 /= 10 NEW_LINE p2 += 1 NEW_LINE DEDENT if p1 > p2 : NEW_LINE INDENT xx1 *= cached_power ( p1 - p2 ) NEW_LINE DEDENT elif p2 > p1 : NEW_LINE INDENT xx2 *= cached_power ( p2 - p1 ) NEW_LINE DEDENT return xx1 , xx2 NEW_LINE DEDENT DEDENT def cached_power ( p ) : NEW_LINE INDENT if p < 6 : NEW_LINE INDENT return power [ p ] NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( 10 , int ( p ) ) NEW_LINE DEDENT DEDENT def direct_compare ( x1 , x2 ) : NEW_LINE INDENT if x1 > x2 : NEW_LINE INDENT return ' > ' NEW_LINE DEDENT elif x2 > x1 : NEW_LINE INDENT return ' < ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' = ' NEW_LINE DEDENT DEDENT def direct_compare ( x1 , x2 ) : NEW_LINE INDENT if x1 > x2 : NEW_LINE INDENT return ' > ' NEW_LINE DEDENT elif x2 > x1 : NEW_LINE INDENT return ' < ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' = ' NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n , m = sys . argv [ 1 ] , sys . argv [ 2 ] NEW_LINE arrs = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrs . append ( sys . argv [ i ] ) NEW_LINE DEDENT length = [ ] NEW_LINE index = 0 NEW_LINE return_dex = None NEW_LINE for tmp in arrs : NEW_LINE INDENT dexG , dexS = tmp . split ( " G " ) NEW_LINE if dexG > dexS : NEW_LINE INDENT return_dex = - 1 NEW_LINE DEDENT length . append ( dexS - dexG ) NEW_LINE DEDENT set = set ( ) NEW_LINE for len in length : NEW_LINE INDENT set . add ( len ) NEW_LINE DEDENT if return_dex is None : NEW_LINE INDENT print ( return_dex ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( len ( set ) ) NEW_LINE DEDENT DEDENT
def GFG ( arr , n , x ) : NEW_LINE INDENT front , back = 0 , n - 1 NEW_LINE while front <= back : NEW_LINE INDENT if arr [ front ] == x or arr [ back ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ i ] = mp [ i ] if i in mp else 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if mp [ i ] != - 1 : NEW_LINE INDENT assert i in mp NEW_LINE mp [ i ] = - 1 NEW_LINE DEDENT DEDENT DEDENT
def gen_free_tree ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE st = [ int ( i ) for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT while st [ - 1 ] <= arr [ i ] : NEW_LINE INDENT x = st [ - 1 ] NEW_LINE st . pop ( - 1 ) NEW_LINE ans += x * min ( st [ - 1 ] , arr [ i ] ) NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 2 , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] * st [ i - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE s = sys . argv [ 1 ] NEW_LINE t = sys . argv [ 2 ] NEW_LINE cache1 = [ 0 ] * 26 NEW_LINE cache2 = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cache1 [ s [ i ] - ' a ' ] += 1 NEW_LINE cache2 [ t [ i ] - ' a ' ] += 1 NEW_LINE DEDENT flag = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if cache1 [ i ] != cache2 [ i ] : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT s1 = s . split ( ) NEW_LINE s2 = t . split ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s1 [ i ] == s2 [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT pos = - 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if s1 [ j ] == s2 [ i ] : NEW_LINE INDENT pos = j NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( pos - 1 , i , - 1 ) : NEW_LINE INDENT l . append ( j ) NEW_LINE temp = s1 [ j + 1 ] NEW_LINE s1 [ j + 1 ] = s1 [ j ] NEW_LINE s1 [ j ] = temp NEW_LINE DEDENT s1 [ i ] = s2 [ i ] NEW_LINE DEDENT print ( len ( l ) ) NEW_LINE for x in l : NEW_LINE INDENT print ( ( x + 1 ) , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT sum = ( a + b ) NEW_LINE product = ( a * b ) NEW_LINE assert simplify ( ( sum + product ) / ( sum + product ) ) == 0 NEW_LINE DEDENT
def pythontools . solution ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 NEW_LINE b = - 2 * y1 NEW_LINE c = ( r ** 2 ) - ( x1 ** 2 ) - ( y1 ** 2 ) NEW_LINE print ( ' x ^ 2 ▁ + ▁ ( % f ▁ x ) ▁ + ▁ ' % a ) NEW_LINE print ( ' y ^ 2 ▁ + ▁ ( % f ▁ y ) ▁ = ▁ ' % b ) NEW_LINE print ( c , ' . ' ) NEW_LINE DEDENT
def test_GFG ( l , sum , K , local , A ) : NEW_LINE INDENT if sum == K : NEW_LINE INDENT print ( ' { ' ) NEW_LINE for i in local : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT print ( ' ▁ ' ) NEW_LINE DEDENT print ( i ) NEW_LINE if i != len ( local ) - 1 : NEW_LINE INDENT print ( ' , ▁ ' ) NEW_LINE DEDENT DEDENT print ( ' } ' ) NEW_LINE return NEW_LINE DEDENT for i in range ( l , len ( A ) ) : NEW_LINE INDENT if sum + A [ i ] > K : NEW_LINE INDENT continue NEW_LINE DEDENT if i == 1 and A [ i ] == A [ i - 1 ] and i > l : NEW_LINE INDENT continue NEW_LINE DEDENT local . append ( A [ i ] ) NEW_LINE unique_combination ( i + 1 , sum + A [ i ] , K , local , A ) NEW_LINE local . pop ( - 1 ) NEW_LINE DEDENT DEDENT
def demo1 ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( sys . argv [ i ] ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE q = sys . argv [ 1 ] NEW_LINE for j in range ( q ) : NEW_LINE INDENT x = sys . argv [ 2 ] NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE m = 0 NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if x >= arr [ m ] : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT print ( l ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys , re NEW_LINE import string NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE import re NEW_LINE
def GFG ( a , b , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return ( a & 1 ) == 1 and True or False NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return ( b & 1 ) == 1 and True or False NEW_LINE DEDENT if ( a & 1 ) == 0 : NEW_LINE INDENT if ( b & 1 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 3 != 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) == 0 : NEW_LINE INDENT return ( ( n - 1 ) % 3 != 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) % 3 != 0 ) NEW_LINE DEDENT DEDENT DEDENT
def test_numpy_array_inequality_1 ( ) : NEW_LINE INDENT import numpy as np NEW_LINE for dtype in [ np . float32 , np . float64 ] : NEW_LINE INDENT a = np . arange ( 10 ) NEW_LINE b = np . arange ( 10 ) NEW_LINE if a == 0 : NEW_LINE INDENT break NEW_LINE DEDENT assert_equal ( intbv ( 0 , size = a // 2 + 1 ) [ 0 ] , b ) NEW_LINE DEDENT DEDENT
def GFG ( a , n ) : NEW_LINE INDENT dp = [ ] NEW_LINE if n == 1 : NEW_LINE INDENT dp . append ( max ( 0 , a [ 0 ] ) ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT dp . append ( max ( 0 , a [ 0 ] ) ) NEW_LINE dp . append ( max ( a [ 1 ] , dp [ 0 ] ) ) NEW_LINE DEDENT elif n >= 3 : NEW_LINE INDENT dp . append ( max ( 0 , a [ 0 ] ) ) NEW_LINE dp . append ( max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) ) NEW_LINE dp . append ( max ( a [ 2 ] , max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) ) ) NEW_LINE i = 3 NEW_LINE while i < n : NEW_LINE INDENT dp . append ( max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return dp [ - 1 ] NEW_LINE DEDENT
def sleuth ( ) : NEW_LINE INDENT import sys NEW_LINE question = sys . stdin . readline ( ) . strip ( ) NEW_LINE original_q = question [ : - 1 ] . strip ( ) NEW_LINE ch = original_q [ - 1 ] NEW_LINE vowels = [ ' A ' , ' E ' , ' I ' , ' O ' , ' U ' , ' Y ' ] NEW_LINE b = any ( e . lower ( ) in ch for e in vowels ) NEW_LINE print ( b ) NEW_LINE DEDENT
def import ( n , k ) : NEW_LINE INDENT """ STRNEWLINE ▁ Import ▁ a ▁ solution ▁ to ▁ the ▁ given ▁ number ▁ of ▁ k ▁ and ▁ k ▁ from ▁ the ▁ given ▁ number ▁ of ▁ n . STRNEWLINE ▁ """ NEW_LINE mini = sys . maxint NEW_LINE for i in range ( 1 , n * i + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT fir = i NEW_LINE sec = n // i NEW_LINE num1 = fir * k + sec NEW_LINE res = ( num1 // k ) * ( num1 % k ) NEW_LINE if res == n : NEW_LINE INDENT mini = min ( num1 , mini ) NEW_LINE DEDENT num2 = sec * k + fir NEW_LINE res = ( num2 // k ) * ( num2 % k ) NEW_LINE if res == n : NEW_LINE INDENT mini = min ( num2 , mini ) NEW_LINE DEDENT DEDENT DEDENT return mini NEW_LINE DEDENT
def C ( ) : NEW_LINE INDENT C = sys . maxsize NEW_LINE for this_case in range ( 1 , C + 1 ) : NEW_LINE INDENT print ( " Case ▁ # % d : ▁ % d % n " % ( this_case , largestCircle ( ) ) ) NEW_LINE DEDENT def largestCircle ( ) : NEW_LINE INDENT N = len ( C ) NEW_LINE bff = [ C [ i ] for i in range ( N ) ] NEW_LINE status = [ - 2 ] * N NEW_LINE chain_length = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT status [ i ] = - 1 NEW_LINE chain_length [ i ] = 0 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if bff [ bff [ i ] ] == i : NEW_LINE INDENT status [ i ] = - 1 NEW_LINE DEDENT DEDENT max_loop_size = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if status [ i ] != - 1 : NEW_LINE INDENT current = bff [ i ] NEW_LINE status [ i ] = i NEW_LINE steps = 1 NEW_LINE done = False NEW_LINE while not done : NEW_LINE INDENT if current == i : NEW_LINE INDENT if steps > max_loop_size : NEW_LINE INDENT max_loop_size = steps NEW_LINE DEDENT done = True NEW_LINE DEDENT elif status [ current ] == i : NEW_LINE INDENT done = True NEW_LINE DEDENT elif status [ current ] == - 1 : NEW_LINE INDENT if steps > chain_length [ current ] : NEW_LINE INDENT chain_length [ current ] = steps NEW_LINE DEDENT done = True NEW_LINE DEDENT else : NEW_LINE INDENT steps += 1 NEW_LINE status [ current ] = i NEW_LINE current = bff [ current ] NEW_LINE DEDENT DEDENT DEDENT DEDENT franken_circle = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if status [ i ] == - 1 : NEW_LINE INDENT franken_circle += ( chain_length [ i ] + 1 ) NEW_LINE DEDENT DEDENT return max ( franken_circle , max_loop_size ) NEW_LINE DEDENT
def py2exe_version ( ) : NEW_LINE INDENT class solution ( object ) : NEW_LINE INDENT def __init__ ( self , CP , PP ) : NEW_LINE INDENT P_decimal = 1 + ( PP / 100 ) NEW_LINE res = P_decimal * CP NEW_LINE DEDENT def __mod__ ( self , C ) : NEW_LINE INDENT return C % P NEW_LINE DEDENT def __floordiv__ ( self , C ) : NEW_LINE INDENT return C / P NEW_LINE DEDENT def __truediv__ ( self , C ) : NEW_LINE INDENT return C / P NEW_LINE DEDENT def __mod__ ( self , C ) : NEW_LINE INDENT return C % P NEW_LINE DEDENT DEDENT return solution NEW_LINE DEDENT
def pyc_test ( ) : NEW_LINE INDENT import sys NEW_LINE t , j , i , n , p1 , p2 , c , p [ 0 ] = sys . argv [ 1 ] , sys . argv [ 2 ] , sys . argv [ 3 ] , sys . argv [ 4 ] NEW_LINE t = t [ 0 ] NEW_LINE for j in range ( 1 , t + 1 ) : NEW_LINE INDENT n = n [ 0 ] NEW_LINE p = [ i for i in range ( n + 5 ) ] NEW_LINE p1 = p2 = p [ 1 ] NEW_LINE print ( 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = p [ i ] NEW_LINE if c > p2 : NEW_LINE INDENT p2 = c NEW_LINE DEDENT elif c < p1 : NEW_LINE INDENT p1 = c NEW_LINE DEDENT if ( p2 - p1 ) == i - 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import math NEW_LINE n = math . floor ( math . log ( n ) ) NEW_LINE s = math . ceil ( math . log ( n ) ) NEW_LINE if n < s : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for d in range ( 39 , 1 , - 1 ) : NEW_LINE INDENT b = lower_bound ( d , n ) NEW_LINE while d * math . log ( b ) <= math . log ( n ) : NEW_LINE INDENT if test ( b , n , s ) : NEW_LINE INDENT print ( b ) NEW_LINE return NEW_LINE DEDENT b += 1 NEW_LINE DEDENT DEDENT for a1 in range ( int ( math . sqrt ( n - s ) ) , 1 , - 1 ) : NEW_LINE INDENT if ( n - s ) % a1 == 0 : NEW_LINE INDENT b = ( n - s ) // a1 + 1 NEW_LINE a0 = n - a1 * b NEW_LINE if a0 >= 0 and a0 < b and a0 + a1 == s : NEW_LINE INDENT print ( b ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if n == s : NEW_LINE INDENT print ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def test_B ( ) : NEW_LINE INDENT x = symbols ( ' x ' , real = True ) NEW_LINE m = symbols ( ' m ' , integer = True , positive = True ) NEW_LINE b = symbols ( ' b ' , integer = True , positive = True ) NEW_LINE result = 0 NEW_LINE for x in range ( 1 , m * b + 1 ) : NEW_LINE INDENT y = symbols ( ' y ' , integer = True , positive = True ) NEW_LINE result = max ( result , 1 * ( x + 1 ) * ( y ) ** ( y + 1 ) / 2 + 1 * ( y + 1 ) * ( x ) ** ( x + 1 ) / 2 ) NEW_LINE DEDENT assert result == 0 NEW_LINE class MyScanner ( Scanner ) : NEW_LINE INDENT def scan ( self , x ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT class MyIterator ( Iterator ) : NEW_LINE INDENT def __next__ ( self ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT class MyIterator ( Iterator ) : NEW_LINE INDENT def scan ( self , x ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT next = MyIterator ( ) NEW_LINE while not next ( ) or not next ( ) : NEW_LINE INDENT try : NEW_LINE INDENT next ( ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE assert next ( ) == x NEW_LINE DEDENT
def GFG ( n , m ) : NEW_LINE INDENT if m % n == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def main ( argv ) : NEW_LINE INDENT f = open ( ' / etc / elementos / ' , ' r ' ) NEW_LINE cantidad = f . readline ( ) NEW_LINE solucion = [ ] NEW_LINE for i in range ( int ( cantidad ) ) : NEW_LINE INDENT cantidadfor = f . readline ( ) NEW_LINE cantidadelementos = int ( cantidadfor ) NEW_LINE elementos_s = f . readline ( ) . split ( ) NEW_LINE elementos = [ int ( element ) for element in elementos_s ] NEW_LINE for j in range ( cantidadelementos ) : NEW_LINE INDENT centinela = False NEW_LINE for k in range ( cantidadelementos - 1 , - 1 , - 1 ) : NEW_LINE INDENT if elementos [ j ] == elementos [ k ] and k - j >= 2 : NEW_LINE INDENT solucion . append ( ' YES ' ) NEW_LINE break NEW_LINE DEDENT DEDENT if centinela : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( solucion ) ) : NEW_LINE INDENT if solucion [ i ] == None : NEW_LINE INDENT solucion [ i ] = ' NO ' NEW_LINE DEDENT DEDENT for i in range ( len ( solucion ) ) : NEW_LINE INDENT print ( solucion [ i ] ) NEW_LINE DEDENT DEDENT
def pytime_object_to_timeval ( * args , ** kw ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE a = sys . argv [ 1 ] NEW_LINE b = sys . argv [ 2 ] NEW_LINE c = [ ] NEW_LINE s = sys . stdin . read ( a ) NEW_LINE c = s . split ( ' \n ' ) NEW_LINE ch = [ chr ( ord ( ' a ' ) + i ) for i in range ( 26 ) ] NEW_LINE for i in range ( b ) : NEW_LINE INDENT m = sys . stdin . readline ( ) NEW_LINE n = sys . stdin . readline ( ) NEW_LINE mm = m [ 0 ] NEW_LINE nn = n [ 0 ] NEW_LINE flag = 1 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if ch [ j ] == mm and flag == 1 : NEW_LINE INDENT ch [ j ] = nn NEW_LINE flag = 0 NEW_LINE DEDENT if ch [ j ] == nn and flag == 1 : NEW_LINE INDENT ch [ j ] = mm NEW_LINE flag = 0 NEW_LINE DEDENT flag = 1 NEW_LINE DEDENT DEDENT for i in range ( a ) : NEW_LINE INDENT c . append ( ch [ c [ i ] - 97 ] ) NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ findnth ▁ function . """ NEW_LINE occur = 0 NEW_LINE for c in str ( G ) : NEW_LINE INDENT if c == ch : occur += 1 NEW_LINE if occur == N : return c NEW_LINE DEDENT DEDENT
def mu_hand_sticks ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE sticks = [ ] NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT sticks . append ( s [ - 1 ] ) NEW_LINE DEDENT legs , headbody = False , False NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if sticks [ i ] >= 4 : NEW_LINE INDENT legs = True NEW_LINE DEDENT if sticks [ i ] >= 6 : NEW_LINE INDENT headbody = True NEW_LINE DEDENT if sticks [ i ] == 2 : NEW_LINE INDENT headbody = True NEW_LINE DEDENT DEDENT if legs and headbody : NEW_LINE INDENT return " Elephant " NEW_LINE DEDENT elif legs : NEW_LINE INDENT return " Bear " NEW_LINE DEDENT else : NEW_LINE INDENT return " Alien " NEW_LINE DEDENT DEDENT
def p_p401 ( p ) : NEW_LINE INDENT """ p401 ▁ : ▁ INTEGER """ NEW_LINE p [ 0 ] = int ( p [ 1 ] ) NEW_LINE DEDENT def test_sum ( limit ) : NEW_LINE INDENT assert p [ 0 ] == limit NEW_LINE DEDENT LIMIT = 1000000000000000.0 NEW_LINE MODULUS = library . pow ( 10 , 9 ) NEW_LINE split_count = int ( library . sqrt ( LIMIT ) ) NEW_LINE split_count = max ( split_count // 3 , 1 ) NEW_LINE split_at = int ( LIMIT / ( split_count + 1 ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , split_at + 1 ) : NEW_LINE INDENT count = LIMIT / i % MODULUS NEW_LINE term = int ( i ) * i % MODULUS NEW_LINE term = term * count % MODULUS NEW_LINE sum = ( sum + term ) % MODULUS NEW_LINE DEDENT for i in range ( split_count , - 1 , - 1 ) : NEW_LINE INDENT start = LIMIT / ( i + 1 ) NEW_LINE end = LIMIT / i NEW_LINE sum_squares = sum_squares_mod ( end ) - sum_squares_mod ( start ) NEW_LINE sum_squares = ( sum_squares + MODULUS ) % MODULUS NEW_LINE sum = ( sum + i * sum_squares % MODULUS ) % MODULUS NEW_LINE DEDENT return str ( sum ) NEW_LINE DEDENT
def test_code_forces1389B ( ) : NEW_LINE INDENT input = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 ]
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global a NEW_LINE global r NEW_LINE flag = False NEW_LINE isTrue = False NEW_LINE for o , a in getopt . getopt ( sys . argv [ 1 : ] , " a " ) : NEW_LINE INDENT if o == ' - a ' : NEW_LINE INDENT a = a . split ( ) NEW_LINE DEDENT elif o == ' - r ' : NEW_LINE INDENT r = a . split ( ) NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a . split ( ) NEW_LINE DEDENT elif o == ' - - r ' : NEW_LINE INDENT r = a . split ( ) NEW_LINE DEDENT elif o == ' - - flag ' : NEW_LINE INDENT flag = True NEW_LINE DEDENT elif o == ' - - isTrue ' : NEW_LINE INDENT isTrue = True NEW_LINE DEDENT DEDENT print ( ( not isTrue ) and l or r ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE b = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT for k , h , m in divmod ( i , 2 ) : NEW_LINE INDENT b . append ( h * 60 + m ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE for p in range ( n ) : NEW_LINE INDENT if b [ p ] [ 0 ] <= b [ i ] [ 0 ] <= b [ i ] [ 0 ] and b [ i ] [ 0 ] <= b [ p ] [ 0 ] and b [ p ] [ 1 ] <= b [ j ] [ 1 ] and b [ j ] [ 1 ] <= b [ p ] [ 1 ] and b [ p ] [ 2 ] <= b [ k ] [ 2 ] and b [ k ] [ 2 ] <= b [ p ] [ 2 ] ) : NEW_LINE INDENT res += 1 ; NEW_LINE DEDENT DEDENT DEDENT ans = max ( ans , res ) ; NEW_LINE DEDENT print ( ans ) ; NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' a ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ aoj1159 ▁ [ - - a ] ▁ [ - - a ] ▁ [ - - a ] ▁ [ - - a ] ▁ [ - - a ] """ ) NEW_LINE return NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - a ' : NEW_LINE INDENT a = a NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a - 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT elif o == ' - - a ' : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Unknown ▁ option : ▁ ' % s ' " % o ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT my_func = my_enumerate NEW_LINE n = len ( my_func ) NEW_LINE q = len ( my_func ) NEW_LINE a = [ my_func [ i ] for i in range ( n ) ] NEW_LINE f = open ( ' / proc / meminfo ' , ' w ' ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT x = my_func [ i ] NEW_LINE cnt = 0 NEW_LINE right = 0 NEW_LINE sum = 0 NEW_LINE for left in range ( n ) : NEW_LINE INDENT while right < n and sum + a [ right ] <= x : NEW_LINE INDENT sum += a [ right ] NEW_LINE DEDENT cnt += right - left NEW_LINE if right == left : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= a [ left ] NEW_LINE DEDENT DEDENT f . write ( cnt ) NEW_LINE DEDENT f . close ( ) NEW_LINE class MyScanner : NEW_LINE INDENT def __init__ ( self , f , 1 << 15 ) : NEW_LINE INDENT self . f = f NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT while not self . f or not self . f . next ( ) : NEW_LINE INDENT self . f . next ( ) NEW_LINE DEDENT DEDENT except StopIteration : NEW_LINE INDENT pass NEW_LINE DEDENT return self . f . next ( ) NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return iter ( self . f ) NEW_LINE DEDENT def __next__ ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT while self . f . next ( ) or not self . f . next ( ) : NEW_LINE INDENT self . f . next ( ) NEW_LINE DEDENT DEDENT except StopIteration : NEW_LINE INDENT pass NEW_LINE DEDENT return self . f . next ( ) NEW_LINE DEDENT def __nonzero__ ( self ) : NEW_LINE INDENT return self . f . next ( ) NEW_LINE DEDENT def __bool__ ( self ) : NEW_LINE INDENT return self . f . next ( ) NEW_LINE DEDENT DEDENT my_func = my_enumerate NEW_LINE my_func = my_enumerate ( ) NEW_LINE f = MyScanner ( f , 1 << 15 ) NEW_LINE f . next ( ) NEW_LINE f . close ( ) NEW_LINE DEDENT
def test_code_force_1409_a ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE a , b = symbols ( ' a ▁ b ' , integer = True , positive = True ) NEW_LINE for i in range ( t . size ) : NEW_LINE INDENT a , b = symbols ( ' a ▁ b ' , integer = True , positive = True ) NEW_LINE counter = 0 NEW_LINE if a < b : NEW_LINE INDENT counter = ( b - a ) / 10 NEW_LINE DEDENT elif a > b : NEW_LINE INDENT counter = ( a - b ) / 10 NEW_LINE DEDENT if a % 10 != b % 10 : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT assert counter == 0 NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT max_size = int ( 1e5 + 5 ) NEW_LINE is_fib = [ False ] * max_size NEW_LINE prefix = [ 0 ] * max_size NEW_LINE def digitsum ( num ) : NEW_LINE INDENT s = 0 NEW_LINE while num != 0 : NEW_LINE INDENT s = s + num % 10 NEW_LINE num = num / 10 NEW_LINE DEDENT return s NEW_LINE DEDENT def generate_fibonacci ( ) : NEW_LINE INDENT del is_fib [ 0 ] NEW_LINE prev , curr = 0 , 1 NEW_LINE is_fib [ prev ] = is_fib [ curr ] = True NEW_LINE while curr < max_size : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp < max_size : NEW_LINE INDENT is_fib [ temp ] = True NEW_LINE DEDENT prev , curr = temp NEW_LINE DEDENT DEDENT def precompute ( k ) : NEW_LINE INDENT generate_fibonacci ( ) NEW_LINE for i in range ( 1 , max_size ) : NEW_LINE INDENT sum = digitsum ( i ) NEW_LINE if is_fib [ sum ] == True and sum % k == 0 : NEW_LINE INDENT prefix [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , max_size ) : NEW_LINE INDENT prefix [ i ] = prefix [ i ] + prefix [ i - 1 ] NEW_LINE DEDENT DEDENT def perform_queries ( k , q , * query ) : NEW_LINE INDENT precompute ( k ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l , r = query [ i ] NEW_LINE cnt = prefix [ r ] - prefix [ l - 1 ] NEW_LINE print ( cnt , end = ' ' ) NEW_LINE DEDENT DEDENT def test_gf_gf_list ( ) : NEW_LINE INDENT for i in range ( 2 , len ( query ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( query ) ) : NEW_LINE INDENT for k in range ( 2 , len ( query ) ) : NEW_LINE INDENT for l in range ( j + 1 , len ( query ) ) : NEW_LINE INDENT for r in range ( j + 1 , len ( query ) ) : NEW_LINE INDENT for i in range ( j + 1 , len ( query ) ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT test_gf_gf_list ( ) NEW_LINE DEDENT
def test_a1642 ( ) : NEW_LINE INDENT X = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE T = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE for t in T : NEW_LINE INDENT X = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE Y = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE answer = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if Y [ i ] == Y [ ( i + 1 ) % 3 ] and Y [ i ] > Y [ ( i + 2 ) % 3 ] : NEW_LINE INDENT answer += abs ( X [ ( i + 1 ) % 3 ] - X [ i ] ) NEW_LINE DEDENT DEDENT assert_array_equal ( answer , [ 1 , 2 , 3 , 4 ] ) NEW_LINE DEDENT DEDENT
def GFG ( str ) : NEW_LINE INDENT len = len ( str ) NEW_LINE for i in range ( len ( str ) / 2 ) : NEW_LINE INDENT if str [ i ] != str [ len - 1 - i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n NEW_LINE global array NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = getopt . getopt ( sys . argv [ 1 : ] , " s : h : " ) NEW_LINE a = 0 NEW_LINE if s == ' S ' : NEW_LINE INDENT array = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if s == ' H ' : NEW_LINE INDENT array . append ( 1 ) NEW_LINE DEDENT elif s == ' C ' : NEW_LINE INDENT array . append ( 2 ) NEW_LINE DEDENT elif s == ' D ' : NEW_LINE INDENT array . append ( 3 ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if array [ i ] [ 0 ] == 0 and i == 0 : NEW_LINE INDENT print ( " S ▁ " + str ( i + 1 ) ) NEW_LINE DEDENT elif array [ i ] [ 0 ] == 0 and i == 1 : NEW_LINE INDENT print ( " H ▁ " + str ( i + 1 ) ) NEW_LINE DEDENT elif array [ i ] [ 0 ] == 0 and i == 2 : NEW_LINE INDENT print ( " C ▁ " + str ( i + 1 ) ) NEW_LINE DEDENT elif array [ i ] [ 0 ] == 0 and i == 3 : NEW_LINE INDENT print ( " D ▁ " + str ( i + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ Sum ▁ of ▁ even ▁ numbers . """ NEW_LINE i , sum = 0 , 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT assert sum == 0 NEW_LINE DEDENT
def test_codechef ( ) : NEW_LINE INDENT import sympy NEW_LINE from sympy . core . function import Function NEW_LINE T = symbols ( ' T ' , integer = True , positive = True ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT s = sympy . sin ( i ) NEW_LINE f = Function ( ' f ' ) NEW_LINE if f . is_Piecewise : NEW_LINE INDENT assert f ( i ) . is_Piecewise NEW_LINE continue NEW_LINE DEDENT count = 1 NEW_LINE a = True NEW_LINE for j in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ j ] == s [ j + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if count == 1 : NEW_LINE INDENT a = False NEW_LINE break NEW_LINE DEDENT elif j == len ( s ) - 2 : NEW_LINE INDENT a = False NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE DEDENT DEDENT DEDENT if a is True : NEW_LINE INDENT assert f ( i ) . is_Piecewise NEW_LINE DEDENT else : NEW_LINE INDENT assert f ( i ) . is_Piecewise NEW_LINE DEDENT DEDENT DEDENT
def pyGFG ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE fl = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ arr [ i ] % n ] >= n : NEW_LINE INDENT if arr [ arr [ i ] % n ] < 2 * n : NEW_LINE INDENT print ( arr [ i ] % n , end = ' ▁ ' ) NEW_LINE fl = 1 NEW_LINE DEDENT DEDENT arr [ arr [ i ] % n ] += n NEW_LINE DEDENT if not ( fl > 0 ) : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT
def test_cf1293b ( ) : NEW_LINE INDENT X = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE Y = np . array ( [ 1 , 2 , 3 , 4 ] ) NEW_LINE N = 1000 NEW_LINE for method in [ ' cd ' , ' mu ' , ' ncg ' , ' mu _ ncg ' ] : NEW_LINE INDENT for data in ( X , Y , N ) : NEW_LINE INDENT res = getattr ( manifold . cf1293b , method ) ( data ) NEW_LINE if res . shape [ 1 ] == 2 : NEW_LINE INDENT assert res . shape [ 0 ] == 2 NEW_LINE DEDENT assert res . shape [ 1 ] == 3 NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) / 3 NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) / 2 NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) / 2 NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 4 == 0 : NEW_LINE INDENT return n // 4 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n & 1 ) == 1 : NEW_LINE INDENT return 1 + CountSetBits ( n >> 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return CountSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT
def GFG ( m , n ) : NEW_LINE INDENT return 8 * m ** n - 6 * m - 6 * n + 4 NEW_LINE DEDENT
def GFG ( n , m ) : NEW_LINE INDENT if m == 1 : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT sum = SUM ( n , m - 1 ) NEW_LINE return ( sum * ( sum + 1 ) / 2 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE assert max_lcm_poly ( n ) == ( n ** 2 - 1 ) / 2 NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ** 2 ) / 12 NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) // 4 NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT print ( 9 * n , 8 * n ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( n & 1 ) > 0 NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT return ( n ) * ( n - 1 ) / 2 NEW_LINE DEDENT
def class Solution ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n + 1 ) + sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT n = 48 NEW_LINE assert n == highestPowerOf2 ( n ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 3 NEW_LINE assert count_intersections ( n ) == 0 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s = sys . stdin . read ( ) NEW_LINE sys . stdin . close ( ) NEW_LINE c = " None " NEW_LINE for i in [ ' a ' , ' z ' ] : NEW_LINE INDENT if not s . find ( " % c " % chr ( i ) ) : NEW_LINE INDENT c = " % c " % chr ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT sys . stdout . write ( c ) NEW_LINE DEDENT
def test_a1581 ( ) : NEW_LINE INDENT f = py . io . TextIO ( ) NEW_LINE f . write ( " hello \n " ) NEW_LINE n = len ( f . getvalue ( ) ) NEW_LINE arr = [ i for i in f . getvalue ( ) . split ( " \n " ) if i ] NEW_LINE arr . sort ( ) NEW_LINE if arr [ 0 ] == 1 : NEW_LINE INDENT f . write ( 1 ) NEW_LINE f . close ( ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT f . write ( arr [ 0 ] ) NEW_LINE f . close ( ) NEW_LINE return NEW_LINE DEDENT DEDENT yes = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] % arr [ 0 ] != 0 : NEW_LINE INDENT yes = False NEW_LINE break NEW_LINE DEDENT DEDENT if yes : NEW_LINE INDENT f . write ( arr [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT f . write ( - 1 ) NEW_LINE DEDENT f . close ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE print ( 1200 > sys . argv [ 1 ] ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global max_element_value NEW_LINE global elements NEW_LINE elements = list ( sys . stdin . readline ( ) . split ( ) ) NEW_LINE right_distance = [ max_element_value ] * len ( elements ) + 1 NEW_LINE left_distance = [ max_element_value ] * len ( elements ) + 1 NEW_LINE for i in range ( len ( right_distance ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT if elements [ i ] == 0 : NEW_LINE INDENT right_distance [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_distance [ i ] = right_distance [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT for j in range ( 1 , len ( left_distance ) ) : NEW_LINE INDENT if elements [ j - 1 ] == 0 : NEW_LINE INDENT left_distance [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT left_distance [ j ] = left_distance [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( len ( elements ) ) : NEW_LINE INDENT print ( min ( right_distance [ i ] , left_distance [ i + 1 ] ) ) NEW_LINE if i + 1 < len ( elements ) : NEW_LINE INDENT print ( " ▁ " . join ( [ str ( x ) for x in elements [ i + 1 ] ] ) ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while x != 0 and y != 0 and z != 0 : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def pyc_main ( ) : NEW_LINE INDENT import sys NEW_LINE c1 = sys . argv [ 1 ] NEW_LINE c5 = sys . argv [ 2 ] NEW_LINE c10 = sys . argv [ 3 ] NEW_LINE c50 = sys . argv [ 4 ] NEW_LINE c100 = sys . argv [ 5 ] NEW_LINE c500 = sys . argv [ 6 ] NEW_LINE if c1 + c5 * 5 + c10 * 10 + c50 * 50 + c100 * 100 + c500 * 500 < 1000 : NEW_LINE INDENT print ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '1' ) NEW_LINE DEDENT DEDENT
def another ( ) : NEW_LINE INDENT f = FastReader ( ) NEW_LINE f . write ( ' % .12f \n ' % ( 2 + 2. * ( m - 1 ) * m ** 2 / 3 / m / m - 2 * ( 2 - sqrt ( 2 ) ) + ( 2 - sqrt ( 2 ) ) * ( 2 * m + 2 * ( m - 1 ) ) / m / m ) * R ) NEW_LINE f . flush ( ) NEW_LINE f . close ( ) NEW_LINE class Another ( object ) : NEW_LINE INDENT def __init__ ( self , f ) : NEW_LINE INDENT self . f = f NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT if self . f . readline ( ) == ' ' or not self . f . readline ( ) : NEW_LINE INDENT self . f . readline ( ) NEW_LINE DEDENT return self . f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT if self . f . readline ( ) == ' ' or not self . f . readline ( ) : NEW_LINE INDENT self . f . readline ( ) NEW_LINE DEDENT return self . f . readline ( ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT if self . f . readline ( ) == ' ' or not self . f . readline ( ) : NEW_LINE INDENT self . f . readline ( ) NEW_LINE DEDENT return self . f . readline ( ) NEW_LINE DEDENT DEDENT return Another NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE assert count_cubes ( [ 1 , 2 , 3 ] ) == ( 1 , 2 ) NEW_LINE
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout . write ( msg + ' \n ' ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT D = int ( opts [ 0 ] ) NEW_LINE N = int ( opts [ 1 ] ) NEW_LINE if ( D | N ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ ] NEW_LINE e = [ ] NEW_LINE r = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT aa = int ( opts [ 0 ] ) NEW_LINE ee = int ( opts [ 1 ] ) NEW_LINE rr = int ( opts [ 2 ] ) NEW_LINE a . append ( aa ) NEW_LINE e . append ( ee ) NEW_LINE r . append ( rr ) NEW_LINE DEDENT dp = [ INF ] * 101 NEW_LINE for d in dp : NEW_LINE INDENT del dp [ d ] NEW_LINE DEDENT dp [ D ] = 0 NEW_LINE for i in range ( D , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , 100 ) : NEW_LINE INDENT if dp [ i ] [ j ] == INF : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( 0 , N ) : NEW_LINE INDENT if j < r [ k ] : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ max ( 0 , i - a [ k ] ) ] [ min ( 100 , j + e [ k ] ) ] = min ( dp [ max ( 0 , i - a [ k ] ) ] [ min ( 100 , j + e [ k ] ) ] , dp [ i ] [ j ] + 1 ) ] NEW_LINE DEDENT DEDENT DEDENT ret = INF NEW_LINE for i in range ( 101 ) : NEW_LINE INDENT ret = min ( ret , dp [ 0 ] [ i ] ) NEW_LINE DEDENT print ( ret if ret else ' NA ' ) NEW_LINE DEDENT
def p012 ( cls ) : NEW_LINE INDENT return cls ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a , b , c , d = symbols ( ' a ▁ b ▁ c ▁ d ' , cls = Dummy ) NEW_LINE assert ( b * c - a * d ) / ( d - c ) == a * b * c - a * c * d NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT isPrime = [ False ] * n NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , n * p + 1 ) : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , n + p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return isPrime NEW_LINE DEDENT
def GFG ( x , d1 , d2 ) : NEW_LINE INDENT result , multiply = 0 , 1 NEW_LINE while x % 10 : NEW_LINE INDENT remainder = x % 10 NEW_LINE if remainder == d1 : NEW_LINE INDENT result = result + d2 * multiply NEW_LINE DEDENT else : NEW_LINE INDENT result = result + remainder * multiply NEW_LINE DEDENT multiply *= 10 NEW_LINE x = x / 10 NEW_LINE DEDENT return result , multiply NEW_LINE DEDENT
def GFG ( i , j , n ) : NEW_LINE INDENT if j >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i >= n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if j == i or j == n - 1 - i : NEW_LINE INDENT if i == n - 1 - j : NEW_LINE INDENT print ( " / " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " \\ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " * " ) NEW_LINE DEDENT if printPattern ( i , j + 1 , n ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT
def pythontag_in_list ( n , sum ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ number ▁ of ▁ pairs ▁ in ▁ the ▁ list ▁ of ▁ integers ▁ n ▁ and ▁ sum . STRNEWLINE ▁ """ NEW_LINE arr = [ 1 , 5 , 7 , - 1 , 5 ] NEW_LINE hm = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not hm . has_key ( arr [ i ] ) : NEW_LINE INDENT hm [ arr [ i ] ] = 0 NEW_LINE DEDENT hm [ arr [ i ] ] = hm [ arr [ i ] ] + 1 NEW_LINE DEDENT twice_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if hm . has_key ( sum - arr [ i ] ) : NEW_LINE INDENT twice_count += hm [ sum - arr [ i ] ] NEW_LINE DEDENT if sum - arr [ i ] == arr [ i ] : NEW_LINE INDENT twice_count -= 1 NEW_LINE DEDENT DEDENT return twice_count / 2 NEW_LINE DEDENT
def count_subarray ( arr , n ) : NEW_LINE INDENT subarray_sum , remaining_sum , count = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT subarray_sum = 0 NEW_LINE remaining_sum = 0 NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT subarray_sum += arr [ k ] NEW_LINE DEDENT for l in range ( i ) : NEW_LINE INDENT remaining_sum += arr [ l ] NEW_LINE DEDENT for l in range ( j + 1 , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] NEW_LINE DEDENT if subarray_sum > remaining_sum : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , x = divmod ( t [ i ] , 2 ) NEW_LINE a , b = divmod ( t [ i + 1 ] , 2 ) NEW_LINE times = min ( a , b ) - 1 + n - max ( a , b ) NEW_LINE if times > x : NEW_LINE INDENT print ( n - 1 - ( times - x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE N = len ( sys . argv ) NEW_LINE sum = 0 NEW_LINE a = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = sys . argv [ i ] NEW_LINE sum += tmp NEW_LINE if tmp % 10 != 0 : NEW_LINE INDENT a . append ( tmp ) NEW_LINE DEDENT DEDENT a . sort ( ) NEW_LINE i = 0 NEW_LINE while sum % 10 == 0 and i < len ( a ) : NEW_LINE INDENT sum -= a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT if sum % 10 == 0 : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def test_repainting_street ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ the ▁ repaint ▁ of ▁ a ▁ street . STRNEWLINE ▁ """ NEW_LINE G = nx . DiGraph ( ) NEW_LINE G . add_nodes_from ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 81 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 111 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , 112 , 115 , 101 , 102 , 103 , 104 , 105 , 106 , 108 , 109 , 110 , )
def find_repeating_number ( arr , n ) : NEW_LINE INDENT sq = int ( math . sqrt ( n ) ) NEW_LINE range = ( n // sq ) + 1 NEW_LINE count = [ 0 ] * range NEW_LINE for i in range : NEW_LINE INDENT count [ ( arr [ i ] - 1 ) // sq ] += 1 NEW_LINE DEDENT selected_block = range - 1 NEW_LINE for i in range - 1 : NEW_LINE INDENT if count [ i ] > sq : NEW_LINE INDENT selected_block = i NEW_LINE break NEW_LINE DEDENT DEDENT m = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( selected_block * sq ) < arr [ i ] ) : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE if m [ arr [ i ] ] == 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 15. NEW_LINE assert max_prime ( n ) == 15. NEW_LINE assert max_prime ( n ) == 25698751364526. NEW_LINE assert max_prime ( n ) == 25698751364526. NEW_LINE assert max_prime ( n ) == 25698751364526. NEW_LINE assert max_prime ( n ) == 25698751364526. NEW_LINE assert max_prime ( n ) == 25698751364526. NEW_LINE assert max_prime ( n ) == 25698751364526. NEW_LINE assert max_prime ( n ) == 25698751364526. NEW_LINE assert max_prime ( n ) == 25698751364526. NEW_LINE DEDENT
def pythons ( a ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ a ▁ list ▁ of ▁ the ▁ beats ▁ of ▁ the ▁ given ▁ number . STRNEWLINE ▁ """ NEW_LINE return [ a [ i ] for i in range ( 0 , len ( a ) , 2 ) ] NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE s1 = sys . stdin . read ( ) . split ( ' \n ' ) NEW_LINE ans = 0 NEW_LINE c1 = 0 NEW_LINE c0 = 0 NEW_LINE for line in s1 : NEW_LINE INDENT if line == '1' : NEW_LINE INDENT if c0 > 0 : NEW_LINE INDENT c0 -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if c1 > 0 : NEW_LINE INDENT c1 -= 1 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c0 += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans * 2 ) NEW_LINE DEDENT
def GFG ( arg ) : NEW_LINE INDENT for i in range ( 1 , n // 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n // 2 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if i * i + j * j == k * k : NEW_LINE INDENT print ( i , j , k ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( ' No ▁ Triplet ' ) NEW_LINE DEDENT
def GFG ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return int ( math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 ) NEW_LINE DEDENT
def get_freq_of_first_one ( arr ) : NEW_LINE INDENT """ STRNEWLINE ▁ Find ▁ the ▁ frequency ▁ of ▁ the ▁ first ▁ one . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ arr ▁ : ▁ array _ like STRNEWLINE ▁ The ▁ array ▁ of ▁ frequencies . STRNEWLINE ▁ low ▁ : ▁ int STRNEWLINE ▁ The ▁ lowest ▁ index ▁ of ▁ the ▁ first ▁ one . STRNEWLINE ▁ high ▁ : ▁ int STRNEWLINE ▁ The ▁ highest ▁ index ▁ of ▁ the ▁ first ▁ one . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ freq ▁ : ▁ int STRNEWLINE ▁ The ▁ frequency ▁ of ▁ the ▁ first ▁ one . STRNEWLINE STRNEWLINE ▁ Notes STRNEWLINE ▁ - - - - - STRNEWLINE ▁ For ▁ more ▁ details ▁ on ▁ the ▁ formula ▁ in ▁ ` ` F ( arr ) ` ` . STRNEWLINE STRNEWLINE ▁ """ NEW_LINE l , h = 0 , 1 NEW_LINE while arr [ h ] == 0 : NEW_LINE INDENT l , h = h , 2 * h NEW_LINE DEDENT return l , h NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n NEW_LINE global sum , total , i NEW_LINE if n == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT while n > 0 : NEW_LINE INDENT n -= 1 NEW_LINE if n > 0 : NEW_LINE INDENT if n >= 2 : NEW_LINE INDENT total += 1 NEW_LINE DEDENT n -= 2 NEW_LINE DEDENT total += 1 NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT num = 0 NEW_LINE f = sys . stdin NEW_LINE d = None NEW_LINE while True : NEW_LINE INDENT num = f . readline ( ) NEW_LINE if num < 0 : NEW_LINE INDENT break NEW_LINE DEDENT d = Doctor ( num ) NEW_LINE if d . judge ( ) : NEW_LINE INDENT print ( d . getBD ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NA ' ) NEW_LINE DEDENT DEDENT class Doctor : NEW_LINE INDENT num = 0 NEW_LINE bd = ' ' NEW_LINE integers = 0 NEW_LINE decimals = 0 NEW_LINE def judge ( self ) : NEW_LINE INDENT if self . integers > 255 or self . decimals > 0.9375 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def to_binary_digits ( self ) : NEW_LINE INDENT tmp = ' ' NEW_LINE count = 1 NEW_LINE for i in self . integers : NEW_LINE INDENT tmp += i % 2 NEW_LINE DEDENT s = ' ' NEW_LINE for i in range ( 8 - len ( tmp ) ) : NEW_LINE INDENT bd += '0' NEW_LINE DEDENT bd += s . reverse ( ) . rstrip ( ' . ' ) + ' . ' NEW_LINE while True : NEW_LINE INDENT if self . decimals == 0 : NEW_LINE INDENT bd += '00' NEW_LINE break NEW_LINE DEDENT if count > 4 : NEW_LINE INDENT return False NEW_LINE DEDENT self . decimals *= 2 NEW_LINE if self . decimals >= 1 : NEW_LINE INDENT self . decimals -= 1 NEW_LINE bd += '1' NEW_LINE if self . decimals == 0 : NEW_LINE INDENT for i in range ( 4 - self . count ) : NEW_LINE INDENT bd += '0' NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . bd += '0' NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def getBD ( self ) : NEW_LINE INDENT if to_binary_digits ( self . bd ) : NEW_LINE INDENT return self . bd NEW_LINE DEDENT return ' NA ' NEW_LINE DEDENT DEDENT return Doctor ( num ) NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT sum , rem = 0 , 0 NEW_LINE while n : NEW_LINE INDENT rem = n % 10 NEW_LINE sum += rem NEW_LINE n /= 10 NEW_LINE DEDENT return sum , rem NEW_LINE DEDENT
def py ( ) : NEW_LINE INDENT import sys NEW_LINE import doctest NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE import numpy as np NEW_LINE DEDENT
def _main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE for args , opts , args in getopt . getopt ( sys . argv [ 1 : ] , ' hL : ' ) : NEW_LINE INDENT for o , a in opts : NEW_LINE INDENT if o == ' - h ' : NEW_LINE INDENT _help ( ) NEW_LINE DEDENT elif o == ' - l ' : NEW_LINE INDENT _lower ( ) NEW_LINE DEDENT elif o == ' - l ' : NEW_LINE INDENT _upper ( ) NEW_LINE DEDENT elif o == ' - l ' : NEW_LINE INDENT _lower ( ) NEW_LINE DEDENT DEDENT DEDENT return _help ( ) NEW_LINE DEDENT
def pyGFG ( arg ) : NEW_LINE INDENT class GFG ( object ) : NEW_LINE INDENT def __init__ ( self , A , q ) : NEW_LINE INDENT self . A = A NEW_LINE self . q = q NEW_LINE DEDENT def performQueries ( self , A , q ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pref_xor = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pref_xor [ i ] = pref_xor [ i - 1 ] ^ A [ i - 1 ] NEW_LINE DEDENT for i in q : NEW_LINE INDENT L , R = i NEW_LINE if L > R : NEW_LINE INDENT temp = L NEW_LINE L , R = R , temp NEW_LINE DEDENT if L != R and pref_xor [ R ] == pref_xor [ L - 1 ] : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( arg ) : NEW_LINE INDENT Arr = [ 1 , 1 , 2 , 2 , 1 ] NEW_LINE q = [ [ 1 , 5 ] , [ 1 , 4 ] , [ 3 , 4 ] ] NEW_LINE performQueries ( Arr , q ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE f = sys . stdin NEW_LINE n = len ( sys . argv ) NEW_LINE list = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT list . append ( sys . argv [ i ] ) NEW_LINE DEDENT list . sort ( ) NEW_LINE c = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if list [ i ] >= c : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT f . write ( ' % d \n ' % c ) NEW_LINE f . close ( ) NEW_LINE DEDENT
def test_b215 ( ) : NEW_LINE INDENT mp . dps = 15 NEW_LINE N = Symbol ( ' N ' ) NEW_LINE R1 = Matrix ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ) NEW_LINE M = Matrix ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ) NEW_LINE P1 = Matrix ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ) NEW_LINE P2 = Matrix ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ) NEW_LINE A = Matrix ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ) NEW_LINE B = Matrix ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ) NEW_LINE max_R1 = 0 NEW_LINE for r1 in R1 : NEW_LINE INDENT max_R1 = max ( max_R1 , r1 ) NEW_LINE DEDENT max_P1 = 0 NEW_LINE for p1 in P1 : NEW_LINE INDENT max_P1 = max ( max_P1 , p1 ) NEW_LINE DEDENT min_P2 = Integer ( 1 ) NEW_LINE for p2 in P2 : NEW_LINE INDENT min_P2 = min ( min_P2 , p2 ) NEW_LINE DEDENT r2 = sqrt ( max_R1 ** 2 + max_P1 ** 2 / ( A * min_P2 + B * max_P1 ) ) NEW_LINE assert r2 == sqrt ( A * min_P2 + B * max_P1 ) NEW_LINE DEDENT
def helloWorld ( num ) : NEW_LINE INDENT firsthalf = 1 NEW_LINE secondhalf = ( num * num ) + 1 NEW_LINE numOfSpaces = 0 NEW_LINE for numOfLines in range ( num , 1 , - 1 ) : NEW_LINE INDENT for numOfSpacesCounter in range ( numOfSpaces , 1 , - 1 ) : NEW_LINE INDENT print ( " ▁ " ) NEW_LINE DEDENT for firstHalfCounter in range ( 1 , numOfLines ) : NEW_LINE INDENT if firstHalfCounter == numOfLines : NEW_LINE INDENT print ( ( firsthalf ) , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( firsthalf ) , end = ' * ' ) NEW_LINE DEDENT DEDENT for secondHalfCounter in range ( 1 , numOfLines ) : NEW_LINE INDENT print ( " * " , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE numOfSpaces += 2 NEW_LINE secondhalf = ( secondhalf - 1 ) - ( ( numOfLines - 1 ) * 2 ) NEW_LINE DEDENT DEDENT
def test_GFG ( n , differences ) : NEW_LINE INDENT ans = [ 0 ] NEW_LINE ans . append ( 0 ) NEW_LINE x = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT diff = differences [ i ] NEW_LINE x = x + diff NEW_LINE ans . append ( x ) NEW_LINE DEDENT anss = [ ] NEW_LINE for obj in ans : NEW_LINE INDENT anss . append ( obj ) NEW_LINE DEDENT ans . sort ( ) NEW_LINE flag = - 1 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT res = ans [ i ] - ans [ i - 1 ] NEW_LINE if res != 1 : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return ans NEW_LINE DEDENT else : NEW_LINE INDENT mpp = { } NEW_LINE j = 1 NEW_LINE value_at_index = [ ] NEW_LINE for x1 in ans : NEW_LINE INDENT mpp [ x1 ] = j NEW_LINE j += 1 NEW_LINE DEDENT for x2 in anss : NEW_LINE INDENT value_at_index . append ( mpp [ x2 ] ) NEW_LINE DEDENT for x3 in value_at_index : NEW_LINE INDENT print ( x3 , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def get_GFG ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( 3 , math . sqrt ( n ) , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n // i NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return ( count ) NEW_LINE DEDENT
def GFG ( N , K ) : NEW_LINE INDENT combo = [ ] NEW_LINE combo . append ( 1 ) NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT
def py ( ) : NEW_LINE INDENT return py . path . local ( __file__ ) NEW_LINE DEDENT
def GFG ( m , n ) : NEW_LINE INDENT N = float ( ( abs ( m ) * abs ( n ) ) / math . sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ) NEW_LINE return N NEW_LINE DEDENT
def test_assignment4 ( ) : NEW_LINE INDENT f = open ( ' / tmp / assignment . txt ' , ' r ' ) NEW_LINE lines = f . readlines ( ) NEW_LINE num = [ line . split ( ) for line in lines ] NEW_LINE n = float ( num [ 0 ] ) NEW_LINE h = float ( num [ 1 ] ) NEW_LINE for i in range ( 1.0 , n ) : NEW_LINE INDENT ans = h * math . sqrt ( i / n ) NEW_LINE print ( ans , end = ' ' ) NEW_LINE if i == n - 1 : NEW_LINE INDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n != 0 : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE h , w = sys . argv [ 1 : ] NEW_LINE a , b = sys . argv [ 2 : ] NEW_LINE print ( h * w - ( h / a * a ) * ( w / b * b ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n , max , ans = sys . argv [ 1 : ] NEW_LINE l = [ ] NEW_LINE t = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT t . append ( i ) NEW_LINE max = max ( max , t ) NEW_LINE DEDENT for i in range ( 1 , max + 1 ) : NEW_LINE INDENT if max % i == 0 : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( l ) ) : NEW_LINE INDENT if l [ j ] >= t : NEW_LINE INDENT ans += l [ j ] - t [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT arr2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr2 . append ( i % k ) NEW_LINE DEDENT current_length , max_length = 0 , 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_length = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr2 [ j ] == arr2 [ i ] : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max_length = max ( max_length , current_length ) NEW_LINE i = j NEW_LINE DEDENT return max_length NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT fs = FastScanner ( ) NEW_LINE T = 1 , 2 , 3 NEW_LINE n , m , l , ans = 0l , 0l , 0l , 0l , 0l , 0l NEW_LINE for tt in range ( T ) : NEW_LINE INDENT n , m = fs . next ( ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if n - m > m - 1 : NEW_LINE INDENT print ( m + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m - 1 ) NEW_LINE DEDENT DEDENT def random ( ) : NEW_LINE INDENT n , m = len ( a ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT oi , temp = a [ oi ] , a [ i ] NEW_LINE a [ oi ] , a [ i ] = temp NEW_LINE DEDENT a . sort ( ) NEW_LINE DEDENT class FastScanner : NEW_LINE INDENT f = open ( ' / proc / self / fd ' , ' r ' ) NEW_LINE tokens = [ ] NEW_LINE next = ' ' NEW_LINE def readline ( self ) : NEW_LINE INDENT while not tokens : NEW_LINE INDENT try : NEW_LINE INDENT tokens . append ( next ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT tokens . append ( next ) NEW_LINE DEDENT return tokens NEW_LINE DEDENT next = ' ' NEW_LINE DEDENT def read ( self ) : NEW_LINE INDENT a = [ ] NEW_LINE for token in tokens : NEW_LINE INDENT a . append ( int ( token ) ) NEW_LINE DEDENT return a NEW_LINE DEDENT def rufflesort ( self , n ) : NEW_LINE INDENT a = [ ] NEW_LINE for token in tokens : NEW_LINE INDENT a . append ( int ( token ) ) NEW_LINE DEDENT return a NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return long ( next ( ) ) NEW_LINE DEDENT DEDENT return FastScanner ( ) NEW_LINE DEDENT
def GFG ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' ▁ ' : NEW_LINE INDENT if hash [ s [ i ] - ' a ' ] == 0 : NEW_LINE INDENT hash [ s [ i ] - ' a ' ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def p024 ( ) : NEW_LINE INDENT print ( [ ] ) NEW_LINE DEDENT
def GFG ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if x > x1 and x < x2 and y > y1 and y < y2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT MX = 2001 NEW_LINE OFF = 1000 NEW_LINE class point ( object ) : NEW_LINE INDENT x , y = symbols ( ' x , y ' ) NEW_LINE DEDENT def count_points ( n , points ) : NEW_LINE INDENT minx = [ int ( x ) for x in points ] NEW_LINE miny = [ int ( y ) for y in points ] NEW_LINE maxx = [ int ( x ) for x in points ] NEW_LINE maxy = [ int ( y ) for y in points ] NEW_LINE x , y = symbols ( ' x , y ' ) NEW_LINE minx [ y ] += OFF NEW_LINE maxx [ y ] = OFF NEW_LINE miny [ x ] = min ( minx [ y ] , x ) NEW_LINE maxy [ x ] = max ( maxx [ y ] , x ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = points [ i ] NEW_LINE if x > minx [ y ] and x < maxx [ y ] : NEW_LINE INDENT if y > miny [ x ] and y < maxy [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE main = sys . argv [ 1 : ] NEW_LINE X = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE Y = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE Z = Y / X NEW_LINE answer = f ( Z ) + 1 NEW_LINE print ( answer ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT sticks = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt += ( sticks [ str ( i ) - '0' ] ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT f = open ( ' / proc / cpuinfo ' , ' r ' ) NEW_LINE out = open ( ' / proc / cpuinfo ' , ' w ' ) NEW_LINE t = int ( f . readline ( ) ) NEW_LINE while t : NEW_LINE INDENT n = int ( f . readline ( ) ) NEW_LINE a = [ ] NEW_LINE st = f . readline ( ) . split ( ) NEW_LINE for i in st : NEW_LINE INDENT a . append ( int ( i ) ) NEW_LINE DEDENT replace_next = False NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if replace_next : NEW_LINE INDENT a [ i ] = max ( a [ i - 1 ] , a [ i + 1 ] ) NEW_LINE ans += 1 NEW_LINE replace_next = False NEW_LINE DEDENT if a [ i ] > a [ i - 1 ] and a [ i ] > a [ i + 1 ] : NEW_LINE INDENT replace_next = True NEW_LINE DEDENT DEDENT if replace_next : NEW_LINE INDENT a [ n - 1 ] = a [ n - 2 ] NEW_LINE ans += 1 NEW_LINE replace_next = False NEW_LINE DEDENT out . write ( ans ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT out . write ( a [ i ] + ' ▁ ' ) NEW_LINE DEDENT out . write ( ' \n ' ) NEW_LINE DEDENT f . close ( ) NEW_LINE out . close ( ) NEW_LINE DEDENT
def GFG ( arr , a , b ) : NEW_LINE INDENT arr [ a ] ^= True NEW_LINE arr [ b + 1 ] ^= True NEW_LINE process ( arr , n ) NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT result ( arr , n ) NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT if arr [ k ] == True : NEW_LINE INDENT print ( '1' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( '0' , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def most_frequent ( arr , n ) : NEW_LINE INDENT arr = np . array ( arr ) NEW_LINE max_count , res = 1 , arr [ 0 ] NEW_LINE curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if curr_count > max_count : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if curr_count > max_count : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def GFG ( ) : NEW_LINE INDENT MAX = 26 NEW_LINE res = 0 NEW_LINE last_pos = [ - 1 ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT last_pos [ i ] = - 1 NEW_LINE DEDENT for i in range ( len ( str ( ' geeksforgeeks ' ) ) ) : NEW_LINE INDENT C = str ( i ) - ' a ' NEW_LINE if last_pos [ C ] != - 1 : NEW_LINE INDENT res = max ( len ( str ( i ) ) - ( i - last_pos [ C ] - 1 ) - 1 , res ) NEW_LINE DEDENT last_pos [ C ] = i NEW_LINE DEDENT return res NEW_LINE DEDENT
def GFG ( arr , n , k ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE ksmallest = [ 1 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT b = [ 1 ] * MAX NEW_LINE for j in range ( 1 , MAX ) : NEW_LINE INDENT if b [ j ] != 1 : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if k != 1 : NEW_LINE INDENT return j , k NEW_LINE DEDENT DEDENT DEDENT return int ( ' - 1' ) , None NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT d = 0 NEW_LINE while ( n / 100 ) > 0 : NEW_LINE INDENT d = n % 10 NEW_LINE n /= 10 NEW_LINE n = abs ( n + ( d * 13 ) ) NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT d = 0 NEW_LINE while ( n / 100 ) > 0 : NEW_LINE INDENT d = n % 10 NEW_LINE n /= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT d = 0 NEW_LINE while ( n / 100 ) > 0 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT assert ( n % 31 == 0 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT d = 0 NEW_LINE while ( n / 100 ) <= 0 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT assert ( n % 71 == 0 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT from sympy . polys . distributedmodules import gf_degree NEW_LINE from sympy . polys . domains import ZZ NEW_LINE from sympy . polys . orderings import lex NEW_LINE from sympy . polys . domains import QQ NEW_LINE from sympy . polys . distributedmodules import DMP NEW_LINE Odd_sum , Even_Sum = gf_degree ( [ 1 , 2 , 3 ] , ZZ ) , ZZ NEW_LINE Odd_sum , Even_Sum = ZZ . map ( [ 1 , 2 , 3 ] ) , ZZ . map ( [ 1 , 2 , 3 ] ) NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT L , R = 1 , 5 NEW_LINE assert gf_degree ( [ L , R ] ) == L NEW_LINE assert gf_degree ( [ L , R ] ) == R NEW_LINE DEDENT DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE class Ratio ( object ) : NEW_LINE INDENT def __init__ ( self , low_cost , up_cost , low_quant , up_quant , r ) : NEW_LINE INDENT for i in range ( low_quant , up_quant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if low_cost <= ans <= up_cost : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT low_cost , up_cost , low_quant , up_quant , r = 14 , 30 , 5 , 12 , 9 NEW_LINE if is_ratio_possible ( low_cost , up_cost , low_quant , up_quant , r ) : NEW_LINE INDENT sys . stdout . write ( " Yes \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( " No \n " ) NEW_LINE DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n == 0 : return False NEW_LINE return int ( math . ceil ( ( math . log ( n , 2 ) / math . log ( 2 ) ) ) ) == int ( math . floor ( ( ( math . log ( n , 2 ) / math . log ( 2 ) ) ) ) ) NEW_LINE DEDENT
def p087 ( ) : NEW_LINE INDENT print ( [ ' p087 . py ' , ' p087 _ test . py ' , ' p087 _ test . c ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ' p087 _ test . h ' , ] ) NEW_LINE DEDENT
def get_long_len_sub ( arr , n ) : NEW_LINE INDENT um = { } NEW_LINE long_len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if um . has_key ( arr [ i ] - 1 ) and len < um [ arr [ i ] - 1 ] : NEW_LINE INDENT len = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if um . has_key ( arr [ i ] + 1 ) and len < um [ arr [ i ] + 1 ] : NEW_LINE INDENT len = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len + 1 NEW_LINE if long_len < um [ arr [ i ] ] : NEW_LINE INDENT long_len = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return long_len NEW_LINE DEDENT
def test_problem_1 ( ) : NEW_LINE INDENT s = symbols ( ' s ' , integer = True , positive = True ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE while t . is_positive : NEW_LINE INDENT a , b = symbols ( ' a ▁ b ' , integer = True , positive = True ) NEW_LINE assert a + b == s ( a , b ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = Symbol ( ' n ' , integer = True ) NEW_LINE assert ( 1 << n ) . nseries ( n , 0 , 5 ) == 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 10 NEW_LINE assert gf_degree ( [ ] , n ) == 0 NEW_LINE assert gf_degree ( [ 1 ] , n ) == 1 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 3 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) == 4 NEW_LINE assert gf_degree ( [ 1 , 2 , 3 , 4 ] ) ==
def GFG ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if curr_sum > 0 : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import string NEW_LINE import struct NEW_LINE import time NEW_LINE import random NEW_LINE import math NEW_LINE import hashlib NEW_LINE import random NEW_LINE import time NEW_LINE import random NEW_LINE import string NEW_LINE import struct NEW_LINE import time NEW_LINE import random NEW_LINE import hashlib NEW_LINE from random import random NEW_LINE import time NEW_LINE from time import time NEW_LINE from random import random NEW_LINE from hashlib import md5 NEW_LINE from hashlib import sha256 NEW_LINE from struct import pack NEW_LINE from struct import calcsize NEW_LINE from hashlib import sha1 NEW_LINE from hashlib import sha256 NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from random import random NEW_LINE from time import time NEW_LINE from random import random NEW_LINE from hashlib import md5 NEW_LINE from hashlib import sha256 NEW_LINE from hashlib import sha256 NEW_LINE from struct import calcsize NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from hashlib import md5 , sha256 , sha1 , sha256 , sha1 NEW_LINE from hashlib import md5 , sha256 , sha1 , sha1 NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from hashlib import md5 , sha256 , sha1 , sha1 , sha1 NEW_LINE from hashlib import md5 , sha256 , sha1 , sha1 NEW_LINE from struct import calcsize NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from hashlib import sha256 , md5 , sha256 , sha1 , sha1 , sha1 NEW_LINE from hashlib import sha256 , sha256 , sha1 , sha1 , sha1 NEW_LINE from hashlib import md5 , sha256 , sha1 , sha1 , sha1 NEW_LINE from struct import calcsize NEW_LINE from struct import calcsize NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import unpack NEW_LINE from struct import calcsize NEW_LINE from struct import calcsize NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT num = ( ( n / 2 ) + 1 ) NEW_LINE max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if val == max : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def test_er ( ) : NEW_LINE INDENT f = py . io . TextIO ( encoding = ' utf - 8' ) NEW_LINE s = f . getvalue ( ) NEW_LINE cum = [ ] NEW_LINE cum . append ( 0 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT cum . append ( cum [ - 1 ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cum . append ( cum [ - 1 ] ) NEW_LINE DEDENT DEDENT s = f . getvalue ( ) NEW_LINE q = int ( s ) NEW_LINE while q != 0 : NEW_LINE INDENT s = f . readline ( ) NEW_LINE l , r = int ( s ) , int ( s [ : - 1 ] ) - 1 NEW_LINE yield ( lambda : cum [ r ] - cum [ l - 1 ] ) , q , l , r NEW_LINE DEDENT DEDENT
def _main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE while 1 : NEW_LINE INDENT n , m = getopt . getopt ( sys . argv [ 1 : ] , ' n : m ' ) NEW_LINE if ( n | m ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT pow3 = [ 1 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pow3 [ i ] = pow3 [ i - 1 ] * 3 NEW_LINE DEDENT c = [ ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT a , b = getopt . getopt ( sys . argv [ 2 : ] , ' a : b : c ' ) NEW_LINE for j in range ( a , b + 1 ) : NEW_LINE INDENT k , c = getopt . getopt ( sys . argv [ 3 : ] , ' k : c ' ) NEW_LINE c . append ( k ) NEW_LINE DEDENT DEDENT p = 0 NEW_LINE x = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT d = abs ( p - c [ i ] ) NEW_LINE x += pow3 [ i ] * d NEW_LINE if d == 1 : NEW_LINE INDENT p = 2 - p NEW_LINE DEDENT DEDENT y = pow3 [ n ] - 1 - x NEW_LINE if x > y : NEW_LINE INDENT x = y NEW_LINE DEDENT sys . exit ( x > m ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX = 100000 NEW_LINE print ( " % d ▁ " % MAX ) NEW_LINE print ( " and ▁ " ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT print ( " and ▁ " ) NEW_LINE for i in range ( b ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE checksum ( g1 , a , g2 , b ) NEW_LINE i , x = 0 , 0 NEW_LINE for i , x in enumerate ( g1 ) : NEW_LINE INDENT x += g1 [ i ] NEW_LINE DEDENT for i in range ( b ) : NEW_LINE INDENT x -= g2 [ i ] NEW_LINE DEDENT return ( x , checksum ( g1 , a , g2 , b ) ) NEW_LINE DEDENT
def test_a ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE a = [ x , x ** 2 , x ** 3 ] NEW_LINE a . sort ( ) NEW_LINE max = 0 NEW_LINE d = [ - 500 ] * n + [ 0 ] * n NEW_LINE d [ 0 ] = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 3 ) : NEW_LINE INDENT if i - a [ j ] >= 0 and d [ i - a [ j ] ] != - 1 : NEW_LINE INDENT d [ i ] = max ( d [ i ] , d [ i - a [ j ] ] + 1 ) NEW_LINE DEDENT DEDENT assert d [ n ] == max ( d [ i ] , d [ i - a [ j ] ] + 1 ) NEW_LINE DEDENT DEDENT
def get_GFG ( vec , n ) : NEW_LINE INDENT suffix = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if vec [ i ] == 1 : NEW_LINE INDENT suffix += 1 NEW_LINE vec [ i ] = suffix NEW_LINE DEDENT DEDENT res = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if vec [ i ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if vec [ i ] > 0 : NEW_LINE INDENT res = max ( res , zero + vec [ i ] ) NEW_LINE DEDENT DEDENT return max ( res , zero ) NEW_LINE DEDENT
def gen2poly ( maze ) : NEW_LINE INDENT R = 4 NEW_LINE C = 4 NEW_LINE countPaths = [ ] NEW_LINE for i in range ( R ) : NEW_LINE INDENT if maze [ i ] [ 0 ] == - 1 : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , C ) : NEW_LINE INDENT if maze [ 0 ] [ i ] == 0 : NEW_LINE INDENT maze [ 0 ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT if maze [ i ] [ j ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if maze [ i - 1 ] [ j ] > 0 : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE DEDENT if maze [ i ] [ j - 1 ] > 0 : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return ( maze [ R - 1 ] [ C - 1 ] > 0 ) , maze [ R - 1 ] [ C - 1 ] NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT is_prime = True NEW_LINE arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] NEW_LINE if N < 2 : NEW_LINE INDENT is_prime = False NEW_LINE DEDENT if N % 2 == 0 or N % 3 == 0 or N % 5 == 0 : NEW_LINE INDENT is_prime = False NEW_LINE DEDENT for i in range ( 0 , math . sqrt ( N ) , 30 ) : NEW_LINE INDENT for c in arr : NEW_LINE INDENT if c > math . sqrt ( N ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if N % ( c + i ) == 0 : NEW_LINE INDENT is_prime = False NEW_LINE break NEW_LINE DEDENT DEDENT if not is_prime : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if is_prime : NEW_LINE INDENT assert ' Prime ▁ Number ' in str ( is_prime ) NEW_LINE DEDENT else : NEW_LINE INDENT assert ' Not ▁ a ▁ Prime ▁ Number ' in str ( is_prime ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE x1 = sys . argv [ 1 ] NEW_LINE y1 = sys . argv [ 2 ] NEW_LINE x2 = sys . argv [ 3 ] NEW_LINE y2 = sys . argv [ 4 ] NEW_LINE x3 = x2 + ( y1 - y2 ) NEW_LINE y3 = y2 - ( x1 - x2 ) NEW_LINE x4 = x1 - ( y2 - y1 ) NEW_LINE y4 = y1 + ( x2 - x1 ) NEW_LINE sys . stdout . write ( x3 + " ▁ " + y3 + " ▁ " + x4 + " ▁ " + y4 ) NEW_LINE DEDENT
def GFG ( seq , i , j ) : NEW_LINE INDENT return ( x > y ) + ( x < y ) NEW_LINE lps = [ x for x in seq if x > y ] NEW_LINE if i == j : NEW_LINE INDENT return 1 NEW_LINE DEDENT if seq [ i ] == seq [ j ] and i + 1 == j : NEW_LINE INDENT return 2 NEW_LINE DEDENT if seq [ i ] == seq [ j ] : NEW_LINE INDENT return lps ( seq , i + 1 , j - 1 ) + 2 NEW_LINE DEDENT return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) NEW_LINE DEDENT
def GFG ( str , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT l , r = i + 1 , i + 1 NEW_LINE lsum , rsum = 0 , 0 NEW_LINE while r < n and l >= 0 : NEW_LINE INDENT lsum += str [ l ] - '0' NEW_LINE rsum += str [ r ] - '0' NEW_LINE if lsum == rsum : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def pygfG ( a , n , ind ) : NEW_LINE INDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( a [ ( i % n ) ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def pygfG ( a , n , ind ) : NEW_LINE INDENT b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( b [ n + i ] = a [ i ] ) NEW_LINE DEDENT for i in range ( ind , n + ind ) : NEW_LINE INDENT print ( b [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def test_er42b ( ) : NEW_LINE INDENT f = Function ( ' f ' ) NEW_LINE n , a , b = symbols ( ' n ▁ a ▁ b ' , integer = True , positive = True ) NEW_LINE s = f ( n ) NEW_LINE ans = a + b NEW_LINE flip = a > b NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if s [ i ] == ' * ' : NEW_LINE INDENT flip = a > b NEW_LINE DEDENT else : NEW_LINE INDENT if flip == 1 : NEW_LINE INDENT a = ( a , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( b , 0 ) NEW_LINE DEDENT flip *= - 1 NEW_LINE DEDENT DEDENT assert ans - a - b == ans NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE id = sys . argv [ 1 ] NEW_LINE root = Node ( yield id , 0 , sys . argv [ 2 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT target_id = sys . argv [ 2 ] NEW_LINE parent = root . find_node ( target_id ) NEW_LINE parent . children . append ( Node ( yield id , parent . depth + 1 , sys . argv [ 3 ] ) ) NEW_LINE DEDENT root . print_contents ( ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT class Node : NEW_LINE INDENT id , depth NEW_LINE contents = None NEW_LINE children = [ ] NEW_LINE def find_node ( self , i , d , c ) : NEW_LINE INDENT if i == self . id : NEW_LINE INDENT return self NEW_LINE DEDENT for child in self . children : NEW_LINE INDENT target = child . find_node ( id ) NEW_LINE if target is not None : NEW_LINE INDENT return target NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def print_contents ( self ) : NEW_LINE INDENT for i in range ( depth ) : NEW_LINE INDENT sys . stdout . write ( ' . ' ) NEW_LINE DEDENT sys . stdout . write ( contents ) NEW_LINE for child in self . children : NEW_LINE INDENT child . print_contents ( ) NEW_LINE DEDENT DEDENT DEDENT
def main2 ( ) : NEW_LINE INDENT global v1 , v2 , t , d NEW_LINE dp = [ ] NEW_LINE for x in range ( 1200 ) : NEW_LINE INDENT np . random . seed ( 0 ) NEW_LINE v1 = x NEW_LINE v2 = x NEW_LINE t = t NEW_LINE d = d NEW_LINE dp = np . zeros ( ( t , 1200 ) ) NEW_LINE for x in dp : NEW_LINE INDENT np . random . seed ( 0 ) NEW_LINE DEDENT ans = - 1 NEW_LINE if t == 2 : NEW_LINE INDENT print ( v1 + v2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v1 + v2 + calculate ( 1 , v1 , v1 ) ) NEW_LINE DEDENT DEDENT def calculate ( currentTime , currentSpeed , prev ) : NEW_LINE INDENT if currentSpeed < 0 : NEW_LINE INDENT return - int ( 1e8 ) NEW_LINE DEDENT if currentTime == t - 1 : NEW_LINE INDENT if abs ( currentSpeed - v2 ) <= d : NEW_LINE INDENT return 0 NEW_LINE DEDENT return - int ( 1e8 ) NEW_LINE DEDENT if dp [ currentTime ] [ currentSpeed ] != - 1 : NEW_LINE INDENT return dp [ currentTime ] [ currentSpeed ] NEW_LINE DEDENT bestAns = - int ( 1e8 ) NEW_LINE for i in range ( 0 , d ) : NEW_LINE INDENT ans = currentSpeed + i + calculate ( currentTime + 1 , currentSpeed + i , currentSpeed ) NEW_LINE ans2 = currentSpeed - i + calculate ( currentTime + 1 , currentSpeed - i , currentSpeed ) NEW_LINE bestAns = max ( bestAns , max ( ans , ans2 ) ) NEW_LINE DEDENT return dp [ currentTime ] [ currentSpeed ] = bestAns NEW_LINE DEDENT return main ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE a , b = sys . argv [ 1 : ] NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j = n - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if b [ j ] >= a [ i ] : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT print ( j + 1 ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] > a [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT print ( j ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global num NEW_LINE global dis1 NEW_LINE global dis2 NEW_LINE num = [ ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT num . append ( i ) NEW_LINE DEDENT elif i == 1 : NEW_LINE INDENT num . append ( i ) NEW_LINE DEDENT elif i == 2 : NEW_LINE INDENT num . append ( i ) NEW_LINE DEDENT elif i == 3 : NEW_LINE INDENT num . append ( i ) NEW_LINE DEDENT DEDENT num . sort ( ) NEW_LINE dis1 = num [ 2 ] - num [ 0 ] NEW_LINE dis2 = num [ 2 ] - num [ 1 ] NEW_LINE ans = 0 NEW_LINE if dis1 % 2 == 0 and dis2 % 2 == 0 : NEW_LINE INDENT ans = dis1 / 2 + dis2 / 2 NEW_LINE DEDENT elif dis1 % 2 != 0 and dis2 % 2 != 0 : NEW_LINE INDENT ans = dis1 / 2 + dis2 / 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = dis1 / 2 + dis2 / 2 + 2 NEW_LINE DEDENT sys . stdout . write ( ans ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE T = sys . argv [ 1 ] NEW_LINE while T : NEW_LINE INDENT n = sys . argv [ 2 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if j == 1 or i == j : NEW_LINE INDENT sys . stdout . write ( 1 + " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( 0 + " ▁ " ) NEW_LINE DEDENT DEDENT sys . stdout . write ( " \n " ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 ) NEW_LINE DEDENT
def p001 ( ) : NEW_LINE INDENT print ( [ ] ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n NEW_LINE global str NEW_LINE global s NEW_LINE global s1 NEW_LINE n = len ( sys . argv ) NEW_LINE str = sys . argv [ 1 ] NEW_LINE s = " " NEW_LINE s1 = " " NEW_LINE for c in str : NEW_LINE INDENT if c == ' n ' : s += "1 ▁ " NEW_LINE if c == ' z ' : s1 += "0 ▁ " NEW_LINE DEDENT sys . stdout . write ( s + s1 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE R , G = map ( int , sys . argv [ 1 : ] ) NEW_LINE print ( ( 2 * G ) - R ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT R = QQ . old_poly_ring ( x , y ) NEW_LINE Result = 1 NEW_LINE while n > 0 : NEW_LINE INDENT Result = Result * n NEW_LINE n -= 1 NEW_LINE DEDENT assert Result == 1 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ product ▁ of ▁ the ▁ Diagonals ▁ of ▁ the ▁ polynomials . """ NEW_LINE product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] [ i ] NEW_LINE product = product * arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT if n % 2 == 1 : NEW_LINE INDENT product = product / arr [ n / 2 ] [ n / 2 ] NEW_LINE DEDENT return product NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE for line in sys . stdin : NEW_LINE INDENT n = line . strip ( ) . split ( ' ▁ ' ) NEW_LINE if n == ' ' : NEW_LINE INDENT break NEW_LINE DEDENT map = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ line [ 0 ] ] += 1 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT ans = ' - ' NEW_LINE if map [ i ] != ' ' : NEW_LINE INDENT ch = map [ i ] . split ( ' * ' ) NEW_LINE ans = ' ' . join ( ch ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( ) : NEW_LINE INDENT NO_OF_CHARS = 256 NEW_LINE count = [ ] NEW_LINE i = 0 NEW_LINE for c in range ( len ( str ( ) ) ) : NEW_LINE INDENT ( count [ c ] , count [ c ] ) = i , count [ c ] + 1 NEW_LINE DEDENT first , second = 0 , 0 NEW_LINE for c in range ( NO_OF_CHARS ) : NEW_LINE INDENT if count [ c ] > count [ first ] : NEW_LINE INDENT second , first = first , c NEW_LINE DEDENT elif count [ c ] > count [ second ] and count [ c ] != count [ first ] : NEW_LINE INDENT second , first = c , first NEW_LINE DEDENT DEDENT return chr ( second ) , chr ( first ) , chr ( second ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import numpy NEW_LINE dp = [ 1 ] * 4001 NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT for ii in range ( 0 , 1000 * i ) : NEW_LINE INDENT for iii in range ( max ( 0 , ii - 1000 ) , ii + 1 ) : NEW_LINE INDENT dp [ i ] [ ii ] += dp [ i - 1 ] [ iii ] NEW_LINE DEDENT DEDENT DEDENT while sys . stdin . read ( ) != ' ' : NEW_LINE INDENT print ( dp [ 4 ] [ sys . stdin . read ( ) ] ) NEW_LINE DEDENT DEDENT
def test_sort_example ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ sorting ▁ of ▁ the ▁ elements ▁ of ▁ a ▁ list . STRNEWLINE ▁ """ NEW_LINE n = len ( arr ) NEW_LINE arr = np . array ( arr , dtype = ' int32' ) NEW_LINE arr = arr . reshape ( n // 2 , n , order = ' F ' ) NEW_LINE arr = arr . sort ( ) NEW_LINE print ( ' Modified ▁ Array ▁ : ▁ % s ' % str ( arr ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ minflip ▁ algorithm . """ NEW_LINE arr1 = [ 1 , 0 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 0 , 1 , 1 , 1 , 1 , 0 , 0 ] NEW_LINE arr3 = [ 1 , 1 , 1 , 1 , 0 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE p , q = 2 , 4 NEW_LINE assert minflip ( arr1 , arr2 , arr3 , p , q , n ) == 0 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT i , s = symbols ( ' i ▁ s ' , integer = True , positive = True ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i NEW_LINE DEDENT assert simplify ( s ) == 0 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ bitonic ▁ generator . """ NEW_LINE evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 != 1 : NEW_LINE INDENT evenArr . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( i ) NEW_LINE DEDENT DEDENT evenArr . sort ( ) NEW_LINE oddArr . sort ( ) NEW_LINE i = 0 NEW_LINE for j in evenArr : NEW_LINE INDENT arr = [ i , j ] NEW_LINE DEDENT for j in oddArr : NEW_LINE INDENT arr = [ i , j ] NEW_LINE DEDENT return NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE right , left = 0 , 0 NEW_LINE visited = [ False ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT while right < n : NEW_LINE INDENT while right < n and not visited [ arr [ right ] ] : NEW_LINE INDENT count += ( right - left ) NEW_LINE visited [ arr [ right ] ] = True NEW_LINE right += 1 NEW_LINE DEDENT while left < right and ( right != n and visited [ arr [ right ] ] ) : NEW_LINE INDENT visited [ arr [ left ] ] = False NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def import ( root_data ) : NEW_LINE INDENT class TreeNode ( object ) : NEW_LINE INDENT def __init__ ( self , val , left , right ) : NEW_LINE INDENT self . val = val NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " % s ▁ % s ▁ % s " % ( self . val , self . left , self . right ) NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT trees = set ( ) NEW_LINE def is_subtree ( self , s , t ) : NEW_LINE INDENT tree1 = preorder ( s , True ) NEW_LINE tree2 = preorder ( t , True ) NEW_LINE return tree1 . index ( tree2 ) >= 0 NEW_LINE DEDENT def preorder ( self , t , left ) : NEW_LINE INDENT if t is None : NEW_LINE INDENT if left : NEW_LINE INDENT return " lnull " NEW_LINE DEDENT else : NEW_LINE INDENT return " rnull " NEW_LINE DEDENT DEDENT return " # % d ▁ % s ▁ % s " % ( self . val , preorder ( t . left , True ) , preorder ( t . right , False ) ) NEW_LINE DEDENT def main ( self ) : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE root = TreeNode ( 3 ) NEW_LINE root . left = TreeNode ( 4 ) NEW_LINE root . right = TreeNode ( 5 ) NEW_LINE root . left . left = TreeNode ( 1 ) NEW_LINE root . left . right = TreeNode ( 2 ) NEW_LINE subRoot = TreeNode ( 4 ) NEW_LINE subRoot . left = TreeNode ( 1 ) NEW_LINE subRoot . right = TreeNode ( 2 ) NEW_LINE out = sObj . is_subtree ( root , subRoot ) NEW_LINE print ( out ) NEW_LINE DEDENT DEDENT
def GFG ( idx , diff , N , M , K ) : NEW_LINE INDENT M , N , M = 1001 , N , M , M NEW_LINE dp = { } NEW_LINE if idx > N : NEW_LINE INDENT if diff == K : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if dp [ idx ] [ diff ] != - 1 : NEW_LINE INDENT return dp [ idx ] [ diff ] NEW_LINE DEDENT ans = solve ( idx + 1 , diff , N , M , K ) NEW_LINE ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) NEW_LINE return dp [ idx ] [ diff ] = ans % MOD NEW_LINE DEDENT
def p222 ( ) : NEW_LINE INDENT print ( p222 ( ) . run ( ) ) NEW_LINE sphereRadii = np . zeros ( 21 ) NEW_LINE for i in range ( sphereRadii . shape [ 0 ] ) : NEW_LINE INDENT sphereRadii [ i ] = ( i + 30 ) * 1000 NEW_LINE DEDENT minLength = np . zeros ( sphereRadii . shape [ 0 ] , dtype = np . int32 ) NEW_LINE min = np . inf NEW_LINE for i in range ( sphereRadii . shape [ 0 ] ) : NEW_LINE INDENT min = min ( find_minimum_length ( i , ( 1 << sphereRadii . shape [ 0 ] ) - 1 ) + sphereRadii [ i ] , min ) NEW_LINE DEDENT return np . round ( min ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT n = 0 NEW_LINE sides = [ ] NEW_LINE judge = False NEW_LINE line = ' ' NEW_LINE tmp = ' ' NEW_LINE with open ( ' input . txt ' , ' r ' ) as f : NEW_LINE INDENT line = f . readline ( ) NEW_LINE n = int ( line . split ( ) [ 0 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = line . split ( ) NEW_LINE tmp = line . split ( ) NEW_LINE for j in range ( len ( sides ) ) : NEW_LINE INDENT sides [ j ] = int ( tmp [ j ] ) NEW_LINE sides [ j ] *= sides [ j ] NEW_LINE DEDENT for j in range ( len ( sides ) ) : NEW_LINE INDENT if sides [ j % 3 ] == sides [ ( j + 1 ) % 3 ] + sides [ ( j + 2 ) % 3 ] : NEW_LINE INDENT judge = True NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT judge = False NEW_LINE DEDENT DEDENT Answer ( judge ) NEW_LINE DEDENT DEDENT Answer ( judge ) NEW_LINE DEDENT
def test_gf_gf_sum ( ) : NEW_LINE INDENT assert gf_gf_sum ( [ ] , 11 , ZZ ) == 0 NEW_LINE assert gf_gf_sum ( [ ] , 11 , ZZ ) == 0 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ ) == 1 NEW_LINE assert gf_gf_sum ( [ 1 ] , 11 , ZZ
def get_total_xor_of_subarray_xors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if freq % 2 == 1 : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE l , p , q = sys . argv [ 1 : ] NEW_LINE print ( ( p * l ) / ( p + q ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE while t : NEW_LINE INDENT n = t . pop ( ) NEW_LINE arr = [ ] NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT arr . append ( t [ i ] ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE print ( abs ( arr [ n ] - arr [ n - 1 ] ) ) NEW_LINE t = t . pop ( ) NEW_LINE DEDENT DEDENT
def test_S ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE cntp = [ ] NEW_LINE cntn = [ ] NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = symbols ( ' a ' , integer = True , positive = True ) NEW_LINE if a == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif a > 0 : NEW_LINE INDENT cntp . append ( a ) NEW_LINE DEDENT elif a < 0 : NEW_LINE INDENT cntn . append ( abs ( a ) ) NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT res = res + ( cntp [ i ] * cntn [ i ] ) NEW_LINE DEDENT res = res + ( ( cnt * ( cnt - 1 ) ) / 2 ) NEW_LINE assert res == 0 NEW_LINE DEDENT
def pyf95a ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' cf95a ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT if len ( args ) != 2 : NEW_LINE INDENT print ( " Usage : ▁ pyf95a ▁ < filename > " ) NEW_LINE return NEW_LINE DEDENT if args [ 0 ] == ' - ' : NEW_LINE INDENT o = ' - ' NEW_LINE DEDENT else : NEW_LINE INDENT o = ' - ' NEW_LINE DEDENT compare ( args [ 1 ] , args [ 0 ] ) NEW_LINE if o == ' - ' : NEW_LINE INDENT o = ' - ' NEW_LINE DEDENT else : NEW_LINE INDENT o = ' - ' NEW_LINE DEDENT n = len ( args ) NEW_LINE ss = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ss . append ( args [ i ] ) NEW_LINE DEDENT cc = ' ' NEW_LINE m = len ( cc ) NEW_LINE c = args [ 0 ] NEW_LINE c_ = ord ( c ) NEW_LINE a = c if c == ' a ' else ' b ' NEW_LINE a_ = ord ( a ) NEW_LINE lucky = [ ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT l = len ( ss [ i ] ) NEW_LINE if m - j >= l and compare ( cc , j , ss [ i ] , 0 , l ) == 0 : NEW_LINE INDENT for h in range ( l ) : NEW_LINE INDENT lucky . append ( True ) NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if lucky : NEW_LINE INDENT if ord ( cc [ j ] ) == c : NEW_LINE INDENT cc [ j ] = ord ( cc [ j ] ) if c == ' a ' else a_ NEW_LINE DEDENT else : NEW_LINE INDENT cc [ j ] = ord ( cc [ j ] ) if c == ' c ' else c_ NEW_LINE DEDENT DEDENT DEDENT print ( cc ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE a = sys . argv [ 1 ] NEW_LINE c = sys . argv [ 2 ] NEW_LINE w = [ ] NEW_LINE e = [ ] NEW_LINE min = a NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT if c [ i - 1 ] == ' W ' : NEW_LINE INDENT w . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT e . append ( i ) NEW_LINE DEDENT w . append ( w [ - 1 ] ) NEW_LINE e . append ( e [ - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT min = min ( min , w [ i - 1 ] + e [ a ] - e [ i ] ) NEW_LINE DEDENT print ( min ) NEW_LINE DEDENT
def test_cf1213_a ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE n = symbols ( ' n ' , integer = True , positive = True ) NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT num1 = x ** i NEW_LINE if num1 % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if even > odd : NEW_LINE INDENT assert odd == 0 NEW_LINE DEDENT else : NEW_LINE INDENT assert even == 1 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE MAX = 10000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE for i in range ( 3 , MAX + 1 , 2 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for i in range ( 3 , i * i <= MAX , 2 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT for j in range ( i * 3 , MAX , i * 2 ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT n = sys . stdin . readline ( ) NEW_LINE while n != ' ' : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT for i in range ( n , 13 , 2 ) : NEW_LINE INDENT if prime [ i ] and prime [ i - 2 ] and prime [ i - 6 ] and prime [ i - 8 ] : NEW_LINE INDENT sys . stdout . write ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT n = sys . stdin . readline ( ) NEW_LINE DEDENT DEDENT
def b_Spider_Man ( ) : NEW_LINE INDENT class FastReader ( BufferedReader ) : NEW_LINE INDENT def __init__ ( self , f ) : NEW_LINE INDENT BufferedReader . __init__ ( self , f ) NEW_LINE DEDENT def readline ( self ) : NEW_LINE INDENT while not self . f or not self . f . endswith ( ' \n ' ) : NEW_LINE INDENT try : NEW_LINE INDENT self . f . readline ( ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return self . f . readline ( ) NEW_LINE DEDENT def nextInt ( self ) : NEW_LINE INDENT return int ( next ( self . f ) ) NEW_LINE DEDENT def nextLong ( self ) : NEW_LINE INDENT return long ( next ( self . f ) ) NEW_LINE DEDENT def nextDouble ( self ) : NEW_LINE INDENT return float ( next ( self . f ) ) NEW_LINE DEDENT def nextLine ( self ) : NEW_LINE INDENT str = " " NEW_LINE try : NEW_LINE INDENT str = self . f . readline ( ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT pass NEW_LINE DEDENT return str NEW_LINE DEDENT def scan ( self ) : NEW_LINE INDENT t = 1 NEW_LINE while t : NEW_LINE INDENT self . solve ( ) NEW_LINE DEDENT DEDENT def solve ( self ) : NEW_LINE INDENT t = self . nextInt ( ) NEW_LINE arr = [ ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT arr . append ( self . nextInt ( ) ) NEW_LINE DEDENT prev_winner = None NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT if prev_winner == None : NEW_LINE INDENT prev_winner = 2 NEW_LINE DEDENT DEDENT if prev_winner == 2 or prev_winner == 0 : NEW_LINE INDENT if ( arr [ i ] - 1 ) % 2 == 0 : NEW_LINE INDENT print ( 2 ) NEW_LINE prev_winner = 2 NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE prev_winner = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ i ] - 1 ) % 2 == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE prev_winner = 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE prev_winner = 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT assert ( ( n & n - 1 ) == 0 ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n - 1 ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_set ( n ) NEW_LINE assert only_first_and_last_are_
def get_minimum_cost_of_breaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X = sorted ( X , key = lambda x : x [ 1 ] ) NEW_LINE Y = sorted ( Y , key = lambda x : x [ 1 ] ) NEW_LINE hzntl , vert = 1 , 1 NEW_LINE i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if X [ i ] > Y [ j ] : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while i < m : NEW_LINE INDENT total += X [ i ] NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while j < n : NEW_LINE INDENT total += Y [ j ] NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT
def class GCD ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def gf_mul ( a , b , p , K ) : NEW_LINE INDENT mul = [ ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT mul . append ( 0 ) NEW_LINE for k in range ( 3 ) : NEW_LINE INDENT mul [ i ] += a [ i ] [ k ] * b [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT a [ i ] [ j ] = mul [ i ] [ j ] NEW_LINE DEDENT DEDENT def power ( F , n ) : NEW_LINE INDENT M = [ 1 , 1 , 1 ] NEW_LINE if n == 1 : NEW_LINE INDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] NEW_LINE DEDENT return power ( F , n // 2 ) NEW_LINE DEDENT gf_mul ( a , b , p , K ) NEW_LINE if n % 2 != 0 : NEW_LINE INDENT gf_mul ( a , M , p , K ) NEW_LINE DEDENT return gf_mul ( a , M , p , K ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT if x > y : NEW_LINE INDENT temp = x NEW_LINE x , y = y , temp NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE assert a == b == c NEW_LINE DEDENT
def check_possibility ( nums ) : NEW_LINE INDENT broken_point = 0 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] > nums [ i + 1 ] : NEW_LINE INDENT broken_point += 1 NEW_LINE if broken_point >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] : NEW_LINE INDENT nums [ i ] , nums [ i + 1 ] = nums [ i + 1 ] , nums [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i + 1 ] , nums [ i ] = nums [ i ] , nums [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def GFG ( mid , array , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if array [ i ] > mid : NEW_LINE INDENT return False NEW_LINE DEDENT sum += array [ i ] NEW_LINE if sum > mid : NEW_LINE INDENT count += 1 NEW_LINE sum = array [ i ] NEW_LINE DEDENT DEDENT count += 1 NEW_LINE if count <= K : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE global M NEW_LINE global memo NEW_LINE while True : NEW_LINE INDENT M = input ( ) NEW_LINE N = input ( ) NEW_LINE if M == 0 : NEW_LINE INDENT break NEW_LINE DEDENT data = [ int ( x , 2 ) for x in input ( ) . split ( ) ] NEW_LINE memo . append ( - 1 ) NEW_LINE print ( rec ( 0 , data ) ) NEW_LINE DEDENT def rec ( used , data ) : NEW_LINE INDENT if len ( data ) <= 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if memo [ used ] >= 0 : NEW_LINE INDENT return memo [ used ] NEW_LINE DEDENT ret = 99 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( used & ( 3 << ( 2 * i ) ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT on = [ ] NEW_LINE off = [ ] NEW_LINE for v in data : NEW_LINE INDENT if ( v & ( 1 << i ) ) : NEW_LINE INDENT on . append ( v ) NEW_LINE DEDENT else : NEW_LINE INDENT off . append ( v ) NEW_LINE DEDENT DEDENT if not on or not off : NEW_LINE INDENT continue NEW_LINE DEDENT ret = min ( ret , max ( rec ( used | ( 1 << ( 2 * i ) ) , on ) , rec ( used | ( 2 << ( 2 * i ) ) , off ) ) ) NEW_LINE DEDENT memo [ used ] = ret + 1 NEW_LINE return ret + 1 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE for tc in range ( t ) : NEW_LINE INDENT a , b = tc NEW_LINE print ( solve ( a , b ) ) NEW_LINE DEDENT sys . exit ( ) NEW_LINE DEDENT
def solve ( a , b , n ) : NEW_LINE INDENT ans = [ ] NEW_LINE max = int ( ' - 1' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT max = max ( max , ( a [ i ] - b [ i ] ) ) NEW_LINE DEDENT if max < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] - max NEW_LINE if temp <= 0 : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( temp ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ans [ i ] != b [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def GFG ( N ) : NEW_LINE INDENT N = N . lower ( ) NEW_LINE if N [ - 1 ] in [ '0' , '2' , '4' , '6' ] : NEW_LINE INDENT return ( ' Even ' , ' Odd ' ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ' Even ' , ' Odd ' ) NEW_LINE DEDENT DEDENT
def pyvectorize ( ) : NEW_LINE INDENT import numpy as np NEW_LINE import sys NEW_LINE class Vector ( object ) : NEW_LINE INDENT A = np . zeros ( 20 ) NEW_LINE DEDENT def add ( x ) : NEW_LINE INDENT if len ( A ) == len ( A ) : NEW_LINE INDENT A = np . zeros ( len ( A ) * 2 ) NEW_LINE DEDENT A [ : ] = x NEW_LINE return A NEW_LINE DEDENT def delete_back ( ) : NEW_LINE INDENT length -= 1 NEW_LINE DEDENT def __repr__ ( ) : NEW_LINE INDENT s = " " NEW_LINE if length > 0 : NEW_LINE INDENT s += A [ 0 ] NEW_LINE DEDENT for i in range ( 1 , length ) : NEW_LINE INDENT s += " ▁ " + A [ i ] NEW_LINE DEDENT return s NEW_LINE DEDENT class Main ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT self . n , self . q = args NEW_LINE self . v = [ ] NEW_LINE self . active = [ ] NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT for i in range ( 0 , q ) : NEW_LINE INDENT req , t = self . get ( i ) NEW_LINE try : NEW_LINE INDENT if not self . active [ t ] : NEW_LINE INDENT v [ t ] = np . zeros ( len ( v ) ) NEW_LINE self . active [ t ] = True NEW_LINE DEDENT v [ t ] . append ( self . get ( t ) ) NEW_LINE DEDENT except IndexError : NEW_LINE INDENT if self . active [ t ] : NEW_LINE INDENT print ( v [ t ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return Main NEW_LINE DEDENT
def test_pr6 ( ) : NEW_LINE INDENT x , y = symbols ( ' x , y ' , real = True ) NEW_LINE n , k1 , k2 , w1 , w2 , a = symbols ( ' n ▁ k1 ▁ k2 ▁ a ' , integer = True , positive = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = Wild ( ' a ' , exclude = [ x ] ) NEW_LINE if a [ i ] % 2 == 0 : NEW_LINE INDENT w1 += 1 NEW_LINE k1 = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT w2 += 1 NEW_LINE k2 = i + 1 NEW_LINE DEDENT DEDENT assert ( w1 == 1 ) . subs ( a , k2 ) == ( k1 , k2 ) NEW_LINE DEDENT
def GFG ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) NEW_LINE sol = 0 NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + abs ( X [ i - 1 ] - Y [ i - 1 ] ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( count [ i ] - count [ j ] ) > K : NEW_LINE INDENT j += 1 NEW_LINE DEDENT sol = max ( sol , i - j ) NEW_LINE DEDENT return sol NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global INF , EPS NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' hi : ' , [ ' help ' , ' debug ' , ' debug ' ] ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT print ( msg ) NEW_LINE return NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - h ' : NEW_LINE INDENT usage ( ) NEW_LINE return NEW_LINE DEDENT if o == ' - i ' : NEW_LINE INDENT INF = int ( a ) NEW_LINE DEDENT elif o == ' - h ' : NEW_LINE INDENT print ( __doc__ ) NEW_LINE return NEW_LINE DEDENT elif o == ' - i ' : NEW_LINE INDENT DEBUG = int ( a ) NEW_LINE DEDENT elif o == ' - d ' : NEW_LINE INDENT DEBUG = DEBUG NEW_LINE DEDENT elif o == ' - d ' : NEW_LINE INDENT DEBUG = DEBUG NEW_LINE DEDENT elif o == ' - i ' : NEW_LINE INDENT DEBUG = DEBUG NEW_LINE DEDENT elif o == ' - i ' : NEW_LINE INDENT DEBUG = DEBUG NEW_LINE DEDENT elif o == ' - i ' : NEW_LINE INDENT DEBUG = DEBUG NEW_LINE DEDENT DEDENT if args : NEW_LINE INDENT for arg in args : NEW_LINE INDENT if arg not in ( ' - ' , ' - - help ' ) : NEW_LINE INDENT usage ( ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if args : NEW_LINE INDENT for arg in args : NEW_LINE INDENT if arg not in ( ' - ' , ' - - help ' ) : NEW_LINE INDENT usage ( ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if args : NEW_LINE INDENT for arg in args : NEW_LINE INDENT if arg not in ( ' - ' , ' - - help ' ) : NEW_LINE INDENT usage ( ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if args : NEW_LINE INDENT for arg in args : NEW_LINE INDENT if arg not in ( ' - ' , ' - - help ' ) : NEW_LINE INDENT usage ( ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if sys . version_info >= ( 3 , ) : NEW_LINE INDENT print ( deeprepr ( sys . argv [ 0 ] ) ) NEW_LINE DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT n = 15 NEW_LINE if n <= 2 : NEW_LINE INDENT return ( n , 2 ) NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if i * i > n : NEW_LINE INDENT return True NEW_LINE DEDENT return is_prime ( n , i + 1 ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT for x in [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 ] : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT minimumCost = 1 NEW_LINE if minimumCost == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if minimumCost == 2 and minimumCost == 3 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if minimumCost == 4 : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT
def GFG ( x ) : NEW_LINE INDENT right_one , next_higher_one_bit , right_ones_pattern , next = x NEW_LINE if next_higher_one_bit : NEW_LINE INDENT right_one = x & - x NEW_LINE next_higher_one_bit = x + right_one NEW_LINE right_ones_pattern = x ^ next_higher_one_bit NEW_LINE right_ones_pattern = ( right_ones_pattern ) // right_one NEW_LINE right_ones_pattern >>= 2 NEW_LINE next = next_higher_one_bit | right_ones_pattern NEW_LINE DEDENT return next NEW_LINE DEDENT
def GFG ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , j * j <= i ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i / j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i / j NEW_LINE DEDENT DEDENT DEDENT sum = sum - i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ GFG ▁ algorithm . """ NEW_LINE count = 0 NEW_LINE result = np . inf NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if count != 0 : NEW_LINE INDENT result = np . minimum ( result , count ) NEW_LINE DEDENT count = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def get_levenstein ( input ) : NEW_LINE INDENT rev_input = [ input ] NEW_LINE rev_input = rev_input . reverse ( ) NEW_LINE n = len ( input ) NEW_LINE dp = [ [ ] for i in range ( 0 , n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] . append ( i ) NEW_LINE dp [ i ] . append ( i ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if input [ i - 1 ] == rev_input [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = int ( ' ' ) NEW_LINE for i , j in enumerate ( dp ) : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if i < n : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def p_p088 ( p ) : NEW_LINE INDENT ''' p088 ▁ : ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , ' ▁ INTEGER ▁ ' , } NEW_LINE
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE n = int ( sys . argv [ 1 ] ) NEW_LINE sa = sys . argv [ 2 : ] NEW_LINE a = [ int ( x ) for x in sa ] NEW_LINE a = [ int ( x ) for x in a ] NEW_LINE a = [ int ( x ) for x in a ] NEW_LINE mod = 1000000007 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : p = p * i % mod NEW_LINE q = [ 1 ] * n NEW_LINE for i in range ( 1 , n + 1 ) : q [ i ] = ( q [ i - 1 ] + modinv ( i + 1 , mod ) ) % mod NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = q [ i ] + q [ n - i - 1 ] - 1 NEW_LINE val *= a [ i ] NEW_LINE val %= mod NEW_LINE val *= p NEW_LINE val %= mod NEW_LINE ans += val NEW_LINE ans %= mod NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def queue_reverse ( q ) : NEW_LINE INDENT queue = [ ] NEW_LINE print ( queue ) NEW_LINE while not queue : NEW_LINE INDENT print ( queue . pop ( ) , end = ' ▁ ' ) NEW_LINE queue . append ( queue . pop ( ) ) NEW_LINE DEDENT q = reverse_queue ( q ) NEW_LINE q . append ( q ) NEW_LINE return q NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE prime = [ False ] * ( MAX + 1 ) NEW_LINE SieveOfEratosthenes ( ) NEW_LINE for i in range ( MAX + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX * 2 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT def find_diff ( arr , n ) : NEW_LINE INDENT min , max = MAX + 2 , - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == True : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return ( max , min ) NEW_LINE DEDENT def test_diff ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 4 NEW_LINE arr = [ 1 , 2 , 3 , 5 ] NEW_LINE res = find_diff ( arr , n ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( " No ▁ prime ▁ numbers " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Difference ▁ is ▁ % d " % res ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import os NEW_LINE import string NEW_LINE import aj_grl_2 NEW_LINE cost = [ ] NEW_LINE d = [ ] NEW_LINE used = [ ] NEW_LINE V = 0 NEW_LINE INF = 0 NEW_LINE cnt = 0 NEW_LINE def Prim ( s ) : NEW_LINE INDENT d = [ ] NEW_LINE used = [ ] NEW_LINE INF = int ( s ) NEW_LINE del used NEW_LINE del d NEW_LINE d . append ( INF ) NEW_LINE cnt = 0 NEW_LINE while True : NEW_LINE INDENT v = - 1 NEW_LINE for u in range ( V ) : NEW_LINE INDENT if not used [ u ] and ( v == - 1 or d [ u ] < d [ v ] ) : NEW_LINE INDENT v = u NEW_LINE DEDENT DEDENT if v == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT used [ v ] = True NEW_LINE a = d [ v ] / 100 NEW_LINE if a > 0 : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT cnt += a NEW_LINE for k in range ( V ) : NEW_LINE INDENT if not used [ k ] and cost [ v ] != 0 : NEW_LINE INDENT d . append ( min ( cost [ v ] , d [ k ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def AOJ_GRL_2 ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT V = input ( ) . split ( ) NEW_LINE cost = [ ] NEW_LINE if V == 0 : NEW_LINE INDENT break NEW_LINE DEDENT n = input ( ) . split ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT input = input . split ( ) NEW_LINE a = int ( input [ 0 ] ) NEW_LINE b = int ( input [ 1 ] ) NEW_LINE c = int ( input [ 2 ] ) NEW_LINE cost . append ( a ) NEW_LINE cost . append ( b ) NEW_LINE cost . append ( c ) NEW_LINE DEDENT Prim ( 0 ) NEW_LINE print ( cnt ) NEW_LINE DEDENT DEDENT AOJ_GRL_2 ( ) NEW_LINE DEDENT
def test_A_Summer_Camp ( ) : NEW_LINE INDENT import random NEW_LINE import math NEW_LINE import string NEW_LINE import math NEW_LINE import random NEW_LINE import math NEW_LINE import random NEW_LINE import math NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import
def test_GFG ( ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = [ False ] * 26 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = P [ j ] - ' a ' NEW_LINE if freq [ pos ] == True : NEW_LINE INDENT break NEW_LINE DEDENT freq [ pos ] = True NEW_LINE s += P [ j ] NEW_LINE S . add ( s ) NEW_LINE DEDENT DEDENT return len ( S ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - d | - e | - u | - t ] ▁ [ - d | - e | - u | - t ] """ % sys . argv [ 0 ] ) NEW_LINE print ( """ ▁ - d ▁ : ▁ decode ▁ ASCII ▁ data ▁ ( default ) STRNEWLINE ▁ ▁ - e ▁ : ▁ encode ▁ ASCII ▁ data ▁ ( default ) STRNEWLINE ▁ ▁ - u ▁ : ▁ encode ▁ and ▁ decode ▁ Unicode ▁ data ▁ ( default ) STRNEWLINE ▁ ▁ - t ▁ : ▁ encode ▁ and ▁ decode ▁ string ▁ ( default ) STRNEWLINE ▁ ▁ - h ▁ : ▁ print ▁ this ▁ help """ ) NEW_LINE return NEW_LINE DEDENT for o , a in opts : NEW_LINE INDENT if o == ' - d ' : NEW_LINE INDENT decode ( a ) NEW_LINE DEDENT elif o == ' - u ' : NEW_LINE INDENT encode ( a ) NEW_LINE DEDENT elif o == ' - t ' : NEW_LINE INDENT encode ( a ) NEW_LINE DEDENT elif o == ' - t ' : NEW_LINE INDENT encode ( a ) NEW_LINE DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT min_diff = S . Infinity NEW_LINE for i in ( 1 , 2 , 3 ) : NEW_LINE INDENT cnt = S . Pi / 2 NEW_LINE if cnt == n - k : NEW_LINE INDENT temp = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT temp . append ( a [ j ] ) NEW_LINE DEDENT DEDENT max_diff = S . Infinity NEW_LINE for j in range ( len ( temp ) - 1 ) : NEW_LINE INDENT max_diff = max ( max_diff , temp [ j + 1 ] - temp [ j ] ) NEW_LINE DEDENT min_diff = min ( min_diff , max_diff ) NEW_LINE DEDENT DEDENT assert min_diff == min_diff NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ difference ▁ of ▁ the ▁ elements ▁ of ▁ the ▁ GFG . """ NEW_LINE largest = arr [ 0 ] NEW_LINE i = None NEW_LINE for i in range ( n ) : NEW_LINE INDENT if largest < arr [ i ] : NEW_LINE INDENT largest = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = largest - arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def countKdivPairs ( A , n , K ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ number ▁ of ▁ Kdiv ▁ pairs ▁ in ▁ the ▁ given ▁ number ▁ of ▁ Kdiv ▁ pairs . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ A ▁ : ▁ array _ like STRNEWLINE ▁ Input ▁ array . STRNEWLINE ▁ n ▁ : ▁ int STRNEWLINE ▁ Number ▁ of ▁ Kdiv ▁ pairs . STRNEWLINE ▁ K ▁ : ▁ int STRNEWLINE ▁ Number ▁ of ▁ Kdiv ▁ pairs ▁ in ▁ the ▁ given ▁ number ▁ of ▁ Kdiv ▁ pairs . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ count ▁ : ▁ int STRNEWLINE ▁ Number ▁ of ▁ Kdiv ▁ pairs ▁ in ▁ the ▁ given ▁ number ▁ of ▁ Kdiv ▁ pairs . STRNEWLINE STRNEWLINE ▁ """ NEW_LINE A = np . array ( [ 2 , 2 , 1 , 7 , 5 , 3 ] ) NEW_LINE n = 6 NEW_LINE K = 4 NEW_LINE return sum ( [ count * ( count - 1 ) / 2 for count in A ] ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while True : NEW_LINE INDENT S = sys . stdin . readline ( ) . split ( ) NEW_LINE if S [ 0 ] == '0' : NEW_LINE INDENT break NEW_LINE DEDENT S = sys . stdin . readline ( ) . split ( ) NEW_LINE if S [ 0 ] == ' + ' : NEW_LINE INDENT print ( S [ 0 ] ) NEW_LINE f = True NEW_LINE break NEW_LINE DEDENT if S [ 0 ] == ' - ' : NEW_LINE INDENT S = sys . stdin . readline ( ) . split ( ) NEW_LINE if S [ 0 ] == ' + ' : NEW_LINE INDENT print ( S [ 0 ] ) NEW_LINE f = False NEW_LINE break NEW_LINE DEDENT DEDENT if f and S [ 0 ] == ' - ' : NEW_LINE INDENT S = sys . stdin . readline ( ) . split ( ) NEW_LINE if S [ 0 ] == ' + ' : NEW_LINE INDENT S = sys . stdin . readline ( ) . split ( ) NEW_LINE if S [ 0 ] == ' - ' : NEW_LINE INDENT S = sys . stdin . readline ( ) . split ( ) NEW_LINE DEDENT DEDENT DEDENT if f and S [ 0 ] == ' + ' : NEW_LINE INDENT S = sys . stdin . readline ( ) . split ( ) NEW_LINE if S [ 0 ] == ' - ' : NEW_LINE INDENT S = sys . stdin . readline ( ) . split ( ) NEW_LINE DEDENT DEDENT if f and S [ 0 ] == ' - ' : NEW_LINE INDENT S = sys . stdin . readline ( ) . split ( ) NEW_LINE if S [ 0 ] == ' + ' : NEW_LINE INDENT S = sys . stdin . readline ( ) . split ( ) NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( ' NA ' ) NEW_LINE DEDENT DEDENT DEDENT
def import ( arr , n ) : NEW_LINE INDENT """ STRNEWLINE ▁ Import ▁ a ▁ binary ▁ array ▁ into ▁ a ▁ binary ▁ array . STRNEWLINE ▁ """ NEW_LINE max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if arr [ curr ] == 0 : NEW_LINE INDENT if curr - prev_prev_zero > max_count : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if n - prev_prev_zero > max_count : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT
def test_solution ( ) : NEW_LINE INDENT ans = Integer ( 0 ) NEW_LINE for rem in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if n % rem == 0 : NEW_LINE INDENT ans = min ( ans , rem + ( n // rem ) * k ) NEW_LINE DEDENT DEDENT DEDENT
def GFG ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a %= mod NEW_LINE while b : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( 2 * a ) % mod NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import string NEW_LINE MAX = ' Z ' - ' A ' + 1 NEW_LINE n = 0 NEW_LINE inDeg , outDeg , vis = getopt . getopt ( sys . argv [ 1 : ] , ' a ' ) NEW_LINE nei = [ ] NEW_LINE check ( ) NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if vis [ i ] != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if inDeg [ i ] != outDeg [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE def dfs ( k ) : NEW_LINE INDENT if vis [ k ] == 1 : NEW_LINE INDENT return NEW_LINE DEDENT vis [ k ] = 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if 0 < nei [ k ] [ i ] : NEW_LINE INDENT dfs ( i ) NEW_LINE DEDENT DEDENT DEDENT def run ( ) : NEW_LINE INDENT n = 0 NEW_LINE inDeg = [ ] NEW_LINE outDeg = [ ] NEW_LINE vis = [ ] NEW_LINE nei = [ ] NEW_LINE print ( ' ' ) NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT c = string . split ( sys . stdin . readline ( ) ) NEW_LINE u = c [ 0 ] - ' a ' NEW_LINE v = c [ - 1 ] - ' a ' NEW_LINE outDeg [ u ] += 1 NEW_LINE inDeg [ v ] += 1 NEW_LINE nei [ u ] [ v ] = 1 NEW_LINE vis [ u ] = vis [ v ] = - 1 NEW_LINE s = u NEW_LINE DEDENT dfs ( s ) NEW_LINE if check ( ) : NEW_LINE INDENT print ( ' OK ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NG ' ) NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE N = len ( sys . argv ) NEW_LINE a = np . arange ( N ) NEW_LINE index = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if abs ( a [ index ] ) < abs ( a [ i ] ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT print ( 2 * N - 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( ( index + 1 ) , ( i + 1 ) ) NEW_LINE DEDENT if a [ index ] > 0 : NEW_LINE INDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT print ( ( i - 1 ) , i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( ( i + 1 ) , i ) NEW_LINE DEDENT DEDENT DEDENT
def get_GFG ( str ) : NEW_LINE INDENT """ STRNEWLINE ▁ Given ▁ a ▁ string ▁ and ▁ a ▁ string ▁ of ▁ letters , ▁ return ▁ a ▁ list ▁ of ▁ strings . STRNEWLINE ▁ """ NEW_LINE len = len ( str ) NEW_LINE len -= 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] != str [ len ] : NEW_LINE INDENT return [ ] NEW_LINE DEDENT len -= 1 NEW_LINE DEDENT return [ str ] NEW_LINE DEDENT def print_solution ( partitions ) : NEW_LINE INDENT for i in partitions : NEW_LINE INDENT for j in i : NEW_LINE INDENT print ( j , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def add_strings ( v , s , temp , index = None ) : NEW_LINE INDENT s = ' ' . join ( s ) NEW_LINE current = [ temp ] NEW_LINE if index is None : NEW_LINE INDENT temp = [ ] NEW_LINE DEDENT for i in range ( index , len ( s ) ) : NEW_LINE INDENT str = str + s [ i ] NEW_LINE if check_palindrome ( str ) : NEW_LINE INDENT temp . append ( str ) NEW_LINE if i + 1 < len ( s ) : NEW_LINE INDENT v = add_strings ( v , s , temp , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( temp ) NEW_LINE DEDENT temp = [ current ] NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT def partition ( s , v ) : NEW_LINE INDENT temp = [ ] NEW_LINE v = add_strings ( v , s , temp , 0 ) NEW_LINE print_solution ( v ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = ' geeks ' NEW_LINE partitions = [ ] NEW_LINE partition ( s , partitions ) NEW_LINE DEDENT
def pympmath_comb ( Z ) : NEW_LINE INDENT import mpmath NEW_LINE import mpmath . mp as mpmath NEW_LINE M = 100000007 NEW_LINE comb = mpmath . mp . mpf ( str ( n - i ) ) / mpmath . mp . mpf ( str ( i + 1 ) ) NEW_LINE return comb . mod ( mpmath . mp . mpf ( str ( M ) ) ) . mod ( mpmath . mp . mpf ( str ( M ) ) ) . mod ( mpmath . mp . mpf ( str ( M ) ) ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT M = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if M . has_key ( i ) : NEW_LINE INDENT M [ i ] = M [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT M [ i ] = 1 NEW_LINE DEDENT DEDENT num_count = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 0 , k + 1 ) : NEW_LINE INDENT num_count [ i ] = 0 NEW_LINE DEDENT itr = M . keys ( ) NEW_LINE for i in itr : NEW_LINE INDENT if i <= k : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if i * i > k : NEW_LINE INDENT break NEW_LINE DEDENT num_count [ i * i ] += i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT lcm , length = 0 , 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if num_count [ i ] > length : NEW_LINE INDENT length = num_count [ i ] NEW_LINE lcm = i NEW_LINE DEDENT DEDENT if lcm == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " LCM ▁ = ▁ % d , ▁ Length ▁ = ▁ % d " % ( lcm , length ) ) NEW_LINE print ( " Indexes ▁ = ▁ " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lcm % arr [ i ] == 0 : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ pairs ▁ of ▁ leading ▁ zeros . """ NEW_LINE odd1 , even1 = [ ] , [ ] NEW_LINE odd2 , even2 = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT odd1 . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT even1 . append ( 0 ) NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT odd2 . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT even2 . append ( 0 ) NEW_LINE DEDENT DEDENT pairs = [ min ( odd1 , odd2 ) , min ( even1 , even2 ) ] NEW_LINE assert pairs == [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE DEDENT
def GFG ( a , b , n , m ) : NEW_LINE INDENT odd1 , even1 = 0 , 0 NEW_LINE odd2 , even2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 1 : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if b [ i ] % 2 == 1 : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , even2 ) + min ( odd2 , even1 ) NEW_LINE return pairs NEW_LINE DEDENT
def maximum_diffrence ( arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE min_element = arr [ 0 ] NEW_LINE i = 0 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if arr [ i ] - min_element > max_diff : NEW_LINE INDENT max_diff = arr [ i ] - min_element NEW_LINE DEDENT if arr [ i ] < min_element : NEW_LINE INDENT min_element = arr [ i ] NEW_LINE DEDENT DEDENT return max_diff , min_element NEW_LINE DEDENT
def GFG ( n , k ) : NEW_LINE INDENT C = [ [ 0 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n + [ k + 1 ] * n NEW_LINE return C
def GFG ( ) : NEW_LINE INDENT MAX = 26 NEW_LINE max_element = len ( freq ) NEW_LINE max_ele = freq [ 0 ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if max_ele < freq [ i ] : NEW_LINE INDENT max_ele = freq [ i ] NEW_LINE DEDENT DEDENT return max_ele NEW_LINE DEDENT
def test_195 ( ) : NEW_LINE INDENT f = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) NEW_LINE n = len ( f ) NEW_LINE a = f . T NEW_LINE b = f . T NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if abs ( a [ i ] - b [ i ] ) > 5 : NEW_LINE INDENT sum += 10 - abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT assert sum == 10 NEW_LINE f = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) NEW_LINE n = len ( f ) NEW_LINE a = f . T NEW_LINE b = f . T NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if abs ( a [ i ] - b [ i ] ) > 5 : NEW_LINE INDENT sum += 10 - abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT assert sum == 10 NEW_LINE f = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) NEW_LINE n = len ( f ) NEW_LINE a = f . T NEW_LINE b = f . T NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if abs ( a [ i ] - b [ i ] ) > 5 : NEW_LINE INDENT sum += 10 - abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT assert sum == 10 NEW_LINE f = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) NEW_LINE n = len ( f ) NEW_LINE a = f . T NEW_LINE b = f . T NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if abs ( a [ i ] - b [ i ] ) > 5 : NEW_LINE INDENT sum += 10 - abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT assert sum == 10 NEW_LINE f = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) NEW_LINE n = len ( f ) NEW_LINE a = f . T NEW_LINE b = f .
def pyGFG ( ) : NEW_LINE INDENT MAX = 32 NEW_LINE pow2 = [ ] NEW_LINE visited = [ ] NEW_LINE ans = Vector ( ) NEW_LINE def power_2 ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT pow2 . append ( ans ) NEW_LINE ans *= 2 NEW_LINE DEDENT DEDENT def count_set_bits ( x ) : NEW_LINE INDENT set_bits = 0 NEW_LINE while x != 0 : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE set_bits += 1 NEW_LINE DEDENT return set_bits NEW_LINE DEDENT def add ( num ) : NEW_LINE INDENT point = 0 NEW_LINE value = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if num % 2 == 1 : NEW_LINE INDENT value += ( 1 << i ) NEW_LINE DEDENT num /= 2 NEW_LINE DEDENT DEDENT ans . append ( value ) NEW_LINE DEDENT solve ( n = 3 , k = 5 ) NEW_LINE DEDENT
def p027 ( ) : NEW_LINE INDENT print ( [ ' p027 . py ' , ' p027 . c ' , ' p027 . h ' , ' p027 . i ' , ' p027 . j ' , ' p027 . k ' , ' p027 . l ' , ' p027 . m ' , ' p027 . n ' , ' p027 . o ' , ' p027 . p ' , ' p027 . q ' , ' p027 . r ' , ' p027 . s ' , ' p027 . t ' , ' p027 . u ' , ' p027 . v ' , ' p027 . w ' , ' p027 . x ' , ' p027 . y ' , ' p027 . z ' , ' p027 . w ' , ' p027 . x ' , ' p027 . y ' , ' p027 . z ' , ' p027 . w ' , ' p027 . x ' , ' p027 . y ' , ' p027 . z ' , ' p027 . w ' , ' p027 . x ' , ' p027 . y ' , ' p027 . z ' , ' p027 . w ' , ' p027 . x ' , ' p027 . y ' , ' p027 . z ' , ' p027 . w ' , ' p027 . x ' , ' p027 . y ' , ' p027 . z ' , ' p027 . w ' , ' p027 . x ' , ' p027 . y ' , ' p027 . z ' , ' p027 . w ' , ' p027 . x ' , ' p027 . y ' , ' p027 . z ' , ' p027 . w ' , ' p027 . x ' , ' p027 . y ' , ' p027 . z ' , ' p027 . w ' , ' p027 . x ' , ' p027 . y ' , ' p027 . z ' , ' p027 . w ' , ' p027 . x ' , ' p027 . y ' , ' p027 . z ' , ] ) NEW_LINE best_num = 0 NEW_LINE best_a
def test_pre149 ( ) : NEW_LINE INDENT import sys NEW_LINE import random NEW_LINE import string NEW_LINE import doctest NEW_LINE import tempfile NEW_LINE import os NEW_LINE import tempfile NEW_LINE import random NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE import tempfile NEW_LINE
def test_GFG ( ) : NEW_LINE INDENT MAX = 100001 NEW_LINE isPrime = [ 0 ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if isPrime [ p ] == 0 : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT def find_subset ( a , n ) : NEW_LINE INDENT cnt1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT DEDENT if cnt1 > 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 1 ) : NEW_LINE INDENT print ( cnt1 + 1 ) NEW_LINE for j in range ( cnt1 ) : NEW_LINE INDENT print ( 1 , a [ i ] , a [ j ] ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT DEDENT DEDENT if cnt1 >= 2 : NEW_LINE INDENT print ( cnt1 ) NEW_LINE for i in range ( cnt1 ) : NEW_LINE INDENT print ( 1 , a [ i ] , a [ j ] ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if isPrime [ a [ i ] + a [ j ] ] == 0 : NEW_LINE INDENT print ( 2 , a [ i ] , a [ j ] ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE return - 1 NEW_LINE DEDENT
def pythontools ( ) : NEW_LINE INDENT import sys NEW_LINE n , r , t , sum , pos = 0 , 0 , 0 , 0 NEW_LINE n , r , t , sum , pos = int ( n ) , int ( r ) , int ( t ) , int ( sum ) NEW_LINE p = [ ] NEW_LINE water = [ ] NEW_LINE empty = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT p . append ( i ) NEW_LINE DEDENT for i in range ( 1 , t ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT pos = ( p [ j ] * i % r ) NEW_LINE if i > 1 : NEW_LINE INDENT empty . append ( pos ) NEW_LINE DEDENT if water [ pos ] : NEW_LINE INDENT water . pop ( pos ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT for j in range ( r ) : NEW_LINE INDENT if empty : NEW_LINE INDENT water . append ( empty ) NEW_LINE empty . append ( 0 ) NEW_LINE DEDENT DEDENT DEDENT print ( sum ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT
def py2exe_options ( ) : NEW_LINE INDENT s = subprocess . Popen ( [ sys . executable , ' - c ' , ' import ▁ sys , ▁ getopt , ▁ getopt , ▁ getopt _ long , ▁ getopt _ short , ▁ getopt _ long , ▁ getopt _ getopt , ▁ getopt _ getopt ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) NEW_LINE n = s . stdout . read ( ) . rstrip ( ) NEW_LINE s . stdin . close ( ) NEW_LINE for line in s . stdout : NEW_LINE INDENT c = line . split ( ' ▁ ' ) NEW_LINE for i in range ( len ( c ) - 6 ) : NEW_LINE INDENT if c [ i ] == ' H ' and c [ i + 1 ] == ' o ' and c [ i + 2 ] == ' s ' and c [ i + 3 ] == ' h ' and c [ i + 4 ] == ' i ' and c [ i + 5 ] == ' n ' and c [ i + 6 ] == ' o ' : NEW_LINE INDENT c [ i + 6 ] = ' a ' NEW_LINE i += 6 NEW_LINE DEDENT DEDENT print ( [ c [ i : i + 6 ] for i in range ( len ( c ) - 6 ) ] ) NEW_LINE DEDENT DEDENT
def binary_search ( arr , low , high ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ number ▁ of ▁ rotations ▁ of ▁ arr ▁ between ▁ low ▁ and ▁ high . STRNEWLINE ▁ """ NEW_LINE if high < low : NEW_LINE INDENT return 0 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return count_rotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return count_rotations ( arr , mid + 1 , high ) NEW_LINE DEDENT
def test_issue_7171 ( ) : NEW_LINE INDENT scn = S ( 1 ) / 2 NEW_LINE n = scn ( 0 ) NEW_LINE k = scn ( 1 ) NEW_LINE i , req = 1 , 1 NEW_LINE while k - req >= 0 : NEW_LINE INDENT if k - req >= 0 : NEW_LINE INDENT k , i = k - req , i % n NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE if i % n != 0 : NEW_LINE INDENT req = i % n NEW_LINE DEDENT else : NEW_LINE INDENT req = n NEW_LINE DEDENT DEDENT assert k == req NEW_LINE DEDENT
def get_GFG ( arr , n , m ) : NEW_LINE INDENT if n > m : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT if DP [ 0 ] : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT if DP [ j ] == True : NEW_LINE INDENT if DP [ ( j + arr [ i ] ) % m ] == False : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if temp [ j ] : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT DEDENT return DP [ 0 ] NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' deut ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - d | - e | - u | - t ] ▁ [ - d | - e | - u | - t ] """ % sys . argv [ 0 ] ) NEW_LINE print ( """ ▁ - d , ▁ - e : ▁ decode ▁ ASCII ▁ strings ▁ ( default ) STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE x = sys . argv [ 1 ] NEW_LINE arr = [ ] NEW_LINE totals = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( sys . argv [ i ] ) NEW_LINE totals . append ( arr [ 0 ] [ i ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = min ( arr [ i - 1 ] [ j ] , arr [ i - 1 ] [ ( j - 1 + n ) % n ] ) NEW_LINE totals . append ( arr [ i ] [ j ] ) NEW_LINE DEDENT totals . append ( x * i ) NEW_LINE DEDENT totals . sort ( ) NEW_LINE print ( totals ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while 1 : NEW_LINE INDENT d , w = sys . stdin . readline ( ) . split ( ) NEW_LINE if d == ' ' : break NEW_LINE G = [ [ int ( x ) for x in line . split ( ) ] for line in open ( ' / proc / cpuinfo ' , ' r ' ) . readlines ( ) ] NEW_LINE max = 0 NEW_LINE for i in range ( d ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT G [ i ] [ j ] = int ( line . split ( ) [ 0 ] ) NEW_LINE DEDENT DEDENT for i in range ( 0 , d - 3 ) : NEW_LINE INDENT for j in range ( 0 , w - 3 ) : NEW_LINE INDENT solve ( G , i , j , 3 , 3 ) NEW_LINE DEDENT DEDENT sys . stdout . write ( max ) NEW_LINE DEDENT DEDENT
def test_codechef ( ) : NEW_LINE INDENT import sympy NEW_LINE n = Symbol ( ' n ' ) NEW_LINE k = Symbol ( ' k ' ) NEW_LINE arr = [ sympy . Wild ( ' arr ' ) for i in range ( int ( n ) ) ] NEW_LINE if k == 1 : NEW_LINE INDENT print ( n ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( int ( n ) ) : NEW_LINE INDENT if ans [ i ] == 0 : NEW_LINE INDENT ktimes = k * arr [ i ] NEW_LINE index = bisect . bisect_left ( arr , ktimes ) NEW_LINE if index >= 0 : NEW_LINE INDENT ans . append ( - 1 ) NEW_LINE DEDENT DEDENT DEDENT ans1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ans [ i ] == 0 : NEW_LINE INDENT ans1 += 1 NEW_LINE DEDENT DEDENT assert ans1 == 0 NEW_LINE DEDENT
def GFG ( k , n ) : NEW_LINE INDENT sum = int ( pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ) NEW_LINE return sum NEW_LINE DEDENT
def GFG ( i , tight , sum_so_far , Sum , number , len ) : NEW_LINE INDENT if i == len ( number ) : NEW_LINE INDENT if sum_so_far == Sum : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = dp [ i ] [ 1 ] [ sum_so_far ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = 0 NEW_LINE ntight = 0 NEW_LINE nsum_so_far = 0 NEW_LINE for currdigit in range ( '0' , '9' ) : NEW_LINE INDENT if not tight and currdigit > number [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT ntight = tight or currdigit < number [ i ] NEW_LINE nsum_so_far = sum_so_far + ( currdigit - '0' ) NEW_LINE ans += solve ( i + 1 , ntight , nsum_so_far , Sum , number , len ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def test_friend_decision ( ) : NEW_LINE INDENT """ Test ▁ the ▁ decision ▁ function . """ NEW_LINE count = 0 NEW_LINE def f ( entery ) : NEW_LINE INDENT n = len ( entery ) NEW_LINE entery = entery . split ( ' ▁ ' ) NEW_LINE arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( entery [ i ] ) NEW_LINE decision ( arr ) NEW_LINE DEDENT return count NEW_LINE DEDENT def decision ( entery ) : NEW_LINE INDENT localct = 0 NEW_LINE inputs = entery . split ( ' ▁ ' ) NEW_LINE for i in inputs : NEW_LINE INDENT if i == '1' : NEW_LINE INDENT localct += 1 NEW_LINE DEDENT DEDENT if localct > 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT return f NEW_LINE DEDENT
def pythree_level_difference ( root ) : NEW_LINE INDENT import sys NEW_LINE import struct NEW_LINE class Node : NEW_LINE INDENT data = 0 NEW_LINE left , right = struct . unpack ( ' > H ' , root . data ) NEW_LINE DEDENT class GFG : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = self . right = None NEW_LINE DEDENT def data ( self , key ) : NEW_LINE INDENT if self . key == self . key : NEW_LINE INDENT return self . left NEW_LINE DEDENT q = Queue ( ) NEW_LINE q . put ( self . key ) NEW_LINE level = 0 NEW_LINE evenSum , oddSum = 0 , 0 NEW_LINE while len ( q ) != 0 : NEW_LINE INDENT size = len ( q ) NEW_LINE level += 1 NEW_LINE while size > 0 : NEW_LINE INDENT temp = q . pop ( ) NEW_LINE if level % 2 == 0 : NEW_LINE INDENT evenSum += temp . data NEW_LINE DEDENT else : NEW_LINE INDENT oddSum += temp . data NEW_LINE DEDENT if temp . left : NEW_LINE INDENT q . put ( temp . left ) NEW_LINE DEDENT if temp . right : NEW_LINE INDENT q . put ( temp . right ) NEW_LINE DEDENT size -= 1 NEW_LINE DEDENT DEDENT return ( oddSum - evenSum ) NEW_LINE DEDENT DEDENT return GFG NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = [ 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 ] NEW_LINE count = 0 NEW_LINE number = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number += ( count ) * ( count + 1 ) / 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if count != 0 : NEW_LINE INDENT number += ( count ) * ( count + 1 ) / 2 NEW_LINE DEDENT return number NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT a = [ 1 , 5 , 5 , 1 , 6 , 1 ] NEW_LINE n = len ( a ) NEW_LINE assert a == n NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while True : NEW_LINE INDENT n = input ( ) . split ( ) NEW_LINE if n == ' ' : NEW_LINE INDENT return NEW_LINE DEDENT up1 , up2 = 0 , 0 NEW_LINE k = [ int ( x ) for x in n . split ( ) ] NEW_LINE if k [ 0 ] > 0 : NEW_LINE INDENT up1 += 1 NEW_LINE if k [ 1 ] >= 2 : NEW_LINE INDENT up2 += 1 NEW_LINE DEDENT DEDENT if up2 == 0 : NEW_LINE INDENT print ( ' NA ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( up1 + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def get_graph_path ( m , n ) : NEW_LINE INDENT if m == 1 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return get_graph_path ( m - 1 , n ) + get_graph_path ( m , n - 1 ) NEW_LINE DEDENT
def GFG ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT
def import ( arr , n ) : NEW_LINE INDENT import numpy as np NEW_LINE class solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . n = n NEW_LINE DEDENT def countPairs ( self ) : NEW_LINE INDENT return len ( self . n ) NEW_LINE DEDENT def countPairs ( self ) : NEW_LINE INDENT return len ( self . n ) NEW_LINE DEDENT def countPairs ( self ) : NEW_LINE INDENT return len ( self . n ) NEW_LINE DEDENT def countPairs ( self ) : NEW_LINE INDENT return len ( self . n ) NEW_LINE DEDENT DEDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
def test_GFG ( arr , n ) : NEW_LINE INDENT s = set ( arr ) NEW_LINE index = 0 NEW_LINE mp = { } NEW_LINE for itr in s : NEW_LINE INDENT index += 1 NEW_LINE mp [ itr ] = index NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = mp [ arr [ i ] ] NEW_LINE DEDENT def query ( BIT ) : NEW_LINE INDENT ans = 0 NEW_LINE while index > 0 : NEW_LINE INDENT ans = max ( ans , BIT [ index ] ) NEW_LINE index -= index & ( - index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def update ( BIT , index , n ) : NEW_LINE INDENT x = query ( BIT , index - 1 , n ) NEW_LINE value = x + 1 NEW_LINE while index <= n : NEW_LINE INDENT BIT [ index ] = max ( BIT [ index ] , value ) NEW_LINE index += index & ( - index ) NEW_LINE DEDENT DEDENT def find_LISLength ( arr ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT BIT [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT update ( BIT , arr [ i ] , n ) NEW_LINE DEDENT ans = query ( BIT , n , n ) NEW_LINE return ans NEW_LINE DEDENT
def groups ( ) : NEW_LINE INDENT f = open ( ' groups . txt ' ) NEW_LINE Q = int ( f . readline ( ) ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT N = int ( f . readline ( ) ) NEW_LINE schedule = [ [ ] for _ in range ( N ) ] NEW_LINE x = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT line = f . readline ( ) NEW_LINE sr = re . split ( ' \s + ' , line ) NEW_LINE for k in range ( 5 ) : NEW_LINE INDENT schedule [ x ] . append ( int ( sr [ k ] ) ) NEW_LINE DEDENT x += 1 NEW_LINE DEDENT check = False NEW_LINE outer : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT for k in range ( j + 1 , 5 ) : NEW_LINE INDENT day1count = 0 NEW_LINE day2count = 0 NEW_LINE bothcount = 0 NEW_LINE neither = 0 NEW_LINE for l in schedule : NEW_LINE INDENT if schedule [ l ] [ j ] == 0 and schedule [ l ] [ k ] == 0 : NEW_LINE INDENT neither += 1 NEW_LINE DEDENT if schedule [ l ] [ j ] == 1 and schedule [ l ] [ k ] == 0 : NEW_LINE INDENT day1count += 1 NEW_LINE DEDENT elif schedule [ l ] [ j ] == 0 and schedule [ l ] [ k ] == 1 : NEW_LINE INDENT day2count += 1 NEW_LINE DEDENT elif schedule [ l ] [ j ] == 1 and schedule [ l ] [ k ] == 1 : NEW_LINE INDENT bothcount += 1 NEW_LINE DEDENT DEDENT if neither > 0 : NEW_LINE INDENT continue NEW_LINE DEDENT elif day1count > len ( schedule ) / 2 or day2count > len ( schedule ) / 2 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT check = True NEW_LINE break outer NEW_LINE DEDENT DEDENT DEDENT print ( check and " YES " ) NEW_LINE DEDENT DEDENT DEDENT
def test_p164 ( ) : NEW_LINE INDENT assert [ 1 , 2 , 3 , 4 ] == [ 1 , 2 , 3 , 4 ] NEW_LINE BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CONSECUTIVE = 3 NEW_LINE MAX_SUM = 9 NEW_LINE def run ( ) : NEW_LINE INDENT ways = [ [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 2 , 3 , 4 ] ] NEW_LINE return ways NEW_LINE DEDENT for prefix in [ 1 , 2 , 3 , 4 ] : NEW_LINE INDENT
def py ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE import string NEW_LINE import os NEW_LINE import re NEW_LINE import ast NEW_LINE import ast . nodes NEW_LINE import ast . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE import ast . nodes . nodes NEW_LINE DEDENT
def class Solution ( matrix ) : NEW_LINE INDENT for r in range ( 1 , len ( matrix ) ) : NEW_LINE INDENT for c in range ( 1 , len ( matrix [ 0 ] ) ) : NEW_LINE INDENT if matrix [ r - 1 ] [ c - 1 ] != matrix [ r ] [ c ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def p094 ( ) : NEW_LINE INDENT print ( [ ' p094' ] ) NEW_LINE LIMIT = library . pow ( 10 , 9 ) NEW_LINE sum = 0 NEW_LINE for s in range ( 1 , ( LIMIT + 1 ) // 3 + 1 ) : NEW_LINE INDENT for t in range ( s - 2 , 0 , - 1 ) : NEW_LINE INDENT if library . gcd ( s , t ) == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s ** 2 - t ** 2 ) // 2 NEW_LINE c = ( s ** 2 + t ** 2 ) // 2 NEW_LINE if a * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT if a * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT if b * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE DEDENT if p <= LIMIT : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT
def import ( ) : NEW_LINE INDENT import sys NEW_LINE while True : NEW_LINE INDENT N , T , L , B = sys . argv [ 1 : ] NEW_LINE if N == 0 and T == 0 and L == 0 and B == 0 : NEW_LINE INDENT break NEW_LINE DEDENT square = [ ] NEW_LINE for i in range ( L + 1 ) : NEW_LINE INDENT square . append ( 1 ) NEW_LINE DEDENT for i in range ( B + 1 ) : NEW_LINE INDENT square . append ( 2 ) NEW_LINE DEDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for j in range ( T ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for s in range ( 1 , 6 ) : NEW_LINE INDENT idx = 1 NEW_LINE num = i + s NEW_LINE if square [ i ] == 1 : NEW_LINE INDENT idx = 2 NEW_LINE DEDENT if i + s > N : NEW_LINE INDENT num = 2 * N - ( i + s ) NEW_LINE DEDENT if square [ num ] == 2 and j + idx <= T : NEW_LINE INDENT dp [ 0 ] [ j + idx ] += dp [ i ] [ j ] * 1.0 / 6 NEW_LINE DEDENT elif j + idx <= T : NEW_LINE INDENT dp [ num ] [ j + idx ] += dp [ i ] [ j ] * 1.0 / 6 NEW_LINE DEDENT DEDENT DEDENT DEDENT goal = 0.0 NEW_LINE for i in range ( 0 , T ) : NEW_LINE INDENT goal += dp [ N ] [ i ] NEW_LINE DEDENT sys . stdout . write ( " % .6f \n " % goal ) NEW_LINE DEDENT DEDENT
def test_oddsum ( ) : NEW_LINE INDENT x = symbols ( ' x ' ) NEW_LINE t = symbols ( ' t ' , integer = True , positive = True ) NEW_LINE while t . is_odd : NEW_LINE INDENT s = 0 NEW_LINE o = 0 NEW_LINE e = 0 NEW_LINE a = symbols ( ' a ' , integer = True , positive = True ) NEW_LINE x = symbols ( ' x ' , integer = True , positive = True ) NEW_LINE for i in a : NEW_LINE INDENT x = x ** i NEW_LINE s += x NEW_LINE if x % 2 != 0 : NEW_LINE INDENT o += 1 NEW_LINE DEDENT else : NEW_LINE INDENT e += 1 NEW_LINE DEDENT DEDENT if s % 2 != 0 : NEW_LINE INDENT assert s == 0 NEW_LINE DEDENT else : NEW_LINE INDENT if o >= 1 and e >= 1 : NEW_LINE INDENT assert s == 0 NEW_LINE DEDENT else : NEW_LINE INDENT assert not s == 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( H , n , K ) : NEW_LINE INDENT inser = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) NEW_LINE if diff <= K : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff / K ) - 1 NEW_LINE DEDENT DEDENT return inser NEW_LINE DEDENT
def GFG ( str , len ) : NEW_LINE INDENT count = 1 NEW_LINE if len == 1 : NEW_LINE INDENT return count NEW_LINE DEDENT if str [ 0 ] == str [ 1 ] : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , len - 1 ) : NEW_LINE INDENT if str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if str [ len - 1 ] == str [ len - 2 ] : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def test_evensum ( ) : NEW_LINE INDENT import sys NEW_LINE import doctest NEW_LINE import os NEW_LINE import random NEW_LINE import time NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE import random NEW_LINE
def get_perfect_squares ( n ) : NEW_LINE INDENT perfect_squares = [ ] NEW_LINE current , i = 1 , 1 NEW_LINE while current <= n : NEW_LINE INDENT perfect_squares . append ( current ) NEW_LINE current = int ( math . pow ( yield i , 2 ) ) NEW_LINE DEDENT return perfect_squares NEW_LINE DEDENT
def GFG ( side1 , side2 ) : NEW_LINE INDENT h = np . sqrt ( ( side1 ** 2 ) + ( side2 ** 2 ) ) NEW_LINE return h NEW_LINE DEDENT
def pythree_odd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE i = 0 NEW_LINE n = size - 2 NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) > 0 : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ ODD ▁ elements ▁ are ▁ % d ▁ & ▁ % d " % ( x , y ) ) NEW_LINE DEDENT
def test_strone_game ( ) : NEW_LINE INDENT import sys NEW_LINE t = sys . argv [ 1 ] NEW_LINE while t : NEW_LINE INDENT n = len ( t ) NEW_LINE ar = [ 0 ] * n NEW_LINE max = 0 NEW_LINE min = 100000 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ar [ i ] = t [ i ] NEW_LINE if ar [ i ] < min : NEW_LINE INDENT min = ar [ i ] NEW_LINE x = i + 1 NEW_LINE DEDENT if ar [ i ] > max : NEW_LINE INDENT max = ar [ i ] NEW_LINE y = i + 1 NEW_LINE DEDENT DEDENT pos1 , pos2 = 1 , 1 , 1 , 1 , 0 , 0 NEW_LINE pos1 , pos2 += n - x NEW_LINE if pos1 < pos2 : NEW_LINE INDENT a , b = pos1 , pos2 NEW_LINE DEDENT else : NEW_LINE INDENT a , b = pos2 , pos1 NEW_LINE DEDENT pos3 , pos4 += n - y NEW_LINE if pos3 < pos4 : NEW_LINE INDENT b , c = pos3 , pos4 NEW_LINE DEDENT else : NEW_LINE INDENT b , c = pos4 , pos3 NEW_LINE DEDENT div = abs ( y - x ) NEW_LINE if div < a or div < b : NEW_LINE INDENT mm , total = min ( a , b ) , total ( a , b ) NEW_LINE print ( total ) NEW_LINE t -= 1 NEW_LINE DEDENT DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE out = sys . stdout NEW_LINE first = sys . argv [ 1 ] NEW_LINE second = sys . argv [ 2 ] NEW_LINE d = { ' monday ' : 1 , ' tuesday ' : 2 , ' wednesday ' : 3 , ' thursday ' : 4 , ' friday ' : 5 , ' saturday ' : 6 , ' sunday ' : 7 } NEW_LINE diff = 0 NEW_LINE if d [ second ] >= d [ first ] : NEW_LINE INDENT diff = d [ second ] - d [ first ] NEW_LINE DEDENT else : NEW_LINE INDENT diff = 7 - d [ first ] + d [ second ] NEW_LINE DEDENT ok = diff == 0 or diff == 2 or diff == 3 NEW_LINE out . write ( ok and ' YES ' or ' NO ' ) NEW_LINE out . flush ( ) NEW_LINE out . close ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE n = len ( sys . argv ) NEW_LINE f = False NEW_LINE s = False NEW_LINE ind = 0 NEW_LINE x = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x . append ( sys . argv [ i ] ) NEW_LINE if f == False : NEW_LINE INDENT if x [ i ] in [ ' OO ' , ' OO ' , ' OO ' ] : NEW_LINE INDENT f = True NEW_LINE ind = i NEW_LINE DEDENT DEDENT DEDENT if f == True : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i != ind : NEW_LINE INDENT print ( x [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if x [ i ] [ : 2 ] == ' OO ' : NEW_LINE INDENT print ( ' + + ' , x [ i ] [ 2 : 5 ] + ' \n ' ) NEW_LINE DEDENT elif x [ i ] [ 3 : 5 ] == ' OO ' : NEW_LINE INDENT print ( x [ i ] [ : 3 ] + ' + + ' , ' \n ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def GFG ( head ) : NEW_LINE INDENT class Node : NEW_LINE INDENT data = 0 NEW_LINE next = None NEW_LINE def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT def __next__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def print_list ( head ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE do : NEW_LINE INDENT print ( temp . data , end = ' ' ) NEW_LINE temp = temp . next NEW_LINE DEDENT while temp is not head : NEW_LINE INDENT print ( head . data ) NEW_LINE DEDENT DEDENT def delete_k ( head_ref , k ) : NEW_LINE INDENT head = head_ref NEW_LINE if head is None : NEW_LINE INDENT return NEW_LINE DEDENT curr , prev = head , None NEW_LINE while True : NEW_LINE INDENT if curr . next is head and curr == head : NEW_LINE INDENT break NEW_LINE DEDENT print_list ( head ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE DEDENT if curr is head : NEW_LINE INDENT prev = head NEW_LINE while prev . next is head : NEW_LINE INDENT prev = prev . next NEW_LINE DEDENT head = curr . next NEW_LINE prev . next = head NEW_LINE head_ref = head NEW_LINE DEDENT elif curr . next is head : NEW_LINE INDENT prev . next = head NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = curr . next NEW_LINE DEDENT DEDENT return head NEW_LINE DEDENT def insert_k ( head_ref , x ) : NEW_LINE INDENT head = head_ref NEW_LINE temp = Node ( x ) NEW_LINE if head is None : NEW_LINE INDENT temp . next = temp NEW_LINE head_ref = temp NEW_LINE return head_ref NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = head NEW_LINE while temp1 . next is head : NEW_LINE INDENT temp1 = temp1 . next NEW_LINE DEDENT temp1 . next = temp NEW_LINE temp . next = head NEW_LINE DEDENT return head NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT head = None NEW_LINE head = insert_k ( head , 1 ) NEW_LINE head = insert_k ( head , 2 ) NEW_LINE head = insert_k ( head , 3 ) NEW_LINE head = insert_k ( head , 4 ) NEW_LINE head = insert_k ( head , 5 ) NEW_LINE head = insert_k ( head , 6 ) NEW_LINE head = insert_k ( head , 7 ) NEW_LINE head = insert_k ( head , 8 ) NEW_LINE head = insert_k ( head , 9 ) NEW_LINE k = 4 NEW_LINE head = delete_k ( head , k ) NEW_LINE DEDENT DEDENT
def GFG ( cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return int ( ' - inf ' ) NEW_LINE DEDENT if x > 0 : NEW_LINE INDENT return abs ( ( n - cur ) / x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( ( cur - 1 ) / x ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import numpy NEW_LINE import numpy . linalg NEW_LINE import numpy . random NEW_LINE import numpy . ma NEW_LINE import numpy . ma NEW_LINE import numpy . ma . extras NEW_LINE import numpy . ma . extras NEW_LINE import numpy . stats NEW_LINE import numpy . stats NEW_LINE import numpy . ndimage NEW_LINE import numpy . ndimage NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE import numpy . ndimage . measurements NEW_LINE DEDENT
def GFG ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_gcd = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_gcd = __gcd ( curr_gcd , arr [ j ] ) NEW_LINE ans += ( curr_gcd == 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def get_GFG ( char ) : NEW_LINE INDENT if char in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def GFG ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N
def GFG ( ) : NEW_LINE INDENT limit = 10000000 NEW_LINE position = [ 0 ] * ( limit + 1 ) NEW_LINE sieve ( ) NEW_LINE position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if position [ i ] == 0 : NEW_LINE INDENT position [ i ] = yield pos NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def GFG ( len ) : NEW_LINE INDENT DP_s = 9 NEW_LINE num_monotone = [ 0 ] * DP_s NEW_LINE DP = [ [ 0 ] * DP_s , [ 0 ] * DP_s ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , len ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ len - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT
def GFG ( len ) : NEW_LINE INDENT DP_s = 9 NEW_LINE num_monotone = [ 0 ] * DP_s NEW_LINE DP = [ [ 0 ] * DP_s , [ 0 ] * DP_s ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , len ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ len - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT
def GFG ( a , n , l , r ) : NEW_LINE INDENT mx , k = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * mx + 1 NEW_LINE for i in range ( len ( count ) ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * mx + 1 NEW_LINE l , r = min ( l , r ) , min ( r , l ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT
def test_b1680 ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ the ▁ b1680 ▁ algorithm . STRNEWLINE ▁ """ NEW_LINE data = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE T = data . shape [ 0 ] NEW_LINE for t in range ( T ) : NEW_LINE INDENT R , C = t NEW_LINE A = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE r = - 1 NEW_LINE c = - 1 NEW_LINE outer = [ ] NEW_LINE for rr in range ( R ) : NEW_LINE INDENT for cc in range ( C ) : NEW_LINE INDENT if A [ rr , cc ] == ' R ' : NEW_LINE INDENT r = rr NEW_LINE c = cc NEW_LINE break outer NEW_LINE DEDENT DEDENT DEDENT ok = True NEW_LINE for rr in range ( r + 1 , R ) : NEW_LINE INDENT for cc in range ( c ) : NEW_LINE INDENT if A [ rr , cc ] == ' R ' : NEW_LINE INDENT ok = False NEW_LINE DEDENT DEDENT DEDENT assert ok NEW_LINE DEDENT DEDENT
def test ( ) : NEW_LINE INDENT import math NEW_LINE def find_area ( r ) : NEW_LINE INDENT return math . pow ( r , 2 ) NEW_LINE DEDENT assert find_area ( 5 ) == 5 NEW_LINE DEDENT
def pydm_s ( ) : NEW_LINE INDENT global below NEW_LINE vis = [ ] NEW_LINE result = 0 NEW_LINE K = len ( sys . argv ) NEW_LINE adj = [ ] NEW_LINE unis = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT adj . append ( [ ] ) NEW_LINE DEDENT for i in range ( 2 * K ) : NEW_LINE INDENT town = sys . argv [ i ] - 1 NEW_LINE unis . append ( town ) NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT x = sys . argv [ i ] - 1 NEW_LINE y = sys . argv [ i + 1 ] - 1 NEW_LINE adj [ x ] . append ( y ) NEW_LINE adj [ y ] . append ( x ) NEW_LINE DEDENT below = [ ] NEW_LINE vis = [ ] NEW_LINE dfs ( 0 ) NEW_LINE print ( result ) NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT N = 6 NEW_LINE assert nth_term ( N ) == 0 NEW_LINE DEDENT
def get_height ( X ) : NEW_LINE INDENT import numpy as np NEW_LINE import scipy . misc NEW_LINE import scipy . optimize NEW_LINE from scipy . optimize import leastsq NEW_LINE X = np . arange ( 35 ) NEW_LINE return ( 2 * X ) NEW_LINE DEDENT
def pythree_graph ( graph , u , v , k ) : NEW_LINE INDENT """ Return ▁ a ▁ graph ▁ with ▁ the ▁ given ▁ k - th ▁ edge ▁ and ▁ a ▁ graph ▁ of ▁ the ▁ given ▁ v - th ▁ edges . """ NEW_LINE if k == 0 and u == v : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k == 1 and graph [ u , v ] == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT if graph [ u , i ] == 1 : NEW_LINE INDENT count += countwalks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def GFG ( n , b ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE x = ( ( n * math . log10 ( n / M_E ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) / ( math . log10 ( b ) ) NEW_LINE return int ( math . floor ( x ) + 1 ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE global n , q , init NEW_LINE init = 1 NEW_LINE for o , a in getopt . getopt ( sys . argv [ 1 : ] , " qv " ) : NEW_LINE INDENT if o == ' - v ' : NEW_LINE INDENT add ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum ( a for a in a if a ) ) NEW_LINE DEDENT DEDENT global nodes NEW_LINE global size NEW_LINE def init ( n ) : NEW_LINE INDENT size = 1 NEW_LINE while size < n : NEW_LINE INDENT size *= 2 NEW_LINE DEDENT nodes = [ ] NEW_LINE DEDENT def add ( target , value ) : NEW_LINE INDENT while target in nodes : NEW_LINE INDENT nodes . append ( target ) NEW_LINE target += target & ( - target ) NEW_LINE DEDENT DEDENT def sum ( s , t ) : NEW_LINE INDENT return sum ( t ) - sum ( s - 1 ) NEW_LINE DEDENT def sum ( t ) : NEW_LINE INDENT res = 0 NEW_LINE while t : NEW_LINE INDENT res += nodes [ t ] NEW_LINE t -= t & ( - t ) NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE import getopt NEW_LINE try : NEW_LINE INDENT opts , args = getopt . getopt ( sys . argv [ 1 : ] , ' ' ) NEW_LINE DEDENT except getopt . error as msg : NEW_LINE INDENT sys . stdout = sys . stderr NEW_LINE print ( msg ) NEW_LINE print ( """ usage : ▁ % s ▁ [ - n ] ▁ [ - o ▁ < output > ] """ % sys . argv [ 0 ] ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT if args == [ ] : NEW_LINE INDENT usage ( ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if len ( args ) == 0 : NEW_LINE INDENT usage ( ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if len ( args ) > 1 : NEW_LINE INDENT usage ( ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if len ( args ) == 1 : NEW_LINE INDENT usage ( ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if len ( args ) == 2 : NEW_LINE INDENT a , b = args NEW_LINE DEDENT else : NEW_LINE INDENT a , b = solve ( args [ 0 ] ) NEW_LINE DEDENT if len ( args ) == 2 : NEW_LINE INDENT return ( 2 * a + b ) % 1000000007 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * b + a ) % 1000000007 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT import sys NEW_LINE while True : NEW_LINE INDENT numerator = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE denominator = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE maxproduct = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE parts = sys . stdin . readline ( ) . rstrip ( ) NEW_LINE if parts == ' ' : NEW_LINE INDENT break NEW_LINE DEDENT count = 0 NEW_LINE count += Judge ( numerator , denominator , parts , 1 , 0 ) NEW_LINE print ( count ) NEW_LINE DEDENT def Judge ( p , q , separate , now_pro , prev_deno ) : NEW_LINE INDENT count = 0 NEW_LINE if p == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if separate <= 0 : NEW_LINE INDENT return count NEW_LINE DEDENT deno = maxproduct / now_pro + 1 NEW_LINE while separate * q < p * deno : NEW_LINE INDENT deno -= 1 NEW_LINE DEDENT while p * deno >= q and prev_deno <= deno : NEW_LINE INDENT subtraction_deno = q * deno NEW_LINE subtraction_nume = p * deno - q NEW_LINE if now_pro * deno <= maxproduct : NEW_LINE INDENT count += Judge ( subtraction_nume , subtraction_deno , separate - 1 , now_pro * deno , deno ) NEW_LINE DEDENT deno -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def get_GFG ( s ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ a ▁ string ▁ of ▁ the ▁ form ▁ GFG . STRNEWLINE ▁ """ NEW_LINE s = ' ' NEW_LINE ReverseString = s . split ( ) NEW_LINE for i in range ( len ( s ) / 2 ) : NEW_LINE INDENT temp = s [ i ] NEW_LINE s [ i ] = s [ - i - 1 ] NEW_LINE s [ - i - 1 ] = temp NEW_LINE DEDENT return ' ' . join ( reversed ( s ) ) NEW_LINE def binary_conversion ( m ) : NEW_LINE INDENT while m != 0 : NEW_LINE INDENT tmp = m % 2 NEW_LINE s += str ( tmp ) NEW_LINE m = int ( m / 2 ) NEW_LINE DEDENT s = ReverseString ( s ) NEW_LINE DEDENT def find_character ( n , m , i ) : NEW_LINE INDENT binary_conversion ( m ) NEW_LINE s1 = ' ' NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( len ( s ) ) : NEW_LINE INDENT if s [ y ] == '1' : NEW_LINE INDENT s1 += '10' NEW_LINE DEDENT else : NEW_LINE INDENT s1 += '01' NEW_LINE DEDENT DEDENT s = s1 NEW_LINE s1 = ' ' NEW_LINE DEDENT return s [ i ] - '0' NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT m , n , i = 5 , 8 NEW_LINE print ( find_character ( n , m , i ) ) NEW_LINE DEDENT return main NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ number ▁ of ▁ subsets ▁ of ▁ the ▁ generators . """ NEW_LINE us = set ( ) NEW_LINE even_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT us . add ( i ) NEW_LINE DEDENT DEDENT even_count = len ( us ) NEW_LINE assert int ( pow ( 2 , even_count ) - 1 ) == 0 NEW_LINE DEDENT
def test_GFG ( ) : NEW_LINE INDENT """ Test ▁ the ▁ LM ▁ ( LM ) ▁ algorithm . """ NEW_LINE MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE fib = [ 0 ] * MAX NEW_LINE if n == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if n == 1 or n == 2 : NEW_LINE INDENT return ( f [ n ] , 1 ) NEW_LINE DEDENT if f [ n ] != 0 : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = 0 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT k = ( n + 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib [ k ] * fib [ k ] + fib [ k - 1 ] * fib [ k - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib [ k - 1 ] + fib [ k ] ) * fib [ k ] NEW_LINE DEDENT return f NEW_LINE DEDENT
def GFG ( n , w ) : NEW_LINE INDENT x , sum = 0 , 0 NEW_LINE if w >= 0 and w <= 8 : NEW_LINE INDENT x , sum = 9 - w , 9 + w NEW_LINE DEDENT elif w >= - 9 and w <= - 1 : NEW_LINE INDENT x , sum = 10 + w , 10 + w NEW_LINE DEDENT sum = int ( pow ( 10 , n - 2 ) ) NEW_LINE sum = ( x * sum ) NEW_LINE return sum NEW_LINE DEDENT
def find_kth_char ( s , k ) : NEW_LINE INDENT s = s . lower ( ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if ord ( s [ i ] ) == ord ( ' a ' ) : NEW_LINE INDENT total_len += 1 NEW_LINE if total_len == k : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while i < len ( s ) and not ord ( s [ i ] ) == ord ( '0' ) : NEW_LINE INDENT n = n * 10 + ( s [ i ] - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if k <= next_total_len : NEW_LINE INDENT pos = k % total_len NEW_LINE DEDENT else : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return find_kth_char ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT return ' ▁ ' NEW_LINE DEDENT
def test_gf_count_nonempty_substr ( ) : NEW_LINE INDENT assert gf_count_nonempty_substr ( [ ] , ZZ ) == 0 NEW_LINE assert gf_count_nonempty_substr ( [ 1 ] , ZZ ) == 1 NEW_LINE assert gf_count_nonempty_substr ( [ 1 , 2 ] , ZZ ) == 2 NEW_LINE assert gf_count_nonempty_substr ( [ 1 , 2 , 3 ] , ZZ ) == 3 NEW_LINE assert gf_count_nonempty_substr ( [ 1 , 2 , 3 ] , ZZ ) == 3 NEW_LINE assert gf_count_nonempty_substr ( [ 1 , 2 , 3 ] , ZZ ) == 3 NEW_LINE assert gf_count_nonempty_substr ( [ 1 , 2 , 3 ] , ZZ ) == 3 NEW_LINE assert gf_count_nonempty_substr ( [ 1 , 2 , 3 ] , ZZ ) == 3 NEW_LINE assert gf_count_nonempty_substr ( [ 1 , 2 , 3 ] , ZZ ) == 3 NEW_LINE assert gf_count_nonempty_substr ( [ 1 , 2 , 3 ] , ZZ ) == 3 NEW_LINE assert gf_count_nonempty_substr ( [ 1 , 2 , 3 ] , ZZ ) == 3 NEW_LINE assert gf_count_nonempty_substr ( [ 1 , 2 , 3 ] , ZZ ) == 3 NEW_LINE assert gf_count_
