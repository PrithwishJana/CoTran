public static boolean [ ] sieve_of_erastosthenes ( int num ) { boolean [ ] inputArray = new boolean [ num ] ; inputArray [ 0 ] = inputArray [ 1 ] = false ; inputArray [ 2 ] = inputArray [ 3 ] = inputArray [ 5 ] = true ; int sqrt = Math . sqrt ( num ) ; for ( int serial = 3 ; serial < num ; serial += 2 ) { if ( serial >= sqrt ) { return inputArray ; } for ( int s = serial * 2 ; s < num ; s += serial ) { inputArray [ s ] = false ; } } boolean [ ] primeTable = sieve_of_erastosthenes ( 13 * ( 10 * 5 ) ) ; while ( true ) { int k = Integer . parseInt ( JOptionPane . showInputDialog ( null , " Enter ▁ the ▁ prime ▁ to ▁ use ▁ for ▁ the ▁ algorithm " ) ) ; if ( k == 0 ) { break ; } if ( primeTable [ k ] ) { System . out . println ( 0 ) ; } else { int i = k ; while ( primeTable [ i ] == false ) { i ++ ; } int j = i - 1 ; while ( primeTable [ j ] == false ) { j -- ; } System . out . println ( i - j ) ; } } return inputArray ; }
public static final int MAX_CHAR = 26 ; ; public static void countFreq ( String str1 , int [ ] freq , int len1 ) { for ( int i = 0 ; i < len1 ; i ++ ) freq [ ( int ) str1 . charAt ( i ) - ' a ' ] ++ ; ; } public static boolean canMakePalindrome ( int [ ] freq , int len1 ) { int countOdd = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( ( freq [ i ] % 2 != 0 ) && ( freq [ i ] > 0 ) ) countOdd ++ ; ; if ( ( len1 % 2 == 0 ) && ( freq [ len1 ] > 0 ) ) if ( ( countOdd > 0 ) ) return false ; ; else return true ; } public static String findOddAndRemoveItsFreq ( int [ ] freq ) { String oddStr = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( ( freq [ i ] % 2 != 0 ) && ( freq [ i ] > 0 ) ) { freq [ i ] -- ; ; oddStr += ( char ) ( i + ( int ) freq [ i ] / 2 ) ; ; return oddStr ; } ; } public static String findPalindromicString ( String str1 ) { int len1 = str1 . length ( ) ; ; int [ ] freq = new int [ MAX_CHAR ] ; countFreq ( str1 , freq , len1 ) ; ; if ( ( canMakePalindrome ( freq , len1 ) == false ) && ( freq [ len1 ] > 0 ) ) return " No ▁ Palindromic ▁ String " ; oddStr = findOddAndRemoveItsFreq ( freq ) ; String frontStr = " " ; String rearStr = " ▁ " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { String temp = " " ; if ( ( freq [ i ] != 0 ) && ( freq [ i ] > 0 ) ) { char ch = ( char ) ( i + ( int ) freq [ i ] / 2 ) ; ; for ( int j = 1 ; j < ( int ) ( freq [ i ] / 2 ) + 1 ; j ++ ) temp += ch ; ; frontStr += temp ; rearStr = temp + rearStr ; ; } } return ( frontStr + oddStr + rearStr
static public final double cross ( Complex a , Complex b ) { return a . real * b . imag - a . imag * b . real ; }
public static int count9s ( String number ) { int n = number . length ( ) ; int [ ] d = new int [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { d [ i ] = 0 ; } d [ 0 ] = 1 ; int result = 0 ; int modSum = 0 ; int continuousZero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( Character . digit ( number . charAt ( i ) , 10 ) - '0' ) == 0 ) { continuousZero ++ ; } else { continuousZero = 0 ; } modSum += Character . digit ( number . charAt ( i ) , 10 ) - '0' ; modSum %= 9 ; result += d [ modSum ] ; d [ modSum ] ++ ; result -= continuousZero ; } return result ; }
public static int fastPow ( int N , int K ) { if ( ( K == 0 ) || ( K == 1 ) ) return 1 ; ; int temp = fastPow ( N , ( int ) ( K / 2 ) ) ; ; if ( ( K % 2 == 0 ) || ( K % 2 == 1 ) ) return temp * temp ; ; else return N * temp * temp ; }
NUM = ( 0b0111111 , 0b0000110 , 0b1011011 , 0b1001111 , 0b1100110 , 0b1101101 , 0b1111101 , 0b0100111 , 0b1111111 , 0b1101111 , ) ; while ( 1 ) { int n = Integer . parseInt ( input . readLine ( ) ) ; if ( n == - 1 ) break ; int current = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int num = NUM [ Integer . parseInt ( input . readLine ( ) ) ] ; System . out . format ( current ^ num , " b " ) . zfill ( 7 ) ; current = num ; } }
public static int MAX = 10000 ; int [ ] arr = new int [ MAX ] ; public static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; int p = 2 ; while ( p * p < MAX ) { if ( ( prime [ p ] == true ) && ( prime [ p * 2 ] == true ) ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } p ++ ; } for ( int p = 2 ; p < MAX ; p ++ ) { if ( ( prime [ p ] ) ) { arr [ p ] = p ; } } final boolean isEuclid = true ; int product = 1 ; int i = 0 ; while ( ( product < n ) && ( product < n ) ) { product = product * arr [ i ] ; if ( ( product + 1 == n ) && ( product < n ) ) { return true ; } i ++ ; } }
public static final void main ( String [ ] args ) { final int MAX = 100000 ; boolean [ ] prime = new boolean [ MAX ] ; int [ ] arr = new int [ MAX ] ; final boolean [ ] SieveOfEratosthenes = new boolean [ MAX ] ; for ( int p = 2 ; p <= Integer . MAX_VALUE ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { arr [ p ] = p ; } } final boolean isPrimorialPrime = true ; int n = 31 ; if ( ! prime [ n ] ) { return ; } int product = 1 , i = 0 ; while ( product < n ) { product *= arr [ i ] ; if ( product + 1 == n || product - 1 == n ) { return ; } i ++ ; } System . out . println ( " YES " ) ; SieveOfEratosthenes ( n ) ; int n = 31 ; if ( ( isPrimorialPrime ) && ( product < n ) ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } }
static void mulTable ( int N , int i ) { if ( ( i > 10 ) && ( i < N ) ) return ; System . out . println ( N + " * " + i + " = " + N * i ) ; }
public static int closestNumber ( int n , int m ) { int q = ( int ) ( n / m ) ; int n1 = m * q ; if ( ( ( n * m ) > 0 ) && ( ( n * m ) < q ) ) { int n2 = ( m * ( q + 1 ) ) ; if ( ( abs ( n - n1 ) < abs ( n - n2 ) ) ) return n1 ; } return n2 ; }
public static int solve ( int ang , int n ) { if ( ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) && ( ( ang * n ) % 180 != 0 ) ) return 0 ; int ans = 1 ; int freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; }
public static int [ ] computeLps ( String s ) { int n = s . length ( ) ; int [ ] lps = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { lps [ i ] = 0 ; } int Len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( ( i < n ) && ( lps [ i ] == 0 ) ) { if ( ( s . charAt ( i ) == s . charAt ( Len ) ) ) { Len ++ ; lps [ i ] = Len ; i ++ ; } else { if ( ( Len != 0 ) && ( lps [ i ] == 0 ) ) { Len = lps [ Len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } return lps ; } public static void Longestsubstring ( String s ) { lps = computeLps ( s ) ; n = s . length ( ) ; if ( ( lps [ n - 1 ] == 0 ) && ( lps [ n - 1 ] == 0 ) ) { System . out . println ( - 1 ) ; System . exit ( ) ; } for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( ( lps [ i ] == lps [ n - 1 ] ) && ( lps [ i ] == 0 ) ) { System . out . println ( s . substring ( 0 , lps [ i ] ) ) ; System . exit ( ) ; } } if ( ( lps [ lps [ n - 1 ] - 1 ] == 0 ) && ( lps [ n - 1 ] == 0 ) ) { System . out . println ( - 1 ) ; } else { System . out . println ( s . substring ( 0 , lps [ n - 1 ] ) ) ; } } }
public static void checkIfSortRotated ( int [ ] arr , int n ) { int minEle = Integer . MAX_VALUE ; int maxEle = - Integer . MAX_VALUE - 1 ; int minIndex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < minEle ) { minEle = arr [ i ] ; minIndex = i ; } } int flag1 = 1 ; for ( int i = 1 ; i < minIndex ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag1 = 0 ; break ; } } int flag2 = 2 ; for ( int i = minIndex + 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag2 = 0 ; break ; } } if ( ( flag1 && flag2 && arr [ n - 1 ] < arr [ minIndex - 1 ] ) || ( flag1 && flag2 && arr [ n - 1 ] < arr [ minIndex - 1 ] ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } arr [ 0 ] = 3 ; arr [ 1 ] = 4 ; arr [ 2 ] = 5 ; arr [ 3 ] = 1 ; arr [ 4 ] = 2 ; arr [ 5 ] = 0 ; arr [ 6 ] = 0 ; arr [ 7 ] = 0 ; arr [ 8 ] = 0 ; checkIfSortRotated ( arr , n ) ; }
public static int a ( ) { String a = JOptionPane . showInputDialog ( " Enter ▁ a ▁ number " ) ; int n = Integer . parseInt ( a ) ; int d = Integer . parseInt ( a ) ; int [ ] array = JOptionPane . getRootFrame ( ) . getFrames ( ) ; a = 0 ; while ( a < n ) { array [ a ] = Integer . parseInt ( array [ a ] ) ; a ++ ; } a = 0 ; int i = 0 ; while ( i < n - 1 ) { if ( array [ i ] >= array [ i + 1 ] ) { a += ( array [ i ] - array [ i + 1 ] ) / d + 1 ; array [ i + 1 ] += ( ( array [ i ] - array [ i + 1 ] ) / d + 1 ) * d ; } i ++ ; } System . out . println ( a ) ; return a ; }
public static void checkIfPowerIsolated ( int num ) { int input1 = num ; ; int count = 0 ; ; int [ ] factor = new int [ num + 1 ] ; factor [ 0 ] = 0 ; if ( ( num % 2 == 0 ) && ( num % 2 == 1 ) ) { while ( ( num % 2 == 0 ) && ( num % 2 == 1 ) ) { count ++ ; num /= 2 ; } factor [ 2 ] = count ; } int i = 3 ; while ( ( i * i <= num ) && ( num % i == 0 ) ) { count = 0 ; while ( ( num % i == 0 ) && ( num % i == 1 ) ) { count ++ ; num /= i ; } if ( ( count > 0 ) && ( count < factor . length ) ) { factor [ i ] = count ; } i += 2 ; } if ( ( num > 1 ) && ( num < factor . length ) ) { factor [ num ] = 1 ; } int product = 1 ; for ( int i = 0 ; i != factor . length ; i ++ ) { if ( ( factor [ i ] > 0 ) && ( factor [ i ] > 1 ) ) { product = product * factor [ i ] * i ; } } if ( ( product == input1 ) && ( product > 0 ) ) { System . out . println ( " Power - isolated ▁ Integer " ) ; } else { System . out . println ( " Not ▁ a ▁ Power - isolated ▁ Integer " ) ; } }
s , a = 0 , c = 1 ; for ( int x : s ) { if ( x == ' A ' && a ) { a = 0 ; } else if ( x == ' Z ' && ! a ) { a = 1 , c = c + 1 ; } } System . out . println ( " AZ " * c == 0 ? - 1 : c ) ; }
public static final void main ( String [ ] args ) { final Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] [ ] indices = new int [ n ] [ ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) indices [ a [ i ] ] . add ( i ) ; for ( int i = 0 ; i < indices . length ; i ++ ) { if ( indices [ i ] . length < 2 ) continue ; for ( int j = 0 ; j < indices [ i ] . length - 1 ; j ++ ) { int first = indices [ i ] [ j ] ; int second = indices [ i ] [ j + 1 ] ; ans = Math . max ( ans , n - second + first ) ; } } System . out . println ( ans == 0 ? - 1 : ans ) ; for ( ; ; ) { int n = sc . nextInt ( ) ; int [ ] a = Arrays . stream ( sc . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; sc . close ( ) ; } }
public static String multiply ( String num1 , String num2 ) { int len1 = num1 . length ( ) ; int len2 = num2 . length ( ) ; if ( len1 == 0 || len2 == 0 ) return "0" ; char [ ] result = new char [ len1 + len2 ] ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = ( char ) num1 . charAt ( i ) - 48 ; i_n2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int n2 = ( char ) num2 . charAt ( j ) - 48 ; int summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry ; carry = summ / 10 ; result [ i_n1 + i_n2 ] = summ % 10 ; i_n2 ++ ; } if ( ( carry > 0 ) && ( result [ i_n1 + i_n2 ] == 0 ) ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } int i = result . length - 1 ; while ( ( i >= 0 ) && ( result [ i ] == 0 ) ) i -- ; if ( ( i == - 1 ) && ( result [ 0 ] == 0 ) ) return "0" ; String s = " " ; while ( ( i >= 0 ) && ( result [ i ] == 0 ) ) { s += ( char ) ( result [ i ] + 48 ) ; i -- ; } return s ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] X = new int [ n ] ; }
public static int nSquare ( int nSquare , int kth ) { int nRight = nSquare - kth , nLeft = nSquare - kth ; int slogan [ ] = input ( ) ; if ( kth - 1 < ( nSquare - 1 ) - ( nLeft - 1 ) ) { while ( kth - 1 > 0 ) { kth -- ; System . out . println ( " LEFT " ) ; } for ( int i = 0 ; i < nSquare ; i ++ ) { System . out . print ( MessageFormat . format ( " PRINT ▁ { 0 } " , slogan [ i ] ) ) ; if ( i != nSquare - 1 ) System . out . println ( " RIGHT " ) ; } } else { int nRight = nSquare - kth ; while ( nRight > 0 ) { nRight -- ; System . out . println ( " RIGHT " ) ; } for ( int i = nSquare - 1 ; i >= 0 ; i -- ) { System . out . print ( MessageFormat . format ( " PRINT ▁ { 0 } " , slogan [ i ] ) ) ; if ( i != 0 ) System . out . println ( " LEFT " ) ; } } return nRight ; }
public static void printDistSum ( int [ ] arr , int n ) { int Sum = Arrays . stream ( arr ) . mapToInt ( Integer :: intValue ) . sum ( ) ; boolean [ ] [ ] dp = new boolean [ Sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = true ; } for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= Sum ; j ++ ) { if ( ( dp [ i - 1 ] [ j ] == true ) && ( dp [ i ] [ j + arr [ i - 1 ] ] == true ) ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j < Sum + 1 ; j ++ ) { if ( ( dp [ n ] [ j ] == true ) && ( dp [ n ] [ j + arr [ i ] ] == true ) ) { System . out . print ( j + " ▁ " ) ; } } arr [ 0 ] = 2 ; arr [ 1 ] = 3 ; arr [ 2 ] = 4 ; arr [ 3 ] = 5 ; arr [ 4 ] = 6 ; n = arr . length ; printDistSum ( arr , n ) ; }
public static int Subtract ( int a , int b ) { int c = a + ( ~ b + 1 ) ; return c ; }
from ▁ cmd ▁ IDENTCHARS STRNEWLINE ▁ */ public static int [ ] IDENTCHARS ( String input ) { int n = Integer . parseInt ( input ) ; int l = 1 ; int r = n ; while ( ( l < r ) && ( l < n ) ) { int mid = l + ( r - l ) / 2 ; int idxcnt = mid * ( mid + 1 ) / 2 ; if ( ( idxcnt < n ) && ( idxcnt < n ) ) l = mid + 1 ; else r = mid ; } l -- ; int idxcnt = l * ( l + 1 ) / 2 ; System . out . println ( Integer . toString ( n - idxcnt ) ) ; return new int [ ] { n - idxcnt } ; }
public static int n ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] arr = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; final int loveTriangle = arr [ 0 ] ; if ( arr [ 1 ] < 0 ) { if ( arr [ 2 ] == 0 ) return idx ; return - 1 ; } return loveTriangle ( arr [ idx - 1 ] , seen | new HashSet < > ( ) ) ; boolean isTrue = false ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == loveTriangle ( arr [ i - 1 ] , new HashSet < > ( ) ) ) { isTrue = true ; break ; } } if ( isTrue ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; return n ; }
public static int nextZero ( int i , int [ ] occurrences ) { while ( i < 26 ) { if ( occurrences [ i ] == 0 ) return i ; i ++ ; } return - 1 ; } public static String getModifiedString ( String str ) { int n = str . length ( ) ; if ( n > 26 ) return " - 1" ; char [ ] ch = str . toCharArray ( ) ; ch = Arrays . copyOf ( ch , 26 ) ; occurrences [ 26 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { occurrences [ Character . digit ( ch [ i ] , 10 ) - Character . digit ( ' a ' , 10 ) ] ++ ; } int index = nextZero ( 0 , occurrences ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( occurrences [ Character . digit ( ch [ i ] , 10 ) - Character . digit ( ' a ' , 10 ) ] > 1 ) { occurrences [ Character . digit ( ch [ i ] , 10 ) - Character . digit ( ' a ' , 10 ) ] -- ; ch [ i ] = ( char ) ( Character . digit ( ch [ i ] , 10 ) + index ) ; occurrences [ index ] = 1 ; index = nextZero ( index + 1 , occurrences ) ; } } ch = Arrays . copyOf ( ch , ch . length + 1 ) ; System . out . println ( ch ) ; return ch [ 0 ] ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; getModifiedString ( str ) ; } }
public static void isCorrect ( int hourMax , int minuteMax , String time ) { String h = time . substring ( " : " ) ; String m = time . substring ( " : " ) ; String mirrored [ ] = { "0" , "1" , "2" , "5" , "3" , " " , "4" , " " , "5" , "2" , "6" , " " , "7" , " " , "8" , "8" , "9" } ; String mirroredH = mirrored [ h . length ( ) ] + mirrored [ h . charAt ( 0 ) ] ; String mirroredM = mirrored [ m . length ( ) ] + mirrored [ m . charAt ( 0 ) ] ; if ( mirroredH . length ( ) == 2 && Integer . parseInt ( mirroredH ) < minuteMax && mirroredM . length ( ) == 2 && Integer . parseInt ( mirroredM ) < hourMax ) { return mirroredM + " : " + mirroredH ; } return ; } int N = Integer . parseInt ( input . nextLine ( ) ) ; for ( ; ; ) { int hourMax = Integer . parseInt ( input . nextLine ( ) ) ; int minuteMax = Integer . parseInt ( input . nextLine ( ) ) ; int hourNow = Integer . parseInt ( input . nextLine ( ) ) ; int minuteNow = Integer . parseInt ( input . nextLine ( ) ) ; String result = "00:00" ; boolean flag = false ; for ( int hour = hourNow ; hour < hourMax ; hour ++ ) { int start = minuteNow == 0 ? hour : hourNow ; for ( int minute = start ; minute < minuteMax ; minute ++ ) { time = "0" * ( 2 - Integer . parseInt ( input . nextLine ( ) ) ) + Integer . parseInt ( hour ) + " : " + "0" * ( 2 - Integer . parseInt ( input . nextLine ( ) ) ) + Integer . parseInt ( minute ) ; boolean mirrored = isCorrect ( hourMax , minuteMax , time ) ; if ( mirrored ) { result = time ; flag = true ; break ; } } if ( flag ) break ; } System . out . println ( result ) ; } }
public static final int munimumNumberOfPiles ( int n , List < Integer > nValues ) throws Exception { Collections . sort ( nValues ) ; int pile = - 1 ; for ( int idx = 0 , s = nValues . size ( ) ; idx < s ; idx ++ ) { int k = ( int ) Math . ceil ( ( idx + 1 ) / ( s + 1 ) ) ; pile = Math . max ( pile , k ) ; } return pile ; }
x ; for ( int jj = 0 ; jj < x ; jj ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; if ( n == 1 ) { System . out . println ( 3 ) ; } else { if ( n % 2 == 1 ) { System . out . println ( 1 ) ; } else { int p = 0 ; int k = n ; while ( n % 2 == 0 ) { p ++ ; n /= 2 ; } int t = 2 * p ; if ( t == k ) { System . out . println ( t + 1 ) ; } else { System . out . println ( t ) ; } } } } }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ primes " ) ) ; int root = ( int ) ( n * ( 1 / 2 ) ) + 1 ; boolean [ ] isPrime = new boolean [ n + 3 ] ; for ( int i = 4 ; i <= n ; i += 2 ) isPrime [ i ] = false ; int ans = 0 ; int prePrime = - 1 ; for ( int i = 3 ; i <= n ; i += 2 ) { if ( isPrime [ i ] ) { if ( prePrime + 2 == i ) ans += 2 ; prePrime = i ; if ( i > root ) continue ; for ( int j = i * i ; j <= n ; j += i ) isPrime [ j ] = false ; } } System . out . println ( ans ) ; }
public static int [ ] L ( ) { int [ ] L = new int [ 10 ] ; Scanner input = new Scanner ( System . in ) ; int r = 1 ; for ( String k : input . nextLine ( ) . split ( " ▁ " ) ) { L [ r ] += Integer . parseInt ( k ) ; r ++ ; } input . nextLine ( ) ; for ( String j : input . nextLine ( ) . split ( " ▁ " ) ) { System . out . println ( L [ Integer . parseInt ( j ) - 1 ] ) ; } return L ; }
n , m ) public static int [ ] sumL ( int n , int [ ] input ) { int [ ] sumL = new int [ n + 2 ] ; int L ; sumL [ n ] = 1 ; sumL [ n - 2 ] = 1 ; for ( int i = n - 1 ; i > 0 ; i -- ) { L = sumL [ i + 1 ] ; int j = 2 ; while ( i * j <= n ) { L += ( sumL [ i * j ] - sumL [ Math . min ( n , ( i + 1 ) * j - 1 ) + 1 ] ) ; L %= m ; j ++ ; } L %= m ; sumL [ i ] = ( sumL [ i + 1 ] + L ) ; sumL [ i ] %= m ; } System . out . println ( L ) ; return sumL ; }
public static final void printMax ( int [ ] arr , int n , int k ) { Deque < Integer > Qi = new ArrayDeque < Integer > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { while ( Qi . size ( ) > 0 && arr [ i ] >= arr [ Qi . size ( ) - 1 ] ) Qi . pop ( ) ; Qi . push ( i ) ; ; } for ( int i = k ; i < n ; i ++ ) { System . out . print ( Integer . toString ( arr [ Qi . pop ( ) ] ) + " ▁ " ) ; while ( Qi . size ( ) > 0 && Qi . peek ( ) <= i - k ) Qi . pop ( ) ; while ( Qi . size ( ) > 0 && arr [ i ] >= arr [ Qi . size ( ) - 1 ] ) Qi . pop ( ) ; Qi . push ( i ) ; } System . out . print ( Integer . toString ( arr [ Qi . pop ( ) ] ) ) ; }
public static int russianPeasant ( int a , int b ) { int res = 0 ; while ( ( b > 0 ) && ( b < 1 ) ) { if ( ( b & 1 ) != 0 ) res = res + a ; a = a << 1 ; b = b > > 1 ; } return res ; }
public static boolean isValid ( String string , int length ) { for ( int i = 1 ; i < length ; i ++ ) { if ( string . charAt ( i ) == string . charAt ( i - 1 ) ) { return false ; } } return true ; }
static final int lehmann ( int n , int t ) { int a = random . nextInt ( 2 ) ; int e = ( n - 1 ) / 2 ; while ( ( t > 0 ) && ( a % e ) == 1 ) { int result = ( ( int ) ( a * e ) ) % n ; if ( ( ( result % n ) == 1 || ( result % n ) == ( n - 1 ) ) && ( ( result % n ) == ( n - 1 ) ) ) { a = random . nextInt ( 2 ) ; t -- ; } else { return - 1 ; } } return 1 ; }
public static int main ( String [ ] args ) { for ( ; ; ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) , Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ b ▁ number ▁ to ▁ test " ) ) ; int b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) ; int i = 0 ; while ( true ) { if ( a <= 0 || b <= 0 ) break ; if ( a > b ) { i += a / b ; a -= a / b * b ; } else { i += b / a ; b -= b / a * a ; } } System . out . println ( i ) ; } }
s ; int k = Integer . parseInt ( input ) ; System . out . println ( " impossible " if k > s . length ( ) else Math . max ( 0 , k - s . length ( ) ) ) ; }
public static int MaxTraceSub ( int [ ] [ ] mat ) { int maxTrace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i ; int s = j ; int trace = 0 ; while ( ( r < N && s < N ) || ( r > N && s > N ) ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; maxTrace = Math . max ( trace , maxTrace ) ; } } } return maxTrace ; }
public static void main ( String [ ] args ) { while ( true ) { try { double xa1 = Double . parseDouble ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ x ▁ coordinate ▁ of ▁ the ▁ input ▁ point " ) ) ; double ya1 = Double . parseDouble ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ y ▁ coordinate ▁ of ▁ the ▁ input ▁ point " ) ) ; double xa2 = Double . parseDouble ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ x ▁ coordinate ▁ of ▁ the ▁ input ▁ point " ) ) ; double ya2 = Double . parseDouble ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ y ▁ coordinate ▁ of ▁ the ▁ input ▁ point " ) ) ; double xb1 = Double . parseDouble ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ x ▁ coordinate ▁ of ▁ the ▁ input ▁ point " ) ) ; double yb1 = Double . parseDouble ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ y ▁ coordinate ▁ of ▁ the ▁ input ▁ point " ) ) ; double xb2 = Double . parseDouble ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ x ▁ coordinate ▁ of ▁ the ▁ input ▁ point " ) ) ; double yb2 = Double . parseDouble ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ y ▁ coordinate ▁ of ▁ the ▁ input ▁ point " ) ) ; if ( xb2 < xa1 || xb1 > xa2 || yb2 < ya1 || yb1 > ya2 ) { System . out . println ( " NO " ) ; } else {
public static int [ ] convertToBinary ( int n ) { int [ ] listy = new int [ 31 ] ; while ( n > 0 ) { listy [ n % 2 ] = 0 ; n /= 2 ; } for ( int i = 0 ; i < 31 - listy . length ; i ++ ) { listy [ i ] = 0 ; } return listy ; } public static void main ( String [ ] args ) { int [ ] testCases = new int [ Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ test ▁ cases " ) ) ] ; for ( int testCase = 0 ; testCase < testCases . length ; testCase ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ test ▁ cases " ) ) ; int [ ] a = new int [ Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ test ▁ cases " ) ) ] ; for ( int i = 0 ; i < 31 ; i ++ ) { int [ ] x = convertToBinary ( i ) ; for ( int j = 0 ; j < x . length ; j ++ ) { x [ j ] += x [ j ] ; } } int [ ] collector = new int [ n + 1 ] ; for ( int i = 0 ; i < collector . length ; i ++ ) { if ( collector [ i ] > 0 ) { collector [ i ] ++ ; } } int [ ] realCollector = new int [ collector . length ] ; for ( int i = 0 ; i < collector . length ; i ++ ) { if ( collector [ i ] > 0 ) { realCollector [ i ] = i ; } } int [ ] finalAnswer = new int [ 1 ] ; if ( Arrays . equals ( realCollector , collector ) ) { System . out . println ( " ▁ " + Arrays . toString ( collector ) ) ; } else { int minCollector = Math . min ( realCollector , collector ) ; realCollector = realCounter ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i > minCollector ) { break ; } else { boolean isGood = true ; for ( int j : realCollector ) { if ( j % i != 0 ) { isGood = false ; break ; } } if ( isGood ) { finalAnswer [ i ] = i ; } } } System . out . println (
public static int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; i ++ ) { int divCount = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { if ( ( i % j == 0 ) && ( j % i == 0 ) ) { divCount ++ ; } } if ( ( divCount % 2 ) != 0 ) { res ++ ; } } return res ; }
public static int max ( int n , int m ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] arr = Arrays . copyOf ( input . nextLine ( ) . split ( " ▁ " ) , n ) ; int [ ] li = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) li [ i ] = Math . ceil ( arr [ i ] / m ) ; int maxi = Math . max ( li ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( maxi == li [ i ] ) { System . out . println ( i + " ▁ " ) ; break ; } } return maxi ; }
public static void printArray ( int N , int [ ] arr ) { for ( int i = 0 ; i <= N ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; }
public static void printArray ( int N , int [ ] arr ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . print ( " \n " + " " ) ; } public static void replacedArray ( int N , int [ ] arr ) { for ( int i = 0 ; i < N ; i ++ ) { int posSum = 0 ; int negSum = 0 ; for ( int j = i + 1 ; j < N ; j += 1 ) { if ( ( arr [ j ] > 0 ) && ( arr [ j ] > 1 ) ) { posSum += arr [ j ] ; } else { negSum += arr [ j ] ; } } int diff = Math . abs ( posSum ) - Math . abs ( negSum ) ; arr [ i ] = Math . abs ( diff ) ; } } public static void main ( String [ ] args ) { if ( args . length == 0 ) { System . out . println ( " Usage : ▁ replacedArray " ) ; System . out . println ( " ▁ ▁ replacedArray ▁ N ▁ arr " ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁
public static int countDivisbleby4 ( String s ) { int n = s . length ( ) ; int count = 0 ; ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( s . charAt ( i ) == '4' || s . charAt ( i ) == '8' || s . charAt ( i ) == '0' ) && ( s . charAt ( i ) == '1' || s . charAt ( i ) == '2' || s . charAt ( i ) == '3' ) ) { count ++ ; } } for ( int i = 0 ; i < n - 1 ; i += 1 ) { int h = ( Character . digit ( s . charAt ( i ) , 16 ) - '0' ) * 10 + ( Character . digit ( s . charAt ( i + 1 ) , 16 ) - '0' ) ; if ( ( h % 4 == 0 ) && ( h % 2 == 0 ) ) { count = count + i + 1 ; } } return count ; }
public static String toString ( int t ) { for ( ; t > 0 ; t -- ) { String [ ] s = new String [ t ] ; for ( int i = 0 ; i < s . length ; i ++ ) { s [ i ] = Integer . toString ( i ) ; } String res = " YES " . equals ( max ( s , 0 , 2 ) ) + max ( s , 2 , s . length ) == Arrays . asList ( Collections . singletonList ( s ) ) . stream ( ) . collect ( Collectors . joining ( " , " ) ) ; System . out . println ( res ) ; } return " YES " ; }
public static void main ( String [ ] args ) { List < Integer > l = new ArrayList < Integer > ( ) ; int limit = 10000000000 ; final int number = 0 ; if ( ( number > limit ) && ( four == seven ) ) { l . add ( number ) ; } gen ( number * 10 + 4 , four + 1 , seven ) ; gen ( number * 10 + 7 , four , seven + 1 ) ; }
public static void main ( String [ ] args ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ solve " ) ) ; for ( ; ; ) { int n = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ solve " ) ; int k = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ solve " ) ; int [ ] a = Arrays . copyOf ( JOptionPane . getRootFrame ( ) . getContentPane ( ) . getFrames ( ) , n ) ; boolean has = false ; boolean prop = n == 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == k ) { has = true ; } if ( a [ i ] >= k && i > 0 ) { if ( a [ i - 1 ] >= k ) { prop = true ; } if ( i > 1 && a [ i - 2 ] >= k ) { prop = true ; } } } System . out . println ( has ? " yes " : " no " ) ; } }
public static int T ( Scanner scanner ) { int C = Integer . parseInt ( scanner . nextLine ( ) ) ; for ( int C = 1 ; C <= T ; C ++ ) { int D = scanner . nextInt ( ) ; int I = scanner . nextInt ( ) ; int M = scanner . nextInt ( ) ; int N = scanner . nextInt ( ) ; int x [ ] = scanner . nextLine ( ) . split ( " ▁ " ) ; int r [ ] = new int [ 256 ] ; for ( int q = 0 ; q < x . length ; q ++ ) { int nr [ ] = Arrays . stream ( x ) . mapToInt ( i -> i + D ) . toArray ( ) ; q = Integer . parseInt ( scanner . nextLine ( ) ) ; if ( M == 0 ) { for ( int i = 0 ; i < 256 ; i ++ ) { nr [ i ] = Math . min ( nr [ i ] , r [ i ] + Math . abs ( q - i ) ) ; } } else { for ( int i = 0 ; i < 256 ; i ++ ) { for ( int j = 0 ; j < 256 ; j ++ ) { nr [ j ] = Math . min ( nr [ j ] , r [ i ] + Math . abs ( q - j ) + ( Math . max ( 0 , Math . abs ( i - j ) - 1 ) / M ) * I ) ; } } } r = nr ; } System . out . println ( " Case ▁ # " + C + " : ▁ " + Math . min ( r . length , 256 ) ) ; } return C ; }
public static void countIsland ( int [ ] [ ] ban ) { final int x = 0 ; final int y = 0 ; if ( 0 <= y && y < 12 && 0 <= x && ban [ y ] [ x ] == 1 ) { ban [ y ] [ x ] = 0 ; for ( int dx = - 1 , dy = 1 ; dx <= 1 ; dx ++ , dy ++ ) { remove ( x + dx , y + dy ) ; } } int count = 0 ; for ( int y = 0 ; y < 12 ; y ++ ) { for ( int x = 0 ; x < 12 ; x ++ ) { if ( ban [ y ] [ x ] == 1 ) { count ++ ; remove ( x , y ) ; } } } System . out . println ( count ) ; }
public static boolean arraySortedOrNot ( int [ ] arr , int n ) { if ( ( n == 0 || n == 1 ) && ( arr [ 0 ] > arr [ 1 ] ) ) return true ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] > arr [ i ] ) && ( arr [ i - 1 ] > arr [ 0 ] ) ) return false ; } return true ; int [ ] arr = { 20 , 23 , 23 , 45 , 78 , 88 } ; n = arr . length ; if ( ( arraySortedOrNot ( arr , n ) ) && ( arr [ 0 ] > arr [ 1 ] ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
public static int main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ searched " ) ) ; int [ ] arr = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ string ▁ to ▁ be ▁ searched " ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int k = Math . min ( arr . length , n ) ; if ( n == 1 ) { System . out . println ( 0 ) ; } else { int res = 0 ; for ( int i : arr ) { res += ( i - k ) ; } System . out . println ( res ) ; } } }
public static int printKDistinct ( int arr [ ] , int size , int KthIndex ) { HashMap < Integer , Integer > dict = new HashMap < Integer , Integer > ( ) ; ArrayList < Integer > vect = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] < dict . size ( ) ) ) dict . put ( arr [ i ] , dict . get ( arr [ i ] ) + 1 ) ; else dict . put ( arr [ i ] , 1 ) ; } for ( int i = 0 ; i < size ; i ++ ) { if ( ( dict . get ( arr [ i ] ) > 1 ) ) continue ; else KthIndex = KthIndex - 1 ; if ( ( KthIndex == 0 ) && ( arr [ i ] < dict . size ( ) ) ) return arr [ i ] ; } return - 1 ; }
static int [ ] fib ( int [ ] f , int n ) { f [ 0 ] = 0 ; ; f [ 1 ] = 1 ; ; for ( int i = 2 ; i <= n ; i ++ ) f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 ; ; return f ; }
public static int [ ] ABC ( ) { int [ ] ABC = Arrays . stream ( input ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; if ( ABC . length == 5 ) { System . out . println ( " YES " . equals ( Arrays . toString ( ABC ) ) ) ; } else { System . out . println ( " NO " ) ; } return ABC ; }
static int N = Integer . parseInt ( input . nextLine ( ) ) ; int Z = Integer . parseInt ( input . nextLine ( ) ) ; int W = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] X = new int [ N + 1 ] ; int [ ] Y = new int [ 1e9 ] ; for ( int i = N ; i > 0 ; i -- ) { X [ i ] = Math . max ( Math . abs ( A [ i - 1 ] - A [ N ] ) , Y [ j ] ) ; Y [ i ] = Math . min ( Math . abs ( A [ i - 1 ] - A [ N ] ) , X [ j ] ) ; } System . out . println ( X [ 1 ] ) ; return X [ 1 ] ; }
public static void countEleLessThanOrEqual ( int [ ] arr1 , int [ ] arr2 , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr2 [ j ] <= arr1 [ i ] ) ) { count ++ ; } } System . out . print ( count + " ▁ " ) ; } arr1 = new int [ ] { 1 , 2 , 3 , 4 , 7 , 9 } ; arr2 = new int [ ] { 0 , 1 , 2 , 1 , 1 , 4 } ; m = arr1 . length ; n = arr2 . length ; countEleLessThanOrEqual ( arr1 , arr2 , m , n ) ; }
_ , k = 1 ) STRNEWLINE ▁ * ▁ @ return ▁ the ▁ minimum ▁ of ▁ the ▁ given ▁ numbers STRNEWLINE ▁ */ public static int min ( int [ ] arr , int k ) { int [ ] arr = Arrays . copyOf ( arr , arr . length ) ; if ( k == 1 ) { System . out . println ( Math . min ( arr , arr [ 0 ] ) ) ; } else if ( k == 2 ) { System . out . println ( Math . max ( arr [ 0 ] , arr [ arr . length - 1 ] ) ) ; } else { System . out . println ( Math . max ( arr , arr [ 0 ] ) ) ; } return arr [ 0 ] ; }
public static void main ( String [ ] args ) { String A = JOptionPane . showInputDialog ( " Enter ▁ the ▁ string ▁ A " ) ; System . out . println ( A ) ; int S = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ S " ) ) ; for ( ; ; ) { String B = JOptionPane . showInputDialog ( " Enter ▁ the ▁ string ▁ B " ) ; String C = JOptionPane . showInputDialog ( " Enter ▁ the ▁ string ▁ C " ) ; A . put ( A . indexOf ( B ) , C ) ; System . out . println ( A ) ; } }
static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; final int n = sc . nextInt ( ) ; System . out . println ( Arrays . toString ( sc . nextLine ( ) . split ( " ▁ " ) ) ) ; }
public static int main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int k = sc . nextInt ( ) ; int p = sc . nextInt ( ) ; int ans = 0 ; int ans2 = 0 ; int i = 1 ; while ( ans2 < k ) { String s = Integer . toString ( i ) ; ans += Integer . parseInt ( s + s . substring ( 0 , s . length ( ) - 1 ) ) ; ans2 ++ ; i ++ ; } System . out . println ( ans % p ) ; }
public static int N ( ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] A = Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] aToI = new int [ A . length + 2 ] ; for ( int i = 0 , a = A . length ; i < a ; i ++ ) { aToI [ a ] = i ; } int [ ] L = new int [ N + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { L [ i ] = i - 1 ; } int [ ] R = new int [ N + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { R [ i ] = i + 1 ; } int ans = 0 ; for ( int a = N ; a > 0 ; a -- ) { int i = aToI [ a ] ; ans += a * ( R [ i ] - i ) * ( i - L [ i ] ) ; L [ R [ i ] ] = L [ i ] ; R [ L [ i ] ] = R [ i ] ; } System . out . println ( ans ) ; return ans ; }
public static int lps ( String str ) { int n = str . length ( ) ; int [ ] [ ] L = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 0 ; for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; ; } } return L [ 0 ] [ n - 1 ] ; }
public static void printConsecutive ( int last , int first ) { System . out . print ( first + " ▁ " ) ; first ++ ; for ( int x = first ; x <= last ; x ++ ) { System . out . print ( " ▁ + " + x + " ▁ " ) ; } final int N = 12 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= last ; j ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { System . out . print ( N + " = ▁ " ) ; printConsecutive ( last , first + 1 ) ; return ; } } } System . out . println ( " - 1" ) ; int n = 12 ; findConsecutive ( n ) ; }
public static String toString ( int a , int b ) { String ans = " YES " ; if ( Math . abs ( a - b ) > 1 || a + b == 0 ) ans = " NO " ; System . out . println ( ans ) ; }
protected static int gcd ( int a , int b ) { if ( ( a == 0 || b == 0 ) && ( a == b ) ) return 0 ; ; if ( ( a == b ) ) return a ; ; if ( ( a > b ) ) return gcd ( a - b , b ) ; ; return gcd ( a , b - a ) ; }
public static boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; char [ ] c = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) c [ i ] = s . charAt ( i ) ; Arrays . sort ( c , 0 , n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( c [ i ] != s . charAt ( i ) ) && ( c [ i ] != ' ▁ ' ) ) return false ; return true ; }
public static void printMax ( int [ ] arr , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { max = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] > max ) { max = arr [ i + j ] ; } } System . out . print ( String . valueOf ( max ) + " ▁ " ) ; } if ( System . getSecurityManager ( ) == null ) { arr = new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; n = arr . length ; k = 3 ; printMax ( arr , n , k ) ; } }
mod = 1000000007 ; eps = 10 * - 9 ; public static void main ( String [ ] args ) { final Scanner sc = new Scanner ( System . in ) ; final int N = sc . nextInt ( ) ; final int M = sc . nextInt ( ) ; final int [ ] [ ] adj = new int [ N + 1 ] [ M ] ; for ( ; N <= M ; N ++ ) { int a = sc . nextInt ( ) , b = sc . nextInt ( ) ; adj [ a ] [ b ] = sc . nextInt ( ) ; adj [ b ] [ a ] = sc . nextInt ( ) ; } final int [ ] seen = new int [ N + 1 ] ; int single = 0 ; int bipartite = 0 ; int notBipartite = 0 ; for ( int v0 = 1 ; v0 <= N ; v0 ++ ) { if ( seen [ v0 ] != 0 ) continue ; boolean flg = 1 ; final LinkedList < Integer > que = new LinkedList < Integer > ( ) ; que . add ( v0 ) ; seen [ v0 ] = 1 ; int cnt = 0 ; while ( que . size ( ) > 0 ) { int v = que . removeFirst ( ) ; cnt ++ ; for ( int u : adj [ v ] ) { if ( seen [ u ] == 0 ) { seen [ u ] = - seen [ v ] ; que . add ( u ) ; } else { if ( seen [ u ] == seen [ v ] ) flg = 0 ; } } } if ( cnt == 1 ) single ++ ; else { if ( flg ) bipartite ++ ; else notBipartite ++ ; } } int ans = N * N - ( N - single ) * N ; ans += ( bipartite + notBipartite ) * N ; ans += bipartite * N ; System . out . println ( ans ) ; }
public static int ss ( int a , int b ) { a = Math . min ( a , b ) ; return a * ( a + 1 ) / 2 + ( b - a ) * a ; }
from ▁ itertools ▁ combinations ▁ of ▁ the ▁ given ▁ input ▁ sequence . STRNEWLINE ▁ */ public static int [ ] [ ] getPair ( int N , int K ) { int [ ] [ ] P = new int [ N ] [ K ] ; for ( int i = 0 ; i < N ; i ++ ) P [ i ] = Arrays . copyOf ( input , N ) ; int ans = 10 * 18 * 5 ; for ( int x = 0 ; x < N ; x ++ ) { int u = Math . max ( P [ x ] [ 0 ] , P [ x ] [ 1 ] ) ; int d = Math . min ( P [ x ] [ 0 ] , P [ x ] [ 1 ] ) ; for ( int y = 0 ; y < N ; y ++ ) { int r = Math . max ( P [ y ] [ 0 ] , P [ y ] [ 1 ] ) ; int l = Math . min ( P [ y ] [ 0 ] , P [ y ] [ 1 ] ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( d <= P [ i ] [ 0 ] && l <= P [ i ] [ 1 ] && r <= P [ i ] [ 0 ] && r <= P [ i ] [ 1 ] ) count ++ ; } if ( count >= K ) ans = Math . min ( ans , ( u - d ) * ( r - l ) ) ; } } System . out . println ( ans ) ; return P ; }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] l = new int [ n ] ; Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { l += new int [ m ] ; map . put ( l [ i ] , i ) ; } List < Integer > z = Arrays . asList ( l ) ; for ( int i = m - 1 ; i >= 0 ; i -- ) { if ( i % 2 == 0 ) { Collections . sort ( z , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return o1 . compareTo ( o2 ) ; } } ) ; } else { Collections . sort ( z , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return o1 . compareTo ( o2 ) ; } } ) ; } } for ( int i : z ) { System . out . print ( map . get ( i ) + " ▁ " ) ; } return map . get ( n ) ; }
public static String [ ] preProcess ( String [ ] substrings , String s ) { int n = s . length ( ) ; ; for ( int i = 0 ; i < n ; i ++ ) { String dup = " " ; ; for ( int j = i ; j < n ; j ++ ) { dup += s . charAt ( j ) ; substrings [ j ] = dup ; } ; } Arrays . sort ( substrings ) ; ; return substrings ; }
static int [ ] [ ] test ( ) { int [ ] [ ] f = { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; int [ ] [ ] b = { { 0 , - 1 } , { - 1 , 0 } , { 0 , 1 } , { 1 , 0 } } ; while ( true ) { int w = map . nextInt ( ) ; int h = map . nextInt ( ) ; if ( w == 0 ) break ; int r = 1 , c = 1 , d = 0 ; while ( true ) { String buf = map . next ( ) ; if ( buf . equals ( " STOP " ) ) break ; else if ( buf . equals ( " RIGHT " ) ) d = ( d + 1 ) % 4 ; else if ( buf . equals ( " LEFT " ) ) d = ( d + 3 ) % 4 ; else { if ( buf . equals ( " FORWARD " ) ) { int r2 = r + Integer . parseInt ( buf ) * f [ d ] [ 1 ] ; int c2 = c + Integer . parseInt ( buf ) * f [ d ] [ 0 ] ; if ( r2 < 1 ) r2 = 1 ; if ( r2 > h ) r2 = h ; if ( c2 < 1 ) c2 = 1 ; if ( c2 > w ) c2 = w ; r = r2 ; c = c2 ; } } System . out . println ( c + " ▁ " + r ) ; } } return f ; }
public static int n ( ) { int n = Integer . parseInt ( input ) ; String s = input . nextLine ( ) ; int i = 0 ; int x = 0 ; int ans = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( s . charAt ( j ) == s . charAt ( i ) == ' x ' ) x ++ ; else { if ( x > 1 ) ans += x - 1 ; x = 0 ; } i = j ; } if ( x > 1 ) ans += x - 1 ; System . out . println ( ans ) ; }
public static void main ( String [ ] args ) { while ( 1 ) { String x = JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ; if ( x . equals ( "0" ) ) break ; int a = 0 ; int b = 0 ; for ( int i = 1 ; i < x . length ( ) ; i ++ ) { if ( x . charAt ( i ) == ' A ' ) a ++ ; else b ++ ; } if ( a > b ) a ++ ; else b ++ ; System . out . println ( a + " ▁ " + b ) ; } }
public static long fact ( int N ) { long product = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = product * i ; } return product ; }
public static int longestSubArray ( int arr [ ] , int n ) { boolean isZeroPresent = false ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] == 0 ) && ( arr [ i + 1 ] == 0 ) ) { isZeroPresent = true ; break ; } } if ( ( isZeroPresent ) && ( n > 0 ) ) return n ; return 0 ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ used " ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ used " ) ) ; int x = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ used " ) ; System . out . println ( ( k - 1 ) * 9 + x ) ; } return n ; }
public static void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; System . out . println ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; }
public static final int NO_OF_CHARS = 256 ; public static int maxDistinctChar ( String str , int n ) { int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) count [ ( char ) str . charAt ( i ) ] ++ ; int maxDistinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( ( count [ i ] != 0 ) && ( count [ i ] != 1 ) ) maxDistinct ++ ; return maxDistinct ; } public static int smallesteSubstr_maxDistictChar ( String str ) { int n = str . length ( ) ; int maxDistinct = maxDistinctChar ( str , n ) ; int minl = n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { String subs = str . substring ( i , j ) ; int subsLenght = subs . length ( ) ; int subDistinctChar = maxDistinctChar ( subs , subsLenght ) ; if ( ( subsLenght < minl ) && ( maxDistinct == subDistinctChar ) ) minl = subsLenght ; } } return minl ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { String str = " AABBBCBB " ; int l = smallesteSubstr_maxDistictChar ( str ) ; ; System . out . println ( " The ▁ length ▁ of ▁ the ▁ smallest ▁ substring ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ characters ▁ : " + l ) ; } } }
public static String f ( int n , String s1 , String s2 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 . charAt ( i ) != s2 . charAt ( i ) ) && ( s1 . charAt ( i ) == ' R ' || s2 . charAt ( i ) == ' R ' ) ) { if ( ( s1 . charAt ( i ) == ' R ' || s2 . charAt ( i ) == ' R ' ) && ( s1 . charAt ( i ) == ' R ' || s2 . charAt ( i ) == ' R ' ) ) { return " NO " ; } } } return " YES " ; }
public static int findNumberOfEvenCells ( int n , int [ ] [ ] q , int size ) { int [ ] row = new int [ n ] ; ; int [ ] col = new int [ n ] ; for ( int i = 0 ; i < size ; i ++ ) { int x = q [ i ] [ 0 ] ; ; int y = q [ i ] [ 1 ] ; ; row [ x - 1 ] ++ ; ; col [ y - 1 ] ++ ; ; } int r1 = 0 ; ; int r2 = 0 ; ; int c1 = 0 ; int c2 = 0 ; ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( row [ i ] % 2 == 0 ) && ( row [ i ] % 2 == 1 ) ) r1 ++ ; ; if ( ( row [ i ] % 2 == 1 ) && ( row [ i ] % 2 == 2 ) ) r2 ++ ; ; if ( ( col [ i ] % 2 == 0 ) && ( col [ i ] % 2 == 1 ) ) c1 ++ ; ; if ( ( col [ i ] % 2 == 1 ) && ( col [ i ] % 2 == 2 ) ) c2 ++ ; } int count = r1 * c1 + r2 * c2 ; ; return count ; }
public static void checkType ( int [ ] arr , int n ) { if ( ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) || ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) ) { System . out . println ( " Increasing " ) ; ; } else if ( ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) || ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) ) { System . out . println ( " Decreasing " ) ; ; } else if ( ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) || ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) ) { System . out . println ( " Increasing ▁ then ▁ decreasing " ) ; ; } else { System . out . println ( " Decreasing ▁ then ▁ increasing " ) ; ; } }
public static void main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( System . in . readLine ( ) ) ; String s = System . in . readLine ( ) ; System . out . println ( n / 2 - Math . max ( s . contains ( "10" ) , s . contains ( "01" ) ) ) ; } }
public static final int getDivisionByFraction ( int a , int b , int c , int d ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; int c = Integer . parseInt ( input . nextLine ( ) ) ; int d = Integer . parseInt ( input . nextLine ( ) ) ; if ( c > a || d > b ) { if ( c > a && d > b ) { int p = Math . min ( new BigDecimal ( b / d ) . divide ( new BigDecimal ( a / c ) , 2 , BigDecimal . ROUND_FLOOR ) . intValue ( ) , new BigDecimal ( a / c ) . divide ( new BigDecimal ( b / d ) , 2 , BigDecimal . ROUND_FLOOR ) . intValue ( ) ) ; } else if ( c > a ) { int p = Math . min ( new BigDecimal ( a / c ) . divide ( new BigDecimal ( b / d ) , 2 , BigDecimal . ROUND_FLOOR ) . intValue ( ) , new BigDecimal ( b / d ) . divide ( new BigDecimal ( a / c ) , 2 , BigDecimal . ROUND_FLOOR ) . intValue ( ) ) ; } else { int p = Math . min ( new BigDecimal ( b / d ) . divide ( new BigDecimal ( a / c ) , 2 , BigDecimal . ROUND_FLOOR ) . intValue ( ) , new BigDecimal ( a / c ) . divide ( new BigDecimal ( b / d ) , 2 , BigDecimal . ROUND_FLOOR ) . intValue ( ) ) ; } } else { int p = Math . min ( new BigDecimal ( b / d ) . divide ( new BigDecimal ( a / c ) , 2 , BigDecimal . ROUND_FLOOR ) . intValue ( ) , new BigDecimal ( a / c ) . divide ( new BigDecimal ( b / d ) , 2 , BigDecimal . ROUND_FLOOR ) . intValue ( ) ) ; } c *= p ; d *= p ; int up = ( a * b - c * d ) , down = a * b ; String ans = String . valueOf ( new BigDecimal ( up / down ) . divide ( new BigDecimal ( c / d ) , 2 , BigDecimal . ROUND_FLOOR ) . intValue ( ) ) ; System . out . println ( "0/1" . equals ( ans ) ? "0" : ans ) ; return a / b ; }
public static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) { return 1 ; } else { return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) ; } }
public static void rearrange ( int arr [ ] , int n ) { int j = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] < 0 ) && ( arr [ j ] > 0 ) ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; j = j + 1 ; } } System . out . println ( arr ) ; }
public static int centeredSquareNum ( int n ) { return n * n + ( ( n - 1 ) * ( n - 1 ) ) ; }
t ; for ( int test = 0 ; test < t ; test ++ ) { int n = map . get ( input . nextLine ( ) ) ; int k = map . get ( input . nextLine ( ) ) ; if ( k == 1 ) { if ( n % 2 == 1 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { if ( n <= k ) { System . out . println ( " NO " ) ; } else { if ( n % 2 == 0 && k % 2 == 1 ) { System . out . println ( " NO " ) ; } else if ( n % 2 == 1 && k % 2 == 0 ) { System . out . println ( " NO " ) ; } else { int x = 2 * k - 1 ; int minSum = ( ( 1 + x ) * x ) / 4 ; if ( minSum > n ) { System . out . println ( " NO " ) ; } else if ( minSum == n ) { System . out . println ( " YES " ) ; } else { if ( ( n - minSum ) % 2 == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } } } } } }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) / 2 ; List < Integer > s = Collections . list ( ) ; return sum ( s . subList ( 0 , n ) ) * n + sum ( s . subList ( n , n ) ) ; }
public static int maxSubArraySum ( int [ ] arr , int size ) { int maxSoFar = arr [ 0 ] ; int currMax = arr [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { currMax = Math . max ( arr [ i ] , currMax + arr [ i ] ) ; maxSoFar = Math . max ( maxSoFar , currMax ) ; } return maxSoFar ; } public static final int lenOfLongSubarrWithGivenSum ( int [ ] arr , int n , int k ) { Map < Integer , Integer > um = Maps . newHashMap ( ) ; int Sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum += arr [ i ] ; if ( ( Sum == k ) && ( Sum != k ) ) maxLen = i + 1 ; if ( ( Sum != 0 ) && ( Sum < um . size ( ) ) ) um . put ( Sum , i ) ; if ( ( Sum < 0 ) && ( ( Sum - k ) < um . size ( ) ) ) maxLen = i - um . get ( Sum - k ) ; } return maxLen ; } public static int lenLongSubarrWithMaxSum ( int [ ] arr , int n ) { int maxSum = maxSubArraySum ( arr , n ) ; return lenOfLongSubarrWithGivenSum ( arr , n , maxSum ) ; } public static int [ ] getNegativeArray ( int [ ] array ) { return new int [ ] { 5 , - 2 , - 1 , 3 , - 4 } ; } }
static final public void main ( String [ ] args ) throws Exception { String s = String . valueOf ( args [ 0 ] ) ; char prev = ( char ) s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( ( char ) s . charAt ( i ) != prev + 1 ) { return ; } prev = ( char ) s . charAt ( i ) ; } System . out . println ( " " + s ) ; }
public static int find ( int dividend , int divisor , int start , int end ) { if ( ( start > end ) && ( start < end ) ) return ( 0 ) ; int mid = start + ( end - start ) / 2 ; int n = dividend - divisor * mid ; if ( ( n > divisor ) && ( n < 0 ) ) start = mid + 1 ; else if ( ( n < 0 ) && ( n > divisor ) ) end = mid - 1 ; else { if ( ( n == divisor ) || ( n == 0 ) ) { mid ++ ; n = 0 ; } return ( mid ) ; } return find ( dividend , divisor , start , end ) ; } public static int divide ( int dividend , int divisor ) { return find ( dividend , divisor , 1 , dividend ) ; } public static int [ ] divide ( int dividend , int divisor ) { if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { dividend = 10 ; divisor = 3 ; int [ ] ans = divide ( dividend , divisor ) ; System . out . print ( Integer . toString ( ans [ 0 ] ) + " , ▁ " ) ; System . out . print ( Integer . toString ( ans [ 1 ] ) ) ; return ans ; } return new int [ ] { 0 } ; }
n ; int cities = Integer . parseInt ( input . nextLine ( ) ) ; for ( int i = 0 ; i < cities ; i ++ ) { if ( i == 0 ) { System . out . println ( Math . abs ( cities [ 0 ] - cities [ 1 ] ) + " ▁ " + Math . abs ( cities [ 0 ] - cities [ - 1 ] ) ) ; } else if ( i == cities . length - 1 ) { System . out . println ( Math . abs ( cities [ cities . length - 1 ] - cities [ i - 1 ] ) + " ▁ " + Math . abs ( cities [ 0 ] - cities [ - 1 ] ) ) ; } else { int mn = Math . min ( Math . abs ( cities [ i ] - cities [ i - 1 ] ) , Math . abs ( cities [ i ] - cities [ i + 1 ] ) ) ; int mx = Math . max ( Math . abs ( cities [ i ] - cities [ 0 ] ) , Math . abs ( cities [ i ] - cities [ - 1 ] ) ) ; System . out . println ( mn + " ▁ " + mx ) ; } }
public static void solve ( ) { int n = map . get ( input ) ; int i = map . get ( n ) ; int [ ] ns = new int [ n ] ; Arrays . fill ( ns , ( int ) input . charAt ( i ) ) ; int k = 1 << ( i * 8 / n ) ; lis = new int [ n - 1 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( ns [ i ] != ns [ i + 1 ] ) { lis [ i + 1 ] = i + 1 ; } } lis [ n ] = n ; System . out . println ( 0 < lis . length && n - Math . max ( lis [ i + k ] - lis [ i ] , 0 ) ) ; }
public static void towerOfHanoi ( int n , int fromRod , int toRod , int auxRod1 , int auxRod2 ) { if ( ( n == 0 ) || ( n == 1 ) ) return ; if ( ( n == 2 ) || ( n == 3 ) ) { System . out . println ( " Move ▁ disk " + n + " ▁ from ▁ rod " + fromRod + " ▁ to ▁ rod " + toRod ) ; return ; } towerOfHanoi ( n - 2 , fromRod , auxRod1 , auxRod2 , toRod ) ; System . out . println ( " Move ▁ disk " + n - 1 ) ; }
public static void main ( String [ ] args ) { System . out . println ( " Testing ▁ the ▁ " + tokenize ( " ▁ " ) + " ▁ operator " ) ; final StringTokenizer st = new StringTokenizer ( " ▁ " ) ; final BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; final String IS = new String ( ) ; final String IN = new String ( ) ; final String IF = new String ( ) ; final String a = "1000" ; final String b = "1001" ; final String c = "1010" ; final String d = "1011" ; final String e = "1100" ; final String f = "1101" ; final String g = "1110" ; final String h = "1111" ; final String s = IS . nextToken ( ) ; String res = " " ; while ( s . hasMoreTokens ( ) ) { if ( s . hasMoreTokens ( ) ) { res += a ; } else if ( s . hasMoreTokens ( ) ) { res += b ; } else if ( s . hasMoreTokens ( ) ) { res += c ; } else if ( s . hasMoreTokens ( ) ) { res += d ; } else if ( s . hasMoreTokens ( ) ) { res += e ; } else if ( s . hasMoreTokens ( ) ) { res += f ; } else if ( s . hasMoreTokens ( ) ) { res += g ; } else { res += h ; } } System . out . println ( ( Integer . parseInt ( res , 2 ) ) % ( 10 * 6 + 3 ) ) ; }
public static Map < Integer , Integer > M = new HashMap < Integer , Integer > ( ) { { for ( int i = 0 ; i < Integer . parseInt ( input . nextLine ( ) ) ; i ++ ) { String [ ] query = input . nextLine ( ) . split ( " ▁ " ) ; if ( query [ 0 ] . equals ( "0" ) ) { M . put ( query [ 1 ] , query [ 2 ] ) ; } else if ( query [ 0 ] . equals ( "1" ) ) { if ( query [ 1 ] . contains ( " ▁ " ) ) { System . out . println ( M . get ( query [ 1 ] ) ) ; } else { System . out . println ( 0 ) ; } } else { M . put ( query [ 1 ] , 0 ) ; } } } }
public static int minSum ( int [ ] arr , int n ) { int sum = arr [ 0 ] ; ; int prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
public static int findN ( int k ) { if ( ( k == 0 ) || ( k == 1 ) ) ans = 3 ; if ( ( k == 1 ) || ( k == 2 ) ) ans = 1 ; else if ( ( k % 4 == 0 ) || ( k == 3 ) ) ans = k ; else ans = - 1 ; return ans ; k = 7 ; int res = findN ( k ) ; if ( ( res == - 1 ) || ( res == - 2 ) ) System . out . println ( " Not ▁ possible " ) ; else System . out . println ( res ) ; }
public static int subsetXOR ( int [ ] arr , int n , int K ) { int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] > maxEle ) && ( arr [ i ] < maxEle ) ) { maxEle = arr [ i ] ; } } int m = ( 1 << ( int ) ( log2 ( maxEle ) + 1 ) ) - 1 ; int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = arr [ i ] ; dp [ i ] [ 1 ] = arr [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { for ( int k = 0 ; k < n + 1 ; k ++ ) { dp [ i ] [ j ] [ k ] = 0 ; } } } for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { for ( int k = 0 ; k < n + 1 ; k ++ ) { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; if ( ( k != 0 ) && ( k != 1 ) ) { dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] ; } } } } int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { ans += dp [ n ] [ K ] [ i ] ; } return ans ; }
public static int D , G ; int [ ] [ ] PC = map ( ) . toArray ( new int [ ] [ ] { } ) ; int ans = 10 * 9 ; for ( int i = 0 ; i < 2 * D ; i ++ ) { int score = 0 ; int problem = 0 ; for ( int j = 0 ; j < D ; j ++ ) { if ( ( i > > j ) & 1 ) { score += 100 * ( j + 1 ) * PC [ j ] [ 0 ] + PC [ j ] [ 1 ] ; problem += PC [ j ] [ 0 ] ; } } if ( score > G ) continue ; int left = G - score ; for ( int j = 0 ; j < D ; j ++ ) { if ( ( i > > j ) & 1 ) continue ; if ( left > 100 * ( j + 1 ) * PC [ j ] [ 0 ] + PC [ j ] [ 1 ] ) { } else { int tmp = ( left + ( 100 * ( j + 1 ) ) - 1 ) / ( 100 * ( j + 1 ) ) ; ans = Math . min ( ans , problem + Math . min ( tmp , PC [ j ] [ 0 ] ) ) ; } } } System . out . println ( ans ) ; return ans ; }
public static void main ( String [ ] args ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ run " ) ) ; for ( ; ; ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ run " ) ) ; int m = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ run " ) ) ; int [ ] a = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ numbers ▁ to ▁ run " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int s = 0 ; if ( Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ numbers ▁ to ▁ run " ) ) . mapToInt ( Integer :: parseInt ) . sum ( ) == m ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public static int n ( String input ) { int n = Integer . parseInt ( input ) ; List < Integer > l = Arrays . asList ( Integer . parseInt ( input ) . split ( " ▁ " ) ) ; int maxi = l . stream ( ) . mapToInt ( Integer :: parseInt ) . max ( ) . orElse ( 0 ) ; int mini = l . stream ( ) . mapToInt ( Integer :: parseInt ) . min ( ) . orElse ( 0 ) ; if ( n == 1 || l . size ( ) == l . stream ( ) . mapToInt ( Integer :: parseInt ) . sum ( ) ) { System . out . println ( 0 ) ; } else { System . out . println ( l . size ( ) - maxi - mini ) ; } return n ; }
public static final int minAbsDiff ( int n ) { int left = Math . pow ( 2 , Math . floor ( log2 ( n ) ) ) ; int right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; }
public static int LCIS ( int [ ] arr1 , int n , int [ ] arr2 , int m ) { int [ ] table = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( arr1 [ i ] == arr2 [ j ] ) && ( current + 1 > table [ j ] ) ) { table [ j ] = current + 1 ; } } if ( ( arr1 [ i ] > arr2 [ j ] ) && ( table [ j ] > current ) ) { if ( ( table [ j ] > current ) && ( current + 1 > table [ j ] ) ) { current = table [ j ] ; } } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( ( table [ i ] > result ) && ( table [ i ] > result ) ) { result = table [ i ] ; } } return result ; }
public static int countSetBits ( int n ) { int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) bitCount += countSetBitsUtil ( i ) ; return bitCount ; }
public static int partition ( int [ ] arr , int low , int high ) { int pivot = arr [ low ] ; int i = low - 1 ; int j = high + 1 ; while ( ( true ) && ( arr [ i ] < pivot ) ) { i ++ ; while ( ( arr [ i ] > pivot ) && ( arr [ i ] < 0 ) ) { i ++ ; } j -- ; while ( ( arr [ j ] > pivot ) && ( arr [ j ] < 0 ) ) { j -- ; } if ( ( i >= j ) ) { return j ; } arr [ i ] = arr [ j ] ; } }
public static int partition ( int [ ] arr , int low , int high ) { int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j < high ; j ++ ) { if ( ( arr [ j ] <= pivot ) && ( arr [ j ] > pivot ) ) { i ++ ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } } arr [ i + 1 ] = arr [ high ] ; return ( i + 1 ) ; }
public static int maxSubArraySum ( int [ ] a , int size ) { int maxSoFar = - 10 * 9 ; int maxEndingHere = 0 ; for ( int i = 0 ; i < size ; i ++ ) { maxEndingHere = maxEndingHere + a [ i ] ; if ( ( maxSoFar < maxEndingHere ) && ( maxEndingHere < 0 ) ) { maxSoFar = maxEndingHere ; } if ( ( maxEndingHere < 0 ) && ( maxEndingHere < - 1 ) ) { maxEndingHere = 0 ; } } return maxSoFar ; }
public static int fun ( int [ ] p ) { return p . length > 0 ? p [ p . length - 1 ] : - 1 ; }
public static void printArray ( int N , int SUM , int K ) { int minSum = ( N * ( N + 1 ) ) / 2 ; int maxSum = ( N * K ) - ( N * ( N - 1 ) ) / 2 ; if ( ( minSum > SUM || maxSum < SUM ) && ( N > K ) ) { System . out . println ( " Not ▁ Possible " ) ; return ; } int [ ] arr = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 1 ) arr [ i ] = i ; int sum = minSum ; int i = N ; while ( ( i >= 1 ) && ( sum < K ) ) { int x = sum + ( K - i ) ; if ( ( x < SUM ) || ( x > K ) ) { sum = sum + ( K - i ) ; arr [ i ] = K ; K -- ; } else { arr [ i ] += ( SUM - sum ) ; sum = SUM ; break ; } i -- ; } for ( int i = 1 ; i <= N ; i += 1 ) System . out . print ( Integer . toString ( arr [ i ] ) + " ▁ " ) ; }
public static int COST = 3 ; ; int maxItems = 0 ; int type1 = x / COST ; ; x %= COST ; ; int type2 = y / COST ; ; y %= COST ; ; int type3 = z / COST ; ; z %= COST ; ; int type4 = Math . min ( x , Math . min ( y , z ) ) ; ; int maxItems = type1 + type2 + type3 + type4 ; ; return maxItems ; }
public static final int runTasks ( Deque < Integer > A , Deque < Integer > B ) { int totalTime = 0 ; while ( ( A . size ( ) > 0 ) && ( B . size ( ) > 0 ) ) { Integer x = A . pop ( ) ; Integer y = B . pop ( ) ; if ( ( x == y ) || ( x == y ) ) { totalTime ++ ; } else { B . appendFirst ( y ) ; A . push ( x ) ; totalTime += 2 ; } } return totalTime ; }
public static void line ( double x0 , double y0 ) { double c = 2 * y0 * x0 ; System . out . println ( " { : . 1 } " . format ( y0 ) + " x " + " ▁ + ▁ " + " { : . 1 } " . format ( x0 ) + " y ▁ = ▁ " + " { : . 1 } " . format ( c ) ) ; if ( GWT . isProdMode ( ) ) { x0 = 4 ; y0 = 3 ; line ( x0 , y0 ) ; } }
public static int input ( ) { return input ( ) . length ; }
static public void main ( String [ ] args ) { final double EPS = 1e-9 ; final double cross = a . real * b . imag - a . imag * b . real ; final double dot = a . real * b . real + a . imag * b . imag ; final double checkCCW = p0 . x * b . x + p0 . y * b . y ; final double checkCCW = p1 . x * b . x + p1 . y * b . y ; final double checkCCW = p2 . x * b . x + p2 . y * b . y ; final double checkCCW = p3 . x * b . x + p3 . y * b . y ; final double checkCCW = p4 . x * b . x + p4 . y * b . y ; final double checkCCW = p5 . x * b . x + p5 . y * b . y ; final double checkCCW = p6 . x * b . x + p6 . y * b . y ; final double checkCCW = p7 . x * b . x + p7 . y * b . y ; final double [ ] [ ] _lines = new double [ 2 ] [ ] ; for ( int i = 0 ; i < _lines . length ; i ++ ) { _lines [ i ] = Arrays . copyOf ( _lines [ i ] , _lines [ i ] . length ) ; final double [ ] p0 = ( _lines [ i ] . length + 1 ) / 2 ; final double [ ] p1 = ( _lines [ i ] . length + 1 ) / 2 ; final double [ ] p2 = ( _lines [ i ] . length + 1 ) / 2 ; final double [ ] p3 = ( _lines [ i ] . length + 1 ) / 2 ; final double [ ] intersect = checkIntersection ( p0 , p1 , p2 ) ; intersect [ 0 ] = p1 [ 0 ] + y * 1j ; intersect [ 1 ] = p2 [ 0 ] + y * 1j ; intersect [ 2 ] = p3 [ 0 ] + y * 1j ; intersect [ 3 ] = p4 [ 0 ] + y * 1j ; intersect [ 0 ] = p5 [ 0 ] + y * 1j ; intersect [ 1 ] = p5 [ 1 ] + y * 1j ; intersect [ 2 ] = p5 [ 1 ] + y * 1j ; } if ( args . length == 0 ) { String [ ] _input = args ; }
public static boolean isAnyNotPalindrome ( String s ) { Set < String > unique = new HashSet < String > ( ) ; for ( int i = 0 ; i <= s . length ( ) ; i ++ ) { unique . add ( s . charAt ( i ) ) ; } if ( ( unique . size ( ) > 1 ) && ( unique . size ( ) == 2 ) ) { return true ; } else { return false ; } }
public static int findMajority ( int [ ] arr , int n ) { return arr [ ( int ) ( n / 2 ) ] ; }
x ; int N = 0 , S = 0 ; int po = 0 ; String c = " YES " ; for ( int i = 0 ; i < x ; i ++ ) { String [ ] p = Arrays . copyOfRange ( input , i , i + 1 ) ; if ( N == 0 && S == 0 ) { if ( p [ 1 ] != " South " ) { c = " NO " ; break ; } } if ( S - N == 20000 ) { if ( p [ 1 ] != " North " ) { c = " NO " ; break ; } } if ( p [ 1 ] . equals ( " North " ) ) { po = po - Integer . parseInt ( p [ 0 ] ) ; N += Integer . parseInt ( p [ 0 ] ) ; if ( po < 0 ) { c = " NO " ; break ; } } else if ( p [ 1 ] . equals ( " South " ) ) { S += Integer . parseInt ( p [ 0 ] ) ; po = po + Integer . parseInt ( p [ 0 ] ) ; if ( po > 20000 ) { c = " N0" ; break ; } } if ( N == S ) { N = 0 , S = 0 ; } } if ( N != S ) { c = " NO " ; } System . out . println ( c ) ; }
public static int countSubArrays ( int [ ] arr , int n , int K ) { int count = 0 ; ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwiseOr = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwiseOr = bitwiseOr | arr [ k ] ; } if ( ( bitwiseOr >= K ) && ( bitwiseOr < ( arr [ k ] + arr [ j ] ) ) ) { count ++ ; } } } return count ; }
public static boolean canBeEqual ( int a , int b , int c , int k ) { int [ ] arr = new int [ 3 ] ; ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; Arrays . sort ( arr ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( ( k < 0 || k % 3 != 0 ) && ( k > 0 ) ) return false ; ; return true ; }
public static int [ ] [ ] adjacency ( int i ) { int [ ] [ ] adjacency = new int [ 100 ] [ ] ; for ( int x = 0 ; x < adjacency . length ; x ++ ) adjacency [ x ] [ 0 ] = i ; final int node = adjacency [ node ] [ 0 ] ; final int [ ] leaf = new int [ N + 1 ] ; leaf [ 0 ] = node ; return adjacency ; }
public static final void main ( String [ ] args ) { System . setSecurityManager ( new SecurityManager ( ) ) ; final double inf = 10 * 20 ; final double eps = 1.0 / 10 * 10 ; final double mod = 10 * 9 + 7 ; final double dd [ ] = { new double [ ] { - 1 , 0 } , new double [ ] { 0 , 1 } , new double [ ] { 1 , 0 } , new double [ ] { 0 , - 1 } } ; final double ddn [ ] = { new double [ ] { - 1 , 0 } , new double [ ] { - 1 , 1 } , new double [ ] { 0 , 1 } , new double [ ] { 1 , 1 } , new double [ ] { 1 , 0 } , new double [ ] { 1 , - 1 } , new double [ ] { 0 , - 1 } , new double [ ] { - 1 , - 1 } } ; final double LI [ ] = { Double . MIN_VALUE , Double . MAX_VALUE } ; final double LI_ [ ] = { Double . MIN_VALUE , Double . MAX_VALUE } ; final double LF [ ] = { Double . MIN_VALUE , Double . MAX_VALUE } ; final double LS [ ] = { Double . MIN_VALUE , Double . MAX_VALUE } ; final int I = Integer . MAX_VALUE ; final double F = Double . MAX_VALUE ; final double S = Double . MIN_VALUE ; final double pf = Double . MAX_VALUE ; final int main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int k = I ; int l = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( sc . nextInt ( ) != '1' ) break ; l ++ ; } if ( l >= k ) return ; System . out . println ( sc . nextInt ( ) ) ; } System . out . println ( main ) ; }
public static final void main ( String [ ] args ) { final int t = 1 ; for ( ; ; ) { final int i = 0 ; int line ; Scanner scanner = new Scanner ( System . in ) ; scanner . nextLine ( ) ; final int boughtCount = scanner . nextInt ( ) ; scanner . nextLine ( ) ; final int [ ] madeOut = new int [ t ] ; scanner . nextLine ( ) ; int res = 0 ; for ( int i = 0 ; i < madeOut . length ; i ++ ) { if ( madeOut [ i ] != 0 ) return ; System . out . println ( - 1 ) ; res += Math . min ( boughtCount [ i ] , madeOut [ i ] ) ; } System . out . println ( res ) ; } }
public static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ ] [ ] L = new int [ o + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { for ( int k = 0 ; k < o + 1 ; k ++ ) { if ( ( i == 0 || j == 0 || k == 0 ) && ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) ) { L [ i ] [ j ] [ k ] = 0 ; } else if ( ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) ) { L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; } else { L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } } X = " AGGT12" ; Y = "12TXAYB " ; Z = "12XBA " ; m = X . length ( ) ; n = Y . length ( ) ; o = Z . length ( ) ; System . out . println ( " Length ▁ of ▁ LCS ▁ is " + lcsOf3 ( X , Y , Z , m , n , o ) ) ; return L [ m ] [ n ] [ o ] ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] r = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = i ; } int ans = Math . abs ( r [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { ans += Math . abs ( r [ i ] - r [ i - 1 ] ) ; } System . out . println ( ans ) ; }
public static boolean isSpiltPossible ( int n , int [ ] a ) { int Sum = 0 ; int c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum += a [ i ] ; if ( ( a [ i ] == 1 ) && ( a [ i ] == 2 ) ) c1 ++ ; } if ( ( Sum % 2 ) != 0 ) return false ; if ( ( ( Sum / 2 ) % 2 == 0 ) && ( c1 > 0 ) ) return true ; if ( ( c1 > 0 ) && ( a [ 0 ] == 1 ) && ( a [ 1 ] == 2 ) ) return true ; else return false ; }
public static int n ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] l = new int [ 4 ] ; for ( int i = 0 ; i < l . length ; i ++ ) l [ i ] = Integer . parseInt ( input ) ; return n ; }
public static void countEvenOdd ( int min , int max , int [ ] [ ] steps ) { boolean beven = true ; boolean aeven = false ; int n = 2 ; for ( int i = 0 ; i <= n ; i ++ ) { int a = steps [ i ] [ 0 ] ; int b = steps [ i ] [ 1 ] ; if ( ( ! ( aeven || a & 1 ) ) && ( b & 1 ) ) aeven = true ; if ( ( beven ) ) { if ( ( b & 1 ) != 0 ) beven = false ; } else if ( ( ! ( a & 1 ) ) && ( ! ( b & 1 ) ) ) beven = true ; } if ( ( beven ) ) { int even = ( Integer . MAX_VALUE / 2 ) - Integer . MAX_VALUE ; int odd = 0 ; if ( ( ! ( beven ^ aeven ) ) && ( ! ( a & 1 ) ) ) even += ( max - min + 1 - Integer . MAX_VALUE + Integer . MIN_VALUE ) ; else odd += ( max - min + 1 - Integer . MAX_VALUE + Integer . MIN_VALUE ) ; System . out . println ( " even ▁ = ▁ " + even + " , ▁ odd ▁ = ▁ " + odd + " , ▁ " + " " ) ; } min = 1 ; max = 4 ; steps [ 0 ] = new int [ ] { 1 , 2 } ; steps [ 1 ] = new int [ ] { 3 , 4 } ; countEvenOdd ( min , max , steps ) ; }
public static int vamshi ( ) { int vamshi = 0 , z = 0 ; while ( true ) { vamshi += ( int ) input . nextInt ( ) ; z ++ ; } System . out . println ( ( vamshi / z + 1 ) * z ) ; }
public static void printKPFNums ( int A , int B , int K ) { boolean prime [ ] = { true } ; int [ ] pFactors = new int [ B + 1 ] ; for ( int p = 2 ; p <= B ; p ++ ) { if ( ( pFactors [ p ] == 0 ) && ( prime [ p ] ) ) { for ( int i = p ; i <= B ; i += p ) { pFactors [ i ] = pFactors [ i ] + 1 ; } } } for ( int i = A ; i <= B ; i ++ ) { if ( ( pFactors [ i ] == K ) && ( prime [ i ] ) ) { System . out . print ( i + " ▁ " ) ; } } A = 14 ; B = 18 ; K = 2 ; printKPFNums ( A , B , K ) ; }
public static void reverserWords ( String string ) { List < String > st = Lists . newArrayList ( ) ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( string . charAt ( i ) != ' ▁ ' ) { st . add ( string . substring ( i ) ) ; } else { while ( st . size ( ) > 0 ) { System . out . print ( st . get ( st . size ( ) - 1 ) + " ▁ " ) ; st . remove ( st . size ( ) - 1 ) ; } System . out . println ( ) ; } } while ( st . size ( ) > 0 ) { System . out . print ( st . get ( st . size ( ) - 1 ) + " ▁ " ) ; st . remove ( st . size ( ) - 1 ) ; } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " windows " ) ) { string = " Geeks ▁ for ▁ Geeks " ; reverserWords ( string ) ; } }
public static int input ( ) { int a = b = 0 ; for ( int x = 0 , y = 0 ; x < a && y < b ; x ++ , y ++ ) { a += x > y ? 1 : 0 ; b += x < y ? 1 : 0 ; } System . out . println ( - 1 == a ? b / a + 1 : b / a ) ; }
n ; int N = n + 2 ; boolean [ ] isPrime = new boolean [ N ] ; isPrime [ 0 ] = 0 ; isPrime [ 1 ] = 0 ; final int sieve [ ] = new int [ N ] ; int i = 2 ; while ( i * i <= N ) { if ( isPrime [ i ] == 0 ) { i ++ ; continue ; } int j = 2 * i ; while ( j < N ) { isPrime [ j ] = 0 ; j += i ; } i ++ ; } sieve [ 0 ] = 1 ; sieve [ 1 ] = 1 ; sieve [ 2 ] = 1 ; sieve [ 3 ] = 1 ; sieve [ 4 ] = 1 ; sieve [ 5 ] = 1 ; sieve [ 6 ] = 1 ; sieve [ 7 ] = 1 ; sieve [ 8 ] = 1 ; sieve [ 9 ] = 1 ; sieve [ 10 ] = 1 ; sieve [ 11 ] = 1 ; sieve [ 12 ] = 1 ; sieve [ 13 ] = 1 ; sieve [ 14 ] = 1 ; sieve [ 15 ] = 1 ; sieve [ 16 ] = 1 ; sieve [ 17 ] = 1 ; sieve [ 18 ] = 1 ; sieve [ 19 ] = 1 ; sieve [ 20 ] = 1 ; sieve [ 21 ] = 1 ; sieve [ 22 ] = 1 ; sieve [ 23 ] = 1 ; sieve [ 24 ] = 1 ; sieve [ 25 ] = 1 ; sieve [ 26 ] = 1 ; sieve [ 27 ] = 1 ; sieve [ 28 ] = 1 ; sieve [ 29 ] = 1 ; sieve [ 30 ] = 1 ; sieve [ 31 ] = 1 ; sieve [ 32 ] = 1 ; sieve [ 33 ] = 1 ; sieve [ 34 ] = 1 ; sieve [ 35 ] = 1 ; sieve [ 36 ] = 1 ; sieve [ 37 ] = 1 ; sieve [ 38 ] = 1 ; sieve [ 39 ] = 1 ; sieve [ 40 ] = 1 ; sieve [ 41 ] = 1 ; sieve [ 42 ] = 1 ; sieve [ 43 ] = 1 ; sieve [ 44 ] = 1 ; sieve [ 45 ] = 1 ; sieve [ 46 ] = 1 ; sieve [ 47 ] = 1 ; sieve [ 48 ] = 1 ; sieve [ 49 ] =
public static final void main ( String [ ] args ) { final Scanner sc = new Scanner ( System . in ) ; final java . util . Stack stack = new java . util . Stack ( ) ; while ( sc . hasNextLine ( ) ) { final String s = sc . nextLine ( ) ; if ( s . matches ( " [ - + ] ? \ " d + " ) ) { stack . push ( Double . parseDouble ( s ) ) ; } else if ( s . equals ( " + " ) ) { final double n = stack . pop ( ) ; stack . push ( n ) ; } else if ( s . equals ( " - " ) ) { final double n = stack . pop ( ) ; stack . push ( n ) ; } else if ( s . equals ( " * " ) ) { final double n = stack . pop ( ) ; stack . push ( n ) ; } else if ( s . equals ( " / " ) ) { final double n = stack . pop ( ) ; stack . push ( n ) ; } } System . out . println ( " { : . 6f } " . format ( stack . pop ( ) ) ) ; }
public static int numInp ( ) { return Integer . parseInt ( input ( ) ) ; }
public static void findNthTerm ( int n ) { if ( n % 2 == 0 ) { n /= 2 ; System . out . println ( 3 * ( n - 1 ) ) ; } else { n = ( n / 2 ) + 1 ; System . out . println ( 2 * ( n - 1 ) ) ; } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " win " ) ) { int N = 4 ; findNthTerm ( N ) ; N = 11 ; findNthTerm ( N ) ; } }
public static int countNonIncreasing ( int [ ] arr , int n ) { int cnt = 0 ; ; int len = 1 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( ( arr [ i + 1 ] >= arr [ i ] ) && ( arr [ i ] <= arr [ i + 1 ] ) ) { len ++ ; } else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; ; len = 1 ; } } if ( ( len > 1 ) && ( ( len - 1 ) * len ) / 2 == 0 ) { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; ; } return ( int ) cnt ; }
public static int maximize ( int [ ] A1 , int [ ] A2 , int n , int x , int y ) { int [ ] c = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = A2 [ i ] - A1 [ i ] ; Sum += A1 [ i ] ; } Arrays . sort ( c ) ; c = c [ n - 1 ] ; int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { Sum += c [ i ] ; if ( ( i + 1 ) >= ( n - x ) ) maxi = Math . max ( Sum , maxi ) ; } return maxi ; }
public static int t ( ) { int t = Integer . parseInt ( System . in ) ; for ( int i = 0 ; i < t ; i ++ ) { int x = Integer . parseInt ( System . in ) ; if ( x / 1000 > 0 ) { System . out . println ( 10 * ( x % 10 - 1 ) + 10 ) ; } else if ( x / 100 > 0 ) { System . out . println ( 10 * ( x % 10 - 1 ) + 6 ) ; } else if ( x / 10 > 0 ) { System . out . println ( 10 * ( x % 10 - 1 ) + 3 ) ; } else { System . out . println ( 10 * ( x % 10 - 1 ) + 1 ) ; } } return t ; }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] [ ] cost = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = new int [ n ] ; int m = Integer . parseInt ( input . nextLine ( ) ) ; for ( ; m > 0 ; m -- ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; int c = Integer . parseInt ( input . nextLine ( ) ) ; int d = Integer . parseInt ( input . nextLine ( ) ) ; cost [ a - 1 ] [ b - 1 ] = c ; cost [ b - 1 ] [ a - 1 ] = d ; } int s = Integer . parseInt ( input . nextLine ( ) ) ; int g = Integer . parseInt ( input . nextLine ( ) ) ; int V = Integer . parseInt ( input . nextLine ( ) ) ; int P = Integer . parseInt ( input . nextLine ( ) ) ; for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( cost [ i ] [ j ] > cost [ i ] [ k ] + cost [ k ] [ j ] ) cost [ i ] [ j ] = cost [ i ] [ k ] + cost [ k ] [ j ] ; } } } System . out . println ( V - P - cost [ s - 1 ] [ g - 1 ] - cost [ g - 1 ] [ s - 1 ] ) ; return s - 1 ; }
public static int [ ] [ ] test ( ) { int r1 = Integer . MAX_VALUE , r2 = Integer . MIN_VALUE ; int c1 = Integer . MIN_VALUE , c2 = Integer . MAX_VALUE ; int d1 = Integer . MIN_VALUE , d2 = Integer . MAX_VALUE ; int x = ( d1 + c1 - r2 ) / 2 ; int y = r1 - x ; int z = c1 - x ; int w = d1 - x ; if ( 1 <= x && x <= 9 && 1 <= y && y <= 9 && 1 <= z && z <= 9 && 1 <= w && Integer . MAX_VALUE == w && Integer . MAX_VALUE == w && Integer . MIN_VALUE == w ) { System . out . println ( x + " ▁ " + y ) ; System . out . println ( z + " ▁ " + w ) ; } else { System . out . println ( - 1 ) ; } return new int [ ] [ ] { { x , y } , { z , w } } ; }
public static final void main ( String [ ] args ) { while ( true ) { int n = Integer . parseInt ( System . in . readLine ( ) ) ; int m = Integer . parseInt ( System . in . readLine ( ) ) ; if ( n == m == 0 ) break ; List < Integer > a = Arrays . asList ( Integer . parseInt ( System . in . readLine ( ) ) , Integer . parseInt ( System . in . readLine ( ) ) ) ; List < Integer > w = Arrays . asList ( Integer . parseInt ( System . in . readLine ( ) ) , Integer . parseInt ( System . in . readLine ( ) ) ) ; Set < Integer > Set = new HashSet < > ( ) ; final int i = m ; if ( i == m ) { Set . add ( weight ) ; return ; } go ( i + 1 , weight ) ; go ( i + 1 , weight + w . get ( i ) ) ; go ( i + 1 , weight - w . get ( i ) ) ; go ( 0 , 0 ) ; boolean ans = false ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { if ( a . get ( i ) != 0 ) { if ( ans == false ) ans = new HashSet < > ( Math . abs ( s - i ) ) ; else ans = new HashSet < > ( s - i ) ; if ( i + s . contains ( s ) || i - s . contains ( s ) ) { ans = new HashSet < > ( Math . abs ( s - i ) ) ; } } } if ( ans == false ) { System . out . println ( 0 ) ; continue ; } else if ( ans . size ( ) == 0 ) { System . out . println ( - 1 ) ; continue ; } else { System . out . println ( Math . min ( ans , 1 ) ) ; } } }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ display " ) ) ; Map < String , Integer > m = new HashMap < String , Integer > ( ) ; m . put ( " A " , Integer . MAX_VALUE ) ; m . put ( " B " , Integer . MAX_VALUE ) ; m . put ( " C " , Integer . MAX_VALUE ) ; m . put ( " AB " , Integer . MAX_VALUE ) ; m . put ( " AC " , - 1 ) ; return n ; }
public static boolean startsWith ( String str , String pre ) { int strLen = str . length ( ) ; int preLen = pre . length ( ) ; int i = 0 ; int j = 0 ; while ( ( i < strLen && j < preLen ) || ( i > 0 && j > 0 ) ) { if ( ( str . charAt ( i ) != pre . charAt ( j ) ) || ( str . charAt ( i ) != pre . charAt ( j ) ) ) { return false ; } i ++ ; j ++ ; } return true ; } public static boolean endsWith ( String str , String suff ) { i = str . length ( ) - 1 ; j = suff . length ( ) - 1 ; while ( ( i >= 0 && j >= 0 ) || ( i > 0 && j > 0 ) ) { if ( ( str . charAt ( i ) != suff . charAt ( j ) ) || ( str . charAt ( i ) != suff . charAt ( j ) ) ) { return false ; } i -- ; j -- ; } return true ; } public static boolean checkString ( String str , String a , String b ) { if ( ( str . length ( ) != a . length ( ) + b . length ( ) ) || ( str . charAt ( a . length ( ) ) != b . charAt ( b . length ( ) ) ) ) { return false ; } if ( ( startsWith ( str , a ) ) && ( endsWith ( str , b ) ) ) { return true ; } if ( ( startsWith ( str , b ) ) && ( endsWith ( str , a ) ) ) { if ( ( endsWith ( str , a ) ) && ( endsWith ( str , b ) ) ) { return true ; } } return false ; } public static void main ( String [ ] args ) { System . out . println ( " Yes " ) ; } public static void main ( String [ ] args ) { System . out . println ( " No " ) ; } } </DOCUMENT>
public static void printCombination ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i % 3 != 0 ) && ( i % 3 != 1 ) ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( ( j % 3 != 0 ) && ( j % 3 != 1 ) ) { for ( int k = 1 ; k <= n ; k ++ ) { if ( ( k % 3 != 0 ) && ( i + j + k ) == n ) { System . out . println ( i + " ▁ " + j + " ▁ " + k ) ; ; return ; } } } } } } n = 233 ; printCombination ( n ) ; }
public static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { for ( int k = 0 ; k < n + 1 ; k ++ ) { if ( i + j + k == n ) { result ++ ; } } } } return result ; }
public static int digitSum ( int n ) { int sum = 0 ; while ( ( n > 0 ) && ( sum < TEN ) ) { sum += n % TEN ; n /= TEN ; } return sum ; }
public static int power ( int x , int a ) { int res = 1 ; ; while ( ( a ) > 0 ) { if ( ( a & 1 ) != 0 ) res = res * x ; x = x * x ; a >>= 1 ; } ; return res ; }
static public int [ ] [ ] testArray2d ( int a , int b , int c ) { int [ ] [ ] result = new int [ a ] [ b ] ; for ( int i = 0 ; i < a ; i ++ ) result [ i ] = new int [ b ] ; result [ a ] = new int [ b ] ; result [ b ] = new int [ c ] ; result [ c ] = new int [ c ] ; result [ c ] = new int [ c ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [ d ] ; result [ d ] = new int [
s = input . nextLine ( ) ; System . out . println ( "2018" + s . substring ( 4 ) ) ; }
from ▁ queue ▁ to ▁ be ▁ used ▁ for ▁ the ▁ first ▁ time . STRNEWLINE ▁ */ public static void firstnonrepeating ( String Str ) { MAX_CHAR = 26 ; Queue < Character > q = new LinkedList < Character > ( ) ; int charCount [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < Str . length ( ) ; i ++ ) { q . offer ( Str . charAt ( i ) ) ; charCount [ Character . toUpperCase ( Str . charAt ( i ) ) - Character . toUpperCase ( ' a ' ) ] ++ ; while ( ( ! q . isEmpty ( ) ) && ( charCount [ Character . toUpperCase ( q . poll ( ) ) - Character . toUpperCase ( ' a ' ) ] > 1 ) ) { if ( ( charCount [ Character . toUpperCase ( q . poll ( ) ) - Character . toUpperCase ( ' a ' ) ] > 1 ) && ( q . isEmpty ( ) ) ) { q . offer ( null ) ; } else { System . out . print ( q . poll ( ) + " ▁ " ) ; break ; } } if ( ( q . isEmpty ( ) ) && ( charCount [ Character . toUpperCase ( Str . charAt ( i ) ) - Character . toUpperCase ( ' a ' ) ] > 1 ) ) { System . out . print ( - 1 + " ▁ " ) ; } } System . out . println ( ) ; }
public static final void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ nodes ▁ to ▁ print " ) ) ; int [ ] graph = new int [ n - 1 ] ; for ( ; n > 0 ; n -- ) { int i = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ nodes ▁ to ▁ print " ) ) ; int j = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ nodes ▁ to ▁ print " ) ) ; graph [ i ] = j ; graph [ j ] = i ; } int left = 0 ; int right = 0 ; int [ ] color = new int [ n + 1 ] ; Set < Integer > visited = new HashSet < Integer > ( ) ; final int node = 0 ; LinkedList < Integer > level = new LinkedList < Integer > ( ) ; level . add ( node ) ; if ( node != 0 ) color [ node ] = 1 ; while ( level . size ( ) > 0 ) { node = level . removeFirst ( ) ; for ( int val : graph [ node ] ) { if ( val != 0 ) { color [ val ] = 1 - color [ node ] ; visited . add ( val ) ; level . add ( val ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) { if ( i != 0 ) { visited . add ( i ) ; dfs ( i ) ; } } for ( int val = 1 ; val <= n ; val ++ ) { if ( color [ val ] == 0 ) left ++ ; else right ++ ; } System . out . println ( left * right - n + 1 ) ; }
public static int solve ( int n , int m , int obstacles , double [ ] rangee ) { double val = Math . min ( n , m ) ; rangee = new double [ rangee . length ] ; Arrays . fill ( rangee , 0 ) ; int c = 1 ; for ( int i = obstacles - 1 ; i >= 0 ; i -- ) { rangee [ i ] = 2 * rangee [ i ] ; val -= rangee [ i ] ; if ( ( val <= 0 ) && ( rangee [ i ] > 0 ) ) { return c ; } else { c ++ ; } } if ( ( val > 0 ) && ( rangee [ m ] > 0 ) ) { return - 1 ; } n = 4 ; m = 5 ; obstacles = 3 ; rangee [ 0 ] = 1.0 ; rangee [ 1 ] = 1.25 ; rangee [ 2 ] = 1.15 ; System . out . println ( solve ( n , m , obstacles , rangee ) ) ; }
public static void main ( String [ ] s ) { Scanner sc = new Scanner ( System . in ) ; int t = Integer . parseInt ( sc . nextLine ( ) ) ; int e1 = Integer . parseInt ( sc . nextLine ( ) ) ; int e2 = Integer . parseInt ( sc . nextLine ( ) ) ; int i = 1 ; while ( i < s . length ) { int x = Integer . parseInt ( sc . nextLine ( ) ) ; if ( sc . nextLine ( ) . charAt ( i ) == ' + ' ) e2 += x ; else e2 *= x ; i += 2 ; } if ( e1 == t && e2 == t ) System . out . print ( " U " ) ; else if ( e1 == t ) System . out . print ( " M " ) ; else if ( e2 == t ) System . out . print ( " L " ) ; else System . out . print ( " I " ) ; }
public static class MinStack extends Stack < Integer > { public static void push ( ) { stack . clear ( ) ; minStack . clear ( ) ; } public void push ( Integer x ) { stack . push ( x ) ; if ( minStack . size ( ) == 0 ) { minStack . push ( x ) ; return ; } if ( x <= minStack . peek ( ) ) { minStack . push ( x ) ; } else { minStack . push ( minStack . peek ( ) ) ; } } public void pop ( ) { if ( stack . size ( ) > 0 ) { minStack . pop ( ) ; stack . pop ( ) ; } } public Integer top ( ) { if ( stack . size ( ) > 0 ) { return stack . pop ( ) ; } return null ; } public Integer getMin ( ) { if ( minStack . size ( ) > 0 ) { return minStack . pop ( ) ; } return null ; } }
public static String convertToWords ( int n , String s ) { String one [ ] = { " " , " one ▁ " , " two ▁ " , " three ▁ " , " four ▁ " , " five ▁ " , " six ▁ " , " seven ▁ " , " eight ▁ " , " nine ▁ " , " ten ▁ " , " eleven ▁ " , " twelve ▁ " , " thirteen ▁ " , " fourteen ▁ " , " fifteen ▁ " , " sixteen ▁ " , " seventeen ▁ " , " eighteen ▁ " , " nineteen ▁ " } ; ; String ten [ ] = { " " , " " , " twenty ▁ " , " thirty ▁ " , " forty ▁ " , " fifty ▁ " , " sixty ▁ " , " seventy ▁ " , " eighty ▁ " , " ninety ▁ " } ; ; final int numToWords = n / 10 ; String str = " " ; ; if ( ( n > 19 ) && ( n % 10 ) != 0 ) str += ten [ n / 10 ] + one [ n % 10 ] ; else str += one [ n ] ; if ( ( n ) > 0 ) str += s ; return str ; }
public static int flipSign ( int a ) { int neg = 0 ; ; int tmp = a < 0 ? - 1 : 1 ; while ( ( a != 0 ) && ( a != - 1 ) ) { neg += tmp ; a += tmp ; } ; return neg ; } public static boolean areDifferentSign ( int a , int b ) { return ( ( a < 0 && b > 0 ) || ( a > 0 && b < 0 ) ) ; } public static int sub ( int a , int b ) { return a + flipSign ( b ) ; } public static int mul ( int a , int b ) { if ( ( a < b ) && ( b < a ) ) { return mul ( b , a ) ; } int sum = 0 ; for ( int i = Math . abs ( b ) ; i > 0 ; i -- ) { sum += a ; } if ( ( b < 0 ) && ( a != 0 ) ) { sum = flipSign ( sum ) ; } return sum ; } public static int division ( int a , int b ) { int quotient = 0 ; int divisor = flipSign ( Math . abs ( b ) ) ; for ( int dividend = Math . abs ( a ) ; dividend < Math . abs ( divisor ) + divisor ; dividend ++ ) { quotient ++ ; } if ( ( areDifferentSign ( a , b ) ) && ( quotient > 0 ) ) { quotient = flipSign ( quotient ) ; } return quotient ; } }
public static int factorial ( int n ) { int i = n ; int fact = 1 ; while ( ( n / i != n ) && ( i % 2 == 0 ) ) { fact = fact * i ; i -- ; } return fact ; }
public static int CntDivbyX ( int [ ] arr , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( ( number % x == 0 ) || ( number % x == 1 ) ) && ( ( number % x == 2 ) || ( number % x == 3 ) ) ) { count ++ ; } } return count ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ be ▁ inserted " ) ) ; List < Integer > a = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ elements ▁ to ▁ be ▁ inserted " ) ) ; Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int x : a ) { int c = 0 ; while ( x > 0 ) { c += x % 2 ; x /= 2 ; } map . put ( c , x ) ; } int ans = 0 ; for ( Integer v : map . values ( ) ) { ans += v * ( v - 1 ) / 2 ; } System . out . println ( ans ) ; if ( args . length == 0 ) { int t = 1 ; while ( t > 0 ) { main ( ) ; t -- ; } } }
public static int minNoOf_operation ( int [ ] arr , int n , int k ) { int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int noOfSubtraction = 0 ; if ( ( arr [ i ] > arr [ i - 1 ] ) && ( arr [ i ] > arr [ i - 1 ] ) ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; ; if ( ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) && ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return ( int ) res ; }
public static int CountSubSet ( int arr [ ] , int n , int X ) { int N = 2 * n ; ; int count = 0 ; ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { if ( ( arr [ j ] == X ) && ( arr [ j + 1 ] == X ) ) { count ++ ; } ; } } } return count ; }
public static int FindMaxProduct ( int [ ] [ ] arr , int n ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( j - 3 ) >= 0 ) && ( ( j - 2 ) >= 0 ) && ( ( j - 1 ) >= 0 ) && ( ( j - 0 ) >= 0 ) ) { int result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) ; if ( ( max < result ) || ( max > result ) ) max = result ; } if ( ( ( i - 3 ) >= 0 ) && ( ( i - 1 ) >= 0 ) && ( ( i - 2 ) >= 0 ) && ( ( i - 0 ) >= 0 ) && ( ( i - 3 ) >= 0 ) ) { int result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) ; if ( ( max < result ) || ( max > result ) ) max = result ; } if ( ( ( i - 3 ) >= 0 ) && ( ( i - 1 ) <= 0 ) && ( ( i - 0 ) <= 0 ) && ( ( i - 2 ) >= 0 ) && ( ( i - 0 ) <= 0 ) ) { int result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ) ; if ( ( max < result ) || ( max > result ) ) max = result ; } } } return max ; }
public static void main ( String [ ] args ) { int MAX = 50002 ; ; int [ ] primes = new int [ MAX ] ; sieve ( ) ; boolean [ ] isPrime = new boolean [ MAX ] ; int p = 2 ; while ( p * p < MAX ) { if ( ( isPrime [ p ] == true ) && ( p < MAX ) ) { for ( int i = p * 2 ; i < MAX ; i += p ) { isPrime [ i ] = false ; } } p ++ ; } for ( p = 2 ; p < MAX ; p ++ ) { if ( ( isPrime [ p ] ) && ( p < MAX ) ) { primes [ p ] = p ; } } final int power = 2 ; int count = 0 ; int z = y ; while ( ( x >= z ) && ( x < z ) ) { count += ( x / z ) ; z *= y ; } System . out . println ( count ) ; final int modMult = a % mod ; int res = 0 ; a = a % mod ; while ( ( b > 0 ) && ( b % 2 == 1 ) ) { if ( ( b % 2 == 1 ) ) { res = ( res + a ) % mod ; } a = ( a * 2 ) % mod ; b /= 2 ; } System . out . println ( res % mod ) ; final int countWays = n ; int m = 1 ; int ans = 1 ; for ( int i = 1 ; i < primes . length ; i ++ ) { int powers = power ( n , primes [ i ] ) ; if ( ( powers == 0 ) && ( powers < m ) ) { ans = modMult ( ans , powers + 1 , m ) % m ; } if ( ( ( ( ans - 1 ) % m ) < 0 ) && ( ans < m ) ) { System . out . println ( ans - 1 + m ) ; } else { System . out . println ( ans - 1 ) ; } } if ( args . length == 0 ) { sieve ( ) ; int n = 4 ; int m = 7 ; System . out . println ( countWays ) ; } }
public static int smallestIndexsum ( int [ ] arr , int n ) { int i = n - 1 ; ; while ( ( i >= 0 && arr [ i ] % 2 == 1 ) || ( i >= 0 && arr [ i ] % 2 == 0 ) ) i -- ; int sum = 0 ; ; for ( int j = 0 ; j <= i ; j ++ ) sum += arr [ j ] ; ; return sum ; }
public static Date getDaysDate ( ) { int y1 = input . nextInt ( ) ; int m1 = input . nextInt ( ) ; int d1 = input . nextInt ( ) ; int y2 = input . nextInt ( ) ; int m2 = input . nextInt ( ) ; int d2 = input . nextInt ( ) ; final Date date1 = new Date ( year ( ) , month ( ) , m1 , d1 ) ; final Date date2 = new Date ( year ( ) , month ( ) , m2 , d2 ) ; final Date res = date2 - date1 ; System . out . println ( Math . abs ( res . getTime ( ) ) ) ; return date1 ; }
public static int getQCount ( ) { Scanner S = new Scanner ( System . in ) ; int totalQ = S . nextInt ( ) ; int CQ = 0 ; int CQAQ = 0 ; for ( int i = 0 ; i < S . nextInt ( ) ; i ++ ) { if ( S . next ( ) == " Q " ) { CQ ++ ; } else if ( S . next ( ) == " A " ) { CQAQ += CQ * ( totalQ - CQ ) ; } } System . out . println ( CQAQ ) ; return CQAQ ; }
static public int main ( String [ ] args ) throws Exception { String [ ] inputMethods = { " clipboard " , " file " , " key " } ; int usingMethod = 0 ; InputMethod inputMethod = inputMethods [ usingMethod ++ ] ; Function < Integer , Integer > tin = new Function < Integer , Integer > ( ) { public Integer apply ( Integer input ) { return map . get ( input ) ; } } ; Function < Integer , Integer > lin = new Function < Integer , Integer > ( ) { public Integer apply ( Integer input ) { return Arrays . stream ( tin . apply ( input ) . iterator ( ) ) . mapToInt ( Integer :: parseInt ) . sum ( ) ; } } ; int mod = 1000000007 ; final int n = tin . apply ( n ) . count ( ) ; final int k = tin . apply ( k ) . count ( ) ; final int [ ] al = lin . apply ( n ) . toArray ( new int [ n ] ) ; Arrays . sort ( al ) ; int ss = sum ( al ) ; final int [ ] arrive = new int [ k ] ; arrive [ 0 ] = 1 ; final Set < Integer > usefulSet = new HashSet < Integer > ( ) ; for ( int v : al ) { ss -= v ; int uMax = 0 ; if ( v >= k ) { usefulSet . add ( v ) ; continue ; } for ( int i = 0 , j = 0 ; i < k ; i ++ , j ++ ) { int p = k - i - 1 ; int isOn = arrive [ p ] ; if ( isOn == 1 && p + v >= k ) { usefulSet . add ( v ) ; uMax = k ; } else if ( isOn == 1 ) { arrive [ p + v ] = 1 ; uMax = Math . max ( uMax , p + v ) ; } } if ( uMax + ss >= k ) { usefulSet . add ( v ) ; } } int ret = 0 ; for ( int v : al ) { if ( v != usefulSet . contains ( v ) ) { ret ++ ; } } return ret ; }
n , s ) { int m = s / n ; if ( s % n == 0 ) { System . out . println ( m ) ; } else { System . out . println ( m + 1 ) ; } }
public static int multiply ( int [ ] v , int x ) { int carry = 0 ; int size = v . length ; for ( int i = 0 ; i < size ; i ++ ) { int res = carry + v [ i ] * x ; v [ i ] = res % 10 ; carry = res / 10 ; } while ( ( carry != 0 ) && ( carry % 10 == 0 ) ) { v [ 0 ] = carry % 10 ; carry /= 10 ; } final int findSumOfDigits = n ; v = new int [ n + 1 ] ; v [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { multiply ( v , i ) ; } int sum = 0 ; size = v . length ; for ( int i = 0 ; i < size ; i ++ ) { sum += v [ i ] ; } return sum ; }
public static void main ( String [ ] args ) { new NSpidersToSeeIn ( Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ Spiderers ▁ to ▁ see ▁ in " ) ) ) ; final int nSpidersToSeeIn = JOptionPane . showInputDialog ( " Enter ▁ the ▁ Spiderers ▁ to ▁ see ▁ in " ) ; final String [ ] field = new String [ ] { JOptionPane . showInputDialog ( " Enter ▁ the ▁ Spiderers ▁ to ▁ see ▁ in " ) } ; final int nSpidersToSeeIn = JOptionPane . showInputDialog ( " Enter ▁ the ▁ Spiderers ▁ to ▁ see ▁ in " ) ; final int iRow = 1 ; final int iCol = 1 ; int nSpiders = 0 ; int iRight = iRow - iCol , iLeft = iRow + iCol ; if ( iRight >= 0 && field [ iCol ] . charAt ( iRight ) == ' R ' ) nSpiders ++ ; if ( iLeft < field [ 0 ] . length ( ) && field [ iCol ] . charAt ( iLeft ) == ' L ' ) nSpiders ++ ; if ( ! iCol % 2 && field [ iCol ] . charAt ( iRow ) == ' U ' ) nSpiders ++ ; System . out . println ( " Spiders ▁ = ▁ " + nSpiders ) ; if ( args . length == 0 ) { System . out . println ( main ( ) ) ; } }
n , m ) public static int [ ] solve ( int [ ] input , int [ ] out ) { int [ ] comp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) comp [ i ] = i + 2 ; for ( int i = 0 ; i < m ; i ++ ) { int l = Integer . parseInt ( input [ i ] . trim ( ) . substring ( 1 ) ) ; int r = Integer . parseInt ( input [ i ] . trim ( ) . substring ( 1 ) ) ; int x = input [ i ] ; int t = l ; while ( t <= r ) { int nextVal = comp [ t - 1 ] ; if ( out [ t - 1 ] == 0 && t != x ) out [ t - 1 ] = x ; comp [ t - 1 ] = r + 1 == t ? x : x ; t = nextVal ; } } System . out . println ( new String ( out ) ) ; return out ; }
public static int [ ] findMaxs ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ input ▁ lines " ) ) ; int [ ] arr = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ lines ▁ to ▁ search " ) . trim ( ) . split ( " ▁ " ) ) . toArray ( ) ; int [ ] ans = new int [ n ] ; int mx = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { ans [ i ] = Math . max ( 0 , mx - arr [ i ] + 1 ) ; if ( arr [ i ] > mx ) mx = arr [ i ] ; } System . out . println ( new String [ ] { ans } ) ; return ans ; }
public static int pell ( int n ) { if ( ( n <= 2 ) && ( n > 0 ) ) return n ; return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) ; }
public static int n ( ) { int i = 1 , j = n * n ; while ( i < j ) { System . out . println ( i + " ▁ " + j ) ; i ++ ; j -- ; } return i ; }
public static int binarySearch ( int [ ] arr , int low , int high , int ele ) { while ( low < high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == ele ) { return mid ; } else if ( arr [ mid ] > ele ) { high = mid ; } else { low = mid + 1 ; } } return - 1 ; } public static void printSmall ( int [ ] arr , int asize , int n ) { int [ ] copyArr = arr . clone ( ) ; Arrays . sort ( copyArr ) ; for ( int i = 0 ; i < asize ; i ++ ) { if ( binarySearch ( copyArr , low , 0 , n , arr [ i ] ) > - 1 ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " linux " ) ) { arr = new int [ ] { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = arr . length ; int n = 5 ; printSmall ( arr , asize , n ) ; } }
public static int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( ( n > 0 ) && ( ( n & 1 ) == 0 ) ) { if ( ( ( n & 1 ) == 0 ) || ( ( n & 1 ) == 1 ) ) { count += Math . pow ( 2 , k ) ; } k ++ ; n >>>= 1 ; } return count ; }
public static int R ( ) { int R = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ buy ▁ and ▁ sell " ) ) ; int bestBuy = Math . min ( Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ sell ▁ and ▁ buy " ) ) ) ; int bestSellsell = Math . max ( Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ buy ▁ and ▁ sell " ) ) ) ; int numBuy = R / bestBuy ; System . out . println ( Math . max ( R , R + ( bestSellsell - bestBuy ) * numBuy ) ) ; return R ; }
from ▁ System . currentTimeMillis ( ) ▁ - ▁ 1 STRNEWLINE ▁ */ public static int main ( String [ ] args ) { int maximum = - Integer . MAX_VALUE , x = 0 , ans = Integer . MAX_VALUE ; ArrayList < Integer > graph = new ArrayList < Integer > ( 100 ) ; int [ ] weight = new int [ 100 ] ; final int node = Integer . MIN_VALUE ; final int parent = Integer . MAX_VALUE ; final int maximum = Integer . MAX_VALUE ; int a = new BigInteger ( weight [ node ] + x ) . compareTo ( new BigInteger ( "1" ) ) ; if ( maximum < a ) { maximum = a ; ans = node ; } else if ( maximum == a ) ans = Math . min ( ans , node ) ; for ( int to : graph ) { if ( to == parent ) continue ; dfs ( to , node ) ; } if ( args . length == 0 ) { x = 15 ; weight [ 1 ] = 5 ; weight [ 2 ] = 10 ; weight [ 3 ] = 11 ; weight [ 4 ] = 8 ; weight [ 5 ] = 6 ; graph [ 1 ] . add ( 2 ) ; graph [ 2 ] . add ( 3 ) ; graph [ 2 ] . add ( 4 ) ; graph [ 1 ] . add ( 5 ) ; dfs ( 1 , 1 ) ; System . out . println ( ans ) ; } return ans ; }
public static void MAX = 26 ; public static void updateFreq ( String strr , int [ ] freq ) { int lenn = strr . length ( ) ; for ( int i = 0 ; i < lenn ; i ++ ) freq [ ( char ) strr . charAt ( i ) - ' a ' ] ++ ; }
public static int n ( ) { int a = Integer . parseInt ( input ( ) ) ; int b = Integer . parseInt ( input ( ) ) ; System . out . println ( a + b ) ; }
n , L , R , QL , QR ; int [ ] W = Arrays . copyOf ( input . split ( " ▁ " ) , n + 1 ) ; int [ ] sumEl = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) sumEl [ i ] = W [ i - 1 ] + sumEl [ i - 1 ] ; int answer = QR * ( n - 1 ) + sumEl [ n ] * R ; for ( int i = 1 ; i <= n ; i ++ ) { int energy = L * sumEl [ i ] + R * ( sumEl [ n ] - sumEl [ i ] ) ; if ( i > ( n - i ) ) energy = energy + ( i - ( n - i ) - 1 ) * QL ; else if ( ( n - i ) > i ) energy = energy + ( ( n - i ) - i - 1 ) * QR ; if ( energy < answer ) answer = energy ; } System . out . println ( answer ) ; }
public static int wastedWater ( int V , int M , int N ) { int amtPerMin = M - N ; int timeToFill = V / amtPerMin ; int wastedAmt = N * timeToFill ; return wastedAmt ; }
public static int maxSubStr ( String str , int n ) { int count0 = 0 ; int count1 = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) count0 ++ ; else count1 ++ ; if ( count0 == count1 ) cnt ++ ; } if ( count0 != count1 ) return - 1 ; return cnt ; }
a , b , c ; }
public static int findS ( int s ) { int _sum = 0 ; int n = 1 ; while ( ( _sum < s ) && ( _sum < s ) ) { _sum += n ; n ++ ; } n -- ; if ( _sum == s ) return n ; return - 1 ; s = 15 ; n = findS ( s ) ; if ( n == - 1 ) System . out . println ( " - 1" ) ; else System . out . println ( n ) ; }
public static int maximumAbsolute ( int [ ] arr , int n ) { int mn = 10 * 9 ; int mx = - 10 * 9 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i > 0 && arr [ i ] == - 1 && arr [ i - 1 ] != - 1 ) || ( i < n - 1 && arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) ) { mn = Math . min ( mn , arr [ i - 1 ] ) ; mx = Math . max ( mx , arr [ i - 1 ] ) ; } if ( ( i < n - 1 && arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) || ( i < n - 1 && arr [ i + 1 ] == - 1 && arr [ i + 1 ] != - 1 ) ) { mn = Math . min ( mn , arr [ i + 1 ] ) ; mx = Math . max ( mx , arr [ i + 1 ] ) ; } } int commonInteger = ( mn + mx ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] == - 1 ) && ( arr [ i + 1 ] == - 1 ) ) { arr [ i ] = commonInteger ; } } int maxDiff = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; if ( ( diff > maxDiff ) || ( diff < 0 ) ) { maxDiff = diff ; } } return maxDiff ; }
public static int countStrings ( int N ) { int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; dp [ 1 ] [ 0 ] = 1 ; ; dp [ 1 ] [ 1 ] = 1 ; ; dp [ 1 ] [ 2 ] = 0 ; ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } int ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
public static int longestSubseq ( int n , int k , String s ) { int [ ] dp = new int [ n ] ; int [ ] maxLength = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int curr = Character . digit ( s . charAt ( i ) , 10 ) - Character . digit ( s . charAt ( i ) , 10 ) ; int lower = Math . max ( 0 , curr - k ) ; int upper = Math . min ( 25 , curr + k ) ; for ( int j = lower ; j <= upper ; j ++ ) { dp [ i ] = Math . max ( dp [ i ] , maxLength [ j ] + 1 ) ; } maxLength [ curr ] = Math . max ( dp [ i ] , maxLength [ curr ] ) ; } return Math . max ( dp [ 0 ] , maxLength [ 0 ] ) ; }
public static int longestFibonacciSubarray ( int n , int [ ] a ) { if ( ( n <= 2 ) && ( a [ 0 ] == a [ 1 ] + a [ 2 ] ) ) return n ; int Len = 2 ; int mx = - 10 * 9 ; for ( int i = 2 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) && ( a [ i ] == a [ i - 2 ] + a [ i - 1 ] ) ) Len ++ ; else Len = 2 ; mx = Math . max ( mx , Len ) ; } return mx ; }
public static int minimumSubarrays ( int [ ] ar , int n ) { List < Integer > se = new ArrayList < Integer > ( ) ; int cnt = 1 ; ; for ( int i = 0 ; i < n ; i ++ ) { if ( se . contains ( ar [ i ] ) == false ) { se . add ( ar [ i ] ) ; } else { cnt ++ ; se . clear ( ) ; se . add ( ar [ i ] ) ; } } return cnt ; }
public static boolean check ( int s ) { int [ ] freq = new int [ 10 ] ; while ( ( s != 0 ) && ( freq [ s ] != 0 ) ) { int r = s % 10 ; s = s / 10 ; freq [ r ] ++ ; } int xor = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { xor = xor ^ freq [ i ] ; } if ( ( xor == 0 ) && ( freq [ s ] != 0 ) ) { return true ; } else { return false ; } }
_ , ▁ a ▁ = ▁ 1 STRNEWLINE ▁ */ private static int [ ] [ ] getDaysFor ( int a ) { int [ ] [ ] days = map ( Integer . parseInt ( input ( ) . nextLine ( ) ) ) ; int names = 0 ; int lists = 0 ; for ( int i : days ) { names += i ; System . out . print ( names / a - lists + " , ▁ " ) ; lists += names / a - lists ; } return days ; }
public static final void main ( String [ ] args ) { int MAXN = 1000005 ; int even [ ] = new int [ MAXN ] ; int odd [ ] = new int [ MAXN ] ; final int precompute [ ] = new int [ MAXN ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 == 1 ) && ( arr [ i ] % 2 == 0 ) ) odd [ i ] = 1 ; ; if ( ( arr [ i ] % 2 == 0 ) && ( arr [ i ] % 2 == 1 ) ) even [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { even [ i ] = even [ i ] + even [ i - 1 ] ; ; odd [ i ] = odd [ i ] + odd [ i - 1 ] ; ; } final int L = odd [ R ] ; final int R = odd [ R ] ; final int cnt = odd [ R ] ; if ( ( L > 0 ) && ( cnt > odd [ L - 1 ] ) ) cnt -= odd [ L - 1 ] ; if ( ( cnt == R - L + 1 ) && ( cnt > 0 ) ) System . out . println ( " Odd " ) ; else System . out . println ( " Even " ) ; }
public static int tests ( ) { int tests = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ windows ▁ to ▁ test " ) ) ; for ( ; ; ) { int windows = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ windows ▁ to ▁ test " ) ) ; boolean test = true ; for ( int k = 0 ; k < ( windows / 3 + 1 ) ; k ++ ) { if ( test ) { for ( int j = 0 ; j < ( windows / 5 + 1 ) ; j ++ ) { if ( test ) { for ( int i = 0 ; i < ( windows / 7 + 1 ) ; i ++ ) { if ( i * 7 + j * 5 + k * 3 == windows ) { System . out . println ( k + " ▁ " + j + " ▁ " + i ) ; test = false ; break ; } } } } } } if ( test ) { System . out . println ( - 1 ) ; } } }
public static int solve ( int m , int n , int o , int p , String hhmm ) { int h = Integer . parseInt ( hhmm . charAt ( 0 ) + hhmm . charAt ( 1 ) ) ; int m = Integer . parseInt ( hhmm . charAt ( 3 ) + hhmm . charAt ( 4 ) ) ; int lft = h * 60 + m ; int rt = lft + n ; int i = 30 * 10 ; int ans = 0 ; while ( i < 1440 ) { if ( i < rt && i + p > lft ) ans ++ ; i += o ; } return ans ; }
i = input ; int l = 3 ; for ( ; i > 0 ; i -- ) { int x = ( int ) i ( ) ; if ( x == l ) System . out . println ( " NO " ) ; ; exit ( ) ; l ^= x ; } System . out . println ( " YES " ) ; }
public static int times ( int [ ] steps , int n ) { int currentLevel = 0 ; int previousLevel = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previousLevel = currentLevel ; currentLevel = currentLevel + steps [ i ] ; if ( ( ( previousLevel < 0 && currentLevel >= 0 ) || ( previousLevel > 0 && currentLevel <= 0 ) ) && ( i == 0 ) ) { count ++ ; } } return count ; steps = new int [ ] { 1 , - 1 , 0 , 0 , 1 , 1 , - 3 , 2 } ; n = steps . length ; System . out . println ( times ( steps , n ) ) ; }
public static int D = 360 ; int [ ] x = new int [ D ] ; int n = Integer . parseInt ( input . nextLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int m = Integer . parseInt ( input . nextLine ( ) ) , d = Integer . parseInt ( input . nextLine ( ) ) , v = Integer . parseInt ( input . nextLine ( ) ) , s = Integer . parseInt ( input . nextLine ( ) ) ; m -- ; d -- ; int start = 30 * m + d ; int end = ( start + v - 1 ) % D ; boolean [ ] h = new boolean [ D ] ; for ( int j = 0 ; j < v ; j ++ ) { int y = ( start + j ) % D ; h [ y ] = true ; } for ( int j = 0 ; j < D ; j ++ ) { if ( h [ j ] ) { x [ j ] = Math . max ( x [ j ] , s ) ; } else { int A = Math . abs ( start - j ) ; if ( A > D / 2 ) A = D - A ; int B = Math . abs ( end - j ) ; if ( B > D / 2 ) B = D - B ; x [ j ] = Math . max ( x [ j ] , s - Math . min ( A , B ) ) ; } } } System . out . println ( Math . min ( x . length , D ) ) ; return x . length ; }
public static void print ( String ( String [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] ) { System . out . println ( ( " Um _ nik " ) . charAt ( Integer . parseInt ( input ) ) / 1000 <= Integer . parseInt ( input ) ) ; }
public static String smallest ( String s ) { int l = s . length ( ) ; String ans = " " ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( s . charAt ( i ) > s . charAt ( i + 1 ) ) && ( s . charAt ( i + 1 ) != ' \0' ) ) { for ( int j = 0 ; j < l ; j ++ ) { if ( ( i != j ) && ( s . charAt ( j ) != ' \0' ) ) { ans += s . charAt ( j ) ; } } return ans ; } } ans = s . substring ( 0 , l - 1 ) ; return ans ; }
x , y = map . get ( x ) ; y = map . get ( y ) ; int [ ] gr1 = { 2 } ; int [ ] gr2 = { 4 , 6 , 9 , 11 } ; if ( x == gr1 [ 0 ] ) { int xGR = 1 ; } else if ( x == gr2 [ 0 ] ) { int xGR = 2 ; } else { xGR = 3 ; } if ( y == gr1 [ 0 ] ) { int yGR = 1 ; } else if ( y == gr2 [ 0 ] ) { int yGR = 2 ; } else { yGR = 3 ; } if ( xGR == yGR ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
public static int FindMinNumber ( int [ ] arr , int n , int k ) { int i = 0 ; int j = 0 ; int minNum = 10 * 9 ; boolean found = false ; int Sum = 0 ; while ( ( i < n ) && ( i < arr . length ) ) { Sum = Sum + arr [ i ] ; if ( ( Sum == k ) || ( Sum == k ) ) { minNum = Math . min ( minNum , ( ( n - ( i + 1 ) ) + j ) ) ; found = true ; } else if ( ( Sum > k ) && ( Sum > k ) ) { while ( ( Sum > k ) && ( Sum > k ) ) { Sum = Sum - arr [ j ] ; j ++ ; } if ( ( Sum == k ) || ( Sum == k ) ) { minNum = Math . min ( minNum , ( ( n - ( i + 1 ) ) + j ) ) ; found = true ; } } i ++ ; } if ( ( found ) && ( minNum > k ) ) return minNum ; return - 1 ; }
n ; int b = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( n [ i ] . equals ( "1" ) ) b ++ ; } System . out . println ( b ) ; }
public static void nthPalindrome ( int n , int k ) { if ( ( k & 1 ) != 0 ) { int temp = k / 2 ; if ( temp > 0 ) { int palindrome = 10 * temp ; palindrome = palindrome + n - 1 ; System . out . print ( palindrome + " ▁ " ) ; if ( ( k & 1 ) != 0 ) { palindrome = palindrome / 10 ; } while ( ( palindrome > 0 ) && ( palindrome < 10 ) ) { System . out . print ( palindrome % 10 + " ▁ " ) ; palindrome = palindrome / 10 ; } } } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " win " ) ) { n = 6 ; k = 5 ; System . out . print ( String . valueOf ( n ) + " th ▁ palindrome ▁ of ▁ " + String . valueOf ( k ) + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; System . out . println ( ) ; n = 10 ; k = 6 ; System . out . print ( String . valueOf ( n ) + " th ▁ palindrome ▁ of ▁ " + String . valueOf ( k ) + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; System . out . println ( ) ; } }
static int [ ] array ( int N , int X ) { int [ ] Xs = Arrays . copyOf ( input , N ) ; int [ ] Ys = Xs . clone ( ) ; int [ ] Y_sum = new int [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) Y_sum [ i ] = Y [ i - 1 ] + Ys [ i ] ; int ans = 1e100 ; for ( int rep_num = 1 ; rep_num <= N ; rep_num ++ ) { int local_ans = X * rep_num ; local_ans += 5 * Y_sum [ rep_num - 1 ] ; int i = 2 * rep_num - 1 ; int n = 1 ; while ( i <= N - 1 ) { local_ans += ( 2 * n + 3 ) * ( Y_sum [ i ] - Y_sum [ i - rep_num ] ) ; n ++ ; i += rep_num ; } local_ans += ( 2 * n + 3 ) * ( Y_sum [ N - 1 ] - Y_sum [ i - rep_num ] ) ; ans = Math . min ( ans , local_ans ) ; } System . out . println ( ans + N * X ) ; return Xs ; }
public static int MAX = 10000 ; int [ ] hashTable = new int [ MAX ] ; int minOperations ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { hashTable [ arr [ i ] ] ++ ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( hashTable [ arr [ i ] ] ) != 0 ) { for ( int j = i ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( arr [ j ] % arr [ i ] == 0 ) ) { hashTable [ arr [ j ] ] = 0 ; } } res ++ ; } } return res ; }
p1 , p2 , p3 , p4 , a , b = map . get ( input ) ; if ( min ( p1 , p2 , p3 , p4 ) > a && min ( p1 , p2 , p3 , p4 ) <= b ) { System . out . print ( min ( p1 , p2 , p3 , p4 ) - a ) ; } else if ( min ( p1 , p2 , p3 , p4 ) > b && min ( p1 , p2 , p3 , p4 ) > a && a != b ) { System . out . print ( b - a + 1 ) ; } else if ( a == b && min ( p1 , p2 , p3 , p4 ) > a ) { System . out . print ( min ( p1 , p2 , p3 , p4 ) - a ) ; } else { System . out . print ( 0 ) ; } }
static final public String compute ( ) { long numer = 1 ; long denom = 1 ; for ( int d = 10 ; d < 100 ; d ++ ) { for ( long n = 10 ; n < d ; n ++ ) { long n0 = n % 10 ; long n1 = n / 10 ; long d0 = d % 10 ; long d1 = d / 10 ; if ( ( n1 == d0 && n0 * d == n * d1 ) || ( n0 == d1 && n1 * d == n * d0 ) ) { numer *= n ; denom *= d ; } } } return Long . toString ( denom / fractions . gcd ( numer , denom ) ) ; if ( System . getSecurityManager ( ) == null ) { System . out . println ( compute ( ) ) ; } return Long . toString ( denom / fractions . gcd ( numer , denom ) ) ; }
public static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>>= 1 ; } return count ; }
for ( ; ; ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; int b = Integer . parseInt ( input . nextLine ( ) ) ; int x = Integer . parseInt ( input . nextLine ( ) ) ; int y = Integer . parseInt ( input . nextLine ( ) ) ; }
public static int minSwaps ( int [ ] arr ) { int n = arr . length ; int [ ] arrpos = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arrpos [ i ] = i ; Arrays . sort ( arr , new Comparator < Integer > ( ) { public int compare ( Integer it ) { return it . intValue ( ) ; } } ) ; boolean [ ] vis = new boolean [ n ] ; for ( int k = 0 ; k < n ; k ++ ) { vis [ k ] = false ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrpos [ i ] == i ) continue ; int cycleSize = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrpos [ j ] ; cycleSize ++ ; } if ( cycleSize > 0 ) ans += ( cycleSize - 1 ) ; } return ans ; }
public static int N = 1000005 ; boolean prime [ ] = new boolean [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int i = 2 ; i < N ; i ++ ) { if ( ( prime [ i ] == true ) && ( prime [ i ] == false ) ) { for ( int j = i * 2 ; j < N ; j += i ) { prime [ j ] = false ; } } } } static void sumTruncatablePrimes ( int n ) { int sum = 0 ; for ( int i = 2 ; i < n ; i ++ ) { int num = i ; boolean flag = true ; while ( ( num ) ) { if ( ( prime [ num ] == false ) && ( prime [ num % 10 ] == false ) ) { flag = false ; break ; } num /= 10 ; } num = i ; int power = 10 ; while ( ( num / power ) != 0 ) { if ( ( prime [ num % power ] == false ) && ( prime [ num % 10 ] == true ) ) { flag = false ; break ; } power *= 10 ; } if ( ( flag == true ) && ( prime [ num % 10 ] == false ) ) { sum += i ; } } } int n = 25 ; sieve ( n ) ; System . out . println ( sumTruncatablePrimes ( n ) ) ; }
public static void findWeights ( int X ) { int sum = 0 ; int power = 0 ; while ( ( sum < X ) && ( sum < X ) ) { sum = Math . pow ( 3 , power + 1 ) - 1 ; sum /= 2 ; power ++ ; } int ans = 1 ; for ( int i = 1 ; i <= power ; i ++ ) { System . out . print ( ans + " ▁ " ) ; ans = ans * 3 ; } X = 2 ; findWeights ( X ) ; }
public static int [ ] addToArrayForm ( int [ ] A , int K ) { int [ ] v = new int [ A . length ] , ans = new int [ A . length ] ; int rem = 0 , i ; for ( i = A . length - 1 ; i >= 0 ; i -- ) { int my = A [ i ] + ( K % 10 ) + rem ; if ( my > 9 ) { rem = 1 ; v [ i ] = my % 10 ; } else { v [ i ] = my ; rem = 0 ; } K = K / 10 ; } while ( K > 0 ) { my = ( K % 10 ) + rem ; v [ i ] = my % 10 ; if ( my / 10 > 0 ) rem = 1 ; else rem = 0 ; K = K / 10 ; } if ( rem > 0 ) v [ i ] = rem ; for ( i = v . length - 1 ; i >= 0 ; i -- ) ans [ i ] = v [ i ] ; return ans ; }
public static void printPaths ( char [ ] [ ] inputchar , int R , int C ) { for ( int i = 0 ; i < C ; i ++ ) { dfs ( inputchar , " " , 0 , i , R , C ) ; ; System . out . println ( ) ; } final int i = R ; final int j = C ; if ( ( i == R ) && ( j == C ) ) { System . out . print ( res + " ▁ " ) ; ; return ; } res = res + inputchar [ i ] [ j ] ; ; for ( int k = 0 ; k < C ; k ++ ) { dfs ( inputchar , res , i + 1 , k , R , C ) ; ; if ( ( i + 1 == R ) && ( j == C ) ) break ; } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " win " ) ) { inputchar [ ] [ ] = new char [ ] [ ] { { ' a ' , ' b ' } , { ' d ' , ' e ' } } ; R = inputchar . length ; C = inputchar [ 0 ] . length ; printPaths ( inputchar , R , C ) ; } }
public static void assignRoom ( String direction , String hotel ) { if ( direction . equals ( " L " ) ) { for ( int x = 0 ; x < 10 ; x ++ ) { if ( hotel . charAt ( x ) == 0 ) { hotel . append ( "1" ) ; return ; } } } else if ( direction . equals ( " R " ) ) { for ( int x = 9 ; x >= 0 ; x -- ) { if ( hotel . charAt ( x ) == 0 ) { hotel . append ( "1" ) ; return ; } } } else { hotel . charAt ( Integer . parseInt ( direction ) ) = 0 ; return ; } int [ ] rooms = new int [ 10 ] ; int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ room ▁ number : ▁ " ) ) ; String [ ] instructions = JOptionPane . showInputDialog ( " Enter ▁ a ▁ room ▁ instructions : ▁ " ) ; for ( int x = 0 ; x < instructions . length ; x ++ ) { assignRoom ( instructions [ x ] , rooms ) ; } for ( int x : rooms ) { JOptionPane . showMessageDialog ( null , instructions [ x ] , JOptionPane . INFORMATION_MESSAGE ) ; } }
public static void main ( String [ ] args ) { for ( ; ; ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ ( 0-9 ) " ) ) , b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ b ▁ number ▁ ( 0-9 ) " ) ) ; int a1 = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a1 ▁ number ▁ ( 0-9 ) " ) ) , b1 = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ b1 ▁ number ▁ ( 0-9 ) " ) ) ; if ( Math . max ( a , b ) == Math . max ( a1 , b1 ) ) { if ( Math . min ( a , b ) + Math . min ( a1 , b1 ) == Math . max ( a , b ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } else System . out . println ( " NO " ) ; } }
public static void precisionCompute ( int x , int y , int n ) { if ( y == 0 ) { System . out . println ( " Infinite " ) ; ; return ; } if ( x == 0 ) { System . out . println ( 0 ) ; ; return ; } if ( n <= 0 ) { System . out . println ( x / y ) ; ; return ; } if ( ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) ) { System . out . print ( " - " ) ; ; if ( x <= 0 ) x = - x ; ; if ( y <= 0 ) y = - y ; ; } int d = x / y ; for ( int i = 0 ; ; i ++ ) { System . out . print ( d ) ; ; x = x - ( y * d ) ; ; if ( x == 0 ) break ; x = x * 10 ; ; d = x / y ; ; if ( ( i == 0 ) && ( y > 0 ) ) { System . out . print ( " . " ) ; ; } } x = 22 ; y = 7 ; n = 15 ; precisionCompute ( x , y , n ) ; }
public static int gcd ( int a , int b ) { if ( ( b == 0 ) || ( b == 1 ) ) return a ; else return gcd ( b , a % b ) ; } public static final int lcmOfArray ( int [ ] arr , int n ) { if ( ( n < 1 ) || ( n == 0 ) ) return 0 ; int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; ; } return lcm ; } public static int minPerfectCube ( int [ ] arr , int n ) { int lcm = lcmOfArray ( arr , n ) ; int minPerfectCube = lcm ; int cnt = 0 ; while ( ( lcm > 1 ) && ( lcm % 2 == 0 ) ) { cnt ++ ; lcm /= 2 ; } if ( ( cnt % 3 == 2 ) && ( cnt % 3 == 1 ) ) { minPerfectCube *= 2 ; } else if ( ( cnt % 3 == 1 ) && ( cnt % 3 == 0 ) ) { minPerfectCube *= 4 ; } int i = 3 ; while ( ( lcm > 1 ) && ( lcm % i == 0 ) ) { cnt = 0 ; while ( ( lcm % i == 0 ) && ( cnt % i == 0 ) ) { cnt ++ ; lcm /= i ; } if ( ( cnt % 3 == 1 ) && ( cnt % i == 0 ) ) { minPerfectCube *= i * i ; } else if ( ( cnt % 3 == 2 ) && ( cnt % i == 0 ) ) { minPerfectCube *= i ; } i += 2 ; } return minPerfectCube ; } }
class Node { Stack < Node > s ; Stack < Node > q ; int elements ; public Node ( int key ) { data = key ; left = null ; right = null ; } public void printSpecificLevelOrder ( Node root ) { s . push ( root ) ; Node prnt = s . pop ( ) ; q . push ( prnt . data ) ; if ( prnt . right != null ) s . push ( root . right ) ; if ( prnt . left != null ) s . push ( root . left ) ; while ( ( elements = s . pop ( ) ) > 0 ) { Node first = s . pop ( ) ; q . push ( first . data ) ; Node second = s . pop ( ) ; q . push ( second . data ) ; if ( first . left != null && second . right != null && first . right != null && second . left != null ) { s . push ( first . left ) ; s . push ( second . right ) ; s . push ( first . right ) ; s . push ( second . left ) ; } } for ( elements = Collections . nCopies ( q . size ( ) , 0 ) ; elements -- > 0 ; ) System . out . print ( elements + " ▁ " ) ; } }
public static void hollowSquare ( int rows ) { for ( int i = 1 ; i <= rows ; i ++ ) { if ( ( i == 1 || i == rows ) && ( i == 1 || i == rows ) ) { for ( int j = 1 ; j <= rows ; j ++ ) { System . out . print ( " * " ) ; } } else { for ( int j = 1 ; j <= rows ; j ++ ) { if ( ( j == 1 || j == rows ) && ( j == 1 || j == rows ) ) { System . out . print ( " * " ) ; } else { System . out . print ( " ▁ " ) ; } } } System . out . println ( ) ; } final int solidSquare = 1 ; for ( int i = 1 ; i <= rows ; i ++ ) { for ( int j = 1 ; j <= rows ; j ++ ) { System . out . print ( " * " ) ; } System . out . println ( ) ; } final int printPattern = 1 ; for ( int i = 1 ; i <= rows ; i ++ ) { System . out . print ( " Solid ▁ Square : " ) ; solidSquare ++ ; System . out . print ( " \n Hollow ▁ Square : " ) ; hollowSquare ( rows ) ; } rows = 5 ; printPattern ( rows ) ; }
public static < T > void main ( String [ ] args ) { final List < T > list = new ArrayList < > ( ) ; list . add ( new T ( 1 ) ) ; list . add ( new T ( 2 ) ) ; list . add ( new T ( 3 ) ) ; }
static final Comparator < Integer > COMPARATOR = new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return Integer . compare ( o1 , o2 ) ; } private int [ ] getValues ( Integer o1 ) { return ArrayUtils . toPrimitive ( o1 ) . length ; } private int [ ] getInlsts ( Integer o1 ) { return new int [ ] { Integer . MAX_VALUE } ; } private int [ ] inp ( Integer o1 ) { return Integer . MAX_VALUE ; } private int [ ] instr ( Integer o1 ) { return o1 . toString ( ) . length ( ) ; } private int [ ] words ( Integer o1 ) { return o1 . toString ( ) . length ( ) ; } private int [ ] chars ( Integer o1 ) { return o1 . toString ( ) . length ( ) ; } private int [ ] solve ( ) { int n = inp ( o1 ) ; int [ ] t = new int [ n ] ; int [ ] w = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = getValues ( o1 ) ; int b = getValues ( o1 + 1 ) ; t [ i ] = a ; w [ i ] = b ; } int sm = Arrays . binarySearch ( t , t ) ; int cnt = Arrays . binarySearch ( w , w ) ; int [ ] dp = new int [ sm + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = sm ; j > t [ i ] - 1 ; j -- ) { dp [ j ] = Math . max ( dp [ j ] , dp [ j - t [ i ] ] + w [ i ] ) ; } } for ( int i = 1 ; i < dp . length ; i ++ ) { int rem = cnt - dp [ i ] ; if ( dp [ i ] > 0 && rem <= i ) { System . out . println ( i ) ; ; break ; } } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " % d ▁ " , rem ) ; } return dp ; } }
public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int a = Integer . parseInt ( input . nextLine ( ) ) , b = Integer . parseInt ( input . nextLine ( ) ) , x = input . nextInt ( ) ; if ( a <= x && x <= a + b ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
public static final int findLargest ( int [ ] arr , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { gcd = gcd ( arr [ i ] , gcd ) ; } return gcd ; }
public static void findWinner ( int n ) { if ( ( ( n - 1 ) % 6 == 0 ) && ( n > 0 ) ) { System . out . println ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) ; ; } else { System . out . println ( " First ▁ Player ▁ wins ▁ the ▁ game " ) ; ; } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " win " ) ) { n = 7 ; ; findWinner ( n ) ; } }
public static final < T > void main ( String [ ] args ) { final HashMap < String , List < T > > graph = new HashMap < > ( ) ; graph . put ( " " , new ArrayList < > ( ) ) ; graph . put ( " " , new ArrayList < > ( ) ) ; graph . put ( " " , new ArrayList < > ( ) ) ; graph . put ( " " , new ArrayList < > ( ) ) ; graph . put ( " " , new ArrayList < > ( ) ) ; graph . put ( " " , new ArrayList < > ( ) ) ; }
public static final < T > void main ( String [ ] args ) { final HashMap < String , List < T > > graph = new HashMap < > ( ) ; graph . put ( " " , new ArrayList < > ( ) ) ; graph . put ( " " , new ArrayList < > ( ) ) ; graph . put ( " " , new ArrayList < > ( ) ) ; graph . put ( " " , new ArrayList < > ( ) ) ; graph . put ( " " , new ArrayList < > ( ) ) ; graph . put ( " " , new ArrayList < > ( ) ) ; }
public static void getElements ( int a , int [ ] arr , int n ) { int [ ] elements = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) elements [ i ] = 1 ; elements [ 0 ] = a ; for ( int i = 1 ; i < n ; i ++ ) elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) System . out . print ( elements [ i ] + " ▁ " ) ; arr = new int [ n + 1 ] ; arr [ 13 ] = 2 ; arr [ 6 ] = 1 ; n = arr . length ; a = 5 ; getElements ( a , arr , n ) ; }
public static String [ ] solve ( int R , int P , int S ) { Scanner sc = new Scanner ( System . in ) ; java . util . List < String > res = new ArrayList < String > ( ) ; if ( ( R < 0 || P < 0 || S < 0 ) && ( R + P + S == 1 ) ) { return " IMPOSSIBLE " ; } if ( R + P + S == 1 ) { return R > 0 ? " R " : R > 0 ? " P " : P > 0 ? " S " : R > 0 ? " S " : R > 0 ? " R " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " : R > 0 ? " S " :
I ; int n = Integer . parseInt ( I . nextLine ( ) ) ; int m = Integer . parseInt ( I . nextLine ( ) ) ; int [ ] b = new int [ n * 2 ] ; b [ 0 ] = b [ n - 1 ] = b [ n ] = b [ 2 * n - 1 ] = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int r = Integer . parseInt ( I . nextLine ( ) ) ; int c = Integer . parseInt ( I . nextLine ( ) ) ; b [ r - 1 ] = b [ n + c - 1 ] = 0 ; } if ( n % 2 > 0 && b [ n / 2 ] > 0 && b [ n + n / 2 ] > 0 ) { b [ n / 2 ] = 0 ; } System . out . println ( Arrays . toString ( b ) ) ; }
static final void printRepeating ( int [ ] arr , int size ) { int S = 0 ; ; int P = 1 ; int n = size - 2 ; for ( int i = 0 ; i <= size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; int D = Math . sqrt ( S * S - 4 * P ) ; int x = ( D + S ) / 2 ; int y = ( S - D ) / 2 ; System . out . println ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : " + ( int ) ( x ) + " & " + ( int ) ( y ) ) ; }
public static int main ( String [ ] args ) { int [ ] primes = new int [ 10001 ] ; for ( int p = 2 ; p <= 10001 ; p ++ ) { for ( int m = 2 ; m <= Math . floor ( Math . sqrt ( p ) ) ; m ++ ) { if ( p % m == 0 ) { break ; } } else { primes [ p ] = p ; } } int targ = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ prime ▁ number ▁ to ▁ solve " ) ) ; while ( targ != 0 ) { int ans = 0 ; for ( int p = 0 ; p < primes . length ; p ++ ) { if ( primes [ p ] > targ ) { break ; } int tempsum = 0 ; for ( int l = p ; l < primes . length ; l ++ ) { tempsum += primes [ l ] ; if ( tempsum > targ ) { break ; } else if ( tempsum == targ ) { ans ++ ; break ; } } } System . out . println ( ans ) ; targ = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ prime ▁ number ▁ to ▁ solve " ) ) ; } return ans ; }
public static final double atan2 ( double x , double y ) { int N = Integer . MAX_VALUE , * XY = new int [ N ] ; XY = Arrays . copyOf ( XY , N ) ; for ( int i = 0 , j = N - 1 ; i < N ; i ++ , j -- ) { double [ ] D = Arrays . copyOf ( XY , N ) ; D [ j ] = Math . atan2 ( X - x , Y - y ) ; } D [ N - 1 ] = D [ 0 ] + 2 * Math . PI ; double ans = 0 ; for ( double a : D ) { if ( b - a >= Math . PI ) ans = ( b - a ) - Math . PI ; } System . out . println ( ans / ( 2 * Math . PI ) ) ; return ans ; }
alp = new String [ ] { " * * * * * * * * * * * * " , " * qwertyuiop * " , " * asdfghjkl * * " , " * zxcvbnm * * * * " , " * * * * * * * * * * * * " } ; _alp = " " ; private static void check ( String now , String nxt ) { int a = now . indexOf ( now ) / 12 , b = now . indexOf ( now ) % 12 ; int c = now . indexOf ( nxt ) / 12 , d = now . indexOf ( nxt ) % 12 ; String q1 = _log . length - 1 ; String q2 = d <= 5 ? " L " : " R " ; _log . append ( q2 ) ; if ( Math . abs ( a - c ) + Math . abs ( b - d ) <= 1 ) _log . append ( q1 ) ; else _log . append ( q2 ) ; } while ( 1 ) { String s = JOptionPane . showInputDialog ( null , " Enter ▁ the ▁ answer : " ) ; if ( s . equals ( " # " ) ) break ; _log = new String [ ] { " L " , " R " } ; _log = new String [ s . length ( ) - 1 ] ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) check ( s . charAt ( i ) , s . charAt ( i + 1 ) ) ; int count = 0 ; for ( int i = 0 ; i < log . length ( ) ; i ++ ) if ( log . charAt ( i ) != log . charAt ( i + 1 ) ) count ++ ; c = log . charAt ( 0 ) ; int ans = 0 ; for ( int i = 0 ; i < log . length ( ) ; i ++ ) if ( log . charAt ( i ) != log . charAt ( i + 1 ) ) { c = log . charAt ( i ) ; ans ++ ; } System . out . println ( ans ) ; } }
length , tour = input . nextLine ( ) ) { System . out . println ( " YES " . equals ( tour . count ( " SF " ) ) ? " YES " : " NO " ) ; }
public static int [ ] bigres ( ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ bigressed . " ) ) ; for ( int m = 0 ; m < t ; m ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ bigressed . " ) ) ; int [ ] a = Arrays . copyOf ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ bigressed . " ) . trim ( ) . split ( " ▁ " ) , n ) ; int res = a [ 0 ] * a [ 1 ] ; for ( int q = 0 ; q < a . length - 1 ; q ++ ) res = Math . max ( res , ( a [ q ] * a [ q + 1 ] ) ) ; bigres += new int [ n ] ; } for ( int i = 0 ; i < bigres . length ; i ++ ) System . out . println ( bigres [ i ] ) ; return bigres ; }
protected static int gcd ( int x , int y ) { if ( x > y ) { int small = y ; if ( small > x ) { small = x ; } for ( int i = 1 ; i <= small ; i ++ ) { if ( ( ( x % i == 0 ) && ( y % i == 0 ) ) || ( ( x % i == 0 ) && ( y % i == 0 ) ) ) { gcd = i ; } } return gcd ; } final int FindLCM ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; ; } final int rangeDivisor ( int m , int n , int a , int b ) { int lcm = FindLCM ( a , b ) ; int aDivisor = ( int ) ( n / a - ( m - 1 ) / a ) ; int bDivisor = ( int ) ( n / b - ( m - 1 ) / b ) ; int commonDivisor = ( int ) ( n / lcm - ( m - 1 ) / lcm ) ; int ans = aDivisor + bDivisor - commonDivisor ; return ans ; } }
s ; String t = " , . ? ! " ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { s = s . replace ( t . charAt ( i ) , t . charAt ( i + 1 ) ) ; } s = " ▁ " + s . trim ( ) . replaceAll ( " ▁ " , " " ) ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { s = s . replace ( " ▁ " + t . charAt ( i ) , t . charAt ( i + 1 ) ) ; } System . out . println ( s ) ; }
public static final int smallestKFreq ( int [ ] arr , int n , int k ) { TreeMap < Integer , Integer > mp = new TreeMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp . put ( arr [ i ] , i ) ; int res = Integer . MAX_VALUE ; int res1 = Integer . MAX_VALUE ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( entry . getValue ( ) == k ) res = Math . min ( res , entry . getKey ( ) ) ; } return res == res1 ? - 1 : res ; }
public static boolean areVowelsInOrder ( String s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == ' a ' || s . charAt ( i ) == ' e ' || s . charAt ( i ) == ' i ' || s . charAt ( i ) == ' o ' || s . charAt ( i ) == ' u ' ) && ( s . charAt ( i ) < c ) ) { if ( s . charAt ( i ) < c ) { return false ; } else { c = s . charAt ( i ) ; } } } return true ; } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " linux " ) ) { s = " aabbbddeecc " ; if ( areVowelsInOrder ( s ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
INF = 10 * 20 ; final int MAX_INT = 10 * 6 ; int [ ] a = { INF } ; int [ ] b = { INF } ; a [ 0 ] = 0 , b [ 0 ] = 0 ; for ( int i = 1 ; i < 200 ; i ++ ) { int t = i * ( i + 1 ) * ( i + 2 ) / 6 ; int mm = Math . min ( t * 5 , MAX_INT ) ; for ( int j = t ; j < mm ; j ++ ) { if ( a [ j ] > a [ j - t ] + 1 ) a [ j ] = a [ j - t ] + 1 ; } if ( t % 2 == 0 ) continue ; for ( int j = t ; j < MAX_INT ; j ++ ) { if ( b [ j ] > b [ j - t ] + 1 ) b [ j ] = b [ j - t ] + 1 ; } } while ( true ) { int N = Integer . parseInt ( System . in . readLine ( ) ) ; if ( N == 0 ) exit ( ) ; System . out . println ( a [ N ] + " ▁ " + b [ N ] ) ; } }
public static int countOfLetters ( String string ) { int letter = 0 ; ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( ( ( string . charAt ( i ) >= ' A ' && string . charAt ( i ) <= ' Z ' ) || ( string . charAt ( i ) >= ' a ' && string . charAt ( i ) <= ' z ' ) ) && ( ( string . charAt ( i ) >= '0' && string . charAt ( i ) <= '9' ) || ( string . charAt ( i ) >= ' A ' && string . charAt ( i ) <= ' Z ' ) ) ) letter ++ ; ; } ; return letter ; }
public static List < Integer > lis ( ) { List < Integer > lis = new ArrayList < Integer > ( ) ; int cnt = 0 ; while ( true ) { try { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number : ▁ " ) ) ; if ( n > 0 ) { cnt ++ ; lis . add ( n ) ; } else { System . out . println ( lis . remove ( cnt - 1 ) ) ; cnt -- ; } } catch ( Exception e ) { break ; } } return lis ; }
N , x ) STRNEWLINE ▁ */ public static void main ( String [ ] args ) { if ( x == 1 || x == 2 * N - 1 ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; List < Integer > l = new ArrayList < Integer > ( ) ; l . add ( i ) ; l . remove ( x - 1 ) ; l . remove ( x ) ; l . remove ( x + 1 ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) { System . out . println ( l . get ( i ) ) ; } System . out . println ( x - 1 ) ; System . out . println ( x ) ; System . out . println ( x + 1 ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) { System . out . println ( l . get ( N - 2 + i ) ) ; } } }
public static int MAX = 100001 ; int perfectDiv [ ] = new int [ MAX ] ; void precomputeCounts ( ) { int i = 1 ; while ( i * i < MAX ) { for ( int j = i * i ; j < MAX ; j += i * i ) { perfectDiv [ j ] ++ ; } i ++ ; } final int countPerfectDivisors = perfectDiv [ n ] ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Total ▁ perfect ▁ divisors ▁ of " + n + " = " + countPerfectDivisors ) ; } n = 16 ; LOG . debug ( " Total ▁ perfect ▁ divisors ▁ of " + n + " = " + countPerfectDivisors ) ; }
public static int N ( ) { int N = map . size ( ) ; int [ ] A = Arrays . copyOf ( map , N ) ; int [ ] B = Arrays . copyOf ( map , N ) ; System . out . println ( sum ( A ) * sum ( B ) ) ; return N ; }
n , t , e = map . get ( n ) ; List < Integer > xlst = Arrays . asList ( map . get ( n ) ) ; for ( int i = 0 , x = xlst . size ( ) ; i < x ; i ++ ) { int a = ( t - e - 1 ) / x ; if ( ( a + 1 ) * x <= t + e ) { System . out . println ( i + 1 ) ; break ; } } else { System . out . println ( - 1 ) ; } }
public static final void cal_IST ( double h , double r ) { double IST = Math . round ( ( h * r * 1.0 ) / 360 ) ; ; int int_IST = ( int ) IST ; ; float float_IST = Math . ceil ( ( IST - int_IST ) * 60 ) ; ; System . out . println ( String . format ( " % d : % f " , int_IST , float_IST ) ) ; ; }
static final void printRoots ( int n ) { double theta = Math . PI * 2 / n ; for ( int k = 0 ; k <= n ; k ++ ) { double real = Math . cos ( k * theta ) ; double img = Math . sin ( k * theta ) ; System . out . print ( " { : . 3 f } " . format ( real ) + " ▁ " ) ; if ( ( img >= 0 ) && ( img < 1 ) ) { System . out . print ( " ▁ + ▁ i ▁ " ) ; } else { System . out . print ( " ▁ - ▁ i ▁ " ) ; } System . out . print ( " { : . 3 f } " . format ( Math . abs ( img ) ) ) ; } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " mac " ) ) { printRoots ( 1 ) ; printRoots ( 2 ) ; printRoots ( 3 ) ; } }
public static void findCart ( int [ ] arr1 , int [ ] arr2 , int n , int n1 ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n1 ; j ++ ) { System . out . print ( " { " + arr1 [ i ] + " , ▁ " + arr2 [ j ] + " } , ▁ " ) ; } } arr1 [ 0 ] = 1 ; arr2 [ 0 ] = 2 ; arr1 [ 1 ] = 3 ; arr2 [ 1 ] = 4 ; arr2 [ 2 ] = 5 ; arr2 [ 2 ] = 6 ; int n1 = arr1 . length ; int n2 = arr2 . length ; findCart ( arr1 , arr2 , n1 , n2 ) ; ; }
public static int noOfWays ( String s ) { int n = s . length ( ) ; int countLeft = 0 ; int countRight = 0 ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( s . charAt ( i ) == s . charAt ( 0 ) ) && ( s . charAt ( i + 1 ) == s . charAt ( 0 ) ) ) countLeft ++ ; else break ; } int i = n - 1 ; while ( ( i >= 0 ) && ( s . charAt ( i ) == s . charAt ( n - 1 ) ) ) { if ( ( s . charAt ( i ) == s . charAt ( n - 1 ) ) && ( s . charAt ( i + 1 ) == s . charAt ( n - 1 ) ) ) countRight ++ ; else break ; i -- ; } if ( ( s . charAt ( 0 ) == s . charAt ( n - 1 ) ) && ( s . charAt ( n - 1 ) == s . charAt ( 0 ) ) ) return ( ( countLeft + 1 ) * ( countRight + 1 ) ) ; else return ( countLeft + countRight + 1 ) ; }
static final int MAX = 100000 ; ; boolean prime [ ] = new boolean [ MAX + 1 ] ; public static void SieveOfEratosthenes ( ) { prime [ 1 ] = false ; prime [ 0 ] = false ; ; int p = 2 ; while ( ( p * p <= MAX ) && ( prime [ p ] ) ) { if ( ( prime [ p ] ) ) { int i = p * 2 ; while ( ( i <= MAX ) && ( prime [ i ] ) ) { prime [ i ] = false ; i += p ; } } p ++ ; } }
public static void SieveOfEratosthenes ( ) { prime [ 1 ] = false ; prime [ 0 ] = false ; int p = 2 ; while ( p * p <= MAX ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) { prime [ i ] = false ; } } p ++ ; } final int arr [ ] = { 2 , 3 , 5 , 7 , 11 } ; int c = 0 ; int Sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { Sum += arr [ i ] ; c = 0 ; } } } System . out . println ( Sum ) ; }
public static void MAX ( ) { int MAX = 1000000 ; boolean prime [ ] = new boolean [ MAX + 1 ] ; prime [ 1 ] = false ; ; prime [ 0 ] = false ; ; int p = 2 ; while ( p * p <= MAX ) { if ( ( prime [ p ] == true ) && ( prime [ p ] == false ) ) { for ( int i = p * 2 ; i <= MAX ; i += p ) { prime [ i ] = false ; } } p ++ ; } ; void productOfKthPrimes ( int arr [ ] , int n , int k ) { int c = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( prime [ arr [ i ] ] ) ) { c ++ ; if ( ( c % k == 0 ) && ( ( product = arr [ i ] ) != 0 ) ) { product *= arr [ i ] ; c = 0 ; } } } System . out . println ( product ) ; } if ( Main . isWindows ) { SieveOfEratosthenes ( ) ; int n = 5 ; int k = 2 ; int arr [ ] = { 2 , 3 , 5 , 7 , 11 } ; productOfKthPrimes ( arr , n , k ) ; } }
public static void findAllSequences ( int diff , char [ ] out , int start , int end ) { if ( ( Math . abs ( diff ) > ( end - start + 1 ) / 2 ) && ( start > end ) ) return ; ; if ( ( start > end ) || ( diff == 0 ) ) { if ( ( diff == 0 ) && ( start > end ) ) System . out . print ( Arrays . toString ( out ) + " ▁ " ) ; return ; } out [ start ] = '0' ; out [ end ] = '1' ; findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '1' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '0' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '1' ; out [ end ] = '0' ; findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) ; }
public static boolean check ( int [ ] h , int high ) { Arrays . sort ( h ) ; int summ = 0 ; for ( int i = h . length - 1 ; i >= 0 ; i -- ) summ += h [ i ] ; return summ <= high ; }
class newNode { public static void init ( final byte [ ] data ) { data = data ; next = null ; } private void printList ( Node node ) { while ( ( node != null ) && ( node . data != null ) ) { System . out . print ( node . data + " - > " + " ▁ " ) ; node = node . next ; } System . out . println ( " NULL " ) ; } private int cntNodes ( Node node ) { if ( ( node == null ) && ( m == 0 ) ) return 0 ; return ( 1 + cntNodes ( node . next ) ) ; } }
public static int maxSubStrings ( String s , int k ) { int maxSubStr = 0 ; int n = s . length ( ) ; for ( int c = 0 ; c < 27 ; c ++ ) { char ch = ( char ) ( ' a ' + c ) ; int curr = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { if ( ( s . charAt ( i ) != ch ) && ( s . charAt ( i ) == ch && cnt != k ) ) { i ++ ; cnt ++ ; } i -- ; if ( ( cnt == k ) && ( s . charAt ( i ) == ch ) ) { curr ++ ; } } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; }
public static void ansQueries ( int [ ] prefeven , int [ ] prefodd , int l , int r ) { if ( ( ( r - l + 1 ) % 2 == 0 ) && ( ( l - r ) % 2 == 0 ) ) { System . out . println ( "0" ) ; } else { if ( ( l % 2 == 0 ) && ( r - l + 1 ) % 2 == 0 ) { System . out . println ( prefeven [ r ] ^ prefeven [ l - 1 ] ) ; } else { System . out . println ( prefodd [ r ] ^ prefodd [ l - 1 ] ) ; } } final int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; final int n = arr . length ; final int l = arr [ 0 ] ; final int r = arr [ 1 ] ; final int q = arr [ 2 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( ( i ) % 2 == 0 ) && ( l - i + 1 ) % 2 == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } int i = 0 ; while ( ( i != q ) && ( i < n ) ) { ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) ; i ++ ; } }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] l = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) l [ i ] = Integer . parseInt ( input ( ) ) ; Arrays . sort ( l ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( l [ i ] >= l [ i - 1 ] ) { if ( l [ i - 1 ] == 0 ) l [ i ] = 0 ; else l [ i ] = l [ i - 1 ] - 1 ; } else l [ i ] = l [ i ] ; } System . out . println ( Arrays . toString ( l ) ) ; }
public static void main ( String [ ] args ) { for ( int p = 0 ; p < Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ analyzed : ▁ " ) ) ; p ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ analyzed : ▁ " ) ) ; int k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ analyzed : ▁ " ) ) ; int [ ] a = JOptionPane . getSelectedValues ( ) ; if ( n % 2 > 0 ) { int x = n / 2 , y = n / 2 + 1 ; if ( n == 2 ) { int s = 0 ; for ( int i = 0 ; i < n * k ; i += 2 ) s += a [ i ] ; System . out . println ( s ) ; } else { int d = x * k , s = 0 ; while ( d < ( n * k ) ) { s += a [ d ] ; d += y ; } System . out . println ( s ) ; } } } }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ rows ▁ to ▁ display " ) ) ; int r = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ columns ▁ to ▁ display " ) ; Stack < Integer > stack = new Stack < > ( ) ; for ( ; n > 0 ; n -- ) { int [ ] row = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ rows ▁ to ▁ display " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int c = row [ 0 ] ; int i = row [ 1 ] ; if ( c == 0 ) stack . push ( row [ 2 ] ) ; if ( stack . peek ( ) != null ) { if ( c == 1 ) System . out . println ( stack . peek ( ) . pop ( ) ) ; if ( c == 2 ) stack . pop ( ) ; } } }
public static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; ; } } public static void removeMin ( int arr [ ] , int n ) { int minVal = arr [ 0 ] ; ; for ( int i = 1 ; i < n ; i ++ ) { minVal = Math . min ( minVal , arr [ i ] ) ; ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] - minVal ; ; } ; } public static void removeFromMax ( int arr [ ] , int n ) { int maxVal = arr [ 0 ] ; ; for ( int i = 1 ; i < n ; i ++ ) { maxVal = Math . max ( maxVal , arr [ i ] ) ; ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = maxVal - arr [ i ] ; ; } ; } public static void modifyArray ( int arr [ ] , int n , int k ) { if ( ( k % 2 == 0 ) && ( arr [ 0 ] > arr [ 1 ] ) ) { removeMin ( arr , n ) ; ; } else { removeFromMax ( arr , n ) ; } printArray ( arr , n ) ; ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 8 , 12 , 16 } ; int n = arr . length ; int k = 2 ; modifyArray ( arr , n , k ) ; } }
public static int [ ] findCentroid ( int [ ] [ ] v ) { int ans [ ] = { 0 , 0 } ; int n = v . length ; double signedArea = 0 ; for ( int i = 0 ; i < v . length ; i ++ ) { double x0 = v [ i ] [ 0 ] ; double y0 = v [ i ] [ 1 ] ; double x1 = v [ ( i + 1 ) % n ] [ 0 ] ; double y1 = v [ ( i + 1 ) % n ] [ 1 ] ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; int vp [ ] [ ] = { { 1 , 2 } , { 3 , - 4 } , { 6 , - 7 } } ; ans = findCentroid ( vp ) ; System . out . println ( " { : . 3 } " . format ( ans [ 0 ] ) + " ▁ " + ans [ 1 ] ) ; return ans ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ lock " ) ) ; String color = " blue " ; int block = 0 ; int i = 0 ; while ( i != n ) { String command = String . valueOf ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ command ▁ to ▁ unlock " ) ) ; if ( command . equals ( " lock " ) ) block = 1 ; else if ( command . equals ( " unlock " ) ) block = 0 ; else if ( block == 0 ) color = command ; i ++ ; } System . out . println ( color ) ; }
public static int minOperations ( int [ ] ar , int k ) { Arrays . sort ( ar ) ; int opsNeeded = 0 ; for ( int i = 0 ; i < k ; i ++ ) { opsNeeded += ar [ k - 1 ] - ar [ i ] ; } int ans = opsNeeded ; for ( int i = k ; i < ar . length ; i ++ ) { opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) ; opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = Math . min ( ans , opsNeeded ) ; } return ans ; }
public static void charCheck ( char inputChar ) { if ( ( ( int ) ( Character . digit ( inputChar , 10 ) ) >= 65 && ( int ) ( Character . digit ( inputChar , 10 ) ) <= 90 ) || ( ( int ) ( Character . digit ( inputChar , 10 ) ) >= 97 && ( int ) ( Character . digit ( inputChar , 10 ) ) <= 122 ) ) System . out . print ( " ▁ Alphabet ▁ " ) ; else if ( ( int ) ( Character . digit ( inputChar , 10 ) ) >= 48 && ( int ) ( Character . digit ( inputChar , 10 ) ) <= 57 ) System . out . print ( " ▁ Digit ▁ " ) ; else System . out . print ( " ▁ Special ▁ Character ▁ " ) ; }
public static String getStr ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display " ) ) ; int [ ] [ ] mat = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { mat [ i ] [ i ] = new int [ Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display " ) ) - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { mat [ i ] [ i ] = new int [ n ] ; } int i = 0 ; String h = " " ; i = 0 ; while ( i < n ) { int [ ] l = new int [ n ] ; int a = i ; while ( true ) { l [ a ] ++ ; if ( l [ a ] > 1 ) break ; a = mat [ a ] [ 0 ] ; } int m = 0 ; int j = 0 ; while ( j < n ) { if ( l [ j ] > m ) { m = l [ j ] ; x = j + 1 ; } j = j + 1 ; } h = h + String . valueOf ( x ) + ' ▁ ' ; i = i + 1 ; } System . out . println ( h ) ; return h ; }
public static int [ ] [ ] findMers ( ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int m = input . nextInt ( ) ; int [ ] [ ] w = Arrays . copyOf ( input . nextLine ( ) . split ( " ▁ " ) , m ) ; int [ ] [ ] d = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = input . nextInt ( ) ; int b = input . nextInt ( ) ; d [ a - 1 ] [ b ] = d [ b - 1 ] [ a ] ; } int [ ] [ ] x = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] . length > 1 ) { for ( int i1 = 0 ; i1 < d [ i ] . length ; i1 ++ ) { for ( int i2 = i1 + 1 ; i2 < d [ i ] . length ; i2 ++ ) { if ( ( i + 1 == d [ d [ i ] [ i1 ] - 1 ] ) && ( d [ i ] [ i2 ] == d [ d [ i ] [ i1 ] - 1 ] ) && ( i + 1 == d [ d [ i ] [ i2 ] - 1 ] ) && ( d [ i ] [ i1 ] == d [ d [ i ] [ i2 ] - 1 ] ) ) { int z = ( i + 1 ) == d [ i ] . length ? d [ i ] [ i1 ] : d [ i ] [ i2 ] ; x [ i ] [ z ] = i + 1 ; } } } } } int c1 = 1e9 ; for ( int a = 0 , b = 0 , c = 0 ; a < n && b < n && c < m ; a ++ , b ++ , c ++ ) { c1 = Math . min ( c1 , w [ a - 1 ] [ b - 1 ] + w [ b - 1 ] [ c - 1 ] ) ; } System . out . println ( c1 == 1e9 ? - 1 : c1 ) ; return x ; }
u ( ) . toString ( ) ; int n = Integer . parseInt ( u ( ) . split ( " ▁ " ) [ 0 ] ) ; int k = Integer . parseInt ( u ( ) . split ( " ▁ " ) [ 1 ] ) ; int [ ] M = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { M [ i ] = Integer . parseInt ( u ( ) . split ( " ▁ " ) [ 2 ] ) ; } int m = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int p = 0 ; p < n ; p ++ ) { if ( ( 0 == M [ p ] ) && ( M [ p ] > 0 ) ) { System . out . print ( p + " ▁ " ) ; break ; } } for ( int l = 0 ; l < p + 1 - k ; l ++ ) { M [ l ] -- ; } M [ p ] -- ; } return m ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ rows ▁ to ▁ solve " ) ) ; int [ ] [ ] rows = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ columns ▁ to ▁ solve " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] [ ] r = new int [ n ] [ rows . length ] ; Map < Integer , Integer > cords = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ rows ▁ to ▁ solve " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; for ( int j = 0 ; j < rows [ i ] ; j ++ ) { cords . put ( r [ i ] [ j ] , new Integer ( i ) ) ; } } int it = 1 ; int [ ] [ ] ans = new int [ n ] [ rows . length ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < rows [ i ] ; j ++ ) { if ( r [ i ] [ j ] != it ) { int tmp = new Integer ( cords . get ( it ) . intValue ( ) ) ; r [ i ] [ j ] = r [ cords . get ( it ) . intValue ( ) ; r [ cords . get ( it ) . intValue ( ) ] = r [ cords . get ( it ) . intValue ( ) ; cords . put ( r [ cords . get ( it ) . intValue ( ) ] , tmp * 1 ) ; ans [ i ] [ j ] = new Integer ( i ) ; ans [ i ] [ j ] = cords . get ( it ) . intValue ( ) ; } it ++ ; } } System . out . println ( ans . length ) ; for ( int [ ] i : ans ) { for ( int j : i ) { System . out . print ( j + " ▁ " ) ; } System . out . println ( ) ; } }
public static int sameOccurrence ( int [ ] arr , int n , int x , int y ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ctX = 0 ; int ctY = 0 ; for ( int j = i ; j < n ; j += 1 ) { if ( ( arr [ j ] == x ) && ( arr [ j + 1 ] == y ) ) { ctX ++ ; ; } else if ( ( arr [ j + 1 ] == y ) && ( arr [ j + 1 ] == x ) ) { ctY ++ ; ; } if ( ( ctX == ctY ) && ( arr [ j + 1 ] == x ) ) { result ++ ; } } } return ( result ) ; }
public static int t ( ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display " ) ) ; while ( ( t > 0 ) && ( t < 10 ) ) { t -- ; String s = JOptionPane . showInputDialog ( " Enter ▁ the ▁ characters ▁ to ▁ display " ) ; int n = s . length ( ) ; int ct = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s . charAt ( i ) == '0' ) && ( t > 0 ) ) { ct ++ ; } } if ( ( ct < n - ct ) || ( ct > n - ct ) ) { System . out . println ( ct ) ; } else if ( ( ct > n - ct ) ) { System . out . println ( n - ct ) ; } else { if ( ( n != 2 ) && ( ct > 0 ) ) { System . out . println ( ct - 1 ) ; } else { System . out . println ( 0 ) ; } } } return t ; }
public static void main ( String [ ] args ) { int c = 0 ; Map < Integer , Integer > f = new HashMap < > ( ) ; for ( int x : args ) { f . put ( x , d = f . get ( x ) + 1 ) ; } ; c += d % 2 * 2 - 1 ; System . out . println ( new String [ ] { " Agasa " , " Conan " } [ c > 0 ] ) ; }
public static int [ ] a ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; ; for ( int i = 0 ; i < 5 ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; } ; return a ; }
public static int findTriplets ( int target ) { int arr [ ] = { 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 } ; int length = arr . length ; int totalCount = 0 ; for ( int i = 0 ; i < length - 2 ; i ++ ) { if ( target % arr [ i ] == 0 ) { for ( int j = i + 1 ; j < length - 1 ; j ++ ) { if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) { int toFind = target / ( arr [ i ] * arr [ j ] ) ; for ( int k = j + 1 ; k < length ; k ++ ) { if ( arr [ k ] == toFind ) totalCount ++ ; } } } } } System . out . println ( " Total ▁ number ▁ of ▁ triplets ▁ found : " + totalCount ) ; return totalCount ; }
public static int main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ used " ) ) ; int l [ ] = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ list ▁ of ▁ digits ▁ to ▁ be ▁ used " ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; if ( n == 1 ) { System . out . println ( new Integer ( 1 ) ) ; System . out . println ( - l [ 0 ] ) ; System . out . println ( new Integer ( 1 ) ) ; System . out . println ( 0 ) ; System . out . println ( new Integer ( 1 ) ) ; System . out . println ( 0 ) ; } else { System . out . println ( new Integer ( 1 ) ) ; System . out . println ( - l [ 0 ] ) ; System . out . println ( new Integer ( 1 ) ) ; System . out . println ( new Integer ( 1 ) ) ; System . out . println ( 0 ) ; System . out . println ( new Integer ( 1 ) ) ; System . out . println ( 0 ) ; } int [ ] x = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) x [ i ] = - l [ i ] * n ; System . out . println ( x ) ; System . out . println ( new Integer ( 2 ) . toString ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) x [ i ] = ( n - 1 ) * l [ i ] ; System . out . println ( x [ 1 : ] ) ; return 0 ; }
public static final int finalNum ( int [ ] arr , int n ) { int result = arr [ 0 ] ; for ( int i = 1 ; i < arr . length ; i ++ ) { result = gcd ( result , arr [ i ] ) ; } return result ; }
N = 1000 ; public static int lastElement ( int [ ] a , int n ) { int steps = 1 ; int [ ] [ ] v = new int [ n ] [ n ] ; if ( n == 1 ) return a [ 0 ] [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] [ i ] = a [ i ] | a [ i + 1 ] ; while ( v [ steps ] [ 0 ] . length > 1 ) { steps ++ ; for ( int i = 0 ; i < v [ steps - 1 ] . length ; i += 2 ) { if ( steps & 1 ) v [ steps ] [ i ] = v [ steps - 1 ] [ i ] | v [ steps - 1 ] [ i + 1 ] ; else v [ steps ] [ i ] = v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ; } } return v [ steps ] [ 0 ] ; }
public static int numberCake ( int n ) { return ( n * n * n + 5 * n + 6 ) / 6 ; }
static final void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; System . setIn ( input ) ; System . setOut ( new PrintStream ( System . out ) ) ; final int pin = Integer . parseInt ( input . nextLine ( ) ) ; final int tupin = Integer . parseInt ( input . nextLine ( ) ) ; final int lispin = Integer . parseInt ( input . nextLine ( ) ) ; final Collection < String > c = new ArrayList < > ( ) ; c . add ( " g " ) ; c . add ( " p " ) ; c . add ( " q " ) ; c . add ( " a " ) ; c . add ( " b " ) ; c . add ( " c " ) ; c . add ( " d " ) ; c . add ( " e " ) ; c . add ( " f " ) ; c . add ( " g " ) ; c . add ( " p " ) ; c . add ( " q " ) ; c . add ( " a " ) ; c . add ( " b " ) ; c . add ( " c " ) ; c . add ( " d " ) ; c . add ( " e " ) ; c . add ( " f " ) ; c . add ( " g " ) ; c . add ( " p " ) ; c . add ( " q " ) ; c . add ( " a " ) ; c . add ( " b " ) ; c . add ( " c " ) ; c . add ( " d " ) ; c . add ( " e " ) ; c . add ( " f " ) ; c . add ( " g " ) ; c . add ( " p " ) ; c . add ( " q " ) ; c . add ( " a " ) ; c . add ( " b " ) ; c . add ( " c " ) ; c . add ( " d " ) ; c . add ( " e " ) ; c . add ( " f " ) ; c . add ( "
public static void pattern ( int N ) { int k = 0 , space = 1 , rows = N ; for ( int i = rows ; i > 0 ; i -- ) { for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( ' * ' ) ; if ( i != rows ) { for ( k = 1 ; k <= space ; k ++ ) System . out . print ( ' ▁ ' ) ; space += 2 ; } for ( int j = i ; j > 0 ; j -- ) { if ( j != rows ) System . out . print ( ' * ' ) ; } System . out . println ( ) ; } N = 6 ; pattern ( N ) ; }
public static int maximumMiddleValue ( int n , int k , int [ ] arr ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = Math . max ( ans , arr [ i - 1 ] ) ; } return ans ; }
public static class TreeNode { public static void init ( final int rootData ) { val = rootData ; left = null ; right = null ; } class Solution { public void pathSumHelper ( TreeNode root , int target , int soFar , int [ ] cache ) { if ( root != null ) { int complement = soFar + root . val - target ; if ( complement < cache . length ) { result += cache [ complement ] ; } cache [ soFar + root . val ] = cache . length - 1 ; pathSumHelper ( root . left , target , soFar + root . val , cache ) ; pathSumHelper ( root . right , target , soFar + root . val , cache ) ; cache [ soFar + root . val ] -- ; } return ; } public int pathSum ( TreeNode root , int sum ) { result = 0 ; pathSumHelper ( root , sum , 0 , new int [ ] { 0 , 1 } ) ; return result ; } } if ( System . getProperty ( " os . arch " ) . contains ( " sparc " ) ) { Solution sObj = new Solution ( ) ; TreeNode tree = new TreeNode ( 10 ) ; tree . left = new TreeNode ( 5 ) ; tree . right = new TreeNode ( - 3 ) ; tree . left . left = new TreeNode ( 3 ) ; tree . left . right = new TreeNode ( 2 ) ; tree . right . right = new TreeNode ( 11 ) ; tree . left . left . left = new TreeNode ( 3 ) ; tree . left . left . right = new TreeNode ( - 2 ) ; tree . left . right . right = new TreeNode ( 1 ) ; int s = 8 ; int out = sObj . pathSum ( tree , s ) ; ; System . out . println ( out ) ; } }
public static void getmax ( int [ ] arr , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } System . out . println ( Math . min ( s , x ) ) ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ entered " ) ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( " Case ▁ " + ( i + 1 ) + " : " ) ; int num = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ entered " ) ) ; for ( int j = 0 ; j <= 10 ; j ++ ) { num *= num ; String sn = Integer . toString ( num ) ; if ( sn . length ( ) < 8 ) { int d = 8 - sn . length ( ) ; for ( int k = 0 ; k < d ; k ++ ) { sn = "0" + sn ; } } num = Integer . parseInt ( sn . substring ( 2 , 6 ) ) ; System . out . println ( num ) ; } } return n ; }
public static int MAX = 250000 ; int SQRT = 500 ; boolean [ ] prime = new boolean [ MAX ] ; public static void sieve ( ) { for ( int i = 2 ; i <= MAX ; i += 2 ) { prime [ i ] = false ; } for ( int i = 3 ; i <= SQRT ; i += 2 ) { if ( prime [ i ] ) { for ( int j = i * i ; j <= MAX ; j += i ) { prime [ j ] = false ; } } } sieve ( ) ; while ( true ) { int n = Integer . parseInt ( System . in . readLine ( ) ) ; if ( n == 0 ) break ; int ans = 0 , m = n << 1 ; if ( n == 1 ) ans ++ ; int i = n + 1 ; if ( ( i & 1 ) == 0 ) i ++ ; while ( i <= m ) { if ( prime [ i ] ) ans ++ ; i += 2 ; } System . out . println ( ans ) ; } }
public static int maxOR ( int [ ] arr , int n ) { int maxVal = 0 ; ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxVal = Math . max ( maxVal , arr [ i ] | arr [ j ] ) ; } ; } ; return maxVal ; }
public static class Solution { int numJewelsInStones ( final String J , final String S ) { if ( J . length ( ) == 0 || S . length ( ) == 0 ) return 0 ; final Set < String > jSet = new HashSet < String > ( J ) ; int ans = 0 ; for ( final String c : S ) { if ( c . contains ( " aA " ) ) ans ++ ; } return ans ; } }
public static int MAX = 100 ; ; int n = 0 ; int [ ] store = new int [ MAX ] ; ; int [ ] [ ] graph = new int [ MAX ] [ ] ; for ( int i = 0 ; i < MAX ; i ++ ) { graph [ i ] = new int [ MAX ] ; } ; int [ ] [ ] d = new int [ MAX ] [ ] ; ; final int b = MAX ; for ( int i = 1 ; i < b ; i ++ ) { for ( int j = i + 1 ; j < b ; j ++ ) { if ( ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) && ( graph [ store [ i ] ] [ store [ j ] ] == 1 ) ) { return false ; } } ; } ; final int max_ = 0 ; for ( int i = 0 ; i < n ; i ++ ) { store [ l ] = i ; ; if ( ( isClique ( l + 1 ) ) && ( graph [ l ] [ store [ i ] ] == 0 ) ) { max_ = Math . max ( max_ , l ) ; ; max_ = Math . max ( max_ , maxCliques ( j , l + 1 ) ) ; ; } } ; if ( System . out . println ( max_ ) ) { int [ ] [ ] edges = { { 1 , 2 } , { 2 , 3 } , { 3 , 1 } , { 4 , 3 } , { 4 , 1 } , { 4 , 2 } } ; int size = edges . length ; n = 4 ; for ( int i = 0 ; i < size ; i ++ ) { graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 ; graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 ; d [ edges [ i ] [ 0 ] ] ++ ; d [ edges [ i ] [ 1 ] ] ++ ; } ; System . out . println ( maxCliques ( 0 , 1 ) ) ; } ; }
static int setBitNumber ( int n ) { int k = ( int ) Math . log ( n ) ; return 2 * k ; }
public static R = new R ( ) { public void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display " ) ) ; int m = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ m ▁ of ▁ characters ▁ to ▁ display " ) ) ; int s = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ s ▁ of ▁ characters ▁ to ▁ display " ) ) ; int f = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ f ▁ of ▁ characters ▁ to ▁ display " ) ) ; if ( s < f ) { int d = 1 ; char c = ' R ' ; if ( s < f ) { d = - 1 ; c = ' L ' ; } String res = " " ; int i = 1 ; int j = s ; int t = 0 , l = 0 , r = 0 ; int k = 1 ; while ( j != f ) { if ( i > t && k < m ) { t = R . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ t ▁ of ▁ characters ▁ to ▁ display " ) ) ; k ++ ; } if ( i == t && ( l <= j && j <= r || l <= j + d && j <= r ) ) { res += ' X ' ; } else { res += c ; j += d ; } i ++ ; } System . out . println ( res ) ; } } }
public static int subsetPairNotDivisibleByK ( int [ ] arr , int N , int K ) { int [ ] f = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) { f [ arr [ i ] % K ] ++ ; } if ( ( K % 2 == 0 ) && ( K > 0 ) ) { f [ K / 2 ] = Math . min ( f [ K / 2 ] , 1 ) ; } int res = Math . min ( f [ 0 ] , 1 ) ; for ( int i = 1 ; i < ( K / 2 ) ; i ++ ) { res += Math . max ( f [ i ] , f [ K - i ] ) ; } return res ; }
public static void main ( String [ ] lines ) { int w = Integer . parseInt ( lines [ 0 ] . substring ( 1 ) ) , m = Integer . parseInt ( lines [ 0 ] . substring ( 1 ) ) , k = Integer . parseInt ( lines [ 0 ] . substring ( 1 ) ) ; int maxLength = 0 ; int availableDigits = ( int ) ( w / k ) ; while ( availableDigits > 0 ) { int currentCostPerN = Integer . parseInt ( String . valueOf ( m ) ) ; int sameCostUntil = 10 * ( currentCostPerN ) ; int usableNumbers = sameCostUntil - m ; int useDigits = usableNumbers * currentCostPerN ; m = sameCostUntil ; if ( availableDigits >= useDigits ) { maxLength += usableNumbers ; availableDigits -= useDigits ; } else { maxLength += ( int ) ( availableDigits / currentCostPerN ) ; availableDigits = 0 ; } } System . out . println ( maxLength ) ; }
public static void printRoots ( int a , int b , int c ) { System . out . println ( Integer . toString ( 1 ) + " , ▁ " + c / ( a * 1.0 ) ) ; }
public static int [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] dp ( int pos , int fl , int pr , int bin ) { int [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] { int pos = 0 ; int fl = 0 ; int pr = 0 ; int bin = 0 ; if ( ( pos == bin ) || ( pos == bin + 1 ) ) return new int [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] { } ; if ( ( memo [ pos ] [ fl ] [ pr ] != - 1 ) && ( memo [ pos ] [ fl ] [ pr ] != - 1 ) ) return memo [ pos ] [ fl ] [ pr ] ; ; int val = 0 ; if ( ( bin [ pos ] == '0' ) || ( bin [ pos ] == '1' ) ) val = val + dp ( pos + 1 , fl , 0 , bin ) ; else if ( ( bin [ pos ] == '1' ) || ( bin [ pos ] == '0' ) ) val = val + dp ( pos + 1 , fl , 1 , bin ) ; if ( ( pr == 0 ) && ( fl == 1 ) ) { if ( ( fl == 1 ) || ( fl == 0 ) ) val += dp ( pos + 1 , fl , 1 , bin ) ; else if ( ( fl == 0 ) || ( fl == 1 ) ) val += dp ( pos + 1 , fl , 1 , bin ) ; } memo [ pos ] [ fl ] [ pr ] = val ; return new int [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]
N = 4 ; public static void MaximumDecimalValue ( int [ ] [ ] mat , int n ) { int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ i ] = new int [ n ] ; } if ( ( mat [ 0 ] [ 0 ] == 1 ) && ( mat [ 0 ] [ 0 ] == 2 ) ) { dp [ 0 ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { if ( ( mat [ 0 ] [ i ] == 1 ) && ( mat [ 0 ] [ i - 1 ] == 2 ) ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 * i ; } else { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( ( mat [ i ] [ 0 ] == 1 ) && ( mat [ i ] [ 0 ] == 2 ) ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 * i ; } } else { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( ( mat [ i ] [ j ] == 1 ) && ( mat [ i ] [ j - 1 ] == 2 ) ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 * ( i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } }
public static void createHash ( Set < Integer > hash1 , int maxElement ) { int prev = 0 , curr = 1 ; hash1 . add ( prev ) ; hash1 . add ( curr ) ; while ( ( curr = Math . abs ( curr ) ) < maxElement ) { int temp = curr + prev ; hash1 . add ( temp ) ; prev = curr ; curr = temp ; } final int n = hash1 . size ( ) ; hash1 . clear ( ) ; createHash ( hash1 , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i < hash1 . size ( ) ) && ( n - i ) < hash1 . size ( ) ) { System . out . println ( String . valueOf ( i ) + " , ▁ " + String . valueOf ( n - i ) ) ; return ; } } System . out . println ( " - 1" ) ; if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " linux " ) ) { int N = 90 ; findFibonacciPair ( N ) ; } }
static int countgroup ( int [ ] a , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xs = xs ^ a [ i ] ; } if ( xs == 0 ) { return ( 1 << ( n - 1 ) ) - 1 ; } return 0 ; }
public static int maxLength ( String s , int n ) { int ans = - ( Integer . MAX_VALUE + 1 ) ; ; int [ ] A = new int [ n + 5 ] , L = new int [ n + 1 ] , R = new int [ n + 1 ] ; int [ ] freq = new int [ n + 1 ] ; freq [ 0 ] = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( Character . digit ( s . charAt ( j ) , 16 ) - Character . digit ( ' a ' , 16 ) == i ) && ( A [ j ] ++ ) == 0 ) count ++ ; freq [ j ] = count ; } for ( int j = 0 ; j < n ; j ++ ) { L [ j ] = ( 2 * freq [ j - 1 ] ) - j ; R [ j ] = ( 2 * freq [ j ] ) - j ; } int maxLen = - ( Integer . MAX_VALUE + 1 ) ; int minVal = Integer . MAX_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { minVal = Math . min ( minVal , L [ j ] ) ; A [ j ] ++ ; int l = 0 ; int r = j ; while ( ( l <= r ) && ( A [ mid ] <= R [ j ] ) ) { int mid = ( l + r ) > > 1 ; if ( ( A [ mid ] <= R [ j ] ) && ( A [ mid ] > L [ j ] ) ) { maxLen = Math . max ( maxLen , j - mid + 1 ) ; r = mid - 1 ; } else l = mid + 1 ; } } ans = Math . max ( ans , maxLen ) ; A [ j ] = 0 ; R [ j ] = 0 ; L [ j ] = 0 ; } return ans ; }
public static void main ( String [ ] args ) { int N = 100005 ; ArrayList < ArrayList < Integer > > gr = new ArrayList < ArrayList < Integer > > ( N ) ; int [ ] colour = { - 1 } ; ArrayList < Pair < Integer , Integer > > edges = new ArrayList < Pair < Integer , Integer > > ( N ) ; boolean bip = true ; final int x = 0 ; final int y = 0 ; gr . add ( new ArrayList < Integer > ( ) ) ; gr . add ( new ArrayList < Integer > ( ) ) ; edges . add ( new Pair < Integer , Integer > ( x , y ) ) ; final int dfs = 0 ; colour [ x ] = - 1 ; synchronized ( gr ) { for ( int i = 0 ; i < gr . size ( ) ; i ++ ) { if ( colour [ i ] == - 1 ) dfs ++ ; else if ( colour [ i ] == col ) bip = false ; } } final Directed_Graph < Integer > g = new Directed_Graph < Integer > ( n , m ) ; dfs ( 1 , 1 ) ; if ( ! bip ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i <= m ; i ++ ) { if ( colour [ edges . get ( i ) . first ] == 0 ) edges . set ( i , edges . get ( i ) . second ) ; System . out . println ( edges . get ( i ) . first + " ▁ " + edges . get ( i ) . second ) ; } }
public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; List < Integer > l = Lists . newArrayList ( ) ; for ( int i = 0 ; i < input . nextInt ( ) ; i ++ ) { l . add ( input . nextInt ( ) ) ; } Set < Integer > s = Sets . newHashSet ( l ) ; if ( Iterables . isEmpty ( s ) && Iterables . size ( l ) != 0 ) { Collections . sort ( l ) ; } System . out . println ( * l ) ; }
static int k ( int n , int w ) { int sum = 0 ; for ( int i = 1 ; i <= w ; i ++ ) { sum += k * i ; } if ( sum <= n ) { System . out . println ( 0 ) ; } else { System . out . println ( sum - n ) ; } return sum ; }
public static boolean isPrime ( int k ) { if ( ( k <= 1 ) || ( k > 2 ) ) return false ; for ( int i = 2 ; i <= k ; i ++ ) if ( ( k % i == 0 ) ) return false ; return true ; } public static final boolean check ( int num , int k ) { int flag = 1 ; for ( int i = 2 ; i <= k ; i ++ ) if ( ( num % i == 0 ) ) flag = 0 ; if ( ( flag == 1 ) && ( num % k == 0 ) ) return true ; else return false ; } public static final int findCount ( int a , int b , int k ) { int count = 0 ; if ( ( ! isPrime ( k ) ) && ( k > 0 ) ) { for ( int i = a ; i <= b ; i ++ ) { int ans = check ( i , k ) ; if ( ( ans == 1 ) && ( k > 0 ) ) count ++ ; else continue ; } } return count ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { int a = 2020 ; int b = 6300 ; int k = 29 ; System . out . println ( findCount ( a , b , k ) ) ; } }
public static String a ( ) { String a = " abcdefghijklmnopqrstuvwxyz " ; int n = Integer . parseInt ( input ( ) . toCharArray ( ) ) ; ; int t = a . length * n ; if ( k > n || ( k == 1 && n != 1 ) ) { System . out . println ( - 1 ) ; } else if ( n == 1 ) { System . out . println ( " a " ) ; } else { System . out . println ( t . substring ( 0 , n - k + 2 ) + a . substring ( 2 , k ) ) ; } }
static final public int maxn = 16 ; public static void precompute ( ) { int [ ] dp = new int [ maxn ] ; for ( int i = 0 ; i < maxn ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; int [ ] v = { 4 , 6 , 9 } ; for ( int i = 1 ; i < maxn ; i <<= 1 ) { for ( int k = 0 ; k < 3 ; k ++ ) { int j = v [ k ] ; if ( ( i >= j && dp [ i - j ] != - 1 ) || ( i == j && dp [ i - j ] == - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } }
public static int countSquares ( int n ) { return ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) ; }
public static final int [ ] getModd ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) , m = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > al = Arrays . asList ( Integer . parseInt ( input . nextLine ( ) ) , Integer . parseInt ( input . nextLine ( ) ) ) ; Map < Integer , Integer > modd = new HashMap < Integer , Integer > ( ) ; int s = 0 ; for ( Integer a : al ) { s += a ; s %= m ; modd . put ( s , s ) ; } int ans = 0 ; for ( Integer i : modd . values ( ) ) { ans += i * ( i - 1 ) / 2 ; } ans += modd . get ( 0 ) ; System . out . println ( ans ) ; }
public static int FindSubarray ( int [ ] arr , int n , int k ) { int [ ] countOne = new int [ n ] ; countOne [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { countOne [ i ] = new Integer ( arr [ i ] ) . intValue ( ) ; ; } int sum = countOne [ 0 ] ; ; if ( ( n == 1 ) && ( countOne [ 0 ] >= k ) ) { if ( ( countOne [ 0 ] >= k ) && ( countOne [ 0 ] >= k ) ) { return 1 ; } else { return - 1 ; } } int ans = Integer . MAX_VALUE ; ; int i = 1 ; ; int j = 0 ; ; while ( ( i < n ) && ( i < arr . length ) ) { if ( ( k == countOne [ j ] ) ) { ans = 1 ; break ; } else if ( ( k == countOne [ i ] ) ) { ans = 1 ; break ; } else if ( ( sum + countOne [ i ] < k ) && ( sum + countOne [ i ] > k ) ) { sum += countOne [ i ] ; ; i ++ ; } else if ( ( sum + countOne [ i ] > k ) && ( sum + countOne [ i ] == k ) ) { ans = Math . min ( ans , ( i - j ) + 1 ) ; ; sum -= countOne [ j ] ; ; j ++ ; } else if ( ( sum + countOne [ i ] == k ) && ( sum + countOne [ i ] > k ) ) { ans = Math . min ( ans , ( i - j ) + 1 ) ; ; sum += countOne [ i ] ; ; i ++ ; } } if ( ( ans != Integer . MAX_VALUE ) && ( ans != Integer . MIN_VALUE ) ) { return ans ; } else { return - 1 ; } }
public static void Loss ( double SP , double P ) { double loss = 0 ; loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) ; System . out . println ( " Loss ▁ = " + " { : . 3 } " . format ( loss ) ) ; }
N , M , X ) { int A = Integer . parseInt ( input . nextLine ( ) ) ; System . out . println ( Math . min ( A , M - A ) ) ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] sushi = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) sushi [ i ] = Integer . parseInt ( input ( ) ) ; int res = 0 ; int before = 0 , after = 0 ; int cur = sushi [ 0 ] ; int i = 0 ; while ( i < n ) { if ( sushi [ i ] == cur ) { before ++ ; i ++ ; } else { int j = i ; int jS = sushi [ j ] ; cur = sushi [ j ] ; while ( j < n && sushi [ j ] == jS ) { after ++ ; j ++ ; } i = j ; res = Math . max ( res , Math . min ( before , after ) ) ; before = after ; after = 0 ; } } System . out . println ( res * 2 ) ; }
public static String compute ( ) { int ans = Integer . parseInt ( " " ) ; if ( getTerminal ( ans ) == 89 ) { return String . valueOf ( ans ) ; } TERMINALS = ( 1 << 89 ) ; final int n = 0 ; while ( n != 0 ) { n = squareDigitSum ( n ) ; } final int squareDigitSum = n ; int result = 0 ; while ( n > 0 ) { result += SQUARE_DIGITS_SUM [ n % 1000 ] ; n /= 1000 ; } return result ; }
public static int fact ( int n ) { int fact = 1 ; ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; } ; return fact ; }
public static void printCommonElements ( int [ ] [ ] mat ) { Map < Integer , Integer > mp = Maps . newHashMap ( ) ; for ( int j = 0 ; j < N ; j ++ ) mp . put ( mat [ 0 ] [ j ] , 1 ) ; for ( int i = 1 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( mat [ i ] [ j ] < mp . keySet ( ) ) && mp . get ( mat [ i ] [ j ] ) == i ) { mp . put ( mat [ i ] [ j ] , i + 1 ) ; if ( i == M - 1 ) System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } }
static public void main ( String [ ] args ) throws Exception { final long n = Integer . parseInt ( args [ 0 ] ) ; final long x1 = Integer . parseInt ( args [ 1 ] ) , x2 = Integer . parseInt ( args [ 2 ] ) ; final List < Callable < Integer > > funcs = new ArrayList < Callable < Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final int k = Integer . parseInt ( args [ 3 ] ) , b = Integer . parseInt ( args [ 4 ] ) ; funcs . add ( new Callable < Integer > ( ) { public Integer call ( ) throws Exception { return k * i + b ; } } ) ; final Comparator < Integer > comp = new Comparator < Integer > ( ) { public int compare ( Integer o1 , Integer o2 ) { long start = System . currentTimeMillis ( ) ; Integer res = ( int ) ( x1 + EPS ) ; long elapsedTime = System . currentTimeMillis ( ) - start ; System . out . println ( " \ " " + o1 . toString ( ) + " \ " ▁ took ▁ " + elapsedTime * 1000 + " ▁ ms " ) ; return res ; } } ; System . out . println ( " \ " " + o2 . toString ( ) + " \ " ▁ took ▁ " + elapsedTime * 1000 + " ▁ ms " ) ; } @ SuppressWarnings ( " unchecked " ) final Callable < Integer > callable = ( Callable < Integer > ) ( ) -> { final long start = System . currentTimeMillis ( ) ; Integer res = ( Integer ) ( x1 + EPS ) ; System . out . println ( " \ " " + res + " \ " ▁ took ▁ " + elapsedTime * 1000 + " ▁ ms " ) ; return res ; } ; @ SuppressWarnings ( " unchecked " ) final Callable < Integer > callable = ( Callable < Integer > ) ( ) -> { final long start = System . currentTimeMillis ( ) ; Integer res = ( Integer ) ( x2 + EPS ) ; System . out . println ( " \ " " + res + " \ " ▁ took ▁ " + elapsedTime * 1000 + " ▁ ms " ) ; return res ; } ; if ( args . length == 0 ) { callable . call ( new BufferedReader ( System . in ) == null ? new InputStreamReader ( System . in ) : new BufferedReader ( System . in ) ) ; callable . call ( ) ; } }
public static int line2int ( String linea ) { String temp = " " ; for ( int i = 0 ; i < linea . length ( ) ; i ++ ) { if ( linea . charAt ( i ) == ' ▁ ' ) { if ( temp != " " ) { val1 = Integer . parseInt ( temp ) ; temp = " " ; } } else { temp = temp + linea . charAt ( i ) ; } } int val2 = Integer . parseInt ( temp ) ; return ( val1 ) ; }
public static int sumOfAP ( int a , int d , int n ) { int sum = 0 ; int i = 0 ; while ( i < n ) { sum = sum + a ; a = a + d ; i = i + 1 ; } return sum ; }
public static void find3Numbers ( int [ ] arr , int n ) { int small = + 2147483647 ; int large = + 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] <= small ) && ( arr [ i ] <= large ) ) { small = arr [ i ] ; } else if ( ( arr [ i ] <= large ) && ( arr [ i ] <= small ) ) { large = arr [ i ] ; } else { break ; } } if ( ( i == n ) || ( i == n - 1 ) ) { System . out . println ( " No ▁ such ▁ triplet ▁ found " ) ; return ; } for ( int j = 0 ; j < i + 1 ; j ++ ) { if ( ( arr [ j ] < large ) && ( arr [ j ] > small ) ) { small = arr [ j ] ; break ; } } System . out . println ( Integer . toString ( small ) + " ▁ " + Integer . toString ( large ) + " ▁ " + Integer . toString ( arr [ i ] ) ) ; return ; }
public static void numbersWith3Divisors ( int n ) { boolean prime [ ] = new boolean [ ( n + 1 ) ] ; prime [ 0 ] = prime [ 1 ] = false ; ; int p = 2 ; ; while ( ( p * p <= n ) && ( prime [ p ] == true ) ) { for ( int i = p * 2 ; i <= n ; i += p ) { prime [ i ] = false ; } } p ++ ; }
public static int findPairCount ( int N , int K ) { int count = 0 ; ; int [ ] rem = new int [ K ] ; ; rem [ 0 ] = N / K ; ; for ( int i = 1 ; i < K ; i ++ ) { rem [ i ] = ( N - i ) / K + 1 ; ; } ; if ( ( K % 2 == 0 ) ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; ; for ( int i = 1 ; i < K / 2 ; i ++ ) { count += rem [ i ] * rem [ K - i ] ; ; } count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; ; for ( int i = rage ( 1 , K / 2 + 1 ) ; i < N ; i ++ ) { count += rem [ i ] * rem [ K - i ] ; ; } } return count ; }
public static void main ( String [ ] args ) { final Scanner input = new Scanner ( System . in ) ; while ( true ) { final int n = input . nextInt ( ) ; final int m = input . nextInt ( ) ; if ( n == 0 && m == 0 ) break ; if ( n > 0 ) { a = Arrays . copyOf ( input . nextLine ( ) . split ( " ▁ " ) , n ) ; } if ( m > 0 ) { b = Arrays . copyOf ( input . nextLine ( ) . split ( " ▁ " ) , m ) ; } int ans = i = j = 0 ; int s = 0 , t = - 1 ; while ( i < n || j < m ) { if ( i < n ) { if ( s == a [ i ] ) { i ++ ; } if ( i < n ) { t = a [ i ] ; } } if ( j < m ) { if ( s == b [ j ] ) { j ++ ; } if ( j < m && ( t < 0 || b [ j ] < t ) ) { t = b [ j ] ; } } if ( t >= 0 ) { if ( i < n && t == a [ i ] ) { i ++ ; } if ( j < m && t == b [ j ] ) { j ++ ; } ans = Math . max ( ans , t - s ) ; s = t ; t = - 1 ; } } if ( t >= 0 ) { ans = Math . max ( ans , t - s ) ; } System . out . println ( ans ) ; } }
public static int n ( String input ) { int arr [ ] = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int x = Math . max ( arr ) ; int arrSum = Arrays . stream ( arr ) . mapToInt ( Integer :: parseInt ) . sum ( ) ; if ( arrSum - x >= x && arrSum % 2 == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } return arr [ 0 ] ; }
static double PHI = 1.6180339 ; int [ ] f = { 0 , 1 , 1 , 2 , 3 , 5 } ; final int n = 6 ; if ( n < 6 ) return f [ n ] ; int t = 5 ; double fn = 5 ; while ( t < n ) { fn = Math . round ( fn * PHI ) ; t ++ ; } return fn ; }
public static int kthSmallest ( int n , int k ) { return 2 * k ; }
public static void printSumTricky ( int [ ] [ ] mat , int k ) { n = mat . length ; if ( k > n ) return ; int [ ] [ ] stripSum = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int Sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) Sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = Sum ; for ( i = 1 ; i < n - k ; i ++ ) ; } } }
public static int [ ] M ( ) { int [ ] M = Arrays . stream ( input ( ) . toArray ( Integer [ ] :: new ) ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; int a = M [ 0 ] ; int b = M [ 1 ] ; int n = M [ 2 ] ; if ( a != 0 ) { if ( b % a != 0 ) { System . out . println ( " No ▁ solution " ) ; } else { b = b / a ; int x = 0 , y = - 2000 ; if ( b >= 0 ) { while ( y < b ) { y = Math . pow ( x , n ) ; x = x + 1 ; } if ( y > b ) { System . out . println ( " No ▁ solution " ) ; } else { System . out . println ( x - 1 ) ; } } else { if ( n % 2 == 0 ) { System . out . println ( " No ▁ solution " ) ; } else { x = - 1 ; y = 2000 ; while ( y > b ) { y = Math . pow ( x , n ) ; x = x - 1 ; } if ( y < b ) { System . out . println ( " No ▁ solution " ) ; } else { System . out . println ( x + 1 ) ; } } } } } else { if ( b == 0 ) { System . out . println ( 5 ) ; } else { System . out . println ( " No ▁ solution " ) ; } } return M ; }
public static int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
public static int nextPowerOf2 ( int n ) { int count = 0 ; if ( ( n > 0 ) && ! ( n > 0 ) && ( n - 1 ) > 0 ) return n ; while ( n != 0 ) { n >>>= 1 ; count ++ ; } return 1 << count ; } public static int removeElement ( int n ) { if ( n == 1 || n == 2 ) return 0 ; int a = nextPowerOf2 ( n ) ; if ( n == a || n == a - 1 ) return 1 ; else if ( n == a - 2 ) return 0 ; else if ( n % 2 == 0 ) return 1 ; else return 2 ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { n = 5 ; System . out . println ( removeElement ( n ) ) ; } } public static void main ( String [ ] args ) { if ( args . length == 0 ) { n = 5 ; System . out . println ( removeElement ( n ) ) ; } } }
N , P = map . size ( ) ; static final int combi ( int N , int K ) { int a = 1 ; for ( int i = 0 ; i < K ; i ++ ) a *= N - i ; for ( int j = 0 ; j < K ; j ++ ) a /= j + 1 ; return a ; }
public static int modInverse ( int a , int m ) { a = a % m ; ; for ( int x = 1 ; x < m ; x ++ ) { if ( ( ( a * x ) % m == 1 ) && ( ( a * x ) % m == 0 ) ) { return x ; } } return 1 ; }
public static int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; }
static final void findGreater ( double a , double b ) { double x = a * ( Math . log ( b ) ) ; ; double y = b * ( Math . log ( a ) ) ; ; if ( ( y > x ) ) System . out . println ( " a ^ b ▁ is ▁ greater " ) ; }
public static final int findAnswer ( String str1 , String str2 , int n ) { int l = 0 , r = 0 ; int ans = 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( str1 . charAt ( i ) != str2 . charAt ( i ) ) && ( str1 . charAt ( i ) != str2 . charAt ( i ) ) ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ( str1 . charAt ( i ) != str2 . charAt ( i ) ) && ( str1 . charAt ( i ) != str2 . charAt ( i ) ) ) { r = i ; break ; } } if ( ( r < l ) && ( l == r ) ) { return 26 * ( n + 1 ) ; } else if ( ( l == r ) && ( l == r ) ) { return ans ; } else { for ( int i = l + 1 ; i <= r ; i ++ ) { if ( ( str1 . charAt ( i ) != str2 . charAt ( i - 1 ) ) && ( str1 . charAt ( i ) != str2 . charAt ( i ) ) ) { ans -- ; break ; } } for ( int i = l + 1 ; i <= r ; i ++ ) { if ( ( str1 . charAt ( i - 1 ) != str2 . charAt ( i ) ) && ( str1 . charAt ( i ) != str2 . charAt ( i ) ) ) { ans -- ; break ; } } return ans ; } }
public static int t ( ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ algorithm " ) ) ; for ( int p = 0 ; p < t ; p ++ ) { int n = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ algorithm " ) ; int x = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ algorithm " ) ; int m = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ algorithm " ) ; int L = x ; int R = x ; for ( int i = 0 ; i < m ; i ++ ) { int l = ( Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ algorithm " ) ) ) , r = ( Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ algorithm " ) ) ) ; if ( l <= R && r >= L ) { L = Math . min ( L , l ) ; R = Math . max ( R , r ) ; } } System . out . println ( R - L + 1 ) ; } return t ; }
public static boolean bitsAreInAltPatrnInGivenTRange ( int n , int l , int r ) { int num = n > > > ( l - 1 ) ; ; int prev = num & 1 ; num = num > > > 1 ; for ( int i = 1 ; i < ( r - l ) ; i ++ ) { int curr = num & 1 ; if ( ( curr == prev ) && ( curr != 0 ) ) return false ; prev = curr ; num = num > > > 1 ; } return true ; }
static void main ( String [ ] args ) { Scanner i = new Scanner ( System . in ) ; int n = i . nextInt ( ) ; int m = i . nextInt ( ) ; int sa = i . nextInt ( ) ; sa = Math . min ( new int [ n - sa ] , sa ) ; StringBuilder ss = new StringBuilder ( ) ; for ( ; ; ) { int a = i . nextInt ( ) ; int b = i . nextInt ( ) ; b -= a ; ss . append ( ( b % 2 && b <= sa << 1 ) ? "1 \n " : "0 \n " ) ; } System . out . println ( ss . toString ( ) ) ; }
public static int nthGroup ( int n ) { return n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int a = 0 ; int r = 0 , c = - 1 ; int [ ] [ ] dl = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { List < Integer > tl = Arrays . asList ( Integer . parseInt ( input . nextLine ( ) ) . split ( " ▁ " ) ) ; if ( c < 0 && tl . contains ( 0 ) ) { r = i ; c = tl . indexOf ( 0 ) ; } dl [ i ] = tl ; } int s = sum ( dl [ ( r + 1 ) % n ] ) ; a = s - sum ( dl [ r ] ) ; dl [ r ] [ c ] = a ; if ( n > 1 && a < 1 ) { System . out . println ( - 1 ) ; System . exit ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s != sum ( dl [ i ] ) ) { System . out . println ( - 1 ) ; System . exit ( ) ; } } dl = Arrays . asList ( Integer . parseInt ( input . nextLine ( ) ) . split ( " ▁ " ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s != sum ( dl [ i ] ) ) { System . out . println ( - 1 ) ; System . exit ( ) ; } } int s1 = s2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s1 += dl [ i ] [ i ] ; s2 += dl [ i ] [ n - i - 1 ] ; } if ( ! ( s1 == s2 == s ) ) { System . out . println ( - 1 ) ; System . exit ( ) ; } if ( n == 1 ) { a = 1 ; } else { a = Math . abs ( a ) ; } return a ; }
static final public void sched ( ) { ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; ( ( Integer ) input . get ( ) ) . intValue ( ) ; }
public static int maximumOccurredElement ( int [ ] L , int [ ] R , int n ) { int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i < n ; i += 1 ) { arr [ L [ i ] ] ++ ; arr [ R [ i ] + 1 ] -- ; } int msum = arr [ 0 ] ; for ( int i = 1 ; i < MAX ; i += 1 ) { arr [ i ] += arr [ i - 1 ] ; if ( ( msum < arr [ i ] ) && ( msum > arr [ i ] ) ) { msum = arr [ i ] ; ind = i ; } } return ind ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int back = input ( ) ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int p = input ( ) ; if ( p == back ) { count ++ ; } back = p ; } System . out . println ( count + 1 ) ; }
public static int n ( ) { int n , m ; n = Integer . parseInt ( input ( ) . nextLine ( ) ) ; m = Integer . parseInt ( input ( ) . nextLine ( ) ) ; if ( n < 1 ) { if ( m < 1 ) { System . out . println ( n + " ▁ " + m ) ; quit ( ) ; } System . out . println ( " Impossible " ) ; quit ( ) ; } if ( m > n ) { min = m ; max = n + m - 1 ; System . out . println ( min + " ▁ " + max ) ; } if ( m <= n ) { min = n ; max = n + m - 1 ; if ( m == 0 ) max = n ; System . out . println ( min + " ▁ " + max ) ; } return min ; }
public static double func ( double x ) { return ( ( double ) 1 ) / ( 1 + x * x ) ; }
public static int main ( String [ ] args ) { int N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ algorithm " ) ) ; int K = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ algorithm " ) ) ; int X = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ first ▁ element ▁ of ▁ the ▁ matrix ▁ to ▁ repeat " ) ) ; int Y = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ second ▁ element ▁ of ▁ the ▁ matrix ▁ to ▁ repeat " ) ) ; if ( N <= K ) { System . out . println ( Integer . toString ( N * X ) ) ; } else { System . out . println ( Integer . toString ( K * X + ( N - K ) * Y ) ) ; } return 0 ; }
public static double sqrt ( double x , double h ) { while ( true ) { double x = ( double ) input . nextDouble ( ) ; if ( x == 0 ) break ; double h = ( double ) input . nextDouble ( ) ; double l = Math . sqrt ( 0.25 * x * x + h * h ) ; System . out . println ( x * x + 2 * x * l ) ; } return 0 ; }
public static int k ( ) { int k = Integer . parseInt ( input ( ) ) ; int i = 10 ; while ( k > 0 ) { i += 9 ; if ( Arrays . equals ( Integer . toString ( i ) , 10 ) ) k -- ; } System . out . println ( i ) ; }
public static final void main ( String [ ] args ) { final int MAX = 100000 ; boolean prime [ ] = new boolean [ MAX ] ; prime [ 0 ] = true ; for ( int p = 2 ; p <= Integer . MAX_VALUE ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } final void printPrimeQuad ( int n ) { for ( int i = 0 ; i < n - 7 ; i ++ ) { if ( ( prime [ i ] && prime [ i + 2 ] && prime [ i + 6 ] && prime [ i + 8 ] ) || ( prime [ i ] && prime [ i + 2 ] && prime [ i + 6 ] && prime [ i + 8 ] ) ) { System . out . println ( i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i + " ▁ " + i ) ;
public static int MAX = 1000 ; public static int maxSubsequenceSubstring ( String x , String y , int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { dp [ i ] = new int [ m ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( ( x . charAt ( j - 1 ) == y . charAt ( i - 1 ) ) && ( x . charAt ( j ) == y . charAt ( i - 1 ) ) ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans = Math . max ( ans , dp [ i ] [ n ] ) ; } return ans ; } }
public static int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i <= n ; i += 1 ) { if ( ( i % a == 0 || i % b == 0 ) ) { sum += i ; } } return sum ; }
public static final void main ( String [ ] args ) { final int [ ] st = new int [ Integer . MAX_VALUE ] ; final int [ ] av = new int [ Integer . MAX_VALUE ] ; Scanner s = new Scanner ( System . in ) ; Scanner t = new Scanner ( System . in ) ; Set < String > se = new HashSet < String > ( ) ; for ( int i = s . nextInt ( ) ; i < s . nextInt ( ) ; i ++ ) se . add ( s . nextInt ( ) . toLowerCase ( ) ) ; for ( int i = t . nextInt ( ) ; i < t . nextInt ( ) ; i ++ ) av [ i ] ++ ; for ( int i = s . nextInt ( ) ; i < st . length ; i ++ ) st [ i ] ++ ; int y = 0 , w = 0 ; for ( int i = se . size ( ) ; i < se . size ( ) ; i ++ ) { int j = se . get ( i ) . toUpperCase ( ) ; int a = Math . min ( st [ i ] , av [ i ] ) , b = Math . min ( st [ j ] , av [ j ] ) ; y += a + b ; st [ i ] -= a ; st [ j ] -= b ; av [ i ] -= a ; av [ j ] -= b ; int c = Math . min ( st [ i ] , av [ j ] ) , d = Math . min ( st [ j ] , av [ i ] ) ; w += c + d ; } System . out . println ( y + " ▁ " + w ) ; }
public static int MAX = 1000 ; int [ ] sequence = new int [ MAX + 1 ] ; ; public static void vanEckSequence ( ) { for ( int i = 0 ; i < MAX ; i ++ ) sequence [ i ] = 0 ; ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( ( sequence [ j ] == sequence [ i ] ) && ( sequence [ i ] == sequence [ j ] ) ) { sequence [ i + 1 ] = i - j ; break ; } } } } public static int getNthTerm ( int n ) { return sequence [ n ] ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; int n = 6 ; ; System . out . println ( getNthTerm ( n ) ) ; n = 100 ; ; System . out . println ( getNthTerm ( n ) ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } }
public static int MAX = 10000 ; int [ ] sequence = new int [ MAX + 1 ] ; ; public static void vanEckSequence ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( ( sequence [ j ] == sequence [ i ] ) && ( sequence [ i ] != 0 ) ) { sequence [ i + 1 ] = i - j ; break ; } } } } public static int getCount ( int n ) { int count = 1 ; int i = n - 1 ; while ( ( sequence [ i + 1 ] != 0 ) && ( sequence [ i ] != 0 ) ) { count ++ ; i = i - sequence [ i + 1 ] ; } return count ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( getCount ( n ) ) ; } public static void main ( String [ ] args ) { int n = 11 ; System . out . println ( getCount ( n ) ) ; } }
public static int MAX = 10000 ; int [ ] sequence = new int [ MAX + 1 ] ; ; public static void vanEckSequence ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( ( sequence [ j ] == sequence [ i ] ) && ( sequence [ i ] == sequence [ j ] ) ) { sequence [ i + 1 ] = i - j ; break ; } } } } public static int getCount ( int n ) { int nthTerm = sequence [ n - 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( sequence [ i ] == nthTerm ) && ( sequence [ i ] == nthTerm ) ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; int n = 5 ; System . out . println ( getCount ( n ) ) ; n = 11 ; System . out . println ( getCount ( n ) ) ; } }
static int nthElement ( int a , int b , int n ) { int lcm = ( a * b ) / ( int ) gcd ( a , b ) ; int l = 1 ; int r = Math . min ( a , b ) * n ; while ( ( l <= r ) && ( l < n ) ) { int mid = ( l + r ) > > > 1 ; int val = ( ( int ) ( mid / a ) + ( int ) ( mid / b ) - ( int ) ( mid / lcm ) ) ; if ( ( val == n ) && ( val < n ) ) { return ( int ) Math . max ( ( int ) ( mid / a ) * a , ( int ) ( mid / b ) * b ) ; } if ( ( val < n ) && ( val > n ) ) { l = mid + 1 ; } else { r = mid - 1 ; } } a = 5 ; b = 3 ; n = 5 ; System . out . println ( nthElement ( a , b , n ) ) ; }
public static int getDayNumber ( ) { Calendar cal = Calendar . getInstance ( ) ; int y = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ day ▁ of ▁ the ▁ year ▁ to ▁ start ▁ on " ) ) ; boolean isRun = cal . get ( Calendar . YEAR ) == cal . get ( Calendar . YEAR ) ; int week = cal . get ( Calendar . DAY_OF_WEEK ) ; while ( true ) { cal . add ( Calendar . YEAR , 1 ) ; if ( cal . get ( Calendar . YEAR ) == isRun && cal . get ( Calendar . DAY_OF_WEEK ) == week ) { System . out . println ( cal . get ( Calendar . YEAR ) ) ; break ; } } return cal . get ( Calendar . DAY_OF_WEEK ) ; }
public static int N ( Scanner scanner ) { int [ ] base = { 0 } ; int out = 0 ; int point = 0 ; int inning = 0 ; while ( true ) { String event = scanner . nextLine ( ) ; if ( event . equals ( " HIT " ) ) { if ( base [ 2 ] == 1 ) point ++ ; base [ 2 ] = base [ 1 ] ; base [ 1 ] = base [ 0 ] ; base [ 0 ] = 1 ; } else if ( event . equals ( " HOMERUN " ) ) { point += Arrays . asList ( base ) . size ( ) + 1 ; base = new int [ 3 ] ; } else if ( event . equals ( " OUT " ) ) { out ++ ; if ( out == 3 ) { System . out . println ( point ) ; inning ++ ; if ( inning == N ) break ; base = new int [ 3 ] ; out = 0 ; point = 0 ; } } } return point ; }
protected static int gcd ( int a , int b ) { if ( ( a == 0 || b == 0 ) && ( a == b ) ) return 0 ; if ( ( a == b ) ) return a ; if ( ( a > b ) ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } private static int findValue ( int x , int y , int z ) { int g = gcd ( y , z ) ; return ( x * g ) / gcd ( x , g ) ; }
public static void foot ( double a , double b , double c , double d , double x1 , double y1 , double z1 ) { double k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) ; ; double x2 = a * k + x1 ; ; double y2 = b * k + y1 ; ; double z2 = c * k + z1 ; ; System . out . print ( " x2 ▁ = " + " { : . 1 } " . format ( x2 ) + " ▁ " ) ; System . out . print ( " y2 ▁ = " + " { : . 1 } " . format ( y2 ) + " ▁ " ) ; System . out . print ( " z2 ▁ = " + " { : . 1 } " . format ( z2 ) + " ▁ " ) ; }
public static int [ ] [ ] c ( ) { int [ ] [ ] c = new int [ 2 ] [ 2 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { c [ i ] [ 0 ] = input ( ) ; c [ i ] [ 1 ] = input ( ) ; } if ( c [ 0 ] [ 0 ] == c [ 1 ] [ 2 ] && c [ 0 ] [ 1 ] == c [ 1 ] [ 1 ] && c [ 0 ] [ 2 ] == c [ 1 ] [ 0 ] ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } return c ; }
public static int getMinimumOps ( int [ ] ar ) { int n = ar . length ; int small = Math . min ( ar , n ) ; int large = Math . max ( ar , n ) ; int [ ] [ ] dp = new int [ large + 1 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = new int [ n ] ; for ( int j = small ; j < large ; j ++ ) { dp [ 0 ] [ j ] = Math . abs ( ar [ 0 ] - j ) ; } } for ( int i = 1 ; i < n ; i ++ ) { int minimum = 10 * 9 ; for ( int j = small ; j < large ; j ++ ) { minimum = Math . min ( minimum , dp [ i - 1 ] [ j ] ) ; dp [ i ] [ j ] = minimum + Math . abs ( ar [ i ] - j ) ; } } int ans = 10 * 9 ; for ( int j = small ; j < large ; j ++ ) { ans = Math . min ( ans , dp [ n - 1 ] [ j ] ) ; } return ans ; }
public static final double PI = 3.14159265 ; public static final double areaLeaf ( double a ) { return ( a * a * ( PI / 2 - 1 ) ) ; }
public static int removeAlternate ( int n ) { if ( ( n == 1 ) && ( n % 2 == 0 ) ) return 1 ; if ( ( n % 2 == 0 ) && ( n % 3 == 0 ) ) return 2 * removeAlternate ( n / 2 ) - 1 ; else return 2 * removeAlternate ( ( ( n - 1 ) / 2 ) ) + 1 ; }
public static void check ( int n , int m ) { if ( ( n == 2 || m == 2 || n % m == 0 ) && ( n % m == 0 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
public static boolean solve ( int [ ] a , int n , int m ) { int [ ] b = new int [ a . length ] ; boolean flag = false ; for ( int i = 0 ; i < a . length ; i ++ ) { int curr = a [ i ] / n ; if ( curr >= 3 ) flag = true ; if ( curr >= 2 ) b [ i ] = curr ; } if ( m % 2 == 1 ) { if ( ! flag ) return false ; } return Arrays . binarySearch ( b , 0 , n ) >= 0 ; }
public static int negProdSubArr ( int [ ] arr , int n ) { int positive = 1 ; int negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] > 0 ) && ( arr [ i ] < 1 ) ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( ( i > 0 ) && ( arr [ i ] > 1 ) ) arr [ i ] *= arr [ i - 1 ] ; if ( ( arr [ i ] == 1 ) && ( arr [ i ] > 0 ) ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
public static int negProdSubArr ( int [ ] arr , int n ) { int positive = 1 ; int negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] > 0 ) && ( arr [ i ] < 1 ) ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( ( i > 0 ) && ( arr [ i ] > 1 ) ) arr [ i ] *= arr [ i - 1 ] ; if ( ( arr [ i ] == 1 ) && ( arr [ i ] > 0 ) ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
public static int solve ( ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int k = scanner . nextInt ( ) ; int cnt = 1 ; int ans = 0 ; while ( cnt <= k && cnt < n ) { cnt *= 2 ; ans ++ ; } if ( cnt >= n ) { return ans ; } else { ans += ( n - cnt ) / k ; ans += 1 == ( n - cnt ) % k ? 0 : 1 ; return ans ; } }
public static int GCD ( int a , int b ) { while ( a % b != 0 ) { a = b ; b = a % b ; } return b ; final int LCM = a * b / GCD ( a , b ) ; final String l = JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ GCD " ) ; int x = Integer . parseInt ( l ) , y = Integer . parseInt ( l ) , a = Integer . parseInt ( l ) , b = Integer . parseInt ( l ) ; int lcm = LCM ( x , y ) ; System . out . println ( b / lcm - ( a - 1 ) / lcm ) ; }
public static int minRemove ( int [ ] arr , int n ) { int [ ] LIS = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return ( n - len ) ; }
public static void printMax ( int [ ] a , int n , int k ) { int [ ] maxUpToDate = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { maxUpToDate [ i ] = 0 ; } int [ ] s = new int [ n ] ; s [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ( s [ i ] > 0 ) && a [ s [ i - 1 ] ] < a [ i ] ) { maxUpToDate [ s [ i ] ] = i - 1 ; -- s [ i ] ; } s [ i ] ++ ; } while ( ( s [ 0 ] > 0 ) && ( s [ 0 ] < n ) ) { maxUpToDate [ s [ 0 ] ] = n - 1 ; -- s [ 0 ] ; } int j = 0 ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { while ( ( j < i || maxUpToDate [ j ] < i + k - 1 ) ) { j ++ ; } System . out . print ( a [ j ] + " ▁ " ) ; } System . out . println ( ) ; }
public static String compute ( ) { int ans = Math . max ( Integer . parseInt ( String . valueOf ( a * b ) ) , Integer . parseInt ( String . valueOf ( a * b ) ) ) ; return String . valueOf ( ans ) ; }
public static int countWindowDistinct ( int [ ] win , int k ) { int distCount = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int j = 0 ; while ( j < i ) { if ( ( win [ i ] == win [ j ] ) ) break ; else j ++ ; } if ( ( j == i ) ) distCount ++ ; } return distCount ; }
public static int evenNumSubstring ( String str ) { int length = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < length ; i += 1 ) { int temp = ( char ) str . charAt ( i ) - ( char ) '0' ; if ( ( temp % 2 == 0 ) && ( temp % 3 == 0 ) ) { count += ( i + 1 ) ; } } return count ; if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " win " ) ) { str = str . substring ( "1" , "2" ) ; str = str . substring ( "3" , "4" ) ; System . out . println ( evenNumSubstring ( str ) ) ; } return count ; }
public static int max ( int index , int cnt , int [ ] [ ] dp , int n , int m , int k ) { if ( ( index == n ) && ( cnt == k ) ) { if ( ( cnt == k ) ) return 1 ; else return 0 ; } if ( ( dp [ index ] [ cnt ] != - 1 ) && ( dp [ index ] [ cnt ] != - 1 ) ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; dp [ index ] [ cnt ] = ans ; return dp [ index ] [ cnt ] ; }
public static final int getSum ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= Integer . MAX_VALUE ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) summ += i ; else { summ += i ; summ += n / i ; } } } return summ - n ; } public static void printAliquot ( int n ) { System . out . print ( n + " ▁ " ) ; Set < Integer > s = new HashSet < Integer > ( ) ; s . add ( n ) ; int nextt = 0 ; while ( n > 0 ) { n = getSum ( n ) ; if ( n == s . size ( ) ) { System . out . println ( " Repeats ▁ with " + n ) ; break ; } System . out . print ( n + " ▁ " ) ; s . add ( n ) ; } } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " windows " ) ) { printAliquot ( 12 ) ; } }
public static int n ( ) { int n = 0 , a , b ; int lista [ ] = new int [ n ] ; int listb [ ] = new int [ n ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( k + 1 < n ) { System . out . print ( 1 + " ▁ " ) ; } else { System . out . print ( 2 + " ▁ " ) ; } } for ( int k = 0 ; k < n ; k ++ ) { if ( k + 1 < n ) { System . out . print ( a + " ▁ " ) ; } else { System . out . print ( a + " ▁ " ) ; } } return n ; }
public static void reverseArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { arr [ i ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] ; } arr [ 0 ] = 5 ; arr [ 1 ] = 3 ; arr [ 2 ] = 7 ; arr [ 3 ] = 2 ; arr [ 4 ] = 1 ; arr [ 5 ] = 6 ; n = arr . length ; reverseArray ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
public static void printSeriesSum ( int N ) { double sum = 0 ; ; double a = 1 ; int cnt = 0 ; boolean flag = true ; sum += a ; while ( ( cnt < N ) && ( flag ) ) { double nextElement ; if ( ( flag ) || ( cnt < N ) ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * ( 3 / 2 ) ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } System . out . println ( sum ) ; }
public static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } else { return gcd ( b % a , a ) ; } int t = Integer . MAX_VALUE ; while ( t > 0 ) { t -- ; a = Integer . parseInt ( input . readLine ( ) ) ; b = Integer . parseInt ( input . readLine ( ) ) ; int c = gcd ( a , b ) ; a = a / c ; b = b / c ; if ( a == b ) { int ans1 = 1 ; int ans2 = 0 ; if ( a % 2 == 0 || b % 2 == 0 ) { ans1 = 1 ; ans2 = 1 ; } else { ans1 = a * b / 2 + 1 ; ans2 = a * b / 2 ; } System . out . println ( ans1 + " ▁ " + ans2 ) ; } } return ans1 ; }
public static final int [ ] sieve ( int L , int R ) { int sz = ( int ) 1e5 ; ; boolean [ ] isPrime = new boolean [ sz + 1 ] ; isPrime [ 0 ] = isPrime [ 1 ] = false ; ; for ( int i = 2 ; i <= ( int ) Math . sqrt ( sz ) ; i ++ ) { if ( ( isPrime [ i ] ) && ( i < sz ) ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } ; } } final int minDifference = L ; final int R = R ; int fst = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( ( isPrime [ i ] ) && ( i < L ) ) { fst = i ; break ; } } int snd = 0 ; for ( int i = fst + 1 ; i <= R ; i ++ ) { if ( ( isPrime [ i ] ) && ( i < L ) ) { snd = i ; break ; } } if ( ( snd == 0 ) || ( snd == 1 ) ) return new int [ ] { - 1 , 0 } ; int diff = snd - fst ; int left = snd + 1 ; int right = R ; for ( int i = left ; i <= right ; i ++ ) { if ( ( isPrime [ i ] ) && ( i - snd <= diff ) ) { fst = snd ; snd = i ; diff = snd - fst ; } } return new int [ ] { diff } ; }
public static int getMaxLength ( int [ ] arr , int n ) { int start = 0 ; int preCnt = 0 ; while ( ( start < n ) && arr [ start ] == 1 ) { preCnt = preCnt + 1 ; start = start + 1 ; } int end = n - 1 ; int suffCnt = 0 ; while ( ( end >= 0 ) && arr [ end ] == 1 ) { suffCnt = suffCnt + 1 ; end = end - 1 ; } if ( ( start > end ) || ( start < 0 ) ) { return n ; } int midCnt = 0 ; int i = start ; int result = 0 ; while ( ( i <= end ) && ( arr [ i ] == 1 ) ) { if ( ( arr [ i ] == 1 ) || ( arr [ i ] == 0 ) ) { midCnt = midCnt + 1 ; result = Math . max ( result , midCnt ) ; } else { midCnt = 0 ; } i = i + 1 ; } return Math . max ( result , preCnt + suffCnt ) ; } if ( Main . isWindows ( ) ) { int [ ] arr = { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; n = arr . length ; System . out . println ( getMaxLength ( arr , n ) ) ; } return n ; }
public static int INF = 10 * 20 ; int d = map . get ( Integer . parseInt ( input . nextLine ( ) ) ) ; int n = map . get ( Integer . parseInt ( input . nextLine ( ) ) ) ; int [ ] temp = new int [ d ] ; for ( int i = 0 ; i < d ; i ++ ) temp [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; temp [ 0 ] = 0 ; int [ ] alst = new int [ n ] ; int [ ] blst = new int [ n ] ; int [ ] clst = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = map . get ( Integer . parseInt ( input . nextLine ( ) ) ) ; int b = map . get ( Integer . parseInt ( input . nextLine ( ) ) ) ; int c = map . get ( Integer . parseInt ( input . nextLine ( ) ) ) ; alst [ i ] = a ; blst [ i ] = b ; clst [ i ] = c ; } int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( alst [ i ] <= temp [ 1 ] && temp [ 1 ] <= blst [ i ] ) ) dp [ 1 ] [ i ] = - INF ; } for ( int i = 2 ; i <= d ; i ++ ) { int t = temp [ i ] ; for ( int j = 0 ; j < n ; j ++ ) { if ( alst [ j ] <= t && t <= blst [ j ] ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ x ] + Math . abs ( clst [ j ] - clst [ x ] ) , 0 ) ; } } System . out . println ( Math . max ( dp [ d ] , dp [ i ] ) ) ; return dp [ d ] ; }
public static void f ( String s ) { for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) < s . charAt ( i - 1 ) ) { System . out . println ( " YES " ) ; System . out . println ( i + " ▁ " + i + " ▁ " ) ; return ; } } System . out . println ( " NO " ) ; }
public static double sqroot ( double s ) { double pSq = 0 ; ; int N = 0 ; for ( int i = ( int ) s ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( ( j * j == i ) && ( j * j == i ) ) { pSq = i ; N = j ; break ; } } if ( ( pSq > 0 ) && ( pSq < ( N + 1 ) ) ) break ; } double d = s - pSq ; double P = d / ( 2.0 * N ) ; double A = N + P ; double sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] arr = Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int ans = - 1 ; int temp = 0 ; Set < Integer > seen = new HashSet < Integer > ( ) ; int p = 0 ; while ( seen . size ( ) != n ) { ans ++ ; if ( p % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && arr [ i ] <= temp ) { seen . add ( i ) ; temp ++ ; } } p ++ ; } else { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i != 0 && arr [ i ] <= temp ) { seen . add ( i ) ; temp ++ ; } } p ++ ; } } System . out . println ( ans ) ; return ans ; }
public static void main ( String [ ] args ) { int R = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ R ▁ and ▁ N ▁ to ▁ solve " ) ) ; int N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ N ▁ to ▁ solve " ) ) ; if ( ! ( R | N ) . equals ( R ) ) break ; int geta = 20 ; int buildings [ ] = new int [ geta * 2 ] ; for ( ; ; ) { int xl = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ xl ▁ and ▁ xr ▁ to ▁ solve " ) ) ; int xr = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ h ▁ and ▁ l ▁ to ▁ solve " ) ) ; for ( int i = xl + geta ; i < xr + geta ; i ++ ) buildings [ i ] = Math . max ( buildings [ i ] , h ) ; } int left = 0 , right = 20 ; for ( ; ; ) { int mid = ( left + right ) / 2 ; boolean flag = true ; for ( int i = - R + geta ; i < R + geta ; i ++ ) { if ( i < geta ) { int y = Math . pow ( R * R - ( i - geta + 1 ) * ( i - geta + 1 ) , 0.5 ) ; flag &= buildings [ i ] >= y - R + mid ; } else { int y = Math . pow ( R * R - ( i - geta ) * ( i - geta ) , 0.5 ) ; flag &= buildings [ i ] >= y - R + mid ; } } if ( flag ) left = mid ; else right = mid ; } System . out . println ( " { : . 20f } " . format ( left ) ) ; }
public static void main ( String [ ] s ) { for ( String s : new String [ ] { new String ( open ( 0 ) ) } . substring ( 2 ) ) { int i = r = 0 ; for ( int x : Collections . list ( s . split ( " ▁ " ) ) ) { i ++ ; } ; r = ( i == 0 ) ? r : r + 1 ; System . out . println ( r + 1 ) ; } }
public static void main ( String [ ] args ) { while ( true ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number : ▁ " ) ) ; if ( n == 0 ) break ; System . out . println ( String . valueOf ( Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number : ▁ " ) ) ) . substring ( 2 ) ) ; } }
public static int maxAlternateSum ( int arr [ ] , int n ) { if ( ( n == 1 ) && ( arr [ 0 ] == 0 ) ) return arr [ 0 ] ; int dec [ ] = new int [ n + 1 ] ; int inc [ ] = new int [ n + 1 ] ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] > arr [ i ] ) && ( arr [ j ] < arr [ i ] ) ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( ( arr [ j ] < arr [ i ] ) && ( flag == 1 ) ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( result < inc [ i ] ) && ( result < dec [ i ] ) ) result = inc [ i ] ; if ( ( result < dec [ i ] ) && ( result < inc [ i ] ) ) result = dec [ i ] ; } return result ; }
public static void generateArr ( int [ ] arr , int n ) { if ( ( n == 1 ) && ( arr [ 0 ] == 0 ) ) { System . out . println ( arr [ 0 ] ) ; ; return ; } ; int [ ] barr = new int [ n ] ; barr [ 0 ] = arr [ 0 ] & arr [ 1 ] ; ; barr [ n - 1 ] = arr [ n - 1 ] & arr [ n - 2 ] ; ; for ( int i = 1 ; i < n - 1 ; i ++ ) { barr [ i ] = arr [ i - 1 ] & arr [ i + 1 ] ; ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( barr [ i ] + " ▁ " ) ; ; } ; }
public static void ReplaceElements ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
public static void ReplaceElements ( int [ ] arr , int n ) { if ( ( n <= 1 ) && ( arr [ 0 ] == 0 ) ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev + arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev + arr [ n - 1 ] ; if ( System . getProperty ( " os . arch " ) . contains ( " i386" ) ) { arr [ 0 ] = 2 ; arr [ 1 ] = 3 ; arr [ 2 ] = 4 ; arr [ 3 ] = 5 ; arr [ 4 ] = 6 ; } else { arr [ 0 ] = 2 ; arr [ 1 ] = 3 ; arr [ 2 ] = 4 ; arr [ 3 ] = 5 ; arr [ 4 ] = 6 ; } int n = arr . length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
public static int countTriplets ( int A , int B , int C ) { int ans = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( ( i * k > j * j ) && ( i * k > j * k ) ) { ans ++ ; } } } } return ans ; }
public static final void main ( String [ ] args ) { final int MAX = 100000 ; boolean [ ] prime = new boolean [ MAX + 1 ] ; prime [ 0 ] = true ; for ( int p = 2 ; p <= Integer . MAX_VALUE ; p ++ ) { if ( ( prime [ p ] == true ) && ( prime [ p * p ] == true ) ) { for ( int i = p * p ; i < MAX + 1 ; i += p ) { prime [ i ] = false ; } ; } } final int smallestPrime = 10 * ( d - 1 ) ; ; final int r = ( 10 * d ) - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( prime [ i ] ) ) { System . out . println ( smallestPrime + " ▁ " + largestPrime + " ▁ " + i ) ; } ; } ; final int l = 10 * ( d - 1 ) ; ; final int r = ( 10 * d ) - 1 ; for ( int i = r ; i >= l ; i -- ) { if ( ( prime [ i ] ) ) { System . out . println ( smallestPrime + " ▁ " + largestPrime + " ▁ " + i ) ; } ; } ; if ( args . length == 0 ) { SieveOfEratosthenes ( ) ; } ; int queries [ ] = { 2 , 5 } ; int q = args . length ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( smallestPrime + " ▁ " + queries [ i ] + " ▁ " + largestPrime + " ▁ " + queries [ i ] ) ; } ; }
public static int INF = 10 * 20 ; int n = map . get ( Integer . parseInt ( input . nextLine ( ) ) ) ; int m = map . get ( Integer . parseInt ( input . nextLine ( ) ) ) ; int [ ] dist = new int [ n ] ; int [ ] weth = new int [ m ] ; for ( ; n > 0 ; n -- ) { dist [ n - 1 ] = Integer . parseInt ( input . nextLine ( ) ) ; } for ( ; m > 0 ; m -- ) { weth [ m - 1 ] = Integer . parseInt ( input . nextLine ( ) ) ; } int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = INF ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = n ; j > 0 ; j -- ) { dp [ j ] = Math . min ( dp [ j ] , dp [ j - 1 ] + dist [ j - 1 ] * weth [ i ] ) ; } } System . out . println ( dp [ n ] ) ; return dp [ n ] ; }
n , k , x ) { int [ ] ls = map ( input ) . toArray ( ) ; for ( int m = 1 ; m <= k ; m ++ ) ls [ ls . length - m ] = x ; System . out . println ( Arrays . toString ( ls ) ) ; }
public static void main ( String [ ] args ) throws Exception { final String inputPath = System . getProperty ( " test . src " , " . " ) ; if ( inputPath == null ) { final BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; final int n = Integer . parseInt ( br . readLine ( ) ) , m = Integer . parseInt ( br . readLine ( ) ) , a = Integer . parseInt ( br . readLine ( ) ) , d = Integer . parseInt ( br . readLine ( ) ) ; final List < Integer > t = Arrays . asList ( Integer . parseInt ( br . readLine ( ) ) , Integer . parseInt ( br . readLine ( ) ) , Integer . parseInt ( br . readLine ( ) ) , Integer . parseInt ( br . readLine ( ) ) , Integer . parseInt ( br . readLine ( ) ) ) ; final int n1 = m ; final int a = a ; final int d = d ; final List < Integer > t = Arrays . asList ( n1 , a * n1 ) ; insort ( t , a * n1 ) ; int pred = 0 ; int k = 0 ; n = 0 ; int step = d / a + 1 ; int answer = 0 ; int fl = 0 ; for ( int i = 0 ; i < t . size ( ) ; i ++ ) { if ( t . get ( i ) > pred ) { if ( fl == 0 ) { n = ( i - pred + ( pred % a ) ) / a ; if ( n != 0 ) { k += ( n / step ) * step - step * ( n % step == 0 ) + 1 ; if ( k > n1 ) { k = n1 ; fl = 1 ; } } if ( ( k * a + d >= i ) && ( n != 0 ) ) { pred = k * a + d ; } else { pred = i + d ; k = Math . floor ( pred / a ) ; answer ++ ; } k = Math . min ( Math . floor ( pred / a ) , n1 ) ; answer += n / step + ( n % step != 0 ) ; } else { answer ++ ; pred = i + d ; } } if ( i == a * n1 ) fl = 1 ; } } System . out . println ( MessageFormat . format ( " { 0 }
public static int main ( String [ ] args ) { int testCase = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ test " ) ) ; while ( testCase > 0 ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ test " ) ) ; int sum = n * ( n + 1 ) / 2 ; int i = 1 ; while ( i <= n ) { sum -= i * 2 ; i *= 2 ; } System . out . println ( Integer . toString ( sum ) ) ; testCase -- ; } return 0 ; }
s ; boolean x = true ; HashMap < Integer , Integer > dt = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s . get ( i ) < dt . get ( i ) ) dt . put ( i , ++ cnt ) ; else dt . put ( i , 1 ) ; } int cnt = 0 ; x = true ; for ( Entry < Integer , Integer > entry : dt . entrySet ( ) ) { if ( entry . getValue ( ) % 2 != 0 && cnt < 1 ) cnt ++ ; else if ( entry . getValue ( ) % 2 != 0 && cnt >= 1 ) { x = false ; break ; } } if ( x ) System . out . println ( " First " ) ; else if ( ! x && s . size ( ) % 2 == 0 ) System . out . println ( " Second " ) ; else if ( ! x && s . size ( ) % 2 != 0 ) System . out . println ( " First " ) ; }
public static int reverse ( int n ) { int rev = 0 ; while ( ( n != 0 ) && ( n % 10 == 0 ) ) { rev = ( rev * 10 ) + ( n % 10 ) ; n /= 10 ; } return rev ; }
public static void disp ( int rowNo , int block ) { System . out . println ( rowNo * block ) ; final int ht = ht / h ; final int calculate = ( 4 * a ) / l ; final int noBlock = ( h < w ) ? h : w ; if ( ( h < w ) && ( noBlock < h ) ) { rowNo = row ( ht , w ) ; } else { rowNo = row ( ht , h ) ; } disp ( rowNo , noBlock ) ; if ( Main . isWindows ) { l = 50 ; w = 20 ; h = 35 ; a = 700 ; ht = 140 ; calculate = l ; calculate = w ; calculate = h ; calculate = w ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate = h ; calculate =
static final String [ ] bin = { "000" , "001" , "010" , "011" , "100" , "101" , "110" , "111" } ; ; static final int maxFreq = 16 ; String binary = " " ; ; for ( int i = 0 ; i < binary . length ( ) ; i ++ ) binary += bin [ ( int ) binary . charAt ( i ) - '0' ] ; binary = binary . substring ( 0 , binary . length ( ) - 1 ) ; int count = 1 ; int prev = - 1 ; int j = 0 ; for ( int i = binary . length ( ) - 1 ; i >= 0 ; i -- ) { if ( ( binary . charAt ( i ) == '1' ) && ( binary . charAt ( i + 1 ) == '1' ) ) { count = Math . max ( count , j - prev ) ; prev = j ; } j ++ ; } return new String [ ] { binary , count } ; }
public static boolean isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; } public static void encryptString ( String s , int n , int k ) { int [ ] cv = new int [ n ] ; int [ ] cc = new int [ n ] ; if ( ( isVowel ( s . charAt ( 0 ) ) ) && ( isVowel ( s . charAt ( 1 ) ) ) ) cv [ 0 ] = 1 ; else cc [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { cv [ i ] = cv [ i - 1 ] + isVowel ( s . charAt ( i ) ) ; cc [ i ] = cc [ i - 1 ] + ( isVowel ( s . charAt ( i ) ) == false ) ? 1 : 0 ; } String ans = " " ; int prod ; prod = cc [ k - 1 ] * cv [ k - 1 ] ; ans += Integer . toString ( prod ) ; for ( int i = k ; i < s . length ( ) ; i ++ ) { prod = ( ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ) ; ans += Integer . toString ( prod ) ; } }
public static int harmonicMean ( int [ ] arr , int [ ] freq , int n ) { double sm = 0 ; double frequencySum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sm = sm + freq [ i ] / arr [ i ] ; frequencySum = frequencySum + freq [ i ] ; } return ( Math . round ( frequencySum / sm ) ) ; int [ ] num = { 13 , 14 , 15 , 16 , 17 } ; int [ ] freq = { 2 , 5 , 13 , 7 , 3 } ; n = num . length ; System . out . println ( " { : . 4 } " . format ( harmonicMean ( num , freq , n ) ) ) ; }
static final double polyarea ( int n , double a ) { if ( ( a < 0 && n < 0 ) || ( a > n && n > 0 ) ) return - 1 ; double A = ( a * a * n ) / ( 4 * Math . tan ( ( 180 / n ) * Math . PI / 180 ) ) ; return A ; }
public static final int gcd ( int a , int b ) { if ( ( a == 0 ) && ( b == 0 ) ) return b ; ; if ( ( b == 0 ) && ( a == 0 ) ) return a ; ; if ( ( a == b ) && ( a > b ) ) return gcd ( a - b , b ) ; ; return gcd ( a , b - a ) ; ; } static final int lcm ( int a , int b ) { return ( a / lcm ( a , b ) * b ) ; } static final int getMinValue ( int c ) { int ans = Integer . MAX_VALUE ; ; for ( int i = 1 ; i <= Integer . MAX_VALUE ; i ++ ) { if ( ( c % i ) == 0 && lcm ( i , c / i ) == c ) ans = Math . min ( ans , Math . max ( i , c / i ) ) ; } ; return ( int ) ans ; }
public static int findNmin ( ) { int M = Integer . parseInt ( input . nextLine ( ) ) ; int Nmin = Integer . parseInt ( input . nextLine ( ) ) ; int Nmax = Integer . parseInt ( input . nextLine ( ) ) ; if ( M + Nmin + Nmax == 0 ) break ; int [ ] P = new int [ M ] ; for ( ; P [ 0 ] != 0 ; P [ 0 ] = Integer . parseInt ( input . nextLine ( ) ) ) ; int [ ] dif = new int [ M ] ; for ( int i = 0 ; i < P . length - 1 ; i ++ ) { dif [ i + 1 ] = P [ i ] - P [ i + 1 ] ; } int ans = Nmin ; int tmp = dif [ Nmin ] ; for ( int i = Nmin + 1 ; i <= Nmax ; i ++ ) { if ( dif [ i ] >= tmp ) { ans = i ; tmp = dif [ i ] ; } } System . out . println ( ans ) ; return ans ; }
public static R = new R ( ) { public void main ( String [ ] args ) { List < Integer > list = Arrays . asList ( Integer . parseInt ( input ) . split ( " ▁ " ) ) ; int b = 0 , q = 0 , i = 0 , m = 0 ; Set < Integer > a = new HashSet < Integer > ( R . class . getClassLoader ( ) . getResourceAsStream ( " / " + R . class . getName ( ) + " . class " ) ) ; int c = 0 ; for ( ; ; ) { if ( Math . abs ( b ) > i ) break ; if ( b != 0 ) c ++ ; b *= q ; } System . out . println ( c < 32 ? " inf " : " " ) ; } }
public static void main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( System . in . readLine ( ) ) , m = new HashMap < > ( ) ; int [ ] x = map . get ( n ) ; for ( int i = 0 , v = x . length ; i < v ; i ++ ) { m . put ( x [ i ] , i + 1 ) ; } m = Collections . unmodifiableMap ( m ) ; System . out . println ( m . get ( Arrays . asList ( m ) . get ( 0 ) ) + " ▁ " + m . get ( Arrays . asList ( m ) . get ( m . size ( ) - 1 ) ) ) ; } }
static int findIndex ( int n ) { double fibo = 2.078087 * Math . log ( n ) + 1.672276 ; return Math . round ( fibo ) ; }
public static boolean isSmaller ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( ( n1 < n2 ) && ( n2 < n1 ) ) return true ; if ( ( n2 < n1 ) && ( n1 < n2 ) ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ( str1 . charAt ( i ) < str2 . charAt ( i ) ) && ( str1 . charAt ( i ) > str2 . charAt ( i ) ) ) return true ; else if ( ( str1 . charAt ( i ) > str2 . charAt ( i ) ) && ( str1 . charAt ( i ) < str2 . charAt ( i ) ) ) return false ; } return false ; } public static void findDiff ( String str1 , String str2 ) { if ( ( isSmaller ( str1 , str2 ) ) && ( isSmaller ( str1 , str2 ) ) ) { String temp = str1 ; str1 = str2 ; str2 = temp ; } String str3 = " " ; int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; str1 = str1 . substring ( 0 , n1 ) ; str2 = str2 . substring ( 0 , n2 ) ; int carry = 0 ; for ( int i = 0 ; i < n2 ; i ++ ) { int sub = ( ( Character . digit ( str1 . charAt ( i ) , 16 ) - '0' ) << 4 ) + ( ( Character . digit ( str2 . charAt ( i ) , 16 ) - '0' ) << 4 ) + carry ; if ( ( sub < 0 ) && ( sub < 10 ) ) { sub = sub + 10 ; carry = 1 ; } else carry = 0 ; str3 = str3 + Integer . toString ( sub ) ; } for ( int i = n2 ; i < n1 ; i ++ ) { sub = ( ( Character . digit ( str1 . charAt ( i ) , 16 ) - '0' ) << 4 ) + ( ( Character . digit ( str2 . charAt ( i ) , 16 ) - '0' ) << 4 ) + carry ; if ( ( sub < 0 ) && ( sub < 10 ) ) { sub = sub + 10 ; carry = 1 ; } else carry = 0 ; str3 = str3 + Integer . toString ( sub ) ; } str3 = str3 . substring ( 0 , str3 . length ( ) ) ; }
public static int minSwaps ( String s1 , String s2 ) { int c0 = 0 ; int c1 = 0 ; ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '1' ) || ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) ) c0 ++ ; else if ( ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) || ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '1' ) ) c1 ++ ; } int ans = c0 / 2 + c1 / 2 ; ; if ( ( c0 % 2 == 0 && c1 % 2 == 0 ) || ( ( c0 + c1 ) % 2 == 0 ) ) return ans ; else if ( ( ( c0 + c1 ) % 2 == 0 ) && ( ( c0 + c1 ) % 2 == 1 ) ) return ans + 2 ; else return - 1 ; if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { s1 = "0011" ; s2 = "1111" ; ans = minSwaps ( s1 , s2 ) ; ; System . out . println ( ans ) ; } else if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { s1 = "0011" ; s2 = "1111" ; ans = minSwaps ( s1 , s2 ) ; ; System . out . println ( ans ) ; } else if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { s1 = "0011" ; s2 = "1111" ; ans = minSwaps ( s1 , s2 ) ; ; System . out . println ( ans ) ; } else if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { s1 = "0011" ; s2 = "1111" ; ans = minSwaps ( s1 , s2 ) ; ; System . out . println ( ans ) ; } else if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { s1 = "0011" ; s2 = "1111" ; ans = minSwaps ( s1 , s2 ) ; ; System . out . println ( ans ) ; } return ans ; }
class SegmentTree { private static final int MAX = - 1 ; public int max ( int a , int b ) { if ( a < b ) return b ; else return a ; } private int N = 1 ; while ( ( N < n ) && ( N > 0 ) ) N *= 2 ; seg = new int [ N * 2 - 1 ] ; for ( int k = 0 ; k < N ; k ++ ) { k += N - 1 ; seg [ k ] = a ; while ( ( 0 < k ) && ( k > 0 ) ) { k = ( k - 1 ) / 2 ; ; seg [ k ] = max ( seg [ 2 * k + 1 ] , seg [ 2 * k + 2 ] ) ; } } private int max ( int a , int b , int k , int l , int r ) { if ( r <= a || b <= l ) return 0 ; if ( a <= l && r <= b ) return seg [ k ] ; else { int vl = max ( a , b , k * 2 + 1 , l , ( l + r ) / 2 ) ; int vr = max ( a , b , k * 2 + 2 , ( l + r ) / 2 , r ) ; return max ( vl , vr ) ; } } public int maxQuery ( int a , int b ) { return max ( a , b , 0 , 0 , N ) ; } }
public static void main ( String [ ] a ) { Scanner scan = new Scanner ( System . in ) ; int p = scan . nextInt ( ) ; int c = sum ( ( i - p ) * Integer . parseInt ( y ) ) ; System . out . println ( new ArrayList < String > ( ) . balance ( c > 0 ) ) ; System . out . println ( new ArrayList < String > ( ) . balance ( c < 0 ) ) ; }
public static void normalSieve ( int n ) { int prime [ ] = { 0 } ; ; int i = 3 ; ; while ( ( i * i < n ) && ( prime [ ( int ) ( i / 2 ) ] == 0 ) ) { if ( ( prime [ ( int ) ( i / 2 ) ] == 1 ) || ( prime [ ( int ) ( i / 2 ) ] == 2 ) ) { int j = i * i ; while ( ( j < n ) && ( prime [ ( int ) ( j / 2 ) ] == 0 ) ) { prime [ ( int ) ( j / 2 ) ] = 1 ; j += i * 2 ; } } i += 2 ; } ; System . out . print ( 2 + " ▁ " ) ; i = 3 ; ; while ( ( i < n ) && ( prime [ ( int ) ( i / 2 ) ] == 0 ) ) { if ( ( prime [ ( int ) ( i / 2 ) ] == 1 ) || ( prime [ ( int ) ( i / 2 ) ] == 2 ) ) { System . out . print ( i + " ▁ " ) ; } i += 2 ; } ; }
public static String toString ( ) { String txt = input ( ) ; String out = " " ; int cap = 0 ; int small = 0 ; for ( int i = 0 ; i < txt . length ( ) ; i ++ ) { if ( txt . charAt ( i ) == ' ▁ ' ) small ++ ; else cap ++ ; } if ( small >= cap ) for ( int i = 0 ; i < txt . length ( ) ; i ++ ) out += txt . charAt ( i ) . toLowerCase ( ) ; else for ( int i = 0 ; i < txt . length ( ) ; i ++ ) out += txt . charAt ( i ) ; System . out . println ( out ) ; return out ; }
public static int frequencyOfSmallest ( int n , int [ ] arr ) { int mn = arr [ 0 ] ; int freq = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] < mn ) && ( arr [ i ] > mn ) ) { mn = arr [ i ] ; freq = 1 ; } else if ( ( arr [ i ] == mn ) && ( arr [ i ] > mn ) ) { freq ++ ; } } return freq ; }
public static boolean isSubArray ( int [ ] A , int [ ] B , int n , int m ) { int i = 0 ; int j = 0 ; ; while ( ( i < n && j < m ) || ( j == m ) ) { if ( ( A [ i ] == B [ j ] ) && ( A [ i ] == B [ j ] ) ) { i ++ ; j ++ ; if ( ( j == m ) || ( A [ i ] == B [ j ] ) ) return true ; } else { i = i - j + 1 ; j = 0 ; } } return false ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; List < Integer > l = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) l . add ( Integer . parseInt ( input ( ) ) ) ; int ans = n - 1 ; int last = 0 ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) { ans += Math . abs ( last - i ) + 1 ; last = i ; } System . out . println ( ans ) ; }
public static int calculateSum ( int n , int k ) { int res = 1 ; int MOD = 1000000007 ; for ( int i = 0 ; i <= k ; i ++ ) { res = ( res * n ) % MOD ; } return res ; }
public static boolean ok ( String last4 ) { for ( int i = 0 ; i < 4 ; i ++ ) { String [ ] t = Arrays . copyOf ( last4 , last4 . length ( ) ) ; if ( i >= 1 ) t [ i ] = t [ i - 1 ] ; if ( " " . equals ( t [ i ] ) ) return false ; } return true ; }
public static int i = 0 ; int sumsell = 0 ; int sumn = 0 ; while ( true ) { try { int at = Integer . parseInt ( input . nextLine ( ) ) ; int n = Integer . parseInt ( input . nextLine ( ) ) ; sumsell += at * n ; sumn += n ; i ++ ; } catch ( EOFException e ) { break ; } } System . out . println ( sumsell ) ; System . out . println ( ( int ) ( sumn / i + 0.5 ) ) ; }
MAX = 100 ; public static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) { C [ j ] = C [ j ] + C [ j - 1 ] ; } } return C [ k ] ; }
public static void main ( String [ ] args ) { String string1 = JOptionPane . showInputDialog ( " Enter ▁ the ▁ first ▁ string : ▁ " ) ; System . out . print ( string1 + " \n " ) ; String string2 = JOptionPane . showInputDialog ( " Enter ▁ the ▁ second ▁ string : ▁ " ) ; System . out . print ( string2 + " \n " ) ; System . out . print ( " Are ▁ both ▁ strings ▁ same : " ) ; if ( ( string1 . equals ( string2 ) ) && ( string1 . equals ( string2 ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
public static final int pairCount ( int [ ] arr , int n ) { int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] > maxVal ) && ( arr [ i ] < maxVal ) ) { maxVal = arr [ i ] ; } } boolean [ ] prime = new boolean [ maxVal + 1 ] ; prime [ 0 ] = false ; prime [ 1 ] = false ; int k = ( int ) Math . sqrt ( maxVal ) + 1 ; for ( int p = 2 ; p <= k ; p += 1 ) { if ( ( prime [ p ] == true ) && ( prime [ p * 2 ] == true ) ) { for ( int i = p * 2 ; i < maxVal + 1 ; i += p ) { prime [ i ] = false ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( prime [ arr [ i ] ] ) && ( prime [ arr [ i + 1 ] ] ) ) { count ++ ; } } return ( count * ( count - 1 ) ) / 2 ; } if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; System . out . println ( ( int ) pairCount ( arr , n ) ) ; } return n ; }
public static final int getPrime ( int [ ] arr , int n ) { int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] > maxVal ) && ( arr [ i ] < maxVal ) ) { maxVal = arr [ i ] ; } } boolean [ ] prime = new boolean [ maxVal + 1 ] ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p <= Integer . MAX_VALUE ; p ++ ) { if ( ( prime [ p ] == true ) && ( arr [ p ] > maxVal ) && ( arr [ p ] < maxVal ) ) { for ( int i = p * 2 ; i < maxVal + 1 ; i ++ ) { prime [ i ] = false ; } } } int maximum = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( prime [ arr [ i ] ] ) && ( arr [ i ] > maxVal ) ) { maximum = Math . max ( maximum , arr [ i ] ) ; } } return maximum ; }
static String compute ( ) { return Long . toString ( Arrays . copyOf ( NUMBERS , 10 ) ) . substring ( 0 , 10 ) ; }
public static void findElements ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } arr [ 2 ] = - 6 ; arr [ 3 ] = 3 ; arr [ 5 ] = 5 ; arr [ 1 ] = 1 ; n = arr . length ; findElements ( arr , n ) ; }
public static void printDistinct ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) || ( i < n - 1 && ( arr [ i ] == arr [ i + 1 ] ) ) ) { while ( ( i < n - 1 && ( arr [ i ] == arr [ i + 1 ] ) ) || ( i < n - 1 && ( arr [ i ] == arr [ i + 1 ] ) ) ) { i ++ ; } ; } else { System . out . print ( arr [ i ] + " ▁ " ) ; } ; } arr = new int [ n ] ; arr [ 0 ] = 6 ; arr [ 1 ] = 10 ; arr [ 2 ] = 5 ; arr [ 3 ] = 4 ; arr [ 4 ] = 9 ; arr [ 5 ] = 120 ; arr [ 6 ] = 4 ; arr [ 7 ] = 6 ; arr [ 8 ] = 10 ; }
public static void main ( String [ ] args ) { int a , b ; a = Arrays . stream ( args ) . mapToInt ( Integer :: intValue ) . sum ( ) ; b = Arrays . stream ( args ) . mapToInt ( Integer :: intValue ) . sum ( ) ; System . out . println ( a * b ) ; }
public static int nthTerm ( int a , int b , int n ) { int z = 0 ; if ( ( n % 6 == 1 ) && ( a == 0 ) ) z = a ; else if ( ( n % 6 == 2 ) && ( b == 0 ) ) z = b ; else if ( ( n % 6 == 3 ) && ( b == 1 ) ) z = b - a ; else if ( ( n % 6 == 4 ) && ( a == 0 ) ) z = - a ; else if ( ( n % 6 == 5 ) && ( b == 1 ) ) z = - b ; if ( ( n % 6 == 0 ) && ( a == 0 ) ) z = - ( b - a ) ; return z ; }
public static int findSubSequence ( String s , int num ) { int res = 0 ; int i = 0 ; while ( ( num ) != 0 ) { if ( ( num & 1 ) != 0 ) { res += ( char ) s . charAt ( i ) - ( char ) '0' ; } i ++ ; num = num > > 1 ; } final int combinedSum = s . length ( ) ; int n = s . length ( ) ; int cSum = 0 ; int ran = ( 1 << n ) - 1 ; for ( int i = 0 ; i < ran + 1 ; i ++ ) { cSum += findSubSequence ( s , i ) ; } return cSum ; }
public static int minimumCost ( int [ ] cost , int n ) { int dp1 = 0 ; int dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
public static int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; ; }
static java . lang . String longSub ( String str , int k ) { int [ ] freq = new int [ 26 ] ; int start = 0 ; int maxLen = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { char ch = str . charAt ( i ) ; freq [ ( int ) ch - ' a ' ] ++ ; if ( ( freq [ ( int ) ch - ' a ' ] > k ) && ( maxLen < ( i - start ) ) ) { if ( ( freq [ ( int ) ch - ' a ' ] > k ) && ( maxLen < ( i - start ) ) ) { maxLen = i - start ; } while ( ( freq [ ( int ) ch - ' a ' ] > k ) && ( maxLen < ( n - start ) ) ) { freq [ ( int ) str . charAt ( start ) - ' a ' ] -- ; start = start + 1 ; } } } if ( ( maxLen < ( n - start ) ) && ( maxLen < ( n - start ) ) ) maxLen = n - start ; return " babcaag " ; }
public static final void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = Integer . parseInt ( input . nextLine ( ) ) ; ; int sa = sg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int a = Integer . parseInt ( input . nextLine ( ) ) , g = Integer . parseInt ( input . nextLine ( ) ) ; if ( a <= g ) { if ( sa + a - sg <= 500 ) { sa += a ; System . out . print ( " A " ) ; } else { sg += g ; System . out . print ( " G " ) ; } } else { if ( sg + g - sa <= 500 ) { sg += g ; System . out . print ( " G " ) ; } else { sa += a ; System . out . print ( " A " ) ; } } } }
public static class Solution { public static String toHex ( final int num ) { if ( num == 0 ) return "0" ; final String mp = "0123456789abcdef " ; String ans = " " ; for ( ; num > 0 ; num /= 8 ) { final int n = num & 15 ; final char c = mp . charAt ( n ) ; ans = c + ans ; num = num > > 4 ; } return ans . substring ( 0 , num ) ; } public static String toString ( final int num ) { if ( num == 0 ) return "0" ; final Solution sObj = new Solution ( ) ; int num = 26 ; String out = sObj . toHex ( num ) ; System . out . println ( out ) ; return out ; } }
public static List < String > numbers ( ) { int [ ] numbers = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ numbers : ▁ " ) . toArray ( ) ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; int start = 0 ; List < String > arr = new ArrayList < String > ( ) ; int count = 0 ; for ( int i = 0 ; i <= numbers . length ; i ++ ) { String string = " " ; int next = start ; for ( int j = 0 ; j <= numbers . length ; j ++ ) { if ( count < numbers . length ) { if ( j == next ) { string += ' L ' ; count ++ ; next += 2 ; if ( next >= numbers . length ) { start = 1 == start ? 0 : 1 ; } } else { string += " S " ; } } else { string += " S " ; } } arr . add ( string ) ; } if ( count < numbers . length ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; for ( String i : arr ) { System . out . println ( i ) ; } } return arr ; }
public static void longestString ( String str1 , String str2 ) { int count1 [ 26 ] = { 0 } ; int count2 [ 26 ] = { 0 } ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ ( char ) str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ ( char ) str2 . charAt ( i ) - ' a ' ] ++ ; String result = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . min ( count1 [ i ] , count2 [ i ] ) + 1 ; j ++ ) result = result + ( char ) ( ' a ' + i ) ; } System . out . println ( result ) ; }
public static int msb ( int x ) { int ret = 0 ; while ( ( ( x > > ( ret + 1 ) ) != 0 ) && ( ( x & ( 1 << i ) ) != 0 ) ) { ret = ret + 1 ; } return ret ; }
public static void q1 ( String s , int i ) { if ( ( i == s . length ( ) ) && ( s . charAt ( i ) == ' a ' ) ) { System . out . println ( " Yes " ) ; ; return ; } if ( ( s . charAt ( i ) == ' a ' ) && ( s . charAt ( i + 1 ) == ' b ' ) ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; } static void q2 ( String s , int i ) { if ( ( i == s . length ( ) ) && ( s . charAt ( i ) == ' a ' ) ) { System . out . println ( " No " ) ; ; return ; } if ( ( s . charAt ( i ) == ' a ' ) && ( s . charAt ( i + 1 ) == ' b ' ) ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; } static void q3 ( String s , int i ) { if ( ( i == s . length ( ) ) && ( s . charAt ( i ) == ' a ' ) ) { System . out . println ( " Yes " ) ; ; return ; } if ( ( s . charAt ( i ) == ' a ' ) && ( s . charAt ( i + 1 ) == ' b ' ) ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; } static void q4 ( String s , int i ) { if ( ( i == s . length ( ) ) && ( s . charAt ( i ) == ' a ' ) ) { System . out . println ( " No " ) ; ; return ; } if ( ( s . charAt ( i ) == ' a ' ) && ( s . charAt ( i + 1 ) == ' b ' ) ) { System . out . println ( " Yes " ) ; ; return ; } if ( ( s . charAt ( i ) == ' a ' ) && ( s . charAt ( i + 1 ) == ' b ' ) ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; } }
public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; PrintWriter write = new PrintWriter ( System . out ) ; List < String > ans = new ArrayList < > ( ) ; while ( scanner . hasNext ( ) ) { int M = Integer . parseInt ( scanner . nextLine ( ) ) ; if ( M == 0 ) break ; List < List < Integer > > P = new ArrayList < > ( ) ; for ( int i = 0 ; i < M ; i ++ ) P . add ( Arrays . asList ( scanner . nextLine ( ) . split ( " ▁ " ) ) ) ; memo = new HashMap < > ( ) ; final int i = M ; final int rest = scanner . nextInt ( ) ; if ( i == M ) return ; Integer key = ( i == 0 ) ? null : Integer . valueOf ( i ) ; if ( key == null ) return ; int res = 0 ; int a = P . get ( i ) , b = P . get ( i + 1 ) ; for ( int j = 0 ; j <= b ; j ++ ) { if ( rest - j * a < 0 ) break ; res += dfs ( i + 1 , rest - j * a ) ; } memo . put ( key , res ) ; return ; } int G = Integer . parseInt ( scanner . nextLine ( ) ) ; for ( int i = 0 ; i < G ; i ++ ) ans . add ( String . valueOf ( dfs ( 0 , Integer . parseInt ( scanner . nextLine ( ) ) ) ) ) ; }
public static void findTime ( String T , int K ) { int minutes = ( ( ( Character . digit ( T [ 0 ] , 10 ) - '0' ) * 10 + Character . digit ( T [ 1 ] , 10 ) - '0' ) * 60 + ( ( Character . digit ( T [ 2 ] , 10 ) - '0' ) * 10 + Character . digit ( T [ 3 ] , 10 ) - '0' ) ) ; ; minutes += K ; int hour = ( ( int ) ( minutes / 60 ) ) % 24 ; int min = minutes % 60 ; if ( ( hour < 10 ) && ( min < 10 ) ) { System . out . print ( " 0 " + hour + " : " ) ; } else { System . out . print ( String . format ( " % 02d : " , hour ) ) ; } if ( ( min < 10 ) && ( hour < 10 ) && ( min < 10 ) ) { System . out . print ( " 0 " + min ) ; } else { System . out . print ( String . format ( " % 02d : " , minTime ) ) ; } }
static void maxProductSum ( String string , int m ) { int n = string . length ( ) ; int maxProd = - ( Integer . MAX_VALUE ) , maxSum = - ( Integer . MIN_VALUE ) ; for ( int i = 0 ; i < n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( Character . digit ( string . charAt ( j ) , 16 ) - '0' ) ; sum = sum + ( Character . digit ( string . charAt ( j ) , 16 ) - '0' ) ; } maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } System . out . println ( " Maximum ▁ Product ▁ = " + maxProd ) ; System . out . println ( " Maximum ▁ Sum ▁ = " + maxSum ) ; }
public static int R = 3 ; int C = 3 ; java . util . List < Integer > cost = new java . util . ArrayList < Integer > ( ) ; int m = 0 ; int n = 0 ; if ( ( n < 0 || m < 0 ) && ( m == 0 ) ) { cost . add ( Integer . MAX_VALUE ) ; } else if ( ( m == 0 && n == 0 ) ) { cost . add ( cost . get ( m ) . get ( n ) ) ; } else { cost . add ( cost . get ( m ) . get ( n ) + Math . min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ) ; } final int min = cost . get ( m ) . get ( 0 ) ; if ( ( min < cost . get ( m ) . get ( 0 ) ) && ( min > cost . get ( m ) . get ( 1 ) ) ) { cost . add ( cost . get ( m ) . get ( 0 ) ) ; } else { cost . add ( cost . get ( m ) . get ( 0 ) ) ; } cost . add ( cost . get ( m ) . get ( 1 ) ) ; cost . add ( cost . get ( m ) . get ( 2 ) ) ; cost . add ( cost . get ( m ) . get ( 3 ) ) ; cost . add ( cost . get ( m ) . get ( 4 ) ) ; cost . add ( cost . get ( m ) . get ( 5 ) ) ; cost . add ( cost . get ( m ) . get ( 6 ) ) ; cost . add ( cost . get ( m ) . get ( 7 ) ) ; cost . add ( cost . get ( m ) . get ( 8 ) ) ; cost . add ( cost . get ( m ) . get ( 9 ) ) ; cost . add ( cost . get ( m ) . get ( 10 ) ) ; cost . add ( cost . get ( m ) . get ( 11 ) ) ; cost . add ( cost . get ( m ) . get ( 12 ) ) ; cost . add ( cost . get ( m ) . get ( 13 ) ) ; cost . add ( cost . get ( m ) . get ( 14 ) ) ; cost . add ( cost . get ( m ) . get ( 15 )
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] p = Arrays . copyOf ( input ( ) . toCharArray ( ) , n ) ; return Math . min ( Math . abs ( x - i ) , n ) ; }
public static int MAX = 100003 ; int [ ] ws = new int [ MAX ] ; int [ ] par = new int [ MAX * 2 ] ; public static int weight ( int x ) { root ( x ) ; return ws [ x ] ; } public static int root ( int x ) { if ( par [ x ] < 0 ) return x ; int p = root ( par [ x ] ) ; ws [ x ] = ws [ x ] + ws [ par [ x ] ] ; par [ x ] = p ; return par [ x ] ; } public static int unite ( int y , int x , int z ) { z = z + weight ( x ) ; z = z - weight ( y ) ; int x = root ( x ) ; int y = root ( y ) ; if ( x == y ) return 0 ; if ( par [ y ] < par [ x ] ) { int tmp = x ; x = y ; y = tmp ; z = - z ; } par [ x ] = par [ x ] + par [ y ] ; par [ y ] = x ; ws [ y ] = z ; return 1 ; } public static int diff ( int x , int y ) { if ( root ( x ) != root ( y ) ) return 0 ; int ans = ws [ x ] - ws [ y ] ; return 1 ; } public static void diff ( int x , int y ) { if ( Main . isWindows ( ) ) { ans = ws [ x ] - ws [ y ] ; } int N = ( Integer ) input . nextInt ( ) ; for ( int q = 0 ; q < Q ; q ++ ) { int t = ( Integer ) input . nextInt ( ) ; if ( t > 0 ) { int x = t ; int y = t ; int [ ] z = diff ( x , y ) ; if ( z == null ) System . out . print ( " ? " ) ; else System . out . print ( z [ 1 ] ) ; } else { int x = t ; int y = t ; int z = t ; unite ( x , y , z ) ; } } }
public static int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) { if ( ( i % M == 0 ) && ( A % M == 0 ) ) { sum += i ; } } return sum ; }
static final int countNumbersWith4 ( int n ) { if ( ( n < 4 ) || ( n > 9 ) ) return 0 ; int d = ( int ) Math . log10 ( n ) ; int [ ] a = new int [ d + 1 ] ; a [ 0 ] = 1 ; if ( a . length > 1 ) a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + Math . ceil ( Math . pow ( 10 , i - 1 ) ) ; int p = Math . ceil ( Math . pow ( 10 , d ) ) ; int msd = n / p ; if ( ( msd == 4 ) && ( n % p ) + 1 == p ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( ( msd > 4 ) && ( n % p ) + 1 == p ) return ( ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
public static int wah ( ) { int wah [ ] = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) . toArray ( ) ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; int x = wah [ 0 ] ; int y = wah [ 1 ] ; int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) . toString ( ) ) ; int all [ ] = { x , y , y - x , - x , - y , x - y } ; int res = ( n - 1 ) % 6 ; System . out . println ( all [ res ] % 1000000007 ) ; return res ; }
public static final void INT_MIN = - 2 * 31 ; final int INT_MAX = 2 * 31 ; void findPostOrderUtil ( int [ ] pre , int n , int minval , int maxval , int [ ] preIndex ) { if ( ( preIndex [ 0 ] == n ) && ( pre [ preIndex [ 0 ] ] < minval || pre [ preIndex [ 0 ] ] > maxval ) ) return ; if ( ( pre [ preIndex [ 0 ] ] < minval || pre [ preIndex [ 0 ] ] > maxval ) && ( pre [ preIndex [ 0 ] ] > minval ) ) return ; int val = pre [ preIndex [ 0 ] ] ; preIndex [ 0 ] ++ ; findPostOrderUtil ( pre , n , minval , val , preIndex ) ; findPostOrderUtil ( pre , n , val , maxval , preIndex ) ; System . out . print ( val + " ▁ " ) ; }
public static int countWays ( int n , int [ ] arr , int k ) { if ( ( k <= 0 ) || k >= n ) return 0 ; Set < Integer > s = new HashSet < Integer > ( ) ; for ( int element : arr ) s . add ( element ) ; if ( ( s . size ( ) <= k ) && ( s . size ( ) > n ) ) return 0 ; ; return s . size ( ) - k ; }
public static String getIp ( ) { int cnt = JOptionPane . showInputDialog ( " Enter ▁ ip ▁ address " ) ; for ( int k = 0 ; k < Integer . MAX_VALUE ; k ++ ) { String ip = JOptionPane . showInputDialog ( " Enter ▁ ip ▁ address " ) ; if ( ip . equals ( " " ) ) { System . out . println ( "0000:0000:0000:0000:0000:0000:0000" ) ; continue ; } ip = ip . split ( " : " ) [ 0 ] ; String ret = " " ; if ( ip . charAt ( 0 ) == ' ' ) ip = new String ( "0000" ) ; else if ( ip . charAt ( ip . length ( ) - 1 ) == ' ' ) ip = ip . substring ( 0 , ip . length ( ) - 2 ) + new String ( "0000" ) ; for ( int i = 0 ; i < ip . length ( ) ; i ++ ) { if ( ip . charAt ( i ) == ' ' ) ip = ip . substring ( 0 , i ) + new String ( "0000" ) ; } for ( int i = 0 ; i < ip . length ( ) ; i ++ ) { if ( ip . charAt ( i ) != ' ' ) ip = "0" + ( 4 - ip . length ( ) ) + ip . charAt ( i ) ; } System . out . println ( " : " + ip ) ; } return ret ; }
public static final boolean isPrime ( int n ) { int flag = 1 ; int i = 2 ; while ( ( i * i <= n ) && ( flag == 1 ) ) { if ( ( n % i == 0 ) ) { flag = 0 ; break ; } i ++ ; } return ( flag == 1 ) ? true : false ; } public static boolean isPerfectSquare ( int x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } public static int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( isPrime ( i ) != null ) && ( i * i <= n ) ) { int j = 1 ; while ( ( j * j * j <= i ) && ( j * j <= n ) ) { if ( ( isPerfectSquare ( i - j * j * j * j ) ) && ( j * j <= n ) ) { answer ++ ; break ; } j ++ ; } } } return answer ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( countInterestingPrimes ( N ) ) ; } }
public static void main ( String [ ] args ) { N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ words ▁ to ▁ be ▁ counted " ) ) ; W = new ArrayList < List < Integer > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { W . add ( Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ words ▁ to ▁ be ▁ counted " ) ) ) ; } int cnt = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( W . get ( i ) . get ( 0 ) != W . get ( i - 1 ) . get ( - 1 ) ) { cnt = 1 ; } } Collections . sort ( W ) ; for ( int i = 1 ; i < N ; i ++ ) { if ( W . get ( i ) . equals ( W . get ( i - 1 ) ) ) { cnt = 1 ; } } if ( cnt == 1 ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; } }
public static int findNum ( int [ ] div , int [ ] rem , int N ) { int num = rem [ N - 1 ] ; int i = N - 2 ; while ( ( i >= 0 ) && ( num == 0 ) ) { num = num * div [ i ] + rem [ i ] ; i -- ; } return num ; }
public static void segregate0and1 ( int [ ] arr , int size ) { int type0 = 0 ; int type1 = size - 1 ; while ( ( type0 < type1 ) && ( type0 < size ) ) { if ( ( arr [ type0 ] == 1 ) || ( arr [ type0 ] == 0 ) ) { ( arr [ type0 ] = arr [ type1 ] ) ; type1 -- ; } else { type0 ++ ; } } arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; arr [ 2 ] = 0 ; arr [ 3 ] = 1 ; arr [ 4 ] = 1 ; arr [ 5 ] = 1 ; arr [ 6 ] = 1 ; arr [ 7 ] = 1 ; arr [ 8 ] = 1 ; arr [ 9 ] = 1 ; arr [ 10 ] = 1 ; arr [ 11 ] = 1 ; arr [ 12 ] = 1 ; arr [ 13 ] = 1 ; arr [ 14 ] = 1 ; arr [ 15 ] = 1 ; arr [ 16 ] = 1 ; arr [ 17 ] = 1 ; arr [ 18 ] = 1 ; arr [ 19 ] = 1 ; arr [ 20 ] = 1 ; arr [ 21 ] = 1 ; arr [ 22 ] = 1 ; arr [ 23 ] = 1 ; arr [ 24 ] = 1 ; arr [ 25 ] = 1 ; arr [ 26 ] = 1 ; arr [ 27 ] = 1 ; arr [ 28 ] = 1 ; arr [ 29 ] = 1 ; arr [ 30 ] = 1 ; arr [ 31 ] = 1 ; arr [ 32 ] = 1 ; arr [ 33 ] = 1 ; arr [ 34 ] = 1 ; arr [ 35 ] = 1 ; arr [ 36 ] = 1 ; arr [ 37 ] = 1 ; arr [ 38 ] = 1 ; arr [ 39 ] = 1 ; arr [ 40 ] = 1 ; arr [ 41 ] = 1 ; arr [ 42 ] = 1 ; arr [ 43 ] = 1 ; arr [ 44 ] = 1 ; arr [ 45 ] = 1 ; arr [ 46 ] = 1 ; arr [ 47 ] = 1 ; arr [ 48 ] = 1 ; arr [ 49 ] = 1 ; arr [ 50 ] = 1 ; arr [ 51 ] = 1 ; arr [ 52 ] = 1 ; arr [ 53 ] = 1 ; arr [ 54 ] = 1 ; arr [ 55 ] = 1 ; arr [ 56 ] = 1 ; arr [ 57 ] = 1 ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] d = new int [ n ] ; for ( ; n > 0 ; n -- ) d [ n - 1 ] = Integer . parseInt ( input ( ) ) ; System . out . println ( new HashSet < > ( d ) ) ; }
public static void main ( String [ ] s ) { Scanner s = new Scanner ( System . in ) ; Scanner t = new Scanner ( System . in ) ; int a = ( int ) t . nextInt ( ) - ( int ) s . nextInt ( ) ; int b = ( int ) t . nextInt ( ) - ( int ) s . nextInt ( ) ; int x = Math . abs ( a ) ; int y = Math . abs ( b ) ; char [ ] c = { ' R ' , ' U ' , ' L ' , ' D ' } ; int i = 0 ; int j = 1 ; if ( a < 0 ) i = 2 ; if ( b < 0 ) j = 3 ; int k = j ; if ( x > y ) { k = i ; x = y ; y = x ; } int m = c [ i ] + c [ j ] ; int n = c [ k ] ; System . out . println ( y ) ; for ( int l = 0 ; l < x ; l ++ ) { System . out . println ( m ) ; } for ( int l = 0 ; l < y - x ; l ++ ) { System . out . println ( n ) ; } }
public static int f ( ) { return map . get ( Integer . parseInt ( input ) ) ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ lines ▁ to ▁ print " ) ) ; List < List < Integer > > L = new ArrayList < List < Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) L . add ( Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ lines ▁ to ▁ print " ) . split ( " \n " ) ) ) ; for ( int i = 0 , X = L . size ( ) ; i < n ; i ++ ) { for ( int j = 0 , Y = X . length ; j < n ; j ++ ) { if ( Y == 1 || Arrays . binarySearch ( L . get ( t ) , j ) < 0 ) continue ; System . out . println ( " NO " ) ; System . exit ( 0 ) ; } } System . out . println ( " YES " ) ; }
public static int a ( int x ) { int a = ( int ) x ; int MAX = ( 1 << 32 ) - 1 ; System . out . println ( " { :032b } " ) ; return a & b ; }
x = Integer . parseInt ( input . nextLine ( ) ) ; System . out . println ( MessageFormat . format ( " { x : 032b } " ) ) ; System . out . println ( MessageFormat . format ( " { ~ x ▁ & ▁ 0xffffffff : 032b } " ) ) ; }
static public int countPermutations ( Iterator < String > i , Collection < String > c ) { Counter b = c . count ( s -> s . charAt ( 0 ) ) ; System . out . println ( sum ( p * q * r ) ) ; return b . size ( ) ; }
n , m ) public static int main ( String [ ] args ) { int [ ] a = Arrays . stream ( args ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] b = Arrays . stream ( args ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int ans = 0 ; int s1 = a [ 0 ] ; int s2 = b [ 0 ] ; int i = 0 ; int j = 0 ; while ( i < a . length || j < b . length ) { if ( s1 == s2 ) { ans ++ ; i ++ ; j ++ ; if ( i < a . length && j < b . length ) { s1 = a [ i ] ; s2 = b [ j ] ; } } else if ( s1 < s2 ) { i ++ ; s1 += a [ i ] ; } else if ( s2 < s1 ) { j ++ ; s2 += b [ j ] ; } } System . out . println ( ans ) ; }
public static void main ( String [ ] args ) { while ( true ) { int a , en , b ; a = input . nextInt ( ) ; en = input . nextInt ( ) ; b = input . nextInt ( ) ; if ( en == ' ? ' ) { break ; } else { a = Integer . parseInt ( a ) ; b = Integer . parseInt ( b ) ; if ( en == ' + ' ) { System . out . println ( a + b ) ; } else if ( en == ' - ' ) { System . out . println ( a - b ) ; } else if ( en == ' * ' ) { System . out . println ( a * b ) ; } else if ( en == ' / ' ) { System . out . println ( Integer . parseInt ( a / b ) ) ; } } } }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] a = Arrays . copyOf ( input . nextLine ( ) . split ( " ▁ " ) , n ) ; int [ ] d = new int [ n - 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) d [ i ] = a [ i + 1 ] - a [ i ] ; int cnt = 1 ; int l = r = cur = 0 ; while ( l < n - 1 ) { while ( r < n - 1 && cur * d [ r ] >= 0 ) { if ( cur == 0 ) cur = d [ r ] ; r ++ ; } if ( r < n - 1 && cur * d [ r ] < 0 ) cnt ++ ; r ++ ; l = r ; cur = 0 ; } System . out . println ( cnt ) ; return cnt ; }
public static int MAX = 256 ; public static int countPairs ( String s ) { int [ ] cnt = new int [ MAX ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { cnt [ ( char ) s . charAt ( i ) - 97 ] ++ ; } int ans = 0 ; for ( int i = 0 ; i <= MAX ; i ++ ) { ans += cnt [ i ] * cnt [ i ] ; } return ans ; }
public static final void main ( String [ ] args ) { final boolean prime [ ] = new boolean [ 100005 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p <= Integer . MAX_VALUE ; p ++ ) if ( prime [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) prime [ i ] = false ; final int [ ] sortedArray = new int [ n ] ; SieveOfEratosthenes ( 100005 ) ; final int v [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] == 0 ) v [ i ] = arr [ i ] ; Arrays . sort ( v ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] == true ) System . out . print ( arr [ i ] + " ▁ " ) ; else { System . out . print ( v [ j ] + " ▁ " ) ; j ++ ; } }
public static final < T > int [ ] createHash ( Set < T > hash1 , int maxElement ) { int prev = 0 , curr = 1 ; hash1 . add ( prev ) ; hash1 . add ( curr ) ; while ( ( curr = Math . abs ( curr ) ) <= maxElement ) { int temp = curr + prev ; if ( temp <= maxElement ) { hash1 . add ( temp ) ; } prev = curr ; curr = temp ; } final int gcdFibonacciFreq = arr . size ( ) ; hash1 . clear ( ) ; createHash ( hash1 , Math . max ( arr . size ( ) , 1 ) ) ; Map < T , Integer > m = new HashMap < T , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { m . put ( arr . get ( i ) , i ) ; } int gcd = 0 ; for ( Iterator < T > it = m . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { if ( ( m . get ( it . next ( ) ) ) . contains ( hash1 . get ( it . next ( ) ) ) ) { gcd = Math . gcd ( gcd , it . next ( ) ) ; } } return new int [ ] { gcd } ; }
public static final double findArea ( double a ) { double R = a * ( 2.0 - Math . sqrt ( 2 ) ) ; ; double area = 3.14 * R * R / 2.0 ; ; return area ; }
public static int findQuadruples ( int [ ] a , int [ ] b , int [ ] c , int [ ] d , int x , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int l = 0 ; l < n ; l ++ ) { if ( ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) && ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) ) { count ++ ; } } } } } return count ; }
public static void findSmallest ( String s , int [ ] [ ] q , int m ) { int N = s . length ( ) ; int [ ] [ ] H = new int [ 26 ] [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { H [ i ] [ ( int ) s . charAt ( i - 1 ) - ' a ' ] ++ ; for ( int j = 0 ; j < 26 ; j ++ ) H [ i ] [ j ] += H [ i - 1 ] [ j ] ; } for ( int j = 0 ; j < m ; j ++ ) { int l = q [ j ] [ 0 ] ; int r = q [ j ] [ 1 ] ; int n = q [ j ] [ 2 ] ; int sum = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { sum += H [ r ] [ i ] - H [ l - 1 ] [ i ] ; if ( ( sum >= n ) && ( sum < n ) ) { System . out . print ( ( char ) ( ( char ) ' a ' + i ) ) ; break ; } } } if ( System . getProperty ( " os . arch " ) . contains ( " sparc " ) ) { s = " afbccdeb " ; q [ 0 ] = new int [ 26 ] ; q [ 1 ] = new int [ 26 ] ; q [ 2 ] = new int [ 26 ] ; q [ 3 ] = new int [ 26 ] ; int x = q [ 0 ] . length ; findSmallest ( s , q , x ) ; } }
public static int miner ( int a , int b , String [ ] mines ) { int s = 0 ; int j = 0 ; while ( j < mines . length && mines [ j ] != "1" ) j ++ ; if ( j == mines . length ) return 0 ; for ( int i = j + 1 ; i < mines . length ; i ++ ) { if ( mines [ i ] . equals ( "0" ) && mines [ i - 1 ] . equals ( "1" ) ) { int r1 = i - 1 ; if ( mines [ i ] . equals ( "1" ) && mines [ i - 1 ] . equals ( "0" ) ) { s += Math . min ( b * ( i - r1 - 1 ) , a ) ; } } s += a ; return s ; } int t = Integer . parseInt ( System . in . readLine ( ) ) ; for ( ; t > 0 ; ) { a = Integer . parseInt ( System . in . readLine ( ) ) ; b = Integer . parseInt ( System . in . readLine ( ) ) ; mines = System . in . readLine ( ) ; System . out . println ( miner ( a , b , mines ) ) ; } return 0 ; }
public static int t ( ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ moves ▁ to ▁ perform " ) ) ; for ( int i = 0 ; i <= t ; i ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ start ▁ point " ) ) ; startPoint = 0 ; numbMoves = 0 ; if ( n == 1 ) { System . out . println ( 2 ) ; } else if ( n % 3 == 0 ) { System . out . println ( Integer . toString ( n / 3 ) ) ; continue ; } else if ( n == 2 || n == 3 ) { System . out . println ( 1 ) ; } else { int x = n % 3 ; System . out . println ( Integer . toString ( ( n - x ) / 3 + 1 ) ) ; } } return t ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ n " ) ) ; List < Integer > s = Arrays . asList ( 1 ) ; int [ ] q = new int [ n ] ; for ( int i = n ; i > 0 ; i -- ) { if ( n % i == 0 ) q [ i ] ++ ; } for ( int j : q ) { int w = n / j ; s = s . subList ( 0 , w ) . toArray ( new Integer [ w ] ) ; } System . out . println ( s ) ; }
public static void printPairs ( int [ ] arr , int n ) { int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) && ( v [ j ] == 0 ) ) { v [ j ] = Math . abs ( arr [ i ] ) ; } } } if ( ( v . length == 0 ) || ( v [ 0 ] == 0 ) ) return ; ; Arrays . sort ( v ) ; for ( int i = 0 ; i < v . length ; i ++ ) { System . out . print ( - v [ i ] + " ▁ " ) ; } }
public static int doublefactorial ( int n ) { if ( ( n == 0 || n == 1 ) ) return 1 ; ; return n * doublefactorial ( n - 2 ) ; }
public static int isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( ( h > l ) && ( str . charAt ( l ) != str . charAt ( h ) ) ) { if ( ( str . charAt ( l ) != str . charAt ( h ) ) && ( str . charAt ( l ) != str . charAt ( h ) ) ) return 0 ; l = l + 1 ; h = h - 1 ; } return 1 ; }
public static int sumOfSubstrings ( String num ) { int n = num . length ( ) ; int [ ] sumofdigit = new int [ n ] ; sumofdigit [ 0 ] = Integer . parseInt ( num . substring ( 0 , 1 ) ) ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = Integer . parseInt ( num . substring ( i , i + 1 ) ) ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; }
public static int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * Integer . bitCount ( a / n ) * Integer . bitCount ( b / n ) ; ans += Integer . bitCount ( a / n ) * ( b % n ) ; ans += ( a % n ) * Integer . bitCount ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; ; return ans ; }
public static String compute ( ) { int LIMIT = 1000000 ; int maxnumer = 0 ; int maxdenom = 1 ; for ( int d = 1 ; d <= LIMIT ; d ++ ) { int n = d * 3 / 7 ; if ( d % 7 == 0 ) { n -- ; } if ( n * maxdenom > d * maxnumer ) { maxnumer = n ; maxdenom = d ; } } return String . valueOf ( maxnumer ) ; }
c = new int [ 100 ] ; ; static void coef ( int n ) { c [ 0 ] = 1 ; ; for ( int i = 1 ; i < n ; i ++ ) { c [ 1 + i ] = 1 ; ; for ( int j = i ; j > 0 ; j -- ) c [ j ] = c [ j - 1 ] - c [ j ] ; ; c [ 0 ] = - c [ 0 ] ; ; } ; }
public static int countGreater ( int [ ] arr , int n ) { int min = Integer . MAX_VALUE ; ; int counter = 0 ; ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ( arr [ i ] > min ) && ( arr [ i ] <= min ) ) { counter ++ ; } if ( ( arr [ i ] <= min ) && ( arr [ i ] > min ) ) { min = arr [ i ] ; } } return counter ; }
n , x ) STRNEWLINE ▁ */ public static int binarySearch ( int [ ] input , int [ ] a ) { int n = map ( input , 0 , input . length ) ; int [ ] aArray = Arrays . copyOf ( input , n ) ; Arrays . sort ( aArray ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = x - aArray [ i ] ; count ++ ; if ( x <= 0 ) break ; } if ( x == 0 ) System . out . println ( count ) ; else System . out . println ( count - 1 ) ; return count ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ question ▁ to ▁ solve " ) ) ; int left = 0 ; int right = 0 ; for ( ; n > 0 ; n -- ) { int a = map . get ( JOptionPane . YES_OPTION ) ; int b = map . get ( JOptionPane . NO_OPTION ) ; if ( a > 0 ) { right ++ ; } else if ( a < 0 ) { left ++ ; } } if ( left == 0 || right == 0 || left == 1 || right == 1 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } }
public static int [ ] solve ( ) { int T = Integer . parseInt ( System . in . readLine ( ) ) , D = Integer . parseInt ( System . in . readLine ( ) ) , L = Integer . parseInt ( System . in . readLine ( ) ) ; if ( T == 0 ) break ; int [ ] a = new int [ T ] ; for ( int i = 0 ; i < T ; i ++ ) { int x = Integer . parseInt ( System . in . readLine ( ) ) ; if ( x >= L ) { a [ i ] = i ; } } T = T - 1 , ans = 0 ; for ( int i = 1 ; i < a . length ; i ++ ) { int x = D ; if ( T - a [ i - 1 ] < D ) { x = T - a [ i - 1 ] ; } if ( a [ i ] - a [ i - 1 ] < x ) { ans += a [ i ] - a [ i - 1 ] ; } else { ans += x ; } } if ( a . length > 0 ) { ans += T - a [ a . length - 1 ] == 0 ? T : D ; } System . out . println ( ans ) ; return a ; }
public static int minimumSwaps ( int [ ] arr ) { int count = 0 ; ; int i = 0 ; ; while ( ( i < arr . length ) && ( arr [ i ] != i + 1 ) ) { if ( ( arr [ i ] != i + 1 ) && ( arr [ i ] != arr [ i ] - 1 ) ) { while ( ( arr [ i ] != i + 1 ) && ( arr [ i ] != arr [ i ] - 1 ) ) { int temp ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; }
public static String compute ( ) { final int TARGET = 500500 ; final int MODULUS = 500500507 ; final boolean [ ] isprime = EulerLib . listPrimality ( 7376507 ) ; final int [ ] queue = new int [ TARGET ] ; int nextprime = 2 ; heapQueue . add ( queue , nextprime ) ; int ans = 1 ; for ( ; ; ) { int item = heapQueue . poll ( queue ) ; ans *= item ; ans %= MODULUS ; heapQueue . add ( queue , item * item ) ; if ( item == nextprime ) { nextprime ++ ; while ( ! isprime [ nextprime ] ) { nextprime ++ ; } heapQueue . add ( queue , nextprime ) ; } } return String . valueOf ( ans ) ; }
public static void findUniquePair ( int [ ] arr , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { XOR = XOR ^ arr [ i ] ; } int setBitNo = XOR & ~ ( XOR - 1 ) ; int x = 0 ; int y = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] & setBitNo ) != 0 ) { x = x ^ arr [ i ] ; } else { y = y ^ arr [ i ] ; } } System . out . println ( " The ▁ unique ▁ pair ▁ is ▁ ( " + x + " , ▁ " + y + " ) " + " ▁ " ) ; }
public static int n ( ) { int n = Integer . parseInt ( System . in . readLine ( ) ) ; int [ ] [ ] s = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = Integer . parseInt ( System . in . readLine ( ) ) ; s [ i ] [ k ] = Integer . parseInt ( System . in . readLine ( ) ) ; } int flag = 0 ; int [ ] d1 = new int [ n ] ; int [ ] d2 = new int [ n ] ; Set < Integer > rem = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i == j ) && ( i != n - j - 1 ) ) { d1 [ i ] [ j ] = s [ i ] [ j ] ; } if ( ( i == n - j - 1 ) && ( i != n - j - 1 ) ) { d2 [ i ] [ j ] = s [ i ] [ j ] ; } if ( ( i != j && i != n - j - 1 ) && ( i != n - j - 1 ) ) { rem . add ( s [ i ] [ j ] ) ; } } } if ( ( rem . size ( ) != 1 ) || ( d1 != d2 ) ) { System . out . println ( " NO " ) ; } else if ( ( set ( d1 ) . size ( ) != 1 ) || ( set ( d1 ) . equals ( rem ) ) ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } return flag ; }
static final void main ( String [ ] args ) { final Scanner sc = new Scanner ( System . in ) ; for ( String s : sc . nextLine ( ) . split ( " @ ( \ " d ) ( . ) " ) ) { System . out . println ( s . replaceAll ( " @ ( \ " d ) ( . ) " , new Function < String , Integer > ( ) { public Integer apply ( String m ) { return m . substring ( 2 ) * Integer . parseInt ( m . substring ( 1 ) ) ; } } ) ) ; } }
public static boolean isMajority ( int [ ] a ) { int mp [ ] = new int [ a . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] < mp [ i ] ) { mp [ i ] ++ ; } else { mp [ i ] = 1 ; } } for ( int x : mp ) { if ( mp [ x ] >= a . length / 2 ) { return true ; } } return false ; }
n , w ) public static int [ ] [ ] [ ] getW ( ) { int [ ] [ ] vw_l = new int [ n ] [ w ] ; for ( int y = 0 ; y < n ; y ++ ) vw_l [ y ] [ y ] = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] [ ] dp = new int [ n + 1 ] [ w ] ; for ( int i = 0 ; i < n ; i ++ ) { int _v = vw_l [ i ] [ 0 ] ; int _w = vw_l [ i ] [ 1 ] ; for ( int j = 0 ; j < w + 1 ; j ++ ) { if ( j < _w ) dp [ i + 1 ] [ j ] = dp [ i ] [ j ] ; else dp [ i + 1 ] [ j ] = Math . max ( dp [ i + 1 ] [ j - _w ] + _v , dp [ i ] [ j ] ) ; } } System . out . println ( dp [ n ] [ w ] ) ; return dp ; }
public static void main ( String [ ] args ) { final int PI2 = Math . PI / 2 ; final List < Point2D > L = new ArrayList < Point2D > ( 1001 ) ; L . add ( null ) ; L . add ( new Point2D . Double ( 1.0 , 0.0 ) ) ; for ( int i = 2 ; i < 1001 ; i ++ ) { final double x = L . get ( L . size ( ) - 1 ) . getX ( ) ; final double y = L . get ( L . size ( ) - 1 ) . getY ( ) ; final double rad = Math . atan2 ( y , x ) + PI2 ; L . add ( new Point2D . Double ( x + Math . cos ( rad ) , y + Math . sin ( rad ) ) ) ; } for ( ; ; ) { final int n = Integer . parseInt ( args [ 0 ] ) ; if ( n == - 1 ) break ; System . out . println ( " { :0.2f } \n { :0.2f } " . format ( * L . get ( n ) ) ) ; } }
public static void printKMissing ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( ( i < n && arr [ i ] <= 0 ) || ( i < k && arr [ i ] > 0 ) ) { i = i + 1 ; } int count = 0 ; int curr = 1 ; while ( ( count < k && i < n ) || ( i < k && arr [ i ] > 0 ) ) { if ( ( arr [ i ] != curr ) || ( arr [ i ] == curr ) ) { System . out . print ( String . valueOf ( curr ) + " ▁ " ) ; count = count + 1 ; } else { i = i + 1 ; } curr = curr + 1 ; } while ( ( count < k ) || ( count < n && arr [ count ] == 0 ) ) { System . out . print ( String . valueOf ( curr ) + " ▁ " ) ; curr = curr + 1 ; count = count + 1 ; } arr [ 0 ] = 2 ; arr [ 1 ] = 3 ; arr [ 2 ] = 4 ; n = arr . length ; k = 3 ; printKMissing ( arr , n , k ) ; ; }
public static void printNumbers ( int [ ] a , int n ) { Map < Integer , Integer > mpp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; for ( int j = 1 ; j <= num ; j ++ ) { if ( j * j > num ) break ; if ( ( num % j == 0 ) && ( j != 1 ) ) { if ( ( j != 1 ) && ( ( num / j ) != j ) ) { mpp . put ( j , mpp . get ( j ) + 1 ) ; } if ( ( ( num / j ) != j ) && ( ( num / j ) != j ) ) { mpp . put ( num / j , mpp . get ( num / j ) + 1 ) ; } } } } int maxi = 0 ; for ( Iterator it = mpp . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { maxi = Math . max ( mpp . get ( it . next ( ) ) , maxi ) ; } for ( Iterator it = mpp . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { if ( ( mpp . get ( it . next ( ) ) == maxi ) && ( ( num / j ) != j ) ) { System . out . print ( it . next ( ) + " ▁ " ) ; } } }
public static String s = new Scanner ( System . in ) . nextLine ( ) ; String ts = s . replace ( " a " , " " ) ; int ls = ts . length ( ) / 2 ; String ans = s . substring ( 0 , s . length ( ) - ls ) ; if ( ts . length ( ) % 2 || ans . replace ( " a " , " " ) != ts . substring ( ls ) ) System . out . print ( " : ( " ) ; else System . out . print ( ans ) ; return ans ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ remove " ) ) ; List < Integer > a = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ elements ▁ to ▁ remove " ) . split ( " ▁ " ) ) ; int K = Math . max ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ remove " ) , 1 ) ; int i = 0 ; while ( true ) { if ( a . indexOf ( a . get ( i ) ) < K ) { int C = a . indexOf ( a . get ( i ) ) ; n -= C ; int Val = a . get ( i ) ; for ( int k = 0 ; k < C ; k ++ ) { a . remove ( Val ) ; } } else { i ++ ; } if ( i == n ) break ; } int MinI = 1000001 ; int ID = - 1 ; List < Integer > A = Arrays . asList ( a ) ; for ( i = 0 ; i < A . size ( ) ; i ++ ) { int j = n - 1 ; while ( j >= 0 && a . get ( j ) != A . get ( i ) ) { j -- ; } if ( j < MinI ) { MinI = j ; ID = A . get ( i ) ; } } System . out . println ( ID ) ; return ID ; }
public static int checkIfStartsWithCapital ( String string ) { if ( ( string . charAt ( 0 ) >= ' A ' && string . charAt ( 0 ) <= ' Z ' ) || ( string . charAt ( 0 ) >= ' a ' && string . charAt ( 0 ) <= ' z ' ) ) return 1 ; ; else return 0 ; } public static void check ( String string ) { if ( ( checkIfStartsWithCapital ( string ) ) && ( string . charAt ( 0 ) == ' A ' ) ) System . out . println ( " Accepted " ) ; else System . out . println ( " Not ▁ Accepted " ) ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { string = " GeeksforGeeks " ; check ( string ) ; string = " geeksforgeeks " ; check ( string ) ; } }
public static double getAvg ( double prevAvg , double x , int n ) { return ( ( prevAvg * n + x ) / ( n + 1 ) ) ; ; }
public static String compute ( ) { int ans = 0 ; int [ ] isprime = EulerLib . listPrimality ( 999999 ) ; int [ ] primes = EulerLib . listPrimes ( 999999 ) ; int consecutive = 0 ; for ( int i = 0 ; i < primes . length ; i ++ ) { int sum = primes [ i ] ; int consec = 1 ; for ( int j = i + 1 ; j < primes . length ; j ++ ) { sum += primes [ j ] ; consec ++ ; if ( sum >= isprime . length ) break ; if ( isprime [ sum ] > consecutive ) { ans = sum ; consecutive = consec ; } } } return String . valueOf ( ans ) ; }
public static int lis ( int [ ] arr , int n ) { int i , j , maxm = 0 ; int [ ] lst = new int [ n ] ; for ( int s = 0 ; s < n ; s ++ ) { for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] > arr [ j ] && lst [ i ] < lst [ j ] + 1 ) || ( arr [ i ] > arr [ j ] && lst [ i ] > lst [ j ] + 1 ) ) { lst [ i ] = lst [ j ] + 1 ; } } } for ( i = 0 ; i < n ; i ++ ) { if ( maxm < lst [ i ] ) { maxm = lst [ i ] ; } } return maxm ; }
public static int sum ( int a , int b ) { int z = ( i & 1 ) + ( i & 2 ) ; java . util . Random r = new java . util . Random ( ) ; if ( z * ( 1 / 2 ) == r . nextInt ( z * ( 1 / 2 ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return z ; }
public static void fix ( int [ ] A ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) s . add ( A [ i ] ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( i < s . size ( ) ) A [ i ] = i ; else A [ i ] = - 1 ; } }
public static void main ( String [ ] args ) { int [ ] A = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ question ▁ to ▁ solve " ) . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int ans = Math . abs ( A [ 0 ] + A [ 1 ] - A [ 2 ] - A [ 3 ] ) ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( i == j ) continue ; int now = 0 ; for ( int t = 0 ; t < 4 ; t ++ ) { if ( t == i || t == j ) now += A [ t ] ; else now -= A [ t ] ; if ( Math . abs ( now ) < ans ) ans = Math . abs ( now ) ; } } System . out . println ( ans ) ; } if ( args . length == 0 ) main ( ) ; }
class Node { public static void init ( int data ) { data = data ; prev = null ; next = null ; } public void push ( Node headRef , int newData ) { Node newNode = new Node ( newData ) ; newNode . next = headRef ; if ( headRef != null ) { headRef . prev = newNode ; } headRef = newNode ; } public void makeOddNode ( Node headRef , int [ ] A , int n ) { Node ptr = headRef ; int i = 0 ; while ( ptr != null ) { Node next = ptr . next ; if ( ptr . data % 2 == 0 ) { ptr . data = A [ i ] ; i ++ ; } ptr = next ; } } public void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + " ▁ " ) ; head = head . next ; } } }
public static int [ ] s_max ( int [ ] u , int r , int s , Map < Integer , Integer > m ) { int [ ] s_max = new int [ 10 ] ; s_max [ 0 ] = 0 ; for ( int i = 1 ; i < 11 ; i ++ ) { int s = 0 ; for ( int j = 0 ; j < i ; j ++ ) { s += ( 10 - j - 1 ) * ( i - j ) ; } s_max [ i ] = s ; } final boolean [ ] u = new boolean [ 10 ] ; u [ 0 ] = u [ 1 ] = u [ 2 ] = u [ 3 ] = u [ 4 ] = u [ 5 ] = u [ 6 ] = u [ 7 ] = u [ 8 ] = u [ 9 ] = u [ 10 ] = u [ 11 ] = u [ 12 ] = u [ 13 ] = u [ 14 ] = u [ 15 ] = u [ 16 ] = u [ 17 ] = u [ 18 ] = u [ 19 ] = u [ 20 ] = u [ 21 ] = u [ 22 ] = u [ 23 ] = u [ 24 ] = u [ 25 ] = u [ 26 ] = u [ 27 ] = u [ 28 ] = u [ 29 ] = u [ 30 ] = u [ 31 ] = u [ 32 ] = u [ 33 ] = u [ 34 ] = u [ 35 ] = u [ 36 ] = u [ 37 ] = u [ 38 ] = u [ 39 ] = u [ 40 ] = u [ 41 ] = u [ 42 ] = u [ 43 ] = u [ 44 ] = u [ 45 ] = u [ 46 ] = u [ 47 ] = u [ 48 ] = u [ 49 ] = u [ 50 ] = u [ 51 ] = u [ 52 ] = u [ 53 ] = u [ 54 ] = u [ 55 ] = u [ 56 ] = u [ 57 ] = u [ 58 ] = u [ 59 ] = u [ 60 ] = u [ 61 ] = u [ 62 ] = u [ 63 ] = u [ 64 ] = u [ 65 ] = u [ 66 ] = u [ 67 ] = u [ 68 ] = u [ 69 ] = u [ 70 ] = u [ 71 ] = u [ 72 ] = u [ 73 ] = u [ 74 ] = u [ 75 ] = u [ 76 ] = 0 ; return s_
public static int mod ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } public static final int nCr ( int n , int r ) { return ( int ) ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) ; } public static final int powMod ( int a , int n ) { if ( ( n == 0 ) || ( n == 1 ) ) return 1 ; int pt = powMod ( a , ( int ) ( n / 2 ) ) ; pt = ( pt * pt ) % mod ; if ( ( n % 2 ) != 0 ) return ( pt * a ) % mod ; else return pt ; } public static int CountSubset ( int [ ] arr , int n ) { int ans = powMod ( 2 , n - 1 ) ; Arrays . sort ( arr , 0 , n ) ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( ( j < n ) && arr [ j ] == arr [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } return ans ; } if ( System . getProperty ( " os . arch " ) . contains ( " Windows " ) ) { int arr [ ] = { 2 , 3 , 2 } ; int n = arr . length ; System . out . println ( CountSubset ( arr , n ) ) ; } return 0 ; }
public static int MAX = 1000001 ; double MAX_sqrt = MAX * ( 0.5 ) ; int primeUpto [ ] = new int [ MAX ] ; public static void SieveOfEratosthenes ( ) { boolean isPrime [ ] = new boolean [ MAX ] ; isPrime [ 0 ] = false , isPrime [ 1 ] = false ; for ( int i = 2 ; i <= Integer . MAX_VALUE ; i ++ ) { if ( isPrime [ i ] == 1 ) { for ( int j = i * 2 ; j < MAX ; j += i ) { isPrime [ j ] = 0 ; } } } for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] == 1 ) { primeUpto [ i ] ++ ; } } } private static int countOfNumbers ( int N , int K ) { SieveOfEratosthenes ( ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) > > > 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else { low = mid + 1 ; } } return ( N - ans + 1 ) == ans ? ans : 0 ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { int N = 10 , K = 3 ; System . out . println ( countOfNumbers ( N , K ) ) ; } } }
public static int countOperations ( int n ) { int i = 2 ; while ( ( ( i * i ) < n ) && ( n % i ) ) i ++ ; if ( ( ( i * i ) > n ) && ( n % i ) ) i = n ; return ( 1 + ( n - i ) / 2 ) ; }
n , q ) public static int [ ] [ ] getAcc ( ) { Scanner s = new Scanner ( System . in ) ; int [ ] ac = new int [ n - 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s . hasNext ( ) && s . next ( ) == ' A ' ) { ac [ i ] = 1 ; } } int [ ] acc = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { acc [ i + 1 ] = acc [ i ] + ac [ i ] ; } int [ ] [ ] lr = new int [ q ] [ n ] ; for ( int i = 0 ; i < q ; i ++ ) { lr [ i ] = Arrays . copyOf ( acc , n ) ; } for ( int i = 0 ; i < q ; i ++ ) { int l = lr [ i ] [ 0 ] - 1 ; int r = lr [ i ] [ 1 ] - 1 ; System . out . println ( acc [ r ] - acc [ l ] ) ; } return lr ; }
public static int T ( ) { int T = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ display " ) ) ; for ( int i = 0 ; i < T ; i ++ ) { int l = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ display " ) ) ; int r = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ display " ) ) ; System . out . println ( l + " ▁ " + r ) ; } return T ; }
public static final String compute ( ) { final int LIMIT = 5000 ; final int MODULUS = 10 * 16 ; int [ ] count = new int [ LIMIT * 2 / 2 ] ; count [ 0 ] = 1 ; int s = 0 ; for ( int p = EulerLib . listPrimes ( LIMIT ) ; p < LIMIT ; p ++ ) { for ( int i = 0 ; i < s + 1 ; i ++ ) { count [ i + p ] = ( count [ i + p ] + count [ i ] ) % MODULUS ; } s += p ; } int [ ] isprime = EulerLib . listPrimality ( s + 1 ) ; int ans = Arrays . binarySearch ( count , isprime ) % MODULUS ; return String . valueOf ( ans ) ; }
public static int countOddNumber ( int rowNum ) { int count = 0 ; while ( rowNum != 0 ) { count += rowNum & 1 ; rowNum >>>= 1 ; } return ( 1 << count ) ; }
public static void findMin ( int V ) { int [ ] deno = { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 } ; int n = deno . length ; int [ ] ans = new int [ n ] ; int i = n - 1 ; while ( ( i >= 0 ) && ( V >= deno [ i ] ) ) { while ( ( V >= deno [ i ] ) && ( V <= deno [ i ] ) ) { V -= deno [ i ] ; ans [ i ] = deno [ i ] ; } i -- ; } for ( i = 0 ; i < ans . length ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } }
static final < T > void compute ( ) { Predicate < T > cond = i -> Arrays . binarySearch ( Arrays . asList ( String . valueOf ( i ) ) , String . valueOf ( j * i ) ) >= 0 ; int ans = Iterables . size ( i ) ; cond . test ( i ) ; cond . test ( ans ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( compute ( ) ) ; } }
public static int count ( int [ ] arr , int n , int x ) { if ( ( x == 1 ) && ( arr . length == n ) ) { int ans = Math . pow ( 2 , n ) - 1 ; return ans ; } ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % x == 0 ) && ( arr [ i ] != 0 ) ) { count ++ ; } } int ans = Math . pow ( 2 , count ) - 1 ; return ans ; }
public static int findEle ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == sum - arr [ i ] ) { return arr [ i ] ; } } return - 1 ; }
public static int findExtraCharacter ( String strA , String strB ) { HashMap < Integer , Integer > m1 = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < strB . length ( ) ; i ++ ) { if ( strB . charAt ( i ) == ' a ' ) m1 . put ( strB . charAt ( i ) , 1 ) ; else m1 . put ( strB . charAt ( i ) , 1 ) ; } for ( int i = 0 ; i < strA . length ( ) ; i ++ ) m1 . put ( strA . charAt ( i ) , 1 ) ; for ( int h1 : m1 . keySet ( ) ) { if ( m1 . get ( h1 ) == 1 ) return h1 ; } if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { strA = " abcd " ; strB = " cbdad " ; System . out . println ( findExtraCharacter ( strA , strB ) ) ; } return 0 ; }
public static int main ( String [ ] args ) { int balls = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ balls ▁ number ▁ ( 0-6 ) : ▁ " ) ) ; int ans = 0 ; if ( balls == 0 ) break ; for ( int cs = 0 ; cs < 54 ; cs ++ ) { for ( int ts = 0 ; ts < 96 ; ts ++ ) { if ( Math . pow ( cs , 3 ) <= balls ) ans = Math . max ( ans , Math . pow ( cs , 3 ) ) ; if ( ts * ( ts + 1 ) * ( ts + 2 ) / 6 <= balls ) ans = Math . max ( ans , ts * ( ts + 1 ) * ( ts + 2 ) / 6 ) ; if ( Math . pow ( cs , 3 ) + ts * ( ts + 1 ) * ( ts + 2 ) / 6 <= balls ) ans = Math . max ( ans , Math . pow ( cs , 3 ) + ts * ( ts + 1 ) * ( ts + 2 ) / 6 ) ; } } System . out . println ( ans ) ; return 0 ; }
public static String substitute ( String text , String a , String b ) { int pos = 0 ; String newText = text ; int L1 = a . length ( ) ; int L2 = b . length ( ) ; while ( true ) { int idx = newText . indexOf ( a , pos ) ; if ( idx < 0 ) return newText ; newText = newText . substring ( 0 , idx ) + b + newText . substring ( idx + L1 ) ; pos = idx + L2 ; } return newText ; }
public static int n ( String input ) { int n = Integer . parseInt ( input ) ; List < Integer > ls = Arrays . asList ( Integer . parseInt ( input ) . split ( " ▁ " ) ) ; Map < Integer , Integer > cnt = Maps . newHashMap ( ) ; boolean ans = true ; for ( Integer el : ls ) { if ( el != null ) cnt . put ( el , 1 ) ; else cnt . put ( el , 1 ) ; if ( cnt . get ( el ) > ( n + 1 ) / 2 ) ans = false ; } if ( ans ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; return n ; }
static int maxSumPair ( int [ ] arr1 , int n1 , int [ ] arr2 , int n2 ) { int max1 = - Integer . MAX_VALUE - 1 ; int max2 = - Integer . MAX_VALUE - 1 ; for ( int i = 0 ; i <= n1 ; i ++ ) { if ( ( arr1 [ i ] > max1 ) && ( arr2 [ i ] > max2 ) ) { max1 = arr1 [ i ] ; } } for ( int i = 0 ; i <= n2 ; i ++ ) { if ( ( arr2 [ i ] > max2 ) && ( arr1 [ i ] > max1 ) ) { max2 = arr2 [ i ] ; } } return max1 + max2 ; }
public static int operations ( int [ ] op , int n , int k ) { int i , count ; int nVal = 0 ; int minimum = 10 * 9 ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; minimum = Math . min ( minimum , nVal ) ; if ( ( ( k + nVal ) <= 0 ) && ( ( k + nVal ) >= minimum ) ) return ( i + 1 ) ; } if ( ( nVal >= 0 ) && ( ( k + nVal ) >= minimum ) ) return - 1 ; int times = ( k - Math . abs ( minimum ) ) / Math . abs ( nVal ) ; k = ( k - ( times * Math . abs ( nVal ) ) ) ; count = ( times * n ) ; while ( ( k > 0 ) && ( ( k + nVal ) >= minimum ) ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( ( k <= 0 ) && ( ( k + nVal ) >= minimum ) ) break ; } } return count ; op = new int [ ] { - 60 , 65 , - 1 , 14 , - 25 } ; n = op . length ; k = 100000 ; System . out . println ( operations ( op , n , k ) ) ; }
pref = new int [ 100010 ] ; }
static int main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int r = in . nextInt ( ) ; int l = in . nextInt ( ) ; int appearance [ ] = new int [ n ] ; int point [ ] = new int [ n ] ; int top = 0 ; int pre_t = 0 ; for ( ; ; ) { int d = in . nextInt ( ) ; int t = in . nextInt ( ) ; int x = in . nextInt ( ) ; d -- ; appearance [ top ] += t - pre_t ; pre_t = t ; point [ d ] += x ; if ( 0 < x && top != d ) { if ( point [ top ] < point [ d ] ) top = d ; else if ( point [ top ] == point [ d ] && d < top ) top = d ; } else if ( x < 0 && top == d ) top = point . length - Math . max ( point ) ; } appearance [ top ] += l - pre_t ; System . out . println ( 1 + appearance . length ) ; return 0 ; }
public static double centeredCube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; if ( System . getSecurityManager ( ) == null ) { n = 3 ; System . out . println ( String . format ( " % d th ▁ Centered ▁ cube ▁ number : ▁ % d " , n , centeredCube ( n ) ) ) ; n = 10 ; System . out . println ( String . format ( " % d th ▁ Centered ▁ cube ▁ number : ▁ % d " , n , centeredCube ( n ) ) ) ; } return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
t ; for ( int testcase = 0 ; testcase < t ; testcase ++ ) { int n = Integer . parseInt ( input . readLine ( ) ) ; String s = input . readLine ( ) ; int lef = 1 , rig = 1 , sw = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( s . charAt ( i ) > s . charAt ( i + 1 ) ) && ( sw == 0 ) ) { sw = 1 ; break ; } } if ( ( sw == 0 ) || ( sw == 1 ) ) { System . out . println ( s ) ; continue ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == '1' ) && ( sw == 0 ) ) { lef = i ; break ; } } for ( int i = n - 1 ; i > 0 ; i -- ) { if ( ( s . charAt ( i ) == '0' ) && ( sw == 0 ) ) { rig = i ; break ; } } String st = s . substring ( 0 , lef ) + '0' + s . substring ( rig + 1 ) ; System . out . println ( st ) ; }
public static int nthTerm ( int N ) { int nth = 0 ; for ( int i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }
public static boolean isPower ( int x , int y ) { if ( ( x == 1 ) && ( y == 1 ) ) return ( y == 1 ) ; int pow = 1 ; while ( ( pow < y ) ) pow = pow * x ; return ( pow == y ) ; }
public static boolean isPower ( int x , int y ) { if ( ( x == 1 ) && ( y == 1 ) ) return ( y == 1 ) ; int pow = 1 ; while ( ( pow < y ) || ( pow < x ) ) pow = pow * x ; return ( pow == y ) ; if ( ( isPower ( 10 , 1 ) ) && ( x == 1 ) ) System . out . print ( 1 ) ; else System . out . print ( 0 ) ; if ( ( isPower ( 1 , 20 ) ) && ( x == 1 ) ) System . out . print ( 1 ) ; else System . out . print ( 0 ) ; if ( ( isPower ( 2 , 128 ) ) && ( x == 1 ) ) System . out . print ( 1 ) ; else System . out . print ( 0 ) ; if ( ( isPower ( 2 , 30 ) ) && ( x == 1 ) ) System . out . print ( 1 ) ; else System . out . print ( 0 ) ; return ( pow == y ) ; }
public static double minimumValue ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; ; double answer = 0 ; ; for ( int i = 0 ; i < k ; i ++ ) { answer += arr [ i ] * arr [ i ] ; } ; return answer * ( 2 * k - 2 ) ; }
public static void bfs ( int x , boolean [ ] visited , int [ ] order ) { if ( visited [ x ] ) return ; visited [ x ] = true ; for ( int to : edges [ x ] ) bfs ( to , visited , order ) ; order [ x ] = x ; final int bfs_rev [ ] = { x } ; if ( visited [ x ] ) return ; visited [ x ] = true ; int ret = new int [ 200 ] ; for ( int to : rev_edges [ x ] ) ret += bfs_rev [ to ] ; System . arraycopy ( ret , 0 , order , 0 , ret . length ) ; int n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; ArrayList < Integer > edges = new ArrayList < Integer > ( ) ; for ( ; n > 0 ; n -- ) { int u , s , d ; u = Integer . parseInt ( System . getProperty ( " line . separator " ) ) - 1 ; d = Integer . parseInt ( System . getProperty ( " line . separator " ) ) - 1 + 100 ; if ( s == " lock " ) { edges . add ( d ) ; rev_edges . add ( d ) ; } else { edges . add ( u ) ; rev_edges . add ( d ) ; } } order [ x ] = ret ; visited [ x ] = false ; for ( int i = 0 ; i < 200 ; i ++ ) if ( ! visited [ i ] ) bfs ( i , visited , order ) ; order [ x ] = ret ; visited [ x ] = false ; for ( int i = 0 ; i < 200 ; i ++ ) if ( ! visited [ i ] ) if ( bfs_rev [ i ] . length >= 2 ) { System . out . println ( 1 ) ; break ; } else System . out . println ( 0 ) ; }
public static int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( ( N == 1 ) || ( N == 2 ) ) return 0 ; return ( int ) Math . pow ( 2 , E - 1 ) ; if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " win " ) ) { N = 4 ; System . out . println ( countWays ( N ) ) ; } return N ; }
public static int findLCM ( int [ ] arr , int n ) { int lcm = arr [ 0 ] ; ; for ( int i = 1 ; i < n - 1 ; i ++ ) { lcm = ( lcm * arr [ i ] ) / Math . gcd ( arr [ i ] , lcm ) ; ; } return lcm ; }
public static int getN ( ) { return Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ ns ▁ to ▁ display " ) ) ; }
public static void solve ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ solve " ) ) ; n = n * 4 ; int [ ] a = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ solve " ) . trim ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; HashMap < Integer , Integer > mp = new HashMap < > ( ) ; Arrays . sort ( a ) ; int i = 0 ; int j = n - 1 ; int area = a [ i ] * a [ j ] ; i ++ ; j -- ; while ( ( i < j ) && ( i < n ) ) { int x = a [ i ] * a [ j ] ; if ( ( x != area ) || ( x == area ) ) { System . out . println ( " NO " ) ; return ; } i ++ ; j -- ; } for ( i = 0 ; i <= n ; i ++ ) { if ( a [ i ] < mp . get ( i ) ) mp . put ( a [ i ] , ++ i ) ; else mp . put ( a [ i ] , 1 ) ; } for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( ( entry . getValue ( ) % 2 != 0 ) && ( entry . getValue ( ) % 2 != 0 ) ) { System . out . println ( " NO " ) ; return ; } } System . out . println ( " YES " ) ; }
public static int MinDeletion ( int [ ] a , int n ) { Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; ; for ( int i = 0 ; i < n ; i ++ ) map . put ( a [ i ] , i ) ; ; int ans = 0 ; for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { int x = entry . getKey ( ) ; int frequency = entry . getValue ( ) ; if ( ( x <= frequency ) && ( x > 0 ) ) ans += ( frequency - x ) ; else ans += frequency ; } ; return ans ; }
public static String fromStart ( String inp , int del11 ) { String inp1 = inp . substring ( 0 , del1 - 1 ) ; ; String inp2 = inp . substring ( del1 , inp . length ( ) ) ; ; return inp1 + inp2 ; }
public static int nondecdigits ( int n ) { int x ; for ( x = n ; x > 0 ; ) { int no = x ; int prevDigdig = 11 ; boolean flag = true ; while ( ( no != 0 ) && ( no % 10 == 0 ) ) { if ( ( prevDigdig < no % 10 ) && ( prevDigdig > no % 10 ) ) { flag = false ; break ; } prevDigdig = no % 10 ; no /= 10 ; } if ( ( flag == true ) && ( no % 10 == 0 ) ) break ; } return x ; }
public static int anti ( int a , int b , int c , int d ) { int l = Math . abs ( a - b ) ; ; int m = Math . abs ( b - d ) ; if ( anti == c ) { print ( a + m , b , c + m , d ) ; } else if ( b == d ) { print ( a , b + l , c , d + l ) ; } else if ( l != m ) { print ( - 1 ) ; } else { print ( a , d , c , b ) ; } return a ; }
x , y ; int t ; while ( ( t = input . nextInt ( ) ) > 1 && x * 10 + y > 21 ) { int t = Math . min ( x , 2 ) ; x -= t ; y -= ( 2 - t ) * 10 + 2 ; if ( ( y < 2 || 10 * x + y < 22 ) && ( y < 2 || 10 * x + y < 21 ) ) { CielWon = true ; break ; } y -= 2 ; t = Math . min ( 2 , y / 10 ) ; y -= 10 * t ; x -= 2 - t ; } System . out . println ( " Ciel " == CielWon ? " Hanako " : " Ciel " ) ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( System . in . readLine ( ) ) , m = Integer . parseInt ( System . in . readLine ( ) ) ; List < String > l = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = System . in . readLine ( ) ; s = Arrays . toString ( s ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( s . charAt ( j ) == ' . ' ) { if ( ( i + j ) & 1 ) { s . charAt ( j ) = ' W ' ; } else { s . charAt ( j ) = ' B ' ; } } } l . add ( s ) ; } for ( String c : l ) { System . out . println ( " " + c ) ; } }
public static final Iterable < Integer > find ( String s , char ch ) { return new Iterable < Integer > ( ) { public Iterator < Integer > iterator ( ) { return new Iterator < Integer > ( ) { int i = 0 , ltr = s . length ( ) ; public boolean hasNext ( ) { return ltr == ch ; } public Integer next ( ) { if ( '0' != s . charAt ( ltr ) ) { System . out . println ( n - 1 ) ; } else { int [ ] indices = find ( s , '0' ) ; if ( indices . length == 1 ) { System . out . println ( n ) ; } else { int maximum = 0 ; Iterator < Integer > combs = Arrays . asList ( indices ) . iterator ( ) ; while ( combs . hasNext ( ) ) { maximum = Math . max ( maximum , 2 + 2 * ( Math . abs ( indices [ 0 ] - indices [ 1 ] ) - 1 ) - ( Math . abs ( indices [ 0 ] - indices [ 1 ] ) - 1 ) ) ; } System . out . println ( s . indexOf ( '1' ) + maximum ) ; } return n ; } } ; } } ; }
public static int countDistictSubarray ( int [ ] arr , int n ) { Map < Integer , Integer > vis = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) vis . put ( arr [ i ] , 1 ) ; int k = vis . size ( ) ; Map < Integer , Integer > vid = new HashMap < Integer , Integer > ( ) ; int ans = 0 ; int right = 0 ; int window = 0 ; for ( int left = 0 ; left < n ; left ++ ) { while ( ( right < n && window < k ) || ( left < n && window > k ) ) { if ( arr [ right ] == 1 ) vid . put ( arr [ right ] , 1 ) ; else vid . put ( arr [ right ] , 1 ) ; if ( ( vid . get ( arr [ right ] ) == 1 ) || ( vid . get ( arr [ right ] ) == 0 ) ) window ++ ; right ++ ; } if ( ( window == k ) && ( right == n ) ) ans += ( n - right + 1 ) ; vid . put ( arr [ left ] , 1 ) ; if ( ( vid . get ( arr [ left ] ) == 0 ) || ( vid . get ( arr [ left ] ) == 1 ) ) window -- ; } return ans ; }
n , s ) { int ans = s ; for ( ; n > 0 ; n -- ) { int a = Math . min ( n , Math . max ( 0 , s ) ) ; int b = Math . max ( n , Math . min ( s , a ) ) ; ans = Math . max ( ans , a + b ) ; } System . out . println ( ans ) ; }
public static boolean isPrime ( int n ) { if ( ( n <= 1 ) || ( n <= 3 ) ) return false ; ; if ( ( n <= 2 ) || ( n <= 3 ) ) return true ; ; if ( ( n % 2 == 0 || n % 3 == 0 ) ) return false ; ; int i = 5 ; while ( ( i * i <= n ) && ( i < n ) ) { if ( ( n % i == 0 || n % ( i + 2 ) == 0 ) ) return false ; ; i = i + 6 ; } ; return true ; }
public static int countSetBits ( int n ) { int count = 0 ; ; while ( ( n > 0 ) && ( n < n ) ) { n &= ( n - 1 ) ; ; count ++ ; } ; final int pairs [ ] = new int [ n ] ; count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) ; ; if ( ( sum == k ) || ( sum == n ) ) { count ++ ; } ; } } ; if ( System . getSecurityManager ( ) == null ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; n = arr . length ; k = 4 ; System . out . println ( pairs [ n ] ) ; } ; return count ; }
public static final void reverseQueueFirstKElements ( int k , Queue < Integer > queue ) { if ( ( queue . isEmpty ( ) == true || k > queue . qsize ( ) ) && ( k <= 0 ) ) return ; if ( ( k <= 0 ) || ( k > queue . qsize ( ) ) ) return ; Stack < Integer > stack = new Stack < Integer > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { stack . push ( queue . queue . get ( 0 ) ) ; queue . get ( ) ; } while ( ( stack . size ( ) != 0 ) && ( stack . peek ( ) != null ) ) { queue . put ( stack . pop ( ) ) ; stack . pop ( ) ; } for ( int i = 0 ; i < queue . qsize ( ) - k ; i ++ ) { queue . put ( queue . queue . get ( 0 ) ) ; queue . get ( ) ; } }
public static int a ( ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ of ▁ digits " ) ) ; for ( int i = 0 ; i < a ; i ++ ) { int b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ of ▁ digits " ) ) ; int [ ] arr = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ of ▁ digits " ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int tmp = b ; int win1 = 0 ; int win2 = 0 ; int cnt = 0 ; for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ j ] % 2 == 0 ) cnt ++ ; } if ( cnt % 2 == 1 ) System . out . println ( " errorgorn " ) ; else System . out . println ( " maomao90" ) ; } return a ; }
public static int xorCalc ( int k ) { if ( ( k == 1 ) && ( k == 2 ) ) return 2 ; if ( ( ( ( k + 1 ) & k ) == 0 ) && ( k == 2 ) ) return k / 2 ; return 1 ; }
public static class Solution { public static boolean isPerfectSquare ( final int num ) { int low = 1 , high = num ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int midSquare = mid * mid ; if ( midSquare == num ) { return true ; } else if ( midSquare < num ) { low = mid + 1 ; } else { high = mid - 1 ; } } return false ; } }
public static int a ( ) { int a = Integer . parseInt ( input ) ; int b = Integer . parseInt ( input ) ; int c = Integer . parseInt ( input ) ; if ( ( 2 * Math . max ( a , b , c ) - ( a + b + c ) ) == 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return a ; }
public static void main ( String [ ] args ) { System . out . println ( " Enter ▁ a ▁ number ▁ of ▁ numbers : ▁ " ) ; final StringTokenizer st = new StringTokenizer ( " ▁ " , " " ) ; final int I = new Integer ( Integer . parseInt ( st . nextToken ( ) ) ) ; final int IS = new Integer ( Integer . parseInt ( st . nextToken ( ) ) ) ; final int IN = new Integer ( Integer . parseInt ( st . nextToken ( ) ) ) ; final float IF = new Float ( Float . parseFloat ( st . nextToken ( ) ) ) ; final int n = IN . intValue ( ) ; final int [ ] l = I . toArray ( ) ; int c = 0 ; final int [ ] r = new int [ n ] ; int s = Arrays . stream ( l ) . mapToInt ( i -> i + 1 ) . sum ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( s - l [ i ] ) / ( n - 1 ) == l [ i ] ) { c ++ ; r [ i ] = i + 1 ; } } System . out . println ( c ) ; System . out . println ( r [ 0 ] ) ; }
public static int [ ] [ ] nq ( ) { int [ ] [ ] nq = Arrays . copyOf ( input ( ) . split ( " ▁ " ) , input ( ) . length ) ; int [ ] [ ] queue = Arrays . copyOf ( nq , nq . length ) ; for ( int i = 0 ; i < nq [ 0 ] . length ; i ++ ) { queue [ i ] = input ( ) . split ( " ▁ " ) ; } int ti = 0 ; int cur = 0 ; while ( Integer . parseInt ( queue [ cur ] [ 1 ] ) > 0 ) { int [ ] num = queue [ cur ] ; int syori = Integer . parseInt ( num [ 1 ] ) - nq [ 1 ] ; if ( syori > 0 ) { num [ 1 ] = syori ; queue [ cur ] = num ; ti += nq [ 1 ] ; } else { ti += Integer . parseInt ( num [ 1 ] ) ; System . out . println ( " { } ▁ { } " . format ( num [ 0 ] , ti ) ) ; } cur ++ ; if ( queue . length <= cur ) { break ; } } return queue ; }
public static int findElement ( int [ ] arr , int [ ] [ ] ranges , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( ( left <= index && right >= index ) || ( left == index && right == index ) ) { if ( ( index == left ) || ( index == right ) ) { index = right ; } else { index = index - 1 ; } } } return arr [ index ] ; }
public static boolean hasValidNum ( int [ ] arr , int n ) { int [ ] spf = new int [ MAXN ] ; int [ ] hash1 = new int [ MAXN ] ; for ( int i = 0 ; i < MAXN ; i ++ ) { spf [ i ] = i ; } int [ ] sieve = new int [ MAXN ] ; for ( int i = 4 ; i < MAXN ; i += 2 ) { spf [ i ] = i ; } for ( int i = 3 ; i < MAXN ; i ++ ) { if ( i * i < MAXN ) { break ; } if ( ( spf [ i ] == i ) && ( spf [ i ] == i ) ) { for ( int j = i * i ; j < MAXN ; j += i ) { if ( ( spf [ j ] == j ) && ( spf [ j ] == i ) ) { spf [ j ] = i ; } } } } final int getFactorization ( int x ) { while ( ( x != 1 ) && ( x != 0 ) ) { int temp = spf [ x ] ; if ( ( x % temp == 0 ) && ( hash1 [ spf [ x ] ] > 1 ) ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( ( x % temp == 0 ) && ( x != 0 ) ) { x = x / temp ; } } } final boolean check = true ; while ( ( x != 1 ) && ( x != 0 ) ) { int temp = spf [ x ] ; if ( ( x % temp == 0 ) && ( hash1 [ temp ] > 1 ) ) { return false ; } while ( ( x % temp == 0 ) && ( x != 0 ) ) { x = x / temp ; } } return true ; }
public static boolean isExists ( int [ ] a , int n ) { int [ ] freq = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; Sum += a [ i ] ; } if ( Sum % 2 == 0 ) { if ( freq [ Sum / 2 ] ) { return true ; } } return false ; int [ ] a = { 5 , 1 , 2 , 2 } ; n = a . length ; if ( isExists ( a , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return true ; }
public static int areaOfKite ( int d1 , int d2 ) { int area = ( d1 * d2 ) / 2 ; ; return area ; }
public static String seats ( ) { seats = new String [ 3 ] ; seats [ 0 ] = '0' ; seats [ 1 ] = ' # ' ; seats [ 2 ] = ' . ' ; seats [ 3 ] = ' . ' ; seats [ 4 ] = ' . ' ; seats [ 5 ] = ' . ' ; seats [ 6 ] = ' . ' ; seats [ 7 ] = ' . ' ; seats [ 8 ] = ' . ' ; seats [ 9 ] = ' . ' ; seats [ 10 ] = ' . ' ; seats [ 11 ] = ' . ' ; seats [ 12 ] = ' . ' ; seats [ 13 ] = ' . ' ; seats [ 14 ] = ' . ' ; seats [ 15 ] = ' . ' ; seats [ 16 ] = ' . ' ; seats [ 17 ] = ' . ' ; seats [ 18 ] = ' . ' ; seats [ 19 ] = ' . ' ; seats [ 20 ] = ' . ' ; seats [ 21 ] = ' . ' ; seats [ 22 ] = ' . ' ; seats [ 23 ] = ' . ' ; seats [ 24 ] = ' . ' ; seats [ 25 ] = ' . ' ; seats [ 26 ] = ' . ' ; seats [ 27 ] = ' . ' ; seats [ 28 ] = ' . ' ; seats [ 29 ] = ' . ' ; seats [ 30 ] = ' . ' ; seats [ 31 ] = ' . ' ; seats [ 32 ] = ' . ' ; seats [ 33 ] = ' . ' ; seats [ 34 ] = ' . ' ; seats [ 35 ] = ' . ' ; seats [ 36 ] = ' . ' ; seats [ 37 ] = ' . ' ; seats [ 38 ] = ' . ' ; seats [ 39 ] = ' . ' ; seats [ 40 ] = ' . ' ; seats [ 41 ] = ' . ' ; seats [ 42 ] = ' . ' ; seats [ 43 ] = ' . ' ; seats [ 44 ] = ' . ' ; seats [ 45 ] = ' . ' ; seats [ 46 ] = ' . ' ; seats [ 47 ] = ' . ' ; seats [ 48 ] = ' . ' ; seats [ 49 ]
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ question " ) ) ; while ( n % 2 == 0 ) { n /= 2 ; } if ( n == 1 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } return n ; }
public static boolean productEqual ( int n ) { if ( n < 10 ) return false ; int prodOdd = 1 ; int prodEven = 1 ; while ( n > 0 ) { int digit = n % 10 ; prodOdd *= digit ; n = n / 10 ; if ( n == 0 ) break ; ; digit = n % 10 ; prodEven *= digit ; n = n / 10 ; } if ( prodOdd == prodEven ) return true ; return false ; }
public static List < Integer > charList ( ) { List < Integer > charList = Lists . newArrayList ( ) ; charList . add ( Character . MIN_VALUE ) ; charList . add ( Character . MAX_VALUE ) ; charList . add ( Character . MIN_VALUE ) ; charList . add ( Character . MAX_VALUE ) ; while ( true ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number : ▁ " ) ) ; if ( n == 0 ) break ; int [ ] keys = Arrays . copyOf ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ key : ▁ " ) , n ) ; String sentence = JOptionPane . showInputDialog ( " Enter ▁ a ▁ sentence : ▁ " ) ; for ( int i = 0 ; i < sentence . length ( ) ; i ++ ) { if ( sentence . charAt ( i ) . isUpperCase ( ) ) { int j = Character . digit ( sentence . charAt ( i ) , 10 ) - Character . digit ( sentence . charAt ( i ) , 10 ) + 26 ; if ( j < 0 ) j = Character . digit ( sentence . charAt ( i ) , 10 ) - Character . digit ( sentence . charAt ( i ) , 10 ) ; System . out . print ( charList . get ( j - keys [ i % keys . length ] ) + " ▁ " ) ; } } System . out . println ( ) ; } return charList ; }
public static void checkEVENodd ( int [ ] arr , int n , int l , int r ) { if ( ( arr [ r ] == 1 ) && ( arr [ l ] == 1 ) ) System . out . println ( " odd " ) ; else System . out . println ( " even " ) ; }
public static int i ( ) { Scanner i = new Scanner ( System . in ) ; int W = i . nextInt ( ) ; int H = i . nextInt ( ) ; int x = i . nextInt ( ) ; int y = i . nextInt ( ) ; int r = i . nextInt ( ) ; if ( x - r < 0 || y - r < 0 || x + r > W || y + r > H ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; } return r ; }
public static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
public static final int compositeProduct ( int [ ] arr , int n ) { int maxVal = Math . max ( arr ) ; boolean [ ] prime = new boolean [ maxVal + 1 ] ; prime [ 0 ] = true ; prime [ 1 ] = true ; for ( int p = 2 ; p <= mt . ceil ( mt . sqrt ( maxVal ) ) ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= maxVal ; i += p ) { prime [ i ] = false ; } } } int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == false ) { product *= arr [ i ] ; } } return product ; }
public static void main ( String [ ] args ) { while ( true ) { int x = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ input ▁ characters ▁ to ▁ be ▁ compared " ) ) ; int y = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ input ▁ characters ▁ to ▁ be ▁ compared " ) ) ; if ( x == 0 && y == 0 ) break ; List < Integer > liste = new ArrayList < Integer > ( ) ; liste . add ( x ) ; liste . add ( y ) ; Collections . sort ( liste ) ; System . out . println ( liste . get ( 0 ) + " ▁ " + liste . get ( 1 ) ) ; } }
public static void main ( String [ ] args ) { for ( ; ; ) { String n = JOptionPane . showInputDialog ( " Enter ▁ a ▁ number : ▁ " ) ; if ( n . startsWith ( " op " ) ) { System . out . println ( " FILIPINO " ) ; } else if ( n . startsWith ( " adinm " ) ) { System . out . println ( " KOREAN " ) ; } else { System . out . println ( " JAPANESE " ) ; } } }
public static int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left ; ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; ; return ans ; }
public static final int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; ; for ( int i = 0 ; i <= n + 1 ; i += a ) { for ( int j = 0 ; j <= n - i + 1 ; j += b ) { double z = ( n - ( i + j ) ) / c ; ; if ( ( Math . floor ( z ) == Math . ceil ( z ) ) && ( z > 0 ) ) { int x = i / a ; int y = j / b ; ; maxVal = Math . max ( maxVal , x + y + ( int ) z ) ; ; } } } return maxVal ; }
public static int [ ] a ( ) { int [ ] a = new int [ 10 ] ; for ( int i = 0 ; i < a . length ; i ++ ) a [ i ] = Integer . parseInt ( input ( ) ) ; Arrays . sort ( a ) ; for ( int i = 1 ; i < 4 ; i ++ ) System . out . println ( a [ a . length - i ] ) ; return a ; }
public static final int factorial ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ( ans ) ; } public static int numberOfPossiblePallindrome ( String string , int n ) { Map < String , Integer > mp = Maps . newHashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( string . charAt ( i ) == ' a ' ) mp . put ( string . substring ( i ) , 1 ) ; else mp . put ( string . substring ( i ) , 1 ) ; int k = 0 ; int num = 0 ; int den = 1 ; int fi ; for ( int it = 0 ; it < mp . size ( ) ; it ++ ) { if ( ( mp . get ( it ) % 2 == 0 ) && ( mp . get ( it ) / 2 == 0 ) ) fi = mp . get ( it ) / 2 ; else { fi = ( mp . get ( it ) - 1 ) / 2 ; k ++ ; } num = num + fi ; den = den * fact ( fi ) ; } if ( ( num != 0 ) && ( den != 0 ) ) num = fact ( num ) ; ans = num / den ; if ( ( k != 0 ) && ( k != 0 ) ) ans = ans * k ; return ( ans ) ; } public static String toString ( ) { String string = " ababab " ; int n = string . length ( ) ; System . out . println ( numberOfPossiblePallindrome ( string , n ) ) ; return string ; } }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ searched " ) ) ; List < Integer > l = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < JOptionPane . getMaxInputSize ( ) ; i ++ ) { if ( ( n == 1 ) && ( l . size ( ) == 0 ) ) { System . out . println ( "1" ) ; } else { while ( ( n > 1 ) && ( l . size ( ) == 0 ) ) { if ( ( l . get ( 0 ) == null ) || ( l . get ( 0 ) . equals ( " " ) ) ) { System . out . println ( "1" ) ; break ; } else if ( ( l . get ( 0 ) == null ) || ( l . get ( 0 ) . equals ( " " ) ) ) { System . out . println ( n ) ; break ; } else if ( ( l . get ( 0 ) != null ) && ( l . get ( 0 ) . equals ( " " ) ) ) { l . set ( 0 , n ) ; n /= 2 ; } else { l . set ( 0 , n ) ; n /= 2 ; } } } } return n ; }
public static int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
public static int t ( ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ be ▁ read " ) ) ; while ( t > 0 ) { String s = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ be ▁ read " ) ; boolean flag = false ? JOptionPane . YES_OPTION : JOptionPane . NO_OPTION ; if ( flag ) { int summ = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' A ' ) summ ++ ; else summ -- ; if ( summ < 0 ) { flag = false ; break ; } } } if ( flag ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; t -- ; } return t ; }
public static String firstSubstring ( String s ) { int n = s . length ( ) ; ; int c = 0 ; ; HashMap mpp = new HashMap ( ) ; ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == ' ▁ ' || s . charAt ( i ) == ' # ' ) && ( s . charAt ( i ) == ' ▁ ' ) ) { String s1 = s . substring ( c , i ) ; ; mpp . put ( s1 , 1 ) ; c = i + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == ' ▁ ' ) && ( s . charAt ( i ) == ' # ' ) ) continue ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( s . charAt ( j ) == ' ▁ ' ) && ( s . charAt ( j ) == ' # ' ) ) break ; String s1 = s . substring ( i , j + 1 ) ; String s2 = s1 ; s1 = s1 . substring ( 0 , s1 . length ( ) - 1 ) ; if ( s1 . contains ( " ▁ " ) ) { if ( mpp . get ( s1 ) ) return s2 ; } } } return " - 1" ; } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " linux " ) ) { s = " mango ▁ is ▁ sweet ▁ when ▁ nam ▁ en ▁ tastes ▁ it # " ; String s1 = firstSubstring ( s ) ; System . out . println ( s1 ) ; return s1 ; } return " " ; }
public static int countConsecutive ( int n ) { String s = Integer . toString ( n ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( ( s . charAt ( i ) == s . charAt ( i + 1 ) ) && ( s . charAt ( i + 2 ) == s . charAt ( i + 3 ) ) ) { count ++ ; } } return count ; }
public static void findAngle ( int n ) { int interiorAngle = ( int ) ( ( n - 2 ) * 180 / n ) ; int exteriorAngle = ( int ) ( 360 / n ) ; System . out . println ( " Interior ▁ angle : " + interiorAngle ) ; System . out . println ( " Exterior ▁ angle : " + exteriorAngle ) ; }
static final void nDigitPerfectSquares ( int n ) { System . out . print ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) + " ▁ " ) ; ; System . out . print ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ) ; ; }
public static void main ( String [ ] args ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) ; for ( int l = 0 ; l < t ; l ++ ) { JOptionPane . showMessageDialog ( null , " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ; String strm = JOptionPane . showInputDialog ( " Enter ▁ the ▁ string ▁ to ▁ print " ) ; int ls = strm . length ( ) ; strm = strm . substring ( 0 , ls ) ; if ( ls - strm . length ( ) > strm . length ( ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) ; String x = JOptionPane . showInputDialog ( " Enter ▁ the ▁ input ▁ string " ) ; String s = " " ; int count = 0 ; for ( int i = 0 ; i < x . length ( ) - 1 ; i += 2 ) { String k = x . substring ( i , i + 2 ) ; if ( k . contains ( " a " ) || k . contains ( " b " ) ) { k = " ab " ; count = count + 1 ; } s = s + k ; } System . out . println ( count ) ; System . out . println ( s ) ; }
public static final int [ ] countSubsequences ( int i , int n , int k , int [ ] a , int [ ] prefix ) { if ( ( n == 0 ) || ( n == 1 ) ) return new int [ ] { 1 } ; int p = power ( a , n / 2 ) ; p = p * p ; if ( ( n & 1 ) != 0 ) p = p * a ; return new int [ ] { p } ; } public static void solve ( int i , int n , int sum , int k , int [ ] a , int [ ] prefix ) { discard_count = 0 ; if ( ( sum > k ) && ( sum > k ) ) { discard_count += power ( 2 , n - i ) ; return ; } if ( ( i == n ) || ( i == 0 ) ) return ; int rem = prefix [ n - 1 ] - prefix [ i ] ; if ( ( sum + a [ i ] + rem > k ) && ( sum + a [ i ] ) > k ) solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) ; if ( ( sum + rem > k ) && ( sum + a [ i ] ) > k ) solve ( i + 1 , n , sum , k , a , prefix ) ; } public static void countSubsequences ( int [ ] arr , int n , int K ) { sum = 0.0 ; int k = log2 ( K ) ; int [ ] prefix = new int [ n ] ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = log2 ( arr [ i ] ) ; sum += a [ i ] ; } prefix [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; } int total = power ( 2 , n ) - 1 ; if ( ( sum <= k ) && ( sum <= k ) ) return ; solve ( 0 , n , 0.0 , k , a , prefix ) ; } }
public static class newNode { public static final Node < Integer > data = new Node < Integer > ( ) { public Integer data ( ) { return data ; } public Node < Integer > left ( ) { return null ; } public Node < Integer > right ( ) { return null ; } } ; }
public static int main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . nextLine ( ) ) ; int [ ] si = new int [ n + 1 ] , sj = new int [ n + 1 ] ; String s = sc . nextLine ( ) . trim ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sj [ i + 1 ] = sj [ i ] + ( s . charAt ( i ) == ' J ' ) ? 1 : 0 ; si [ i + 1 ] = si [ i ] + ( s . charAt ( i ) == ' I ' ) ? 1 : 0 ; } int ans = a = b = c = 0 ; for ( int i = 1 ; i < n ; i ++ ) { a = Math . max ( a , sj [ i ] * ( si [ n ] - si [ i ] ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' O ' ) { b += si [ n ] - si [ i + 1 ] ; c += sj [ i ] ; ans += ( si [ n ] - si [ i + 1 ] ) * sj [ i ] ; } } System . out . println ( ans + Math . max ( a , b ) + " ▁ " + c ) ; }
public static class Dice { public static void init ( String eyes ) { _eyes = new String [ ] { " dummy " } ; } @ SuppressWarnings ( " unused " ) public String eye ( ) { return _eyes [ 1 ] ; } @ SuppressWarnings ( " unused " ) public void roll ( String direction ) { String [ ] a = _eyes ; if ( direction . equals ( " N " ) ) { _eyes = new String [ ] { " dummy " , a [ 2 ] , a [ 6 ] , a [ 3 ] , a [ 4 ] , a [ 1 ] , a [ 5 ] } ; } else if ( direction . equals ( " S " ) ) { _eyes = new String [ ] { " dummy " , a [ 5 ] , a [ 1 ] , a [ 3 ] , a [ 4 ] , a [ 6 ] , a [ 2 ] } ; } else if ( direction . equals ( " W " ) ) { _eyes = new String [ ] { " dummy " , a [ 3 ] , a [ 2 ] , a [ 6 ] , a [ 1 ] , a [ 5 ] , a [ 4 ] } ; } else if ( direction . equals ( " E " ) ) { _eyes = new String [ ] { " dummy " , a [ 4 ] , a [ 2 ] , a [ 1 ] , a [ 6 ] , a [ 5 ] , a [ 3 ] } ; } else { throw new IllegalArgumentException ( " NEWS箱推し " ) ; } } eyes = JOptionPane . showInputDialog ( null , _eyes ) ; Dice dice = new Dice ( _eyes ) ; String [ ] direction_text = JOptionPane . showInputDialog ( null , " Enter ▁ the ▁ eye ▁ to ▁ roll ▁ to ▁ the ▁ dice " ) ; for ( int i = 0 ; i < direction_text . length ; i ++ ) { dice . roll ( direction_text [ i ] ) ; } System . out . println ( dice . eye ) ; }
class node { public static node ( int data ) { this . data = data ; this . next = null ; } } public static node add ( int data ) { node newnode = new node ( 0 ) ; newnode . data = data ; newnode . next = null ; return newnode ; } public static void printArr ( int [ ] a , int n ) { int i = 0 ; while ( ( i < n ) && ( i < a . length ) ) { System . out . print ( a [ i ] + " ▁ " ) ; i = i + 1 ; } } }
static final public int nonDecNums ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; } return Integer . parseInt ( a [ n ] [ 0 ] ) ; }
public static void main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ searched " ) ) ; int [ ] l = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ list ▁ of ▁ digits ▁ to ▁ be ▁ searched " ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; Map < Integer , Integer > map = new HashMap < > ( ) ; int f = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( i + l [ i ] ) % n ; if ( map . containsKey ( x ) ) { f = 1 ; break ; } else { map . put ( x , 1 ) ; } } if ( f == 1 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } } }
public static class Solution { public static int minMoves ( final int [ ] nums ) { if ( nums == null || nums . length == 0 ) return 0 ; int minNum = Math . min ( nums ) ; return Arrays . stream ( nums ) . mapToInt ( i -> i - minNum ) . sum ( ) ; } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " windows " ) ) { Solution sObj = new Solution ( ) ; int [ ] nums = { 1 , 2 , 3 } ; int out = sObj . minMoves ( nums ) ; System . out . println ( out ) ; return out ; } return 0 ; }
public static int a ( ) { int a , b ; a = map . get ( ) ; b = map . get ( ) ; if ( a <= 0 && 0 <= b ) { System . out . println ( " Zero " ) ; } else if ( a < 0 && Math . min ( b - a , - a ) % 2 == 0 ) { System . out . println ( " Negative " ) ; } else { System . out . println ( " Positive " ) ; } return a ; }
public static int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; }
public static int MAX_CHAR = 256 ; public static int maximumChars ( String str1 ) { int n = str1 . length ( ) ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { firstInd [ ( char ) str1 . charAt ( i ) ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { int firstInd [ ( char ) str1 . charAt ( i ) ] = i ; if ( ( firstInd [ i ] == - 1 ) && ( firstInd [ i ] == 0 ) ) { firstInd [ ( char ) str1 . charAt ( i ) ] = i ; } else { res = Math . max ( res , Math . abs ( i - firstInd [ i ] - 1 ) ) ; } } str1 = " abba " ; System . out . println ( maximumChars ( str1 ) ) ; return res ; }
n , d ) { int [ ] z = map ( ) . get ( 0 ) ; int L = 0 ; int R = 0 ; int ans = 0 ; int ans1 = 0 ; while ( L < n && R < n ) { ans = Math . max ( z [ R ] . intValue ( ) , ans ) ; if ( Math . abs ( z [ L ] . intValue ( ) - z [ R ] . intValue ( ) ) < d ) { ans1 += z [ R ] . intValue ( ) ; R ++ ; } else { ans = Math . max ( ans1 , ans ) ; ans1 -= z [ L ] . intValue ( ) ; L ++ ; } } System . out . println ( Math . max ( ans , ans1 ) ) ; }
public static final double findArea ( double a ) { double area = 5 * Math . sqrt ( 3 ) * a * a ; return area ; }
public static void compute ( ) { int [ ] ninePyramidalPDF = { 1 } ; int [ ] PYRAMIDAL_DIE_PDF = { 0 , 1 , 1 , 1 , 1 } ; for ( int i = 0 ; i < 9 ; i ++ ) { ninePyramidalPDF = convolve ( ninePyramidalPDF , PYRAMIDAL_DIE_PDF ) ; } int [ ] six_cubic_pdf = { 1 } ; int [ ] CUBIC_DIE_PDF = { 0 , 1 , 1 , 1 , 1 , 1 , 1 } ; for ( int i = 0 ; i < 6 ; i ++ ) { six_cubic_pdf = convolve ( six_cubic_pdf , CUBIC_DIE_PDF ) ; } double ans = 0 ; for ( int i = 0 ; i < ninePyramidalPDF . length ; i ++ ) { ans += ninePyramidalPDF [ i ] * sum ( six_cubic_pdf , 0 , i ) ; } ans = ( double ) ans / ( sum ( ninePyramidalPDF ) * sum ( six_cubic_pdf ) ) ; System . out . println ( MessageFormat . format ( " { 0 } " , ans ) ) ; }
public static int N = 6 ; int Even = N / 2 ; int Odd = N - Even ; System . out . println ( Even * Odd ) ; }
public static int solve ( int M , int N , int s ) { if ( ( N % s == 0 ) && ( M % s == 0 ) ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( ( M % s == 0 ) && ( N % s == 0 ) ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return M * N ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) return b ; ; return gcd ( b % a , a ) ; } public static final int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } public static int countPairs ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) && ( lcm ( arr [ j ] , arr [ i ] ) == lcm ( arr [ j ] , arr [ i ] ) ) ) ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 } ; int n = arr . length ; ; System . out . println ( countPairs ( arr , n ) ) ; } }
public static int [ ] scoresOfTheParticipants ( ) { int [ ] scoresOfTheParticipants = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ participants ▁ to ▁ process " ) . toArray ( ) ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; int totalScores = Arrays . stream ( scoresOfTheParticipants ) . mapToInt ( Integer :: intValue ) . sum ( ) ; int chosenTeams = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { for ( int j = i + 1 ; j < 6 ; j ++ ) { for ( int k = j + 1 ; k < 6 ; k ++ ) { if ( scoresOfTheParticipants [ i ] + scoresOfTheParticipants [ j ] + scoresOfTheParticipants [ k ] == totalScores - ( scoresOfTheParticipants [ i ] + scoresOfTheParticipants [ j ] + scoresOfTheParticipants [ k ] ) ) { chosenTeams ++ ; } } } } if ( chosenTeams == 0 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; } return scoresOfTheParticipants ; }
private static int popcnt32 ( int number ) { int counter = 0 ; while ( ( number > 0 ) && ( number % 2 == 1 ) ) { if ( ( number % 2 == 1 ) ) { counter = counter + 1 ; } number = ( int ) ( number / 2 ) ; } return counter ; final int a = 1 ; final int n = popcnt32 ( a ) ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { res = ( int ) ( res | ( 1 << ( 32 - i ) ) ) ; } return Math . abs ( res ) ; }
public static int t ( ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ test " ) ) ; for ( ; ; ) { int n = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ test " ) ; int k = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ test " ) ; int [ ] lst = Arrays . copyOf ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ test " ) , n ) ; int cnt = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( lst [ i ] > k ) { cnt ++ ; } } System . out . println ( cnt ) ; } }
public static int a1 , a2 ; int t = 0 ; if ( a1 == 1 && a2 == 1 ) { System . out . println ( 0 ) ; } else { while ( a1 > 0 && a2 > 0 ) { if ( a1 > a2 ) { a2 ++ ; a1 -= 2 ; } else { a2 -= 2 ; a1 ++ ; } t ++ ; } System . out . println ( t ) ; } return t ; }
public static class Solution { public static int xorQueries ( final int [ ] arr , final int [ ] queries ) { final int [ ] pref = new int [ arr . length ] ; pref [ 0 ] = 0 ; for ( int e : arr ) { pref [ e ] = pref [ e - 1 ] ; } final int [ ] ans = new int [ queries . length ] ; for ( int [ ] l : queries ) { ans [ l [ 0 ] ] = pref [ r [ l [ 0 ] ] ] ^ pref [ l [ 1 ] ] ; } return ans . length ; } }
public static String encodedChar ( String str , int k ) { String expand = " " ; int freq = 0 ; int i = 0 ; while ( ( i < str . length ( ) ) && ( i < k ) ) { String temp = " " ; freq = 0 ; while ( ( i < str . length ( ) ) && ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) ) { temp += str . charAt ( i ) ; i ++ ; } while ( ( i < str . length ( ) ) && ( str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) ) { freq = freq * 10 + str . charAt ( i ) - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j += 1 ) { expand += temp ; } } if ( ( freq == 0 ) && ( k > 0 ) ) { expand += temp ; } return expand . charAt ( k - 1 ) ; }
public static void printPossible ( int a , int b , int c ) { if ( ( ( a + b + c ) % 2 != 0 || a + b < c ) && ( a + b < c ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; }
public static int summation ( int n ) { int absSum = n * ( n + 1 ) / 2 ; ; int sign = 1 == ( ( n + 1 ) % 2 == 0 ) ? - 1 : 1 ; int resultSum = sign * absSum ; ; return resultSum ; }
public static void sortSquare ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] * arr [ i ] ; } Arrays . sort ( arr ) ; }
n , t ) STRNEWLINE ▁ * ▁ @ return ▁ true ▁ if ▁ the ▁ number ▁ is ▁ equal ▁ to ▁ t STRNEWLINE ▁ */ public static boolean isEqualToT ( int t ) { int [ ] a = Arrays . copyOf ( input , n ) ; boolean f = false ; int c = 1 ; int i = 0 ; while ( true ) { c = ( i + 1 ) + a [ i ] ; if ( ( c - 1 ) < i ) break ; if ( c == t ) { f = true ; break ; } if ( c > t ) break ; i = c - 1 ; } if ( f ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; return f ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] A = new int [ n ] , l = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = i ; } return l ; }
public static final boolean isTriangular ( double num ) { if ( ( num < 0 ) || ( num > 1 ) ) return false ; double c = ( - 2 * num ) ; double b = 1 , a = 1 ; double d = ( b * b ) - ( 4 * a * c ) ; if ( ( d < 0 ) || ( d > 1 ) ) return false ; double root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; double root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( ( root1 > 0 ) && Math . floor ( root1 ) == root1 ) return true ; if ( ( root2 > 0 ) && Math . floor ( root2 ) == root2 ) return true ; return false ; }
public static void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) { System . out . print ( - 1 + " ▁ " ) ; } else { System . out . print ( d + " ▁ " ) ; k -- ; while ( k -- > 0 ) { System . out . print ( 0 + " ▁ " ) ; k -- ; } } if ( Main . isDebug ( ) ) { k = 4 ; d = 4 ; printNumberWithDR ( k , d ) ; } }
public static void rotateMatrix ( int [ ] [ ] mat ) { int i = N - 1 ; ; while ( ( i >= 0 ) && ( i < N ) ) { int j = N - 1 ; ; while ( ( j >= 0 ) ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; ; j = j - 1 ; } System . out . println ( ) ; ; i = i - 1 ; } ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ display " ) ) ; if ( n % 500 == 0 ) { System . out . println ( n ) ; } else { System . out . println ( ( n / 500 ) * 500 ) ; } return n ; }
public static int getProduct ( int n ) { int product = 1 ; while ( ( n != 0 ) && ( n % 10 == 0 ) ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
public static int [ ] getCoinsByNumber ( int number ) { while ( 1 ) { int b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ get ▁ coins ▁ for " ) ) ; int r = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ get ▁ coins ▁ for " ) ) ; int g = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ get ▁ coins ▁ for " ) ) ; int c = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ get ▁ coins ▁ for " ) ) ; int s = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ get ▁ coins ▁ for " ) ) ; int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ get ▁ coins ▁ for " ) ) ; if ( t == 0 ) break ; int cnt = b * 5 + r * 3 + s ; int coins = ( b * 5 + r * 3 ) * ( 15 - 2 ) ; coins += b * 15 ; coins += r * 15 ; coins += 7 * g ; coins += 2 * c ; coins += 100 - ( t - cnt ) * 3 ; System . out . println ( coins ) ; } return new int [ ] { coins } ; }
public static int maxn ( ) { int maxn = 1010 ; int mod = 1000000007 ; int [ ] [ ] comb = new int [ maxn ] [ maxn ] ; for ( int i = 0 ; i < maxn ; i ++ ) { comb [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < maxn ; i ++ ) { comb [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i ; j ++ ) { comb [ i ] [ j ] = comb [ i - 1 ] [ j ] + comb [ i - 1 ] [ j - 1 ] % mod ; } } } int k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ cards ▁ to ▁ be ▁ searched " ) ) ; int [ ] color = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { color [ i ] = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ color ▁ to ▁ be ▁ searched " ) ) ; } int res = 1 ; int total = 0 ; for ( int i = 0 ; i < k ; i ++ ) { res = ( res * comb [ total + color [ i ] - 1 ] [ color [ i ] - 1 ] ) % mod ; total += color [ i ] % mod ; } System . out . println ( res % mod ) ; return res ; }
public static final double PI = 3.14159265 ; public static final double lengthRope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
public static int reverseDigits ( int num ) { int revNum = 0 ; ; while ( ( num > 0 ) && ( revNum < num ) ) { revNum = revNum * 10 + num % 10 ; num = num / 10 ; } return revNum ; } public static final boolean isPalindrome ( int n ) { int revN = reverseDigits ( n ) ; ; if ( ( revN == n ) && ( revN > 0 ) ) return true ; else return false ; } public static String toString ( int n ) { if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " win " ) ) { int n = 4562 ; if ( isPalindrome ( n ) == 1 ) { System . out . println ( " Is " + n + " ▁ a ▁ Palindrome ▁ number ? ▁ - > " + true ) ; } else { System . out . println ( " Is " + n + " ▁ a ▁ Palindrome ▁ number ? ▁ - > " + false ) ; } n = 2002 ; if ( isPalindrome ( n ) == 1 ) { System . out . println ( " Is " + n + " ▁ a ▁ Palindrome ▁ number ? ▁ - > " + true ) ; } else { System . out . println ( " Is " + n + " ▁ a ▁ Palindrome ▁ number ? ▁ - > " + false ) ; } return " " ; } }
public static class Solution { public static String addStrings ( final String num1 , final String num2 ) { final StringBuilder res = new StringBuilder ( ) ; int pos1 = num1 . length ( ) - 1 ; int pos2 = num2 . length ( ) - 1 ; int carry = 0 ; while ( pos1 >= 0 || pos2 >= 0 || carry == 1 ) { int digit1 = digit2 = 0 ; if ( pos1 >= 0 ) digit1 = Character . digit ( num1 . charAt ( pos1 ) , 10 ) - '0' ; if ( pos2 >= 0 ) digit2 = Character . digit ( num2 . charAt ( pos2 ) , 10 ) - '0' ; res . append ( String . valueOf ( ( digit1 + digit2 + carry ) % 10 ) ) ; carry = ( digit1 + digit2 + carry ) / 10 ; pos1 -- ; pos2 -- ; } return res . toString ( ) ; } }
public static boolean isPerfect ( int n ) { int sum = 1 ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { sum = sum + i + n / i ; } i ++ ; } return ( true == sum && n != 1 ) ; }
public static final boolean isPower ( int n ) { if ( ( n <= 1 ) && ( n > 0 ) ) return true ; for ( int x = 2 ; x <= ( int ) ( Math . sqrt ( n ) ) ; x ++ ) { int p = x ; while ( ( p <= n ) && ( p > 0 ) ) { p = p * x ; if ( ( p == n ) && ( p > 0 ) ) return true ; } } return false ; }
public static boolean isPower ( int n ) { if ( ( n == 1 ) || ( n == 2 ) ) return true ; for ( int x = 2 ; ( x <= ( int ) ( Math . sqrt ( n ) ) ) ; x ++ ) { int y = 2 ; int p = ( int ) ( Math . pow ( x , y ) ) ; while ( ( p <= n && p > 0 ) || ( p == n ) ) { if ( ( p == n ) || ( p == 2 ) ) return true ; y = y + 1 ; p = Math . pow ( x , y ) ; } } return false ; }
public static final void findTwoNumbers ( int sum , int gcd ) { if ( ( gcd == gcd ) && ( sum - gcd == gcd ) ) { System . out . println ( " a ▁ = ▁ " + Math . min ( gcd , sum - gcd ) + " , ▁ b ▁ = ▁ " + sum - Math . min ( gcd , sum - gcd ) ) ; } else { System . out . println ( - 1 ) ; } }
public static int main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int rb = Integer . parseInt ( input . nextLine ( ) ) , cb = Integer . parseInt ( input . nextLine ( ) ) , rd = Integer . parseInt ( input . nextLine ( ) ) , cd = Integer . parseInt ( input . nextLine ( ) ) ; int t = 0 ; int df = 1 , dp = 1 ; while ( true ) { if ( rb == n ) df = - 1 * df ; if ( cb == m ) dp = - 1 * dp ; if ( rb == rd || cb == cd ) break ; rb += df ; cb += dp ; t ++ ; } System . out . println ( t ) ; } }
public static int N ( int A , int B , int C , int D ) { if ( ( A <= N || C <= N ) && ( N % A == 0 ) ) { if ( N % A == 0 ) { int X = ( int ) ( N / A ) * B ; if ( N % A == 0 ) { int Y = ( int ) ( N / C ) * D ; if ( N % C == 0 ) { int X = ( int ) ( N / B ) * D ; if ( N % B == 0 ) { Y = ( int ) ( N / C ) * D ; } } } else { X = B ; Y = D ; } if ( X <= Y ) { System . out . println ( ( int ) X ) ; } else { System . out . println ( ( int ) Y ) ; } } } else { int X = B ; int Y = D ; if ( X <= Y ) { System . out . println ( ( int ) X ) ; } else { System . out . println ( ( int ) Y ) ; } } return ( int ) ( A / B ) ; }
public static int totalPairs ( int [ ] arr , int n ) { Map < Integer , Integer > m = Maps . newHashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = bin ( arr [ i ] ) . indexOf ( '1' ) ; m . put ( x , m . get ( x ) + 1 ) ; ; } int result = 0 ; for ( Integer it : m . keySet ( ) ) { result += ( m . get ( it ) * ( m . get ( it ) - 1 ) ) / 2 ; } return result ; }
public static int centerHexadecagonalNum ( int n ) { return 8 * n * n - 8 * n + 1 ; }
static int q , h , s , d ; int n ; n = Integer . parseInt ( input . nextLine ( ) ) ; pricesfor2 [ ] = new int [ ] { q * 8 , h * 4 , s * 2 , d } ; pricesfor2 = Arrays . copyOf ( pricesfor2 , n + 1 ) ; nep = n % 2 == 1 ; n /= 2 ; int res = n * pricesfor2 [ 0 ] ; if ( ( nep ) && ( res == q ) ) res += Math . min ( q * 4 , Math . min ( h * 2 , s ) ) ; System . out . println ( res ) ; return res ; }
public static int countNumbers ( int L , int R , int K ) { if ( ( K == 9 ) && ( L > R ) ) K = 0 ; int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( ( rem1 == K ) && ( rem > k ) ) ans ++ ; } return ans ; }
public static final void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; inp = new Function < Integer , Integer > ( ) { public Integer apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f ) { return Arrays . stream ( Integer . parseInt ( input . nextLine ( ) ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . sum ( ) ; } } ; int answer = 0 ; int a = input . nextInt ( ) ; int b = input . nextInt ( ) ; int c = input . nextInt ( ) ; int d = input . nextInt ( ) ; int e = input . nextInt ( ) ; int f = input . nextInt ( ) ; System . out . println ( answer ) ; for ( int T = 0 ; T < 1 ; T ++ ) { a = Integer . parseInt ( input . nextLine ( ) ) ; b = Integer . parseInt ( input . nextLine ( ) ) ; c = Integer . parseInt ( input . nextLine ( ) ) ; d = Integer . parseInt ( input . nextLine ( ) ) ; e = Integer . parseInt ( input . nextLine ( ) ) ; f = Integer . parseInt ( input . nextLine ( ) ) ; System . out . println ( answer ) ; } }
public static class Solution { int Solve ( final int [ ] A ) { int ans = 2 ; int n = A . length ; if ( n <= 2 ) return n ; int [ ] llap = new int [ n ] ; Arrays . fill ( llap , 2 ) ; Arrays . sort ( A ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 ; int k = j + 1 ; while ( ( i >= 0 ) && ( k < n ) ) { if ( A [ i ] + A [ k ] == 2 * A [ j ] ) { llap [ j ] = Math . max ( llap [ k ] + 1 , llap [ j ] ) ; ans = Math . max ( ans , llap [ j ] ) ; i -- ; k ++ ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) k ++ ; else i -- ; } } return ans ; } }
public static int minimumChanges ( int [ ] arr , int n , int d ) { int maxFreq = - 2147483648 ; int [ ] freq = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int a0 = arr [ i ] - i * d ; if ( a0 < freq [ 0 ] ) freq [ a0 ] ++ ; else freq [ a0 ] = 1 ; if ( freq [ a0 ] > maxFreq ) maxFreq = freq [ a0 ] ; } return ( n - maxFreq ) ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = i ; a = Arrays . copyOf ( a , n ) ; a = Arrays . stream ( a ) . filter ( x -> Arrays . binarySearch ( c , x . substring ( 0 , 3 ) ) >= 0 ) . toArray ( ) ; System . out . println ( Math . min ( a , Integer . MAX_VALUE ) . intValue ( ) + 1 ) ; return a . length ; }
public static int countPoints ( int n , int m , int [ ] a , int [ ] b , int x , int y ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int j = 0 , count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) || ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) ) { count ++ ; j ++ ; break ; } else { j ++ ; } } } return count ; }
public static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x > > 1 ) ; }
public static boolean check ( int x ) { int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += v [ i ] - x ; if ( sum >= s ) return true ; else return false ; int t = 1 ; while ( t > 0 ) { t -- ; int n = ( int ) Math . sqrt ( ( double ) Math . ceil ( ( double ) Math . log ( x ) ) ) ; int s = ( int ) Math . sqrt ( ( double ) Math . log ( n ) ) ; int [ ] v = Arrays . copyOf ( input , n ) ; sum = 0 ; int l = 0 ; int r = 0x3f3f3f3f ; for ( int i = 0 ; i <= n ; i ++ ) { sum += v [ i ] ; r = Math . min ( v [ i ] , r ) ; } if ( sum < s ) System . out . println ( - 1 ) ; else { while ( l < r ) { int mid = ( l + r + 1 ) > > > 1 ; if ( check ( mid ) == true ) l = mid ; else r = mid - 1 ; } System . out . println ( l ) ; } } return false ; }
public static int longestSubstring ( String s ) { int cnt = 1 ; ; int maxi = 1 ; int n = s . length ( ) ; ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) != s . charAt ( i - 1 ) ) && ( s . charAt ( i ) != s . charAt ( i - 1 ) ) ) { cnt ++ ; } else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
public static void main ( String [ ] args ) { int k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number " ) ) ; int ans [ 50 ] ; for ( int i = 0 ; i < 50 ; i ++ ) ans [ - 1 - i ] += k / 50 ; for ( int i = 0 ; i < k % 50 ; i ++ ) ans [ - 1 - i ] += 1 ; System . out . println ( 50 ) ; System . out . println ( new Integer ( ans [ 0 ] ) ) ; }
public static int zeroUpto ( int digits ) { int first = ( int ) ( ( Math . pow ( 10 , digits ) - 1 ) / 9 ) ; ; int second = ( int ) ( ( Math . pow ( 9 , digits ) - 1 ) / 8 ) ; ; return 9 * ( first - second ) ; }
static final double cone ( double a ) { if ( ( a < 0 ) || ( a > 1 ) ) return - 1 ; ; double r = ( a * Math . sqrt ( 2 ) ) / 3 ; ; double h = ( 2 * a ) / 3 ; ; double V = 3.14 * Math . pow ( r , 2 ) * h ; ; return V ; }
public static final boolean Prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i <= mt . ceil ( mt . sqrt ( n + 1 ) ) ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
public static double sum ( int n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; }
public static int countElements ( int [ ] p , int n ) { int ans = 0 ; ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) || ( p [ i ] < p [ i + 1 ] && p [ i ] < p [ i + 1 ] ) ) ans ++ ; else if ( ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) || ( p [ i ] < p [ i + 1 ] && p [ i ] > p [ i + 1 ] ) ) ans ++ ; } return ans ; }
x , y = input . nextLine ( ) ; System . out . println ( ' = ' == x ? ' > ' : ' < ' ) ; }
static int findVolume ( int l , int b , int h ) { return ( ( l * b * h ) / 2 ) ; }
n , k ; String s = map . get ( n ) ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) count [ ( char ) s . charAt ( i ) - ' A ' ] ++ ; Arrays . sort ( count ) ; int res = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] >= k ) { res += k * k ; System . out . println ( res ) ; System . exit ( ) ; } k -= count [ i ] ; res += count [ i ] * 2 ; } System . out . println ( res ) ; }
public static String compute ( ) { int i = 286 ; int j = 166 ; int k = 144 ; while ( true ) { int triangle = i * ( i + 1 ) / 2 ; int pentagon = j * ( j * 3 - 1 ) / 2 ; int hexagon = k * ( k * 2 - 1 ) ; int minimum = Math . min ( triangle , pentagon , hexagon ) ; if ( minimum == Math . max ( triangle , pentagon , hexagon ) ) { return String . valueOf ( triangle ) ; } if ( minimum == triangle ) { i ++ ; } if ( minimum == pentagon ) { j ++ ; } if ( minimum == hexagon ) { k ++ ; } } if ( System . getSecurityManager ( ) == null ) { System . out . println ( compute ( ) ) ; } return " " ; }
public static int maxPrimefactorNum ( int N ) { if ( ( N < 2 ) || ( N > N ) ) return 0 ; ; boolean arr [ ] = new boolean [ N + 1 ] ; arr [ 0 ] = true ; ; int prod = 1 ; int res = 0 ; int p = 2 ; while ( ( p * p <= N ) && ( arr [ p ] == true ) ) { if ( ( arr [ p ] == true ) || ( arr [ p ] == false ) ) { for ( int i = p * 2 ; i < N ; i += p ) arr [ i ] = false ; prod *= p ; if ( ( prod > N ) && ( arr [ i ] == false ) ) return res ; res ++ ; } p ++ ; } return res ; }
public static final boolean checkDivisors ( int [ ] a , int n ) { int X = Math . max ( a ) ; int [ ] b = new int [ n ] ; for ( int i = 1 ; i <= Integer . MAX_VALUE ; i ++ ) { if ( ( X % i == 0 ) && ( X / i != i ) ) { b [ i ] = i ; if ( ( X / i != i ) && ( X % i != i ) ) b [ i ] = X / i ; } } if ( ( b . length != n ) && ( b [ n ] != a [ n - 1 ] ) ) return false ; Arrays . sort ( a , 0 , n ) ; Arrays . sort ( b , 0 , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( b [ i ] != a [ i ] ) && ( b [ i ] != a [ i ] ) ) return false ; } return true ; }
public static void subArray ( int [ ] arr , int n ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) { System . out . print ( arr [ k ] + " ▁ " ) ; } System . out . print ( " \n " ) ; } } arr [ 0 ] = 1 ; arr [ 1 ] = 2 ; arr [ 2 ] = 3 ; arr [ 3 ] = 4 ; n = arr . length ; System . out . println ( " All ▁ Non - empty ▁ Subarrays " ) ; subArray ( arr , n ) ; ; }
for ( int n , i ) { System . out . println ( * ( ( 0 - - n // 6 , n // 4 ) , new int [ - 1 ] ) [ n % 2 > 0 || n < 3 ] ) ; }
public static int maxSum ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * i ; } return sum ; }
public static int maxSum ( int [ ] a , int n ) { Arrays . sort ( a ) ; ; int sum = 0 ; ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } ; return sum ; }
public static int findAnswer ( int n , int [ ] arr ) { Arrays . sort ( arr , 0 , n ) ; int sum = 0 ; for ( int i = 0 ; i < ( int ) ( n / 2 ) ; i ++ ) { sum += ( ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ) ; } return sum ; }
public static int findSum ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int sum = arr [ 0 ] ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( ( arr [ i ] != arr [ i + 1 ] ) && ( arr [ i + 1 ] != arr [ i ] ) ) { sum = sum + arr [ i + 1 ] ; } } return sum ; }
_MIN - 2147483648 ; _MAX - 2147483648 ; class newnode { public newnode ( int data ) { this . data = data ; this . left = null ; this . right = null ; } } public static TreeNode getDeepestLeftLeafNode ( TreeNode root ) { if ( ( root == null ) || ( root . left == null ) ) return null ; LinkedList < TreeNode > q = new LinkedList < TreeNode > ( ) ; q . add ( root ) ; TreeNode result = null ; while ( ( q . size ( ) > 0 ) && ( result != null ) ) { TreeNode temp = q . removeFirst ( ) ; q . removeFirst ( ) ; if ( ( temp . left != null ) && ( temp . left . left != null ) ) { q . add ( temp . left ) ; if ( ( ! temp . left . left . right . equals ( root ) ) && ( ! temp . left . right . equals ( root ) ) ) { result = temp . left ; } } if ( ( temp . right != null ) && ( temp . right . right != null ) ) { q . add ( temp . right ) ; } } return result ; } if ( Main . isWindows ) { TreeNode root = newnode ( 1 ) ; root . left = newnode ( 2 ) ; root . right = newnode ( 3 ) ; root . left . Left = newnode ( 4 ) ; root . right . left = newnode ( 5 ) ; root . right . right = newnode ( 6 ) ; root . right . left . right = newnode ( 7 ) ; root . right . right . right = newnode ( 8 ) ; root . right . left . right . left = newnode ( 9 ) ; root . right . right . right . right = newnode ( 10 ) ; TreeNode result = getDeepestLeftLeafNode ( root ) ; if ( result != null ) { System . out . println ( " Deepest ▁ Left ▁ Leaf ▁ Node ▁ : : " + result . data ) ; } else { System . out . println ( " No ▁ result , ▁ Left ▁ leaf ▁ not ▁ found " ) ; } }
_MIN - 2147483648 ; _MAX - 2147483648 ; class newnode { public newnode ( int data ) { this . data = data ; this . left = null ; this . right = null ; } } def getDeepestRightLeafNode ( TreeNode root ) { if ( ( root == null ) || ( root . data < 0 ) ) return null ; LinkedList q = new LinkedList ( ) ; q . add ( root ) ; newnode result = null ; while ( ( q . size ( ) > 0 ) && ( result != null ) ) { TreeNode temp = q . removeFirst ( ) ; q . removeFirst ( ) ; if ( ( temp . left != null ) && ( temp . left . data < 0 ) ) q . add ( temp . left ) ; if ( ( temp . right != null ) && ( temp . right . data < 0 ) ) { q . add ( temp . right ) ; if ( ( ! temp . right . left . data < 0 ) && ( ! temp . right . right . data > 0 ) ) result = temp . right ; } } return result ; } if ( Main . isWindows ) { TreeNode root = newnode ( 1 ) ; root . left = newnode ( 2 ) ; root . right = newnode ( 3 ) ; root . left . right = newnode ( 4 ) ; root . right . left = newnode ( 5 ) ; root . right . right = newnode ( 6 ) ; root . right . left . right = newnode ( 7 ) ; root . right . right . right = newnode ( 8 ) ; root . right . left . right . left = newnode ( 9 ) ; root . right . right . right . right = newnode ( 10 ) ; result = getDeepestRightLeafNode ( root ) ; if ( result != null ) System . out . println ( " Deepest ▁ Right ▁ Leaf ▁ Node ▁ : : " + result . data ) ; else System . out . println ( " No ▁ result , ▁ right ▁ leaf ▁ not ▁ found " ) ; } }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int a = 2 ; int b = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int old_a = a ; a = b ; b = old_a + b ; } System . out . println ( b ) ; }
public static final void printRatio ( int a , int b , int c , int d ) { if ( ( b * c > a * d ) && ( b * c > a * d ) ) { swap ( c , d ) ; swap ( a , b ) ; } int lcm = ( a * c ) / gcd ( a , c ) ; int x = lcm / a ; b = ( int ) ( b * x ) ; int y = lcm / c ; d = ( int ) ( d * y ) ; int k = gcd ( b , d ) ; b = ( int ) ( b / k ) ; d = ( int ) ( d / k ) ; System . out . println ( b + " : " + d ) ; }
public static int maxsum_SIS ( int [ ] arr , int n ) { int maxSum = 0 ; int currentSum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] < arr [ i ] ) && ( arr [ i ] > arr [ i ] ) ) { currentSum = currentSum + arr [ i ] ; } else { maxSum = Math . max ( maxSum , currentSum ) ; currentSum = arr [ i ] ; } } return Math . max ( maxSum , currentSum ) ; }
public static int GCD ( int a , int b ) { if ( ( b == 0 ) || ( b == 1 ) ) return a ; return GCD ( b , a % b ) ; }
static final public int gcd ( int a , int b ) { while ( ( b != 0 ) && ( a != b ) ) { int t = b ; b = a % b ; a = t ; } return a ; }
public static int t ( ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display " ) ) ; for ( ; ; ) { int x = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ x ▁ coordinate ▁ of ▁ the ▁ first ▁ character " ) ) ; int y = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ y ▁ coordinate ▁ of ▁ the ▁ first ▁ character " ) ) ; int w = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ w ▁ coordinate ▁ of ▁ the ▁ first ▁ character " ) ) ; int h = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ h ▁ coordinate ▁ of ▁ the ▁ first ▁ character " ) ) ; int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ n ▁ coordinate ▁ of ▁ the ▁ first ▁ character " ) ) ; int ans = 0 ; for ( ; ; ) { int cx = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ cx ▁ coordinate ▁ of ▁ the ▁ first ▁ character " ) ) ; int cy = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ cy ▁ coordinate ▁ of ▁ the ▁ first ▁ character " ) ) ; if ( x <= cx && x <= x + w && y <= cy && y <= y + h ) { ans ++ ; } } System . out . println ( ans ) ; } }
public static boolean divisibleby37 ( String n ) { int l = n . length ( ) ; if ( ( n == null ) || ( l == 0 ) ) return true ; if ( ( l % 3 == 1 ) && ( n . charAt ( l - 1 ) == '0' ) ) { n = "00" + n ; l += 2 ; } else if ( ( l % 3 == 2 ) && ( n . charAt ( l - 1 ) == '0' ) ) { n = "0" + n ; l ++ ; } int gSum = 0 ; while ( ( l != 0 ) && ( n . charAt ( l - 3 ) == '0' ) ) { int group = Integer . parseInt ( n . substring ( l - 3 , l ) ) ; l = l - 3 ; gSum = gSum + group ; } if ( ( gSum >= 1000 ) && ( n . charAt ( 0 ) == '0' ) ) return ( divisibleby37 ( String . valueOf ( gSum ) ) ) ; else return ( gSum % 37 == 0 ) ; System . out . println ( divisibleby37 ( "8955795758" ) ) ; }
static int [ ] solve ( Scanner scanner ) { Scanner input = new Scanner ( scanner ) ; int n = Integer . parseInt ( input . nextLine ( ) ) ; int y = Integer . parseInt ( input . nextLine ( ) ) ; int ans [ ] = new int [ y ] ; return ans ; }
public static int lcs ( String X , String Y , int m , int n ) { int [ ] [ ] L = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { L [ i ] [ i ] = 0 ; } for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 || j == 0 ) { L [ i ] [ j ] = 0 ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; } else { L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } } return L [ m ] [ n ] ; }
public static int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = base / 2 ; return ( int ) ( base * ( base + 1 ) / 2 ) ; }
public static double rmsValue ( int [ ] arr , int n ) { double square = 0 ; double mean = 0.0 ; double root ; for ( int i = 0 ; i <= n ; i ++ ) { square += ( arr [ i ] * arr [ i ] ) ; } mean = ( square / ( ( double ) ( n ) ) ) ; root = Math . sqrt ( mean ) ; return root ; if ( System . getSecurityManager ( ) == null ) { arr = new int [ ] { 10 , 4 , 6 , 8 } ; n = arr . length ; System . out . println ( " { : . 4 } " . format ( rmsValue ( arr , n ) ) ) ; } return root ; }
public static int m = map . get ( Integer . class ) , n = map . get ( Integer . class ) ; int [ ] p = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) p [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] ce = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) ce [ i ] = Arrays . copyOf ( input . nextLine ( ) , m + 1 ) ; dp = new int [ n + 1 ] ; dp [ 0 ] = Integer . MAX_VALUE ; dp [ 1 ] = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = Integer . MAX_VALUE ; } for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( j < ce [ i ] ) { dp [ i + 1 ] = Math . min ( dp [ i ] , ce [ i ] ) ; continue ; } dp [ i + 1 ] = Math . min ( dp [ i ] , dp [ i ] - ce [ i ] ) + ce [ i ] ; } } Arrays . sort ( dp ) ; Arrays . sort ( dp ) ; int sump [ ] = new int [ m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) sump [ i + 1 ] += sump [ i ] + p [ i ] ; int ans = 0 ; for ( int i = 1 ; i < m ; i ++ ) { ans = Math . max ( ans , sump [ i ] - dp [ n ] ) ; } System . out . println ( ans ) ; return ans ; }
public static class Heap { public static final ThreadLocal < ArrayList < Integer > > _nodes = new ThreadLocal < ArrayList < Integer > > ( ) { protected ArrayList < Integer > initialValue ( ) { return new ArrayList < Integer > ( ) ; } @ Override protected ArrayList < Integer > initialValue ( ) { ArrayList < Integer > heap = new ArrayList < Integer > ( ) ; heap . add ( _nodes ) ; return heap ; } @ Override public Iterator < Integer > iterator ( ) { cur = 0 ; return new Iterator < Integer > ( ) { private int cur ; @ Override public boolean hasNext ( ) { if ( cur >= _nodes . size ( ) ) throw new NoSuchElementException ( ) ; cur ++ ; Integer node = _nodes . get ( cur - 1 ) ; if ( cur / 2 - 1 >= 0 ) { Integer parent = _nodes . get ( cur / 2 - 1 ) ; if ( parent != null ) parent = parent ; if ( cur * 2 - 1 < _nodes . size ( ) ) { Integer left = _nodes . get ( cur * 2 - 1 ) ; if ( left != null ) left = left ; if ( cur * 2 < _nodes . size ( ) ) { Integer right = _nodes . get ( cur * 2 ) ; if ( right != null ) right = right ; return ( node == null ) && ( parent == null ) && ( left == null ) && ( right == null ) ; } } return false ; } @ Override public Integer next ( ) { int len = Integer . parseInt ( input . nextLine ( ) ) ; ArrayList < Integer > nodes = new ArrayList < Integer > ( len ) ; for ( int i = 0 ; ( i < len ) && ( node != null ) ; i ++ ) nodes . add ( Integer . parseInt ( input . nextLine ( ) ) ) ; Heap heap = Heap . create ( nodes ) ; for ( int i = 0 ; ( i < heap . size ( ) ) && ( node != null ) ; i ++ ) { Integer n = heap . get ( i ) ; Integer p = heap . get ( i + 1 ) ; Integer nl = heap . get ( i + 2 ) ; Integer nr = heap . get ( i + 3 ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " node ▁ { } : ▁ key ▁ = ▁ { } , ▁ " ) ; sb . append ( i + 1 ) ; sb . append ( n ) ; sb . append ( " parent ▁ key ▁ = ▁ " ) ; sb .
public static int [ ] [ ] maxSum ( int [ ] [ ] arr ) { int n = 6 ; int m = 6 ; ; int [ ] [ ] dp = new int [ n + 1 ] [ 3 ] ; ; for ( int i = 0 ; i < n ; i ++ ) { int m1 = 0 ; int m2 = 0 ; int m3 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( ( j / ( m / 3 ) ) == 0 ) && ( arr [ i ] [ j ] == 0 ) ) m1 = Math . max ( m1 , arr [ i ] [ j ] ) ; else if ( ( ( j / ( m / 3 ) ) == 1 ) && ( arr [ i ] [ j ] == 1 ) ) m2 = Math . max ( m2 , arr [ i ] [ j ] ) ; else if ( ( ( j / ( m / 3 ) ) == 2 ) && ( arr [ i ] [ j ] == 2 ) ) m3 = Math . max ( m3 , arr [ i ] [ j ] ) ; } dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; ; dp [ i + 1 ] [ 2 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; ; } System . out . println ( ( int ) Math . max ( Math . max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) ; ; return dp ; }
public static void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . max ( x1 , x3 ) ; int y5 = Math . max ( y1 , y3 ) ; int x6 = Math . min ( x2 , x4 ) ; int y6 = Math . min ( y2 , y4 ) ; if ( ( x5 > x6 || y5 > y6 ) && ( x5 < x6 ) ) { System . out . println ( " No ▁ intersection " ) ; return ; } System . out . print ( " ( " + x5 + " , ▁ " + y5 + " ) ▁ " ) ; System . out . print ( " ( " + x6 + " , ▁ " + y6 + " ) ▁ " ) ; int x7 = x5 ; int y7 = y6 ; System . out . print ( " ( " + x7 + " , ▁ " + y7 + " ) ▁ " ) ; int x8 = x6 ; int y8 = y5 ; System . out . print ( " ( " + x8 + " , ▁ " + y8 + " ) ▁ " ) ; }
public static int nHamsters ( ) { int nHamsters = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ hamsters ▁ to ▁ print " ) ) ; String hamsters = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ hamsters ▁ to ▁ print " ) ; int hamstersStanding = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ hamsters ▁ to ▁ print " ) ) ; int hamstersSitting = nHamsters - hamstersStanding ; if ( hamstersStanding == hamstersSitting ) { System . out . println ( 0 ) ; System . out . println ( hamsters ) ; } else if ( hamstersStanding > hamstersSitting ) { int numChange = ( hamstersStanding - hamstersSitting ) / 2 ; System . out . println ( numChange ) ; String result = " " ; for ( int i = 0 ; i < hamsters . length ( ) ; i ++ ) { if ( hamsters . charAt ( i ) == ' X ' && numChange > 0 ) { result += " x " ; numChange -- ; } else { result += hamsters . charAt ( i ) ; } } System . out . println ( result ) ; } else { int numChange = ( hamstersSitting - hamstersStanding ) / 2 ; System . out . println ( numChange ) ; String result = " " ; for ( int i = 0 ; i < hamsters . length ( ) ; i ++ ) { if ( hamsters . charAt ( i ) == ' x ' && numChange > 0 ) { result += " X " ; numChange -- ; } else { result += hamsters . charAt ( i ) ; } } System . out . println ( result ) ; } return nHamsters ; }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int d = Integer . parseInt ( input . nextLine ( ) ) ; int e = Integer . parseInt ( input . nextLine ( ) ) ; int dm = d ; int em = e * 5 ; int max = Math . max ( dm , em ) ; int min = Math . min ( dm , em ) ; int rem = n % max ; int div = ( int ) ( ( n - rem ) / max ) ; int i = div ; int ans = rem ; while ( i > - 1 ) { int dum = 0 ; dum += n ; int rl = dum - ( i * max ) ; int fin = rl % min ; if ( fin < ans ) { if ( fin == 0 ) { ans = 0 ; i = - 1 ; } else ans = fin ; } i -- ; } System . out . println ( ans ) ; }
static int knapSack ( int W , double [ ] wt , double [ ] val , int n ) { double maxratio = - Double . MAX_VALUE - 1 ; ; int maxindex = 0 ; ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( val [ i ] / wt [ i ] ) > maxratio ) ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } ; } return ( W * maxratio ) ; }
public static void AlternateRearrange ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; List < Integer > v1 = Lists . newArrayList ( ) ; List < Integer > v2 = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 == 0 ) && ( arr [ i ] != 0 ) ) { v1 . add ( arr [ i ] ) ; } else { v2 . add ( arr [ i ] ) ; } } int index = 0 ; int i = 0 ; int j = 0 ; boolean flag = false ; if ( ( arr [ 0 ] % 2 == 0 ) && ( arr [ 1 ] != 0 ) ) { flag = true ; } while ( ( index < n ) || ( flag == true ) ) { if ( ( flag == true ) && ( arr [ index ] == 0 ) ) { arr [ index ] = v1 . get ( i ) ; index ++ ; i ++ ; flag = ~ flag ; } else { arr [ index ] = v2 . get ( j ) ; index ++ ; j ++ ; flag = ~ flag ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
public static int A ( ) { int A = map . get ( Integer . parseInt ( input ) ) ; int B = map . get ( Integer . parseInt ( input ) ) ; int C = map . get ( Integer . parseInt ( input ) ) ; if ( A <= C && B >= C ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return A ; }
public static String decToBinary ( int n ) { int binaryNum [ ] = new int [ 32 ] ; for ( int i = 0 ; i < 32 ; i ++ ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } String binary = " " ; for ( int j = i - 1 ; j >= 0 ; j -- ) { binary += Integer . toString ( binaryNum [ j ] ) ; } return binary ; }
public static void makearrayequal ( int [ ] arr , int n ) { int x = 0 ; ; for ( int i = 0 ; i < n ; i ++ ) x += arr [ i ] & 1 ; ; System . out . println ( Math . min ( x , n - x ) ) ; ; }
public static final int [ ] findKthLargest ( final int [ ] nums , final int k ) { Collections . shuffle ( nums ) ; return quickSelection ( nums , 0 , nums . length - 1 , nums . length - k ) ; } public static void quickSelection ( final int [ ] nums , int start , int end , int k ) { if ( start > end ) return ; int pivot = nums [ end ] ; int left = start ; for ( int i = start ; i < end ; i ++ ) { if ( nums [ i ] <= pivot ) { nums [ left ] = nums [ i ] ; left ++ ; } } nums [ left ] = nums [ end ] ; if ( left == k ) { return ; } else if ( left < k ) { quickSelection ( nums , left + 1 , end , k ) ; } else { quickSelection ( nums , start , left - 1 , k ) ; } } }
public static String isDivisible ( int n ) { int temp = n ; while ( ( n > 0 ) && ( temp % 10 == 0 ) ) { int k = n % 10 ; if ( ( temp % k == 0 ) && ( temp % k == 0 ) ) { return " YES " ; } n /= 10 ; ; } return " NO " ; }
public static String isDivisible ( int n ) { int temp = n ; int sum = 0 ; ; while ( ( n > 0 ) && ( temp < 0 ) ) { int k = n % 10 ; sum += k ; n /= 10 ; } if ( ( temp % sum == 0 ) && ( temp > 0 ) ) { return " YES " ; } return " NO " ; }
public static int compare ( int a , int b ) { int a = Integer . parseInt ( input ( ) ) ; int b = Integer . parseInt ( input ( ) ) ; return a > b ? a : b ; }
public static int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( ( l - size + 1 ) * ( b - size + 1 ) ) ; int area = ( totalSquares * size * size ) ; totalArea += area ; size ++ ; } return totalArea ; }
public static void arrange ( int N ) { if ( ( N == 1 ) || ( N == 2 ) ) { System . out . println ( "1" ) ; return ; } if ( ( N == 2 || N == 3 ) ) { System . out . println ( " - 1" ) ; return ; } int even = - 1 ; int odd = - 1 ; if ( ( N % 2 == 0 ) ) { even = N ; odd = N - 1 ; } else { odd = N ; even = N - 1 ; } while ( ( odd >= 1 ) && ( odd <= 2 ) ) { System . out . print ( odd + " ▁ " ) ; odd = odd - 2 ; } while ( ( even >= 2 ) && ( even <= 3 ) ) { System . out . print ( even + " ▁ " ) ; even = even - 2 ; } }
public static int findMinEqualSums ( int [ ] a , int N ) { int sum = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { sum = sum + a [ i ] ; } int sum1 = 0 ; int sum2 = 0 ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i <= N - 1 ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( ( Math . abs ( sum1 - sum2 ) < min ) && ( Math . abs ( sum1 - sum2 ) < min ) ) { min = Math . abs ( sum1 - sum2 ) ; } if ( ( min == 0 ) || ( N == 0 ) ) { break ; } } return min ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ print " ) ) ; i ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ print " ) ) ; if ( n == 1 || n == 2 ) { System . out . println ( n ) ; } else { String u = String . valueOf ( n ) ; int v = n / 3 ; int w = n % 3 ; u += "21" * v ; if ( w == 1 ) { u = "1" + u ; } else if ( w == 2 ) { u += "2" ; } System . out . println ( u ) ; } } }
public static int findOptimalSolution ( int [ ] a , int N ) { Arrays . sort ( a ) ; int points = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { points += a [ i ] * i ; } return points ; }
n , b ) public static int nextInt ( int [ ] input ) { int time = 0 ; LinkedList < Integer > queue = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int t = input [ i ] , d = input [ i + 1 ] ; while ( queue . size ( ) != 0 && t >= queue . getFirst ( ) ) { queue . removeLast ( ) ; } if ( queue . size ( ) <= b ) { time = Math . max ( t , time ) + d ; queue . add ( time ) ; System . out . print ( time + " ▁ " ) ; } else { System . out . print ( - 1 + " ▁ " ) ; } } return time ; }
public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; scanner . nextLine ( ) ; Scanner inp = new Scanner ( System . in ) ; inp . nextLine ( ) ; for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { inp . nextLine ( ) ; inp . nextLine ( ) ; } Arrays . sort ( inp . array ( ) ) ; int sum1 = 0 ; for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { sum1 += Math . max ( inp . array ( ) [ i - 1 ] , inp . array ( ) [ i ] ) ; } if ( ( sum1 + Integer . MAX_VALUE ) <= Integer . MAX_VALUE ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } }
public static int getPairs ( int [ ] a ) { int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < a . length ; j ++ ) { if ( ( a [ i ] < a [ j ] ) && ( a [ i ] > a [ j ] ) ) { count ++ ; } } } return count ; }
n , k ) public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . nextLine ( ) ; if ( k == 0 ) System . out . println ( s ) ; else if ( Integer . parseInt ( s ) <= 9 ) System . out . println ( 0 ) ; else { int c = 0 ; int condition = 0 ; String ans = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i == 0 && condition == 0 ) { ans += "1" ; if ( s . charAt ( i ) == '1' ) c += 0 ; else c += 1 ; } else if ( condition == 0 ) { ans += "0" ; if ( s . charAt ( i ) == '0' ) c += 0 ; else c += 1 ; } if ( c == k ) { condition = 1 ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { ans += s . charAt ( j ) ; if ( j == s . length ( ) - 1 ) { c = - 1 ; break ; } } } } System . out . println ( ans ) ; } }
public static int [ ] [ ] [ ] getA ( ) { int [ ] [ ] [ ] a = new int [ 4 ] [ 4 ] [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { String [ ] data = JOptionPane . showInputDialog ( " Enter ▁ a ▁ number : ▁ " ) . toCharArray ( ) ; a [ i ] = new int [ data . length ] [ data . length ] ; } final int [ ] [ ] [ ] func = a ; int band = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( func [ i ] [ 3 ] == 1 ) { if ( func [ ( i + 2 ) % 4 ] [ 1 ] ) band = 1 ; if ( func [ ( i + 1 ) % 4 ] [ 0 ] || func [ ( i + 3 ) % 4 ] [ 2 ] ) band = 1 ; if ( func [ i ] [ 0 ] || func [ i ] [ 1 ] || func [ i ] [ 2 ] ) band = 1 ; } } if ( band > 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; return func ; }
public static int N = 10000 ; ; int MOD = 1000000007 ; int [ ] F = new int [ N ] ; ; public void precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( int i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; ; } int n = 8 ; precompute ( ) ; ; System . out . println ( F [ n ] ) ; ; }
public static int main ( String [ ] args ) { while ( true ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ number ▁ of ▁ characters ▁ to ▁ enter " ) ) ; if ( n == 0 ) break ; int num = 2 ; int cnt = 0 ; while ( true ) { int ini = num * ( num + 1 ) / 2 ; if ( n < ini ) break ; while ( ini <= n ) { if ( ini == n ) { cnt ++ ; break ; } ini += num ; } num ++ ; } System . out . println ( cnt ) ; } }
public static int CeilIndex ( int [ ] A , int l , int r , int key ) { while ( ( r - l > 1 ) && ( l < r ) ) { int m = l + ( r - l ) / 2 ; if ( ( A [ m ] >= key ) || ( A [ m ] > key ) ) { r = m ; } else { l = m ; } } final int LongestIncreasingSubsequenceLength = A . length + 1 ; int len ; tailTable [ 0 ] = 0 ; len = 1 ; for ( int i = 1 ; i < size ; i ++ ) { if ( ( A [ i ] < tailTable [ 0 ] ) && ( A [ i ] > tailTable [ len - 1 ] ) ) { tailTable [ len ] = A [ i ] ; len ++ ; } else if ( ( A [ i ] > tailTable [ len - 1 ] ) && ( A [ i ] < tailTable [ len - 1 ] ) ) { tailTable [ len ] = A [ i ] ; len ++ ; } else { tailTable [ CeilIndex ( tailTable , - 1 , len - 1 , A [ i ] ) ] = A [ i ] ; } } return len ; }
public static int N ( String input ) { int N = Integer . parseInt ( input ) ; int [ ] X = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int Xmn = Math . min ( X . length , N ) , Xmx = Math . max ( X . length , N ) ; int [ ] temp = new int [ N ] ; int res = Xmx - Xmn ; for ( int x = Xmn ; x <= Xmx ; x ++ ) { for ( int n = 0 ; n < N ; n ++ ) { temp [ n ] = Math . abs ( X [ n ] - x ) ; } if ( Math . max ( temp [ N ] ) < res ) { res = Math . max ( temp [ N ] ) ; } temp = new int [ N ] ; } System . out . println ( res ) ; }
static final public String compute ( ) { final int LIMIT = 10 * 6 ; int ans = sum ( 1 , LIMIT ) ; return String . valueOf ( ans ) ; }
public static int colourVisible ( int [ ] height , int [ ] colour , int K ) { int [ ] arr = new int [ K + 1 ] ; int visible = 0 ; int max = height [ K - 1 ] ; arr [ colour [ K - 1 ] ] = 1 ; int i = K - 2 ; while ( ( i >= 0 ) && ( height [ i ] > max ) ) { if ( ( height [ i ] > max ) && ( colour [ i ] > max ) ) { max = height [ i ] ; arr [ colour [ i ] ] = 1 ; } i -- ; } for ( i = 1 ; i < K ; i += 1 ) { if ( ( arr [ i ] == 1 ) && ( colour [ i ] == 1 ) ) visible ++ ; } return visible ; }
static final public boolean checkPowerof8 ( int n ) { double i = Math . log ( n ) ; return ( i - Math . toDegrees ( i ) < 0.000001 ) ; ; }
public static int main ( String [ ] args ) { for ( ; ; ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ ( 1-4 ) : ▁ " ) ) , 1 ; int b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ b ▁ number ▁ ( 1-4 ) : ▁ " ) ) ; if ( a == b ) { System . out . println ( ( a + b ) / 4 ) ; } else { System . out . println ( Math . min ( Math . min ( a , b ) , ( a + b ) / 4 ) ) ; } } }
public static int [ ] getStudentsArray ( ) { while ( true ) { int n = map . nextInt ( ) ; int m = map . nextInt ( ) ; if ( n == m == 0 ) break ; int [ ] students = new int [ n ] ; for ( ; n > 0 ; n -- ) { int [ ] scores = Arrays . stream ( map . nextInt ( ) ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) students [ i ] += scores [ i ] ; } System . out . println ( Math . max ( students . length , 0 ) ) ; } }
public static void main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display : ▁ " ) ) ; int now = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int l = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display : ▁ " ) ) ; int r = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display : ▁ " ) ) ; if ( now <= l ) { System . out . print ( l + " ▁ " ) ; now = l + 1 ; } else if ( now <= r ) { System . out . print ( now + " ▁ " ) ; now ++ ; } else { System . out . print ( 0 ) ; } } System . out . println ( ) ; } }
public static int countWays ( int n , int m ) { int [ ] count = new int [ n + 2 ] ; for ( int i = 0 ; i < n + 2 ; i ++ ) { count [ i ] = 0 ; } count [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i > m ) && ( count [ i - 1 ] == 0 ) ) { count [ i ] = count [ i - 1 ] + count [ i - m ] ; } else if ( ( i < m ) && ( count [ i ] == 0 ) ) { count [ i ] = 1 ; } else { count [ i ] = 2 ; } } return count [ n ] ; }
public static void bombRequired ( int n ) { System . out . println ( n + n / 2 ) ; for ( int i = 2 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; for ( int i = 1 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; for ( int i = 2 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; }
n = Integer . parseInt ( input ) ; System . out . println ( ( n + 1 ) & - ( n + 1 ) ) ; }
s = String . valueOf ( input . nextLine ( ) ) ; String myStr = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '0' || s . charAt ( i ) == '1' ) { myStr += s . charAt ( i ) ; } else if ( s . charAt ( i ) == ' B ' && myStr . length ( ) != 0 ) { myStr = myStr . substring ( 0 , myStr . length ( ) - 1 ) ; } } System . out . println ( myStr ) ; }
public static final int countMatches ( int [ ] array , int [ ] x ) { while ( true ) { int n = map ( array , 0 , array . length ) ; int x = map ( array , 0 , x . length ) ; if ( ( n == 0 ) & ( x == 0 ) ) break ; int ret = 0 ; for ( int [ ] v : Arrays . copyOfRange ( array , 1 , n + 1 ) ) { if ( Arrays . equals ( v , x ) ) ret ++ ; } System . out . println ( ret ) ; } }
public static final int recur ( int ind , int cnt , int last , int [ ] a , int n , int k , int [ ] [ ] dp ) { if ( ( cnt == k ) && ( ind == n ) ) return 0 ; if ( ( ind == n ) && ( last == 0 ) ) return - 10 * 9 ; if ( ( dp [ ind ] [ cnt ] != - 1 ) && ( dp [ ind ] [ cnt ] != - 1 ) ) return dp [ ind ] [ cnt ] ; int ans = 0 ; for ( int i = ind ; i < n ; i ++ ) { if ( ( cnt % 2 == 0 ) ) ans = Math . max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) ; else ans = Math . max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) ; } dp [ ind ] [ cnt ] = ans ; return ans ; }
public static int main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ be ▁ sorted " ) ) ; double [ ] arr = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ elements ▁ to ▁ be ▁ sorted " ) . toArray ( ) ) . mapToDouble ( x -> x - Integer . MIN_VALUE ) . toArray ( ) ; Arrays . sort ( arr ) ; int o = 2 * n - arr . length ; double arrSum = sum ( arr ) ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < n + 1 ; i ++ ) { if ( i + o >= n ) { res = Math . min ( res , Math . abs ( i - arrSum ) ) ; } } System . out . printf ( " % .3f \n " , res ) ; }
public static String equivalentBase4 ( String bin ) { if ( ( bin . equals ( "00" ) ) || ( bin . equals ( "01" ) ) ) return 0 ; if ( ( bin . equals ( "10" ) ) || ( bin . equals ( "11" ) ) ) return 1 ; if ( ( bin . equals ( "10000" ) ) || ( bin . equals ( "100000" ) ) ) return 2 ; if ( ( bin . equals ( "100001" ) ) || ( bin . equals ( "100000" ) ) ) return 3 ; final int isDivisibleBy5 = bin . length ( ) ; final int l = bin . length ( ) ; if ( ( ( l % 2 ) == 1 ) && ( isDivisibleBy5 == 1 ) ) bin = "0" + bin ; int oddSum = 0 ; int evenSum = 0 ; int isOddDigit = 1 ; for ( int i = 0 ; i < bin . length ( ) ; i += 2 ) { if ( ( isOddDigit ) && ( isDivisibleBy5 == 1 ) ) oddSum += equivalentBase4 ( bin . substring ( i , i + 2 ) ) ; else evenSum += equivalentBase4 ( bin . substring ( i , i + 2 ) ) ; isOddDigit = isOddDigit ^ 1 ; } if ( ( Math . abs ( oddSum - evenSum ) % 5 == 0 ) && ( isDivisibleBy5 == 1 ) ) return " Yes " ; else return " No " ; }
public static final void main ( String [ ] args ) { final Map < Integer , Integer > score = new HashMap < Integer , Integer > ( ) ; score . put ( Integer . valueOf ( 0 ) , 0 ) ; final Queue < Integer > queue = new LinkedList < Integer > ( ) ; queue . add ( Integer . valueOf ( 0 ) ) ; final int [ ] [ ] move = { { 1 , 4 } , { 0 , 2 , 5 } , { 1 , 3 , 6 } , { 2 , 7 } , { 0 , 5 } , { 1 , 4 , 6 } , { 2 , 5 , 7 } , { 3 , 6 } } ; while ( queue . size ( ) > 0 ) { Integer puz = queue . poll ( ) ; int pos = puz . intValue ( ) ; for ( int npos : move [ pos ] ) { Integer npuz = Arrays . asList ( puz ) . stream ( ) . mapToInt ( Integer :: intValue ) . reduce ( 0 , 1 ) ; npuz = Integer . valueOf ( npuz ) ; if ( npuz != puz ) { queue . add ( npuz ) ; score . put ( npuz , score . get ( puz ) + 1 ) ; } } } while ( true ) { try { int puzzle = Integer . valueOf ( JOptionPane . showInputDialog ( " Enter ▁ puzzle ▁ number : ▁ " ) ) . intValue ( ) ; System . out . println ( score . get ( puzzle ) ) ; } catch ( NumberFormatException e ) { break ; } } }
from ▁ list ▁ of ▁ integers ▁ to ▁ min . STRNEWLINE ▁ */ public static int min ( int ... nums ) { List < Integer > o = Arrays . asList ( nums ) ; return Math . min ( Integer . MAX_VALUE , o . size ( ) ) ; }
public static final void main ( String [ ] args ) { final int MAX = 1005 ; boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p <= Integer . MAX_VALUE ; p ++ ) { if ( ( prime [ p ] == true ) && ( prime [ p * 2 ] == true ) ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= MAX ; p += 1 ) { if ( ( prime [ p ] ) ) prime [ p ] = false ; } System . out . println ( " Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is " + minimumSquareFreeDivisors ( N ) ) ; N = 6 ; System . out . println ( " Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is " + minimumSquareFreeDivisors ( N ) ) ; }
public static final void main ( String [ ] args ) { int x = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) ; int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) ; int b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ b ▁ number ▁ to ▁ test " ) ) ; int ans = ( x - a ) % b ; Thread . sleep ( a * 0.001 ) ; System . out . println ( ans ) ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ delete " ) ) ; int k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ delete " ) ) ; List < Integer > elems = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ delete " ) ) ; Predicate < Integer > allSame = arr -> Arrays . stream ( arr ) . anyMatch ( x -> x == arr . get ( 0 ) ) ; if ( allSame . test ( elems . stream ( ) . anyMatch ( x -> x == arr . get ( 0 ) ) ) ) { System . out . println ( 0 ) ; return ; } if ( k == 1 ) { System . out . println ( - 1 ) ; return ; } if ( ! allSame . test ( elems . subList ( k - 1 , k ) ) ) { System . out . println ( - 1 ) ; return ; } Integer target = elems . get ( elems . size ( ) - 1 ) ; List < Integer > toDelete = elems . subList ( 0 , k - 1 ) ; while ( toDelete . size ( ) > 0 && toDelete . get ( toDelete . size ( ) - 1 ) . equals ( target ) ) { toDelete . remove ( toDelete . size ( ) - 1 ) ; } System . out . println ( toDelete . size ( ) ) ; }
public static int fun ( int n ) { return n & ( n - 1 ) ; }
public static int LongestFibSubseq ( int [ ] A , int n ) { Set < Integer > S = new HashSet < Integer > ( A ) ; int maxLen = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = A [ j ] ; int y = A [ i ] + A [ j ] ; int length = 2 ; while ( y < S . size ( ) ) { int z = x + y ; x = y ; y = z ; length ++ ; maxLen = Math . max ( maxLen , length ) ; } } } return maxLen == 0 ? 0 : maxLen ; }
public static int countPairs ( int [ ] a , int [ ] b , int n , int m ) { int cnt = 0 ; Map s = new HashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int sum = a [ i ] + b [ j ] ; if ( ( sum != 0 ) && ( sum != 1 ) ) { cnt ++ ; s . put ( sum , 1 ) ; } } } return cnt ; }
static final boolean check ( int [ ] a , int y ) { int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { int x = Math . sqrt ( a [ i ] ) ; if ( ( Math . floor ( x ) == Math . ceil ( x ) ) && ( sum % y == 0 ) ) { sum = sum + a [ i ] ; } } if ( ( sum % y == 0 ) && ( sum % y == 0 ) ) { return true ; } else { return false ; } a [ 0 ] = 2 ; a [ 1 ] = 3 ; a [ 2 ] = 4 ; a [ 3 ] = 9 ; a [ 4 ] = 10 ; int x = 13 ; if ( check ( a , x ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return true ; }
public static final void heapSort ( int n , int q ) { int n = Integer . parseInt ( input . nextLine ( ) ) , q = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] [ ] Q = new int [ n ] [ q ] ; for ( int i = 0 ; i < n ; i ++ ) { Q [ i ] = new int [ q ] ; } List < List < Integer > > queries = Lists . newArrayList ( ) ; for ( int i = 0 ; i < q ; i ++ ) { queries . add ( Lists . newArrayList ( Integer . parseInt ( input . nextLine ( ) ) ) ) ; } for ( List < Integer > query : queries ) { if ( query . get ( 0 ) == 0 ) { heapSort ( Q [ query . get ( 1 ) ] , - query . get ( 2 ) ) ; } else if ( query . get ( 0 ) == 1 ) { if ( Q [ query . get ( 1 ) ] != null ) { System . out . println ( - Q [ query . get ( 1 ) ] . get ( 0 ) ) ; } } else if ( query . get ( 0 ) == 2 ) { if ( Q [ query . get ( 1 ) ] != null ) { heapSort ( Q [ query . get ( 1 ) ] ) ; } } } }
public static int calculateMinSum ( int [ ] a , int n ) { Arrays . sort ( a ) ; int minSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) { minSum += Math . abs ( a [ i ] - a [ i - 1 ] ) ; } return minSum ; }
public static int n ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] A = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = Integer . parseInt ( input ) ; } return n ; }
N ; int a [ ] = Arrays . copyOf ( input , N ) ; int odd = 0 ; int m2 = 0 ; int m4 = 0 ; for ( int n : a ) { if ( n % 2 == 1 ) odd ++ ; else if ( n % 4 != 0 ) m2 ++ ; else m4 ++ ; } if ( m4 >= odd || ( m2 == 0 && m4 >= odd - 1 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
public static boolean isPalindrome ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) && ( s . charAt ( i ) != s . charAt ( s . length ( ) - 1 ) ) ) { return false ; } } return true ; } public static boolean ans ( String s ) { String s2 = s ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { s2 = s2 . substring ( s . length ( ) - 1 , s2 . length ( ) ) + s2 ; s2 = s2 . substring ( 0 , s2 . length ( ) - 1 ) ; if ( ( s != s2 ) && isPalindrome ( s2 ) ) { return true ; } } return false ; } public static void solve ( String s ) { if ( ( s . length ( ) <= 3 ) || ( s . length ( ) <= 5 ) ) { return ; } int [ ] cnt = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { cnt [ ( int ) s . charAt ( i ) - ' a ' ] ++ ; } int max = cnt [ 0 ] ; for ( int i = 0 ; i < cnt . length ; i ++ ) { if ( cnt [ i ] > max ) { max = cnt [ i ] ; } } if ( ( max >= s . length ( ) - 1 ) && ( s . charAt ( max ) == ' a ' ) ) { s = " nolon " ; System . out . println ( solve ( s ) ) ; } else { if ( ans ( s ) == true ) { return true ; } else { return 2 ; } } } if ( System . getProperty ( " os . arch " ) . contains ( " sparc " ) ) { s = " nolon " ; System . out . println ( solve ( s ) ) ; } }
public static int countNumbers ( int k , int n ) { int [ ] [ ] dp = new int [ 2 ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ i ] [ 1 ] = k - 1 ; } for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
public static int minCost ( int n , int [ ] arr , int cost ) { int Sum = 0 , totalCost = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) Sum += arr [ i ] ; totalCost += cost * Sum ; arr [ n - 1 ] += Sum ; totalCost += ( 2 * cost * arr [ n - 1 ] ) ; return totalCost ; }
public static void main ( String [ ] args ) { final Scanner input = new Scanner ( System . in ) ; int CCA = 0 , CCC = 0 , CAN = 0 ; CAN = Math . min ( c , a , n ) ; c -= CAN ; a -= CAN ; if ( a > 0 && c > 0 ) { CCA = Math . min ( a , c / 2 ) ; c -= ( CCA * 2 ) ; } if ( c > 2 ) { CCC = c / 3 ; } System . out . println ( CAN + CCA + CCC ) ; }
public static int main ( String [ ] args ) { while ( true ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ n ▁ number ▁ ( 0-9 ) : ▁ " ) ) ; if ( n == 0 ) break ; int m = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ m ▁ number ▁ ( 0-9 ) : ▁ " ) ) ; String s = JOptionPane . showInputDialog ( " Enter ▁ s ▁ number ▁ ( 0-9 ) : ▁ " ) ; int [ ] ar = new int [ m ] ; int ans = 0 ; if ( m >= 3 ) { for ( int i = 2 ; i < m ; i ++ ) { if ( s . substring ( i - 2 , i + 1 ) . equals ( " IOI " ) ) { ar [ i ] = ar [ i - 2 ] + 1 ; if ( ar [ i ] >= n ) { ans ++ ; } } } } System . out . println ( ans ) ; } }
public static int t ( ) { int t = Integer . parseInt ( System . in ) ; for ( ; ; ) { String n = System . in . readLine ( ) ; int length = n . length ( ) ; int minval = 10000 ; for ( int i = 0 ; i < length - 1 ; i ++ ) { int n1 = n . charAt ( i ) ; for ( int j = i + 1 ; j < length ; j ++ ) { int n2 = n . charAt ( j ) ; if ( Integer . parseInt ( n1 + n2 ) % 25 == 0 ) { int val = length - i - 2 ; if ( val < minval ) minval = val ; } } } } System . out . println ( minval ) ; }
public static class newNode { public static < T > Node < T > create ( T data ) { Node < T > root = new Node < T > ( ) ; ; root . left = null ; ; root . right = null ; ; } public Node < T > insert ( Node < T > root , T data ) { if ( ( root == null ) || ( data == null ) ) { return newNode ( data ) ; } else { if ( ( data < root . data ) && ( data > root . data ) ) { root . left = insert ( root . left , data ) ; } if ( ( data > root . data ) && ( data > root . data ) ) { root . right = insert ( root . right , data ) ; } return root ; } } public void inOrder ( Node < T > root ) { if ( ( root == null ) || ( data == null ) ) { root . left = insert ( root . left , data ) ; } else { inOrder ( root . left ) ; System . out . print ( root . data + " ▁ " ) ; inOrder ( root . right ) ; } } } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " linux " ) ) { int arr [ ] = { 1 , 2 , 3 , 2 , 5 , 4 , 4 } ; int n = arr . length ; Node < T > root = null ; for ( int i = 0 ; i < n ; i ++ ) { root = insert ( root , arr [ i ] ) ; } inOrder ( root ) ; } }
public static String removeChars ( String str , int k ) { int [ ] hash = new int [ MAX_CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) hash [ ( char ) str . charAt ( i ) - ' a ' ] ++ ; String res = " " ; for ( int i = 0 ; i < n ; i ++ ) if ( ( hash [ ( char ) str . charAt ( i ) - ' a ' ] >= k ) && ( hash [ ( char ) str . charAt ( i ) ] >= 0 ) ) res += str . charAt ( i ) ; return res ; }
public static int LCSubStr ( String X , String Y , int m , int n ) { int [ ] [ ] LCSuff = new int [ n + 1 ] [ m + 1 ] ; LCSuff [ 0 ] [ 0 ] = 0 ; LCSuff [ 0 ] [ 1 ] = 0 ; LCSuff [ 0 ] [ 2 ] = 0 ; int result = 0 ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( ( i == 0 || j == 0 ) && ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCSuff [ i ] [ j ] ) ; } else { LCSuff [ i ] [ j ] = 0 ; } } } return result ; }
public static int countOccurrences ( int x , int d ) { int count = 0 ; ; while ( ( x ) > 0 ) { if ( ( x % 10 == d ) && ( x % 10 == 0 ) ) { count ++ ; } x = ( int ) ( x / 10 ) ; } return count ; }
public static void printLogestIncSubArr ( int [ ] arr , int n ) { int m = 1 ; int l = 1 ; int maxIndex = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] > arr [ i - 1 ] ) && ( arr [ i ] < arr [ n - 1 ] ) ) { l = l + 1 ; } else { if ( ( m < l ) && ( m < n - 1 ) ) { m = l ; maxIndex = i - m ; } l = 1 ; } } if ( ( m < l ) && ( m < n - 1 ) ) { m = l ; maxIndex = n - m ; } for ( int i = maxIndex ; i < ( m + maxIndex ) ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
public static int a ( ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number " ) ) ; for ( int i = a ; i > 0 ; i -- ) { if ( a % i == 0 ) { System . out . print ( i + " ▁ " ) ; a = i ; } } return a ; }
public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] w = Arrays . copyOf ( input . nextLine ( ) . split ( " ▁ " ) , m ) ; for ( ; ; ) { int l = Integer . parseInt ( input . nextLine ( ) ) , r = Integer . parseInt ( input . nextLine ( ) ) , x = input . nextLine ( ) . split ( " ▁ " ) [ 0 ] ; int d = 0 ; for ( int i = l - 1 ; i < r ; i ++ ) { if ( w [ x - 1 ] > w [ i ] ) d ++ ; } if ( d == x - l ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public static int Max_Sum ( int [ ] a , int n ) { int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = 0 ; int S = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = res ; res += a [ i ] ; S += a [ i ] ; res = Math . max ( res , - S ) ; } int ans = S ; ans = Math . max ( ans , res ) ; int g = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { g -= a [ i ] ; ans = Math . max ( ans , g + b [ i ] ) ; } return ans ; }
public static void main ( String [ ] args ) { for ( ; ; ) { int x = Integer . parseInt ( input . nextLine ( ) ) , y = Integer . parseInt ( input . nextLine ( ) ) ; int i = 0 , j = 0 ; boolean turn = false ; int commands = 0 ; while ( true ) { if ( i == x && j == y ) break ; if ( turn ) { if ( i == x ) { } if ( i < x ) i ++ ; else i -- ; commands ++ ; } else { if ( j == y ) { } else if ( j < y ) j ++ ; else j -- ; commands ++ ; } turn = ! turn ; } System . out . println ( commands == x ? " " : commands - 1 ) ; } }
public static void reverse ( String str1 , int x ) { int n = ( str1 . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( str1 . charAt ( i ) + " ▁ " ) ; } for ( int i = n + x - 1 ; i >= n - 1 ; i -- ) { System . out . print ( str1 . charAt ( i ) + " ▁ " ) ; } for ( int i = n + x ; i < str1 . length ( ) ; i ++ ) { System . out . print ( str1 . charAt ( i ) + " ▁ " ) ; } str1 = " geeksforgeeks " ; x = 3 ; reverse ( str1 , x ) ; }
public static int lps ( String str ) { int n = str . length ( ) ; int [ ] [ ] L = new int [ n ] [ n ] ; for ( int y = 0 ; y < n ; y ++ ) { L [ y ] [ y ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { L [ i ] [ i ] = 1 ; } for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) || ( str . charAt ( i ) == str . charAt ( j ) ) ) { L [ i ] [ j ] = 2 ; } else if ( ( str . charAt ( i ) == str . charAt ( j ) ) && ( str . charAt ( j ) == str . charAt ( i + 1 ) ) ) { L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; } else { L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } } return L [ 0 ] [ n - 1 ] ; } public static final int minimumNumberOfDeletions ( String str ) { int n = str . length ( ) ; int l = lps ( str ) ; return ( n - l ) ; } public static final int minimumNumberOfDeletions ( String str ) { if ( StringUtils . isEmpty ( str ) ) { str = " geeksforgeeks " ; System . out . println ( " Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ " + minimumNumberOfDeletions ( str ) ) ; } return 0 ; } }
public static boolean bitCheck ( int n ) { if ( ( ( n & ( n - 1 ) ) == 0 ) && ( ( n & ( n - 1 ) ) == 0 ) ) return true ; return false ; }
public static int main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ coins ▁ to ▁ buy " ) ) ; int [ ] a = new int [ n ] ; JOptionPane . showMessageDialog ( null , " Enter ▁ the ▁ number ▁ of ▁ coins ▁ to ▁ buy " , " Enter ▁ the ▁ number ▁ of ▁ coins ▁ to ▁ buy " , JOptionPane . INFORMATION_MESSAGE ) ; int [ ] minprice = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) minprice [ i - 1 ] = a [ i ] ; for ( int i = 0 ; i < n ; i ++ ) minprice [ i ] = Math . min ( minprice [ i - 1 ] , a [ i ] ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) c += a [ i ] > minprice [ i ] ? 1 : 0 ; System . out . println ( c ) ; } }
public static final void main ( String [ ] args ) { final int LIMIT = 10 * 8 - 1 ; int ans = 0 ; int [ ] primes = EulerLib . listPrimes ( LIMIT / 2 ) ; double sqrt = EulerLib . sqrt ( LIMIT ) ; for ( int i = 0 ; ( i < primes . length ) && ( primes [ i ] > sqrt ) ; i ++ ) { if ( primes [ i ] > LIMIT / 2 ) break ; int end = binarySearch ( primes , LIMIT / primes [ i ] ) ; ans += ( end + 1 == 0 ? - end - 1 : end - 1 ) - i ; } System . out . println ( String . valueOf ( ans ) ) ; final int binarySearch ( Arrays . asList ( primes ) , x -> x < 0 ) ; int start = 0 ; int end = Integer . MAX_VALUE ; while ( start < end ) { int mid = ( start + end ) / 2 ; if ( x < primes [ mid ] ) end = mid ; else if ( x > primes [ mid ] ) start = mid + 1 ; else if ( x == primes [ mid ] ) return mid ; else throw new AssertionError ( ) ; } }
public static int M = 20 ; int [ ] [ ] dp = new int [ M ] [ M ] ; int d = 0 , K = 0 ; public static final int count ( int pos , int cnt , int tight , int nonz , List < Integer > num ) { if ( pos == num . size ( ) ) { if ( cnt == K ) return 1 ; return 0 ; } if ( dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 ) return dp [ pos ] [ cnt ] [ tight ] [ nonz ] ; int ans = 0 ; int limit = 9 == tight ? num . get ( pos ) : num . get ( pos + 1 ) ; for ( int dig = 0 ; dig < limit + 1 ; dig ++ ) { int currCnt = cnt ; if ( dig == d ) { if ( d != 0 || ! d && nonz ) currCnt ++ ; } int currTight = tight ; if ( dig < num . get ( pos ) ) currTight = 1 ; ans += count ( pos + 1 , currCnt , currTight , ( nonz || dig != 0 ) , num ) ; } dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans ; return dp [ pos ] [ cnt ] [ tight ] [ nonz ] ; } public static int solve ( int x ) { synchronized ( dp ) { int [ ] [ ] num = new int [ M ] [ M ] ; while ( x > 0 ) { num [ x % 10 ] [ 0 ] = x % 10 ; x /= 10 ; } num [ x ] = new int [ M ] ; dp = new int [ 2 ] [ M ] ; for ( int j = 0 ; j < M ; j ++ ) { dp [ j ] [ 0 ] = num [ j ] [ j ] ; dp [ j ] [ 1 ] = num [ j ] [ j ] ; } return count ( 0 , 0 , 0 , 0 , num ) ; } }
ip ; String st = " " ; if ( ip . length ( ) != 1 ) { if ( ip . charAt ( 0 ) == "9" ) { st = "9" ; ip = ip . substring ( 1 ) ; } for ( int i = 0 ; i < ip . length ( ) ; i ++ ) { if ( Integer . parseInt ( ip . charAt ( i ) ) > 4 ) { int n = 9 - Integer . parseInt ( ip . substring ( i ) ) ; st += String . valueOf ( n ) ; } else { st += ip . charAt ( i ) ; } } } else { st = ip ; } System . out . println ( Integer . toString ( st ) ) ; }
public static boolean isPeak ( int [ ] arr , int n , int num , int i , int j ) { if ( ( i >= 0 && arr [ i ] > num ) || ( j >= 0 && arr [ j ] > num ) ) return false ; return true ; } public static boolean isTrough ( int [ ] arr , int n , int num , int i , int j ) { if ( ( i >= 0 && arr [ i ] < num ) || ( j >= 0 && arr [ j ] < num ) ) return false ; return true ; } public static void printPeaksTroughs ( int [ ] arr , int n ) { System . out . print ( " Peaks ▁ : ▁ " ) ; for ( i = 0 ; i < n ; i ++ ) if ( ( isPeak ( arr , n , arr [ i ] , i - 1 , i + 1 ) ) ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; System . out . print ( " Troughs ▁ : ▁ " ) ; for ( i = 0 ; i < n ; i ++ ) if ( ( isTrough ( arr , n , arr [ i ] , i - 1 , i + 1 ) ) ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static int [ ] getPeaksTroughs ( int [ ] arr , int n ) { int [ ] arr = { 5 , 10 , 5 , 7 , 4 , 3 , 5 } ; n = arr . length ; printPeaksTroughs ( arr , n ) ; return arr ; } public static void printPeaksTroughs ( int [ ] arr , int n ) { System . out . print ( " Peaks ▁ : ▁ " ) ; for ( i = 0 ; i < n ; i ++ ) if ( ( isPeak ( arr , n , arr [ i ] , i - 1 , i + 1 ) ) ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void printPeaksTroughs ( int [ ] arr , int n ) { System . out . print ( " Troughs ▁ : ▁ " ) ; for ( i = 0 ; i < n ; i ++ ) if ( ( isTrough (
static int index ( int i ) { return 1 + ( i > > 31 ) - ( - i > > > 31 ) ; }
public static int frequency ( int [ ] a , int x ) { int count = 0 ; for ( int i : a ) { if ( i == x ) { count ++ ; } } return count ; }
public static boolean isNumBalanced ( int N ) { String st = Integer . toString ( N ) ; boolean isBalanced = true ; int [ ] freq = new int [ 10 ] ; int n = st . length ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { freq [ Integer . parseInt ( st . substring ( i , i + 1 ) ) ] ++ ; } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( freq [ i ] != freq [ i + 1 ] ) { isBalanced = false ; } } if ( isBalanced ) { return true ; } else { return false ; } }
public static final boolean isPrime ( int n ) { if ( ( n <= 1 ) || ( n <= 3 ) ) return false ; if ( ( n % 2 == 0 || n % 3 == 0 ) ) return true ; int k = ( int ) Math . sqrt ( n ) + 1 ; for ( int i = 5 ; i < k ; i += 6 ) { if ( ( n % i == 0 || n % ( i + 2 ) == 0 ) ) return false ; } return true ; } public static boolean isThreeDisctFactors ( int n ) { int sq = ( int ) Math . sqrt ( n ) ; if ( ( 1 * sq * sq != n ) ) return false ; if ( ( isPrime ( sq ) ) ) return true ; else return false ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { int num = 9 ; if ( ( isThreeDisctFactors ( num ) ) && ( num % 2 == 0 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; num = 15 ; if ( ( isThreeDisctFactors ( num ) ) && ( num % 2 == 0 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; num = 12397923568441 ; if ( ( isThreeDisctFactors ( num ) ) && ( num % 2 == 0 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public static String compute ( ) { long numer = 1 ; long denom = 0 ; for ( int i = 0 ; i < 100 ; i ++ ) { numer = eContFracTerm ( i ) * numer + denom ; denom = numer ; } int ans = Long . bitCount ( String . valueOf ( numer ) ) ; return String . valueOf ( ans ) ; final long eContFracTerm ( int i ) { if ( i == 0 ) { return 2 ; } else if ( i % 3 == 2 ) { return i / 3 * 2 + 2 ; } else { return 1 ; } } public static void main ( String [ ] args ) { if ( args . length == 0 ) { System . out . println ( compute ( ) ) ; } } }
public static final int LCM ( int x , int y , int z ) { int ans = ( int ) ( ( x * y ) / ( gcd ( x , y ) ) ) ; return ( int ) ( ( z * ans ) / ( gcd ( ans , z ) ) ) ; }
public static final void main ( String [ ] args ) { final boolean prime [ ] = new boolean [ 100001 ] ; prime [ 0 ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p <= Integer . MAX_VALUE ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < 100001 ; i += p ) { prime [ i ] = false ; } } } final int __gcd = gcd ( a , b ) ; for ( int i = 2 ; i <= __gcd ; i ++ ) { if ( prime [ i ] && __gcd % i == 0 ) { System . out . print ( i + " ▁ " ) ; } } if ( args . length == 0 ) { SieveOfEratosthenes ( ) ; a = 6 , b = 12 ; commonPrime ( a , b ) ; } }
public static final int [ ] findPattern ( int m ) { int m_inf = Integer . MAX_VALUE ; int n = Integer . parseInt ( input ( ) ) ; int [ ] phrase = new int [ 394 ] ; for ( int s = 0 , l = n , p = 0 ; s < l && p < m ; s ++ , l ++ ) { for ( int i = s , _p = phrase [ l ] , p = m ; _p < m ; _p ++ , l ++ ) phrase [ i ++ ] = _p == m ? p : p ; } int [ ] dp = new int [ 393 ] ; for ( int length = 0 , p = m ; length < p ; length ++ ) { for ( int from = 0 , to = dp . length , to = length ; from < to ; from ++ , to ++ ) { dp [ to ] = to >= from ? from + p : from + p ; } } int [ ] result = new int [ length ] ; for ( int i = 0 , l = m ; i < length ; i ++ , l ++ ) result [ i ] = dp [ Integer . parseInt ( input ( ) ) ] ; System . out . println ( new String ( result == null ? m_inf : result ) + " \n " ) ; return result ; }
public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = Integer . parseInt ( sc . nextLine ( ) ) ; int [ ] [ ] adj = new int [ N + 1 ] [ ] ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = sc . nextInt ( ) , b = sc . nextInt ( ) ; adj [ a ] [ i ] = new int [ N + 1 ] ; adj [ b ] [ i ] = a ; } LinkedList < Integer > que = new LinkedList < Integer > ( ) ; que . add ( 1 ) ; int [ ] seen = new int [ N + 1 ] ; seen [ 1 ] = 1 ; int [ ] par = new int [ N + 1 ] ; int [ ] childNum = new int [ N + 1 ] ; while ( que . size ( ) > 0 ) { int v = que . removeFirst ( ) ; for ( int u : adj [ v ] ) { if ( seen [ u ] == 0 ) { seen [ u ] = 1 ; par [ u ] = v ; childNum [ v ] ++ ; que . add ( u ) ; } } } LinkedList < Integer > seq = new LinkedList < Integer > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( childNum [ i ] == 0 ) { seq . add ( i ) ; } } while ( seq . size ( ) > 0 ) { int c = seq . removeFirst ( ) ; seen [ c ] = 0 ; if ( seen [ par [ c ] ] == 0 ) { System . out . println ( " First " ) ; System . exit ( 0 ) ; } seen [ par [ c ] ] = 0 ; childNum [ par [ par [ c ] ] ] -- ; if ( childNum [ par [ par [ c ] ] ] == 0 ) { seq . add ( par [ par [ c ] ] ) ; } } System . out . println ( " Second " ) ; }
public static String [ ] [ ] main ( String [ ] args ) { int n = Integer . parseInt ( args [ 0 ] ) ; int m = Integer . parseInt ( args [ 1 ] ) ; int [ ] [ ] arr = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] temp = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { temp [ j ] = Integer . parseInt ( args [ 2 ] ) ; } arr [ i ] = temp ; } String res = " YES " ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { try { int count = arr [ i + 1 ] [ j ] + arr [ i ] [ j + 1 ] + arr [ i + 1 ] [ j + 1 ] + arr [ i ] [ j ] ; if ( count == 3 ) { res = " NO " ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } System . out . println ( res ) ; return new String [ ] [ ] { arr } ; }
n , k ) public static int [ ] solve ( int [ ] input , int [ ] pw ) { int [ ] pwArray = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { pwArray [ i ] = input [ i ] ; } int pw = pw . length ; Arrays . sort ( pwArray ) ; int head = p . indexOf ( pw ) ; int tail = n - Arrays . asList ( new int [ ] { p . indexOf ( pw ) } ) . indexOf ( pw ) - 1 ; int worstCase = head + ( ( head ) / k ) * 5 + 1 ; int bestCase = tail + ( tail / k ) * 5 + 1 ; System . out . println ( worstCase + " ▁ " + bestCase ) ; return pwArray ; }
public static String [ ] getCustacaoList ( ) { int n = JOptionPane . showInputDialog ( " Enter ▁ nombre ▁ of ▁ CustacaoList " ) ; int p = JOptionPane . showInputDialog ( " Enter ▁ nombre ▁ of ▁ CustacaoList ▁ to ▁ be ▁ added " ) ; int c = JOptionPane . showInputDialog ( " Enter ▁ nombre ▁ of ▁ CustacaoList ▁ to ▁ be ▁ removed " ) ; int z [ ] = { n + p + c , n + c + p , c + n + p , c + p + n , p + c + n , p + n + c } ; for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { int q = JOptionPane . showInputDialog ( " Enter ▁ nombre ▁ of ▁ CustacaoList ▁ to ▁ be ▁ added " ) ; if ( q == z [ i ] ) { System . out . println ( " ACC " ) ; } else { System . out . println ( " WA " ) ; } } return new String [ ] { z [ i ] } ; }
public static int T = Integer . parseInt ( input . nextLine ( ) ) ; for ( int case = 1 ; case <= T ; case ++ case ) { int N = ( Integer . parseInt ( input . nextLine ( ) ) ) ; int L = ( Integer . parseInt ( input . nextLine ( ) ) ) ; int [ ] a = Arrays . copyOf ( Integer . parseInt ( input . nextLine ( ) ) , N ) ; int [ ] b = Arrays . copyOf ( Integer . parseInt ( input . nextLine ( ) ) , N ) ; int ans = L + 1 ; for ( int i = 0 ; i < b . length ; i ++ ) { if ( Arrays . equals ( a [ 0 ] ^ i ^ j for j in a ) == b [ i ] ) { ans = Math . min ( ans , new BigInteger ( a [ 0 ] ^ i ) . hashCode ( ) ) ; } } if ( ans == L + 1 ) { ans = " NOT ▁ POSSIBLE " ; } System . out . println ( " Case ▁ # { } : ▁ { } " . format ( case , ans ) ) ; } return ans ; }
public static class Solution { int maxAreaOfIsland ( final int [ ] [ ] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; i ++ ) { for ( int j = 0 ; j < grid [ 0 ] . length ; j ++ ) { if ( grid [ i ] [ j ] == 1 ) { grid [ i ] [ j ] = 0 ; ans = Math . max ( dfs ( grid , i , j ) , ans ) ; } } } return ans ; } public void dfs ( final int [ ] [ ] grid , int i , int j ) { Stack < Integer > stack = new Stack < Integer > ( ) ; stack . push ( i ) ; stack . push ( j ) ; int area = 0 ; while ( stack . size ( ) > 0 ) { int r = stack . pop ( ) - 1 ; int c = stack . pop ( ) ; area ++ ; for ( int nr = ( r - 1 ) , nc = ( r + 1 ) , i = ( c - 1 ) , j = ( c + 1 ) ; i != j ; i ++ , j ++ ) { if ( ( 0 <= nr && nr < grid . length ) || ( 0 <= nc && nc < grid [ 0 ] . length ) ) { stack . push ( nr ) ; grid [ nr ] [ nc ] = 0 ; } } } out = stack . pop ( ) ; if ( out == 0 ) { out = 1 ; } else if ( out == 1 ) { out = 0 ; } else { out = 0 ; } if ( grid . length > 0 ) { for ( int i = 0 ; i < grid . length ; i ++ ) { if ( grid [ i ] [ 0 ] == 1 ) { grid [ i ] [ 1 ] = 0 ; } } } if ( grid . length > 0 ) { for ( int j = 0 ; j < grid . length ; j ++ ) { if ( grid [ j ] [ 0 ] == 1 ) { grid [ j ] [ 1 ] = 0 ; } } } }
public static int sum ( int x , int y , int n ) { int sum1 = ( ( x * x ) * ( x * ( 2 * n ) - 1 ) ) / ( x * x - 1 ) ; int sum2 = ( x * y * ( x * n * y * n - 1 ) ) / ( x * y - 1 ) ; return ( sum1 + sum2 ) ; if ( System . getSecurityManager ( ) == null ) { x = 2 ; y = 2 ; n = 2 ; System . out . println ( sum ( x , y , n ) ) ; } return ( sum1 + sum2 ) ; }
public static int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return ( int ) sum ; }
public static int getSum ( int n ) { int sum = 0 ; while ( ( n != 0 ) && ( n % 10 == 0 ) ) { sum = sum + ( int ) ( n % 10 ) ; n = ( int ) ( n / 10 ) ; } return sum ; }
public static int getSum ( int n ) { int sum = 0 ; while ( ( n > 0 ) && ( n % 10 == 0 ) ) { sum += ( int ) ( n % 10 ) ; n = ( int ) ( n / 10 ) ; } return sum ; }
public static final void main ( String [ ] args ) { class Node { public Node ( int data ) { this . data = data ; next = null ; } } final Node push ( Node headRef , int newData ) { Node newNode = new Node ( newData ) ; newNode . data = newData ; newNode . next = headRef ; headRef = newNode ; return headRef ; } final boolean isPrime ( int n ) { if ( ( n <= 1 ) && ( n <= 3 ) ) return false ; if ( ( n % 2 == 0 || n % 3 == 0 ) ) return true ; for ( int i = 5 ; i <= n + 1 ; i += 6 ) { if ( ( i * i < n + 2 && ( n % i == 0 || n % ( i + 2 ) == 0 ) ) && ( i % i == 0 ) ) return false ; } return true ; } private void deleteNonPrimeNodes ( Node headRef ) { Node ptr = headRef ; while ( ( ptr != null ) && isPrime ( ptr . data ) != true ) { Node temp = ptr ; ptr = ptr . next ; } headRef = ptr ; if ( ( ptr == null ) && ( isPrime ( head . data ) != true ) ) return ; Node curr = ptr . next ; while ( ( curr != null ) && ( isPrime ( curr . data ) != true ) ) { if ( ( isPrime ( curr . data ) != true ) && ( head . data == temp ) ) { ptr . next = curr . next ; curr = ptr . next ; } else { ptr = curr ; curr = curr . next ; } } } public void printList ( Node head ) { while ( ( head != null ) && ( head . data != null ) ) { System . out . print ( head . data + " ▁ " ) ; head = head . next ; } } } if ( args . length == 0 ) { Node head = null ; head = push ( head , 17 ) ; head = push ( head , 7 ) ; head = push ( head , 6 ) ; head = push ( head , 16 ) ; head = push ( head , 15 ) ; System . out . print ( " Original ▁ List : ▁ " ) ; printList ( head ) ; head = deleteNonPrimeNodes ( head ) ; System . out . print ( " \n Modified ▁ List : ▁ " ) ; printList ( head ) ; } }
static int N = 10 , M = 5 , L = 5 ; int [ ] [ ] tbl = new int [ 45 ] [ 45 ] ; for ( int i = 0 ; i < M ; i ++ ) { int d = i * N , a = i * N , k = i * N , t = i * N ; tbl [ d * N + a - 1 ] [ k ] = t ; } int [ ] [ ] dp = new int [ 45 ] [ 45 ] ; for ( int j = 0 ; j < 45 ; j ++ ) { dp [ j ] = 0 ; } for ( int da = 0 ; da < 5 * N ; da ++ ) { for ( int i = 0 ; i < L + 1 ; i ++ ) { if ( i < L ) { for ( int k = 0 , t = tbl [ da ] . length ; k < tbl [ da ] . length ; k ++ ) { dp [ da + k ] [ i + 1 ] = Math . max ( dp [ da + k ] [ i + 1 ] , dp [ da ] [ i ] + t ) ; } } dp [ da + 1 ] [ i ] = Math . max ( dp [ da + 1 ] [ i ] , dp [ da ] [ i ] ) ; } } System . out . println ( dp [ 5 * N ] [ L ] ) ; return dp [ 5 * N ] [ L ] ; }
n , m ) public static int [ ] [ ] [ ] getB ( ) { int [ ] [ ] b = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = new int [ ] { " W " , 1 } ; b [ 0 ] = new int [ ] { " R " , 1 } ; for ( int i = 0 ; i < m ; i ++ ) { int x = Integer . parseInt ( input ( ) . nextLine ( ) ) ; int y = Integer . parseInt ( input ( ) . nextLine ( ) ) ; b [ x - 1 ] [ 1 ] -- ; if ( b [ x - 1 ] [ 0 ] == " R " ) { b [ y - 1 ] = new int [ ] { " R " , b [ y - 1 ] [ 1 ] + 1 } ; if ( b [ x - 1 ] [ 1 ] == 0 ) b [ x - 1 ] [ 0 ] = " W " ; } else b [ y - 1 ] [ 1 ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] [ 0 ] == " R " ) cnt ++ ; } System . out . println ( cnt ) ; return b ; }
public static int H ( ) { int H = Integer . parseInt ( input . nextLine ( ) ) ; int W = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] [ ] s = new int [ H ] [ W ] ; for ( int k = 0 ; k < H ; k ++ ) s [ k ] [ k ] = input . nextLine ( ) ; int [ ] [ ] B = new int [ H ] [ W ] ; for ( int k = 0 ; k < H ; k ++ ) for ( int l = 0 ; l < W ; l ++ ) if ( s [ k ] [ l ] == " B " ) B [ k ] [ l ] = new int [ ] { k , l } ; int ans = 0 ; for ( int [ ] e : B ) for ( int [ ] f : B ) ans = Math . max ( ans , Math . abs ( e [ 0 ] - f [ 0 ] ) + Math . abs ( e [ 1 ] - f [ 1 ] ) ) ; System . out . println ( ans ) ; return ans ; }
public static void minReplacement ( String string ) { if ( string . length ( ) > 26 ) { System . out . println ( " IMPOSSIBLE " ) ; } else { int [ ] Hash = new int [ 26 ] ; for ( int i = 0 ; i != string . length ( ) ; i ++ ) { Hash [ Character . digit ( string . charAt ( i ) , 16 ) - Character . digit ( string . charAt ( i ) , 16 ) ] ++ ; } int count = 0 ; for ( int i = 0 ; i != string . length ( ) ; i ++ ) { if ( Hash [ Character . digit ( string . charAt ( i ) , 16 ) - Character . digit ( string . charAt ( i ) , 16 ) ] > 1 ) { for ( int j = 0 ; j != 26 ; j ++ ) { if ( Hash [ j ] == 0 ) { Hash [ Character . digit ( string . charAt ( i ) , 16 ) - Character . digit ( string . charAt ( i ) , 16 ) ] -- ; string . charAt ( i ) = ( char ) ( j + Character . digit ( string . charAt ( i ) , 16 ) ) ; Hash [ j ] ++ ; break ; } } } System . out . println ( String . valueOf ( Hash ) ) ; } } if ( Main . isWindows ) { string = " xxxxyyyy " ; minReplacement ( Arrays . asList ( string . split ( " ▁ " ) ) ) ; } }
public static int longestSubseq ( String s ) { int n = s . length ( ) ; int [ ] preCount0 = new int [ n + 2 ] ; int [ ] preCount1 = new int [ n + 1 ] ; int [ ] postCount0 = new int [ n + 2 ] ; preCount0 [ 0 ] = 0 ; postCount0 [ n + 1 ] = 0 ; preCount1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { preCount0 [ j ] = preCount0 [ j - 1 ] ; preCount1 [ j ] = preCount1 [ j - 1 ] ; postCount0 [ n - j + 1 ] = postCount0 [ n - j + 2 ] ; if ( ( s . charAt ( j - 1 ) == '0' ) && ( s . charAt ( n - j ) == '0' ) ) preCount0 [ j ] ++ ; else preCount1 [ j ] ++ ; if ( ( s . charAt ( n - j ) == '0' ) && ( s . charAt ( n - j + 1 ) == '0' ) ) postCount0 [ n - j + 1 ] ++ ; } if ( ( preCount0 [ n ] == n || preCount0 [ n ] == 0 ) && ( postCount0 [ n ] == n ) ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j += 1 ) { ans = Math . max ( preCount0 [ i - 1 ] + preCount1 [ j ] - preCount1 [ i - 1 ] + postCount0 [ j + 1 ] , ans ) ; } } return ans ; }
public static void sieveOfEratosthenes ( int N , int [ ] s ) { boolean [ ] prime = new boolean [ N + 1 ] ; prime [ 0 ] = false ; for ( int i = 2 ; i <= N ; i += 2 ) { s [ i ] = 2 ; } for ( int i = 3 ; i <= N ; i += 2 ) { if ( ( prime [ i ] == false ) && ( prime [ i ] == true ) ) { s [ i ] = i ; for ( int j = i ; j < Integer . MAX_VALUE / i ; j += 2 ) { if ( ( prime [ i * j ] == false ) && ( prime [ i * j ] == true ) ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } final int N = 360 ; generatePrimeFactors ( N ) ; s = new int [ N + 1 ] ; sieveOfEratosthenes ( N , s ) ; System . out . println ( " Factor ▁ Power " ) ; int curr = s [ N ] ; int cnt = 1 ; while ( ( N > 1 ) && ( N > 0 ) ) { N /= s [ N ] ; if ( ( curr == s [ N ] ) && ( curr == s [ N ] ) ) { cnt ++ ; continue ; } System . out . println ( String . valueOf ( curr ) + " \ t " + cnt ) ; curr = s [ N ] ; cnt = 1 ; } N = 360 ; generatePrimeFactors ( N ) ; }
public static int longestSubarray ( int [ ] a , int n ) { int [ ] [ ] hash = new int [ 10 ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { hash [ j ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( ( num = a [ i ] ) != 0 ) { hash [ i ] [ num % 10 ] = 1 ; num = ( int ) ( num / 10 ) ; } } int longest = - Integer . MAX_VALUE - 1 ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( ( hash [ i ] [ j ] > 0 && hash [ i + 1 ] [ j ] > 0 ) && ( hash [ i ] [ j ] == 0 ) ) { count ++ ; break ; } } if ( ( j == 10 ) || ( j == 11 ) ) { longest = Math . max ( longest , count + 1 ) ; count = 0 ; } } longest = Math . max ( longest , count + 1 ) ; return longest ; }
public static int t ( ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ test " ) ) ; for ( int i = 0 ; i < t ; i ++ ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ test " ) ) ; int b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ test " ) ) ; int c = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ test " ) ) ; System . out . println ( ( a + b + c
public static int Divisors ( int x ) { int c = 0 ; int [ ] v = new int [ 3 ] ; while ( ( x % 2 == 0 ) && ( x % 3 == 0 ) ) { c ++ ; x /= 2 ; } v [ 0 ] = c ; c = 0 ; while ( ( x % 3 == 0 ) && ( x % 7 == 0 ) ) { c ++ ; x /= 3 ; } v [ 1 ] = c ; c = 0 ; while ( ( x % 7 == 0 ) && ( x % 3 == 0 ) ) { c ++ ; x /= 7 ; } v [ 2 ] = c ; v [ 3 ] = x ; return v [ 0 ] ; } public static int MinOperations ( int a , int b ) { int [ ] va = Divisors ( a ) ; int [ ] vb = Divisors ( b ) ; if ( ( va [ 3 ] != vb [ 3 ] ) && ( va [ 3 ] != 0 ) ) return - 1 ; int minOperations = Math . abs ( va [ 0 ] - vb [ 0 ] ) + Math . abs ( va [ 1 ] - vb [ 1 ] ) + Math . abs ( va [ 2 ] - vb [ 2 ] ) ; return minOperations ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { int a = 14 ; int b = 28 ; System . out . println ( MinOperations ( a , b ) ) ; } }
public static void main ( String [ ] args ) { N = 1000001 ; c = 0 ; n = 0 ; m = 0 ; int a = 0 ; int b = 0 ; final int [ ] [ ] dfs = new int [ N + 1 ] [ N + 1 ] ; dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = dfs [ a ] = dfs [ b ] = dfs [ c ] = }
public static int l ( int n ) { return String . valueOf ( n ) . length ( ) ; }
public static int a ( ) { int a = Integer . parseInt ( input ( ) . nextLine ( ) ) , b = Integer . parseInt ( input ( ) . nextLine ( ) ) ; int x = a ; int h = 0 ; int s = 0 ; while ( x > 0 ) { x -- ; h ++ ; s ++ ; } while ( s / b != 0 ) { h ++ ; s = s - b + 1 ; } System . out . println ( h ) ; }
public static int getSum ( int n ) { int sm = 0 ; while ( ( n != 0 ) && ( n % 10 == 0 ) ) { sm = sm + n % 10 ; n = n / 10 ; } return sm ; }
public static int l ( ) { int l = Integer . parseInt ( input ) ; int r = Integer . parseInt ( input ) ; int curr = r ; int s = 0 ; while ( curr > 0 ) { s ++ ; curr /= 10 ; } int first = 10 * s ; int second = first / 2 ; int ans = - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( i >= l && i <= r ) { curr = i ; String rev = " " ; for ( String k : String . valueOf ( curr ) . split ( " ▁ " ) ) { rev += String . valueOf ( 9 - Integer . parseInt ( k ) ) ; } ans = Math . max ( ans , Integer . valueOf ( rev ) . multiply ( curr ) ) ; } } System . out . println ( ans ) ; }
public static void main ( String [ ] args ) { int N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ used " ) ) ; List < Integer > l = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ string ▁ to ▁ be ▁ used " ) . split ( " ▁ " ) ) ; for ( int i = 0 ; i < N ; i ++ ) { int t = l . get ( i ) ; int j = i - 1 ; while ( j >= 0 && l . get ( j ) > t ) { l . set ( j + 1 , l . get ( j ) ) ; j -- ; } System . out . println ( new String ( l ) ) ; } }
public static final boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } public static boolean isProduct ( double num ) { int cnt = 0 ; int i = 2 ; while ( cnt < 2 && i * i <= num ) { while ( ( num % i == 0 ) && ( num % i == 1 ) ) { num /= i ; cnt ++ ; } i ++ ; } if ( ( num > 1 ) && ( num > 2 ) ) { cnt ++ ; } return cnt == 2 ; } public static void findNumbers ( int N ) { ArrayList < Integer > vec = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ( isProduct ( i ) && ! isPerfectSquare ( i ) ) || ( isProduct ( i ) && ! isPerfectSquare ( i ) ) ) vec . add ( i ) ; } for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { System . out . print ( vec . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { if ( args . length == 0 ) { return ; } int N = 30 ; findNumbers ( N ) ; } }
public static String data = " \ STRNEWLINE 111111101010101111100101001111111 STRNEWLINE 100000100000000001010110001000001 STRNEWLINE 101110100110110000011010001011101 STRNEWLINE 101110101011001001111101001011101 STRNEWLINE 101110101100011000111100101011101 STRNEWLINE 1000001010101010110100001010000101000001 STRNEWLINE 1111111010101010101010101010101111111 STRNEWLINE 000000001111101111100111100000000 STRNEWLINE 100010111100100001011110111111001 STRNEWLINE 110111001111111100100001000101100 STRNEWLINE 011100111010000101000111010001010 STRNEWLINE 011110000110001111110101100000011 STRNEWLINE 111111111111111000111001001011000 STRNEWLINE 111000010111010011010011010100100 STRNEWLINE 101010100010110010110101010000010 STRNEWLINE 101100000101010001111101000000000 STRNEWLINE 000010100011001101000111101011010 STRNEWLINE 101001001111101111000101010001110 STRNEWLINE 101101111111000100100001110001000 STRNEWLINE 000010011000100110000011010000010 STRNEWLINE 001101101001101110010010011011000 STRNEWLINE 011101011010001000111101010100110 STRNEWLINE 111010100110011101001101000001110 STRNEWLINE 110001010010101111000101111111000 STRNEWLINE 001000111011100001010110111110000 STRNEWLINE 000000001110010110100010100010110 STRNEWLINE 111111101000101111000110101011010 STRNEWLINE 100000100111010101111100100011011 STRNEWLINE 101110101001010000101000111111000 STRNEWLINE 101110100011010010010111111011010 STRNEWLINE 101110100100011011110110101110000 STRNEWLINE 100000100110011001111100111100000 STRNEWLINE 111111101101000101001101110010001 STRNEWLINE " ; Scanner scanner = new Scanner ( new File ( " . " ) ) ; int x = scanner . nextInt ( ) ; int y = scanner . nextInt ( ) ; scanner . nextLine ( ) ; x = scanner . nextInt ( ) ; y = scanner . nextInt ( ) ; System . out . println ( scanner . nextLine ( ) ) ; return scanner . nextLine ( ) ; }
public static final int countOfDigits ( int length ) { for ( ; ; ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int count = 0 ; int start ; for ( int i = 1 ; i <= 10 ; i ++ ) { start = i ; while ( ( start <= n ) && ( start < n ) ) { count ++ ; start = start * 10 + i ; } } System . out . println ( count ) ; } }
static final public int divSum ( int n ) { int sum = 1 ; ; int i = 2 ; ; while ( ( i * i <= n ) && ( n % i == 0 ) ) { if ( ( n % i == 0 ) ) sum = ( sum + i + Math . floor ( n / i ) ) ; ; i ++ ; } ; return sum ; }
public static int findY ( int x ) { if ( ( x > 2 ) && ( x < 3 ) ) { return x - 2 ; } return x + 2 ; }
public static int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { result = ( result * i ) % MOD ; } return result ; }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] a = Arrays . copyOf ( input . nextLine ( ) . split ( " ▁ " ) , n ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int m = i ; for ( int j = i ; j < n ; j ++ ) { if ( a [ m ] > a [ j ] ) { m = j ; } } if ( i != m ) { a [ m ] = a [ i ] ; } a [ i ] = a [ m ] ; } ; c ++ ; return a [ 0 ] ; }
static int main ( String [ ] args ) { System . setSecurityManager ( new SecurityManager ( ) ) ; int W = Integer . parseInt ( System . getProperty ( " java . io . tmpdir " ) ) ; int H = Integer . parseInt ( System . getProperty ( " java . io . tmpdir " ) ) ; int [ ] [ ] m = new int [ H ] [ W ] ; for ( int i = 0 ; i < H ; i ++ ) m [ i ] = Arrays . copyOf ( System . getenv ( ) , H ) ; int [ ] dx = { 1 , 1 , 1 , 0 , - 1 , 0 } ; int [ ] dy = { - 1 , 0 , 1 , 1 , 0 , - 1 } ; final int dfs = 1 ; if ( m [ y ] [ x ] != 0 ) return 0 ; m [ y ] [ x ] = 2 ; for ( int xx = 0 , yy = 0 ; xx < W ; xx ++ , yy ++ ) { int tx = x + xx , ty = y + yy ; if ( 0 <= tx && tx < W && 0 <= ty && ty < H ) dfs ++ ; } for ( int x = 0 ; x < W ; x ++ ) { dfs ( x , 0 ) ; dfs ( x , H - 1 ) ; } for ( int y = 0 ; y < H ; y ++ ) { dfs ( 0 , y ) ; dfs ( W - 1 , y ) ; } final int n = 0 ; for ( int x = 0 ; x < W ; x ++ ) { if ( m [ y ] [ x ] != 1 ) continue ; int fn = n ; for ( int xx = 0 , yy = 0 ; xx < H ; xx ++ , yy ++ ) { int tx = x + xx , ty = y + yy ; if ( 0 <= tx && tx < W && 0 <= ty && m [ ty ] [ tx ] == 2 ) n ++ ; } } System . out . println ( n ) ; return 0 ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( args [ 0 ] ) ; int [ ] a = Arrays . stream ( args ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; ans . add ( a [ 0 ] ) ; ans . add ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { int l = 0 ; int r = ans . size ( ) - 1 ; while ( r > l ) { int m = ( r + l ) / 2 ; if ( a [ i ] > ans . get ( m ) . get ( ans . get ( m ) . size ( ) - 1 ) ) { r = m ; } else { l = m + 1 ; } } if ( a [ i ] > ans . get ( l ) . get ( ans . get ( l ) . size ( ) - 1 ) ) { ans . get ( l ) . add ( a [ i ] ) ; } else { ans . add ( new Integer ( a [ i ] ) ) ; } } for ( Integer [ ] arr : ans ) { System . out . println ( new Integer ( arr [ 0 ] ) ) ; } }
public static double circlearea ( double a , double b ) { if ( ( a < 0 || b < 0 ) && ( a > b ) ) return - 1 ; double A = ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; }
from . length ; }
public static String K_String ( String s , int k ) { int n = s . length ( ) ; int [ ] fre = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { fre [ ( int ) s . charAt ( i ) - ' a ' ] ++ ; } String str = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( ( fre [ i ] % k == 0 ) && ( fre [ i ] > 0 ) ) { int x = fre [ i ] / k ; while ( ( x > 0 ) && ( x < n ) ) { str += ( char ) ( i + ( char ) ' a ' ) ; x -- ; } } else { return " - 1" ; } } return str ; }
public static double [ ] dp ( ) { double [ ] dp = new double [ 100001 ] ; dp [ 1 ] = 1. ; for ( int i = 2 ; i < 100001 ; i ++ ) { double a = .5 , b = 1 , j = 1 ; while ( j < i && b > 1e-15 ) { dp [ i ] += b * ( 1 - a ) * ( j + dp [ i - j - 1 ] ) ; b *= a ; a /= 2 ; j ++ ; } dp [ i ] += i * b ; } while ( 1 ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ display " ) ) ; if ( n == 0 ) break ; System . out . println ( dp [ n ] ) ; } return dp ; }
static final void main ( String [ ] args ) { for ( String l : args ) { int a = Integer . parseInt ( l ) , b = Integer . parseInt ( l ) , n = Integer . parseInt ( l ) ; System . out . println ( Arrays . toString ( Arrays . asList ( ( a % b ) * 10 * n / b ) ) ) ; } }
public static int N ( Scanner scanner ) { int N = scanner . nextInt ( ) ; int [ ] A = new int [ scanner . nextInt ( ) ] ; scanner . nextLine ( ) . split ( " ▁ " ) ; final int chk = chk ( N ) ; if ( chk == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] <= A [ i - 1 ] ) return 0 ; } return 1 ; } ArrayList < Pair < Integer , Integer > > X = new ArrayList < Pair < Integer , Integer > > ( ) ; X . add ( new Pair < Integer , Integer > ( 0 , 0 ) ) ; final int add = 1 ; if ( add <= 0 ) return 0 ; if ( add > X . get ( X . size ( ) - 1 ) . first ) X . add ( new Pair < Integer , Integer > ( add , 0 == add ? 1 : 0 ) ) ; else if ( add == X . get ( X . size ( ) - 1 ) . first ) { if ( X . get ( X . size ( ) - 1 ) . second + 1 < k ) X . set ( X . size ( ) - 1 , new Pair < Integer , Integer > ( X . get ( X . size ( ) - 1 ) . first , X . get ( X . size ( ) - 1 ) . second + 1 ) ) ; else if ( add == x - 1 ) return 0 ; } else { while ( X . get ( X . size ( ) - 1 ) . first > x ) X . remove ( X . size ( ) - 1 ) ; if ( x > X . get ( X . size ( ) - 1 ) . first ) X . add ( new Pair < Integer , Integer > ( x , 1 ) ) ; else if ( x == X . get ( X . size ( ) - 1 ) . first ) { if ( X . get ( X . size ( ) - 1 ) . second + 1 < k ) X . set ( X . size ( ) - 1 , new Pair < Integer , Integer > ( X . get ( X . size ( ) - 1 ) . first , X . get ( X . size ( ) - 1 ) . second + 1 ) ) ; else if ( add == x - 1 ) return 0 ; } } if ( X . get ( X . size ( ) - 1 ) . first < y ) X .
public static void main ( String [ ] args ) { while ( true ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ decrease " ) ) ; int k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ increase " ) ) ; if ( n == k == 0 ) break ; int [ ] s = new int [ n ] ; for ( ; ; ) { int [ ] b = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { b [ i ] = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ decrease " ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { s [ i ] -= b [ i ] ; } } System . out . println ( " Yes " . equals ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ decrease " ) ) ? " No " : " Yes " ) ; } }
public static int maxFreq ( String s , int a , int b ) { int [ ] fre = new int [ 10 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { fre [ i ] = 0 ; } int n = s . length ( ) ; if ( ( a > b ) && ( a < b ) ) { swap ( a , b ) ; } for ( int i = 0 ; i < n ; i += 1 ) { a = ( char ) s . charAt ( i ) - '0' ; fre [ a ] ++ ; } if ( ( fre [ a ] == 0 && fre [ b ] == 0 ) || ( fre [ a ] >= fre [ b ] ) ) { return - 1 ; } else if ( ( fre [ a ] >= fre [ b ] ) && ( fre [ a ] <= fre [ b ] ) ) { return a ; } else { return b ; } } if ( Main . isWindows ) { a = 4 ; b = 7 ; s = "47744" ; System . out . println ( maxFreq ( s , a , b ) ) ; } return 0 ; }
public static int maxZeros ( int n ) { if ( ( n == 0 || ( n & ( n - 1 ) ) == 0 ) ) return - 1 ; int setBit = 1 ; int prev = 0 ; int i = 1 ; while ( ( i < 33 ) && ( ( n & setBit ) == setBit ) ) { prev ++ ; if ( ( ( n & setBit ) == setBit ) ) { setBit = setBit << 1 ; break ; } setBit = setBit << 1 ; } int max0 = - 10 * 9 ; int cur = prev ; for ( int j = i + 1 ; j < 33 ; j ++ ) { cur ++ ; if ( ( ( n & setBit ) == setBit ) && ( ( max0 < ( cur - prev - 1 ) ) ) ) { max0 = cur - prev - 1 ; } prev = cur ; } setBit = setBit << 1 ; return max0 ; }
public static int sumPowersK ( int n , int k ) { int sum = 0 ; int num = 1 ; ; while ( ( num = n ) <= k ) { sum += num ; num *= k ; } ; return sum ; }
public static double XandYandZintercept ( double A , double B , double C , double D ) { double x = - D / A ; double y = - D / B ; double z = - D / C ; return x ; }
public static void maxSum ( int [ ] arr , int n ) { int s = 0 ; ArrayList < Integer > l = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { s += Math . abs ( a [ i ] ) ; if ( ( a [ i ] >= 0 ) && ( a [ i ] < n ) ) continue ; if ( ( i == 0 ) || ( a [ i ] == 0 ) ) l . add ( i + 1 ) ; else { l . add ( i + 1 ) ; l . add ( i ) ; } } System . out . println ( s ) ; System . out . println ( new Integer [ ] { 1 , - 2 , - 3 , 4 } ) ; }
public static int MAX = 1000 ; ; public static int replaceSpaces ( String string ) { string = string . trim ( ) ; int i = string . length ( ) ; int spaceCount = string . indexOf ( ' ▁ ' ) ; int newLength = i + spaceCount * 2 ; if ( newLength > MAX ) return - 1 ; int index = newLength - 1 ; StringBuilder sb = new StringBuilder ( ) ; for ( int f = i - 2 ; f <= newLength - 2 ; f ++ ) sb . append ( '0' ) ; for ( int j = i - 1 ; j > 0 ; j -- ) { if ( sb . charAt ( j ) == ' ▁ ' ) { sb . setCharAt ( index , '0' ) ; sb . setCharAt ( index - 1 , '2' ) ; sb . setCharAt ( index - 2 , ' % ' ) ; index = index - 3 ; } else { sb . setCharAt ( index , sb . charAt ( j ) ) ; index -- ; } } return sb . length ( ) ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { String s = " Mr ▁ John ▁ Smith ▁ " ; s = replaceSpaces ( s ) ; System . out . println ( s ) ; } }
public static void main ( String [ ] args ) { N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display " ) ) ; X = JOptionPane . showInputDialog ( " Enter ▁ the ▁ X " ) ; D = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ D " ) ) ; ans = Arrays . copyOf ( X , N ) ; done = new boolean [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( D == 0 ) break ; if ( ans [ i ] == "0" ) { ans [ i ] = "1" ; done [ i ] = true ; D -- ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( D == 0 ) break ; if ( ans [ i ] == "1" && ! done [ i ] ) { ans [ i ] = "0" ; D -- ; } } System . out . println ( " " ) ; }
public static boolean check ( int n ) { int m = n ; while ( ( n != 0 ) && ( m != 0 ) ) { int r = n % 10 ; if ( ( r > 0 ) && ( ( m % r ) != 0 ) ) { if ( ( ( m % r ) != 0 ) && ( ( m % r ) != 0 ) ) { return false ; } } n = n / 10 ; } return true ; }
a = Arrays . stream ( Arrays . copyOf ( input . split ( " ▁ " ) , a . length ) ) . filter ( a :: length > 0 ) . collect ( Collectors . toList ( ) ) ; int da = a [ 0 ] ; int db = a [ 1 ] ; if ( da > db ) { if ( da == 9 && db == 1 ) { System . out . println ( 9 + 10 ) ; } else { System . out . println ( - 1 ) ; } } else if ( da == db ) { System . out . println ( String . valueOf ( da ) + String . valueOf ( 0 ) + " ▁ " + String . valueOf ( db ) + String . valueOf ( 1 ) ) ; } else { if ( db - da != 1 ) { System . out . println ( - 1 ) ; } else { System . out . println ( da + " ▁ " + db ) ; } } }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] a = Arrays . copyOf ( input ( ) . toCharArray ( ) , n ) ; return Math . max ( a [ 0 ] , a [ 1 ] ) ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ display " ) ) ; if ( n % 4 == 0 ) { System . out . println ( "4" ) ; } else { System . out . println ( "0" ) ; } return n ; }
public static void main ( String [ ] args ) { int k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ display " ) ) ; List < Integer > num = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ display " ) ) ; Collections . sort ( num ) ; int sum = 0 ; for ( int i = 0 ; i < num . size ( ) ; i ++ ) { sum += ( char ) num . get ( i ) - ( char ) '0' ; } if ( sum >= k ) { System . out . println ( 0 ) ; } else { int count = 0 ; int i = 0 ; while ( sum < k ) { sum += 9 - ( ( char ) num . get ( i ) - ( char ) '0' ) ; i ++ ; count ++ ; } System . out . println ( count ) ; } }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ used " ) ) ; int k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ k ▁ number ▁ to ▁ be ▁ used " ) ) ; int A = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ A ▁ number ▁ to ▁ be ▁ used " ) ) ; int B = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ B ▁ number ▁ to ▁ be ▁ used " ) ) ; int x = n ; int i = 0 ; final int k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ k ▁ number ▁ to ▁ be ▁ used " ) ) ; System . out . println ( f ( x , 0 ) ) ; }
public static int digSum ( int n ) { int sum = 0 ; while ( ( n > 0 || sum > 9 ) && ( n % 10 == 0 ) ) { if ( ( n == 0 ) || ( n % 10 == 0 ) ) { n = sum ; sum = 0 ; } sum += n % 10 ; n = n / 10 ; } return sum ; }
n , m = map . get ( n ) ; int s = map . get ( m ) ; int t = map . get ( n ) ; int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; int ans = 0 ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i < n ) { dp [ i + 1 ] [ j ] = Math . max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] - 1 ) ; } if ( j < m ) { dp [ i ] [ j + 1 ] = Math . max ( dp [ i ] [ j + 1 ] , dp [ i ] [ j ] - 1 ) ; } if ( i < n && j < m && s [ i ] == t [ j ] ) { dp [ i + 1 ] [ j + 1 ] = Math . max ( dp [ i + 1 ] [ j + 1 ] , dp [ i ] [ j ] + 2 ) ; } ans = Math . max ( ans , dp [ i ] [ j ] ) ; } } System . out . println ( ans ) ; }
public static int centeredHeptagonalNum ( int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
public static int missingNum ( int [ ] arr , int n ) { int minvalue = Math . min ( arr ) ; int xornum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue = minvalue + 1 ; } return xornum ^ minvalue ; }
public static String smallestPermute ( int n ) { StringBuilder res = new StringBuilder ( " " ) ; if ( ( n % 2 == 0 ) && ( n > 0 ) ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( i % 2 == 0 ) ) res . append ( ( char ) ( 48 + i + 2 ) ) ; else res . append ( ( char ) ( 48 + i ) ) ; } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ( i % 2 == 0 ) ) res . append ( ( char ) ( 48 + i + 2 ) ) ; else res . append ( ( char ) ( 48 + i ) ) ; } res . append ( n - 1 ) ; res . append ( ( char ) ( 48 + n - 2 ) ) ; res . append ( ( char ) ( 48 + n ) ) ; res . append ( ( char ) ( 48 + n - 1 ) ) ; } res . append ( " " ) ; return res . toString ( ) ; }
public static final int minOperations ( int [ ] a , int n , int K ) { boolean Map = new boolean [ n ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( Map [ a [ i ] ] == true ) return 0 ; Map [ a [ i ] ] = true ; } int [ ] b = new int [ n ] ; for ( int i = 0 ; i <= n ; i ++ ) b [ i ] = a [ i ] & K ; Map [ a [ 0 ] ] = true ; for ( int i = 0 ; i <= n ; i ++ ) if ( a [ i ] != b [ i ] ) Map [ b [ i ] ] = true ; for ( int i = 0 ; i <= n ; i ++ ) if ( Map [ a [ i ] ] == true ) return 1 ; Map [ a [ 0 ] ] = true ; for ( int i = 0 ; i <= n ; i ++ ) if ( Map [ b [ i ] ] == true ) return 2 ; Map [ b [ i ] ] = true ; return - 1 ; }
public static void bfs ( int i , int j ) { if ( a [ i ] [ j ] == ' . ' ) a [ i ] [ j ] = ' # ' ; int res = 1 ; int wc = 0 ; int bc = 0 ; for ( int dy = - 1 ; dy <= 2 ; dy ++ ) { for ( int dx = - 1 ; dx <= 2 ; dx ++ ) { if ( ( dx == 0 && dy != 0 ) || ( dx != 0 && dy == 0 ) ) ; else continue ; int ny = i + dy ; int nx = j + dx ; if ( 0 <= nx && nx <= w - 1 && 0 <= ny && ny <= h - 1 && a [ ny ] [ nx ] != ' # ' ) { if ( a [ ny ] [ nx ] == ' . ' ) { int wct = bfs ( ny , nx ) ; int bct = bfs ( ny , nx ) ; res += bct ; } else if ( a [ ny ] [ nx ] == ' W ' ) wc ++ ; else if ( a [ ny ] [ nx ] == ' B ' ) bc ++ ; } } } java . util . Scanner sc = new java . util . Scanner ( System . in ) ; sc . useDelimiter ( " \\A " ) ; while ( true ) { int w = sc . nextInt ( ) ; int h = sc . nextInt ( ) ; int wans = 0 ; int bans = 0 ; if ( w == 0 && h == 0 ) break ; a = new ArrayList < String > ( ) ; for ( ; w > 0 ; w -- , h -- ) { for ( ; j > 0 ; j -- ) { if ( a [ j ] [ i ] == ' . ' ) { wc = sc . nextInt ( ) ; if ( wc > 0 && bc == 0 ) wans += res ; else if ( wc == 0 && bc > 0 ) bans += res ; } } } System . out . println ( bans + " ▁ " + wans ) ; } }
public static void main ( String [ ] args ) { for ( int x = 0 ; x < Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ : ▁ " ) ) ; x ++ ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ : ▁ " ) ) ; if ( a > 59 && 360 % ( 180 - a ) == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public static final EulaLib compute ( ) { final int NUM_COLORS = 7 ; final int BALLS_PER_COLOR = 10 ; final int NUM_PICKED = 20 ; final int DECIMALS = 9 ; int [ ] numerator = new int [ NUM_COLORS ] ; final int remain = 0 ; final int limit = NUM_PICKED ; final int [ ] history = new int [ NUM_COLORS ] ; if ( remain == 0 ) { List < Integer > hist = Arrays . asList ( history ) ; while ( hist . size ( ) < NUM_COLORS ) hist . add ( 0 ) ; int [ ] histogram = new int [ BALLS_PER_COLOR + 1 ] ; for ( int x = 0 ; x < hist . size ( ) ; ++ x ) histogram [ x ] ++ ; int count = factorial ( NUM_COLORS ) ; for ( int x = 0 ; x < histogram . length ; ++ x ) count = divideExactly ( count , factorial ( histogram [ x ] ) ) ; for ( int x : hist ) count *= EulaLib . binomial ( BALLS_PER_COLOR , x ) ; int distinctColors = history . length ; numerator [ 0 ] += count * distinctColors ; } else if ( history . length < NUM_COLORS ) { for ( int i = Math . min ( limit , remain ) ; i > 0 ; -- i ) { history [ i ] = i ; explore ( remain - i , i , history ) ; history [ i ] = 0 ; } } explore ( NUM_PICKED , BALLS_PER_COLOR , new int [ NUM_COLORS ] ) ; int [ ] denominator = EulaLib . binomial ( NUM_COLORS * BALLS_PER_COLOR , NUM_PICKED ) ; BigInteger ans = new BigInteger ( numerator [ 0 ] , denominator ) ; return formatFraction ( ans , DECIMALS ) ; }
public static int f = 1 ; int n = map . get ( ) , s = map . get ( ) ; int h = map . get ( ) , m = map . get ( ) ; int h1 = h , m1 = m ; if ( h * 60 + m - s > 0 ) { System . out . println ( 0 ) ; f = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int g1 = h1 * 60 + m1 ; int g2 = h * 60 + m ; if ( g2 - g1 > 2 * s + 1 && f == 1 ) { System . out . println ( ( g1 + s + 1 ) / 60 + " ▁ " + ( g1 + s + 1 ) % 60 ) ; f = 0 ; } h1 = h ; m1 = m ; if ( i != n - 1 ) { h = map . get ( ) ; } } if ( f == 1 ) { int g1 = h1 * 60 + m1 ; System . out . println ( ( g1 + s + 1 ) / 60 + " ▁ " + ( g1 + s + 1 ) % 60 ) ; } return f ; }
public static int t ( ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ program " ) ) ; for ( ; ; ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ program " ) ) , 1 ; int b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ program " ) ) ; if ( b == 1 ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; System . out . println ( a + " ▁ times " ) ; System . out . println ( a * b + " ▁ times " ) ; System . out . println ( a * b + " ▁ times " ) ; } } }
public static int main ( String [ ] args ) { Scanner r = new Scanner ( System . in ) ; Scanner a = new Scanner ( System . in ) ; if ( r . hasNext ( ) ) break ; int h = 0 ; for ( int i = 0 , n = r . nextInt ( ) ; i < n ; i ++ ) { if ( r . next ( ) == a . next ( ) ) h ++ ; } int b = - h ; for ( int i = 0 ; i < r . nextInt ( ) ; i ++ ) { if ( r . next ( ) == a . next ( ) ) b ++ ; } System . out . println ( h + " ▁ " + b ) ; return h ; }
public static int findMaxValue ( int [ ] arr , int n ) { if ( n < 4 ) { System . out . println ( " The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements " ) ; return MIN ; } int [ ] table1 = new int [ n + 1 ] , table2 = new int [ n ] ; int [ ] table3 = new int [ n - 1 ] , table4 = new int [ n - 2 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; } for ( int i = n - 3 ; i >= 0 ; i -- ) { table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ; } for ( int i = n - 4 ; i >= 0 ; i -- ) { table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ; } return table4 [ 0 ] ; }
public static void centeredHexagonalSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( 3 * i * ( i - 1 ) + 1 + " ▁ " ) ; } if ( INSTANCE == null ) { n = 10 ; centeredHexagonalSeries ( n ) ; } }
public static void main ( String [ ] args ) { String target = System . in . readLine ( ) ; String [ ] listABC = { " A " , " B " , " C " } ; ArrayList < ArrayList < String > > old = new ArrayList < ArrayList < String > > ( ) ; ArrayList < ArrayList < String > > new = new ArrayList < ArrayList < String > > ( ) ; ArrayList < ArrayList < String > > check = new ArrayList < ArrayList < String > > ( ) ; boolean flag = false ; if ( " ABC " . equals ( target ) ) { old . add ( new ArrayList < String > ( ) ) ; } while ( old . size ( ) != 0 && flag == false ) { for ( Iterator < ArrayList < String > > i = old . iterator ( ) ; i . hasNext ( ) ; ) { if ( i . next ( ) . equals ( " ABC " ) ) { check . add ( i . next ( ) ) ; flag = true ; break ; } for ( int j = 0 ; j < listABC . length ; j ++ ) { String element = i . next ( ) . toString ( ) . replace ( " ABC " , listABC [ j ] ) ; if ( " ABC " . equals ( element ) ) { new ArrayList < String > ( ) . add ( element ) ; } } } } else { old = new ArrayList < ArrayList < String > > ( ) ; new ArrayList < ArrayList < String > > ( ) ; } flag = false ; for ( Iterator < ArrayList < String > > i : check ) { String abc = " ABC " ; ListIterator < ArrayList < String > > li = i . listIterator ( ) ; li . next ( ) ; for ( int j = 0 ; j < listABC . length ; j ++ ) { abc = abc . replace ( listABC [ j ] , " ABC " ) ; if ( abc . equals ( target ) ) { flag = true ; break ; } } } System . out . println ( " Yes " . equals ( flag ) ? " No " : " Yes " ) ; }
n , m = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { n [ i ] = Integer . parseInt ( input . readLine ( ) ) ; } List < String > lists = new ArrayList < > ( ) ; int sq = 0 ; int l = k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { lists . add ( input . readLine ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { sq = lists . get ( i ) . indexOf ( " B " ) ; if ( sq != - 1 ) { sq = ( sq + 1 ) / 2 ; l = i ; k = lists . get ( i ) . indexOf ( " B " ) ; break ; } } System . out . println ( l + sq + " ▁ " + k + sq ) ; }
public static void diagonalsMinMax ( int [ ] [ ] mat ) { int n = mat . length ; if ( ( n == 0 ) || ( n == 1 ) ) return ; int principalMin = mat [ 0 ] [ 0 ] ; int principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] ; int secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( ( i == j ) ) { if ( ( mat [ i ] [ j ] < principalMin ) ) principalMin = mat [ i ] [ j ] ; if ( ( mat [ i ] [ j ] > principalMax ) ) principalMax = mat [ i ] [ j ] ; } if ( ( ( i + j ) == ( n - 1 ) ) && ( mat [ i ] [ j ] < secondaryMin ) ) { if ( ( mat [ i ] [ j ] < secondaryMax ) ) secondaryMin = mat [ i ] [ j ] ; if ( ( mat [ i ] [ j ] > secondaryMax ) ) secondaryMax = mat [ i ] [ j ] ; } } } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) ; }
n = 5 ; public static void diagonalsMinMax ( int [ ] [ ] mat ) { if ( ( n == 0 ) || ( n == n - 1 ) ) return ; int principalMin = mat [ 0 ] [ 0 ] ; int principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] ; int secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( mat [ i ] [ i ] < principalMin ) && ( mat [ i ] [ i ] > principalMax ) ) principalMin = mat [ i ] [ i ] ; if ( ( mat [ i ] [ i ] > principalMax ) && ( mat [ i ] [ i ] < secondaryMin ) ) principalMax = mat [ n - 1 - i ] [ i ] ; if ( ( mat [ n - 1 - i ] [ i ] > secondaryMax ) && ( mat [ n - 1 - i ] [ i ] < secondaryMax ) ) secondaryMin = mat [ n - 1 - i ] [ i ] ; } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) ; }
public static int averageOdd ( int n ) { if ( ( n % 2 == 0 ) && ( n % 3 == 0 ) ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } int sm = 0 ; int count = 0 ; while ( ( n >= 1 ) && ( n > 0 ) ) { count = count + 1 ; sm = sm + n ; n = n - 2 ; } return sm / count ; }
public static int averageOdd ( int n ) { if ( ( n % 2 == 0 ) && ( n % 3 == 0 ) ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } return ( n + 1 ) / 2 ; }
public static boolean areElementsContiguous ( int [ ] arr ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i : arr ) { us . add ( i ) ; } int count = 1 ; int currEle = arr [ 0 ] - 1 ; while ( currEle < arr [ 0 ] ) { count ++ ; currEle -- ; } currEle = arr [ 0 ] + 1 ; while ( currEle < arr [ 0 ] ) { count ++ ; currEle ++ ; } return ( count == us . size ( ) ) ; }
public static final int [ ] performQueries ( int [ ] arr , int n , int [ ] queries , int q ) { final LinkedList < Integer > zero = new LinkedList < Integer > ( ) ; final LinkedList < Integer > one = new LinkedList < Integer > ( ) ; final int getLeftMostZero = 0 ; if ( ! zero . size ( ) ) { return new int [ ] { - 1 } ; } final int getLeftMostOne = 1 ; if ( ! one . size ( ) ) { return new int [ ] { - 1 } ; } final int getLeftMostElement = 0 ; if ( ! zero . size ( ) && ! one . size ( ) ) { return new int [ ] { - 1 } ; } else if ( ! zero . isEmpty ( ) ) { one . removeFirst ( ) ; return new int [ ] { 1 } ; } else if ( ! one . isEmpty ( ) ) { zero . removeFirst ( ) ; return new int [ ] { 0 } ; } int res = 0 < zero . size ( ) ? 1 : 0 ; if ( res == 0 ) { zero . removeFirst ( ) ; } else { one . removeFirst ( ) ; } return res ; } public void performQueries ( int [ ] arr , int n , int [ ] queries , int q ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { zero . add ( i ) ; } else { one . add ( i ) ; } } for ( int i = 0 ; i < q ; i ++ ) { int type = queries [ i ] ; if ( type == 1 ) { System . out . println ( getLeftMostZero ( ) ) ; } else if ( type == 2 ) { System . out . println ( getLeftMostOne ( ) ) ; } else if ( type == 3 ) { System . out . println ( getLeftMostElement ( ) ) ; } } } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " linux " ) ) { int arr [ ] = { 1 , 0 , 1 , 1 } ; int n = arr . length ; int queries [ ] = { 1 , 3 , 1 } ; int q = queries . length ; performQueries ( arr , n , queries , q ) ; } }
public static void Vertices ( int x , int y ) { int val = Math . abs ( x ) + Math . abs ( y ) ; ; if ( x < 0 ) x = - 1 ; else x = 1 ; System . out . print ( val * x + "0" + " ▁ " ) ; ; if ( y < 0 ) y = - 1 ; else y = 1 ; System . out . print ( "0" + val * y + " ▁ " ) ; ; }
public static void main ( String [ ] a , int n ) { int [ ] P = new int [ n ] ; P [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) P [ i ] = a [ i ] + P [ i - 1 ] ; int S = P [ n - 1 ] ; HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hash . put ( P [ i ] , 1 ) ; Set < Integer > res = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= Integer . MAX_VALUE ; i ++ ) { if ( ( S % i == 0 ) && ( hash . size ( ) == 0 ) ) { boolean pres = true ; ; int div1 = i ; int div2 = S / i ; for ( int j = div1 ; j <= S + 1 ; j += div1 ) { if ( j != 0 ) { pres = false ; break ; } } if ( ( pres && div1 != S ) || ( div1 == 0 ) ) res . add ( div1 ) ; pres = true ; for ( int j = S / i ; j <= S + 1 ; j += S / i ) { if ( j != 0 ) { pres = false ; break ; } } if ( ( pres && div2 != S ) || ( div2 == 0 ) ) res . add ( div2 ) ; } } if ( ( res . size ( ) == 0 ) && ( hash . size ( ) == 0 ) ) { System . out . println ( " - 1" ) ; return ; } for ( int i : res ) System . out . print ( i + " ▁ " ) ; }
public static void originalArray ( int [ ] greater , int n ) { int [ ] temp = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = i ; } int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = n - greater [ i ] - i ; arr [ i ] = temp [ k ] ; -- temp [ k ] ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } arr [ 6 ] = 3 ; arr [ 3 ] = 2 ; arr [ 1 ] = 0 ; arr [ 0 ] = 1 ; arr [ 2 ] = 0 ; arr [ 3 ] = 0 ; arr [ 4 ] = 0 ; arr [ 5 ] = 0 ; }
s ; int n = Integer . parseInt ( input ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] x = input ; int a = 0 , b = 0 ; for ( int j : s ) { if ( j == x [ 0 ] ) a ++ ; else if ( j == x [ 1 ] ) b ++ ; else { ans = ans + Math . min ( a , b ) ; a = 0 ; b = 0 ; } } ans = ans + Math . min ( a , b ) ; } System . out . println ( ans ) ; }
public static class Solution { public static int findRadius ( final int [ ] houses , final int [ ] heaters ) { Arrays . sort ( heaters ) ; int i = 0 ; int r = 0 ; for ( int x : Arrays . copyOf ( houses , houses . length ) ) { while ( x >= Arrays . binarySearch ( heaters , i , x ) / 2. ) i ++ ; r = Math . max ( r , Math . abs ( heaters [ i ] - x ) ) ; } return r ; } public static void main ( final String [ ] args ) { Solution sObj = new Solution ( ) ; int [ ] houses = { 1 , 2 , 3 } ; int [ ] heaters = { 2 } ; int out = sObj . findRadius ( houses , heaters ) ; System . out . println ( out ) ; } }
public static final < T > String compute ( ) { Predicate < Integer > cond = i -> ( i % 5 != 0 ) && ( ! EulaLib . isPrime ( i ) ) && ( ( i - 1 ) % findLeastDivisibleRepUnit ( i ) == 0 ) ; int ans = sum ( Iterables . filter ( Iterables . transform ( Lists . newArrayList ( i ) , new Function < Integer , Integer > ( ) { @ Override public Integer apply ( Integer i ) { return i % 2 == 0 ? i % 5 : i % 5 ; } } ) ) , 25 ) ) ; return String . valueOf ( ans ) ; } private int findLeastDivisibleRepUnit ( int n ) { if ( n % 2 == 0 || n % 5 == 0 ) return 0 ; int sum = 1 ; int pow = 1 ; int k = 1 ; while ( sum % n != 0 ) { k ++ ; pow = pow * 10 % n ; sum = ( sum + pow ) % n ; } return k ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) System . out . println ( compute ( ) ) ; } }
public static final int [ ] checkRecursive ( int num , int x , int k , int n ) { res = 0 ; if ( ( x == 0 ) && ( k == n ) ) res ++ ; int r = Math . floor ( Math . pow ( num , ( 1 / n ) ) ) ; ; for ( int i = k + 1 ; i <= r ; i ++ ) { int a = x - ( int ) Math . pow ( i , n ) ; if ( ( a >= 0 ) && ( a <= 1 ) ) checkRecursive ( num , x - ( int ) Math . pow ( i , n ) , i , n ) ; } return res ; }
public static int [ ] [ ] [ ] getS ( ) { int [ ] [ ] S = Arrays . stream ( input ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; int length = S . length - 1 ; for ( int bit = 0 ; bit < 2 * length ; bit ++ ) { int ans = S [ 0 ] [ bit ] ; char [ ] ope = bit & ( 2 * i ) ? ' + ' : ' - ' ; for ( int i = 1 ; i <= length ; i ++ ) { if ( ope [ i - 1 ] == ' + ' ) { ans += S [ i ] [ i ] ; } else { ans -= S [ i ] [ i ] ; } } if ( ans == 7 ) { System . out . println ( " { } { } { } { } { } { } } = 7" . format ( S [ 0 ] [ bit ] , ope [ 0 ] [ bit ] , S [ 1 ] [ bit ] , ope [ 1 ] [ bit ] , S [ 2 ] [ bit ] , ope [ 2 ] [ bit ] , S [ 3 ] [ bit ] ) ) ; break ; } return S ; }
public static int [ ] [ ] [ ] getNegativeInstances ( ) { int N = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; List < Pair < Integer , Integer > > ABs = new ArrayList < Pair < Integer , Integer > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) ABs . add ( Pair . of ( Integer . parseInt ( System . getProperty ( " line . separator " ) ) , Integer . parseInt ( System . getProperty ( " line . separator " ) ) + 1 ) ) ; int bSum = 0 ; for ( Pair < Integer , Integer > A : ABs ) bSum += A . second ; int [ ] [ ] [ ] dp = new int [ N + 1 ] [ ] [ ] ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 0 , n = ABs . size ( ) ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < bSum + 1 ; k ++ ) { if ( dp [ j ] [ k ] == - 1 ) continue ; int nk = Math . min ( bSum , k + 2 * A . second - B . second ) ; dp [ j + 1 ] [ nk ] = Math . max ( dp [ j + 1 ] [ nk ] , dp [ j ] [ k ] + B . second ) ; } } } int [ ] [ ] answer = new int [ N ] [ ] [ ] ; for ( int j = 1 ; j <= N ; j ++ ) { for ( int k = 0 ; k < bSum + 1 ; k ++ ) { if ( dp [ j ] [ k ] == - 1 ) continue ; answer [ j - 1 ] [ k ] = Math . max ( answer [ j - 1 ] [ k ] , dp [ j ] [ k ] + k ) ; } } System . out . println ( new int [ ] [ ] { answer } ) ; return answer ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number " ) ) ; if ( ( n < 10 ) || ( n > 100 ) ) { System . out . println ( n ) ; } else { int l = Integer . parseInt ( String . valueOf ( n ) ) - 1 ; int p = Integer . parseInt ( '9' * l ) ; int t = n - p ; int s = 0 ; while ( ( t > 0 ) && ( t % 10 == 0 ) ) { s += t % 10 ; t /= 10 ; } System . out . println ( s + 9 * l ) ; } return n ; }
public static boolean prime ( int n ) { for ( int i = 2 ; i <= n ; i ++ ) { if ( i * i > n + 1 ) break ; if ( ( n % i == 0 ) && ( i == 0 ) ) return false ; } return true ; }
public static int Squares ( int n , int m , int a ) { return ( ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ) ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ entered " ) ) ; i ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ entered " ) ) ; int m = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ entered " ) ) ; if ( n >= 6 && n % m == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public static int countCubes ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) { for ( int j = 0 ; j < i + 1 ; j ++ ) { if ( j * j * j > i ) break ; if ( j * j * j == i ) cnt ++ ; } } return cnt ; if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " windows " ) ) { a = 7 ; b = 30 ; System . out . println ( " Count ▁ of ▁ Cubes ▁ is ▁ " + countCubes ( a , b ) ) ; } return 0 ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ sort " ) ) ; List < Integer > aa = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ elements ▁ to ▁ sort " ) ) ; List < Integer > cs_a0 = new ArrayList < Integer > ( aa ) ; Collections . sort ( cs_a0 , new Comparator < Integer > ( ) { public int compare ( Integer i , Integer a ) { return i % 2 == 0 ? 1 : - 1 ; } } ) ; Collections . sort ( cs_a0 , new Comparator < Integer > ( ) { public int compare ( Integer i , Integer a ) { return i % 2 == 1 ? - 1 : 1 ; } } ) ; Collections . sort ( cs_a1 , new Comparator < Integer > ( ) { public int compare ( Integer i , Integer a ) { return i % 2 == 1 ? - 1 : 1 ; } } ) ; if ( cs_a0 . get ( 0 ) . intValue ( ) != cs_a1 . get ( 0 ) . intValue ( ) ) { System . out . println ( n - cs_a0 . get ( 0 ) . intValue ( ) - cs_a1 . get ( 0 ) . intValue ( ) ) ; } else { int res = 1 << 30 ; if ( cs_a0 . size ( ) == 1 && cs_a1 . size ( ) == 1 ) res = n / 2 ; if ( cs_a0 . size ( ) > 1 ) res = Math . min ( res , n - cs_a0 . get ( 1 ) . intValue ( ) - cs_a1 . get ( 0 ) . intValue ( ) ) ; if ( cs_a1 . size ( ) > 1 ) res = Math . min ( res , n - cs_a0 . get ( 0 ) . intValue ( ) - cs_a1 . get ( 1 ) . intValue ( ) ) ; System . out . println ( res ) ; } }
public static void subString ( String s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int len = i + 1 ; len <= n ; len ++ ) { System . out . println ( s . substring ( i , len ) ) ; ; } } s = " abcd " ; ; subString ( s , s . length ( ) ) ; ; }
public static boolean isPrime ( int n ) { if ( ( n <= 1 ) || ( n > n ) ) return false ; ; for ( int i = 2 ; i < n ; i ++ ) if ( ( n % i == 0 ) || ( n % i == 1 ) ) return false ; ; return true ; } public static void countPrimePosition ( int [ ] arr ) { int c0 = 0 ; int c1 = 0 ; ; n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] == 0 && isPrime ( i ) ) || ( arr [ i ] == 1 && isPrime ( i ) ) ) c0 ++ ; if ( ( arr [ i ] == 1 && isPrime ( i ) ) || ( arr [ i ] == 2 && isPrime ( i ) ) ) c1 ++ ; } System . out . println ( " Number ▁ of ▁ 0s ▁ = " + c0 ) ; ; System . out . println ( " Number ▁ of ▁ 1s ▁ = " + c1 ) ; ; } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " linux " ) ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 } ; countPrimePosition ( arr ) ; } }
public static void angleextcycquad ( double z ) { System . out . println ( " The ▁ exterior ▁ angle ▁ of ▁ the " + z + " ▁ cyclic ▁ quadrilateral ▁ is ▁ " + z + " ▁ degrees " ) ; ; }
public static void printMinIndexChar ( String Str , String patt ) { int minIndex = 10 * 9 ; int m = Str . length ( ) ; int n = patt . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( patt . charAt ( i ) == Str . charAt ( j ) && j < minIndex ) || ( patt . charAt ( i ) == Str . charAt ( j ) && j < minIndex ) ) { minIndex = j ; break ; } } } if ( ( minIndex != 10 * 9 ) && ( minIndex != 0 ) ) { System . out . println ( " Minimum ▁ Index ▁ Character ▁ = ▁ " + Str . charAt ( minIndex ) ) ; } else { System . out . println ( " No ▁ character ▁ present " ) ; } Str = " geeksforgeeks " ; patt = " set " ; printMinIndexChar ( Str , patt ) ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ check " ) ) ; for ( ; ; ) { int a = new Integer ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ check " ) ) . intValue ( ) ; int b = new Integer ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ check " ) ) . intValue ( ) ; if ( a != b ) { System . out . println ( " Happy ▁ Alex " ) ; break ; } } else { System . out . println ( " Poor ▁ Alex " ) ; } return n ; }
public static int maxnumber ( int n , int k ) { for ( int i = 0 ; i <= k ; i ++ ) { int ans = 0 ; i = 1 ; while ( n / i > 0 ) { int temp = ( n / ( i * 10 ) ) * i + ( n % i ) ; i *= 10 ; if ( temp > ans ) ans = temp ; } n = ans ; } ; return ans ; }
public static int N = map ( ) { int N = map ( ) . length ; int [ ] L = new int [ N * 2 ] ; for ( int i = 0 ; i < M ; i ++ ) { int a = map ( ) . charAt ( i ) , l = map ( ) . charAt ( i + 1 ) ; for ( int ll = a ; ll <= a + l ; ll ++ ) L [ ll ] = 1 ; } for ( int i = N ; i <= 2 * N ; i ++ ) L [ i - N ] = Math . max ( L [ i - N ] , L [ i ] ) ; int left = 0 ; int i = 0 ; while ( L [ i ] == 1 ) { left ++ ; i ++ ; if ( i == N ) { System . out . println ( N + " ▁ " ) ; System . exit ( ) ; } } int [ ] A = new int [ N ] ; int s = 0 ; for ( int i = i ; i < N ; i ++ ) { int li = L [ i ] ; if ( li == 0 ) { if ( s != 0 ) A [ s ] = i ; s = 0 ; } else s ++ ; } if ( s + left != 0 ) A [ s + left ] = i ; Arrays . sort ( A , 0 , s ) ; int v = A [ 0 ] ; int n = 0 ; for ( int a : A ) { if ( a == v ) { n ++ ; } else { System . out . println ( v + " ▁ " + n ) ; n = 1 ; v = a ; } } System . out . println ( v + " ▁ " + n ) ; return n ; }
public static int N ( ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] A = Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int cntA = 0 , sumA = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumA += A [ i ] ; if ( i % 2 == 0 ) { if ( sumA <= 0 ) { cntA += Math . abs ( sumA ) + 1 ; sumA += Math . abs ( sumA ) + 1 ; } } else { if ( sumA >= 0 ) { cntA += Math . abs ( sumA ) + 1 ; sumA -= Math . abs ( sumA ) + 1 ; } } } int cntB = 0 , sumB = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumB += A [ i ] ; if ( i % 2 != 0 ) { if ( sumB <= 0 ) { cntB += Math . abs ( sumB ) + 1 ; sumB += Math . abs ( sumB ) + 1 ; } } else { if ( sumB >= 0 ) { cntB += Math . abs ( sumB ) + 1 ; sumB -= Math . abs ( sumB ) + 1 ; } } } System . out . println ( Math . min ( cntA , cntB ) ) ; return cntA ; }
public static int getLastTwoDigit ( int N ) { if ( N <= 10 ) { int ans = 0 ; int fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } ans = ans % 100 ; return ans ; } else { return 13 ; } }
binaryNumber = "1001" ; int s = Integer . parseInt ( binaryNumber , 2 ) ; System . out . println ( s ) ; }
public static final boolean isPossible ( double x , double y , double z ) { double a = x * x + y * y + z * z ; a = Math . round ( a ) ; if ( ( Math . ceil ( a ) == 1 & Math . floor ( a ) == 1 ) && ( Math . floor ( a ) == 1 ) ) { return true ; } return false ; }
public static int MAX = 1000000 ; int MOD = 10 * 9 + 7 ; int result [ ] = new int [ MAX + 1 ] ; int fact [ ] = new int [ MAX + 1 ] ; public void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } public void performQueries ( int q [ ] , int n ) { preCompute ( ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . println ( result [ q [ i ] ] ) ; } int q [ ] = { 4 , 5 } ; int n = q . length ; performQueries ( q , n ) ; }
public static void main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ compared " ) ) ; int [ ] a = new int [ n ] ; Arrays . fill ( a , - 1 ) ; int sum = a [ n - 1 ] ; int neg = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int val = neg + i * ( a [ i ] - a [ i - 1 ] ) ; sum -= val ; neg = val ; } System . out . println ( sum ) ; } }
public static int segregate ( int [ ] arr , int size ) { int j = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] <= 0 ) && ( arr [ j ] > 0 ) ) { arr [ i ] = arr [ j ] ; j ++ ; } } return j ; }
public static int digitNumber ( int n ) { if ( ( n == 0 ) && ( n == 1 ) ) return 1 ; if ( ( n == 1 ) && ( n == 2 ) ) return 9 ; if ( ( n % 2 != 0 ) ) { int temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { int temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ print " ) ) ; i ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ print " ) ) ; int [ ] a = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ print " ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; if ( a [ 0 ] + a [ 1 ] > a [ a . length - 1 ] ) System . out . println ( - 1 ) ; else System . out . println ( 1 + 2 + n ) ; } }
public static void convert12 ( String str ) { int h1 = ( str . charAt ( 0 ) - '0' ) ; ; int h2 = ( str . charAt ( 1 ) - '0' ) ; ; int hh = h1 * 10 + h2 ; ; String Meridien = " " ; ; if ( ( hh < 12 ) && ( ( hh > 0 ) || ( hh < 10 ) ) ) Meridien = " AM " ; ; else Meridien = " PM " ; hh %= 12 ; ; if ( ( hh == 0 ) && ( ( hh > 0 ) || ( hh > 10 ) ) ) { System . out . print ( "12" ) ; ; for ( int i = 2 ; i < 8 ; i ++ ) System . out . print ( str . charAt ( i ) ) ; ; } else { System . out . print ( hh ) ; ; for ( int i = 2 ; i < 8 ; i ++ ) System . out . print ( str . charAt ( i ) ) ; ; } System . out . println ( " ▁ " + Meridien ) ; ; }
public static boolean check ( String s , int k ) { for ( int i = 0 ; i <= s . length ( ) ; i ++ ) { if ( ( s . charAt ( i ) != s . charAt ( i % k ) ) && ( s . charAt ( i ) != ' \0' ) ) { return false ; } } return true ; }
public static void printknapSack ( int W , int [ ] wt , int [ ] val , int n ) { int [ ] [ ] K = new int [ W + 1 ] [ n ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int w = 0 ; w < W + 1 ; w ++ ) { if ( i == 0 || w == 0 ) { K [ i ] [ w ] = 0 ; } else if ( wt [ i - 1 ] <= w ) { K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; } else { K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } } int res = K [ n ] [ W ] ; System . out . println ( res ) ; int w = W ; for ( int i = n ; i > 0 ; i -- ) { if ( res <= 0 ) break ; if ( res == K [ i - 1 ] [ w ] ) continue ; else { System . out . println ( wt [ i - 1 ] ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } val [ 0 ] = 60 ; val [ 1 ] = 100 ; val [ 2 ] = 120 ; wt [ 0 ] = 10 ; wt [ 1 ] = 20 ; wt [ 2 ] = 30 ; W = 50 ; n = val . length ; printknapSack ( W , wt , val , n ) ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) ; List < String > q = new ArrayList < > ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String a = JOptionPane . showInputDialog ( " Enter ▁ a ▁ string " ) . toString ( ) ; q . add ( a ) ; } for ( String j : q ) { for ( String k : q ) { if ( k . equals ( j ) ) continue ; else if ( j . charAt ( 0 ) == k . charAt ( k . length ( ) - 1 ) ) count ++ ; else continue ; } } System . out . println ( count ) ; return count ; }
public static void indexedSequentialSearch ( int [ ] arr , int n , int k ) { int [ ] elements = new int [ 20 ] ; int [ ] indices = new int [ 20 ] ; int j = 0 , ind = 0 ; for ( int i = 0 ; i < n ; i += 3 ) { elements [ ind ] = arr [ i ] ; indices [ ind ] = i ; ind ++ ; } if ( k < elements [ 0 ] ) { System . out . println ( " Not ▁ found " ) ; System . exit ( 0 ) ; } else { for ( int i = 1 ; i <= ind ; i ++ ) { if ( k < elements [ i ] ) { int start = indices [ i - 1 ] ; int end = indices [ i ] ; break ; } } } for ( int i = start ; i <= end ; i ++ ) { if ( k == arr [ i ] ) { j = 1 ; break ; } } if ( j == 1 ) { System . out . println ( " Found ▁ at ▁ index " + i ) ; } else { System . out . println ( " Not ▁ found " ) ; } }
public static int larrgestPalindrome ( int n ) { int upperLimit = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { upperLimit = upperLimit * 10 ; upperLimit = upperLimit + 9 ; } int lowerLimit = 1 + upperLimit / 10 ; int maxProduct = 0 ; for ( int i = upperLimit ; i >= lowerLimit ; i -- ) { for ( int j = i ; j >= lowerLimit ; j -- ) { int product = i * j ; if ( ( product < maxProduct ) && ( product > maxProduct ) ) break ; int number = product ; int reverse = 0 ; while ( ( number != 0 ) && ( number != 0 ) ) { reverse = reverse * 10 + number % 10 ; number = number / 10 ; } if ( ( product == reverse && product > maxProduct ) && ( product != 0 ) ) maxProduct = product ; } } return maxProduct ; }
public static int [ ] findList ( int n ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] array = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { array [ i ] = Integer . parseInt ( input ( ) ) ; } int [ ] dp = new int [ n ] ; dp [ 0 ] = array [ 0 ] ; for ( int num : array ) { if ( num > dp [ n - 1 ] ) { dp [ n - 1 ] = num ; } else { dp [ bisect ( dp , num ) ] = num ; } } System . out . println ( dp . length ) ; return dp ; }
t ; for ( ; ; ) { int a = Integer . parseInt ( input . nextLine ( ) ) , b = Integer . parseInt ( input . nextLine ( ) ) , c = Integer . parseInt ( input . nextLine ( ) ) ; int ans = 0 ; if ( a > 0 ) { a -- ; ans ++ ; } if ( b > 0 ) { b -- ; ans ++ ; } if ( c > 0 ) { c -- ; ans ++ ; } boolean cDown = false ; if ( c > 1 ) { if ( c > 0 && b > 0 ) { c -- ; b -- ; ans ++ ; cDown = true ; } } if ( a > 0 && b > 0 ) { a -- ; b -- ; ans ++ ; } if ( c > 0 && b > 0 && ! cDown ) { c -- ; b -- ; ans ++ ; } if ( a > 0 && c > 0 ) { a -- ; c -- ; ans ++ ; } if ( a > 0 && b > 0 && c > 0 ) { ans ++ ; } System . out . println ( String . valueOf ( Math . min ( 7 , ans ) ) ) ; } }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ nodes ▁ to ▁ display " ) ) ; int [ ] arr = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ array ▁ of ▁ nodes ▁ to ▁ display " ) . toArray ( ) ) . toArray ( ) ; int [ ] diff = new int [ n - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) diff [ i ] = abs ( arr [ i ] ) ; return max ( diff ) ; }
public static int maximumXor ( int [ ] arr , int n ) throws Exception { LinkedList < Integer > sForward = new LinkedList < Integer > ( ) , sBackward = new LinkedList < Integer > ( ) ; int ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { while ( sForward . size ( ) > 0 && arr [ i ] < arr [ sForward . size ( ) - 1 ] ) { ans = Math . max ( ans , arr [ i ] ^ arr [ sForward . size ( ) - 1 ] ) ; sForward . removeLast ( ) ; } sForward . add ( i ) ; while ( sBackward . size ( ) > 0 && arr [ n - i - 1 ] < arr [ sBackward . size ( ) - 1 ] ) { ans = Math . max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward . size ( ) - 1 ] ) ; sBackward . removeLast ( ) ; } sBackward . add ( n - i - 1 ) ; } return ans ; }
public static void decToHexa ( int n ) { hexaDeciNum = new char [ 100 ] ; hexaDeciNum [ 0 ] = '0' ; ; int i = 0 ; ; while ( ( n != 0 ) && ( i < 100 ) ) { int temp ; temp = n % 16 ; if ( ( temp < 10 ) ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i = i + 1 ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i = i + 1 ; } n = ( int ) ( n / 16 ) ; } int j = i - 1 ; while ( ( j >= 0 ) && ( j < 100 ) ) { System . out . print ( ( hexaDeciNum [ j ] ) + " ▁ " ) ; j = j - 1 ; } n = 2545 ; decToHexa ( n ) ; }
public static int N ( String input ) { int [ ] A = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] C = new int [ 10 * 5 ] ; for ( int ai : A ) C [ ai ] ++ ; int ans = 0 ; for ( int i = 0 ; i < 10 * 5 - 2 ; i ++ ) { ans = Math . max ( C [ i ] + C [ i + 1 ] + C [ i + 2 ] , ans ) ; } System . out . println ( ans ) ; return ans ; }
public static int main ( String [ ] args ) { int h = Integer . parseInt ( System . getProperty ( " user . home " ) ) , w = Integer . parseInt ( System . getProperty ( " user . name " ) ) ; if ( h == w == 0 ) break ; HashMap < Integer , ArrayList < Integer > > mp = new HashMap < Integer , ArrayList < Integer > > ( ) ; for ( int r = 0 ; r < h ; r ++ ) { Scanner s = new Scanner ( System . in ) ; for ( int c = 0 ; c < w ; c ++ ) { mp . put ( s . nextInt ( ) , new ArrayList < Integer > ( ) ) ; } } Scanner s = new Scanner ( System . in ) ; int now [ ] = { 0 , 0 } ; int ans = 0 ; for ( int i = 0 ; i < s . nextInt ( ) ; i ++ ) { ArrayList < Integer > to = mp . get ( s . nextInt ( ) ) ; ans += Math . abs ( now [ 0 ] - to [ 0 ] ) + Math . abs ( now [ 1 ] - to [ 1 ] ) + 1 ; now = to ; } System . out . println ( ans ) ; return 0 ; }
public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; if ( n == 1 ) { System . out . println ( " Hello ▁ World " ) ; } else { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( a + b ) ; } }
public static int extractMaximum ( String ss ) { int num = 0 , res = 0 ; for ( int i = 0 ; i < ss . length ( ) ; i ++ ) { if ( ss . charAt ( i ) >= '0' && ss . charAt ( i ) <= '9' ) { num = num * 10 + ( int ) ( Integer . parseInt ( ss . substring ( i ) ) - 0 ) ; } else { res = Math . max ( res , num ) ; num = 0 ; } } return Math . max ( res , num ) ; String ss = "100klh564abc365bg " ; System . out . println ( extractMaximum ( ss ) ) ; }
public static void findIndices ( int [ ] arr , int n ) { int [ ] sum = new int [ max ] ; for ( int i = 0 ; i < max ; i ++ ) sum [ i ] = 0 ; int k = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum [ i ] = sum [ i - 1 ] + arr [ k ] ; ; k ++ ; } int ans = - ( 1e15 ) ; int index_1 = index_2 = index_3 = - 1 ; for ( int l = 0 ; l < n + 1 ; l ++ ) { int index = 0 ; int vmin = ( 1e15 ) ; for ( int r = l ; r < n ; r ++ ) { if ( ( sum [ r ] < vmin ) && ( sum [ r ] > vmin ) ) { vmin = sum [ r ] ; index = r ; } if ( ( sum [ l ] + sum [ r ] - vmin > ans ) && ( sum [ l ] + sum [ r ] - vmin > ans ) ) { ans = sum [ l ] + sum [ r ] - vmin ; index_1 = l ; index_2 = index ; index_3 = r ; } } } System . out . println ( index_1 + " ▁ " + index_2 + " ▁ " + index_3 ) ; }
public static void printElements ( int [ ] arr , int n ) { for ( int i = 1 ; i < n - 1 ; i += 1 ) { if ( ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) || ( arr [ i ] > arr [ i + 1 ] && arr [ i ] > arr [ i + 1 ] ) ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } if ( System . getSecurityManager ( ) == null ) { arr = new int [ ] { 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 } ; n = arr . length ; printElements ( arr , n ) ; } }
public static int valueofX ( int [ ] ar , int n ) { int summ = sum ( ar ) ; if ( ( summ % n == 0 ) && ( n > 0 ) ) { return summ / n ; } else { int A = summ / n ; int B = summ / n + 1 ; int ValueA = 0 ; int ValueB = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ; ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) ; } if ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) || ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) && ( ( ValueA < ValueB ) )
public static int main ( String [ ] args ) { for ( ; ; ) { int x = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ x ▁ number ▁ ( 0-255 ) : ▁ " ) ) ; int y = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ y ▁ number ▁ ( 0-255 ) : ▁ " ) ) ; int z = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ z ▁ number ▁ ( 0-255 ) : ▁ " ) ) . mapToInt ( Integer :: parseInt ) . sum ( ) ; int a = 0 ; for ( int i = 0 ; i < y ; i ++ ) { int c = 0 ; for ( int j : z ) { if ( j & ( 1 << i ) ) c ++ ; } if ( c > ( x - c ) ) a += 1 << i ; } System . out . println ( a ) ; } }
s = Arrays . stream ( input ) . filter ( s :: length > 0 ) . collect ( Collectors . toList ( ) ) ; -- s . length ; for ( int i = 1 ; i < s . length ; i ++ ) { if ( s . length % 2 == 1 ) { -- s . length ; } else { if ( s . substring ( 0 , Integer . MAX_VALUE / 2 ) . equals ( s . substring ( Integer . MAX_VALUE / 2 ) ) ) { System . out . println ( s . length ) ; System . exit ( ) ; } else { -- s . length ; } } }
public static int findNth ( int n ) { int count = 0 ; ; int curr = 19 ; while ( ( true ) ) { int sum = 0 ; ; int x = curr ; while ( ( x > 0 ) ) { sum = sum + x % 10 ; x = ( int ) ( x / 10 ) ; } if ( ( sum == 10 ) && ( count == 10 ) ) { count ++ ; } if ( ( count == n ) && ( curr == 0 ) ) { return curr ; } curr += 9 ; } return - 1 ; }
public static int findNth ( int n ) { int count = 0 ; for ( int curr = 0 ; curr < n ; curr ++ ) { int sum = 0 ; int x = curr ; while ( ( x = curr ) != 0 ) { sum = sum + x % 10 ; x = x / 10 ; } if ( ( sum == 10 ) && ( count == 10 ) ) { count = count + 1 ; } if ( ( count == n ) && ( count == n ) ) { return curr ; } } return - 1 ; if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { System . out . println ( findNth ( 5 ) ) ; } return - 1 ; }
public static int countNumber ( int N , int S ) { int countElements = 0 ; ; int currentSum = 0 ; int currSum = 0 ; ; while ( ( currSum <= S ) ) { currSum += N ; ; N = N - 1 ; countElements = countElements + 1 ; } return countElements ; }
public static boolean strrmatch ( String strr , String pattern , int n , int m ) { if ( ( m == 0 ) && ( n == 0 ) ) return ( false ) ; boolean [ ] [ ] lookup = new boolean [ m + 1 ] [ n + 1 ] ; for ( int j = 0 ; j < n ; j ++ ) lookup [ j ] [ j ] = false ; lookup [ 0 ] [ 0 ] = true ; for ( int j = 1 ; j <= m ; j ++ ) if ( ( pattern . charAt ( j - 1 ) == ' * ' ) && ( pattern . charAt ( j - 1 ) == ' * ' ) ) lookup [ 0 ] [ j ] = lookup [ 0 ] [ j - 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) if ( ( pattern . charAt ( j - 1 ) == ' * ' ) && ( pattern . charAt ( j - 1 ) == ' * ' ) ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] || lookup [ i - 1 ] [ j ] ; else if ( ( pattern . charAt ( j - 1 ) == ' ? ' ) || strr . charAt ( i - 1 ) == pattern . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] ; else lookup [ i ] [ j ] = false ; return lookup [ n ] [ m ] ; }
public static void f ( int n ) { Set < Integer > a = new HashSet < > ( ) ; int i = 2 ; while ( i * i <= n ) { while ( n % i == 0 ) { a . add ( i ) ; n /= i ; } i ++ ; } if ( n > 1 ) { a . add ( n ) ; } return ; } while ( 1 ) { int a = Integer . parseInt ( System . in . readLine ( ) ) , b = Integer . parseInt ( System . in . readLine ( ) ) ; if ( ( a | b ) == 0 ) break ; a = f ( a ) ; b = f ( b ) ; System . out . println ( " a " . equals ( 2 * max ( a ) - sum ( a ) > 2 * max ( b ) - sum ( b ) ) ? " b " : " a " ) ; } }
public static double nCr ( int n , int r ) { List < Integer > fac = Lists . newArrayList ( ) ; fac . add ( 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) { fac . add ( fac . get ( i - 1 ) * i ) ; } double ans = fac . get ( n ) / ( fac . get ( n - r ) * fac . get ( r ) ) ; return ans ; }
public static int n ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] a = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int mx = Math . max ( a ) ; int hf = 0 ; for ( int x : a ) { if ( Math . abs ( mx - 2 * hf ) > Math . abs ( mx - 2 * x ) ) hf = x ; } System . out . println ( mx + " ▁ " + hf ) ; return mx ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) return b ; return gcd ( b % a , a ) ; }
public static int [ ] countingSort ( int [ ] A , int n ) { int k = Math . max ( A ) ; int [ ] B = new int [ n ] ; int [ ] C = new int [ k + 1 ] ; for ( int j = 0 ; j < n ; j ++ ) C [ A [ j ] ] ++ ; for ( int i = 1 ; i <= k ; i ++ ) C [ i ] = C [ i ] + C [ i - 1 ] ; for ( int j = n - 1 ; j >= 0 ; j -- ) { B [ C [ A [ j ] ] - 1 ] = A [ j ] ; C [ A [ j ] ] -- ; } return B ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; String s = input ( ) ; System . out . println ( Math . min ( n / 11 , s . contains ( "8" ) ) ) ; }
public static int sumOfDigit ( int n , int b ) { int unitDigit ; int sum = 0 ; while ( ( n > 0 ) && ( n % b == 0 ) ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; }
public static final void printLargestDivisible ( int n , int [ ] a ) { int c0 = 0 , c5 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) c0 ++ ; else c5 ++ ; } c5 = Math . floor ( c5 / 9 ) * 9 ; if ( c0 == 0 ) System . out . print ( - 1 + " ▁ " ) ; else if ( c5 == 0 ) System . out . print ( 0 + " ▁ " ) ; else { for ( int i = 0 ; i < c5 ; i ++ ) System . out . print ( 5 + " ▁ " ) ; for ( int i = 0 ; i < c0 ; i ++ ) System . out . print ( 0 + " ▁ " ) ; } if ( Main . isWindows ) { int [ ] a = { 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 0 , 5 , 5 } ; n = a . length ; printLargestDivisible ( n , a ) ; } }
public static int countWays ( int n ) { int counter = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { for ( int k = j ; k <= n ; k ++ ) { for ( int l = k ; l <= n ; l ++ ) { if ( ( i + j + k + l == n ) && ( i + j + k + l == n ) ) { counter ++ ; } } } } } return counter ; }
public static final int numberOfMinutes ( double S , double S1 ) { double Min ; Min = ( ( S - S1 ) / Math . floor ( S ) ) * 60 ; ; return ( int ) Min ; }
public static int fn ( int n , int m , int k , int [ ] L ) { int g = Math . min ( L ) ; L = new int [ L . length ] ; for ( int i = 0 ; i < L . length - 1 ; i ++ ) { L [ i ] = p - g ; } Arrays . sort ( L ) ; int dist = n ; for ( int gt = 0 ; gt < n - k ; gt ++ ) { dist += op [ gt ] ; } return ( dist ) ; }
static final long onesComplement ( long n ) { int numberOfBits = ( int ) ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) + 1 ; ; return ( ( 1L << numberOfBits ) - 1 ) ^ n ; }
t ; for ( int test = 0 ; test < t ; test ++ ) { int w = map . get ( input . nextLine ( ) ) ; int h = map . get ( input . nextLine ( ) ) ; int n = map . get ( input . nextLine ( ) ) ; int w_first = w ; int h_first = h ; if ( n == 1 ) { System . out . println ( " YES " ) ; } else if ( w % 2 == 1 && h % 2 == 1 ) { System . out . println ( " NO " ) ; } else { if ( w % 2 == 0 && h % 2 == 1 ) { int count = 0 ; while ( w % 2 == 0 ) { w /= 2 ; count ++ ; } if ( w == 1 ) { num = w_first ; } else { num = 2 * count ; } } else if ( h % 2 == 0 && w % 2 == 1 ) { int count = 0 ; while ( h % 2 == 0 ) { h /= 2 ; count ++ ; } if ( h == 1 ) { num = h_first ; } else { num = 2 * count ; } } else if ( h % 2 == 0 && w % 2 == 0 ) { int num = 0 ; int count = 0 ; while ( w % 2 == 0 ) { w /= 2 ; count ++ ; } if ( w == 1 ) { num1 = w_first ; } else { num1 = 2 * count ; } count = 0 ; while ( h % 2 == 0 ) { h /= 2 ; count ++ ; } if ( h == 1 ) { num2 = h_first ; } else { num2 = 2 * count ; } num = num1 * num2 ; } if ( num >= n ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public static void findPoint ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( " ( " + 2 * x2 - x1 + " , " + 2 * y2 - y1 + " ) " ) ; ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ used " ) ) ; n ++ ; for ( ; ; ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ used " ) ) , b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ used " ) ) ; System . out . println ( ( Math . min ( Math . min ( a , n - a ) , Math . min ( b , n - b ) ) - 1 ) % 3 + 1 ) ; } }
static final public void alter ( int x , int y ) { while ( ( true ) ) { if ( ( x == 0 || y == 0 ) && ( x >= 2 * y ) ) break ; if ( ( x >= 2 * y ) && ( y >= 2 * x ) ) x = x % ( 2 * y ) ; else if ( ( y >= 2 * x ) && ( x >= 2 * y ) ) y = y % ( 2 * x ) ; else break ; } System . out . println ( " X ▁ = " + x + " , ▁ " + " Y ▁ = " + y ) ; }
public static void main ( String [ ] args ) { int N = readInt ( ) ; int [ ] V = readInts ( ) ; System . out . println ( solve ( N , V ) ) ; }
public static void main ( String [ ] args ) { int num = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ number ▁ of ▁ characters ▁ to ▁ compare " ) ) ; for ( int i = 0 ; i < num ; i ++ ) { int lenz = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ text ▁ to ▁ compare " ) ) ; String text = JOptionPane . showInputDialog ( " Enter ▁ text ▁ to ▁ compare " ) ; boolean isExist = false ; for ( int j = 0 ; j < lenz - 1 ; j ++ ) { for ( int k = j + 1 ; k < lenz ; k ++ ) { int a = text . substring ( j , k + 1 ) . indexOf ( ' a ' ) ; int b = text . substring ( j , k + 1 ) . indexOf ( ' b ' ) ; if ( ( a == b ) && ( a != 0 ) ) { System . out . println ( MessageFormat . format ( " { j + 1 } ▁ { k + 1 } " , j + 1 , k + 1 ) ) ; isExist = true ; break ; } } if ( isExist ) break ; } if ( ! isExist ) System . out . println ( " - 1 ▁ - 1" ) ; } }
public static int findSum ( String L , String R ) { int mod = 1000000007 ; int inv2 = 500000004 ; ; final int modulo = Integer . parseInt ( L ) ; int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { res = ( res * 10 + Integer . parseInt ( num . substring ( i , i + 1 ) ) - 0 ) % mod ; ; } ; return res ; }
public static void unsort ( int l , int r , int [ ] a , int k ) { if ( ( k < 1 || l + 1 == r ) && ( l + 1 == r ) ) return ; k -= 2 ; int mid = ( l + r ) / 2 ; int temp = a [ mid - 1 ] ; a [ mid - 1 ] = a [ mid ] ; a [ mid ] = temp ; unsort ( l , mid , a , k ) ; unsort ( mid , r , a , k ) ; }
static double mean ( double [ ] mid , double [ ] freq , int n ) { double sum = 0 ; double freqSum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; }
public static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
public static int rectangleArea ( int a , int b ) { if ( a < 0 || b < 0 ) return - 1 ; return 2 * a * b ; }
public static int t ( ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ entered " ) ) ; while ( t > 0 ) { t -- ; int n = map . get ( JOptionPane . YES_OPTION ) ; int l = map . get ( JOptionPane . NO_OPTION ) ; int r = map . get ( JOptionPane . DEFAULT_OPTION ) ; int k = n / l ; if ( r * k >= n ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } return t ; }
public static int getsum ( int x ) { return ( int ) ( ( x * ( x + 1 ) ) / 2 ) ; } public static void countJumps ( int n ) { n = Math . abs ( n ) ; int ans = 0 ; while ( ( getsum ( ans ) < n || ( getsum ( ans ) - n ) & 1 ) != 0 ) { ans ++ ; } }
public static int MAX = 10 ; public static int lcs ( int [ ] [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) { if ( k < 0 ) return - ( 10 * 7 ) ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = Math . max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; return ans ; }
public static final void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; double d = scanner . nextDouble ( ) ; double x = scanner . nextDouble ( ) ; double ans = 0 ; for ( int i = 1 ; i <= Integer . MAX_VALUE ; i ++ ) { scanner . nextLine ( ) ; ans += ( Double . toString ( ( int ) n - Integer . MIN_VALUE + 1 ) ) . compareTo ( Double . toString ( i ) ) / ( d + x * Double . toString ( ( int ) n * 2 - 1 ) ) / Double . toString ( "2" ) ) ; } System . out . println ( ans ) ; }
public static void Reverseorder ( int n ) { boolean prime [ ] = new boolean [ ( n + 1 ) / 2 ] ; ; int p = 2 ; ; while ( ( p * p <= n ) && ( prime [ p ] == true ) ) { if ( ( prime [ p ] == true ) || ( prime [ p ] == false ) ) { for ( int i = ( p * 2 ) ; i < ( n + 1 ) ; i += p ) { prime [ i ] = false ; } } p ++ ; } ; for ( p = n ; p > 1 ; p -- ) { if ( ( prime [ p ] ) ) { System . out . print ( p + " ▁ " ) ; } } int N = 25 ; ; System . out . println ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) ; if ( ( N == 1 ) || ( N == 2 ) ) { System . out . println ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) ; } else { Reverseorder ( N ) ; } ; }
public static void pattern ( int minStars , int p_height ) { int p_space = p_height - 1 ; int x = 1 ; for ( int i = 0 ; i <= p_height ; i ++ ) { for ( int j = p_space ; j > i ; j -- ) System . out . print ( " ▁ " ) ; for ( int k = 0 ; k <= minStars ; k ++ ) System . out . print ( " * " ) ; for ( int n = ( p_height + p_height - 2 ) ; n > x ; n -- ) System . out . print ( " ▁ " ) ; for ( int k = 0 ; k <= minStars ; k ++ ) System . out . print ( " * " ) ; minStars = minStars + 2 ; x = x + 2 ; System . out . println ( " " ) ; } if ( Main . isMain ( ) ) { minStars = 1 ; p_height = 5 ; pattern ( minStars , p_height ) ; } }
public static void main ( String [ ] args ) { int visitorsCount = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ visitors ▁ count : ▁ " ) ) ; int minDay = 0 ; int maxDay = 366 ; List < String > users = new ArrayList < String > ( ) ; for ( int i = 0 ; i < visitorsCount ; i ++ ) users . add ( JOptionPane . showInputDialog ( " Enter ▁ user ▁ name : ▁ " ) ) ; minDay = Integer . parseInt ( users . get ( 0 ) . split ( " ▁ " ) [ 1 ] ) ; maxDay = Integer . parseInt ( users . get ( 0 ) . split ( " ▁ " ) [ 2 ] ) ; List < String > allUsers : new ArrayList < String > ( ) ; for ( int i = 0 ; i < users . size ( ) ; i ++ ) { String [ ] user = users . get ( i ) . split ( " ▁ " ) ; allUsers . add ( new String [ ] { user [ 0 ] , Integer . parseInt ( user [ 1 ] ) , Integer . parseInt ( user [ 2 ] ) } ) ; if ( minDay > Integer . parseInt ( user [ 1 ] ) ) minDay = Integer . parseInt ( user [ 1 ] ) ; if ( maxDay < Integer . parseInt ( user [ 2 ] ) ) maxDay = Integer . parseInt ( user [ 2 ] ) ; } Map < Integer , List < String > > mapCunts = new HashMap < Integer , List < String > > ( ) ; for ( int i = minDay ; i <= maxDay ; i ++ ) { for ( String user : allUsers ) { if ( i == user . indexOf ( ' M ' ) ) { mapCunts . computeIfAbsent ( i , k -> new ArrayList < String > ( ) ) . add ( user ) ; } } } int bestMatch = 0 ; for ( List < String > users : mapCunts . values ( ) ) { int malesLen = Integer . parseInt ( Arrays . stream ( users ) . filter ( user -> user . contains ( " M " ) ) . findFirst ( ) . orElse ( - 1 ) ) ; int malesLenX2 = malesLen * 2 ; int femalesLen = users . size ( ) - malesLen ; femalesLenX2 = femalesLen * 2 ; if ( ( malesLen > femal
public static int distancesum ( int [ ] x , int [ ] y , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; } } return sum ; }
static final int MAX = 1000000 ; static final int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; }
public static int fib ( int n ) { double phi = ( ( 1 + ( 5 * ( 1 / 2 ) ) ) / 2 ) ; ; return Math . round ( ( phi * n ) / ( 5 * ( 1 / 2 ) ) ) ; }
static final int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; }
m , n = map . size ( ) ; int [ ] k = Arrays . copyOf ( input , m ) ; for ( int i = 0 ; i < n ; i ++ ) { int a1 = input . charAt ( i ) ; int a2 = input . charAt ( i + 1 ) ; int c = input . charAt ( i + 2 ) ; int d = input . charAt ( i + 3 ) ; for ( int j = Integer . parseInt ( a1 ) - 1 ; j <= Integer . parseInt ( a2 ) ; j ++ ) { if ( k [ j ] == c ) k [ j ] = d ; } } System . out . println ( Arrays . toString ( k ) ) ; }
public static int compareStrings ( String str1 , String str2 ) { int i = 0 ; while ( i < str1 . length ( ) - 1 && str1 . charAt ( i ) == str2 . charAt ( i ) ) i ++ ; if ( str1 . charAt ( i ) > str2 . charAt ( i ) ) return - 1 ; return str1 . charAt ( i ) < str2 . charAt ( i ) ? - 1 : 1 ; } public static final int searchStr ( String [ ] arr , String string , int first , int last ) { if ( first > last ) return - 1 ; int mid = ( last + first ) / 2 ; if ( arr [ mid ] . length ( ) == 0 ) { int left = mid - 1 , right = mid + 1 ; while ( true ) { if ( left < first && right > last ) return - 1 ; if ( right <= last && arr [ right ] . length ( ) != 0 ) { mid = right ; break ; } if ( left >= first && arr [ left ] . length ( ) != 0 ) { mid = left ; break ; } right ++ ; left -- ; } } if ( compareStrings ( string , arr [ mid ] ) == 0 ) return mid ; if ( compareStrings ( string , arr [ mid ] ) < 0 ) return searchStr ( arr , string , mid + 1 , last ) ; return searchStr ( arr , string , first , mid - 1 ) ; } public static void main ( String [ ] args ) { String [ ] arr = { " for " , " " , " " , " " , " geeks " , " ide " , " " , " practice " , " " , " " , " quiz " , " " , " " } ; String string = " quiz " ; int n = arr . length ; System . out . println ( searchStr ( arr , string , 0 , n - 1 ) ) ; } }
public static int a ( ) { int a , b ; b = input . nextInt ( ) ; b = Integer . parseInt ( b . substring ( 0 , b . length ( ) - 1 ) ) ; print ( Integer . parseInt ( a ) + b ) ; }
public static int ax ( ) { int ax = map . get ( Integer . parseInt ( input . nextLine ( ) ) ) ; int ay = map . get ( Integer . parseInt ( input . nextLine ( ) ) ) ; int bx = map . get ( Integer . parseInt ( input . nextLine ( ) ) ) ; int by = map . get ( Integer . parseInt ( input . nextLine ( ) ) ) ; return 3 ; }
public static int solve ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ solve " ) ) ; String a = JOptionPane . showInputDialog ( " Enter ▁ the ▁ string ▁ to ▁ solve " ) ; String b = " " ; System . out . println ( Arrays . toString ( a ) ) ; return Arrays . binarySearch ( a , b ) ; }
static int sumAP ( int n , int d ) { n = ( int ) ( n / d ) ; ; return ( n ) * ( 1 + n ) * ( d / 2 ) ; }
public static void main ( String [ ] args ) { while ( true ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) ; if ( t == 0 ) break ; int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int s = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) ; int f = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) ; t -= f - s ; } if ( t < 1 ) System . out . println ( " OK " ) ; else System . out . println ( t ) ; } }
public static int fact ( int num ) { int fact = 1 ; ; while ( ( num > 1 ) && ( num != 0 ) ) { fact = fact * num ; num = num - 1 ; } ; return fact ; }
public static int get ( ) { return Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . sum ( ) ; }
public static int get ( ) { return Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . sum ( ) ; }
public static int countWays ( int n , int [ ] arr ) { int [ ] count = new int [ n + 1 ] ; count [ 0 ] = 1 ; if ( ( n == 0 ) || ( n == 1 ) ) return 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int noWays = 0 ; for ( int j : arr ) { if ( ( i - j >= 0 ) && ( j >= 0 ) ) noWays += count [ i - j ] ; count [ i ] = noWays ; } } return count [ n ] ; }
public static void main ( String [ ] args ) { int L = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) ; if ( L == 0 ) break ; int a = 0 ; int b = 0 ; int c = 0 ; for ( ; ; ) { a ++ ; int M = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) ; int N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) ; b += M - N ; if ( ! c && b >= L ) c = a ; } System . out . println ( c == 0 ? " NA " : c ) ; }
public static void main ( String [ ] args ) { for ( ; ; ) { int a , b , c ; a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ : ▁ " ) ) ; b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ b ▁ number ▁ : ▁ " ) ) ; c = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ c ▁ number ▁ : ▁ " ) ) ; a = Collections . singletonList ( a ) ; b = Collections . singletonList ( b ) ; c = Collections . singletonList ( c ) ; if ( c - a <= 2 ) System . out . println ( 0 ) ; else System . out . println ( 2 * ( c - a - 2 ) ) ; } }
n , b , d ) { List < Integer > a = Arrays . asList ( input . split ( " ▁ " ) ) ; int waste = 0 ; int num = 0 ; for ( int i : a ) { if ( i <= b ) waste += i ; if ( waste > d ) { num ++ ; waste = 0 ; } } System . out . println ( num ) ; }
public static int binarySearch ( int [ ] arr , int low , int high , int key ) { if ( ( high < low ) && ( key == arr [ ( int ) mid ] ) ) return mid ; if ( ( key > arr [ ( int ) mid ] ) ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) ; }
public static void equalsXorSum ( int [ ] arr , int n ) { int Sum = 0 ; ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( ( Sum == Xor ) && ( n > 0 ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } }
inl = new inl ( ) { public void f ( ) { List < Integer > list = Arrays . asList ( Integer . parseInt ( input ) ) ; int n = list . size ( ) ; int m = list . size ( ) ; int k = list . get ( 0 ) ; Set < Integer > h = new HashSet < > ( list ) ; int b = 1 ; if ( b != 0 ) { for ( ; ; ) { int u = list . get ( 0 ) ; int v = list . get ( 1 ) ; if ( b == u || b == v ) { b = u == v ? v : u ; if ( new Integer ( u ) & h . contains ( new Integer ( v ) ) ) break ; } } } System . out . println ( b ) ; } }
public static void findPairs ( int [ ] arr , int n ) { int cntEven = 0 ; ; int cntOdd = 0 ; ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 == 0 ) && ( arr [ i + 1 ] % 2 == 0 ) ) cntEven ++ ; else cntOdd ++ ; } int evenPairs = 0 ; ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; ; int oddPairs = 0 ; ; oddPairs += ( cntEven * cntOdd ) ; ; System . out . println ( " Odd ▁ pairs ▁ = ▁ " + oddPairs ) ; ; System . out . println ( " Even ▁ pairs ▁ = ▁ " + evenPairs ) ; ; }
public static int minBroadcastRange ( int [ ] houses , int [ ] towers , int n , int m ) { int leftTower = - Integer . MAX_VALUE - 1 ; int rightTower = towers [ 0 ] ; int j = 0 , k = 0 ; int minRange = 0 ; while ( ( j < n ) && ( j < m ) ) { if ( ( houses [ j ] < rightTower ) || ( houses [ j ] > rightTower ) ) { int left = houses [ j ] - leftTower ; int right = rightTower - houses [ j ] ; if ( left < right ) { int localMax = left ; if ( ( localMax > minRange ) && ( localMax < minRange ) ) { minRange = localMax ; } j ++ ; } else { leftTower = towers [ k ] ; if ( ( k < m - 1 ) && ( k < m ) ) { k ++ ; rightTower = towers [ k ] ; } else { rightTower = Integer . MAX_VALUE ; } } } return minRange ; } if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { int [ ] a = { 12 , 13 , 11 , 80 } ; int [ ] b = { 4 , 6 , 15 , 60 } ; n = a . length ; m = b . length ; int max = minBroadcastRange ( a , b , n , m ) ; System . out . println ( max ) ; } return minRange ; }
public static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
n , m , z ; n = Integer . parseInt ( input . nextLine ( ) ) ; m = Integer . parseInt ( input . nextLine ( ) ) ; z = Integer . parseInt ( input . nextLine ( ) ) ; n1 = n , m1 = m ; kill = 0 ; calls = new ArrayList < Call > ( ) ; artists = new ArrayList < Artist > ( ) ; for ( Call call : new ArrayList < Call > ( n , z + 1 , n ) ) calls . add ( call ) ; for ( Artist artist : new ArrayList < Artist > ( m , z + 1 , m ) ) artists . add ( artist ) ; System . out . println ( Arrays . toString ( Arrays . copyOf ( calls , calls . size ( ) ) ) ) ; }
public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; _allinput = new ArrayList ( ) ; for ( String inp : sc . nextLine ( ) . trim ( ) . split ( " ▁ " ) ) { _allinput . add ( inp . trim ( ) ) ; } private static final String _input = " " ; for ( String put : _allinput ) { ++ _allinput ; } Object _obj = _input ; ; }
n , wmax ) public static int [ ] [ ] [ ] [ ] [ ] getW ( ) { int [ ] [ ] [ ] U = new int [ n ] [ ] [ ] ; for ( int i = 0 ; i < n ; i ++ ) { int v = Integer . parseInt ( input ( ) . charAt ( i ) ) ; int w = Integer . parseInt ( input ( ) . charAt ( i + 1 ) ) ; int u = v / w ; U [ i ] [ 0 ] [ u ] = - u ; U [ i ] [ 1 ] [ u ] = v ; U [ i ] [ 2 ] [ u ] = w ; } Arrays . sort ( U ) ; int remains = wmax ; int i = 0 ; int ans = 0 ; while ( true ) { switch ( U [ i ] [ 2 ] ) { case 0 : if ( remains > U [ i ] [ 2 ] ) { remains -= U [ i ] [ 2 ] ; ans += U [ i ] [ 1 ] ; i ++ ; } else { ans += U [ i ] [ 1 ] * remains / U [ i ] [ 2 ] ; break ; } } } System . out . println ( ans ) ; return U ; }
public static int getSingle ( int [ ] arr , int n ) { int ones = 0 ; int twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; int commonBitMask = ~ ( ones & twos ) ; ones &= commonBitMask ; twos &= commonBitMask ; } return ones ; }
public static final int maxdiff ( int arr [ ] , int n ) { int freq [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ; else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ; } } return ans ; }
public static int [ ] [ ] main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ be ▁ compared " ) ) ; int m = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ be ▁ compared " ) ) ; int [ ] [ ] l = new int [ n ] [ m ] ; for ( int a = 0 ; a < n ; a ++ ) { int [ ] l1 = Arrays . copyOf ( l , m ) ; l [ a ] = l1 ; } int ans = 0 ; int [ ] m1 = new int [ m ] ; int count = 0 ; int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( l [ i ] [ j ] < 0 ) && ( l [ i ] [ j ] > 0 ) ) { count ++ ; mini = Math . min ( mini , - l [ i ] [ j ] ) ; ans += - l [ i ] [ j ] ; } else { mini = Math . min ( mini , Math . abs ( l [ i ] [ j ] ) ) ; ans += Math . abs ( l [ i ] [ j ] ) ; } } } if ( ( count % 2 == 0 ) && ( m1 [ 0 ] == 0 ) && ( m1 [ 1 ] == 0 ) && ( m1 [ 2 ] == 0 ) ) { System . out . println ( ans ) ; } else { System . out . println ( ans - 2 * mini ) ; } return m1 ; }
public static void makeAP ( int [ ] arr , int n ) { int initialTerm , commonDifference ; if ( ( n == 3 ) && ( arr [ 2 ] == arr [ 1 ] ) ) { commonDifference = arr [ 2 ] - arr [ 1 ] ; initialTerm = arr [ 1 ] - commonDifference ; } else if ( ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) && ( arr [ 1 ] == arr [ 0 ] ) ) { initialTerm = arr [ 0 ] ; commonDifference = arr [ 1 ] - arr [ 0 ] ; } else if ( ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) && ( arr [ 2 ] == arr [ 0 ] ) ) { commonDifference = arr [ 2 ] - arr [ 1 ] ; initialTerm = arr [ 1 ] - commonDifference ; } else { commonDifference = ( arr [ 3 ] - arr [ 0 ] ) / 3 ; initialTerm = arr [ 0 ] ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ( int ) ( initialTerm + ( i * commonDifference ) ) ) ; } System . out . println ( ) ; arr = new int [ ] { 1 , 3 , 7 } ; n = arr . length ; makeAP ( arr , n ) ; }
public static int countPairs ( int n ) { int count = 0 ; ; for ( int x = 1 ; x <= n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( ( y + x ) % ( y ^ x ) == 0 ) && ( ( y + x ) % ( y ^ x ) == 0 ) ) { count ++ ; } ; } } ; return count ; }
public static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y < n ; y ++ ) { if ( ( ( y * x ) % ( y + x ) == 0 ) && ( ( y * x ) % ( y + x ) == 0 ) ) { count ++ ; } } } return count ; }
public static class Solution { int longestPalindrome ( final String s ) { int ans = 0 ; final Map < Character , Integer > charMap = new HashMap < Character , Integer > ( ) ; for ( final char c : s . toCharArray ( ) ) { charMap . put ( c , charMap . get ( c ) + 1 ) ; } for ( final Character c : Arrays . asList ( charMap . keySet ( ) ) ) { if ( charMap . get ( c ) % 2 == 0 ) { ans += charMap . remove ( c ) ; } else { ans += charMap . get ( c ) / 2 * 2 ; } } if ( charMap . size ( ) != 0 ) { ans ++ ; } return ans ; } } if ( System . getProperty ( " os . arch " ) . contains ( " arm " ) ) { final Solution sObj = new Solution ( ) ; final String s = " abccccdd " ; final int out = sObj . longestPalindrome ( s ) ; System . out . println ( out ) ; } return null ; }
public static int binomialCoeff ( int n , int k ) { double res = 1 ; ; if ( ( k > n - k ) && ( k < n ) ) k = n - k ; for ( int i = 0 ; i < k ; i ++ ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return ( int ) res ; }
static final Comparator < Integer > VALUE_COMPARATOR = new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return Integer . compare ( o1 , o2 ) ; } private Integer [ ] values ( Integer o1 , Integer o2 ) { return o1 == o2 ? new Integer [ ] { o1 } : o1 . split ( " ▁ " ) ; } private Integer [ ] inlst ( Integer o1 ) { return o1 == o2 ? new Integer [ ] { o1 } : o1 . split ( " ▁ " ) ; } private Integer [ ] inlsts ( Integer o1 ) { return o1 == o2 ? new Integer [ ] { o1 } : o1 . split ( " ▁ " ) ; } private Integer [ ] inp ( Integer o1 ) { return o1 == o2 ? new Integer [ ] { o1 } : o1 . split ( " ▁ " ) ; } private Integer [ ] inps ( Integer o1 ) { return o1 == o2 ? new Integer [ ] { o1 } : o1 . split ( " ▁ " ) ; } private Integer [ ] instr ( Integer o1 ) { return o1 == o2 ? new Integer [ ] { o1 } : o1 . split ( " ▁ " ) ; } private Integer [ ] stlst ( Integer o1 ) { return o1 == o2 ? new Integer [ ] { o1 } : o1 . split ( " ▁ " ) ; } private boolean help ( int a , int b , String l ) { List < Integer > tot = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < b ; i ++ ) { tot . add ( l . substring ( i * a , i * a + a ) ) ; } for ( int i = 0 ; i < Arrays . asList ( tot . toArray ( new Integer [ 0 ] ) ) . size ( ) ; i ++ ) { if ( Arrays . asList ( tot . toArray ( new Integer [ 0 ] ) ) . contains ( i ) ) { s = 0 ; } else { s = 1 ; } } for ( int i = 1 ; i < 13 ; i ++ ) { if ( 12 % i == 0 ) { if ( help ( i , 12 / i , s ) ) { tot . add ( ( 12 / i ) + s ) ; } } } System . out . println ( tot . size ( ) + " ▁ " ) ; for ( int a = 0 ; a < tot . size ( ) ; a ++ ) { System . out . println
public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; ii = new Function < Integer , Integer > ( ) { public Integer apply ( Integer input ) { return Integer . parseInt ( input . toString ( ) ) ; } } ; mi = new Function < Integer , Integer > ( ) { public Integer apply ( Integer input ) { return map ( input . toString ( ) ) ; } } ; li = new Function < Integer , Integer > ( ) { public Integer apply ( Integer input ) { return Arrays . asList ( input . toString ( ) ) . stream ( ) . map ( Integer :: parseInt ) . collect ( Collectors . toList ( ) ) ; } } ; final int d = mi . apply ( ) . size ( ) ; int t = mi . apply ( ) . size ( ) ; int a = mi . apply ( ) . size ( ) ; int b = mi . apply ( ) . size ( ) ; int da = mi . apply ( ) . size ( ) ; int db = mi . apply ( ) . size ( ) ; final int n = mi . apply ( ) . size ( ) ; for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < t ; j ++ ) { if ( a - da * i + b - db * j == d || a - da * i == d || b - db * j == d || d == 0 ) { System . out . println ( " YES " ) ; return i ; } } } System . out . println ( " NO " ) ; }
public static boolean isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) { return false ; } else { return true ; } n = 10 ; if ( isSumOfPowersOfTwo ( n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return true ; }
public static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { Stack < Integer > s = new Stack < Integer > ( ) ; if ( ( i <= n ) && ( s . size ( ) != 0 ) ) { s . push ( i ) ; result ++ ; } while ( s . size ( ) != 0 ) { int tp = s . pop ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j < 10 ; j ++ ) { int x = tp * 10 + j ; if ( ( x <= n ) && ( s . size ( ) != 0 ) ) { s . push ( x ) ; result ++ ; } } } } return result ; }
public static int M = 100 ; public static int maxAverageOfPath ( int [ ] [ ] cost , int N ) { int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; for ( int j = 0 ; j < N ; j ++ ) dp [ j ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
public static int MAX = 1000000 ; int [ ] sieve_Prime = new int [ MAX + 4 ] ; int [ ] sieve_count = new int [ MAX + 4 ] ; private static void formSieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_count [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
public static int N ( ) { int ans = 0 ; int l = 0 ; int t = 0 ; int k = 0 ; for ( ; ; ) { if ( N == N ) { int d = L ; if ( d > 0 ) { int length = d - l ; l = d ; while ( t > 0 || k > 0 ) { if ( t > 0 ) { if ( t * V >= length ) { int tmp = ( t * V - length ) / V ; ans += t - tmp ; t = tmp ; if ( K > k ) k ++ ; else t = T ; length = 0 ; break ; } else { length = length - t * V ; ans += t ; t = 0 ; if ( k > 0 ) { k -- ; t = T ; } } } else if ( k > 0 ) { k -- ; t = T ; } } } if ( length > 0 ) { ans += length / U ; if ( K > k ) k ++ ; else t = T ; } } } System . out . println ( ans ) ; }
public static int waysToSplit ( String s ) { int n = s . length ( ) ; ; int answer = 0 ; ; int [ ] prefix = new int [ n ] ; ; int [ ] suffix = new int [ n ] ; ; int [ ] seen = new int [ 26 ] ; ; for ( int i = 0 ; i < n ; i ++ ) { int prev = prefix [ i - 1 ] == 0 ? 0 : 1 ; ; if ( ( seen [ Character . digit ( s . charAt ( i ) , 16 ) - Character . digit ( s . charAt ( i ) , 16 ) ] == 0 ) ) prefix [ i ] += ( prev + 1 ) ; ; else prefix [ i ] = prev ; ; seen [ Character . digit ( s . charAt ( i ) , 16 ) - Character . digit ( s . charAt ( i ) , 16 ) ] = 1 ; } ; seen = new int [ seen . length ] ; ; suffix [ n - 1 ] = 0 ; ; for ( int i = n - 1 ; i > 0 ; i -- ) { int prev = suffix [ i ] ; ; if ( ( seen [ Character . digit ( s . charAt ( i ) , 16 ) - Character . digit ( s . charAt ( i ) , 16 ) ] == 0 ) ) suffix [ i - 1 ] += ( prev + 1 ) ; ; else suffix [ i - 1 ] = prev ; ; seen [ Character . digit ( s . charAt ( i ) , 16 ) - Character . digit ( s . charAt ( i ) , 16 ) ] = 1 ; } ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( prefix [ i ] == suffix [ i ] ) && ( seen [ Character . digit ( s . charAt ( i ) , 16 ) - Character . digit ( s . charAt ( i ) , 16 ) ] == 0 ) ) answer ++ ; ; } return answer ; }
public static String compute ( ) { int TURNS = 15 ; int [ ] [ ] ways = new int [ TURNS ] [ ] ; ways [ 0 ] = new int [ 1 ] ; for ( int i = 1 ; i <= TURNS ; i ++ ) { int [ ] row = new int [ i + 1 ] ; for ( int j = 0 ; j < i + 1 ; j ++ ) { int temp = 0 ; if ( j < i ) temp = ways [ i - 1 ] [ j ] * i ; if ( j > 0 ) temp += ways [ i - 1 ] [ j - 1 ] ; row [ j ] = temp ; } ways [ i ] = row ; } int numer = Arrays . binarySearch ( ways , TURNS / 2 + 1 , TURNS / 2 ) ; int denom = Math . factorial ( TURNS + 1 ) ; return String . valueOf ( denom / numer ) ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ cards " ) ) ; int [ ] t = { 0 } ; int [ ] a = { 0 } ; int [ ] ans = new int [ n + 1 ] , cnt = new int [ n + 1 ] ; for ( int i = 0 ; i < a . length ; i ++ ) cnt [ i ] ++ ; for ( int i = 1 ; i <= n ; i ++ ) { if ( t [ i ] == 1 ) { int [ ] crt = new int [ i ] ; int x = a [ i ] ; while ( cnt [ x ] == 1 ) { crt [ x ] ++ ; x = a [ x ] ; } if ( crt . length > ans . length ) ans = crt ; } } ans = Arrays . copyOf ( ans , ans . length ) ; System . out . println ( ans . length ) ; System . out . println ( Arrays . toString ( ans ) ) ; return ans . length ; }
public static void merge ( int [ ] ar1 , int [ ] ar2 , int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int last = ar1 [ m - 1 ] ; int j = m - 2 ; while ( ( j >= 0 ) && ( ar1 [ j ] > ar2 [ i ] ) ) { ar1 [ j + 1 ] = ar1 [ j ] ; j -- ; } if ( ( j != m - 2 ) || last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } ar1 = new int [ ] { 1 , 5 , 9 , 10 , 15 , 20 } ; ar2 = new int [ ] { 2 , 3 , 8 , 13 } ; m = ar1 . length ; n = ar2 . length ; merge ( ar1 , ar2 , m , n ) ; System . out . println ( " After ▁ Merging ▁ \n First ▁ Array : ▁ " + ar1 ) ; System . out . println ( ar1 ) ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) return b ; return gcd ( b % a , a ) ; }
aa , b , c , d ; do { int [ ] ls = new int [ 2 ] , sum = 0 ; ls [ 0 ] = aa ; ls [ 1 ] = b ; ls [ 0 ] = c ; } while ( true ) ; }
public static int [ ] [ ] countWaysUtil ( int n , int parts , int nextPart ) { int [ ] [ ] dp = new int [ 501 ] [ 501 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { dp [ i ] = new int [ i ] ; } int n = 8 ; System . out . println ( countWays ( n ) ) ; return dp ; }
public static int findK ( int a , int b ) { if ( ( ( a + b ) % 2 == 0 ) && ( ( a + b ) / 2 == 0 ) ) return ( ( a + b ) / 2 ) ; ; return - 1 ; }
static public int getSum ( int x , int y , int z ) { int N = 101 ; ; int mod = ( int ) 1e9 + 7 ; int exactsum [ ] [ ] = new int [ N ] [ N ] ; ; int exactnum [ ] [ ] = new int [ N ] [ N ] ; ; static final int getSum = 1 ; int ans = 0 ; ; exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; ; for ( int i = 0 ; i < x + 1 ; i ++ ) { for ( int j = 0 ; j < y + 1 ; j ++ ) { for ( int k = 0 ; k < z + 1 ; k ++ ) { if ( ( i > 0 ) && ( j > 0 ) && ( k > 0 ) ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; ; exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; ; } if ( ( j > 0 ) && ( k > 0 ) && ( i > 0 ) && ( j - 1 > 0 ) ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; ; } if ( ( k > 0 ) && ( j > 0 ) && ( i > 0 ) && ( i - 1 > 0 ) ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 6 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; ; } ans += exactsum [ i ] [ j ] [ k ] % mod ; ; ans %= mod ; ; } } } return ans ; }
public static boolean isValidString ( String str ) { int [ ] freq = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ ( char ) str . charAt ( i ) - ' a ' ] ++ ; int freq1 = 0 ; int countFreq1 = 0 ; for ( int i = 0 ; i < CHARS ; i ++ ) { if ( ( freq [ i ] != 0 ) && ( freq [ i ] != - 1 ) ) { freq1 = freq [ i ] ; countFreq1 = 1 ; break ; } } int freq2 = 0 ; int countFreq2 = 0 ; for ( int j = i + 1 ; j < CHARS ; j ++ ) { if ( ( freq [ j ] != 0 ) && ( freq [ j ] == freq1 ) ) { countFreq1 ++ ; } else { countFreq2 = 1 ; freq2 = freq [ j ] ; break ; } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( ( freq [ k ] != 0 ) && ( freq [ k ] == freq1 ) ) { countFreq1 ++ ; } if ( ( freq [ k ] == freq2 ) && ( freq [ k ] == - 1 ) ) { countFreq2 ++ ; } else { return false ; } } if ( ( countFreq1 > 1 && countFreq2 > 1 ) && ( freq [ 0 ] == freq1 ) ) { return false ; } return true ; }
public static int t ( ) { int t = Integer . parseInt ( System . in ) ; while ( t > 0 ) { List < Character > s = Arrays . asList ( Character . valueOf ( ' a ' ) , Character . valueOf ( ' b ' ) , Character . valueOf ( ' c ' ) ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i % 2 == 0 ) { if ( s . get ( i ) == ' a ' ) s . set ( i , ' b ' ) ; else s . set ( i , ' a ' ) ; } else { if ( s . get ( i ) == ' z ' ) s . set ( i , ' y ' ) ; else s . set ( i , ' z ' ) ; } } System . out . println ( s . get ( 0 ) ) ; t -- ; } return t ; }
public static int findMinimumSubsequences ( String A , String B ) { int numberOfSubsequences = 1 ; int sizeOfB = B . length ( ) ; int sizeOfA = A . length ( ) ; int inf = 1000000 ; int [ ] [ ] next = new int [ 26 ] [ 26 ] ; for ( int i = 0 ; i < sizeOfB ; i ++ ) { next [ ( char ) B . charAt ( i ) - ' a ' ] [ i ] = i ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = sizeOfB - 2 ; j >= 0 ; j -- ) { if ( ( next [ i ] [ j ] == inf ) && ( next [ i ] [ j ] == inf ) ) { next [ i ] [ j ] = next [ i ] [ j + 1 ] ; } } } int pos = 0 ; int i = 0 ; while ( ( i < sizeOfA ) && ( i < sizeOfB ) ) { if ( ( pos == 0 ) && ( next [ ( char ) A . charAt ( i ) - ' a ' ] [ pos ] == inf ) ) { numberOfSubsequences = - 1 ; break ; } else if ( ( pos < sizeOfB ) && ( next [ ( char ) A . charAt ( i ) - ' a ' ] [ pos ] < inf ) ) { int nextIndex = next [ ( char ) A . charAt ( i ) - ' a ' ] [ pos ] + 1 ; pos = nextIndex ; i ++ ; } else { numberOfSubsequences ++ ; pos = 0 ; } } return numberOfSubsequences ; }
public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; for ( ; ; ) { int n = input . nextInt ( ) ; int m = input . nextInt ( ) ; int [ ] d = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { d [ i ] = Math . max ( i , n - 1 - i ) + Math . max ( j , m - 1 - j ) ; } } Arrays . sort ( d ) ; System . out . println ( Arrays . toString ( d ) ) ; } }
public static void FindRank ( int [ ] arr , int length ) { System . out . print ( 1 + " ▁ " ) ; for ( int i = 1 ; i < length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j <= i ; j ++ ) { if ( ( arr [ j ] > arr [ i ] ) && ( arr [ j ] > arr [ i ] ) ) { rank = rank + 1 ; } } System . out . print ( rank + " ▁ " ) ; } if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { arr = new int [ ] { 88 , 14 , 69 , 30 , 29 , 89 } ; length = arr . length ; FindRank ( arr , length ) ; } }
static void main ( String [ ] args ) { System . setSecurityManager ( new SecurityManager ( ) ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java . util . logging . Logger " ) . setLevel ( java . util . logging . Level . ALL ) ; java . util . logging . Logger . getLogger ( " java .
public static int firstkdigits ( int n , int k ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( ( product /= Math . pow ( 10 , k ) ) != 0 ) && ( product % 10 == 0 ) ) product = product / 10 ; return product ; }
public static int gcd ( int a , int b ) { int m = 0 ; try { while ( true ) { int a = input . nextInt ( ) ; int b = input . nextInt ( ) ; System . out . println ( Math . gcd ( ( int ) a , ( int ) b ) ) ; } } catch ( IOException e ) { int m = 0 ; } return m ; }
public static Map < String , Integer > dic ( ) { Map < String , Integer > dic = new HashMap < > ( ) ; List < String > S = Arrays . asList ( input ( ) ) ; for ( String s : S ) { if ( s != null ) { dic . put ( s , 1 ) ; } else { dic . put ( s , 1 ) ; } } int ans = 0 ; for ( String k : Arrays . asList ( dic . keySet ( ) ) ) { if ( dic . get ( k ) & 1 ) { ans ++ ; } } System . out . println ( ans > > 1 ) ; return dic ; }
public static final int complement ( int num ) { int i ; ; int len = 0 ; int comp ; int temp = num ; while ( ( 1 ) ) { len ++ ; num = ( int ) ( num / 10 ) ; if ( ( Math . abs ( num ) == 0 ) && ( Math . abs ( num ) > 0 ) ) break ; } num = temp ; comp = Math . pow ( 10 , len ) - num ; return ( int ) comp ; }
static int countUnsetBits ( int n ) { int x = n ; n |= n > > 1 ; n |= n > > 2 ; n |= n > > 4 ; n |= n > > 8 ; n |= n > > 16 ; double t = Math . log ( x ^ n ) ; return Math . floor ( t ) ; }
public static int minOperations ( int [ ] arr , int n ) { int result = 0 ; int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i <= n ; i ++ ) freq [ arr [ i ] ] ++ ; int maxi = Math . max ( arr ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j += i ) freq [ j ] = 0 ; result ++ ; } } return result ; }
public static int totalWays ( int N , int M , int X ) { int [ ] [ ] dp = new int [ 2 ] [ N + 1 ] ; for ( int j = 0 ; j < N ; j ++ ) { dp [ j ] [ 0 ] = j ; dp [ j ] [ 1 ] = j ; } if ( ( X == 1 ) && ( N == 1 ) ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 1 ] = 0 ; } if ( ( X == 1 ) && ( M == 1 ) ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; }
public static int getMinNum ( int a , int b , int c ) { if ( ( c < a || c > b ) && ( c > a ) ) return c ; int x = ( ( b / c ) * c ) + c ; return x ; }
public static int N ( ) { int N = Integer . parseInt ( System . in ) ; String S = System . in . readLine ( ) ; int x = 0 ; int maxNum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == ' I ' ) x ++ ; else x -- ; if ( x > maxNum ) maxNum = x ; } System . out . println ( maxNum ) ; }
public static final void protect ( int N , int M ) { ArrayList < ArrayList < Integer > > DP = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) DP . add ( Arrays . asList ( Integer . parseInt ( input . nextLine ( ) ) ) ) ; Collections . sort ( DP , new Comparator < ArrayList < Integer > > ( ) { @ Override public int compare ( ArrayList < Integer > o1 , ArrayList < Integer > o2 ) { int nokori = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( M > o1 . get ( N - i - 1 ) . intValue ( ) ) { M -= o1 . get ( N - i - 1 ) . intValue ( ) ; DP . remove ( i ) ; } else if ( M <= o1 . get ( N - i - 1 ) . intValue ( ) ) { nokori = ( o1 . get ( N - i - 1 ) . intValue ( ) - M ) * o1 . get ( N - i - 1 ) . intValue ( ) ; M = 0 ; DP . remove ( i ) ; break ; } } for ( int i = 0 ; i < DP . size ( ) ; i ++ ) nokori += o1 . get ( i ) . intValue ( ) * o2 . get ( i ) . intValue ( ) ; System . out . println ( nokori ) ; } } ) ; while ( true ) { String NM = input . nextLine ( ) ; N = Integer . parseInt ( NM ) ; M = Integer . parseInt ( NM ) ; if ( N == 0 ) break ; protect ( N , M ) ; } }
public static final int heapify ( int N , int [ ] A ) { int N = Integer . parseInt ( open ( 0 ) . readLine ( ) ) ; int [ ] L = A , C = A , R = A ; int [ ] F = new int [ N ] , B = new int [ 2 * N ] ; System . arraycopy ( L , 0 , B , 0 , N ) ; System . arraycopy ( C , 0 , B , N , 2 * N ) ; System . arraycopy ( R , 0 , B , N , 2 * N ) ; F = new int [ N ] ; System . arraycopy ( L , 0 , F , 0 , N ) ; System . arraycopy ( C , 0 , C , N , 2 * N ) ; F [ 0 ] = sum ( L ) ; System . arraycopy ( R , 0 , F , N , 2 * N ) ; for ( int c = 0 ; c < C . length ; c ++ ) F [ c ] = F [ c - 1 ] + c - heapify ( L , c ) ; R = new int [ N ] ; System . arraycopy ( R , 0 , F , 0 , N ) ; System . arraycopy ( C , 0 , F , N , 2 * N ) ; return max ( F , B ) ; }
public static int countWays ( int [ ] arr , int m , int N ) { int [ ] count = new int [ N + 1 ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( i >= arr [ j ] ) && ( i <= arr [ j + 1 ] ) ) { count [ i ] += count [ i - arr [ j ] ] ; } } } return count [ N ] ; }
public static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) { return 1 ; } else { return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) ; } }
public static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm . get ( a [ i ] ) ; if ( ( hm . get ( a [ i ] ) > 0 ) && ( cumul > 0 ) ) System . out . println ( a [ i ] + " - > " + cumul ) ; hm . put ( a [ i ] , 0 ) ; } a [ 0 ] = 1 ; a [ 1 ] = 3 ; a [ 2 ] = 2 ; a [ 3 ] = 4 ; a [ 4 ] = 2 ; a [ 5 ] = 1 ; a [ 6 ] = 1 ; a [ 7 ] = 1 ; a [ 8 ] = 1 ; a [ 9 ] = 1 ; a [ 10 ] = 1 ; a [ 11 ] = 1 ; a [ 12 ] = 1 ; a [ 13 ] = 1 ; a [ 14 ] = 1 ; a [ 15 ] = 1 ; a [ 16 ] = 1 ; a [ 17 ] = 1 ; a [ 18 ] = 1 ; a [ 19 ] = 1 ; a [ 20 ] = 1 ; a [ 21 ] = 1 ; a [ 22 ] = 1 ; a [ 23 ] = 1 ; a [ 24 ] = 1 ; a [ 25 ] = 1 ; a [ 26 ] = 1 ; a [ 27 ] = 1 ; a [ 28 ] = 1 ; a [ 29 ] = 1 ; a [ 30 ] = 1 ; a [ 31 ] = 1 ; a [ 32 ] = 1 ; a [ 33 ] = 1 ; a [ 34 ] = 1 ; a [ 35 ] = 1 ; a [ 36 ] = 1 ; a [ 37 ] = 1 ; a [ 38 ] = 1 ; a [ 39 ] = 1 ; a [ 40 ] = 1 ; a [ 41 ] = 1 ; a [ 42 ] = 1 ; a [ 43 ] = 1 ;
public static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; ; int possibleA = 0 ; ; int possibleB = 0 ; int possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ; ; if ( ( numbersInRange < 3 ) && ( numbersInRange > 3 ) ) { flag = false ; } else if ( ( numbersInRange > 3 ) && ( numbersInRange > 0 ) ) { flag = true ; if ( ( ( L % 2 ) > 0 ) && ( ( R % 2 ) > 0 ) ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ( ( L % 2 ) == 0 ) && ( ( R % 2 ) == 0 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( ( flag == true ) && ( ( L % 2 ) == 0 ) && ( ( R % 2 ) == 0 ) ) { System . out . println ( " ( " + possibleA + " , " + possibleB + " , " + possibleC + " ) ▁ is ▁ one ▁ such " + " possible ▁ triplet ▁ between " + L + " ▁ and " + R ) ; } else { System . out . println ( " No ▁ Such ▁ Triplet ▁ exists ▁ between " + L + " ▁ and " + R ) ; } }
public static String conversion ( String charSet , String str1 ) { String s2 = " " ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { s2 += alphabets . charAt ( charSet . indexOf ( str1 . charAt ( i ) ) ) ; } return s2 ; }
public static Set < Integer > generateNumber ( int count , int [ ] a , int n , int num , int k ) { if ( k == count ) { s . add ( num ) ; return s ; } for ( int i = 0 ; i <= n ; i ++ ) { generateNumber ( count + 1 , a , n , num + a [ i ] , k ) ; } final int [ ] printDistinctIntegers = { k , a , n } ; generateNumber ( 0 , a , n , 0 , k ) ; System . out . println ( " The " + s . size ( ) + " distinct ▁ integers ▁ are : " ) ; for ( int i : Arrays . asList ( s ) ) { System . out . print ( i + " ▁ " ) ; } return s ; }
public static int product ( int x ) { int prod = 1 ; while ( ( x != 0 ) && ( x != 1 ) ) { prod *= ( x % 10 ) ; x /= 10 ; ; } return prod ; } public static final int findNumber ( int l , int r ) { String a = Integer . toString ( l ) ; ; String b = Integer . toString ( r ) ; ; int ans = r ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) { if ( ( b . charAt ( i ) == '0' ) || ( b . charAt ( i ) == '1' ) ) continue ; List < Character > curr = Arrays . asList ( b . toCharArray ( ) ) ; curr . set ( i , Integer . toString ( ( ( Character . digit ( curr . get ( i ) , 10 ) - '0' ) - 1 ) + Character . digit ( '0' , 10 ) ) ) ; for ( int j = i + 1 ; j < curr . size ( ) ; j ++ ) curr . set ( j , Integer . toString ( ( char ) '9' , 10 ) ) ; int num = 0 ; for ( char c : curr ) num = num * 10 + ( ( int ) c - '0' ) ; if ( ( num >= l ) && ( product ( ans ) < product ( num ) ) ) ans = num ; } return ans ; } if ( Main . class . getName ( ) . equals ( " Main " ) ) { int l = 1 , r = 10 ; System . out . println ( findNumber ( l , r ) ) ; l = 51 , r = 62 ; System . out . println ( findNumber ( l , r ) ) ; } return 0 ; }
public static void isPrime ( int [ ] arr ) { isPrime [ 1 ] = false ; int i = 2 ; while ( i * i < 100005 ) { if ( ( isPrime [ i ] ) ) { int j = 2 * i ; while ( j < 100005 ) { isPrime [ j ] = false ; j += i ; } } i ++ ; } return ; }
MAX = 25 ; public static int getMinSum ( int [ ] arr , int n ) { int [ ] bitsCount = new int [ MAX ] ; bitsCount [ 0 ] = 0 ; int maxBit = 0 ; int sum = 0 ; int ans = 0 ; for ( int d = 0 ; d < n ; d ++ ) { int e = arr [ d ] ; int f = 0 ; while ( ( e > 0 ) && ( e % 2 == 1 ) ) { int rem = e % 2 ; e = e / 2 ; if ( ( rem == 1 ) || ( rem == 0 ) ) bitsCount [ f ] += rem ; f ++ ; } maxBit = Math . max ( maxBit , f ) ; } for ( int d = 0 ; d < maxBit ; d ++ ) { int temp = Math . pow ( 2 , d ) ; if ( ( bitsCount [ d ] > n / 2 ) && ( bitsCount [ d ] > n / 2 ) ) ans = ans + temp ; } for ( int d = 0 ; d < n ; d ++ ) { arr [ d ] = arr [ d ] ^ ans ; sum = sum + arr [ d ] ; } return sum ; } if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { int [ ] arr = { 3 , 5 , 7 , 11 , 15 } ; int n = arr . length ; System . out . println ( getMinSum ( arr , n ) ) ; } return 0 ; }
public static int n ( ) { int n = Integer . parseInt ( System . in ) ; String s = System . in . readLine ( ) ; a = new char [ s . length ( ) ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( a . charAt ( a . length ( ) - 1 ) == ' ' && c == ' ▁ ' ) continue ; a [ a . length ( ) - 1 ] += c ; ; if ( c == ' ? ' || c == ' ! ' || c == ' . ' ) a [ a . length ( ) - 1 ] = ' \0' ; } int ans = 0 ; int last = 0 ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { if ( a [ i ] . length ( ) > n ) { System . out . println ( " Impossible " ) ; System . exit ( 0 ) ; } int add = i + 1 != a . length ( ) ? a [ i ] . length ( ) : 0 ; if ( i == 0 || ( last + add ) > n ) { ans ++ ; last = a . length ( ) ; } else last += add ; } System . out . println ( ans ) ; return ans ; }
public static List < Integer > GetMinimumEnergySpent ( int n , int [ ] shortcuts ) { List < Integer > energySpent = new ArrayList < Integer > ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { energySpent . add ( i ) ; } Queue < Integer > queue = new LinkedList < Integer > ( energySpent ) ; while ( queue . size ( ) > 0 ) { int idx = queue . poll ( ) ; if ( idx < n - 1 && energySpent . get ( idx + 1 ) > energySpent . get ( idx ) + 1 ) { energySpent . set ( idx + 1 , energySpent . get ( idx ) + 1 ) ; queue . add ( idx + 1 ) ; } if ( idx > 0 && energySpent . get ( idx - 1 ) > energySpent . get ( idx ) + 1 ) { energySpent . set ( idx - 1 , energySpent . get ( idx ) + 1 ) ; queue . add ( idx - 1 ) ; } if ( energySpent . get ( idx ) + 1 < energySpent . get ( shortcuts [ idx ] ) ) { energySpent . set ( shortcuts [ idx ] , energySpent . get ( idx ) + 1 ) ; queue . add ( shortcuts [ idx ] ) ; } } return energySpent ; } if ( System . getProperty ( " user . home " ) . equals ( " / home " ) ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ shortcuts ▁ to ▁ be ▁ spent " ) ) ; int [ ] shortcuts = new int [ shortcuts . length ] ; for ( int k = 0 ; k < shortcuts . length ; k ++ ) { shortcuts [ k ] = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ shortcuts ▁ to ▁ be ▁ spent " ) ) ; } List < Integer > energySpent_str = new ArrayList < Integer > ( ) ; for ( int k = 0 ; k < shortcuts . length ; k ++ ) { energySpent_str . add ( Integer . parseInt ( shortcuts [ k ] ) ) ; } System . out . println ( energySpent_str ) ; return energySpent_str ; }
public static int strangeBDParty ( int n , int m , int [ ] k , int [ ] c ) throws Exception { Arrays . sort ( k ) ; int cost = l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( l < m && c [ l ] < c [ k [ i ] - 1 ] ) { cost += c [ l ] ; l ++ ; } else { cost += c [ k [ i ] - 1 ] ; } } return cost ; int rep = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ " + n + " ▁ " + m + " ▁ " + k [ 0 ] + " ▁ " + c [ 0 ] ) ) ; for ( ; rep > 0 ; rep -- ) { n = Arrays . stream ( k ) . mapToInt ( Integer :: parseInt ) . reduce ( 0 , 1 ) ; m = Arrays . stream ( m ) . mapToInt ( Integer :: parseInt ) . reduce ( 0 , 1 ) ; k = Arrays . stream ( k ) . mapToInt ( Integer :: parseInt ) . reduce ( 0 , 1 ) ; c = Arrays . stream ( c ) . mapToInt ( Integer :: parseInt ) . reduce ( 0 , 1 ) ; System . out . println ( strangeBDParty ( n , m , k , c ) ) ; } }
public static int findMaximumNum ( int [ ] arr , int n ) { int i = n ; while ( ( i >= 1 ) && ( i <= n ) ) { int count = 0 ; for ( int j = 0 ; j < n ; j += 1 ) { if ( ( i <= arr [ j ] ) && ( i <= arr [ j + 1 ] ) ) { count ++ ; } } if ( ( count >= i ) && ( count <= i ) ) { return i ; } i -- ; } return 1 ; }
s = new String [ ] { * input } ; for ( ; ; ) { String l = input . readLine ( ) . split ( " ▁ " ) ; int a = Integer . parseInt ( l . substring ( 1 ) ) ; int b = Integer . parseInt ( l . substring ( 2 ) ) + 1 ; if ( l . startsWith ( " print " ) ) { System . out . println ( new String ( s , a , b ) ) ; } else if ( l . startsWith ( " reverse " ) ) { s = new String ( s , a , b ) ; } else if ( l . startsWith ( " replace " ) ) { s = new String ( s , a , b ) ; } } }
public static int solve ( int [ ] A , int n ) { int [ ] [ ] dp = new int [ 2000 ] [ 2000 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = new int [ 2000 ] ; } int flag = 1 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += A [ i ] ; } for ( int i = - sum ; i <= sum ; i ++ ) { dp [ 0 ] [ i ] = 10 * 9 ; } dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = - sum ; j <= sum ; j ++ ) { dp [ flag ] [ j ] = 10 * 9 ; if ( ( j - A [ i - 1 ] <= sum && j - A [ i - 1 ] >= - sum ) || ( j + A [ i - 1 ] <= sum && j + A [ i - 1 ] >= - sum && dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] != 10 * 9 ) ) { dp [ flag ] [ j ] = Math . min ( dp [ flag ] [ j ] , dp [ flag ^ 1 ] [ j + A [ i - 1 ] ] + 1 ) ; } } flag = flag ^ 1 ; } for ( int i = 0 ; i < sum + 1 ; i ++ ) { if ( ( dp [ flag ^ 1 ] [ i ] != 10 * 9 ) && ( dp [ flag ^ 1 ] [ i ] != 0 ) ) { return dp [ flag ^ 1 ] [ i ] ; } } return n - 1 ; }
public static void getInput ( ) { while ( true ) { switch ( input . charAt ( 0 ) ) { case ' y ' : ++ input ; break ; case ' n ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' p ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; case ' r ' : ++ input ; break ; case ' s ' : ++ input ; break ; case ' t ' : ++ input ; break ; default : break ; } } N = Arrays . asList ( input ) ; for ( int l = 0 ; l < N . length ;
public static void fizzBuzz ( ) { int c = 1 ; while ( true ) { String res = " " ; if ( c % 3 == 0 ) res = res + " Fizz " ; if ( c % 5 == 0 ) res = res + " Buzz " ; if ( res . equals ( " " ) ) { ++ c ; } else { ++ c ; } c ++ ; } while ( true ) { int m = Integer . parseInt ( System . in . readLine ( ) ) ; int n = Integer . parseInt ( System . in . readLine ( ) ) ; if ( m == 0 ) break ; List < Integer > player = Arrays . asList ( m , n ) ; int p = 0 ; FizzBuzz fb = new FizzBuzz ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int inp = System . in . readLine ( ) ; if ( player . size ( ) > 1 ) { if ( inp != next ( fb ) ) { -- p ; p = p % player . size ( ) ; } else { p = ( p + 1 ) % player . size ( ) ; } } } String result = Integer . toString ( player . get ( 0 ) + 1 ) ; if ( player . size ( ) > 1 ) { for ( int pi = 1 ; pi < player . size ( ) ; pi ++ ) { result += " ▁ " + Integer . toString ( pi + 1 ) ; } } System . out . println ( result ) ; } }
l = new int [ 1001 ] [ 1001 ] ; for ( int j = 0 ; j < 1001 ; j ++ ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } }
a , b , c , d = map . get ( a ) ; System . out . println ( Math . max ( 0 , Math . min ( b , d ) - Math . max ( a , c ) ) ) ; }
public static void calculate ( int [ ] a , int [ ] b , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) { if ( ( b [ i ] != 0 ) && ( a [ i ] != 0 ) ) { mul = mul * b [ i ] ; } } for ( int i = 0 ; i < n ; i ++ ) { int x = Math . floor ( a [ i ] / mul ) ; System . out . print ( x + " ▁ " ) ; } a = new int [ ] { 5 , 100 , 8 } ; b = new int [ ] { 2 , 3 } ; n = a . length ; m = b . length ; calculate ( a , b , n , m ) ; }
public static int n ( String input ) { int a = sum ( Arrays . asList ( input . split ( " ▁ " ) ) ) ; int b = sum ( Arrays . asList ( ) ) ; int c = sum ( Arrays . asList ( ) ) ; return a - b ; }
public static final void main ( String [ ] args ) { final int n = Integer . parseInt ( args [ 0 ] ) ; final String s = args [ 1 ] ; int ans = 0 ; int left = 0 , right = 0 ; int i = 0 ; while ( i < n ) { final int n = Integer . parseInt ( args [ i ++ ] ) ; final String s = args [ i ++ ] ; ans = 0 ; left = 0 , right = 0 ; i = 0 ; while ( i < n && s . charAt ( i ) != ' > ' ) i ++ ; j = n - 1 ; while ( j >= 0 && s . charAt ( j ) != ' < ' ) j -- ; System . out . println ( Math . min ( i , n - j - 1 ) ) ; } }
static int log2 ( int n ) { int n = Integer . parseInt ( input ) ; int x = 1 ; while ( log2 ( n ) % 1 == 0 ) { x ++ ; n -= 2 * ( Integer . parseInt ( input ) ) ; } System . out . println ( x ) ; return x ; }
public static int p_speed ( ) { int p_speed = ( int ) input . nextInt ( ) ; int d_speed = ( int ) input . nextInt ( ) ; int time = ( int ) input . nextInt ( ) ; int wait = ( int ) input . nextInt ( ) ; int distence = ( int ) input . nextInt ( ) ; int position_p = time * p_speed ; int position_d ; int counter = 0 ; int time_counter ; while ( position_p < distence && d_speed > p_speed ) { time_d = position_p / ( d_speed - p_speed ) ; position_p += ( time_d * p_speed ) ; if ( position_p >= distence ) break ; int t_back = position_p / d_speed + wait ; position_p += ( t_back * p_speed ) ; counter ++ ; } System . out . println ( counter ) ; return time_counter ; }
public static String getTime ( String currentTime ) { String timeDuration = input . nextLine ( ) ; int currentTimeMin = Integer . parseInt ( currentTime . substring ( 0 , 2 ) ) * 60 + Integer . parseInt ( currentTime . substring ( 3 ) ) ; int timeDurationMin = Integer . parseInt ( timeDuration . substring ( 0 , 2 ) ) * 60 + Integer . parseInt ( timeDuration . substring ( 3 ) ) ; int tMin = currentTimeMin - timeDurationMin ; if ( currentTimeMin < timeDurationMin ) { tMin = 24 * 60 - Math . abs ( tMin ) ; } String hour = "0" + Integer . toString ( tMin / 60 ) . equals ( "0" ) ? "0" : Integer . toString ( tMin / 60 ) ; String minute = "0" + Integer . toString ( tMin % 60 ) . equals ( "0" ) ? "0" : Integer . toString ( tMin % 60 ) ; return MessageFormat . format ( " { hour } : { minute } " , hour , minute ) ; }
public static int longestAlternatingSubarray ( int [ ] a , int n ) { int longest = 1 ; int cnt = 1 ; int i = 1 ; while ( i < n ) { if ( ( a [ i ] * a [ i - 1 ] < 0 ) && ( a [ i ] * a [ i - 1 ] > 0 ) ) { cnt = cnt + 1 ; longest = Math . max ( longest , cnt ) ; } else { cnt = 1 ; } i = i + 1 ; } return longest ; }
public static void checkTypeOfTriangle ( int a , int b , int c ) { double sqa = Math . pow ( a , 2 ) ; double sqb = Math . pow ( b , 2 ) ; double sqc = Math . pow ( c , 2 ) ; if ( ( sqa == sqa + sqb || sqb == sqa + sqc || sqc == sqa + sqb ) && ( sqa > sqc + sqb || sqb > sqa + sqc || sqc > sqa + sqb ) ) { System . out . println ( " Right - angled ▁ Triangle " ) ; } else if ( ( sqa > sqc + sqb || sqb > sqa + sqc || sqc > sqa + sqb ) && ( sqa < sqc + sqb || sqc < sqa + sqc ) ) { System . out . println ( " Obtuse - angled ▁ Triangle " ) ; } else { System . out . println ( " Acute - angled ▁ Triangle " ) ; } }
public static void MAX ( String s , int n ) { int cntG = 0 ; int cntF = 0 ; int result = 0 ; int C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( s . charAt ( i ) == ' G ' ) || ( s . charAt ( i ) == ' F ' ) ) { cntG ++ ; result += C ; continue ; } if ( ( s . charAt ( i ) == ' F ' ) || ( s . charAt ( i ) == ' G ' ) ) { cntF ++ ; C += cntG ; continue ; } else continue ; } System . out . println ( result ) ; }
public static void main ( String [ ] args ) { N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ edges ▁ to ▁ go ▁ through " ) ) ; edges = new ArrayList < List < Integer > > ( ) ; for ( ; N > 0 ; N -- ) edges . add ( Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ edges ▁ to ▁ go ▁ through " ) ) ) ; for ( ; N > 0 ; N -- ) for ( ; N > 0 ; N -- ) { int cx = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ x ▁ coordinate ▁ of ▁ the ▁ first ▁ edge " ) ) ; for ( ; N > 0 ; N -- ) { int cy = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ y ▁ coordinate ▁ of ▁ the ▁ first ▁ edge " ) ) ; for ( ; N > 0 ; N -- ) { int x = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ x ▁ coordinate ▁ of ▁ the ▁ second ▁ edge " ) ) ; int y = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ y ▁ coordinate ▁ of ▁ the ▁ second ▁ edge " ) ) ; int h = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ h ▁ coordinate ▁ of ▁ the ▁ second ▁ edge " ) ) ; if ( h > 0 ) htop = Math . abs ( x - cx ) + Math . abs ( y - cy ) + h ; } for ( ; N > 0 ; N -- ) { int x = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ x ▁ coordinate ▁ of ▁ the ▁ third ▁ edge " ) ) ; int y = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ y ▁ coordinate ▁ of ▁ the ▁ third ▁ edge " ) ) ; if ( h == 0 ) { if ( htop - ( Math . abs ( x - cx ) + Math . abs ( y - cy ) ) > 0 ) break ; } if ( h > 0 ) { if ( htop - ( Math . abs ( x - cx ) + Math . abs ( y - cy ) ) != h ) break ; } } else { System . out . println ( cx + " ▁ " + cy + " ▁ " + htop ) ; exit ( ) ;
from ▁ math ▁ functions . STRNEWLINE ▁ */ public static int countSteps ( int n ) { int steps = 0 ; while ( ( n > 0 ) && ( n <= 1 ) ) { int largest = Math . floor ( n * ( 1 / 3 ) ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; }
public static void main ( String [ ] args ) throws Exception { final Scanner sc = new Scanner ( System . in ) ; final Operator < Integer > input = sc . next ( ) ; final List < Integer > data = new ArrayList < > ( ) ; data . forEach ( data :: add ) ; final List < Integer > top2 = data . subList ( 0 , 2 ) ; final List < Integer > others = data . subList ( 2 , data . size ( ) ) ; new Thread ( ) { @ Override public void run ( ) { List < Pair < Integer , Double > > othersResults = new ArrayList < > ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { List < Pair < Integer , Double > > roundResults = new ArrayList < > ( ) ; for ( int j = 0 ; j < 8 ; j ++ ) { final int id = sc . nextInt ( ) ; final double time = sc . nextDouble ( ) ; roundResults . add ( new Pair < > ( Integer . parseInt ( id ) , Double . parseDouble ( time ) ) ) ; } top2 = solve ( roundResults ) ; othersResults . addAll ( others ) ; for ( int id : top2 ) { System . out . println ( " { } ▁ { } " . format ( id , time ) ) ; } } } . start ( ) ; } } . start ( ) ; if ( sc . hasNext ( ) ) { sc . close ( ) ; } }
public static int n ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] a = new int [ Arrays . asList ( input . split ( " ▁ " ) ) . stream ( ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; if ( ( a [ 0 ] == a [ a . length - 1 ] ) && ( a [ a . length - 1 ] == a [ a . length - 2 ] ) ) { int x = a . length * ( a . length - 1 ) / 2 ; return a [ a . length - 1 ] - a [ 0 ] ; } else { return - 1 ; } }
public static int bitsonCount ( int x ) { return bin ( x ) . contains ( "1" ) ? 1 : 0 ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ counted " ) ) ; int [ ] a = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ numbers ▁ to ▁ be ▁ counted " ) ) . toArray ( ) ; int s = sum ( a ) ; if ( s % ( ( n + 1 ) * n / 2 ) != 0 ) { System . out . println ( " NO " ) ; return ; } s /= ( ( n + 1 ) * n / 2 ) ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] -= s ; } for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] > 0 || b [ i ] % n != 0 ) { System . out . println ( " NO " ) ; return ; } } System . out . println ( " YES " ) ; }
public static int maxProd ( int N ) { if ( ( N == 0 ) || ( N < 10 ) ) return 1 ; return Math . max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display " ) ) ; int [ ] s = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display " ) . split ( " ▁ " ) ) . toArray ( ) ; int max = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == 1 ) { int count = 2 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] == 1 ) { count ++ ; continue ; } else break ; } if ( count > max ) max = count ; } } System . out . println ( max ) ; return max ; }
public static final int main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; for ( int tt = 0 ; tt < Integer . parseInt ( input . nextLine ( ) ) ; tt ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] A = new int [ 2 * n ] , B = new int [ n ] ; for ( int i = 0 ; i < 2 * n ; i ++ ) { int x = Integer . parseInt ( input . nextLine ( ) ) , y = Integer . parseInt ( input . nextLine ( ) ) ; if ( x == 0 ) B [ i ] = Math . abs ( y ) ; else A [ i ] = Math . abs ( x ) ; } A = Arrays . copyOf ( A , n ) ; B = Arrays . copyOf ( B , n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += ( ( B [ i ] ) * ( B [ i ] ) + ( A [ i ] ) * ( A [ i ] ) ) * ( 0.5 ) ; System . out . println ( ans ) ; } return 0 ; }
public static int countNonDecreasing ( int n ) { int N = 10 ; int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count = ( int ) ( count * ( N + i - 1 ) ) ; count = ( int ) ( count / i ) ; } return count ; }
public static int reduceString ( String s , int l ) { int count = 1 ; ; int steps = 0 ; for ( int i = 1 ; i < l ; i ++ ) { if ( ( s . charAt ( i ) == s . charAt ( i - 1 ) ) ) { count ++ ; } else { steps += ( int ) ( count / 2 ) ; count = 1 ; } } steps += ( int ) ( count / 2 ) ; return steps ; }
public static int A , B ; int A , B ; A = Integer . parseInt ( System . getProperty ( " user . dir " ) ) ; B = Integer . parseInt ( System . getProperty ( " user . dir " ) ) ; if ( A <= B ) { System . out . println ( " Impossible " ) ; System . exit ( 0 ) ; } stack . clear ( ) ; int N = A + B ; final boolean ask = true ; for ( int i = 0 ; i <= N ; i ++ ) { if ( chain . size ( ) == 0 ) { chain . add ( i ) ; continue ; } int last = chain . get ( chain . size ( ) - 1 ) ; if ( ask ) { chain . add ( i ) ; } else { chain . remove ( 0 ) ; } } int main = chain . size ( ) ; int [ ] ret = new int [ N ] ; for ( int x = 0 ; x <= N ; x ++ ) { ret [ x ] = ( "1" . equals ( main ) ? x : "0" ) ; } System . out . println ( " ! ▁ " + Arrays . toString ( ret ) ) ; return ret [ N ] ; }
x , y , a , b ) { int i = Integer . parseInt ( input ) ; int [ ] c = new int [ a ] ; for ( int i = a ; i <= x ; i ++ ) c [ i ] = i ; for ( int j = b ; j <= y ; j ++ ) c [ j ] = j ; print ( c . length ) ; ; print ( * c ) ; }
public static final int [ ] calculateFactors ( int a , int b ) { final int mod = 1000000007 ; final int mult = ( ( a % mod ) * ( b % mod ) ) % mod ; final int n = a % mod ; int cnt = 0 ; int ans = 1 ; while ( ( n % 2 == 0 ) && ( cnt < mod ) ) { cnt ++ ; n = n / 2 ; } if ( ( cnt > 0 ) && ( ans > 0 ) ) ans = mult ( ans , ( cnt + 1 ) ) ; for ( int i = 3 ; i < Integer . MAX_VALUE ; i += 2 ) { cnt = 0 ; while ( ( n % i == 0 ) && ( cnt < mod ) ) { cnt ++ ; n = n / i ; } if ( ( cnt > 0 ) && ( ans > 0 ) ) ans = mult ( ans , ( cnt + 1 ) ) ; } if ( ( n > 2 ) && ( ans > 0 ) ) ans = mult ( ans , 2 ) ; return new int [ ] { ans % mod , mod } ; }
public static String s ( ) { Scanner s = new Scanner ( System . in ) ; String result = " " ; int i = 0 ; while ( i < s . nextInt ( ) ) { if ( s . charAt ( i ) == ' . ' ) result += '0' ; else { i ++ ; if ( s . charAt ( i ) == ' . ' ) result += '1' ; else result += '2' ; } i ++ ; } System . out . println ( result ) ; }
public static int maxAbsDiff ( int [ ] arr , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
public static final void main ( String [ ] args ) { final int BIG_NUM = 2000000000 ; final int HUGE_NUM = 99999999999999999 ; final int MOD = 1000000007 ; final double EPS = 0.000000001 ; System . setSecurityManager ( new SecurityManager ( ) ) ; final Class < ? > type = Class . forName ( " java . util . concurrent . atomic . AtomicInteger " ) ; final int [ ] work = new int [ BIG_NUM ] ; work [ 0 ] = 0 ; work [ 1 ] = 0 ; work [ 2 ] = 0 ; work [ 3 ] = 0 ; work [ 4 ] = 0 ; work [ 5 ] = 0 ; work [ 6 ] = 0 ; work [ 7 ] = 0 ; work [ 8 ] = 0 ; work [ 9 ] = 0 ; work [ 10 ] = 0 ; work [ 11 ] = 0 ; work [ 12 ] = 0 ; work [ 13 ] = 0 ; work [ 14 ] = 0 ; work [ 15 ] = 0 ; work [ 16 ] = 0 ; work [ 17 ] = 0 ; work [ 18 ] = 0 ; work [ 19 ] = 0 ; work [ 20 ] = 0 ; work [ 21 ] = 0 ; work [ 22 ] = 0 ; work [ 23 ] = 0 ; work [ 24 ] = 0 ; work [ 25 ] = 0 ; work [ 26 ] = 0 ; work [ 27 ] = 0 ; work [ 28 ] = 0 ; work [ 29 ] = 0 ; work [ 30 ] = 0 ; work [ 31 ] = 0 ; work [ 32 ] = 0 ; work [ 33 ] = 0 ; work [ 34 ] = 0 ; work [ 35 ] = 0 ; work [ 36 ] = 0 ; work [ 37 ] = 0 ; work [ 38 ] = 0 ; work [ 39 ] = 0 ; work [ 40 ] = 0 ; work [ 41 ] = 0 ; work [ 42 ] = 0 ; work [ 43 ] = 0 ; work [ 44 ] = 0 ; work [ 45 ] = 0 ; work [ 46 ] = 0 ; work [ 47 ] = 0 ; work [ 48 ] = 0 ; work [ 49 ] = 0 ; work [ 50 ] = 0 ; work [ 51 ] = 0 ; work [ 52 ] = 0 ; work [ 53 ] = 0 ; work [ 54 ] = 0 ; work [ 55 ] = 0 ; work [ 56 ] = 0 ; work [ 57 ] = 0 ; work [ 58 ] = 0 ; }
public static int minRemove ( int [ ] a , int [ ] b , int n , int m ) { Map < Integer , Integer > countA = Maps . newHashMapWithExpectedSize ( n ) ; Map < Integer , Integer > countB = Maps . newHashMapWithExpectedSize ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { countA . put ( a [ i ] , countA . get ( a [ i ] ) + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { countB . put ( b [ i ] , countB . get ( b [ i ] ) + 1 ) ; } int res = 0 ; for ( int x : countA . keySet ( ) ) { if ( countB . get ( x ) == countA . get ( x ) ) { res += Math . min ( countA . get ( x ) , countB . get ( x ) ) ; } } return res ; }
public static int count ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( i < 10 ) && ( i > 0 ) ) { cnt ++ ; } else { int n = i % 10 ; int k = i ; while ( ( k >= 10 ) && ( k < n ) ) { k = k / 10 ; } if ( ( n == k ) && ( n > k ) ) { cnt ++ ; } } } return ( cnt ) ; }
public static int number ( ) { int number = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] arr = Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int counter = 0 ; data = new data ( ) ; data . found = " NO " ; data . first = 0 ; for ( int i = 0 ; i <= number ; i ++ ) { int x = Integer . parseInt ( arr [ i ] ) ; if ( x == 1 ) { if ( counter == 0 ) counter = 1 ; if ( data . found == " yes " ) { int y = i - data . first ; counter = counter * y ; data . first = i ; } else { data . found = " yes " ; data . first = i ; } } } System . out . println ( counter ) ; return counter ; }
static final int bit ( int x ) { int ans = 0 ; while ( ( x ) > 0 ) { x /= 2 ; ans = ans + 1 ; } return ans ; } public static boolean check ( int d , int x ) { if ( ( bit ( x / d ) <= bit ( d ) ) && ( x % d == 0 ) ) return true ; return false ; } ; static final int bs = 1 ; int l = 1 ; int r = ( int ) Math . sqrt ( n ) ; while ( ( l < r ) && ( l < r ) ) { int m = ( int ) ( ( l + r ) / 2 ) ; if ( ( check ( m , n ) ) && ( check ( m , n ) ) ) r = m ; else l = m + 1 ; } if ( ( check ( l , n ) == false ) && ( check ( r , n ) ) ) return Math . floor ( l + 1 ) ; else return Math . floor ( l ) ; }
INT_MAX = 100000000 ; public static int minimalSteps ( String s , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = INT_MAX ; } String s1 = " " ; String s2 = " " ; dp [ 0 ] = 1 ; s1 += s . charAt ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s . charAt ( i ) ; s2 = s . substring ( i + 1 , i + 1 + i + 1 ) ; dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( ( s1 . equals ( s2 ) ) && ( i == 0 ) ) { dp [ i * 2 + 1 ] = Math . min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } } return dp [ n - 1 ] ; }
public static boolean checkUtil ( int num , int dig , int base ) { if ( ( dig == 1 && num < base ) || ( dig > 1 && num >= base ) ) return true ; if ( ( dig > 1 && num >= base ) || ( dig < 0 && num >= base ) ) return checkUtil ( num / base , - - dig , base ) ; return false ; }
public static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } final int getMin = arr [ 0 ] ; int i = 1 ; while ( ( i <= n ) && ( i < arr . length ) ) { minVal = Math . min ( minVal , arr [ i ] ) ; i ++ ; } final int getMax = arr [ i ] ; int i = 1 ; while ( ( i <= n ) && ( i < arr . length ) ) { maxVal = Math . max ( maxVal , arr [ i ] ) ; i ++ ; } System . out . println ( maxVal ) ; }
static int main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = Integer . parseInt ( in . nextLine ( ) ) ; int [ ] p = Arrays . stream ( in . nextLine ( ) . split ( " ▁ " ) ) . toArray ( ) ; char [ ] c = in . nextLine ( ) . toCharArray ( ) ; int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = - x == ' B ' ? x : x ; int s = Arrays . stream ( p ) . mapToInt ( x -> p [ i ] == c [ i ] ? 0 : 1 ) . sum ( ) ; System . out . println ( s + Math . max ( 0 , Math . max ( g ( v ) , 0 ) ) ) ; return s ; }
for ( ; ; ) { double a = map . get ( input . nextLine ( ) ) ; double b = map . get ( input . nextLine ( ) ) ; double c = map . get ( input . nextLine ( ) ) ; double d = map . get ( input . nextLine ( ) ) ; double e = map . get ( input . nextLine ( ) ) ; double f = map . get ( input . nextLine ( ) ) ; double g = map . get ( input . nextLine ( ) ) ; double h = map . get ( input . nextLine ( ) ) ; System . out . println ( new Boolean ( " NO " ) . toString ( ) ) ; System . out . println ( new Boolean ( " YES " ) . toString ( ) ) ; }
public static int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return a ^ b ; return nthXorFib ( n % 3 , a , b ) ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( args [ 0 ] ) ; int taroScore = 0 ; int hanakoScore = 0 ; for ( int turn = 0 ; turn < n ; turn ++ ) { int [ ] animals = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { animals [ i ] = animal ( ) ; } if ( animals [ 0 ] == animals [ 1 ] ) { taroScore ++ ; hanakoScore ++ ; } else if ( Math . max ( animals [ 0 ] , animals [ 1 ] ) == animals [ 0 ] ) { taroScore += 3 ; } else if ( Math . max ( animals [ 0 ] , animals [ 1 ] ) == animals [ 1 ] ) { hanakoScore += 3 ; } } System . out . println ( taroScore + " ▁ " + hanakoScore ) ; }
static final double Area ( double a ) { if ( ( a < 0 ) || ( a > 1 ) ) return - 1 ; double h = 1.268 * a ; double A = 0.70477 * Math . pow ( h , 2 ) ; return A ; }
public static String compute ( ) { int ans = 0 ; Stack < Integer > stack = new Stack < Integer > ( ) ; stack . push ( 1 ) ; stack . push ( 3 ) ; stack . push ( 1 ) ; stack . push ( 2 ) ; while ( stack . size ( ) > 0 ) { int leftn = stack . pop ( ) ; int leftd = stack . pop ( ) ; int rightn = stack . pop ( ) ; int rightd = stack . pop ( ) ; int d = leftd + rightd ; if ( d <= 12000 ) { int n = leftn + rightn ; ans ++ ; stack . push ( n ) ; stack . push ( d ) ; stack . push ( rightn ) ; stack . push ( leftd ) ; stack . push ( n ) ; stack . push ( d ) ; } } return String . valueOf ( ans ) ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; if ( n % 2 == 0 ) { int ans = 2 * ( n / 2 ) ; } else { ans = 0 ; } return ans ; }
public static final void sieve ( boolean [ ] prime , int n ) { prime [ 0 ] = false ; ; prime [ 1 ] = false ; for ( int p = 2 ; p <= Integer . MAX_VALUE ; p ++ ) { if ( ( prime [ p ] == true ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) ) { prime [ p * p ] = true ; }
public static final void sieve ( boolean [ ] prime , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p <= Integer . MAX_VALUE ; p ++ ) { if ( ( prime [ p ] == true ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == true ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) && ( prime [ p * p ] == false ) ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ sorted : ▁ " ) ) ; i ++ ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ sorted : ▁ " ) ) ; int b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ b ▁ number ▁ to ▁ be ▁ sorted : ▁ " ) ) ; int [ ] z = new int [ a ] ; Arrays . sort ( z ) ; z [ a ] = b ; int q = 0 , w = 0 ; for ( int i = 0 ; i < a ; i ++ ) { q += z [ i ] ; if ( q / ( i + 1 ) >= b ) w ++ ; } System . out . println ( w ) ; } }
a = sorted . sort ( new Comparator < Pair < Integer , Integer > > ( ) { public int compare ( Pair < Integer , Integer > o1 , Pair < Integer , Integer > o2 ) { return o1 . second - o2 . second ; } }
public static int maxPartitions ( int [ ] arr , int n ) { int ans = 0 ; ; int maxSoFar = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { maxSoFar = Math . max ( maxSoFar , arr [ i ] ) ; if ( ( maxSoFar == i ) && ( arr [ i ] == 0 ) ) { ans ++ ; } } return ans ; }
public static int countMaxContiguous ( int [ ] arr , int n ) { int currentMax = 0 ; int maxSoFar = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 != 0 ) && ( arr [ i ] > 0 ) ) { currentMax = 0 ; } else { currentMax ++ ; maxSoFar = Math . max ( currentMax , maxSoFar ) ; } } return maxSoFar ; }
static double cubeSide ( double h , double r ) { if ( ( h < 0 && r < 0 ) || ( h > r && h > r ) ) return - 1 ; double a = ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) ; return a ; }
public static void pattern ( int rowsNo ) { for ( int i = 1 ; i <= rowsNo ; i ++ ) { for ( int k = 1 ; k <= i ; k ++ ) { System . out . print ( " ▁ " ) ; } for ( int j = i ; j <= rowsNo ; j ++ ) { System . out . print ( j + " ▁ " ) ; } System . out . println ( ) ; } for ( int i = rowsNo - 1 ; i > 0 ; i -- ) { for ( int k = 1 ; k <= i ; k ++ ) { System . out . print ( " ▁ " ) ; } for ( int j = i ; j <= rowsNo ; j ++ ) { System . out . print ( j + " ▁ " ) ; } System . out . println ( ) ; } rowsNo = 7 ; pattern ( rowsNo ) ; }
public static final void main ( String [ ] args ) { final Scanner sc = new Scanner ( System . in ) ; System . setIn ( sc ) ; System . setOut ( sc ) ; System . setPrecision ( 10 * 8 ) ; final int INF = Float . MAX_VALUE ; final int mod = 10 * 9 + 7 ; final List < Integer > inpl = Arrays . asList ( sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) ) ; System . setIn ( inpl ) ; }
public static int checkDigits ( int n ) { while ( ( n > 0 ) && ( ( n % 10 ) % 2 == 0 ) ) { if ( ( ( n % 10 ) == 0 ) && ( ( n / 10 ) == 0 ) ) { return 0 ; } n = ( int ) ( n / 10 ) ; } final int smallestNumber = n ; int i = n ; while ( ( 1 ) ) { if ( ( checkDigits ( i ) ) && ( ( i % 10 ) == 0 ) ) { return i ; } i ++ ; } if ( GWT . isProdMode ( ) ) { final int N = 2397 ; System . out . println ( smallestNumber ( N ) ) ; } return 0 ; }
public static int checkDigits ( int n ) { while ( ( n > 0 ) && ( ( n % 10 ) % 2 ) != 0 ) { if ( ( ( n % 10 ) == 0 ) && ( ( n % 10 ) == 1 ) ) { return 0 ; } n = ( int ) ( n / 10 ) ; } final int smallestNumber = n ; for ( int i = n ; i < 2401 ; i ++ ) { if ( ( checkDigits ( i ) == 1 ) && ( ( i % 10 ) == 0 ) ) { return ( i ) ; } } final int N = 2397 ; System . out . println ( String . valueOf ( smallestNumber ) ) ; return N ; }
public static void triangularSeries ( int n ) { int j = 1 ; int k = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( k + " ▁ " ) ; j = j + 1 ; k = k + j ; } n = 5 ; triangularSeries ( n ) ; }
private static int input ( ) { return map . get ( Integer . parseInt ( input ( ) . nextLine ( ) ) ) ; }
public static int findPosition ( int k , int n ) { int f1 = 0 ; int f2 = 1 ; int i = 2 ; ; while ( i != 0 ) { int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) { return n * i ; } i ++ ; } return 0 ; }
public static void main ( String [ ] args ) { String s = JOptionPane . showInputDialog ( " First " ) ; System . out . println ( new String ( " Second " ) ) ; }
public static int countMinimumMoves ( int [ ] arr , int n , int k ) { for ( int i = k - 1 ; i < n ; i ++ ) { if ( ( arr [ i ] != arr [ k - 1 ] ) && ( arr [ i ] != arr [ k - 1 ] ) ) { return - 1 ; } } for ( int i = k - 1 ; i >= 0 ; i -- ) { if ( ( arr [ i ] != arr [ k - 1 ] ) && ( arr [ i ] != arr [ k - 1 ] ) ) { return i + 1 ; } } return 0 ; }
public static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( ( y > 0 ) && ( y & 1 ) != 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y > > 1 ; x = ( x * x ) % p ; } return res ; }
T , s , q = map . get ( 0 ) ; v = ( q - 1 ) / q ; tm = 1 ; t = s / ( 1 - v ) ; while ( ( T - s ) / v - t > 0 ) { if ( ( T - s ) / v - t < 1e-10 ) break ; tm ++ ; s += v * t ; t = s / ( 1 - v ) ; } System . out . println ( tm ) ; }
public static int a ( ) { int a = Integer . parseInt ( input ( ) ) ; print ( ( a - 2 ) * 2 ) ; }
public static int countIdenticalRows ( int [ ] [ ] mat ) { int count = 0 ; for ( int i = 0 ; i < mat . length ; i ++ ) { Map < Integer , Integer > hs = Maps . newHashMap ( ) ; for ( int j = 0 ; j < mat [ i ] . length ; j ++ ) hs . put ( mat [ i ] [ j ] , 1 ) ; if ( ( hs . size ( ) == 1 ) && ( hs . values ( ) . length == 1 ) ) count ++ ; } return count ; }
public static void createSorted ( int [ ] a , int n ) { int [ ] b = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { if ( b . length == 0 ) { b [ j ] = a [ j ] ; } else { int start = 0 ; int end = b . length - 1 ; int pos = 0 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( b [ mid ] == a [ j ] ) { b [ max ( 0 , mid + 1 ) ] = a [ j ] ; break ; } else if ( b [ mid ] > a [ j ] ) { pos = end = mid - 1 ; } else { pos = start = mid + 1 ; } if ( start > end ) { pos = start ; b [ max ( 0 , pos ) ] = a [ j ] ; break ; } } } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( b [ i ] + " ▁ " ) ; } }
public static int countTotalDistinct ( String string ) { int cnt = 0 ; ; Set < String > items = new HashSet < String > ( ) ; ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { String temp = " " ; ; Set < String > ans = new HashSet < String > ( ) ; ; for ( int j = i ; j < string . length ( ) ; j ++ ) { temp = temp + string . charAt ( j ) ; ; ans . add ( string . substring ( j , j + 1 ) ) ; ; if ( temp != null ) { items . add ( temp ) ; ; cnt += ans . size ( ) ; ; } } } return cnt ; }
static int firstDigit ( int n ) { int digits = ( int ) ( Math . log10 ( n ) ) ; n = ( int ) ( n / Math . pow ( 10 , digits ) ) ; return n ; }
public static void removeZeros ( int [ ] a , int n ) { int ind = - 1 ; ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] != 0 ) && ( a [ i ] != - 1 ) ) { ind = i ; break ; } } if ( ( ind == - 1 ) ) { System . out . println ( " Array ▁ has ▁ leading ▁ zeros ▁ only " ) ; return ; } }
public static int findMaxm ( int [ ] arr , int n ) { HashMap < Integer , Integer > mpp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] < 0 ) || ( arr [ i ] > n ) ) { mpp . put ( arr [ i ] , mpp . get ( arr [ i ] ) + 1 ) ; } else { mpp . put ( arr [ i ] , 1 ) ; } } int ans = 0 ; for ( Map . Entry < Integer , Integer > value : mpp . entrySet ( ) ) { if ( ( value . getValue ( ) == freq ) && ( value . getKey ( ) == freq ) ) { ans = Math . max ( ans , value . getValue ( ) ) ; } } return ans ; }
public static int n ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] a = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; final int x = n ; int r = 0 ; int y = 0 ; int [ ] D = new int [ 2 * n + 1 ] ; D [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { D [ b ] ++ ; if ( a [ i ] < x ) { r += D [ b ] ; b ++ ; } else { b -- ; r -= D [ b ] ; } y += r ; } Arrays . sort ( a ) ; int l = 0 , r = n ; int m = n / 2 , c = n * ( n + 1 ) / 2 ; while ( true ) { if ( check ( alpha ( m ) ) <= c / 2 ) { if ( m == n - 1 ) break ; else if ( check ( alpha ( m + 1 ) ) > c / 2 ) break ; else l = m ; m = ( m + r ) / 2 ; } else { m = ( m + l ) / 2 ; } } System . out . println ( alpha ( m ) ) ; return y ; }
public static int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x > 0 ) { ans += x % 10 ; x /= 10 ; } return ans ; }
public static final int [ ] getBadge ( String [ ] args ) { final BufferedReader readlines = new BufferedReader ( new InputStreamReader ( System . in ) ) ; final String [ ] badge = { " AAA " , " AA " , " A " , " B " , " C " , " D " , " E " , " NA " } ; final int [ ] limit = { 500 , 35.50 , 37.50 , 40.00 , 43.00 , 50.00 , 55.00 , 70.00 , Float . MAX_VALUE } ; final int [ ] [ ] result = new int [ ] [ ] { { 71.00 , 77.00 , 83.00 , 89.00 , 105.00 , 116.00 , 148.00 , Float . MAX_VALUE } } ; final int [ ] [ ] [ ] rank = { { 71.00 , 77.00 , 83.00 , 89.00 , 105.00 , 116.00 , 148.00 , Float . MAX_VALUE } } ; for ( int i = 0 , l = limit . length ; i < l ; i ++ ) { if ( time < limit [ i ] [ 0 ] ) { result [ i ] = result [ i ] ; } } for ( int i = 0 ; i < result . length ; i ++ ) { final int t500 = Integer . parseInt ( result [ i ] [ 0 ] ) ; final int t1000 = Integer . parseInt ( result [ i ] [ 1 ] ) ; System . out . println ( badge [ Math . max ( rank [ t500 ] , limit [ 500 ] [ 0 ] ) ] ) ; } return result ; }
public static int main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int r = Integer . parseInt ( input . nextLine ( ) ) ; int c = Integer . parseInt ( input . nextLine ( ) ) ; System . out . println ( Math . max ( Math . abs ( n - r ) , r - 1 ) + Math . max ( Math . abs ( m - c ) , c - 1 ) ) ; } }
public static void main ( String [ ] args ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ run " ) ) ; for ( ; ; ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ run " ) ) ; int [ ] a = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ numbers ▁ to ▁ run " ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; Arrays . sort ( a ) ; boolean flag = true ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( a [ i ] - a [ i - 1 ] > 1 ) && ( a [ i ] - a [ i - 1 ] < 0 ) ) { flag = false ; break ; } } if ( flag == true ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
static final void cal_sin ( double n ) { double accuracy = 0.0001 ; ; n = n * ( 3.142 / 180.0 ) ; double x1 = n ; double sinx = n ; double sinval = Math . sin ( n ) ; int i = 1 ; ; while ( ( true ) ) { double denominator = 2 * i * ( 2 * i + 1 ) ; x1 = - x1 * n * n / denominator ; sinx = sinx + x1 ; i = i + 1 ; if ( ( accuracy <= Math . abs ( sinval - sinx ) ) && ( accuracy >= Math . abs ( sinval - sinx ) ) ) break ; } System . out . println ( Math . round ( sinx ) ) ; }
public static int multiply ( int [ ] array , int n ) { int pro = 1 ; for ( int i = 0 ; i < n ; i ++ ) { pro = pro * array [ i ] ; } return pro ; }
public static int [ ] solve ( ) { int [ ] l = new int [ 64 ] ; for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { String query = Arrays . stream ( input ) . collect ( Collectors . joining ( " ▁ " ) ) ; String order = query . substring ( 0 , query . indexOf ( " = " ) ) ; if ( order . equals ( "0" ) ) { System . out . println ( 1 == l [ Integer . parseInt ( query . substring ( 1 ) ) ] ? 0 : 1 ) ; } else if ( order . equals ( "1" ) ) { l [ Integer . parseInt ( query . substring ( 1 ) ) ] = 1 ; } else if ( order . equals ( "2" ) ) { l [ Integer . parseInt ( query . substring ( 1 ) ) ] = 0 ; } else if ( order . equals ( "3" ) ) { l [ Integer . parseInt ( query . substring ( 1 ) ) ] ^= 1 ; } else if ( order . equals ( "4" ) ) { System . out . println ( 1 == Arrays . asList ( l ) ? 0 : 1 ) ; } else if ( order . equals ( "5" ) ) { System . out . println ( 1 == Arrays . asList ( l ) ? 0 : 1 ) ; } else if ( order . equals ( "6" ) ) { System . out . println ( 1 == ! Arrays . asList ( l ) . contains ( " + " ) ? 0 : 1 ) ; } else if ( order . equals ( "7" ) ) { System . out . println ( Arrays . toString ( l ) ) ; } else if ( order . equals ( "8" ) ) { int tmp = 0 ; for ( int i = 0 ; i < Long . SIZE ; i ++ ) { tmp += l [ i ] * 2 * i ; } System . out . println ( tmp ) ; } } return l ; }
public static int bit ( int n ) { int count = 0 ; while ( ( n > 0 ) && ( n < 1 ) ) { count ++ ; n = n & ( n - 1 ) ; } return count ; } public static final int maxSumOfBits ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = bit ( arr [ i ] ) ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( incl > excl ) excl = incl ; else excl = excl ; incl = excl + arr [ i ] ; ; excl = excl ; } if ( incl > excl ) return incl ; else return excl ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 } ; int n = arr . length ; System . out . println ( maxSumOfBits ( arr , n ) ) ; } }
public static int n ( ) { int pares = 0 ; int [ ] [ ] bolo = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int camada = input ( ) ; bolo [ i ] = camada ; } for ( int i = 0 ; i < n ; i ++ ) { int contador = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( bolo [ i ] [ j ] == ' C ' ) contador ++ ; } pares += ( ( contador * ( contador - 1 ) ) / 2 ) ; } for ( int j = 0 ; j < n ; j ++ ) { int contador = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( bolo [ i ] [ j ] == ' C ' ) contador ++ ; } pares += ( ( contador * ( contador - 1 ) ) / 2 ) ; } System . out . println ( pares ) ; return pares ; }
public static int findMinIndex ( int [ ] arr , int low , int high ) { if ( ( high < low ) && ( high == low ) ) return 0 ; if ( ( high == low ) && ( low == 0 ) ) return low ; int mid = ( low + high ) / 2 ; if ( ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) || ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) ) return ( mid + 1 ) ; if ( ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) || ( mid > high && arr [ mid ] > arr [ mid ] ) ) return mid ; if ( ( arr [ high ] > arr [ mid ] ) || ( mid > high && arr [ mid - 1 ] > arr [ mid ] ) ) return findMinIndex ( arr , low , mid - 1 ) ; return findMinIndex ( arr , mid + 1 , high ) ; } private static int binarySearch ( int [ ] arr , int l , int h , int x ) { while ( ( l <= h ) && ( l <= h ) ) { int mid = ( l + h ) / 2 ; if ( ( arr [ mid ] <= x ) && ( arr [ mid + 1 ] < arr [ mid ] ) ) l = mid + 1 ; else h = mid - 1 ; } return h ; } private static int countEleLessThanOrEqual ( int [ ] arr , int n , int x ) { int minIndex = findMinIndex ( arr , 0 , n - 1 ) ; if ( ( x <= arr [ n - 1 ] ) && ( x < arr [ n - 1 ] ) ) return ( binarySearch ( arr , minIndex , n - 1 , x ) + 1 - minIndex ) ; if ( ( ( minIndex - 1 ) >= 0 ) && ( x <= arr [ minIndex - 1 ] ) ) return ( n - minIndex + binarySearch ( arr , 0 , minIndex - 1 , x ) + 1 ) ; return n ; } }
public static double f ( double x , double y ) { double v = y - 2 * x * x + 1 ; ; return v ; } public static double predict ( double x , double y , double h ) { double y1p = y + h * f ( x , y ) ; ; return y1p ; } public static double correct ( double x , double y , double x1 , double y1 , double h ) { double e = 0.00001 ; ; double y1c = y1 ; while ( ( Math . abs ( y1c - y1 ) > e ) && ( x < xn ) ) { y1 = y1c ; y1c = y + 0.5 * h * ( f ( x , y ) + f ( x1 , y1 ) ) ; ; } return y1c ; } public static void printFinalValues ( double x , double xn , double y , double h ) { while ( ( x < xn ) && ( x < xn ) ) { double x1 = x + h ; double y1p = predict ( x , y , h ) ; y1c = correct ( x , y , x1 , y1p , h ) ; ; x = x1 ; y = y1c ; } System . out . println ( " The ▁ final ▁ value ▁ of ▁ y ▁ at ▁ x ▁ = " + ( int ) x + " ▁ is ▁ : " + " { : . 4 } " . format ( y ) ) ; } }
public static String D_Pattern ( String string , int n ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ( j == 1 || ( ( i == 0 || i == n - 1 ) && ( j > 1 && j < n - 2 ) ) || ( j == n - 2 && i != 0 && i != n - 1 ) ) ) { string = string + " * " ; } else { string = string + " ▁ " ; } } string = string + " \n " ; } return ( string ) ; }
public static void kthString ( int n , int k ) { int total = 0 ; int i = 1 ; while ( ( total < k ) && ( i < n ) ) { total = total + n - i ; i ++ ; } int firstYPosition = i - 1 ; int secondYPosition = k - ( total - n + firstYPosition ) ; for ( int j = 1 ; j < firstYPosition ; j += 1 ) { System . out . print ( " x " ) ; } System . out . print ( " y " ) ; int j = firstYPosition + 1 ; while ( ( secondYPosition > 1 ) && ( j < n ) ) { System . out . print ( " x " ) ; secondYPosition -- ; j ++ ; } System . out . print ( " y " ) ; while ( ( j < n ) && ( j < secondYPosition ) ) { System . out . print ( " x " ) ; j ++ ; } }
public static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) { C [ j ] = C [ j ] + C [ j - 1 ] ; } } return C [ k ] ; }
public static class Solution { public static int productExceptSelf ( int [ ] nums ) { int [ ] ans = new int [ nums . length ] ; for ( int i = 1 ; i < nums . length ; i ++ ) { ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] ; } int right = 1 ; for ( int i = nums . length - 1 ; i >= 0 ; i -- ) { ans [ i ] *= right ; right *= nums [ i ] ; } return ans . length ; } }
public static void getSmallestAndLargest ( String s , int k ) { String currStr = s . substring ( 0 , k ) ; String lexMin = currStr ; String lexMax = currStr ; for ( int i = k ; i < s . length ( ) ; i ++ ) { currStr = currStr . substring ( 1 , k ) + s . substring ( i ) ; if ( ( lexMax < currStr ) && ( lexMax . compareTo ( currStr ) < 0 ) ) lexMax = currStr ; if ( ( lexMin > currStr ) && ( lexMin . compareTo ( currStr ) > 0 ) ) lexMin = currStr ; } System . out . println ( lexMin ) ; System . out . println ( lexMax ) ; }
public static int m ( ) { int m = Integer . parseInt ( input ( ) ) ; int [ ] a = Arrays . copyOf ( input ( ) . split ( " ▁ " ) , m ) ; int [ ] b = Arrays . copyOf ( input ( ) . split ( " ▁ " ) , m ) ; int [ ] d = new int [ m ] ; d [ 0 ] = 0 ; class struct { public int value ( int value , int idx ) { d [ idx ] = value ; } } for ( int i = 0 ; i < m ; i ++ ) { b [ i ] = struct . value ( b [ i ] , i ) ; } Arrays . sort ( b , 0 , m ) ; Arrays . sort ( a , 0 , m ) ; for ( int i = 0 ; i < m ; i ++ ) { d [ b [ i ] . idx ] = a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { System . out . print ( d [ i ] + " ▁ " + " ▁ " ) ; } return m ; }
public static int maxSubarrayXOR ( int [ ] set , int n ) { int index = 0 ; for ( int i = INT_BITS - 1 ; i >= 0 ; i -- ) { int maxInd = index ; int maxEle = - 2147483648 ; for ( int j = index ; j < n ; j ++ ) { if ( ( ( set [ j ] & ( 1 << i ) ) != 0 && set [ j ] > maxEle ) || ( maxEle == - 2147483648 ) ) { continue ; } int temp = set [ index ] ; set [ index ] = set [ maxInd ] ; set [ maxInd ] = temp ; maxInd = index ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( j != maxInd && ( set [ j ] & ( 1 << i ) ) != 0 ) || ( j != maxInd && ( set [ j ] & ( 1 << i ) ) != 0 ) ) { set [ j ] = set [ j ] ^ set [ maxInd ] ; } } index = index + 1 ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res = res ^ set [ i ] ; } return res ; } int [ ] set = { 9 , 8 , 5 } ; int n = set . length ; System . out . println ( " Max ▁ subset ▁ XOR ▁ is ▁ " + n ) ; System . out . println ( maxSubarrayXOR ( set , n ) ) ; return n ; }
public static void main ( String [ ] args ) { Scanner b = new Scanner ( System . in ) ; System . out . println ( Math . max ( map . size ( ) , b . count ( ) ) ) ; }
public static int partition ( int arr [ ] , int si , int ei ) { int x = arr [ ei ] ; int i = ( si - 1 ) ; for ( int j = si ; j < ei ; j ++ ) { if ( ( arr [ j ] <= x ) && ( arr [ j ] > x ) ) { i ++ ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } } arr [ i + 1 ] = arr [ ei ] ; return ( i + 1 ) ; }
public static class Solution { public static int firstUniqChar ( final String s ) { final Map < Character , Integer > countMap = new HashMap < Character , Integer > ( ) ; for ( final char c : s . toCharArray ( ) ) { countMap . put ( c , countMap . get ( c ) + 1 ) ; } for ( int i = 0 , len = s . length ( ) ; i < len ; i ++ ) { if ( countMap . get ( s . charAt ( i ) ) == 1 ) { return i ; } } return - 1 ; } public static void main ( final String [ ] args ) { Solution sObj = new Solution ( ) ; String s = " leetcode " ; String out = sObj . firstUniqChar ( s ) ; System . out . println ( out ) ; } }
public static final boolean checkStackPermutation ( int [ ] ip , int [ ] op , int n ) { Queue < Integer > Input = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) Input . offer ( ip [ i ] ) ; Queue < Integer > output = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) output . offer ( op [ i ] ) ; Stack < Integer > tempStack = new Stack < Integer > ( ) ; while ( ( ! Input . isEmpty ( ) ) && ( ! output . isEmpty ( ) ) ) { Integer ele = Input . poll ( ) ; Input . offer ( ele ) ; if ( ( ele == output . peek ( ) ) || ( ele == output . peek ( ) ) ) { output . offer ( ele ) ; while ( ( tempStack . size ( ) != 0 ) && ( tempStack . size ( ) == 0 ) ) { if ( ( tempStack . peek ( ) == output . peek ( ) ) || ( tempStack . peek ( ) == output . peek ( ) ) ) { tempStack . pop ( ) ; output . offer ( ele ) ; } else break ; } } else tempStack . push ( ele ) ; } return ( Input . isEmpty ( ) && tempStack . size ( ) == 0 ) ; }
public static final void main ( String [ ] args ) { final Map < Integer , List < Integer > > s = new HashMap < Integer , List < Integer > > ( ) ; final Map < Integer , List < Integer > > t = new HashMap < Integer , List < Integer > > ( ) ; final List < Integer > S = Arrays . asList ( input ) ; final List < Integer > T = Arrays . asList ( input ) ; for ( int i = 0 ; i < S . size ( ) ; i ++ ) { if ( T . get ( i ) != null ) { s . put ( S . get ( i ) , T . get ( i ) ) ; if ( s . get ( S . get ( i ) ) . size ( ) >= 2 ) { System . out . println ( " No " ) ; break ; } } if ( S . get ( i ) != null ) { t . put ( T . get ( i ) , S . get ( i ) ) ; if ( t . get ( T . get ( i ) ) . size ( ) >= 2 ) { System . out . println ( " No " ) ; break ; } } if ( i == S . size ( ) - 1 ) { System . out . println ( " Yes " ) ; } } }
public static int getSum ( int n , int d ) { int sum = 0 ; ; for ( int i = 0 ; i < n + 1 ; i ++ ) { if ( ( i % 10 == d ) && ( i % 100 == 0 ) ) { sum += i ; } } return sum ; }
static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = Integer . parseInt ( input . nextLine ( ) ) ; for ( int testcases = 0 ; testcases < t ; testcases ++ ) { int a = Integer . parseInt ( input . nextLine ( ) ) , b = Integer . parseInt ( input . nextLine ( ) ) , c = Integer . parseInt ( input . nextLine ( ) ) , r = Integer . parseInt ( input . nextLine ( ) ) ; int MINC = c - r ; int MAXC = c + r ; if ( a == b ) System . out . println ( 0 ) ; else if ( a < b ) { if ( a <= c && c <= b ) System . out . println ( Math . max ( 0 , MINC - a ) + Math . max ( 0 , b - MAXC ) ) ; else if ( c < a ) System . out . println ( Math . min ( b - a , Math . max ( 0 , b - MAXC ) ) ) ; else if ( c > b ) System . out . println ( Math . min ( b - a , Math . max ( 0 , MINC - a ) ) ) ; } else { if ( a >= c && c >= b ) System . out . println ( Math . max ( 0 , MINC - b ) + Math . max ( 0 , a - MAXC ) ) ; else if ( c < b ) System . out . println ( Math . min ( a - b , Math . max ( 0 , a - MAXC ) ) ) ; else if ( c > a ) System . out . println ( Math . min ( a - b , Math . max ( 0 , MINC - b ) ) ) ; } } }
public static int main ( String [ ] args ) { for ( int i = 0 ; i < Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ input ▁ characters ▁ to ▁ display " ) ) ; i ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display " ) ) ; int s = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display " ) ) ; int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display " ) ) ; System . out . println ( n - Math . min ( s , t ) + 1 ) ; } return 0 ; }
public static int findSum ( int N , int K ) { int ans = 0 ; ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; ; return ans ; }
public static int gcd ( int n , int [ ] a ) { int i ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = 1 + ( ( 4 * i * ( i + 1 ) ) / Math . gcd ( 4 * i , i + 1 ) ) / ( i + 1 ) ; } return a [ 0 ] ; }
public static double findArea ( int r , int d ) { double R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; double area = PI * Math . pow ( R , 2 ) ; return area ; if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " win " ) ) { int r = 4 ; int d = 5 ; System . out . println ( findArea ( r , d ) ) ; } return 0 ; }
public static int minimumNumbers ( int n , int s ) { if ( ( s % n ) != 0 ) return s / n + 1 ; ; else return s / n ; }
public static int countTriplets ( int [ ] arr , int n , int m ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int end = n - 1 ; end > 1 ; end -- ) { int start = 0 ; int mid = end - 1 ; while ( ( start < mid ) && ( end < mid ) ) { int prod = ( arr [ end ] * arr [ start ] * arr [ mid ] ) ; if ( ( prod > m ) && ( ( prod < m ) || ( prod == m ) ) ) { mid -- ; } else if ( ( prod == m ) && ( ( end < mid ) || ( end < mid ) ) ) { count ++ ; mid -- ; start ++ ; } } } return count ; } if ( System . getProperty ( " user . dir " ) == null ) { arr = new int [ ] { 1 , 1 , 1 , 1 , 1 , 1 } ; n = arr . length ; m = 1 ; System . out . println ( countTriplets ( arr , n , m ) ) ; } return count ; }
public static int findIndex ( int n ) { if ( ( n <= 1 ) || ( n > 2 ) ) return n ; int a = 0 ; int b = 1 ; int c = 1 ; int res = 1 ; while ( ( c < n ) && ( c < n ) ) { c = a + b ; res = res + 1 ; a = b ; b = c ; } return res ; }
public static boolean isVowel ( char ch ) { if ( ch == ' i ' || ch == ' a ' || ch == ' e ' || ch == ' o ' || ch == ' u ' ) { return true ; } else { return false ; } } public static boolean isSatisfied ( String st , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( ( isVowel ( st . charAt ( i ) ) == false && isVowel ( st . charAt ( i - 1 ) ) == false ) || ( isVowel ( st . charAt ( i - 1 ) ) == false ) ) { return false ; } } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( isVowel ( st . charAt ( i ) ) && isVowel ( st . charAt ( i - 1 ) ) == false && isVowel ( st . charAt ( i + 1 ) ) == false ) || ( isVowel ( st . charAt ( i + 1 ) ) == false ) ) { return false ; } } return true ; } public static String toString ( int i ) { return " acaba " + i ; } public static int length ( int i ) { return i ; } public static boolean isSatisfied ( String st ) { return ( isVowel ( st . charAt ( i ) ) == false && isVowel ( st . charAt ( i - 1 ) ) == false ) || ( isVowel ( st . charAt ( i - 1 ) ) == false ) ; } public static boolean isSatisfied ( String s ) { return ( isVowel ( s ) == false && isVowel ( s . charAt ( 0 ) ) == false ) || ( isVowel ( s . charAt ( 0 ) ) == true ) ; } public static boolean isSatisfied ( String s ) { return ( isVowel ( s ) == false && isVowel ( s . charAt ( 0 ) ) == false ) ; } public static boolean isSatisfied ( String s ) { return ( isVowel ( s ) == false && isVowel ( s . charAt ( 0 ) ) == false ) ; } public static boolean isSatisfied ( String s ) { return ( isVowel ( s ) == true && isVowel ( s . charAt ( 0 ) ) == true ) ; } public static boolean isSatisfied ( String s ) { return ( isVowel ( s ) )
public static int countWays ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
public static double expect ( int m , int n ) { double ans = 0.0 ; int i = m ; while ( ( i ) > 0 ) { ans += ( Math . pow ( i / m , n ) - Math . pow ( ( i - 1 ) / m , n ) ) * i ; i -- ; } return ans ; }
public static int ProdOfPrimes ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; prime [ 0 ] = true ; prime [ 1 ] = true ; int p = 2 ; while ( ( p * p <= n ) && ( prime [ p ] == true ) ) { if ( ( prime [ p ] == true ) && ( prime [ p + 1 ] == true ) ) { int i = p * 2 ; while ( ( i <= n ) && ( prime [ i ] == true ) ) { prime [ i ] = false ; i += p ; } } p ++ ; } int prod = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( prime [ i ] ) ) { prod *= i ; } } return prod ; }
public static String compute ( ) { int ans = sum ( 1 , y , m , new Date ( 1901 , 2001 ) , new Date ( 1 , 13 ) ) ; return String . valueOf ( ans ) ; }
class Date { public static final long getDifference ( Date d , Date m , Date y ) { d = d ; m = m ; y = y ; } private static final long [ ] monthDays = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; private static final long countLeapYears ( Date d ) { long years = d . y ; if ( ( d . m <= 2 ) && ( d . m >= 4 ) ) years -- ; return new long [ ] { years / 4 - years / 100 + years / 400 } ; } private static final long getDifference ( Date dt1 , Date dt2 ) { long n1 = dt1 . y * 365 + dt1 . d ; for ( int i = 0 ; i <= dt1 . m - 1 ; i ++ ) n1 += monthDays [ i ] ; n1 += countLeapYears ( dt1 ) ; long n2 = dt2 . y * 365 + dt2 . d ; for ( int i = 0 ; i <= dt2 . m - 1 ; i ++ ) n2 += monthDays [ i ] ; n2 += countLeapYears ( dt2 ) ; return ( n2 - n1 ) ; } }
public static void generateNumbers ( int n , int num , int a , int b ) { if ( ( num > 0 ) && ( num < n ) ) { st . add ( num ) ; } if ( ( num >= n ) && ( num < n ) ) { return ; } if ( ( num * 10 + a > num ) || ( num * 10 + b > num ) ) { generateNumbers ( n , num * 10 + a , a , b ) ; } generateNumbers ( n , num * 10 + b , a , b ) ; final int i = 0 ; for ( int j = 0 ; j < 10 ; j += 1 ) { generateNumbers ( n , 0 , i , j ) ; } System . out . println ( " The ▁ numbers ▁ are : " + n ) ; final List < Integer > l = Arrays . asList ( st ) ; System . out . println ( l ) ; }
static int n ( int k , int t ) { t = ( n * k * t ) / 100 ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( Math . min ( Math . max ( 0 , t - i * k ) , k ) ) ; } return t ; }
public static final void main ( String [ ] args ) { TreeMap < Integer , Integer > map = new TreeMap < Integer , Integer > ( ) ; for ( ; ; ) { List < Integer > M = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ enter ▁ a ▁ number ▁ to ▁ be ▁ sorted : ▁ " ) ) ; for ( int num : M ) { if ( num == 0 ) continue ; map . put ( num , num ) ; } int ans = 10 * 20 ; for ( Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > m ) { ans = entry . getKey ( ) ; m = entry . getValue ( ) ; } else if ( entry . getValue ( ) == m ) ans = Math . min ( ans , entry . getKey ( ) ) ; } if ( ans == 10 * 20 ) ans = 0 ; System . out . println ( ans ) ; } while ( 1 ) { int n = JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ sorted : ▁ " ) ; if ( n == JOptionPane . YES_OPTION ) break ; main ( n , m ) ; } }
public static int getOddOccurrence ( int [ ] arr ) { int res = 0 ; for ( int element : arr ) { res = res ^ element ; } return res ; }
static final public boolean isKthBitSet ( int x , int k ) { if ( ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) && ( ( x & ( 1 << ( k - 1 ) ) ) != 0 ) ) return true ; else return false ; } public static boolean isPalindrome ( int x ) { int l = 1 ; int r = 2 * 8 ; while ( ( l < r ) && ( x < l ) ) { if ( ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) && ( x < r ) ) return false ; l ++ ; r -- ; } return true ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { x = 1 << 15 + 1 << 16 ; System . out . println ( Integer . toString ( isPalindrome ( x ) ) ) ; x = 1 << 31 + 1 ; System . out . println ( Integer . toString ( isPalindrome ( x ) ) ) ; } }
public static final void SieveOfEratosthenes ( int n , boolean [ ] isPrime ) { isPrime [ 0 ] = false , isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p <= Integer . MAX_VALUE ; p ++ ) if ( isPrime [ p ] == true ) for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; }
public static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; a = 10 ; b = 15 ; System . out . println ( " GCD " ) ; }
public static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; a = 10 ; b = 15 ; System . out . println ( " GCD " ) ; }
public static String compute ( ) { final int SIZE_LIMIT = 1000000 ; final int TYPE_LIMIT = 10 ; int [ ] type = new int [ SIZE_LIMIT + 1 ] ; for ( int n = 3 ; n <= SIZE_LIMIT / 4 + 2 ; n ++ ) { for ( int m = n - 2 ; m > 0 ; m -- ) { int tiles = n * n - m * m ; if ( tiles > SIZE_LIMIT ) break ; type [ tiles ] ++ ; } } int ans = Arrays . binarySearch ( type , 1 ) ; return String . valueOf ( ans ) ; }
public static int t ( ) { int t = Integer . parseInt ( System . in ) ; while ( t > 0 ) { t -- ; String S = System . in . readLine ( ) ; String [ ] s = Arrays . copyOfRange ( S , 0 , S . length ( ) ) ; Stack < Integer > stack = new Stack < Integer > ( ) ; Stack < Integer > pos = new Stack < Integer > ( ) ; int check0 = 0 ; for ( int i = 0 ; i <= s . length ; i ++ ) { int j = s . length - i - 1 ; stack . push ( new Integer ( j ) ) ; if ( s [ j ] . equals ( "0" ) ) { if ( check0 == 0 ) { if ( pos . isEmpty ( ) ) { stack . pop ( ) ; pos . push ( j ) ; } else { if ( pos . peek ( ) - j > 1 ) { stack . pop ( ) ; pos . push ( j ) ; } } if ( stack . isEmpty ( ) ) { if ( stack . peek ( ) - 1 == 0 ) check0 = 1 ; } } } if ( check0 == 1 ) { if ( s [ j ] . equals ( "1" ) ) { if ( pos . peek ( ) - j > 1 ) { stack . pop ( ) ; pos . push ( j ) ; } } } } Stack < Integer > stack2 = new Stack < Integer > ( ) ; int check = 0 ; for ( int i = 0 ; i <= stack . size ( ) - 1 ; i ++ ) { if ( stack . peek ( ) . intValue ( ) < stack . peek ( ) . intValue ( ) ) check = 1 ; } if ( check == 1 ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } return t ; }
public static int maxZeros ( int N ) { int maxm = - 1 ; int cnt = 0 ; while ( ( N > 0 ) && ( ! ( N & 1 ) ) ) { if ( ( ! ( N & 1 ) ) && ( ! ( N & 1 ) ) ) { cnt ++ ; N >>>= 1 ; maxm = Math . max ( maxm , cnt ) ; } else { maxm = Math . max ( maxm , cnt ) ; cnt = 0 ; N >>>= 1 ; } } return maxm ; }
public static void getLongestSeq ( int [ ] a , int n ) { int maxIdx = 0 ; int maxLen = 0 ; int currLen = 0 ; int currIdx = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( a [ k ] > 0 ) { currLen ++ ; if ( currLen == 1 ) { currIdx = k ; } } else { if ( currLen > maxLen ) { maxLen = currLen ; maxIdx = currIdx ; } currLen = 0 ; } } if ( maxLen > 0 ) { System . out . println ( " Index ▁ : " + maxIdx + " ▁ , Length ▁ : " + maxLen + " , " ) ; } else { System . out . println ( " No ▁ positive ▁ sequence ▁ detected . " ) ; } } int [ ] arr = { 1 , 2 , - 3 , 2 , 3 , 4 , - 6 , 1 , 2 , 3 , 4 , 5 , - 8 , 5 , 6 } ; n = arr . length ; getLongestSeq ( arr , n ) ; }
public static final < T > Node < T > create ( T data ) { final Node < T > temp = new Node < T > ( ) ; temp . data = data ; temp . right = null ; temp . down = null ; return temp ; } public static Node < T > construct ( int [ ] [ ] arr , int i , int j , int m , int n ) { if ( ( i > n - 1 || j > m - 1 ) && ( i < m - 1 ) ) return null ; temp . data = arr [ i ] [ j ] ; temp . right = construct ( arr , i , j + 1 , m , n ) ; temp . down = construct ( arr , i + 1 , j , m , n ) ; return temp ; } public static void display ( Node < T > head ) { Node < T > Dp = head ; while ( ( Dp != null ) && ( Dp . data != null ) ) { Node < T > Rp = Dp ; while ( ( Rp != null ) && ( Rp . data != null ) ) { System . out . print ( Rp . data + " ▁ " ) ; Rp = Rp . right ; } System . out . println ( ) ; Dp = Dp . down ; } }
public static int length ( int [ ] nums ) { int N = Integer . parseInt ( input ( ) ) ; int [ ] nums = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) nums [ i ] = Integer . parseInt ( input ( ) ) ; final int numSqrt = Math . sqrt ( num ) ; for ( int prime = 2 ; prime <= numSqrt ; prime ++ ) { if ( num % prime == 0 ) { nums [ prime ] = num % prime ; break ; } } System . out . println ( nums . length ) ; return nums . length ; }
public static void findNthTerm ( int N ) { int ans ; ; if ( ( N % 2 == 0 ) && ( N % 2 == 1 ) ) { ans = ( N / 2 ) * 6 + ( N / 2 ) * 2 ; } else { ans = ( N / 2 + 1 ) * 6 + ( N / 2 ) * 2 ; } ; System . out . println ( ans ) ; ; }
public static boolean isRectangle ( int a , int b , int c , int d ) { if ( a == b == c == d ) { return true ; } else if ( a == b && c == d ) { return true ; } else if ( a == d && c == b ) { return true ; } else if ( a == c && d == b ) { return true ; } return false ; }
static final int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; ; int an = 1 ; for ( int i = 0 ; i < n ; i ++ ) an = ( an * a ) % m ; ; int [ ] value = new int [ m ] ; int cur = an ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( value [ cur ] == 0 ) ) value [ cur ] = i ; } return cur ; }
public static int FindMinimumCost ( int ind , int [ ] a , int n , int k , int [ ] dp ) { if ( ( ind == ( n - 1 ) ) && ( dp [ ind ] != - 1 ) ) return 0 ; else if ( ( dp [ ind ] != - 1 ) && ( dp [ ind ] != 0 ) ) return dp [ ind ] ; else { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( ind + i ) < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } dp [ ind ] = ans ; return ans ; } }
public static final int Probability ( int sum , int times ) { double favorable = 0.0 , total = 36.0 , probability = 0 ; for ( int i = 0 ; i < 7 ; i ++ ) { for ( int j = 0 ; j < 7 ; j ++ ) { if ( ( ( i + j ) == sum ) && ( ( i + j ) == times ) ) { favorable ++ ; } } } int gcd1 = gcd ( ( int ) favorable , ( int ) total ) ; favorable = favorable / gcd1 ; total = total / gcd1 ; probability = Math . pow ( total , times ) ; return ( int ) probability ; }
static int K = map . length , N = map . length ; int mod = 998244353 ; final int inved = 1 ; int x = 0 , y = 0 , u = 0 , v = 1 , k = 0 , l = 1 ; while ( l != 0 ) { x = u ++ , y = v ++ , u = x - u * ( k / l ) , v = y - v * ( k / l ) ; k = l ; l = k % l ; } X [ 0 ] = 0 ; X [ 1 ] = 0 ; X [ 2 ] = 0 ; X [ 3 ] = 0 ; X [ 4 ] = 0 ; X [ 5 ] = 0 ; X [ 6 ] = 0 ; X [ 7 ] = 0 ; X [ 8 ] = 0 ; X [ 9 ] = 0 ; X [ 10 ] = 0 ; X [ 11 ] = 0 ; X [ 12 ] = 0 ; X [ 13 ] = 0 ; X [ 14 ] = 0 ; X [ 15 ] = 0 ; X [ 16 ] = 0 ; X [ 17 ] = 0 ; X [ 18 ] = 0 ; X [ 19 ] = 0 ; X [ 20 ] = 0 ; X [ 21 ] = 0 ; X [ 22 ] = 0 ; X [ 23 ] = 0 ; X [ 24 ] = 0 ; X [ 25 ] = 0 ; X [ 26 ] = 0 ; X [ 27 ] = 0 ; X [ 28 ] = 0 ; X [ 29 ] = 0 ; X [ 30 ] = 0 ; X [ 31 ] = 0 ; X [ 32 ] = 0 ; X [ 33 ] = 0 ; X [ 34 ] = 0 ; X [ 35 ] = 0 ; X [ 36 ] = 0 ; X [ 37 ] = 0 ; X [ 38 ] = 0 ; X [ 39 ] = 0 ; X [ 40 ] = 0 ; X [ 41 ] = 0 ; X [ 42 ] = 0 ; X [ 43 ] = 0 ; X [ 44 ] = 0 ; X [ 45 ] = 0 ; X [ 46 ] = 0 ; X [ 47 ] = 0 ; X [ 48 ] = 0 ; X [ 49 ] = 0 ; X [ 50 ] = 0 ; X [ 51 ] = 0 ; X [ 52 ] = 0 ; X [ 53 ] = 0 ; X [ 54 ] = 0 ; X [ 55 ] = 0 ; X [ 56 ] = 0 ; X [ 57 ] =
public static double getAmount ( ) { int N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ amount ▁ to ▁ send " ) ) ; double c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { String [ ] a = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ amount ▁ to ▁ send " ) . split ( " ▁ " ) ) . toArray ( ) ; if ( a [ 1 ] . equals ( " BTC " ) ) c += Double . parseDouble ( a [ 0 ] ) * 380000.0 ; else c += Double . parseDouble ( a [ 0 ] ) ; } System . out . println ( c ) ; }
public static int getCount ( int [ ] arr , int n , int num1 , int num2 ) { for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] == num1 ) && ( arr [ i + 1 ] == num2 ) ) break ; } if ( ( i >= n - 1 ) && ( arr [ i + 1 ] == num1 ) ) return 0 ; for ( int j = n - 1 ; j >= i ; j -- ) { if ( ( arr [ j ] == num2 ) && ( arr [ j + 1 ] == num1 ) ) break ; } if ( ( j == i ) && ( arr [ i ] == num2 ) ) return 0 ; return ( j - i - 1 ) ; }
public static int compareTo ( int [ ] a , int [ ] b ) { while ( 1 ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ compare : ▁ " ) ) ; if ( n == 0 ) break ; int [ ] a = Arrays . copyOf ( Arrays . asList ( a ) , n ) ; System . out . println ( Math . min ( a [ i + 1 ] - a [ i ] , a [ i ] ) ) ; } return a . length - b . length ; }
public static int countSetBits ( int n ) { int cnt = 0 ; int [ ] setBits = new int [ n + 1 ] ; setBits [ 0 ] = 0 ; setBits [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i % 2 == 0 ) && ( setBits [ i ] == 0 ) ) { setBits [ i ] = setBits [ i / 2 ] ; } else { setBits [ i ] = setBits [ i - 1 ] + 1 ; } } for ( int i = 0 ; i <= n ; i ++ ) { cnt = cnt + setBits [ i ] ; } return cnt ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) return b ; return gcd ( b % a , a ) ; }
public static String compute ( ) { int [ ] divisors = new int [ 10 * 7 + 1 ] ; for ( int i = 2 ; i < ( divisors . length + 1 ) / 2 ; i ++ ) { for ( int j = i * 2 ; j < divisors . length ; j += i ) { divisors [ j ] ++ ; } } int ans = Arrays . stream ( divisors ) . mapToInt ( i -> 1 if divisors [ i ] == divisors [ i + 1 ] else 0 ) . sum ( ) ; return String . valueOf ( ans ) ; }
public static void updateArray ( int arr [ ] , int n ) { int i = n - 1 ; while ( ( i > 0 ) && ( arr [ i ] != - 1 ) ) { arr [ i ] = arr [ i - 1 ] ; i -- ; } arr [ 0 ] = - 1 ; for ( i = 0 ; i < n ; i += 1 ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
public static void findEncryptedArray ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( sum - arr [ i ] + " ▁ " ) ; } }
public static void updateArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { arr [ i ] = arr [ i + 1 ] ; } arr [ n - 1 ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
public static int findMinDifference ( int [ ] arr , int n ) { if ( ( arr [ 0 ] < arr [ 1 ] ) && ( arr [ 1 ] > arr [ 0 ] ) ) { int min__ = secondMax = arr [ 0 ] ; if ( ( arr [ 0 ] < arr [ 1 ] ) && ( arr [ 1 ] > arr [ 0 ] ) ) { int max__ = secondMin = arr [ 1 ] ; if ( ( arr [ 0 ] < arr [ 1 ] ) && ( arr [ 1 ] > arr [ 0 ] ) ) { int max__ = secondMin = arr [ 1 ] ; if ( ( arr [ 0 ] < arr [ 1 ] ) && ( arr [ 1 ] > arr [ 0 ] ) ) { int secondMax = max__ ; max__ = arr [ 1 ] ; } else if ( ( arr [ 0 ] < arr [ 1 ] ) && ( arr [ 1 ] > arr [ 0 ] ) ) { int secondMax = arr [ 1 ] ; } else if ( ( arr [ 0 ] < arr [ 1 ] ) && ( arr [ 1 ] > arr [ 0 ] ) ) { int secondMin = min__ ; min__ = arr [ 1 ] ; } else if ( ( arr [ 0 ] < arr [ 1 ] ) && ( arr [ 1 ] > arr [ 0 ] ) ) { int secondMin = arr [ 1 ] ; } } int diff = Math . min ( max__ - secondMin , secondMax - min__ ) ; return diff ; } } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " windows " ) ) { arr = new int [ ] { 1 , 2 , 4 , 3 , 4 } ; n = arr . length ; System . out . println ( findMinDifference ( arr , n ) ) ; } return 0 ; }
static public void main ( String [ ] args ) throws Exception { final BufferedReader read = new BufferedReader ( new InputStreamReader ( System . in ) ) ; final PrintStream write = new PrintStream ( System . out ) ; final Set < Integer > ret = new HashSet < Integer > ( ) ; int i = 2 ; while ( i <= Math . sqrt ( Math . max ( a , b ) ) ) { while ( a % i == 0 ) { ret . add ( i ) ; a /= i ; } while ( b % i == 0 ) { ret . add ( i ) ; b /= i ; } i ++ ; } if ( a >= 2 ) ret . add ( a ) ; if ( b >= 2 ) ret . add ( b ) ; final Set < Integer > set = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < set . size ( ) ; i ++ ) { if ( set . contains ( i ) || set . contains ( i + 1 ) ) set . add ( i ) ; } System . out . println ( ret ) ; final int n = Integer . parseInt ( read . readLine ( ) ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( ; n > 0 ; n -- ) { int x = Integer . parseInt ( read . readLine ( ) ) ; int y = Integer . parseInt ( read . readLine ( ) ) ; a [ 0 ] = x ; b [ 0 ] = y ; ; } int [ ] f = factor ( a [ 0 ] , b [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { f = test ( a [ i ] , b [ i ] , f ) ; } if ( f . length == 0 ) { write . println ( " - 1 \n " ) ; } else { for ( int i = 0 ; i < f . length ; i ++ ) { write . print ( Integer . toString ( f [ i ] ) + ' \n ' ) ; break ; } } }
public static final Map < Integer , Integer > getStars ( ) { while ( true ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ stars ▁ to ▁ display " ) ) ; if ( n == 0 ) break ; Map < Integer , Integer > stars = new HashMap < Integer , Integer > ( ) ; for ( Integer s : map ( ) ) stars . put ( s , s + 1 ) ; int halfN = n / 2 ; for ( Map . Entry < Integer , Integer > i : stars . entrySet ( ) ) { if ( i . getValue ( ) > halfN ) { System . out . println ( i . getKey ( ) ) ; break ; } } else System . out . println ( " NO ▁ COLOR " ) ; } return stars ; }
public static int factorial ( int n ) { return 1 == ( n == 1 || n == 0 ) ? n : n * factorial ( n - 1 ) ; }
n , d , x ) public static void main ( String [ ] args ) { int [ ] [ ] weights = new int [ d ] [ n ] ; for ( int i = 0 ; i < d ; i ++ ) weights [ i ] = Arrays . copyOf ( input , n ) ; int [ ] prices = new int [ d - 1 ] ; for ( int i = 0 ; i < d - 1 ; i ++ ) prices [ i ] = new int [ weights [ i + 1 ] [ j ] - weights [ i ] [ j ] ] ; int bag = x ; for ( int i = 0 ; i < d - 1 ; i ++ ) { boolean [ ] dp = new boolean [ bag + 1 ] ; dp [ 0 ] = false ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < bag ; k ++ ) { if ( weights [ i ] [ j ] + k < bag + 1 && dp [ k ] != false ) { dp [ k + weights [ i ] [ j ] ] = Math . max ( dp [ k + weights [ i ] [ j ] ] , dp [ k ] + prices [ i ] [ j ] ) ; } } } bag += Math . max ( dp [ 0 ] , dp [ bag + 1 ] ) ; } System . out . println ( bag ) ; }
public static void solve ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ stones ▁ to ▁ solve " ) ) ; int [ ] stones = new int [ n ] ; for ( int x = 0 ; x < n ; x ++ ) stones [ x ] = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ stones ▁ to ▁ solve " ) ) ; total1 = new int [ stones . length + 1 ] ; for ( int i = 1 ; i <= stones . length ; i ++ ) total1 [ i ] = stones [ i - 1 ] + total1 [ i - 1 ] ; total2 = new int [ stones . length + 1 ] ; Arrays . fill ( total2 , 0 ) ; for ( int i = 1 ; i <= stones . length ; i ++ ) total2 [ i ] = stones [ i - 1 ] + total2 [ i - 1 ] ; int m = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ m ▁ stones ▁ to ▁ solve " ) ) ; for ( int i = 0 ; i < m ; i ++ ) { int [ ] x = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) x [ j ] = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ m ▁ stones ▁ to ▁ solve " ) ) ; if ( x [ 0 ] == 1 ) System . out . println ( total1 [ x [ 2 ] ] - total1 [ x [ 1 ] - 1 ] ) ; else System . out . println ( total2 [ x [ 2 ] ] - total2 [ x [ 1 ] - 1 ] ) ; } solve ( ) ; }
public static int findMinimumX ( int [ ] a , int n ) { Set < Integer > st = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) st . add ( a [ i ] ) ; if ( ( st . size ( ) == 1 ) && ( n == 1 ) ) return 0 ; if ( ( st . size ( ) == 2 ) && ( n == 2 ) ) { st = Arrays . asList ( st ) ; int el1 = st . get ( 0 ) ; int el2 = st . get ( 1 ) ; if ( ( ( el2 - el1 ) % 2 == 0 ) && ( ( el2 - el1 ) / 2 == 0 ) ) return ( int ) ( ( el2 - el1 ) / 2 ) ; else return ( el2 - el1 ) ; } if ( ( st . size ( ) == 3 ) && ( n == 3 ) ) { st = Arrays . asList ( st ) ; int el1 = st . get ( 0 ) ; int el2 = st . get ( 1 ) ; int el3 = st . get ( 2 ) ; if ( ( ( el2 - el1 ) == ( el3 - el2 ) ) && ( ( el2 - el1 ) / 2 == 0 ) ) return el2 - el1 ; else return - 1 ; } return - 1 ; }
public static int findX ( int n , int k ) { int r = n ; int m = ( int ) Math . sqrt ( k ) + 1 ; int i = 2 ; while ( i <= m && k > 1 ) { if ( ( i == m ) || ( i == k ) ) i = k ; int u = 0 ; int v = 0 ; while ( k % i == 0 ) { k /= i ; v ++ ; } if ( ( v > 0 ) || ( v > k ) ) { int t = n ; while ( ( t > 0 ) && ( t < u ) ) { t /= i ; u += t ; } r = Math . min ( r , u / v ) ; } i ++ ; } return r ; }
public static boolean LiesInsieRectangle ( int a , int b , int x , int y ) { if ( ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) || ( x - y - b <= 0 && x - y + b >= 0 && x + y - b <= 0 ) ) { return true ; } return false ; }
public static void countPairs ( int [ ] arr , int n ) { int size = ( 2 * N ) + 1 ; int [ ] freq = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( freq [ i ] > 0 ) && ( freq [ i ] < 1 ) ) { ans += ( int ) ( ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ) ; for ( int j = i + 2 ; j < 2001 ; j += 2 ) { if ( ( freq [ j ] > 0 ) && ( freq [ ( int ) ( ( i + j ) / 2 ) ] > 0 ) ) { ans += ( freq [ i ] * freq [ j ] ) ; } } } } System . out . println ( ans ) ; if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { arr = new int [ ] { 4 , 2 , 5 , 1 , 3 , 5 } ; n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
public static double getAvg ( double x , int n , double sum ) { sum = sum + x ; ; return ( double ) sum / n ; }
public static final Set < Integer > MAX = new HashSet < Integer > ( ) { private static final long serialVersionUID = 1L ; { boolean prime [ ] = new boolean [ MAX ] ; prime [ 0 ] = false , prime [ 1 ] = false ; for ( int p = 2 ; p <= 100 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } int product = 1 ; for ( int p = 2 ; p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { product = product * p ; s . add ( product + 1 ) ; } } } private boolean isEuclid ( int n ) { if ( n < s . length ) return true ; else return false ; } }
public static int [ ] getLegs ( ) { String line1 = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ Legs " ) ; String line2 = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ evidence ▁ to ▁ be ▁ searched " ) ; int n = Integer . parseInt ( line1 ) ; int b = Integer . parseInt ( line1 ) ; int [ ] l1 = new int [ line2 . length ( ) ] ; for ( int i = 0 ; i < line2 . length ( ) ; i ++ ) { l1 [ i ] = Integer . parseInt ( line2 . substring ( i ) ) ; } int [ ] l2 = new int [ n ] ; int numOfCuts = 0 ; for ( int i = 0 ; i < l1 . length ; i ++ ) { if ( i != 0 ) { int numOfOds = 0 ; int numOfEvens = 0 ; for ( int j = l1 [ 0 ] ; j < i ; j ++ ) { if ( j % 2 == 0 ) { numOfEvens ++ ; } else { numOfOds ++ ; } } if ( numOfEvens == numOfOds ) { l2 [ i ] = Math . abs ( l1 [ i ] - l1 [ i - 1 ] ) ; } } } Arrays . sort ( l2 ) ; for ( int i = 0 ; i < l2 . length ; i ++ ) { if ( l2 [ i ] <= b ) { numOfCuts ++ ; b -= l2 [ i ] ; } } System . out . println ( numOfCuts ) ; return l2 ; }
public static int maxOperations ( String str ) { int i , g = 0 , gk = 0 , gks = 0 ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( ( str . charAt ( i ) == ' g ' ) || ( str . charAt ( i ) == ' k ' ) ) { g ++ ; } else if ( ( str . charAt ( i ) == ' s ' ) ) { if ( ( g > 0 ) && ( g < gk ) ) { g -- ; gk ++ ; } } else if ( ( str . charAt ( i ) == ' s ' ) ) { if ( ( gk > 0 ) && ( gk < gks ) ) { gk -- ; gks ++ ; } } } return gks ; } if ( Main . isWindows ( ) ) { String a = " ggkssk " ; System . out . println ( maxOperations ( a ) ) ; } return gks ; }
public static int a ( ) { int a = Integer . parseInt ( input ( ) ) ; int [ ] arr = Arrays . stream ( input ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; Arrays . sort ( arr ) ; int c = 0 ; for ( int i = 0 ; i < a - 1 ; i ++ ) { if ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) > 1 ) { c += Math . abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ; } } System . out . println ( c ) ; return a ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) . nextLine ( ) ) ; int m = Integer . parseInt ( input ( ) . nextLine ( ) ) ; int [ ] [ ] students = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = Integer . parseInt ( input ( ) . nextLine ( ) ) ; int b = Integer . parseInt ( input ( ) . nextLine ( ) ) ; students [ a - 1 ] [ i ] = b - 1 ; students [ b - 1 ] [ i ] = a - 1 ; } int [ ] [ ] seen = new int [ n ] [ m ] ; int bench = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 ) { seen [ i ] = new int [ n ] ; if ( students [ i ] . length == 0 || students [ i ] . length == 1 ) continue ; else { int root = i ; int prev = - 1 ; int curr = i ; boolean Finished = false ; int clen = 1 ; while ( ! Finished ) { seen [ curr ] [ i ] = root ; if ( students [ curr ] . length == 1 ) Finished = true ; else { if ( root == students [ curr ] [ 0 ] && root != prev ) { Finished = true ; if ( clen % 2 == 1 ) bench ++ ; } else { if ( students [ curr ] [ 0 ] != prev ) { prev = curr ; clen ++ ; curr = students [ curr ] [ 0 ] ; } else { prev = curr ; curr = students [ curr ] [ 1 ] ; clen ++ ; } } } } } } } if ( ( n - bench ) % 2 == 1 ) System . out . println ( bench + 1 ) ; else System . out . println ( bench ) ; return bench ; }
public static int kthSmallest ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; }
public static void main ( String [ ] args ) { for ( int d = 0 ; d < Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; d ++ ) { n = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; * a = Integer . parseInt ( System . getProperty ( " line . separator " ) ) , * b = new int [ n ] ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( b [ i ] == a [ i ] ) { b [ i ] = b [ i + 1 ] ; } } if ( n == 1 ) { b = new int [ n - 1 ] ; } else if ( b [ b . length - 1 ] == a [ b . length - 1 ] ) { b [ b . length - 1 ] = b [ b . length - 2 ] ; } System . out . println ( * b ) ; } }
public static final EulaLib < Integer > computePrime ( ) { final int START_NUM = 1 ; final int END_NUM = 500 ; final String CROAK_SEQ = " PPPPNNPPPNPPNPN " ; assert 0 <= START_NUM && START_NUM < END_NUM ; assert 1 <= CROAK_SEQ . length ( ) ; final int NUM_JUMPS = CROAK_SEQ . length ( ) - 1 ; final int NUM_TRIALS = 2 * NUM_JUMPS ; int globalnumerator = 0 ; final int [ ] isprime = EulaLib . listPrimality ( END_NUM ) ; for ( int i = START_NUM ; i <= END_NUM ; i ++ ) { for ( int j = 0 ; j < NUM_TRIALS ; j ++ ) { int pos = i ; int trialnumerator = 1 ; if ( isprime [ pos ] == ( CROAK_SEQ . charAt ( 0 ) == ' P ' ) ) trialnumerator *= 2 ; for ( int k = 0 ; k < NUM_JUMPS ; k ++ ) { if ( pos <= START_NUM ) pos ++ ; else if ( pos >= END_NUM ) pos -- ; else if ( ( j > > k ) & 1 == 0 ) pos ++ ; else pos -- ; if ( isprime [ pos ] == ( CROAK_SEQ . charAt ( k + 1 ) == ' P ' ) ) trialnumerator *= 2 ; } globalnumerator += trialnumerator ; } } final int globaldenominator = ( END_NUM + 1 - START_NUM ) * 2 * NUM_JUMPS * 3 * CROAK_SEQ . length ( ) ; final int ans = new Integer ( globalnumerator ) . intValue ( ) ; return String . valueOf ( ans ) ; }
public static final double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) { double lon1 = Math . toRadians ( lon1 ) ; double lon2 = Math . toRadians ( lon2 ) ; double lat1 = Math . toRadians ( lat1 ) ; double lat2 = Math . toRadians ( lat2 ) ; double dlon = lon2 - lon1 ; double dlat = lat2 - lat1 ; double a = Math . sin ( dlat / 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) * Math . sin ( dlon / 2 ) * Math . cos ( dlat ) ; double c = 2 * Math . asin ( Math . sqrt ( a ) ) ; double r = 6371 ; return ( c * r ) ; }
public static int centeredOctahedral ( int n ) { return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) / 3 ; }
public static class Measure { public static final int init ( int init , int stationCount ) { init = init ; stationCount = stationCount ; } public static int clockwise ( int pos ) { return ( stationCount - init + pos ) % stationCount ; } public static int anticlockwise ( int pos ) { return ( stationCount + init - pos ) % stationCount ; } }
public static void SumDivPrime ( int [ ] A , int n ) { int maxVal = Math . max ( A ) + 1 ; boolean [ ] prime = new boolean [ maxVal + 1 ] ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p <= Integer . MAX_VALUE ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = 2 * p ; i <= maxVal + 1 ; i += p ) { prime [ i ] = false ; } } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( prime [ A [ i ] ] ) { sum += A [ i ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { if ( prime [ A [ i ] ] && sum % A [ i ] == 0 ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; }
public static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) { System . out . print ( Integer . toString ( arr [ i % n ] ) + " ▁ " ) ; } arr = new int [ n ] ; arr [ 0 ] = 1 ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; arr [ 3 ] = 7 ; arr [ 4 ] = 9 ; }
public static int closestMultiple ( int n , int x ) { if ( x > n ) return x ; ; int z = ( int ) ( x / 2 ) ; ; n = n + z ; ; n = n - ( n % x ) ; ; return n ; }
for ( ; ; ) { String y = input . nextLine ( ) ; System . out . println ( " cryeadn " . charAt ( Integer . parseInt ( y ) % 3 ) < 1 ? ( ! { * y } & { * '2468' } ) : y . contains ( '0' ) ? y : " " ) ; }
public static int [ ] [ ] [ ] [ ] minimumNumberOfDigits ( int a , int b ) { int [ ] [ ] [ ] dp = new int [ 8101 ] [ ] [ ] ; for ( int i = 0 ; i < 801 ; i ++ ) { dp [ i ] = new int [ 8101 ] ; } int a = a ; int b = b ; if ( ( a > b || a < 0 || b < 0 || a > 900 || b > 8100 ) && ( a == 0 && b == 0 ) ) { return dp [ a ] [ b ] ; } if ( ( a == 0 && b == 0 ) || ( b == 0 && a == 0 ) ) { return dp [ a ] [ b ] ; } int ans = 101 ; for ( int i = 9 ; i > 0 ; i -- ) { int k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) ; if ( ( k != - 1 ) && ( k != 0 ) ) { ans = Math . min ( ans , k + 1 ) ; } } dp [ a ] [ b ] = ans ; return dp ; } public void printSmallestNumber ( int a , int b ) { for ( int i = 0 ; i < 901 ; i ++ ) { for ( int j = 0 ; j < 8101 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } dp [ 0 ] [ 0 ] = 0 ; int k = minimumNumberOfDigits ( a , b ) ; if ( ( k == - 1 ) || ( k > 100 ) ) { System . out . print ( - 1 + " ▁ " ) ; } else { while ( ( a > 0 && b > 0 ) ) { for ( int i = 1 ; i < 10 ; i ++ ) { if ( ( a >= i && b >= i * i && 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) || ( a == 0 && b == 0 ) ) { System . out . print ( i + " ▁ " ) ; a -= i ; b -= i * i ; break ; } } } } }
public static int N = 5005 ; int n , k ; int [ ] [ ] gr = new int [ N ] [ 505 ] ; int [ ] [ ] d = new int [ 505 ] [ N ] ; int ans = 0 ; final int [ ] [ ] Add_edge = new int [ 505 ] [ N ] ; Add_edge ( x , y ) ; gr [ x ] [ y ] = 1 ; gr [ y ] [ x ] = 1 ; dfs ( v , par ) ; ans = 0 ; d [ v ] [ 0 ] = 1 ; for ( int i = 0 ; i < gr [ v ] . length ; i ++ ) { if ( ( i != par ) && ( i != v ) ) { dfs ( i , v ) ; for ( int j = 1 ; j <= k ; j ++ ) ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] ; for ( int j = 1 ; j <= k ; j ++ ) d [ v ] [ j ] += d [ i ] [ j - 1 ] ; } } n = 5 ; k = 2 ; Add_edge ( 1 , 2 ) ; Add_edge ( 2 , 3 ) ; Add_edge ( 3 , 4 ) ; Add_edge ( 2 , 5 ) ; dfs ( 1 , 0 ) ; System . out . println ( ans ) ; return ans ; }
public static int findSubsequence ( int [ ] arr , int n ) { int length = 1 ; ; int [ ] dp = new int [ 10 ] ; ; int tmp = arr [ 0 ] ; ; while ( ( tmp = arr [ tmp % 10 ] ) > 0 ) { dp [ tmp % 10 ] = 1 ; ; tmp /= 10 ; } ; for ( int i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; ; int locMax = 1 ; ; int [ ] cnt = new int [ 10 ] ; ; while ( ( tmp = arr [ tmp % 10 ] ) > 0 ) { cnt [ tmp % 10 ] = 1 ; ; tmp /= 10 ; } ; for ( int d = 0 ; d < 10 ; d ++ ) { if ( ( cnt [ d ] ) > 0 ) { dp [ d ] ++ ; ; locMax = Math . max ( locMax , dp [ d ] ) ; ; } } ; for ( int d = 0 ; d < 10 ; d ++ ) { if ( ( cnt [ d ] ) > 0 ) { dp [ d ] = locMax ; ; } } length = Math . max ( length , locMax ) ; ; } ; return length ; }
public static void main ( String [ ] args ) { for ( ; ; ) { Scanner input = new Scanner ( System . in ) ; System . out . println ( new HashSet < String > ( Arrays . asList ( input . nextLine ( ) . split ( " ▁ " ) ) ) . size ( ) ) ; } }
public static int totalPrimeFactors ( int n ) { int count = 0 ; ; if ( ( ( n % 2 ) == 0 ) && ( ( n % 2 ) == 1 ) ) { count ++ ; while ( ( ( n % 2 ) == 0 ) && ( ( n % 2 ) == 1 ) ) { n /= 2 ; } } int i = 3 ; ; while ( ( i * i <= n ) && ( ( n % i ) == 0 ) ) { if ( ( ( n % i ) == 0 ) && ( ( n % i ) == 1 ) ) { count ++ ; while ( ( ( n % i ) == 0 ) && ( ( n % i ) == 1 ) ) { n /= i ; } } i += 2 ; } ; if ( ( n > 2 ) && ( ( n % G ) != 0 ) ) { count ++ ; } ; return count ; }
public static void calculateSum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; System . out . println ( " Sum ▁ of ▁ multiples ▁ of ▁ " + a + " ▁ up ▁ to ▁ " + N + " ▁ = ▁ " + ans ) ; }
public static void main ( String [ ] args ) { String line [ ] = new String [ 2 ] ; int n = Integer . parseInt ( line [ 0 ] ) , m = Integer . parseInt ( line [ 1 ] ) , k = Integer . parseInt ( line [ 2 ] . substring ( 2 ) ) ; HashMap < String , Integer > skills = new HashMap < String , Integer > ( ) ; for ( ; n > 0 ; n -- ) { line = new String ( line [ 0 ] ) ; skills . put ( line [ 0 ] , Integer . parseInt ( line [ 1 ] ) ) ; } ArrayList < String > newSkills = new ArrayList < String > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { newSkills . add ( new String ( line [ 0 ] ) ) ; } int count = 0 ; ArrayList < String > delete = new ArrayList < String > ( ) ; for ( Map . Entry < String , Integer > entry : skills . entrySet ( ) ) { int value = ( int ) ( k * entry . getValue ( ) / 100 ) ; if ( value < 100 ) { delete . add ( entry . getKey ( ) ) ; } else { skills . put ( entry . getKey ( ) , value ) ; count ++ ; } } for ( String key : delete ) { System . gc ( ) ; } for ( String skill : newSkills ) { if ( skill != null ) { skills . remove ( skill ) ; count ++ ; } } skills = Collections . unmodifiableMap ( skills . values ( ) ) ; System . out . println ( count ) ; for ( Map . Entry < String , Integer > entry : skills . entrySet ( ) ) { System . out . println ( entry . getKey ( ) + " ▁ " + entry . getValue ( ) + " ▁ " ) ; } }
public static int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i < a + 1 ; i ++ ) { if ( ( a == ( i + ( a ^ i ) ) ) && ( i != a ) ) { count ++ ; } } return count ; }
public static int next ( int [ ] arr , int target ) { int start = 0 ; ; int end = arr . length - 1 ; int ans = - 1 ; while ( ( start <= end ) && ( start < end ) ) { int mid = ( start + end ) / 2 ; if ( ( arr [ mid ] <= target ) && ( arr [ mid + 1 ] <= target ) ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; }
public static String [ ] word = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; public static void printWordsWithoutIfSwitch ( int n ) { int [ ] digits = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { digits [ dc ] = n % 10 ; n = n / 10 ; dc ++ ; if ( ( n == 0 ) && ( dc == 0 ) ) break ; } for ( int i = dc - 1 ; i >= 0 ; i -- ) { System . out . print ( word [ digits [ i ] ] + " ▁ " ) ; } n = 350 ; printWordsWithoutIfSwitch ( n ) ; }
from ▁ stdin ▁ to ▁ stdout . STRNEWLINE ▁ */ public static final Function < Integer , Integer > main ( ) { return IntIn . INSTANCE ; }
public static void solve ( String a , String b ) { int l = a . length ( ) ; int min = 0 ; int max = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( a . charAt ( i ) == ' + ' || b . charAt ( i ) == ' + ' || a . charAt ( i ) != b . charAt ( i ) ) && ( a . charAt ( i ) != ' + ' && b . charAt ( i ) != ' + ' && a . charAt ( i ) != b . charAt ( i ) ) ) max ++ ; if ( ( a . charAt ( i ) != ' + ' && b . charAt ( i ) != ' + ' && a . charAt ( i ) != b . charAt ( i ) ) && ( a . charAt ( i ) != ' + ' && b . charAt ( i ) != ' + ' && a . charAt ( i ) != b . charAt ( i ) ) ) min ++ ; } System . out . println ( min + max ) ; if ( Main . isWindows ) { String s1 = " a + c " ; String s2 = " + + b " ; solve ( s1 , s2 ) ; } }
public static int TotalWays ( int n , int s , int k ) { int [ ] dp = new int [ n ] ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = Math . max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
public static int countEvenOdd ( int n ) { int evenCount = 0 ; int oddCount = 0 ; while ( ( n > 0 ) && ( n % 10 == 0 ) ) { int rem = n % 10 ; if ( ( rem % 2 == 0 ) && ( rem % 3 == 0 ) ) { evenCount ++ ; } else { oddCount ++ ; } n = ( int ) ( n / 10 ) ; } System . out . println ( " Even ▁ count ▁ : ▁ " + evenCount ) ; System . out . println ( " \n Odd ▁ count ▁ : ▁ " + oddCount ) ; if ( ( evenCount % 2 == 0 ) && ( oddCount % 2 != 0 ) ) { return 1 ; } else { return 0 ; } }
from . STRNEWLINE ▁ */ public static int combi ( int g , int remain ) { int n = map . get ( g ) , k = map . get ( 0 ) ; int [ ] [ ] books = new int [ 10 ] [ ] ; while ( n -- > 0 ) { int c = map . get ( g ) , g = map . get ( 0 ) ; books [ g - 1 ] [ c ] = c ; n -- ; } int [ ] booksAcc = new int [ books . length + 1 ] [ ] ; booksAcc [ 0 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ] = 0 ; booksAcc [ books . length - 1 ] = 1 ; booksAcc [ books . length - 1 ]
public static int findmin ( int [ ] [ ] p , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( p [ i ] [ 0 ] <= 0 ) && ( p [ i ] [ 0 ] >= 0 ) ) a ++ ; else if ( ( p [ i ] [ 0 ] >= 0 ) && ( p [ i ] [ 1 ] <= 0 ) ) b ++ ; if ( ( p [ i ] [ 1 ] >= 0 ) && ( p [ i ] [ 2 ] <= 0 ) ) c ++ ; else if ( ( p [ i ] [ 1 ] <= 0 ) && ( p [ i ] [ 2 ] >= 0 ) ) d ++ ; } return Math . min ( a , b ) ; }
public static final int maxGCD ( int N , int P ) { int ans = 1 ; HashMap < Integer , Integer > prime_factors = new HashMap < Integer , Integer > ( ) ; for ( int i = 2 ; i <= Integer . MAX_VALUE ; i ++ ) { while ( ( P % i == 0 ) && ( P % i == 1 ) ) { if ( i != 0 ) prime_factors . put ( i , 0 ) ; prime_factors . put ( i , 1 ) ; P /= i ; } } if ( ( P != 1 ) && ( P % i == 1 ) ) prime_factors . put ( P , 1 ) ; for ( Entry < Integer , Integer > entry : prime_factors . entrySet ( ) ) ans *= Math . pow ( entry . getKey ( ) , entry . getValue ( ) / N ) ; return ans ; }
public static int n ( Scanner scanner ) { int k = scanner . nextInt ( ) ; int [ ] b = map . get ( scanner . nextInt ( ) ) ; int t = Arrays . stream ( b ) . mapToInt ( i -> t ) . sum ( ) ; for ( int i = 0 ; i < 1 << k ; i ++ ) { int tmp = 0 ; int [ ] rs = new int [ k ] ; for ( int j = 0 ; j < k ; j ++ ) { if ( scanner . nextInt ( ) & ( 1 << j ) != 0 ) { tmp |= 1 << b [ j ] ; rs [ j ] = b [ j ] ; } } System . out . println ( String . format ( " % d : " , tmp ) + " ▁ " + rs [ k ] ) ; } return k ; }
public static void generateDivisors ( int curIndex , int curDivisor , int [ ] [ ] arr ) { if ( ( curIndex == arr . length ) && ( curDivisor == 0 ) ) { System . out . print ( curDivisor + " ▁ " ) ; return ; } for ( int i = 0 ; i < arr [ curIndex ] . length + 1 ; i ++ ) { generateDivisors ( curIndex + 1 , curDivisor , arr ) ; curDivisor *= arr [ curIndex ] [ 1 ] ; } }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int l [ ] = new int [ 1000010 ] ; for ( ; n > 0 ; n -- ) { int a = Integer . parseInt ( input ( ) . nextLine ( ) ) ; int b = Integer . parseInt ( input ( ) . nextLine ( ) ) ; l [ a ] = b ; } if ( l [ 0 ] > 0 ) dp [ 0 ] = 1 ; int mx = 0 ; for ( int i = 1 ; i < 1000010 ; i ++ ) { if ( ( l [ i ] == 0 ) && ( l [ i - 1 ] == 0 ) ) dp [ i ] = dp [ i - 1 ] ; else { if ( ( l [ i ] >= i ) && ( l [ i ] > i ) ) dp [ i ] = 1 ; ; else dp [ i ] = dp [ i - l [ i ] - 1 ] + 1 ; ; } if ( ( dp [ i ] > mx ) && ( l [ i ] > i ) ) mx = dp [ i ] ; } System . out . println ( n - mx ) ; }
public static String largestPalinSub ( String s ) { String res = " " ; int mx = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { mx = Math . max ( mx , s . charAt ( i ) ) ; } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == mx ) { res += s . charAt ( i ) ; } } return res ; }
public static String convert ( String s ) { String convertStr = " " ; int l = s . length ( ) ; int i = 0 ; while ( i < l ) { if ( i + 1 < l ) { char word = s . charAt ( i ) ; int sequenceNum = 1 ; int j = i + 1 ; while ( j < l ) { if ( ( word == s . charAt ( j ) ) && ( j < l ) ) { sequenceNum ++ ; } else { break ; } j ++ ; } convertStr += Integer . toString ( sequenceNum ) + word ; i = i + sequenceNum - 1 ; } else { convertStr += "1" + Integer . toString ( s . charAt ( i ) ) ; } i ++ ; } return convertStr ; } while ( true ) { try { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ convert " ) ) ; String s = JOptionPane . showInputDialog ( " Enter ▁ a ▁ string ▁ to ▁ convert " ) ; for ( i = 0 ; i <= n ; i ++ ) { s = convert ( s ) ; } System . out . println ( s ) ; } catch ( Exception e ) { break ; } } }
public static int main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] a = Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] d = new int [ 100007 ] ; for ( ; n > 0 ; n -- ) { for ( int i = 0 ; i < a . length ; i ++ ) { if ( j * j > i ) break ; if ( i % j == 0 ) d [ i ] = Math . max ( d [ i ] , d [ i / j ] + 1 , d [ j ] + 1 ) ; } d [ i ] = Math . max ( d [ i ] , 1 ) ; for ( int j = 2 ; j <= i ; j ++ ) { if ( j * j > i ) break ; if ( i % j == 0 ) { d [ i / j ] = d [ i ] ; d [ j ] = d [ i ] ; } } ans = Math . max ( ans , d [ i ] ) ; } System . out . println ( ans ) ; }
public static int [ ] initializeDiffArray ( int [ ] A ) { int n = A . length ; int [ ] D = new int [ n + 1 ] ; D [ 0 ] = A [ 0 ] ; ; D [ n ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { D [ i ] = A [ i ] - A [ i - 1 ] ; } return D ; }
public static void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { Arrays . sort ( arrl ) ; ; Arrays . sort ( exit ) ; ; int guestsIn = 1 ; ; int maxGuests = 1 ; int time = arrl [ 0 ] ; ; int i = 1 ; int j = 0 ; ; while ( ( i < n && j < n ) ) { if ( ( arrl [ i ] <= exit [ j ] ) ) { guestsIn = guestsIn + 1 ; ; if ( ( guestsIn > maxGuests ) ) { maxGuests = guestsIn ; ; time = arrl [ i ] ; } i = i + 1 ; } else { guestsIn = guestsIn - 1 ; ; j = j + 1 ; } } System . out . println ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = " + maxGuests + " at ▁ time " + time ) ; }
public static void lcs ( String x , String y , int preLCS , int preLCSLen ) { Map < Character , Integer > pm = new HashMap < Character , Integer > ( ) ; pm . put ( ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' , new Integer ( 0 ) ) ; for ( char c : pm . keySet ( ) ) { for ( int i = 0 , xc = x . length ( ) ; i < xc ; i ++ ) { if ( x . charAt ( i ) == c ) { pm . put ( c , ( 1 << i ) ) ; } } } int V = ( 1 << x . length ( ) ) - 1 ; ArrayList < String > rec = new ArrayList < String > ( ) ; for ( int yc = 0 ; yc < y . length ( ) ; yc ++ ) { V = ( ( V + ( V & pm . get ( yc ) ) ) | ( V & ~ pm . get ( yc ) ) ) ; rec . add ( bin ( V ) . substring ( x . length ( ) ) ) ; } int lcsLen = bin ( V ) . substring ( x . length ( ) ) . length ( ) ; if ( lcsLen > preLCSLen ) { String rx = x . substring ( 0 , x . length ( ) - 1 ) ; StringBuffer lcs = new StringBuffer ( ) ; int idx = 0 ; for ( String v : rec ) { idx = v . indexOf ( '0' , idx ) ; if ( v . equals ( rx . substring ( idx ) ) ) { lcs . append ( v ) ; if ( lcs . length ( ) == lcsLen ) { return ; } idx ++ ; } } } else { lcs . append ( preLCS ) ; } final Scanner scanner = new Scanner ( System . in ) ; final Scanner fileInput = new Scanner ( System . in ) ; final ArrayList < Integer > ansOut = new ArrayList < Integer > ( ) ; while ( scanner . hasNextLine ( ) ) { String s = scanner . nextLine ( ) ; if ( s . charAt ( 0 ) == ' # ' ) { break ; } int sLen = s . length ( ) ; int sep = sLen / 2 ; int ans = lcs . indexOf ( ' ▁ ' , sep ) ; while ( sep > ansOut . size ( ) ) { ans = lcs . indexOf ( ' ▁ ' , sep ) ; sep -- ; } ans
public static int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = Math . pow ( i , i ) ; int numerator = Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
public static final void isPerfectSquare ( int x ) { int sr = ( int ) Math . sqrt ( x ) ; ; if ( ( sr * sr == x ) && ( sr * sr == x ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
public static int N ( ) { int N = Integer . parseInt ( input ( ) ) ; int [ ] A = new int [ N + i ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = Integer . parseInt ( input ( ) ) * N + i ; } Arrays . sort ( A ) ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int d = ( A [ i ] % N ) % 2 ; if ( d % 2 != i % 2 ) { cnt ++ ; } } System . out . println ( cnt / 2 ) ; }
public static String get ( List < Integer > l ) throws Exception { Collections . sort ( l ) ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) { if ( l . get ( i ) + 1 == l . get ( i ) && l . get ( i ) + 2 == l . get ( i ) ) { return " YES " ; } } return " NO " ; }
static final boolean isSankaku ( int v ) { int x = ( Math . sqrt ( 8 * v + 1 ) - 1 ) / 2 ; return x == Integer . MIN_VALUE ; }
public static int accumulate ( String s ) { int acc = 0 ; ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { acc += ( int ) s . charAt ( i ) - 48 ; ; } return acc ; } public static boolean isDivisible ( String s ) { int n = s . length ( ) ; ; if ( ( s . charAt ( n - 1 ) != '5' && s . charAt ( n - 1 ) != '0' ) || ( s . charAt ( n - 1 ) != '2' && s . charAt ( n - 1 ) != '1' ) ) return false ; ; int sum = accumulate ( s ) ; ; return ( sum % 3 == 0 ) ; } public static String toString ( ) { return "15645746327462384723984023940239" ; } }
public static final EulaLib . Result < String > compute ( ) { final int limit = Integer . MAX_VALUE ; for ( int a = 0 ; a < Integer . MAX_VALUE ; a ++ ) { if ( a * a >= limit ) break ; for ( int b = 1 ; b < Integer . MAX_VALUE ; b ++ ) { if ( ( a + b ) % 2 != 0 ) continue ; int x = ( a * a + b * b ) / 2 ; int y = ( a * a - b * b ) / 2 ; if ( x + y + 1 >= limit ) continue ; int zlimit = Math . min ( y , limit - x - y ) ; for ( int c = 0 ; c < Integer . MAX_VALUE ; c ++ ) { int z = c * c - y ; if ( z >= zlimit ) break ; if ( issquare [ x + z ] && issquare [ x - z ] && issquare [ y - z ] ) return new String ( ) ; } } } return null ; int sumlimit = 10 ; while ( true ) { boolean [ ] issquare = new boolean [ sumlimit ] ; for ( int i = 0 ; i < EulaLib . sqrt ( issquare . length - 1 ) + 1 ; i ++ ) issquare [ i * i ] = true ; Integer sum = findSum ( sumlimit ) ; if ( sum != null ) { sum = sumlimit ; break ; } sumlimit *= 10 ; } while ( true ) { Integer sum = findSum ( sumlimit ) ; if ( sum == null ) return new String ( ) ; sumlimit = sum ; } }
public static boolean isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; } public static void encryptString ( String s , int n , int k ) { int countVowels ; int countConsonants ; String ans = " " ; for ( int l = 0 ; l < n - k + 1 ; l ++ ) { countVowels = 0 ; countConsonants = 0 ; for ( int r = l ; r < l + k ; r ++ ) { if ( ( isVowel ( s . charAt ( r ) ) == true ) && ( s . charAt ( r ) == ' a ' ) ) countVowels ++ ; else countConsonants ++ ; } ans += ( String . valueOf ( countVowels * countConsonants ) ) ; } }
public static int gcd ( int a , int b ) { if ( b == 0 ) return Math . abs ( a ) ; else return gcd ( b , a % b ) ; int N = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; int M = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; String S = System . getProperty ( " line . separator " ) ; String T = System . getProperty ( " line . separator " ) ; if ( S . charAt ( 0 ) != T . charAt ( 0 ) ) { System . out . println ( - 1 ) ; exit ( ) ; } if ( S . length ( ) == T . length ( ) ) { if ( S . equals ( T ) ) System . out . println ( S . length ( ) ) ; else System . out . println ( - 1 ) ; exit ( ) ; } int gcd1 = gcd ( S . length ( ) , T . length ( ) ) ; int lcm = S . length ( ) * T . length ( ) / gcd1 ; int [ ] SS = new int [ N ] ; int [ ] TT = new int [ M ] ; int i = 0 ; int j = 0 ; while ( i < N ) { SS [ i ] = i * lcm / N + 1 ; i ++ ; } while ( j < M ) { TT [ j ] = j * lcm / M + 1 ; j ++ ; } int ind = 0 ; int ind_max = j - 1 ; for ( i = 0 , v = SS [ i ] ; i < ind ; i ++ , v ++ ) { ind = Arrays . binarySearch ( TT , v , ind , j ) ; if ( ind == j ) break ; if ( TT [ ind ] == v ) { if ( S [ i ] == T [ ind ] ) continue ; else { System . out . println ( - 1 ) ; exit ( ) ; } } } System . out . println ( lcm ) ; return lcm ; }
from System . in ; input = new Scanner ( System . in ) . nextLine ( ) . charAt ( 0 ) ; int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; boolean [ ] [ ] black = new boolean [ n + 10 ] [ m ] ; for ( int i = 1 ; i <= m ; i ++ ) { int x = Integer . parseInt ( input . nextLine ( ) ) ; int y = Integer . parseInt ( input . nextLine ( ) ) ; black [ x ] [ y ] = true ; for ( int lx = x - 2 ; lx <= x ; lx ++ ) { for ( int ly = y - 2 ; ly <= y ; ly ++ ) { int cnt = 0 ; for ( int dx = 0 ; dx < 3 ; dx ++ ) { for ( int dy = 0 ; dy < 3 ; dy ++ ) { cnt += black [ lx + dx ] [ ly + dy ] ; } } if ( cnt == 9 ) { System . out . println ( i ) ; System . exit ( ) ; } } } } System . out . println ( - 1 ) ; }
public static int gridLength ( int n , int [ ] [ ] grid ) { String PYDEV = System . getProperty ( " PYDEV " ) ; if ( PYDEV . equals ( " true " ) ) System . setIn ( new FileInputStream ( " sample - input . txt " ) , " rt " ) ; final int gridLength = n ; int L = 0 ; for ( int row : grid ) L = Math . max ( L , Math . max ( new int [ ] { 0 } , grid [ row ] [ 0 ] ) ) ; for ( int c = 0 ; c < n ; c ++ ) { String col = " " + grid [ r ] [ c ] ; L = Math . max ( L , Math . max ( new int [ ] { 0 } , col ) ) ; } for ( int row = - n ; row < 2 * n ; row ++ ) { String diag = " " + grid [ row + c ] [ c ] ; L = Math . max ( L , Math . max ( new int [ ] { 0 } , diag ) ) ; diag = " " + grid [ row - c ] [ c ] ; L = Math . max ( L , Math . max ( new int [ ] { 0 } , diag ) ) ; } return L ; }
static final double fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
public static final int maxLenSub ( int [ ] arr , int n ) { Map < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int maxLen = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int length = 0 ; if ( ( arr [ i ] - 1 ) < um . get ( arr [ i ] - 1 ) && length < um . get ( arr [ i ] - 1 ) ) length = um . get ( arr [ i ] - 1 ) ; if ( arr [ i ] < um . get ( arr [ i ] ) && length < um . get ( arr [ i ] ) ) length = um . get ( arr [ i ] ) ; if ( ( arr [ i ] + 1 ) < um . get ( arr [ i ] ) && length < um . get ( arr [ i ] + 1 ) ) length = um . get ( arr [ i ] + 1 ) ; um . put ( arr [ i ] , length + 1 ) ; if ( maxLen < um . get ( arr [ i ] ) ) maxLen = um . get ( arr [ i ] ) ; } return maxLen ; if ( System . getProperty ( " os . arch " ) . contains ( " sparc " ) ) { arr = Arrays . asList ( 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ) ; n = arr . length ; System . out . println ( " Maximum ▁ length ▁ subsequence ▁ = " + maxLenSub ( arr , n ) ) ; } return 0 ; }
public static void rearrange ( int n ) { arr = new int [ ] { 1 , 3 , 5 , 2 , 4 , 6 } ; synchronized ( arr ) { if ( ( n % 2 == 1 ) && ( n > 0 ) ) return ; int currIdx = ( int ) ( ( n - 1 ) / 2 ) ; while ( ( currIdx > 0 ) && ( n > 0 ) ) { int count = currIdx ; int swapIdx = currIdx ; while ( ( count > 0 ) && ( n > 0 ) ) { int temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx = swapIdx + 1 ; count = count - 1 ; } currIdx = currIdx - 1 ; } } int n = arr . length ; rearrange ( n ) ; for ( int i = 0 ; i <= n ; i ++ ) { System . out . print ( " { } ▁ " . format ( arr [ i ] ) + " ▁ " ) ; } }
static final void main ( String [ ] args ) { final int n = Integer . parseInt ( args [ 0 ] ) ; final int E [ ] = new int [ n ] ; final int S = Integer . parseInt ( args [ 1 ] ) ; final int G = Integer . parseInt ( args [ 2 ] ) ; final int F [ ] = new int [ n ] ; final int H [ ] = new int [ ( n + 1 ) * k ] ; while ( H . length > 0 ) { int c = heappop ( H ) ; if ( u == G ) return ; for ( int f = E [ u ] , v = E [ v ] ; f < n ; f ++ , v ++ ) { int t = c + f ; if ( t < F [ v ] ) { F [ v ] = t ; heappush ( H , ( t ) ) ; } } } return ; } static final void s ( ) { for ( Iterator e = new Iterator ( ) { public boolean hasNext ( ) { return e . hasNext ( ) ; } public Object next ( ) { int n = e . next ( ) . intValue ( ) ; E = new int [ n ] ; for ( ; ; ) { int k = Integer . parseInt ( e . next ( ) . toString ( ) ) ; E [ k ] = 0 ; for ( ; k < k ; k ++ ) { String f = r . next ( ) . toString ( ) ; if ( '0' == f . charAt ( 0 ) ) System . out . println ( g ( n , E , * map ( f . substring ( 2 ) ) ) ) ; else { int c = Integer . parseInt ( f . substring ( 2 ) ) ; E [ c ] += ( e . hasNext ( ) ? e . next ( ) : null ) ; E [ d ] += ( e . hasNext ( ) ? e . next ( ) : null ) ; E [ c ] += ( e . hasNext ( ) ? e . next ( ) : null ) ; E [ d ] += ( e . hasNext ( ) ? e . next ( ) : null ) ; } } } } } ; }
public static void countCharacterType ( String str ) { int vowels = 0 ; int consonant = 0 ; int specialChar = 0 ; int digit = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) && ( ch != ' ▁ ' ) ) { ch = ch . toLowerCase ( ) ; if ( ( ch == ' a ' || ch == ' e ' || ch == ' i ' || ch == ' o ' || ch == ' u ' ) ) { vowels ++ ; } else { consonant ++ ; } } else if ( ( ch >= '0' && ch <= '9' ) || ( ch == ' a ' && ch <= ' z ' ) ) { digit ++ ; } else { specialChar ++ ; } } System . out . println ( " Vowels : " + vowels ) ; System . out . println ( " Consonant : " + consonant ) ; System . out . println ( " Digit : " + digit ) ; System . out . println ( " Special ▁ Character : " + specialChar ) ; }
public static int increaseInVol ( int l , int b , int h ) { int percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ) ; percentInc -- ; percentInc *= 100 ; return percentInc ; }
public static int MaxTotalRectangleArea ( int [ ] a , int n ) { Arrays . sort ( a , 0 , n ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; int i = 0 ; while ( ( i < n - 1 ) && ( i < n ) ) { if ( ( i != 0 ) && ( i < n ) ) i = i + 1 ; if ( ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == false ) || ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == true ) ) { flag = true ; len = a [ i + 1 ] ; i = i + 1 ; } else if ( ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == true ) || ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == false ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i = i + 1 ; } } return sum ; }
public static final void main ( String [ ] args ) { final Node node = new Node ( ) ; node . data = data ; node . next = null ; } public static Node getNode ( String data ) { Node newNode = new Node ( data ) ; newNode . data = data ; return newNode ; } public static Node insertEnd ( Node head , Node newNode ) { if ( ( head == null ) || ( head . next == null ) ) { newNode . next = newNode ; newNode . prev = newNode ; head = newNode ; return head ; } Node last = head . prev ; newNode . next = head ; head . prev = newNode ; newNode . prev = last ; last . next = newNode ; return head ; } public static Node reverse ( Node head ) { if ( ( head == null ) || ( head . next == null ) ) return null ; Node newHead = null ; Node last = head . prev ; Node curr = last ; while ( ( curr . prev != last ) && ( curr . next != head ) ) { Node prev = curr . prev ; newHead = insertEnd ( newHead , curr ) ; curr = prev ; } newHead = insertEnd ( newHead , curr ) ; return newHead ; } public void display ( Node head ) { if ( ( head == null ) || ( head . next == null ) ) return ; Node temp = head ; System . out . print ( " Forward ▁ direction : ▁ " ) ; while ( ( temp . next != head ) && ( temp . data != null ) ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . next ; } System . out . print ( temp . data ) ; Node last = head . prev ; temp = last ; System . out . print ( " Backward ▁ direction : ▁ " ) ; while ( ( temp . prev != last ) && ( temp . data != null ) ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . prev ; } System . out . print ( temp . data ) ; } }
public static void lastFiveDigits ( int n ) { n = ( ( int ) ( n / 10000 ) * 10000 + ( ( int ) ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( int ) ( n / 10 ) % 10 ) * 10 + ( ( int ) ( n / 1000 ) % 10 ) ) ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } System . out . println ( ans ) ; }
public static String compute ( ) { final int DIGITS = 100 ; final double MULTIPLIER = 100 * DIGITS ; int ans = Double . valueOf ( String . valueOf ( EulerLib . sqrt ( i * MULTIPLIER ) ) . substring ( 0 , DIGITS ) ) ; return String . valueOf ( ans ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( compute ( ) ) ; } return String . valueOf ( ans ) ; }
public static void evaluate ( int n ) { if ( ( n == 1 || n == 2 ) && ( n == 3 ) ) { System . out . println ( " No ▁ Pythagoras " + " ▁ Triplet ▁ exists " ) ; ; } else if ( ( n % 2 == 0 ) && ( n == 3 ) ) { int var = n * n / 4 ; ; System . out . print ( " Pythagoras ▁ Triplets " + " ▁ exist ▁ i . e . ▁ " ) ; ; System . out . println ( Integer . toString ( n ) + " ▁ " + Integer . toString ( var - 1 ) + " ▁ " + Integer . toString ( var + 1 ) ) ; } else if ( ( n % 2 != 0 ) && ( n == 3 ) ) { int var = n * n + 1 ; ; System . out . print ( " Pythagoras ▁ Triplets ▁ " + " exist ▁ i . e . ▁ " ) ; ; System . out . println ( Integer . toString ( n ) + " ▁ " + Integer . toString ( var / 2 - 1 ) + " ▁ " + Integer . toString ( var / 2 ) ) ; } }
public static int [ ] abx ( ) { List < Integer > abx = Arrays . asList ( Integer . parseInt ( System . in ) ) ; final int a = abx . get ( 0 ) ; final int b = abx . get ( 1 ) ; return new int [ ] { b - a } ; }
public static int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) return b ; return gcd ( b % a , a ) ; } public static final int findNumber ( int [ ] arr , int n ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i != n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( int i = 0 ; i != n ; i ++ ) if ( ( arr [ i ] == ans ) && ( arr [ i ] != ans ) ) return ans ; return - 1 ; } int [ ] arr = { 2 , 2 , 4 } ; ; int n = arr . length ; System . out . println ( findNumber ( arr , n ) ) ; }
public static int countKdivPairs ( int [ ] A , int n , int K ) { int [ ] freq = new int [ K ] ; for ( int i = 0 ; i < K ; i ++ ) { freq [ i ] = 0 ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int rem = A [ i ] % K ; if ( ( rem != 0 ) && ( rem != 1 ) ) { ans += freq [ K - rem ] ; } else { ans += freq [ 0 ] ; } freq [ rem ] ++ ; } return ans ; }
public static void print ( String input ) { System . out . print ( input . replace ( " , " , " ▁ " ) ) ; }
private static final Scanner _input = new Scanner ( System . in ) { public int nextInt ( ) { return Integer . parseInt ( System . in . nextLine ( ) ) ; } public void nextLine ( ) { int n = Integer . parseInt ( System . in . nextLine ( ) ) ; List < Integer > lst = Arrays . asList ( _input ( ) ) ; if ( lst . get ( 0 ) != lst . get ( lst . size ( ) - 1 ) ) { System . out . println ( n - 1 ) ; } else { int i = 1 ; while ( i < n && lst . get ( i ) == lst . get ( 0 ) ) { i ++ ; } int j = n - 2 ; while ( j >= 0 && lst . get ( j ) == lst . get ( 0 ) ) { j -- ; } System . out . println ( Math . max ( n - i - 1 , j ) ) ; } } }
public static int countSubarrays ( int [ ] arr , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hashPositive = new int [ n + 1 ] ; int [ ] hashNegative = new int [ n + 1 ] ; hashPositive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 == 1 ) && ( hashPositive [ i ] == 0 ) ) { difference = difference + 1 ; } else { difference = difference - 1 ; } if ( ( difference < 0 ) && ( hashNegative [ - difference ] == 0 ) ) { ans += hashNegative [ - difference ] ; hashNegative [ - difference ] = hashNegative [ - difference ] + 1 ; } else { ans += hashPositive [ difference ] ; hashPositive [ difference ] = hashPositive [ difference ] + 1 ; } } return ans ; }
public static void SIZE ( String string , int n ) { int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i <= n ; i ++ ) freq [ ( char ) string . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( freq [ ( char ) string . charAt ( i ) - ' a ' ] % 2 == 0 ) && ( freq [ ( char ) string . charAt ( i ) - ' a ' ] % 2 == 1 ) ) System . out . print ( string . charAt ( i ) + " ▁ " ) ; }
static final public void printChar ( String str_ , int n ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ ( int ) str_ . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) if ( ( freq [ ( int ) str_ . charAt ( i ) - ' a ' ] ) % 2 == 1 ) System . out . print ( " { } " . format ( str_ . charAt ( i ) ) + " ▁ " ) ; }
public static int countGreater ( int [ ] arr , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( ( l <= r ) && ( l < n ) ) { int m = ( int ) ( l + ( r - l ) / 2 ) ; if ( ( arr [ m ] > k ) && ( arr [ m ] > k ) ) { leftGreater = m ; r = m - 1 ; } else { l = m + 1 ; } } return ( n - leftGreater ) ; }
n , m ) public static int [ ] [ ] [ ] [ ] [ ] [ ] [ ] getN ( int [ ] [ ] [ ] input ) { if ( m == 1 ) { System . out . println ( 2 * n % 1000000 ) ; } else { int [ ] [ ] [ ] [ ] [ ] [ ] dp = new int [ 3 ] [ 3 ] [ 3 ] [ 3 ] ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int y = 0 ; y < n ; y ++ ) { for ( int x = 0 ; x < 3 ; x ++ ) { for ( int slideLimit = 0 ; slideLimit < y + 1 ; slideLimit ++ ) { if ( x == 0 ) { dp [ y + 1 ] [ 0 ] [ slideLimit ] += dp [ y ] [ 0 ] [ slideLimit ] ; dp [ y + 1 ] [ 1 ] [ y + 1 ] += dp [ y ] [ 0 ] [ slideLimit ] ; dp [ y + 1 ] [ 2 ] [ y + 1 ] += dp [ y ] [ 0 ] [ slideLimit ] * ( y - slideLimit + 1 ) ; } if ( x == 1 ) { dp [ y + 1 ] [ 0 ] [ y + 1 ] += dp [ y ] [ 1 ] [ slideLimit ] ; dp [ y + 1 ] [ 1 ] [ slideLimit ] += dp [ y ] [ 1 ] [ slideLimit ] ; dp [ y + 1 ] [ 2 ] [ y + 1 ] += dp [ y ] [ 1 ] [ slideLimit ] ; } if ( x == 2 ) { dp [ y + 1 ] [ 0 ] [ y + 1 ] += dp [ y ] [ 2 ] [ slideLimit ] * ( y - slideLimit + 1 ) ; dp [ y + 1 ] [ 1 ] [ y + 1 ] += dp [ y ] [ 2 ] [ slideLimit ] ; dp [ y + 1 ] [ 2 ] [ slideLimit ] += dp [ y ] [ 2 ] [ slideLimit ] ; } } } } System . out . println ( ( Arrays . hashCode ( dp [ n ] ) + Arrays . hashCode ( dp [ n ] ) ) % 1000000 ) ; } return dp ; }
public static final void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( ( val < 0 ) || ( val > N ) ) { System . out . println ( " NO " ) ; return ; } double a = ( N + Math . sqrt ( val ) ) / 2.0 ; double b = ( N - Math . sqrt ( val ) ) / 2.0 ; System . out . println ( " a ▁ = " + ' { 0 : . 6 } ' + ' { ' + a + ' } ' + ' { ' + b + ' } ' ) ; if ( System . getProperty ( " os . arch " ) . equals ( " x86" ) ) { N = 69.0 ; findAandB ( N ) ; } }
public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; for ( ; ; ) { int n = input . nextInt ( ) ; int c = 0 , d = 10 * 9 ; for ( ; n > 0 ; n -- ) { int a = map . get ( input . nextInt ( ) ) ; int b = map . get ( input . nextInt ( ) ) ; if ( a > c ) c = a ; if ( b < d ) d = b ; } if ( c <= d ) System . out . println ( 0 ) ; else System . out . println ( c - d ) ; } }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( System . in . readLine ( ) ) ; int m = Integer . parseInt ( System . in . readLine ( ) ) ; ArrayList < String > ans = new ArrayList < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = System . in . readLine ( ) ; Set < String > x = new HashSet < String > ( s ) ; if ( " X " . equals ( x ) ) ans . add ( s ) ; } ArrayList < String > ans2 = new ArrayList < String > ( ) ; Iterator < String > a = zip ( ans ) ; while ( a . hasNext ( ) ) { String i = a . next ( ) ; Set < String > x = new HashSet < String > ( i ) ; if ( " X " . equals ( x ) ) ans2 . add ( i ) ; } final String f = ans2 . get ( ans2 . size ( ) - 1 ) ; for ( String i : ans2 ) { if ( " . " . equals ( i ) ) { System . out . println ( " NO " ) ; } } System . out . println ( f ) ; }
public static void main ( String [ ] args ) { int A = Integer . parseInt ( args [ 0 ] ) ; int B = Integer . parseInt ( args [ 1 ] ) ; int C = Integer . parseInt ( args [ 2 ] ) ; int [ ] before = { 1 , 0 , 0 } ; int N = A . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] dp = new int [ 3 ] ; int s = 0 ; if ( i == N - 1 ) s ++ ; for ( int j = 0 ; j < 3 ; j ++ ) { for ( int a = s ; a < 10 ; a ++ ) { if ( A [ i ] != ' ? ' && Integer . parseInt ( A [ i ] ) != a ) continue ; for ( int b = s ; b < 10 ; b ++ ) { if ( B [ i ] != ' ? ' && Integer . parseInt ( B [ i ] ) != b ) continue ; for ( int c = s ; c < 10 ; c ++ ) { if ( C [ i ] != ' ? ' && Integer . parseInt ( C [ i ] ) != c ) continue ; if ( ( j + a + b ) % 10 != c ) continue ; dp [ ( j + a + b ) / 10 ] += before [ j ] ; dp [ ( j + a + b ) / 10 ] %= MOD ; } } } } before = dp ; } int ans = before [ 0 ] ; System . out . println ( ans ) ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int test = Integer . parseInt ( input ( ) ) ; int move = 0 ; while ( test != 1 ) { if ( test % 6 == 0 ) { test = test / 6 ; move ++ ; } else if ( test % 3 == 0 ) { test = test * 2 ; move ++ ; } else { System . out . println ( - 1 ) ; break ; } } else { System . out . println ( move ) ; } } return n ; }
public static final int minIncrementForUnique ( int [ ] A ) { int [ ] count = new int [ A . length ] ; Arrays . fill ( count , 1 ) ; List < Integer > taken = new ArrayList < Integer > ( ) ; int ans = 0 ; for ( int x = 0 ; x < 100000 ; x ++ ) { if ( count [ x ] >= 2 ) { taken . addAll ( Arrays . asList ( A ) ) ; } else if ( taken . size ( ) > 0 && count [ x ] == 0 ) { ans += x - taken . remove ( x ) ; } } return ans ; }
n = Integer . parseInt ( input . nextLine ( ) ) ; n -- ; if ( n < 0 ) n = 0 ; System . out . println ( ( 3 * ( n ) ) % 1000003 ) ; }
static final public int modulo_13 ( String s , int n ) { int MOD = ( int ) ( 1e9 + 7 ) ; int [ ] [ ] dp = new int [ n + 1 ] [ 13 ] ; ; dp [ 0 ] [ 0 ] = 1 ; ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int nxt = ( char ) ( s . charAt ( i ) - '0' ) ; ; if ( ( s . charAt ( i ) == ' ? ' ) || ( s . charAt ( i ) == ' ! ' ) ) nxt = j ; ; for ( int k = 0 ; k < 13 ; k ++ ) { int rem = ( 10 * k + nxt ) % 13 ; ; dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; ; dp [ i + 1 ] [ rem ] %= MOD ; ; } if ( ( s . charAt ( i ) != ' ? ' ) || ( s . charAt ( i ) == ' ! ' ) ) break ; ; } } return ( int ) ( dp [ n ] [ 5 ] ) ; }
public static final int countNums ( int a , int b , int c , int d ) { int x = b / c - ( a - 1 ) / c ; ; int y = b / d - ( a - 1 ) / d ; ; int k = ( c * d ) / gcd ( c , d ) ; ; int z = b / k - ( a - 1 ) / k ; ; return ( b - a + 1 - x - y + z ) ; }
public static void main ( String [ ] args ) { int s = ( int ) Math . log10 ( args [ 0 ] ) ; ; int d = ( int ) Math . pow ( 10 , s ) ; int k = d ; ; while ( ( n > 0 ) && ( d > 0 ) ) { while ( ( d > 0 ) && ( k > 0 ) ) { System . out . println ( ( int ) ( n / d ) ) ; ; d = ( int ) ( d / 10 ) ; ; } n = ( int ) ( n % k ) ; k = ( int ) ( k / 10 ) ; ; d = k ; ; } if ( args . length == 0 ) { n = 123 ; printSubstrings ( n ) ; } }
public static String NthCharacter ( int n ) { String s = " " ; int c = 1 ; while ( ( true ) && ( c < 10 ) ) { if ( ( c < 10 ) || ( c > 11 ) ) { s += ( char ) ( 48 + c ) ; } else { String s1 = " " ; int dup = c ; while ( ( dup > 0 ) && ( ( dup % 10 ) != 0 ) ) { s1 += ( char ) ( ( dup % 10 ) + 48 ) ; dup /= 10 ; } s1 = " " + ( char ) ( ( dup % 10 ) + 48 ) ; s += s1 ; } c ++ ; if ( ( s . length ( ) >= n ) && ( s . charAt ( n - 1 ) == ' ▁ ' ) ) { return s . charAt ( n - 1 ) ; } } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " linux " ) ) { n = 11 ; System . out . println ( NthCharacter ( n ) ) ; } return s ; }
public static int days ( int y , int m , int d ) { int cnt = 0 ; for ( int i = 1 ; i <= y ; i ++ ) { if ( i % 3 == 0 ) cnt += 200 ; else cnt += 195 ; } for ( int i = 1 ; i <= m ; i ++ ) { if ( y % 3 == 0 ) cnt += 20 ; else { if ( i % 2 == 0 ) cnt += 19 ; else cnt += 20 ; } } cnt += d - 1 ; return cnt ; }
public static boolean checkPrime ( int n ) { if ( ( n <= 1 ) || ( n <= 3 ) ) return false ; if ( ( n % 2 == 0 || n % 3 == 0 ) ) return false ; for ( int i = 5 ; i <= n ; i += 6 ) { if ( ( n % i == 0 || n % ( i + 2 ) == 0 ) ) return false ; } return true ; } public static final int countPrimeFrequent ( String s ) { int count = 0 ; HashMap < String , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i <= s . length ( ) ; i ++ ) { mp . put ( s . charAt ( i ) , 0 ) ; mp . put ( s . charAt ( i ) , ++ count ) ; } for ( String i : mp . keySet ( ) ) { if ( ( checkPrime ( mp . get ( i ) ) ) ) count ++ ; } ; String s = " geeksforgeeks " ; System . out . println ( countPrimeFrequent ( s ) ) ; return count ; }
public static final Comparator < Integer > COMPARATOR = new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return o1 . compareTo ( o2 ) ; } }
public static int catalan ( int n ) { if ( ( n == 0 || n == 1 ) && ( n > 0 ) ) return 1 ; int catalan [ ] = new int [ n + 1 ] ; catalan [ 0 ] = 1 ; catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { catalan [ i ] = catalan [ i ] + catalan [ j ] * catalan [ i - j - 1 ] ; } } return catalan [ n ] ; }
public static final EulaLib compute ( ) { final Fraction TARGET = new Fraction ( 15499 , 94744 ) ; double totient = 1 ; double denominator = 1 ; int p = 2 ; while ( true ) { totient *= p - 1 ; denominator *= p ; while ( true ) { p ++ ; if ( EulaLib . isPrime ( p ) ) break ; } if ( Fraction . valueOf ( totient ) < TARGET ) { for ( int i = 1 ; i <= p ; i ++ ) { double numer = i * totient ; double denom = i * denominator ; if ( Fraction . valueOf ( numer ) < TARGET ) return String . valueOf ( denom ) ; } } } if ( System . getSecurityManager ( ) == null ) System . out . println ( compute ( ) ) ; return null ; }
public static final void main ( String [ ] args ) { final String path = input ( ) ; final Set < Integer > coord = new HashSet < Integer > ( ) ; coord . add ( ( Integer ) 0 ) ; ; Integer temp = ( Integer ) 0 ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { if ( path . charAt ( i ) == ' L ' ) { temp = ( temp . intValue ( ) ) ; } else if ( path . charAt ( i ) == ' R ' ) { temp = ( temp . intValue ( ) ) ; } else if ( path . charAt ( i ) == ' U ' ) { temp = ( temp . intValue ( ) - 1 ) ; } else { temp = ( temp . intValue ( ) + 1 ) ; } if ( temp == coord . size ( ) ) { System . out . println ( " BUG " ) ; exit ( ) ; } coord . add ( temp ) ; } coord . remove ( ( Integer ) 0 ) ; final Deque < Integer > que = new LinkedList < Integer > ( ) ; que . add ( ( Integer ) 0 ) ; while ( que . size ( ) > 0 ) { if ( que . size ( ) > 1 ) { System . out . println ( " BUG " ) ; exit ( ) ; } int i = que . removeFirst ( ) ; int j = que . removeFirst ( ) ; for ( int p = i + 1 ; p < j ; p ++ ) { if ( ( p < coord . size ( ) ) && ( q < coord . size ( ) ) ) { coord . remove ( ( Integer ) p ) ; que . add ( ( Integer ) q ) ; } } } System . out . println ( " OK " ) ; }
public static final boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n == 2 ) return true ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i < Integer . MAX_VALUE ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; } public static boolean isPossible ( int n ) { if ( isPrime ( n ) && isPrime ( n - 2 ) ) return true ; else return false ; } public static int n = 13 ; if ( isPossible ( n ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; return n ; }
public static int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ entered " ) ) ; i ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ be ▁ entered " ) ) ; if ( ( n <= 30 ) && ( n > 40 ) && ( n > 36 ) && ( n > 44 ) ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; if ( ( n == 40 || n == 36 || n == 44 ) && ( n == 40 || n == 36 || n == 44 ) ) { System . out . println ( "6 ▁ 10 ▁ 15 ▁ " + n - 31 ) ; } else { System . out . println ( "6 ▁ 10 ▁ 14" + n - 30 ) ; } } } }
public static final int [ ] solve ( String string ) { int n , * a ; n = Integer . parseInt ( string . substring ( 1 ) ) ; a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( string . substring ( i ) ) ; } if ( System . getSecurityManager ( ) == null ) { System . out . println ( solve ( " \n " , input -> input ) ) ; } return a ; }
public static int [ ] copy ( int [ ] a ) { int ans = 0 ; for ( int i = 0 ; i <= 14 ; i ++ ) { int [ ] x = Arrays . copyOf ( a , 14 ) ; int n = a [ i ] / 14 ; int r = a [ i ] % 14 ; x [ i ] = 0 ; for ( int j = 0 ; j <= 14 ; j ++ ) x [ j ] += n ; if ( r >= 13 - i ) { for ( int j = i + 1 ; j < 14 ; j ++ ) x [ j ] += 1 ; for ( int j = 0 ; j <= r - 13 + i ; j ++ ) x [ j ] += 1 ; } else { for ( int j = i + 1 ; j < i + 1 + r ; j ++ ) x [ j ] += 1 ; } int summ = 0 ; for ( int j : x ) if ( j % 2 == 0 ) summ += j ; ans = Math . max ( ans , summ ) ; } System . out . println ( ans ) ; return x ; }
public static double pentdiagonal ( double a ) { if ( ( a < 0 ) || ( a > 1 ) ) return - 1 ; double d = 1.22 * a ; return d ; }
public static int hexDiagonal ( int a ) { if ( ( a < 0 ) || ( a > 9 ) ) return - 1 ; ; double d = 1.73 * a ; ; return d ; }
public static void translate ( String st ) { int l = st . length ( ) ; if ( ( l < 2 ) || ( l > 3 ) ) return ; int i = 0 ; int j = 0 ; while ( ( j < l - 1 ) && ( st . charAt ( j ) == ' A ' ) ) { j += 2 ; st . charAt ( i ) = ' C ' ; i ++ ; continue ; } st . charAt ( i ) = st . charAt ( j ) ; i ++ ; j ++ ; }
public static void translate ( String st ) { for ( int i = 1 ; i < st . length ( ) ; i ++ ) { if ( ( st . charAt ( i - 1 ) == ' A ' && st . charAt ( i ) == ' B ' ) || ( st . charAt ( i ) == ' C ' ) ) { st . charAt ( i - 1 ) = ' C ' ; for ( int j = i ; j < st . length ( ) - 1 ; j ++ ) { st . charAt ( j ) = st . charAt ( j + 1 ) ; } st . charAt ( st . length ( ) - 1 ) = ' ▁ ' ; } } return ; }
public static final EulaLib < Integer > PIERE = new EulaLib < Integer > ( ) { @ Override public String compute ( ) { final int TARGET = 2000 ; int count = 2 ; for ( int ring = 0 ; ring < 2 ; ring ++ ) { if ( Arrays . equals ( RingUtils . isPrime ( ring * 6 - 1 , ring * 6 + 1 , ring * 12 + 5 ) , RingUtils . isPrime ( ring * 6 - 1 , ring * 6 + 5 , ring * 12 - 7 ) ) ) { count ++ ; if ( count == TARGET ) { return String . valueOf ( ring * ( ring - 1 ) * 3 + 2 ) ; } } if ( Arrays . equals ( RingUtils . isPrime ( ring * 6 - 1 , ring * 6 + 5 , ring * 12 - 7 ) , RingUtils . isPrime ( ring * 6 - 1 , ring * 6 + 5 , ring * 12 - 7 ) ) ) { count ++ ; if ( count == TARGET ) { return String . valueOf ( ring * ( ring + 1 ) * 3 + 1 ) ; } } } return null ; } }
public static List < Pair < Integer , Integer > > findLens ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int x = Math . min ( n , m ) ; List < Pair < Integer , Integer > > li = new ArrayList < Pair < Integer , Integer > > ( ) ; for ( int i = 0 ; i < x + 1 ; i ++ ) { int x1 = Math . pow ( i , 2 ) ; for ( int j = 0 ; j < x + 1 ; j ++ ) { int y1 = Math . pow ( j , 2 ) ; if ( ( x1 + j == n && i + y1 == m ) || ( x1 + j == m && i + y1 == n ) ) li . add ( new Pair < Integer , Integer > ( i , j ) ) ; } } System . out . println ( li . size ( ) ) ; return li ; }
public static void Digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( ( n > 0 ) && ( n % 10 == 0 ) ) { int r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = n / 10 ; } System . out . println ( largest + " ▁ " + smallest ) ; }
public static void solve ( int d1 , int d2 , int d3 ) { int maxx = Math . max ( d1 , Math . max ( d2 , d3 ) ) ; int sum = ( d1 + d2 + d3 ) ; if ( ( 2 * maxx > sum || sum % 2 == 1 ) ) { System . out . println ( " - 1" ) ; return ; } }
public static boolean distributingBalls ( int k , int n , String string ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) a [ ( char ) string . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( ( a [ i ] > k ) && ( a [ i ] < n ) ) return false ; return true ; }
public static void main ( String [ ] args ) { for ( ; ; ) { int N = Integer . parseInt ( System . in . readLine ( ) ) ; String S = System . in . readLine ( ) ; int ctr = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == ' T ' ) ctr ++ ; else ctr -- ; if ( ctr > N / 3 || ctr < 0 ) break ; } System . out . println ( ctr == N / 3 ? " YES " : " NO " ) ; } }
e = Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . filter ( e -> e . length == 4 ) . findFirst ( ) . orElse ( false ) ; e . forEach ( e -> { } ) ; }
public static final int [ ] [ ] rowWith0s ( int [ ] arr , int low , int high ) { int R = 4 ; int C = 4 ; int first = 0 ; if ( ( high >= low ) && ( low <= high ) ) { int mid = low + ( high - low ) / 2 ; ; if ( ( ( mid == 0 || arr [ mid - 1 ] == 0 ) && arr [ mid ] == 1 ) || ( ( arr [ mid ] == 0 ) && arr [ mid + 1 ] == 0 ) ) { return new int [ ] [ ] { { mid } } ; } else if ( ( arr [ mid ] == 0 ) || ( arr [ mid + 1 ] == 0 ) ) { return new int [ ] [ ] { { first , ( mid + 1 ) , high } } ; } else { return new int [ ] [ ] { { first , low , ( mid - 1 ) } } ; } } return new int [ ] [ ] { { - 1 , - 1 , - 1 } } ; }
static final public int bitAtGivenPosSetOrUnset ( int n , int k ) { int newNum = n > > > ( k - 1 ) ; return ( newNum & 1 ) ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) ; List < Character > s = Arrays . asList ( " A " , " G " , " C " , " T " ) ; if ( n % 4 == 0 ) { int k = n / 4 ; int a = s . indexOf ( ' A ' ) ; int b = s . indexOf ( ' G ' ) ; int c = s . indexOf ( ' C ' ) ; int d = s . indexOf ( ' T ' ) ; if ( a > k || b > k || c > k || d > k ) { System . out . println ( " = = = " ) ; } else { for ( int i = 0 ; i < k - a ; i ++ ) { s . set ( s . indexOf ( ' ? ' ) , ' A ' ) ; } for ( int j = 0 ; j < k - b ; j ++ ) { s . set ( s . indexOf ( ' ? ' ) , ' G ' ) ; } for ( int m = 0 ; m < k - c ; m ++ ) { s . set ( s . indexOf ( ' ? ' ) , ' C ' ) ; } for ( int t = 0 ; t < k - d ; t ++ ) { s . set ( s . indexOf ( ' ? ' ) , ' T ' ) ; } System . out . println ( s ) ; } } else { System . out . println ( " = = = " ) ; } }
public static int [ ] [ ] mv ( int [ ] [ ] mv ) { int [ ] [ ] mv = new int [ ] [ ] { { - 1 , 0 } , { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } } ; while ( true ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ n ▁ of ▁ the ▁ vector : ▁ " ) ) ; if ( n == 0 ) break ; int t1 = JOptionPane . showInputDialog ( " Enter ▁ t ▁ of ▁ the ▁ vector : ▁ " ) ; int t2 = JOptionPane . showInputDialog ( " Enter ▁ v ▁ of ▁ the ▁ vector : ▁ " ) ; int t3 = JOptionPane . showInputDialog ( " Enter ▁ c ▁ of ▁ the ▁ vector : ▁ " ) ; int s = ( int ) t1 - ( int ) ' A ' ; int t = ( int ) t2 - ( int ) ' A ' ; int b = ( int ) t3 - ( int ) ' A ' ; int [ ] [ ] f = new int [ 17 ] [ 3 ] ; for ( int r = 0 ; r < 3 ; r ++ ) f [ 0 ] [ s / 3 ] [ s % 3 ] = 1 ; for ( int j = 1 ; j < n ; j ++ ) { for ( int r = 0 ; r < 3 ; r ++ ) { for ( int c = 0 ; c < 3 ; c ++ ) { for ( int i = 0 ; i < 4 ; i ++ ) { int r2 = r + mv [ i ] [ 0 ] ; int c2 = c + mv [ i ] [ 1 ] ; if ( r2 < 0 || r2 >= 3 || c2 < 0 || c2 >= 3 || 3 * r2 + c2 == b ) r2 = r ; c2 = c ; } f [ j ] [ r2 ] [ c2 ] += f [ j - 1 ] [ r ] [ c ] / 4 ; } } } } System . out . println ( f [ n ] [ t / 3 ] [ t % 3 ] ) ; return mv ; }
public static Set < Integer > test ( ) { int l = 0 , r = 0 ; int result = 0 ; for ( int x = 0 ; x < 31 ; x ++ ) { for ( int y = 0 ; y < 20 ; y ++ ) { int v = 2 * x * 3 * y ; if ( l <= v && v <= r ) { result ++ ; } } } System . out . println ( result ) ; return result ; }
static int N = map . size ( ) , K = map . size ( ) ; ; int L = 1 ; for ( int i = 0 ; i < N ; i ++ ) { L += Math . min ( L , K ) ; } System . out . println ( L ) ; }
public static boolean arePermutations ( int [ ] a , int [ ] b , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }
public static void MAX_CHAR = 26 ; public static void findAndPrintUncommonChars ( String str1 , String str2 ) { int [ ] present = new int [ MAX_CHAR ] ; for ( int i = 0 ; i <= MAX_CHAR ; i ++ ) present [ i ] = 0 ; int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; i <= l1 ; i ++ ) present [ Character . digit ( str1 . charAt ( i ) , 10 ) - Character . digit ( str2 . charAt ( i ) , 10 ) ] = 1 ; for ( int i = 0 ; i <= l2 ; i ++ ) { if ( ( present [ Character . digit ( str2 . charAt ( i ) , 10 ) - Character . digit ( str1 . charAt ( i ) , 10 ) ] == 1 || present [ Character . digit ( str2 . charAt ( i ) , 10 ) - Character . digit ( str1 . charAt ( i ) , 10 ) ] == - 1 ) && ( present [ Character . digit ( str2 . charAt ( i ) , 10 ) - Character . digit ( str1 . charAt ( i ) , 10 ) ] == 2 ) ) { present [ Character . digit ( str2 . charAt ( i ) , 10 ) ] = - 1 ; } else { present [ Character . digit ( str2 . charAt ( i ) , 10 ) ] = 2 ; } } for ( int i = 0 ; i <= MAX_CHAR ; i ++ ) { if ( ( present [ i ] == 1 || present [ i ] == 2 ) && ( present [ i ] == - 1 ) ) System . out . print ( ( char ) ( i + Character . digit ( str1 . charAt ( i ) , 10 ) ) ) ; } }
public static boolean isInside ( int circleX , int circleY , int rad , int x , int y ) { if ( ( ( x - circleX ) * ( x - circleX ) + ( y - circleY ) * ( y - circleY ) <= rad * rad ) ) { return true ; } ; else { return false ; } ; }
public static int minSum ( int [ ] arr , int n , int x ) { int Sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i <= n ; i ++ ) { Sum += arr [ i ] ; if ( ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) || ( arr [ i ] < minimum ) ) { largestDivisible = arr [ i ] ; } if ( arr [ i ] < minimum ) { minimum = arr [ i ] ; } } if ( largestDivisible == - 1 ) { return Sum ; } int sumAfterOperation = ( Sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ) ; return Math . min ( Sum , sumAfterOperation ) ; }
public static int nthTerm ( int n ) { int nth ; if ( ( n % 2 == 0 ) && ( n > 0 ) ) nth = 2 * ( ( n * n ) - n ) ; else nth = ( 2 * n * n ) - n ; return nth ; }
public static class Node { public static void main ( String [ ] args ) { Node . value = args [ 0 ] ; Node . next = null ; Node . prev = null ; } public void run ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ value ▁ to ▁ use " ) ) ; Node tail = new Node ( null ) ; Node node = tail ; for ( ; n > 0 ; n -- ) { String command = JOptionPane . showInputDialog ( " Enter ▁ the ▁ command ▁ to ▁ use " ) ; if ( command . startsWith ( "0" ) ) { Node nn = new Node ( Integer . parseInt ( command . substring ( 2 ) ) ) ; nn . prev = node . prev = node ; if ( node . prev != null ) node . prev . next = nn ; node . prev = nn ; node = node . prev ; } else if ( command . startsWith ( "1" ) ) { int i = Integer . parseInt ( command . substring ( 2 ) ) ; if ( i > 0 ) for ( ; i < i ; i ++ ) node = node . next ; else for ( ; i < - i ; i ++ ) node = node . prev ; } else if ( command . startsWith ( "2" ) ) { Node p = node . prev , n = node . next ; node . prev = null ; node . next = null ; node = n ; if ( p == null ) n . prev = null ; else n . prev = p , p . next = n ; } else throw new IllegalArgumentException ( " invalid ▁ command " ) ; } Stack < Integer > st = new Stack < Integer > ( ) ; node = tail . prev ; while ( node != null ) { st . push ( node . value ) ; node = node . prev ; } while ( st . size ( ) > 0 ) System . out . println ( st . pop ( ) ) ; } if ( SwingUtilities . isEventDispatchThread ( ) ) run ( ) ; }
n , k ) public static int compare ( int a , int b ) { String s = input . nextLine ( ) ; int common = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int a = s . charAt ( n - 1 - i ) ; int b = s . charAt ( 0 ) ; if ( ( a == b ) && ( a != b ) ) { common = i + 1 ; continue ; } } int ans = ( n ) + ( k - 1 ) * ( n - common ) ; String final = s ; for ( int i = 0 ; i < k - 1 ; i ++ ) { final += ( s . charAt ( common ++ ) ) ; } System . out . println ( final ) ; return ans ; }
public static class newNode { public static void init ( final byte [ ] data ) { data = data ; left = right = null ; } private void prInorder ( final Node node ) { if ( ( node == null ) || ( node . left == null ) ) return ; prInorder ( node . left ) ; System . out . print ( node . data + " ▁ " ) ; prInorder ( node . right ) ; } private void constructBinaryTreeUtil ( final byte [ ] pre , final byte [ ] preM , final int preIndex , final int l , final int h , final int size ) { if ( ( preIndex >= size ) || l > h ) return ; root = newNode ( pre [ preIndex ] ) ; preIndex ++ ; if ( ( l == h ) && ( preM [ preIndex ] == preM [ i ] ) ) return ; int i ; for ( i = l ; i <= h ; i ++ ) { if ( ( pre [ preIndex ] == preM [ i ] ) || ( pre [ preIndex ] == preM [ i ] ) ) break ; } if ( ( i <= h ) && ( preM [ preIndex ] == preM [ i ] ) ) { root . left = preIndex ; root . right = preIndex ; constructBinaryTreeUtil ( pre , preM , preIndex , i , h , size ) ; root . right = preIndex ; constructBinaryTreeUtil ( pre , preM , preIndex , l + 1 , i - 1 , size ) ; } } private void constructBinaryTree ( final Node root , final byte [ ] pre , final byte [ ] preMirror , final int size ) { preIndex = 0 ; preMIndex = 0 ; root = constructBinaryTreeUtil ( pre , preMirror , preIndex , 0 , size - 1 , size ) ; prInorder ( root ) ; } public void main ( final String [ ] args ) { final byte [ ] preOrder = { 1 , 2 , 4 , 5 , 3 , 6 , 7 } ; final byte [ ] preOrderMirror = { 1 , 3 , 7 , 6 , 2 , 5 , 4 } ; final int size = 7 ; root = newNode ( 0 ) ; constructBinaryTree ( root , preOrder , preOrderMirror , size ) ; } }
public static String findSubString ( String string , String pat ) { int len1 = string . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } int [ ] hashPat = new int [ noOfChars ] ; int [ ] hashStr = new int [ noOfChars ] ; for ( int i = 0 ; i <= len2 ; i ++ ) { hashPat [ ( int ) pat . charAt ( i ) ] ++ ; } int start = 0 , startIndex = - 1 , minLen = Integer . MAX_VALUE ; int count = 0 ; for ( int j = 0 ; j <= len1 ; j ++ ) { hashStr [ ( int ) string . charAt ( j ) ] ++ ; if ( ( hashPat [ ( int ) string . charAt ( j ) ] != 0 ) && ( hashStr [ ( int ) string . charAt ( j ) ] <= hashPat [ ( int ) string . charAt ( j ) ] ) ) count ++ ; if ( count == len2 ) { while ( ( hashStr [ ( int ) string . charAt ( start ) ] > hashPat [ ( int ) string . charAt ( start ) ] || hashPat [ ( int ) string . charAt ( start ) ] == 0 ) && ( hashStr [ ( int ) string . charAt ( start ) ] > hashPat [ ( int ) string . charAt ( start ) ] ) ) { if ( ( hashStr [ ( int ) string . charAt ( start ) ] > hashPat [ ( int ) string . charAt ( start ) ] ) && ( hashStr [ ( int ) string . charAt ( start ) ] < hashPat [ ( int ) string . charAt ( start ) ] ) ) { hashStr [ ( int ) string . charAt ( start ) ] -- ; } start ++ ; } int lenWindow = j - start + 1 ; if ( minLen > lenWindow ) { minLen = lenWindow ; startIndex = start ; } } } if ( startIndex == - 1 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } return string . substring ( startIndex , startIndex + minLen ) ; }
public static final double tri ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { return Math . abs ( ( x2 - x1 ) * ( y3 - y1 ) - ( y2 - y1 ) * ( x3 - x1 ) ) / 2 ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ input ▁ characters . " ) ) ; int m = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ be ▁ compared . " ) ) ; int [ ] x = new int [ n + m ] ; for ( int i = 0 ; i < n + m ; i ++ ) { x [ i ] = JOptionPane . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ be ▁ compared . " ) ) ; } if ( n > m ) { System . out . println ( " YES " ) ; } else if ( n < m ) { System . out . println ( " NO " ) ; } else if ( n == m ) { if ( new HashSet < > ( x ) . size ( ) % 2 != 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public static void MAX ( ) { int n = MAX ; boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { prime [ i ] = true ; } for ( int p = 2 ; p <= n ; p ++ ) { if ( p * p > n ) break ; if ( ( prime [ p ] == true ) && ( prime [ p ] == false ) ) { for ( int i = 2 * p ; i < n ; i ++ , p ++ ) { prime [ i ] = false ; } } } ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) { if ( ( prime [ p ] ) ) ans . add ( p ) ; } }
public static int [ ] main ( String [ ] args ) { int [ ] a = new int [ 4 ] ; int [ ] b = new int [ 2 ] ; for ( int i = 0 ; i < 4 ; i ++ ) a [ i ] = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number " ) ) ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < 2 ; i ++ ) b [ i ] = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ b ▁ number " ) ) ; Arrays . sort ( b ) ; System . out . println ( Arrays . toString ( a ) + Arrays . toString ( b ) ) ; return a ; }
public static int result ( int n , int [ ] a ) throws Exception { int validMin = 15 ; if ( a [ 0 ] > validMin ) return validMin ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= validMin ) validMin = 15 + a [ i ] ; } return 90 < validMin ? 90 : validMin ; }
public static int memo ( int index , int evenSum , int oddSum , int tight ) { if ( index == v . length ) { if ( evenSum > oddSum ) return 1 ; else return 0 ; } if ( dp [ index ] [ evenSum ] [ oddSum ] [ tight ] != - 1 ) return dp [ index ] [ evenSum ] [ oddSum ] [ tight ] ; int limit = v . length == 1 ? 9 : 9 ; int ans = 0 ; for ( int d = 0 ; d < limit + 1 ; d ++ ) { int currTight = 0 ; if ( d == v [ index ] ) currTight = tight ; if ( d % 2 != 0 ) ans += memo ( index + 1 , evenSum , oddSum + d , currTight ) ; else ans += memo ( index + 1 , evenSum + d , oddSum , currTight ) ; } dp [ index ] [ evenSum ] [ oddSum ] [ tight ] = ans ; return ans ; }
public static int [ ] [ ] [ ] getSums ( ) { int [ ] [ ] [ ] lst = new int [ 3 ] [ 3 ] [ 3 ] ; for ( ; ; ) { lst [ 0 ] [ 0 ] = Arrays . copyOf ( input . nextLine ( ) . split ( " ▁ " ) , 3 ) ; lst [ 1 ] [ 1 ] = Arrays . copyOf ( input . nextLine ( ) . split ( " ▁ " ) , 3 ) ; lst [ 2 ] [ 2 ] = Arrays . copyOf ( input . nextLine ( ) . split ( " ▁ " ) , 3 ) ; } int total = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { total += lst [ i ] [ j ] ; } } total = total / 3 ; boolean flag = true ; for ( int i = 0 ; i < 3 ; i ++ ) { int a = lst [ 0 ] [ i % 3 ] + lst [ 1 ] [ ( i + 1 ) % 3 ] + lst [ 2 ] [ ( i + 2 ) % 3 ] ; if ( a != total ) flag = false ; } int a = lst [ 0 ] [ 0 ] + lst [ 1 ] [ 2 ] + lst [ 2 ] [ 1 ] ; if ( a != total ) flag = false ; a = lst [ 1 ] [ 1 ] + lst [ 0 ] [ 2 ] + lst [ 2 ] [ 0 ] ; if ( a != total ) flag = false ; a = lst [ 2 ] [ 2 ] + lst [ 1 ] [ 0 ] + lst [ 0 ] [ 1 ] ; if ( a != total ) flag = false ; if ( flag ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; return lst ; }
public static void solve ( ) { for ( int t = 0 ; t < Integer . MAX_VALUE ; t ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ solve " ) ) ; int [ ] diff = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) diff [ i ] = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ diff ▁ of ▁ times ▁ to ▁ solve " ) ) ; int [ ] arr = new int [ n ] ; arr [ 0 ] = diff [ 0 ] ; boolean flag = false ; for ( int i = 1 ; i < diff . length ; i ++ ) { int x = arr [ i - 1 ] + diff [ i ] ; int y = arr [ i - 1 ] - diff [ i ] ; if ( y >= 0 && x != y ) { flag = true ; break ; } else arr [ i ] = x ; } if ( flag ) System . out . println ( - 1 ) ; else { for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " linux " ) ) solve ( ) ; }
public static String compute ( ) { return "0" ; }
public static int search ( int [ ] arr , int n , int x ) { for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] == x ) && ( arr [ i + 1 ] == x ) ) return i ; } return - 1 ; ; }
N , C ) public static int [ ] [ ] getSums ( ) { int [ ] [ ] XV = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) XV [ i ] = Arrays . copyOf ( input ( ) . split ( " ▁ " ) , N ) ; int [ ] RIGHTSUM = new int [ N ] ; for ( int x = 0 , v = XV [ N - 1 ] . length ; x < N ; x ++ , v ++ ) RIGHTSUM [ x ] = RIGHTSUM [ x - 1 ] + v ; int [ ] LEFTSUM = new int [ N ] ; for ( int x = 0 , v = XV [ N - 1 ] . length ; x < N ; x ++ , v ++ ) LEFTSUM [ x - 1 ] = LEFTSUM [ x - 1 ] + v ; int [ ] RIGHT = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) RIGHT [ i ] = RIGHTSUM [ i + 1 ] - XV [ i ] [ 0 ] ; int [ ] LEFT = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) LEFT [ i ] = LEFTSUM [ i + 1 ] - ( C - XV [ - i - 1 ] [ 0 ] ) ; int [ ] RIGHTMAX = new int [ RIGHT [ 0 ] ] ; for ( int i = 1 ; i < N ; i ++ ) RIGHTMAX [ i ] = Math . max ( RIGHTMAX [ i - 1 ] , RIGHT [ i ] ) ; LEFTMAX = new int [ LEFT [ 0 ] ] ; for ( int i = 1 ; i < N ; i ++ ) LEFTMAX [ i ] = Math . max ( LEFTMAX [ i - 1 ] , LEFT [ i ] ) ; int [ ] ANS = Math . max ( Math . max ( RIGHT , LEFT ) , 0 ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ANS < ( RIGHTSUM [ i + 1 ] - XV [ i ] [ 0 ] * 2 ) + LEFTMAX [ N - i - 2 ] ) ANS = RIGHTSUM [ i + 1 ] - XV [ i ] [ 0 ] * 2 + LEFTMAX [ N - i - 2 ] ; } System . out .
public static int toggleBitsFromLToR ( int n , int l , int r ) { int num = ( ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ) ; return ( n ^ num ) ; }
public static int MinStep ( int [ ] a , int n ) { int positive = 0 ; ; int negative = 0 ; ; int zero = 0 ; ; int step = 0 ; ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == 0 ) && ( a [ i ] != 0 ) ) { zero ++ ; } else if ( ( a [ i ] < 0 ) && ( a [ i ] != 0 ) ) { negative ++ ; step = step + ( - 1 - a [ i ] ) ; } else { positive ++ ; step = step + ( a [ i ] - 1 ) ; } } if ( ( negative % 2 == 0 ) && ( positive % 2 == 0 ) ) { step = step + zero ; } else { if ( ( zero > 0 ) && ( positive % 2 == 0 ) ) { step = step + zero ; } else { step = step + 2 ; } } return step ; }
static final public void main ( String [ ] args ) { final Scanner in = new Scanner ( System . in ) ; final int n = in . nextInt ( ) ; final int a = in . nextInt ( ) ; final int b = in . nextInt ( ) ; final int [ ] mpp = in . nextInt ( ) ; final int [ ] lis = Arrays . copyOf ( mpp , mpp . length + 1 ) ; final int yn = in . nextInt ( ) ; if ( yn > 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } final int cd = in . nextInt ( ) - in . nextInt ( ) + 1 ; final int fn = in . nextInt ( ) ; if ( in . nextInt ( ) == in . nextInt ( ) ) { System . out . println ( fn ) ; } else { System . out . println ( " NO " ) ; } }
public static void main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display : ▁ " ) ) ; List < Integer > v = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display : ▁ " ) . split ( " ▁ " ) ) . subList ( 0 , n ) ; Collections . sort ( v ) ; System . out . println ( v . get ( n - 1 ) + v . get ( n - 2 ) ) ; } }
public static final void noOfSquares ( int x1 , int y1 , int x2 , int y2 ) { int dx = Math . abs ( x2 - x1 ) ; ; int dy = Math . abs ( y2 - y1 ) ; int ans = dx + dy - gcd ( dx , dy ) ; ; System . out . println ( ans ) ; ; }
public static String getMaximum ( String s , int [ ] a ) { s = Arrays . asList ( s ) ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( int ) s . charAt ( i ) - ( int ) '0' ) < a [ ( int ) s . charAt ( i ) - ( int ) '0' ] ) { int j = i ; while ( ( j < n ) && ( ( int ) s . charAt ( j ) - ( int ) '0' <= a [ ( int ) s . charAt ( j ) - ( int ) '0' ] ) ) { s . setCharAt ( j , ( char ) ( ( char ) '0' + a [ ( int ) s . charAt ( j ) - ( int ) '0' ] ) ) ; j ++ ; } return " " ; } ; } ; return s ; }
public static final boolean MAX_DIGITS = 20 ; ; public static boolean isOctal ( int n ) { while ( ( n = n / 10 ) != 0 ) { if ( ( ( n % 10 ) >= 8 ) && ( ( n % 10 ) != 0 ) ) { return false ; } else { n = ( int ) ( n / 10 ) ; } } return true ; } public static boolean isPalindrome ( int n ) { int divide = 8 == ( isOctal ( n ) == false ) ? 10 : 8 ; int [ ] octal = new int [ n ] ; while ( ( n = n % divide ) != 0 ) { octal [ n ] = n % divide ; n = ( int ) ( n / divide ) ; } int j = octal . length - 1 ; int k = 0 ; while ( ( k <= j ) && ( k < j ) ) { if ( ( octal [ j ] != octal [ k ] ) ) { return false ; } j -- ; k ++ ; } return true ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { int n = 97 ; if ( ( isPalindrome ( n ) ) && ( n % 10 == 0 ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
public static int num ( ) { int num = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ question ▁ to ▁ solve " ) ) ; int [ ] num = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ question ▁ to ▁ solve " ) ; List < Integer > listIs = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < num . length ; i ++ ) { listIs . add ( Integer . parseInt ( num [ i ] ) ) ; } List < Integer > listIS1 = listIs . subList ( 0 , listIs . size ( ) / 2 ) ; List < Integer > listIS2 = listIs . subList ( listIs . size ( ) / 2 , listIs . size ( ) ) ; int sum1 = sum ( listIS1 ) ; int sum2 = sum ( listIS2 ) ; boolean condition = false ; for ( int i : listIs ) { if ( i == 4 || i == 7 ) { condition = true ; continue ; } else { condition = false ; break ; } } if ( condition == true ) { if ( sum1 == sum2 ) { JOptionPane . showMessageDialog ( null , " YES " ) ; } else { JOptionPane . showMessageDialog ( null , " NO " ) ; } } else { JOptionPane . showMessageDialog ( null , " NO " ) ; } return sum1 ; }
public static int binarySearch ( int [ ] arr , int low , int high ) { if ( ( high < low ) || ( high > mid ) ) return - 1 ; int mid = ( int ) ( ( low + high ) / 2 ) ; int midValue = arr [ mid ] ; if ( ( mid == arr [ mid ] ) && ( midValue == arr [ mid ] ) ) return mid ; int leftindex = Math . min ( mid - 1 , midValue ) ; int left = binarySearch ( arr , low , leftindex ) ; if ( ( left >= 0 ) && ( left < mid ) ) return left ; int rightindex = Math . max ( mid + 1 , midValue ) ; int right = binarySearch ( arr , rightindex , high ) ; return right ; }
MAX = 10000 ; prodDig = new int [ MAX ] ; prodDig [ 0 ] = 0 ; prodDig [ 1 ] = 0 ; static final int getDigitProduct ( int x ) { if ( ( x < 10 ) && ( x > 0 ) ) return x ; ; if ( ( prodDig [ x ] != 0 ) && ( x < MAX ) ) return prodDig [ x ] ; ; }
public static int N ( ) { int N = Integer . parseInt ( input ( ) . nextLine ( ) ) ; int K = Integer . parseInt ( input ( ) . nextLine ( ) ) ; int [ ] X = Arrays . copyOf ( input ( ) . nextLine ( ) . split ( " ▁ " ) , N ) ; int answer = 10 * 18 ; for ( int i = 0 ; i < N - K + 1 ; i ++ ) { int left = i , right = i + K - 1 ; int al = Math . abs ( X [ left ] ) , ar = Math . abs ( X [ right ] ) ; if ( X [ left ] * X [ right ] >= 0 ) { answer = Math . min ( answer , Math . max ( al , ar ) ) ; } else { answer = Math . min ( answer , al * 2 + ar ) ; } } System . out . println ( answer ) ; return answer ; }
public static int diff ( int n , int mid ) { if ( ( n > ( mid * mid * mid ) ) && ( n < ( mid * mid * mid ) ) ) { return ( n - ( mid * mid * mid ) ) ; } else { return ( ( mid * mid * mid ) - n ) ; } }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int m = Integer . parseInt ( input ( ) ) ; int [ ] a = new int [ n ] ; for ( ; m > 0 ; m -- ) a [ m ] = Integer . parseInt ( input ( ) ) ; int kmax = Math . max ( a ) + m ; while ( m > 0 ) { Arrays . sort ( a ) ; m -- ; a [ 0 ] ++ ; } int kmin = Math . min ( a ) ; System . out . println ( kmin + " ▁ " + kmax ) ; return kmin ; }
public static int inv ( int a , int m ) { int m0 = m ; int x0 = 0 ; int x1 = 1 ; if ( ( m == 1 ) && ( a > 1 ) ) return 0 ; while ( ( a > 1 ) && ( a < m ) ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( ( x1 < 0 ) && ( a > 0 ) ) x1 = x1 + m0 ; return x1 ; }
public static int findMaxOR ( int [ ] arr , int n ) { Arrays . sort ( arr , 0 , n ) ; int maxOR = arr [ 0 ] ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( ( maxOR | arr [ i ] ) > maxOR ) && ( ( maxOR | arr [ i ] ) < maxOR ) ) { maxOR = maxOR | arr [ i ] ; ; count ++ ; } } return count ; }
public static int seriessum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * ( i + 1 ) / 2 ; } return sum ; }
public static int aliquotSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( n % i == 0 ) && ( i % i == 0 ) ) { sm = sm + i ; } } return sm ; }
public static int pentagonPyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
public static int fifthPowerSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sm = sm + ( i * i * i * i * i ) ; } return sm ; }
public static int squaresum ( int n ) { int sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sm = sm + ( i * i ) ; } return sm ; }
public static int seriessum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * ( i + 1 ) / 2 ; } return sum ; }
static final long sumOfSeries ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; } return sum ; }
public static int findSum ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ = ( summ + ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ) ; } return summ ; }
static int fourthPowerSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum = sum + ( i * i * i * i ) ; } return sum ; }
public static int squareSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { sum += ( 2 * i ) * ( 2 * i ) ; } return sum ; }
public static double AvgofSquareN ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += ( i * i ) ; } return sum / n ; }
public static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += i * ( n - i ) ; } return 2 * sum ; }
public static final int solve ( int n , int base ) { int sum = 0 ; while ( ( n > 0 ) && ( n % base == 0 ) ) { int remainder = n % base ; sum = sum + remainder ; n = ( int ) ( n / base ) ; } return sum ; }
public static int [ ] eratos ( int n ) { boolean [ ] isPrime = new boolean [ 110001 ] ; int [ ] primes = new int [ 110001 ] ; ; ; }
public static int count ( String str ) { ; System . out . println ( bin ( 4 ) . count ( "1" ) ) ; ; System . out . println ( bin ( 15 ) . count ( "1" ) ) ; ; }
INT_MAX = 2147483647 ; public static void optimalSearchTree ( int [ ] keys , int [ ] freq , int n ) { int [ ] [ ] cost = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = freq [ i ] ; for ( int L = 2 ; L <= n ; L ++ ) { for ( int i = 0 ; i < n - L + 2 ; i ++ ) { int j = i + L - 1 ; if ( i >= n || j >= n ) break ; cost [ i ] [ j ] = INT_MAX ; for ( int r = i ; r <= j ; r ++ ) { int c = 0 ; if ( ( r > i ) && ( r < j ) ) c += cost [ i ] [ r - 1 ] ; if ( ( r < j ) && ( r < i ) ) c += cost [ r + 1 ] [ j ] ; c += sum ( freq , i , j ) ; if ( ( c < cost [ i ] [ j ] ) && ( c < cost [ i ] [ j ] ) ) cost [ i ] [ j ] = c ; } } } }
public static int get ( int x , int y , int z ) { if ( ( x > z ) && ( y > z ) ) return - 1 ; val div = z - x ; val ans = ( z - x ) / y ; return ans ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] a = Arrays . copyOf ( input ( ) . split ( " ▁ " ) , n ) ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ a [ i ] - 1 ] = i ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) res += Math . abs ( b [ i ] - b [ i - 1 ] ) ; System . out . println ( res ) ; return res ; }
public static int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < Math . min ( i , k ) + 1 ; j ++ ) { if ( ( j == 0 || j == i ) && ( C [ i ] [ j ] == 0 ) ) { C [ i ] [ j ] = 1 ; } ; } else { C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } ; } ; final int maxcoefficientvalue = n ; if ( ( n % 2 == 0 ) && ( C [ n / 2 ] [ n / 2 ] == 0 ) ) { return binomialCoeff ( n , ( int ) ( n / 2 ) ) ; } else { return binomialCoeff ( n , ( int ) ( ( n + 1 ) / 2 ) ) ; } ; }
public static boolean isVowel ( char ch ) { if ( ch == ' a ' || ch == ' e ' || ch == ' i ' || ch == ' o ' || ch == ' u ' ) { return true ; } else { return false ; } }
public static void main ( String [ ] args ) { while ( true ) { N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ N ▁ ( String ) : ▁ " ) ) ; if ( N == 0 ) exit ( ) ; ( ( W ) W ) = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ W ▁ ( int ) : ▁ " ) ) ; ( ( H ) H ) = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ H ▁ ( int ) : ▁ " ) ) ; ( ( T ) T ) = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ T ▁ ( int ) : ▁ " ) ) ; ( ( C ) C ) = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ C ▁ ( int ) : ▁ " ) ) ; ( ( D ) D ) = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ D ▁ ( int ) : ▁ " ) ) ; ( ( E ) E ) = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ E ▁ ( int ) : ▁ " ) ) ; ( ( F ) F = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ F ▁ ( int ) : ▁ " ) ) ; ( ( G ) G = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ G ▁ ( int ) : ▁ " ) ) ; ( ( H ) H = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ H ▁ ( int ) : ▁ " ) ) ) ; ( ( S ) S ) = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ S ▁ ( int ) : ▁ " ) ) ; int maxPersiston = 0 ; for ( int x = S ; x <= W ; x ++ ) { for ( int y = T ; y <= H ; y ++ ) { maxPersiston = Math . max ( maxPersiston , cumsum [ x ] [ y ] + cumsum [ x ] [ y - 1 ] - cumsum [ x - 1 ] [ y - 1 ] + persimmon [ x ] [ y ] ) ; } } System . out . println ( maxPersiston ) ; } if ( args . length == 0 ) main ( ) ; }
public static int isSubstring ( String s1 , String s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i < N - M + 1 ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( ( s2 . charAt ( i + j ) != s1 . charAt ( j ) ) && ( s2 . charAt ( i + j ) != s2 . charAt ( j + 1 ) ) ) { break ; } } if ( j + 1 == M ) { return i ; } } return - 1 ; }
public static double angleOncirCumference ( double z ) { return ( z / 2 ) ; ; }
public static void countSubarraysof1and0 ( int [ ] a , int n ) { int count1 = 0 ; int count0 = 0 ; int number1 = 0 ; int number0 = 0 ; for ( int i = 0 ; i < n ; i += 1 ) { if ( ( a [ i ] == 1 ) && ( a [ i + 1 ] == 0 ) ) { count1 ++ ; } else { number1 += ( ( count1 ) * ( count1 + 1 ) / 2 ) ; count1 = 0 ; } } for ( int i = 0 ; i < n ; i += 1 ) { if ( ( a [ i ] == 0 ) && ( a [ i + 1 ] == 1 ) ) { count0 ++ ; } else { number0 += ( count0 ) * ( count0 + 1 ) / 2 ; count0 = 0 ; } } if ( ( count1 ) > 0 ) { number1 += ( count1 ) * ( count1 + 1 ) / 2 ; } if ( ( count0 ) > 0 ) { number0 += ( count0 ) * ( count0 + 1 ) / 2 ; } System . out . println ( " Count ▁ of ▁ subarrays ▁ of ▁ 0 ▁ only : " + Integer . toString ( number0 ) ) ; System . out . println ( " Count ▁ of ▁ subarrays ▁ of ▁ 1 ▁ only : " + Integer . toString ( number1 ) ) ; }
public static void printNumbers ( int N ) { int flag = 1 ; int x = N ; if ( ( N > 0 ) && ( flag == 1 ) ) { while ( ( x > 0 ) && ( flag == 1 ) ) { int digit = x % 10 ; if ( ( digit != 1 && digit != 3 ) || ( digit != 2 && digit != 4 ) ) flag = 0 ; x = x / 10 ; } if ( ( flag == 1 ) && ( N > 0 ) ) System . out . print ( N + " ▁ " ) ; printNumbers ( N - 1 ) ; } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " win " ) ) { N = 20 ; printNumbers ( N ) ; } }
public static void printPermutation ( int n , int k ) { int mx = n ; for ( int i = 1 ; i <= k ; i ++ ) { System . out . print ( mx + " ▁ " ) ; mx -- ; } for ( int i = 1 ; i <= mx ; i ++ ) { System . out . print ( i + " ▁ " ) ; } }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; List < Integer > l = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) l . add ( Integer . parseInt ( input ( ) . split ( " ▁ " ) [ i ] ) ) ; int a = l . get ( 0 ) ; l . sort ( ) ; return l . indexOf ( a ) + 1 ; }
public static boolean isMember ( String List , String key ) { for ( int i = 0 ; i != List . length ( ) ; i ++ ) { if ( key . equals ( List . substring ( i , i + 1 ) ) ) { return true ; } } return false ; } public static boolean overlap ( String [ ] List1 , String [ ] List2 ) { for ( int i = 0 ; i != List1 . length ; i ++ ) { if ( isMember ( List2 , List1 [ i ] ) ) { return true ; } } return false ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { System . out . println ( " geeksforgeeks " ) ; return ; } String s1 = " geeksforgeeks " ; String s2 = " geeks " ; List < String > List1 = Arrays . asList ( s1 ) ; List < String > List2 = Arrays . asList ( s2 ) ; boolean yesOrNo = String . valueOf ( overlap ( List1 , List2 ) ) ; if ( ( yesOrNo ) && ( List1 . size ( ) > 0 ) && ( List2 . size ( ) > 0 ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
public static int t ( ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ algorithm " ) ) ; int i = 1 ; while ( true ) { if ( i > t ) break ; int n = map . get ( JOptionPane . YES_OPTION ) ; int a = map . get ( JOptionPane . YES_OPTION ) , b = map . get ( JOptionPane . YES_OPTION ) , c = map . get ( JOptionPane . YES_OPTION ) , d = map . get ( JOptionPane . YES_OPTION ) ; if ( n * ( a - b ) > ( c + d ) || n * ( a + b ) < ( c - d ) ) System . out . println ( " No " ) ; else System . out . println ( " Yes " ) ; i = i + 1 ; } return i ; }
public static void findElements ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { count = count + 1 ; } } if ( count >= 2 ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } arr [ 0 ] = 2 ; arr [ 1 ] = - 6 ; arr [ 2 ] = 3 ; arr [ 3 ] = 5 ; arr [ 4 ] = 1 ; n = arr . length ; findElements ( arr , n ) ; }
N = 3 ; }
public static boolean isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i < ( int ) ( ( n - 2 ) / 2 ) + 1 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) || ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) ) return false ; } return true ; }
public static boolean isHeap ( int [ ] arr , int i , int n ) { if ( i > ( int ) ( ( n - 2 ) / 2 ) ) return true ; if ( ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) ) return true ; return false ; }
public static void main ( String [ ] args ) { V = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ vector ▁ of ▁ integers " ) . collect ( Collectors . toList ( ) ) ) . map ( Integer :: parseInt ) . collect ( Collectors . toList ( ) ) ; P = new ArrayList < > ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { P . add ( new Point ( V . get ( 0 ) , V . get ( 1 ) ) ) ; V = V . subList ( 2 , V . size ( ) ) ; } A = P . get ( 0 ) ; B = P . get ( 1 ) ; C = P . get ( 2 ) ; for ( int i = 1 ; i < 3 ; i ++ ) { int x = P . get ( i ) ; int y = P . get ( i ) ; int x0 = P . get ( 0 ) ; int y0 = P . get ( 0 ) ; P . set ( i , x - x0 ) ; P . set ( i , y - y0 ) ; } int a = P . get ( 1 ) ; int b = P . get ( 2 ) ; int c = P . get ( 3 ) ; if ( a * d - b * c == 0 ) { System . out . println ( " NO " ) ; System . exit ( 0 ) ; } final int dist = A . compareTo ( B ) ; int x = A . get ( 0 ) - B . get ( 0 ) ; int y = A . get ( 1 ) - B . get ( 1 ) ; System . out . println ( " YES " . equals ( dist ) ? " NO " : " YES " ) ; }
public static int findMinDel ( int [ ] arr , int n ) { int minNum = Integer . MAX_VALUE ; ; for ( int i = 0 ; i < n ; i ++ ) { minNum = Math . min ( arr [ i ] , minNum ) ; } ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] == minNum ) && ( arr [ i ] != 0 ) ) { cnt ++ ; } } ; return n - cnt ; }
public static int count ( int x , int y ) { int ans = 0 ; Map < Integer , Integer > m = Maps . newHashMap ( ) ; while ( x % y != 0 ) { x %= y ; ans ++ ; if ( x < m . size ( ) ) return - 1 ; m . put ( x , 1 ) ; x *= 10 ; } return ans ; }
public static boolean isPossibleToMakeDivisible ( int [ ] arr , int n ) { int remainder = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { remainder = ( remainder + arr [ i ] ) % 3 ; } return ( remainder == 0 ) ; }
public static int main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int N = Integer . parseInt ( input . nextLine ( ) ) ; int K = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > A = Arrays . asList ( input . nextInt ( ) , input . nextInt ( ) ) ; int ans = 0 ; ArrayList < Integer > graph = new ArrayList < Integer > ( N ) ; for ( int i = 0 , a = A . size ( ) ; i < a ; i ++ ) { if ( i == 0 ) { if ( A . get ( i ) != 1 ) ans ++ ; continue ; } Par . set ( i , A . get ( i ) - 1 ) ; graph . get ( a - 1 ) . add ( i ) ; } LinkedList < Integer > qs = new LinkedList < Integer > ( ) ; Stack < Integer > stack = new Stack < Integer > ( ) ; int [ ] Depth = new int [ N ] ; Depth [ 0 ] = 0 ; while ( stack . size ( ) > 0 ) { int p = stack . pop ( ) ; for ( Integer np : graph . get ( p ) ) { Depth [ np ] = Depth [ p ] + 1 ; stack . push ( np ) ; } qs . add ( new Integer ( Depth [ p ] ) ) ; } Collections . sort ( qs , new Comparator < Integer > ( ) { public int compare ( Integer o1 , Integer o2 ) { return o1 . compareTo ( o2 ) ; } } ) ; boolean checked [ ] = new boolean [ N ] ; for ( int d = 0 , s = 0 ; d < N ; d ++ ) { if ( d <= K ) break ; if ( checked [ s ] ) continue ; for ( int i = 0 ; i < K - 1 ; i ++ ) s = Par . get ( s ) ; LinkedList < Integer > que = new LinkedList < Integer > ( ) ; que . add ( s ) ; checked [ s ] = true ; while ( que . size ( ) > 0 ) { LinkedList < Integer > qq = new LinkedList < Integer > ( ) ; for ( int p : que ) { for ( Integer np : graph . get ( p ) ) { if ( ! checked [ np ] ) { checked [ np ] = true ; qq . add ( np ) ; } } } que = qq ; } ans ++ ; } System . out . println ( ans
public static void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { int j ; for ( j = i * 3 ; j <= i ; j ++ ) { if ( ( j * 3 ) == i ) { System . out . print ( j * 3 + " ▁ " ) ; break ; } } } a = 1 ; b = 100 ; System . out . print ( " Perfect ▁ cubes ▁ in ▁ given ▁ range : ▁ " ) ; printCubes ( a , b ) ; }
public static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }
public static void main ( String [ ] args ) { try { int N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ compared " ) ) ; int d = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ d ▁ value ▁ to ▁ be ▁ compared " ) ) ; int [ ] nums = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ numbers ▁ to ▁ be ▁ compared " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; Arrays . sort ( nums ) ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= i - 1 ; j -- ) { if ( Math . abs ( nums [ i ] - nums [ j ] ) <= d ) { ans = Math . max ( ans , j - i + 1 ) ; break ; } } } System . out . println ( N - ans ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } }
public static int solve ( String s ) { int a = ( char ) s . charAt ( s . length ( ) - 1 ) - ' a ' ; int n = Integer . parseInt ( s . substring ( 0 , s . length ( ) - 1 ) ) ; int [ ] od = { 4 , 5 , 6 , 3 , 2 , 1 } ; int [ ] ad = { 0 , 7 , 0 , 7 } ; int c = 16 ; int ktmp = ( n - 1 ) / 4 ; int ttmp = ( n - 1 ) % 4 ; int ans = ktmp * 16 + ad [ ttmp ] + od [ a ] ; return ans ; }
public static boolean isPerfectCube ( int x ) { int cr = ( int ) ( x * ( 1 / 3 ) ) ; ; return ( cr * cr * cr == x ) ; }
public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . nextLine ( ) ) ; String s = sc . nextLine ( ) ; String t = sc . nextLine ( ) ; String test = s + t ; if ( ( s . equals ( t ) ) && ( test . startsWith ( s ) ) ) { System . out . println ( s . length ( ) ) ; System . exit ( 0 ) ; } for ( int i = 1 ; i <= n ; i ++ ) { test = s . substring ( 0 , - i ) + t ; if ( ( test . startsWith ( s ) && test . endsWith ( t ) ) && ( test . length ( ) > n ) ) { System . out . println ( test . length ( ) ) ; System . exit ( 0 ) ; } } System . out . println ( s . length ( ) + t . length ( ) ) ; }
public static final void main ( String [ ] args ) { final HashMap < Integer , Integer > graph = new HashMap < Integer , Integer > ( ) ; graph . put ( 0 , 1 ) ; graph . put ( 1 , 2 ) ; graph . put ( 2 , 0 ) ; graph . put ( 2 , 3 ) ; graph . put ( 3 , 3 ) ; System . out . println ( " Following ▁ is ▁ Depth ▁ First ▁ Traversal ▁ ( starting ▁ from ▁ vertex ▁ 2 ) " ) ; }
public static final void countDigits ( int val , int [ ] arr ) { while ( ( val > 0 ) && ( val < 10 ) ) { int digit = val % 10 ; arr [ Integer . toUnsignedInt ( digit ) ] ++ ; val = val / 10 ; } ; }
public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > a = Arrays . asList ( input . nextLine ( ) . split ( " ▁ " ) ) ; String ans = " NO " ; Collections . sort ( a ) ; while ( a . size ( ) > 0 && ! a . get ( a . size ( ) - 1 ) ^ 1 ) { a . remove ( a . size ( ) - 1 ) ; } a . reverse ( ) ; for ( int i = 0 ; i < a . size ( ) - 1 ; i ++ ) { if ( 2 * a . get ( i ) > a . get ( i + 1 ) && a . get ( i ) ^ a . get ( i + 1 ) ) { ans = " YES " ; break ; } } System . out . println ( ans ) ; }
public static void main ( String [ ] args ) { for ( ; ; ) { int N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display : ▁ " ) ) ; System . out . println ( Math . max ( 0 , N - 2 ) ) ; } }
a = input ; System . out . println ( " IO ▁ hb , e ▁ cmoym ▁ ek ▁ etyhbeo ▁ agrudy ! . " . charAt ( Integer . parseInt ( a ( ) ) > Integer . MAX_VALUE ? Integer . MAX_VALUE : a ( ) . toString ( ) + a ( ) . toString ( ) ) ) ; }
public static int linearCheck ( int [ ] [ ] ar , int [ ] arr ) { for ( int i = 0 ; i < m ; i ++ ) { boolean matched = true ; ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ar [ i ] [ j ] != arr [ j ] ) && ( ar [ i ] [ j ] != arr [ j ] ) ) { matched = false ; break ; } } if ( ( matched ) && ( arr [ i ] != arr [ j ] ) ) return i + 1 ; } return - 1 ; }
public static int n ( ) { int n = Integer . parseInt ( System . in . readLine ( ) ) ; while ( n > 0 ) { int p = Integer . parseInt ( System . in . readLine ( ) ) ; int [ ] l = Arrays . copyOf ( Integer . parseInt ( System . in . readLine ( ) ) , p ) ; int c = 0 ; int s = sum ( l ) ; if ( s % p == 0 ) { for ( int i = 0 ; i < p ; i ++ ) { if ( l [ i ] > s / p ) { c ++ ; } } System . out . println ( c ) ; } else { System . out . println ( - 1 ) ; } n -- ; } return n ; }
public static int N ( ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] t = Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] v = Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int time = 0 ; int sum_t = Arrays . stream ( t ) . mapToInt ( Integer :: parseInt ) . sum ( ) ; double [ ] veloCap = new double [ 2 * sum_t + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { int start_t = time ; int goal_t = time + 2 * t [ i ] ; for ( int s = 0 ; s <= 2 * sum_t ; s ++ ) { if ( s < start_t ) { veloCap [ s ] = Math . min ( veloCap [ s ] , 2 * v [ i ] + ( start_t - s ) ) ; } else if ( s < goal_t ) { veloCap [ s ] = Math . min ( veloCap [ s ] , 2 * v [ i ] ) ; } else { veloCap [ s ] = Math . min ( veloCap [ s ] , 2 * v [ i ] + ( s - goal_t ) ) ; } } time += 2 * t [ i ] ; } for ( int s = 0 ; s < 2 * sum_t + 1 ; s ++ ) { veloCap [ s ] = Math . min ( veloCap [ s ] , 2 * sum_t - s , s ) ; } System . out . println ( Arrays . stream ( veloCap ) . mapToDouble ( Double :: doubleValue ) . sum ( ) / 4 - ( veloCap [ 0 ] + veloCap [ 1 ] ) / 8 ) ; return sum_t ; }
public static int nthTerm ( int n ) { return 2 * Math . pow ( n , 2 ) + 4 * n - 2 ; }
public static int nthTerm ( int n ) { return 7 * Math . pow ( n , 2 ) - 7 * n + 7 ; }
public static double nthTerm ( double n ) { return 5 * Math . pow ( n , 2 ) - 5 * n ; }
public static final double nthTerm ( double n ) { return Math . pow ( n , 2 ) + 2 * n + 2 ; if ( System . getSecurityManager ( ) == null ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } return n ; }
public static double nthTerm ( double n ) { return 2 * Math . pow ( n , 3 ) + Math . pow ( n , 2 ) ; }
public static int nthTerm ( int n ) { return 2 * Math . pow ( n , 2 ) - n - 1 ; }
public static final double nthTerm ( double n ) { return Math . pow ( n , 2 ) - 2 * n + 2 ; if ( System . getSecurityManager ( ) == null ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } return n ; }
public static int nthTerm ( int n ) { return 3 * Math . pow ( n , 2 ) + n - 2 ; }
x , y ; int c = Math . abs ( x ) + Math . abs ( y ) ; if ( x > 0 && y > 0 ) System . out . println ( 0 + c + c + 0 ) ; if ( x < 0 && y > 0 ) System . out . println ( - c + 0 + 0 + c ) ; if ( x > 0 && y < 0 ) System . out . println ( 0 + - c + c + 0 ) ; if ( x < 0 && y < 0 ) System . out . println ( - c + 0 + 0 + - c ) ; }
public static String [ ] subArray ( String s ) { int K = Integer . parseInt ( input . nextLine ( ) ) ; int l = s . length ( ) ; String [ ] substr = new String [ l ] ; for ( int i = 0 ; i < l ; i ++ ) { for ( int k = 0 ; k < K ; k ++ ) { substr [ i ] = s . substring ( i , i + k + 1 ) ; if ( i + k + 1 >= l ) break ; } } substr = Arrays . copyOf ( substr , K ) ; Arrays . sort ( substr ) ; return substr ; }
public static class Solution { public static void main ( String [ ] args ) { System . out . println ( " memo ▁ = ▁ " + memo ) ; memo . add ( 0 ) ; memo . add ( 1 ) ; } public static void fib ( int N ) { if ( N < memo . size ( ) ) { System . out . println ( " memo ▁ = ▁ " + memo ) ; } for ( int i = memo . size ( ) ; i <= N ; i ++ ) { memo . add ( memo . get ( i - 1 ) + memo . get ( i - 2 ) ) ; } System . out . println ( " memo ▁ = ▁ " + memo ) ; } }
public static void main ( String [ ] args ) { final int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ string ▁ to ▁ be ▁ compared " ) ) ; final List < String > a = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ b ▁ string ▁ to ▁ be ▁ compared " ) ) ; final List < String > b = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ p ▁ string ▁ to ▁ be ▁ compared " ) ) ; final Counter < String > p = new Counter < String > ( a ) ; final int n = a . size ( ) ; int ok = 0 ; for ( int i = 0 ; i < b . size ( ) ; i ++ ) { if ( p . getCount ( b . get ( i ) ) == 0 ) ok = 1 ; } if ( b != Collections . synchronizedList ( b ) || ok == 1 ) { for ( int i = Collections . synchronizedList ( a ) . size ( ) ; i < n ; i ++ ) System . out . print ( a . get ( i ) + " ▁ " ) ; System . out . println ( ) ; return ; } Collections . sort ( a ) ; LinkedList < String > q1 = new LinkedList < String > ( ) ; LinkedList < String > q2 = new LinkedList < String > ( ) ; LinkedList < String > q = new LinkedList < String > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a . get ( i ) . equals ( " c " ) ) q . add ( i ) ; if ( a . get ( i ) . equals ( " b " ) ) q1 . add ( 0 , i ) ; } int i = 0 , j = 0 ; while ( j < q1 . size ( ) && i < q . size ( ) ) { a . set ( q . get ( i ) , a . get ( q1 . get ( j ) ) ) ; i ++ ; j ++ ; } for ( int i = 0 ; i < a . size ( ) ; i ++ ) System . out . print ( a . get ( i ) + " ▁ " ) ; System . out . println ( ) ; }
public static double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; ; double res = 1 ; double sign = 1 ; double fact = 1 ; double pow = 1 ; for ( int i = 1 ; i <= 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
public static int findNumber ( int N , int S ) { int i = ( ( ( N ) * ( N + 1 ) ) / 4 ) - ( ( S + 1 ) / 2 ) ; ; return i ; }
public static boolean multipleOfThree ( int K , int dig0 , int dig1 ) { int sum ; int temp = ( dig0 + dig1 ) % 10 ; sum = dig0 + dig1 ; if ( ( K == 2 ) && ( sum % 3 == 0 ) ) { if ( ( sum % 3 == 0 ) ) { return true ; } else { return false ; } } sum += temp ; int numberofGroups = ( K - 3 ) / 4 ; int remNumberofDigits = ( K - 3 ) % 4 ; sum += ( numberofGroups * 20 ) ; for ( int i = 0 ; i < remNumberofDigits ; i ++ ) { temp = ( 2 * temp ) % 10 ; sum += temp ; } if ( ( sum % 3 == 0 ) && ( sum % 4 == 0 ) ) { return true ; } else { return false ; } } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " win " ) ) { K = 5 ; dig0 = 3 ; dig1 = 4 ; if ( ( multipleOfThree ( K , dig0 , dig1 ) ) && ( sum % 3 == 0 ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } return false ; }
public static int n ( String input ) { int a [ ] = new int [ input . length ( ) ] ; for ( int i = 0 ; i < a . length ; i ++ ) a [ i ] = Integer . parseInt ( input . substring ( i ) ) ; int b [ ] = new int [ input . length ( ) ] ; for ( int i = 0 ; i < b . length ; i ++ ) b [ i ] = Integer . parseInt ( input . substring ( i ) ) ; int total = Arrays . stream ( a ) . sum ( ) ; Arrays . sort ( b ) ; System . out . println ( " YES " . equals ( total ) ? " NO " : " YES " ) ; return total ; }
public static int countOcc ( String s ) { int cnt = 0 ; for ( int i = 0 ; i <= s . length ( ) - 3 ; i ++ ) { int c = 0 , l = 0 , a = 0 , p = 0 ; for ( int j = i ; j <= i + 4 ; j ++ ) { if ( s . charAt ( j ) == ' c ' ) c ++ ; else if ( s . charAt ( j ) == ' l ' ) l ++ ; else if ( s . charAt ( j ) == ' a ' ) a ++ ; else if ( s . charAt ( j ) == ' p ' ) p ++ ; } if ( c == 1 && l == 1 && a == 1 && p == 1 ) cnt ++ ; } return cnt ; }
static final int countSteps ( int x , int y ) { if ( ( x % y == 0 ) && ( y % x == 0 ) ) return Math . floor ( x / y ) ; ; return Math . floor ( ( x / y ) + countSteps ( y , x % y ) ) ; }
static final public boolean isPerfectSquare ( double x ) { double sr = mt . sqrt ( x ) ; return ( ( sr - mt . floor ( sr ) ) == 0 ) ; }
public static final double PI = 3.14159265 ; public static double areaInRange ( double P , double B , double H ) { return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) ; }
public static void main ( String [ ] args ) { while ( 1 ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display : ▁ " ) ) ; if ( n == 0 ) break ; Map < Integer , String > map = new HashMap < Integer , String > ( ) ; for ( ; n > 0 ; n -- ) { Integer k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ key ▁ to ▁ display : ▁ " ) ) ; String v = JOptionPane . showInputDialog ( " Enter ▁ the ▁ value ▁ to ▁ display : ▁ " ) ; map . put ( k , v ) ; } for ( ; n > 0 ; n -- ) { Integer e = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ value ▁ to ▁ display : ▁ " ) ) ; System . out . print ( map . containsKey ( e ) ? e : " " ) ; } System . out . println ( ) ; } }
public static final int getCount ( int [ ] v , int n ) { int [ ] array = new int [ n ] ; Arrays . fill ( array , 1 ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = n - 1 - upperBound ( v , array , array . length - 1 ) ; if ( ( tmp == array [ i ] ) && ( tmp != 0 ) ) { cnt ++ ; } } return cnt ; }
public static int trailingZeros ( int N ) { int countOfTwo = 0 ; int countOfFive = 0 ; for ( int i = 1 ; i <= N ; i += 1 ) { int val = i ; while ( ( val % 2 == 0 && val > 0 ) || ( val % 5 == 0 && val > 0 ) ) { val /= 2 ; countOfTwo += i ; } while ( ( val % 5 == 0 && val > 0 ) || ( val % 5 == 0 && val > 0 ) ) { val /= 5 ; countOfFive += i ; } } int ans = Math . min ( countOfTwo , countOfFive ) ; return ans ; }
public static int removeZero ( int n ) { int res = 0 ; int d = 1 ; while ( ( n > 0 ) && ( d != 0 ) ) { if ( ( n % 10 != 0 ) ) { res += ( n % 10 ) * d ; d *= 10 ; } n /= 10 ; } final boolean isEqual = ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) ; final int a = 105 ; final int b = 106 ; if ( ( isEqual ) && ( a == b ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return res ; }
public static int m = 1000000007 ; final Scanner in = new Scanner ( System . in ) ; int f_i = in . nextInt ( ) ; int N = Integer . parseInt ( in . nextLine ( ) ) ; int [ ] [ ] n_type = new int [ N ] [ ] ; for ( int i = 0 ; i < N ; i ++ ) { int t = in . nextInt ( ) ; n_type [ i ] = t ; } int [ ] [ ] adj = new int [ N ] [ ] ; for ( int i = 0 ; i < N ; i ++ ) { int s = in . nextInt ( ) , t = in . nextInt ( ) ; s -- ; t -- ; adj [ s ] [ t ] = i ; } final int [ ] prod = new int [ N ] ; int p = 1 ; for ( int i = 0 ; i < N ; i ++ ) { p *= i ; } java . util . Arrays . fill ( prod , 4000 ) ; final int node = n_type [ node ] ; final int [ ] chld = adj [ node ] ; if ( nt . equals ( " E " ) ) { if ( chld != null ) { return prod [ map ( chld ) ] % m ; } else { return 1 ; } } else if ( nt . equals ( " E ? " ) ) { if ( chld != null ) { return ( prod [ map ( chld ) ] + 1 ) % m ; } else { return 2 ; } } else if ( nt . equals ( " A " ) ) { return sum [ map ( chld ) ] % m ; } else if ( nt . equals ( " A ? " ) ) { return ( sum [ map ( chld ) ] + 1 ) % m ; } else { int cnt = 0 ; final int [ ] c_s = Arrays . copyOfRange ( chld , 1 , chld . length + 1 ) ; for ( int i = 1 ; i <= chld . length ; i ++ ) { for ( int j = 0 ; j < cnt ; j ++ ) { c_s [ i ] = cnt + j ; } } if ( nt . length == 1 ) { return cnt % m ; } else { return ( cnt + 1 ) % m ; } } }
public static int n ( Scanner scanner ) { int n = Integer . parseInt ( scanner . nextLine ( ) ) ; List < Integer > l = Arrays . asList ( scanner . nextLine ( ) . split ( " ▁ " ) ) ; if ( n == 1 ) { System . out . println ( l . get ( 0 ) ) ; } else { int x = Math . abs ( l . get ( 0 ) - l . get ( 1 ) ) ; int m1 = Math . min ( l . get ( 0 ) , l . get ( 1 ) ) ; int m2 = Math . max ( l . get ( 0 ) , l . get ( 1 ) ) ; System . out . println ( ( m1 + m2 ) / 2 ) ; } return n ; }
x = Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . filter ( x -> x . length > 0 ) . collect ( Collectors . toList ( ) ) ; for ( int i = 0 ; i < x . length ; i ++ ) { x [ i ] = Integer . parseInt ( x [ i ] ) ; } int a = x [ 0 ] ; int b = x [ 1 ] ; System . out . print ( Math . min ( x . length , b ) + " ▁ " ) ; if ( Math . abs ( a - b ) >= 2 ) { System . out . print ( Math . abs ( a - b ) / 2 ) ; } else { System . out . println ( 0 ) ; } }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int q = n / m ; int r = n % m ; int [ ] a = new int [ m ] ; for ( int i = 0 ; i < r ; i ++ ) a [ i ] ++ ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; return m ; }
public static int countSetBits ( int n ) { int count = 0 ; while ( ( n > 0 ) && ( n != 0 ) ) { count += n & 1 ; n >>>= 1 ; } return count ; } public static final int totalPairs ( String s1 , String s2 ) { int count = 0 ; ; int arr1 [ ] = new int [ 7 ] ; int arr2 [ ] = new int [ 7 ] ; ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { int setBits = countSetBits ( ( char ) s1 . charAt ( i ) ) ; arr1 [ setBits ] ++ ; } ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { int setBits = countSetBits ( ( char ) s2 . charAt ( i ) ) ; ; arr2 [ setBits ] ++ ; } ; for ( int i = 1 ; i < 7 ; i ++ ) { count += ( arr1 [ i ] * arr2 [ i ] ) ; } ; return count ; } public static String toString ( ) { if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " win " ) ) { return " geeks " ; } else if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " mac " ) ) { return " forgeeks " ; } else { return " geeks " ; } } public static String [ ] getNegativeInstanceNames ( ) { return new String [ ] { " " , " " } ; } }
public static int countSubSeq ( int i , int Sum , int cnt , int [ ] a , int n ) { if ( ( i == n ) && ( Sum == 0 && cnt > 0 ) ) { if ( ( Sum == 0 && cnt > 0 ) || ( Sum == 1 && cnt > 0 ) ) return 1 ; else return 0 ; } int ans = 0 ; ans += countSubSeq ( i + 1 , Sum , cnt , a , n ) ; ans += countSubSeq ( i + 1 , Sum + a [ i ] , cnt + 1 , a , n ) ; return ans ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) ; String in = JOptionPane . showInputDialog ( " Enter ▁ the ▁ input ▁ string " ) ; if ( n % 2 == 0 ) { int index = Integer . parseInt ( in ) - 1 ; } else { int index = Integer . parseInt ( in ) ; } final String [ ] in = new String [ n ] ; int j = 0 ; final List < String > inList = new ArrayList < String > ( ) ; for ( int i = 0 ; i < in . length ; i ++ ) { inList . add ( in [ i ] ) ; } final List < String > outList = new ArrayList < String > ( ) ; while ( ( inList . size ( ) > 0 ) && ( outList . size ( ) < n ) ) { if ( ( j == 0 ) || ( j == 1 ) ) { outList . set ( index , inList . get ( 0 ) ) ; inList . remove ( 0 ) ; } else { if ( ( n % 2 != 0 ) && ( index - j >= 0 ) ) { if ( ( index - j ) >= 0 ) { outList . set ( index - j , inList . get ( 0 ) ) ; inList . remove ( 0 ) ; } if ( ( index + j < n ) && ( index + j < n ) ) { outList . set ( index + j , inList . get ( 0 ) ) ; inList . remove ( 0 ) ; } } else { if ( ( index + j < n ) && ( index - j >= 0 ) ) { outList . set ( index - j , inList . get ( 0 ) ) ; inList . remove ( 0 ) ; } } } j ++ ; } }
public static int testSum ( int a , int n , int m ) { int count = 0 ; List < Integer > checkList = new ArrayList < Integer > ( ) ; int i = 0 ; if ( a == 0 ) { i = 1 ; } while ( ( i + a ) * n < m ) { checkList . add ( ( i + a ) * n ) ; i ++ ; } for ( int x : checkList ) { int [ ] xl = new int [ Integer . SIZE ] ; for ( int i = 0 ; i < Integer . SIZE ; i ++ ) { xl [ i ] = Integer . parseInt ( String . valueOf ( x ) ) ; } int y = sum ( xl ) ; if ( x == ( y + a ) * n ) { count ++ ; } } System . out . println ( count ) ; }
public static int pivotBinarySearch ( int [ ] arr , int n , int key ) { int pivot = findPivot ( arr , 0 , n - 1 ) ; ; if ( pivot == - 1 ) return binarySearch ( arr , 0 , n - 1 , key ) ; ; if ( arr [ pivot ] == key ) return pivot ; if ( arr [ 0 ] <= key ) return binarySearch ( arr , 0 , pivot - 1 , key ) ; ; return binarySearch ( arr , pivot + 1 , n - 1 , key ) ; }
public static int n ( ) { int n = Integer . parseInt ( System . in . readLine ( ) ) + 1 ; int d = 1000000007 ; int [ ] [ ] g = new int [ n ] [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) { g [ i ] [ 0 ] = g [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) { g [ i ] [ j ] = ( g [ i ] [ j - 1 ] + g [ i - 1 ] [ j - 1 ] ) % d ; } } System . out . println ( ( g [ n - 1 ] [ - 1 ] - g [ n - 1 ] [ 0 ] ) % d ) ; return n ; }
public static void main ( String [ ] args ) { final StringBuilder answer = new StringBuilder ( ) ; final int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ words " ) ) ; final List < Integer > a = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ list " ) . split ( " ▁ " ) ) ; final List < Integer > b = Collections . unmodifiableList ( a ) ; final Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; map . put ( x , i ) ; boolean [ ] visited = new boolean [ n ] ; for ( int i = 0 , x = a . size ( ) ; i < n ; i ++ ) { if ( visited [ i ] ) continue ; final List < Integer > list = new ArrayList < Integer > ( ) ; list . add ( i ) ; visited [ i ] = 1 ; final Integer hold = a . get ( i ) ; while ( hold != b . get ( list . size ( ) - 1 ) ) { final Integer z = map . get ( b . get ( list . size ( ) - 1 ) ) ; visited [ z ] = 1 ; list . add ( z ) ; } answer . append ( ' ▁ ' ) . append ( StringUtil . join ( list , " ▁ " ) ) ; } System . out . println ( answer . toString ( ) ) ; System . out . println ( answer . toString ( ) ) ; }
public static void makeGuruguru ( int d ) { vector [ ] = { new int [ ] { 0 , - 1 } , new int [ ] { 1 , 0 } , new int [ ] { 0 , 1 } , new int [ ] { - 1 , 0 } } ; final StringBuilder lst = new StringBuilder ( d + 4 ) ; for ( ; d < d + 2 ; d ++ ) lst . append ( new char [ ] { ' # ' } ) ; for ( ; d < d + 4 ; d ++ ) lst . append ( new char [ ] { ' # ' } ) ; int x = 2 , y = d + 1 ; lst . charAt ( y ) = ' # ' ; int direct = 0 ; int vx = vector [ 0 ] . length ; int vy = vector [ 1 ] . length ; int cnt = 1 ; while ( true ) { while ( lst . charAt ( y + vy * 2 ) == ' ▁ ' ) { lst . charAt ( y + vy ) = ' # ' ; y += vy ; x += vx ; cnt ++ ; } if ( cnt <= 1 ) break ; direct = ( direct + 1 ) % 4 ; vx = vector [ direct ] . length ; cnt = 0 ; } for ( y = 2 ; y < d ; y ++ ) System . out . println ( " " + lst . charAt ( y ) . substring ( 2 , d - 2 ) ) ; int n = Integer . parseInt ( System . in . readLine ( ) ) ; makeGuruguru ( Integer . parseInt ( System . in . readLine ( ) ) ) ; for ( ; n - 1 > 0 ; n -- ) { System . out . println ( ) ; makeGuruguru ( Integer . parseInt ( System . in . readLine ( ) ) ) ; } }
static final public String compute ( ) { int ans = sum ( 1 << 10 ) ; for ( int i = 0 ; i < 1 << 10 ; i ++ ) { for ( int j = i ; j < 1 << 10 ; j ++ ) { if ( eulerLib . popCount ( i ) == eulerLib . popCount ( j ) == 6 && isArrangementValid ( i , j ) ) { ans += String . valueOf ( ans ) ; } } } final boolean isArrangementValid = true ; int a = 0 , b = 0 ; if ( testBit ( a , 6 ) || testBit ( a , 9 ) ) a |= ( 1 << 6 ) | ( 1 << 9 ) ; if ( testBit ( b , 6 ) || testBit ( b , 9 ) ) b |= ( 1 << 6 ) | ( 1 << 9 ) ; return String . valueOf ( ans ) ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ be ▁ inserted " ) ) ; int [ ] [ ] a = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int [ ] info = new int [ n ] ; JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ be ▁ inserted " ) ; for ( int j = 0 ; j < info . length ; j ++ ) { info [ j ] = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ be ▁ inserted " ) ) ; } for ( int j = info . length - 2 ; j >= 0 ; j -- ) { a [ i ] [ j - 1 ] = 1 ; } } } for ( int [ ] v : a ) { System . out . println ( new Integer ( v [ 0 ] ) ) ; } return n ; }
n , m = map . size ( ) ; int [ ] [ ] a = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] x = new int [ i ] ; for ( int j = 0 ; j < m ; j ++ ) { x [ j ] = i ; } a [ i ] = x ; } int count = 0 ; for ( int j = 0 ; j < m - 1 ; j ++ ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { Set < Integer > x = new HashSet < Integer > ( ) ; x . add ( a [ i ] [ j ] ) ; x . add ( a [ i + 1 ] [ j ] ) ; x . add ( a [ i ] [ j + 1 ] ) ; x . add ( a [ i + 1 ] [ j + 1 ] ) ; x . add ( a [ i + 1 ] [ j + 1 ] ) ; if ( x . equals ( new Integer ( ' a ' ) ) ) count ++ ; } } System . out . println ( count ) ; }
public static String alternatingCurrent ( List < String > wires ) { final int INF = ( int ) ( 1e9 + 7 ) ; System . setSecurityManager ( new SecurityManager ( ) ) ; final List < String > stk = new ArrayList < String > ( ) ; for ( String upperWire : wires ) { if ( stk . size ( ) > 0 && stk . get ( stk . size ( ) - 1 ) . equals ( upperWire ) ) { stk . remove ( stk . size ( ) - 1 ) ; continue ; } stk . add ( upperWire ) ; } if ( stk . size ( ) > 0 ) { return " No " ; } return " Yes " ; }
public static final void main ( String [ ] args ) { System . setSecurityManager ( new SecurityManager ( ) ) ; final Scanner scanner = new Scanner ( System . in ) ; scanner . useDelimiter ( " ▁ " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " ; " ) ; scanner . useDelimiter ( " ; " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter ( " , " ) ; scanner . useDelimiter (
MAX = 100 ; int countMountains ( int [ ] [ ] a , int n ) { int [ ] [ ] A = new int [ n + 2 ] [ n + 2 ] ; int count = 0 ; for ( int i = 0 ; i < n + 2 ; i ++ ) { for ( int j = 0 ; j < n + 2 ; j ++ ) { if ( ( ( i == 0 ) || ( j == 0 ) || ( i == n + 1 ) || ( j == n + 1 ) ) && ( a [ i ] [ j ] > a [ i - 1 ] [ j - 1 ] ) ) { A [ i ] [ j ] = Integer . MAX_VALUE ; } else { A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] ; } } } for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) ) { count = count + 1 ; } } } return count ; }
public static final int [ ] [ ] getDivisors ( ) { ; int N = 100005 ; int [ ] [ ] d = new int [ N ] [ N ] ; int [ ] pre = new int [ N ] [ N ] ; final int [ ] [ ] Positive_Divisors = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j <= Integer . MAX_VALUE ; j ++ ) { if ( ( i % j == 0 ) && ( j * j == i ) ) { if ( ( j * j == i ) && ( d [ i ] [ j ] == 0 ) ) { d [ i ] [ j ] ++ ; } else { d [ i ] [ j ] += 2 ; } } } } int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( ( d [ i ] [ i ] == d [ i - 1 ] [ i ] ) && ( pre [ i ] [ i ] == 0 ) ) { ans ++ ; } pre [ i ] = ans ; } return d ; }
n , m ) public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int i = s . nextInt ( ) ; int [ ] a = new int [ m ] ; int num = 1 ; final int x = Integer . parseInt ( args [ 0 ] ) ; synchronized ( num ) { x = Integer . parseInt ( args [ 1 ] ) ; for ( int i = 0 ; i < m - x + 1 ; i ++ ) { if ( a [ i ] == 0 ) { a [ i ] = new int [ num ] ; System . out . println ( num ) ; num ++ ; return ; } } System . out . println ( " NULL " ) ; } final int erase = Integer . parseInt ( args [ 2 ] ) ; x = Integer . parseInt ( args [ 3 ] ) ; if ( x != 0 || x < 1 ) { System . out . println ( " ILLEGAL _ ERASE _ ARGUMENT " ) ; } for ( int i = 0 , j = a . length ; i < m ; i ++ ) { if ( a [ i ] == x ) { a [ i ] = 0 ; } } }
static double areaOfRegularPolygon ( int n , int len ) { double P = ( len * n ) ; ; double A = len / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; double area = ( P * A ) / 2 ; return area ; }
MAX = 256 ; public static String lastNonRepeating ( String string , int n ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ ( int ) string . charAt ( i ) ] ++ ; for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = string . charAt ( i ) ; ; if ( ( freq [ ( int ) ch ] == 1 ) && ( freq [ ( int ) ch ] == 0 ) ) return ( " " + ch ) ; } return " - 1" ; } if ( Main . isWindows ) { String string = " GeeksForGeeks " ; int n = string . length ( ) ; ; System . out . println ( lastNonRepeating ( string , n ) ) ; ; } return " " ; }
public static int [ ] [ ] findMina ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ input ▁ to ▁ search " ) ) ; int [ ] [ ] a = new int [ n ] [ n ] ; int minx = 1000000000 ; int maxy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = map . get ( JOptionPane . YES_OPTION ) ; int y = map . get ( JOptionPane . NO_OPTION ) ; minx = Math . min ( minx , x ) ; maxy = Math . max ( maxy , y ) ; a [ i ] [ 0 ] = new int [ ] { x , y } ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] [ 0 ] == minx && a [ i ] [ 1 ] == maxy ) { System . out . println ( i + 1 ) ; break ; } } else { System . out . println ( - 1 ) ; } return a ; }
public static double y ( double x ) { return ( 1 / ( 1 + x ) ) ; }
public static final int [ ] [ ] findLen ( int [ ] arr , int i , int curr , int n , int m ) { int maxN = 20 ; int maxM = 256 ; int [ ] [ ] dp = new int [ maxN ] [ maxM ] ; ; int [ ] [ ] v = new int [ maxN ] [ maxM ] ; ; final int i = arr [ i ] ; int curr = arr [ curr ] ; if ( ( i == n ) && ( curr == m ) ) { if ( ( curr == m ) ) { return 0 ; } else { return - 1 ; } } if ( ( v [ i ] [ curr ] ) != 0 ) { return dp [ i ] [ curr ] ; } v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; ; int r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; ; dp [ i ] [ curr ] = l ; if ( ( r != - 1 ) && ( r == - 1 ) ) { dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; } return dp [ i ] [ curr ] ; }
public static final int [ ] [ ] findLen ( int [ ] arr , int i , int curr , int n , int m ) { int maxN = 20 ; int maxM = 64 ; int [ ] [ ] dp = new int [ maxN ] [ maxM ] ; ; int [ ] [ ] v = new int [ maxN ] [ maxM ] ; ; final int i = arr [ i ] ; int curr = arr [ curr ] ; if ( ( i == n ) && ( curr == m ) ) { if ( ( curr == m ) ) { return 0 ; } else { return - 1 ; } } if ( ( v [ i ] [ curr ] ) != 0 ) { return dp [ i ] [ curr ] ; } v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; ; int r = findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) ; ; dp [ i ] [ curr ] = l ; if ( ( r != - 1 ) && ( r == - 1 ) ) { dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; } return dp [ i ] [ curr ] ; }
public static int [ ] [ ] dfs ( int cur , int pre ) { while ( 1 ) { int N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ words ▁ to ▁ print " ) ) ; if ( N == 0 ) break ; int [ ] [ ] R = new int [ N + 1 ] [ N + 1 ] ; final int dfs_max = R [ cur ] [ pre ] ; int _max = - R [ cur ] [ pre ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) { if ( R [ cur ] [ i ] > 0 && i != pre ) _max = Math . max ( _max , dfs_max ( i , cur ) + R [ cur ] [ i ] ) ; } return R [ cur ] ; } int total = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ words ▁ to ▁ print " ) ) , b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ words ▁ to ▁ print " ) ) , t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ words ▁ to ▁ print " ) ) ; R [ a ] [ b ] = t ; R [ b ] [ a ] = t ; total += ( t * 2 ) ; } for ( int i = 2 ; i <= N ; i ++ ) { int [ ] spam = new int [ R [ i ] . length ] ; for ( int j = 0 ; j < R [ i ] . length ; j ++ ) spam [ j ] = R [ i ] [ j ] ; if ( ( spam . length <= 1 ) && ( spam [ 0 ] == 0 ) ) total -= ( spam [ 0 ] * 2 ) ; } System . out . println ( ( total - dfs_max ( 1 , 0 ) ) ) ; return R ; }
public static int N = Integer . parseInt ( System . in ) ; static final int aaa ( int n ) { if ( Integer . parseInt ( n ) > N ) return 0 ; int ans = 1 == new HashSet < Integer > ( Arrays . asList ( Integer . toString ( n ) ) ) . contains ( "7" ) ? 1 : 0 ; for ( int i : "753" ) ans += aaa ( n + i ) ; return ans ; }
public static int minDiff ( int [ ] arr , int n , int k ) { int result = + 2147483647 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { result = ( int ) Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; } return result ; }
public static final void main ( String [ ] args ) { System . setSecurityManager ( new SecurityManager ( ) ) ; int LINE_NUM = 0 , TOTAL = 0 ; ArrayList < Balls > balls = new ArrayList < Balls > ( ) ; int i ; for ( ; ; ) { i = 0 ; LINE_NUM ++ ; if ( LINE_NUM == 1 ) { TOTAL = Integer . parseInt ( System . getProperty ( " line . separator " ) ) ; continue ; } balls . add ( new Balls ( Integer . parseInt ( System . getProperty ( " line . separator " ) ) ) ) ; if ( LINE_NUM == TOTAL + 1 ) break ; } class VesselClass implements VesselBase { public Balls [ ] getBalls ( ) { Balls tmp = new Balls [ LINE_NUM ] ; ArrayList < Balls > left = new ArrayList < Balls > ( ) ; ArrayList < Balls > right = new ArrayList < Balls > ( ) ; } public void fill ( Balls balls ) { tmp = balls ; } public void DFS ( ) { if ( tmp . size ( ) == 0 ) System . out . println ( " YES " ) ; else if ( left . get ( tmp . size ( ) - 1 ) < tmp . get ( 0 ) ) { left . add ( tmp . get ( 0 ) ) ; tmp . remove ( 0 ) ; DFS ( ) ; } else if ( right . get ( tmp . size ( ) - 1 ) < tmp . get ( 0 ) ) { right . add ( tmp . get ( 0 ) ) ; tmp . remove ( 0 ) ; DFS ( ) ; } else System . out . println ( " NO " ) ; } } Balls [ ] ballsArray = loadBalls ( ) ; for ( Balls balls : ballsArray ) { Vessel Vessel = new VesselClass ( ) ; Vessel . fill ( balls ) ; Vessel . DFS ( ) ; } }
public static int t ( int x ) { int y = 0 ; int j = 1 ; while ( y < x ) { y += j ; if ( y == x ) return ( j ) ; j ++ ; } if ( y - x == 1 ) return ( j ) ; else return ( j - 1 ) ; for ( int i = 0 ; i < t ; i ++ ) { int i = Integer . parseInt ( input . nextLine ( ) ) ; System . out . println ( solve ( i ) ) ; } return 0 ; }
public static double Mean ( int [ ] arr , int n ) { double sm = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sm = sm + arr [ i ] ; return sm / n ; final double meanAbsoluteDeviation = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { absSum = 0 ; for ( int j = 0 ; j <= n ; j ++ ) absSum = absSum + Math . abs ( arr [ i ] - Mean ( arr , n ) ) ; } arr = new int [ n ] ; arr [ 0 ] = 10 ; arr [ 1 ] = 15 ; arr [ 2 ] = 15 ; arr [ 3 ] = 17 ; arr [ 4 ] = 18 ; arr [ 5 ] = 21 ; n = arr . length ; System . out . println ( meanAbsoluteDeviation ) ; }
public static final String compute ( ) { final int LIMIT = 10 * 9 ; int [ ] primes = EulerLib . listPrimes ( 100 ) ; final int count = primes . length ; if ( primeIndex == primes . length ) { return 1 == count ? 0 : 1 ; } else { int result = 0 ; while ( product <= LIMIT ) { result += count ( primeIndex + 1 , product ) ; product *= primes [ primeIndex ] ; } return result ; } }
static int maximumXOR ( int n , int l , int r ) { int x = 0 ; for ( int i = ( int ) Math . log2 ( r ) ; i >= 0 ; i -- ) { if ( ( n & ( 1 << i ) ) != 0 ) { if ( ( x > r ) || ( x + ( 1 << i ) - 1 < l ) ) x ^= ( 1 << i ) ; } else { if ( ( x ^ ( 1 << i ) ) <= r ) x ^= ( 1 << i ) ; } } return n ^ x ; }
public static int maxPrimefactorNum ( int N ) { boolean [ ] arr = new boolean [ N + 5 ] ; arr [ 0 ] = true ; ; int i = 3 ; ; while ( ( i * i <= N ) && ( arr [ i ] ) ) { if ( ( arr [ i ] ) ) { for ( int j = i * i ; j < N + 1 ; j += i ) { arr [ j ] = false ; } } i += 2 ; } ; int [ ] prime = new int [ N + 1 ] ; prime [ 0 ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( ( arr [ i ] ) ) { prime [ i ] = i ; } } i = 0 ; int ans = 1 ; while ( ( ans * prime [ i ] ) <= N && i < prime . length ) { ans *= prime [ i ] ; i ++ ; } return ans ; }
public static int CountTrailingZeros ( int n ) { String bit = Integer . toString ( n ) . substring ( 2 ) ; bit = bit . substring ( 0 , bit . length ( ) - 1 ) ; int zero = 0 ; ; for ( int i = 0 ; i < bit . length ( ) ; i ++ ) { if ( ( bit . charAt ( i ) == '0' ) && ( bit . charAt ( i + 1 ) == ' ▁ ' ) ) zero ++ ; else break ; } return zero ; }
public static int a ( int a , int b , int c ) { int case_1 = a + b + c ; int case_2 = a + a + b + b ; int case_3 = a + c + c + a ; int case_4 = b + c + c + b ; System . out . println ( Math . min ( case_1 , case_2 ) ) ; return case_3 ; }
public static int main ( String [ ] args ) { for ( int t = 0 ; t < Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) ; ) { int n = JOptionPane . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) ; int [ ] p = Arrays . copyOf ( JOptionPane . getSelectedValues ( ) , JOptionPane . DEFAULT_OPTION ) ; int result = 0 ; int c = 0 ; while ( c < n - 1 ) { if ( p [ c ] > p [ c + 1 ] ) { result ++ ; c ++ ; } c ++ ; } System . out . println ( result ) ; } return 0 ; }
public static int distinctSubstring ( String P , String Q , int K , int N ) { Set < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; ; i ++ ) { int sum = 0 ; ; StringBuffer sb = new StringBuffer ( ) ; for ( int j = i ; j < N ; j ++ ) { int pos = ( char ) P . charAt ( j ) - 97 ; sum = sum + ( char ) Q . charAt ( pos ) - 48 ; sb . append ( P . charAt ( j ) ) ; if ( ( sum <= K ) && ( sum <= K ) ) { S . add ( sb . toString ( ) ) ; } else { break ; } } } return S . size ( ) ; }
public static String makeEven ( String arr [ ] , int n ) { int firstEI = - 1 ; int lastEI = - 1 ; int lastNI = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( Integer . parseInt ( arr [ i ] ) % 2 == 0 && Integer . parseInt ( arr [ i ] ) < Integer . parseInt ( arr [ lastNI ] ) ) ) { firstEI = i ; break ; } if ( Integer . parseInt ( arr [ i ] ) % 2 == 0 ) { lastEI = i ; } } if ( firstEI != - 1 ) { ( arr [ firstEI ] ) = arr [ lastNI ] ; return arr [ firstEI ] ; } if ( firstEI == - 1 && lastEI != - 1 ) { ( arr [ lastEI ] ) = arr [ lastNI ] ; return arr [ lastEI ] ; } return arr [ lastNI ] ; if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { String string = "1356425" ; String result = " " ; result = makeEven ( Arrays . asList ( string ) , Arrays . asList ( string . split ( " ▁ " ) ) ) ; System . out . println ( result ) ; } return result ; }
public static void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j * i <= n ) { div [ i * j ] ++ ; } } } for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( div [ i ] + " ▁ " ) ; } if ( System . getSecurityManager ( ) == null ) { n = 10 ; findDivisors ( n ) ; } }
public static int [ ] [ ] getNegativeInstances ( ) { int [ ] [ ] instances = new int [ 2 ] [ ] ; instances [ 0 ] = 0 ; instances [ 1 ] = 0 ; int [ ] numOf0 = new int [ b . length + 1 ] ; for ( int i = 0 ; i < b . length ; i ++ ) { numOf0 [ i ] = numOf0 [ i - 1 ] + ( b [ i ] == '0' ) ; numOf1 [ i ] = numOf1 [ i - 1 ] + ( b [ i ] == '1' ) ; } for ( int i = 0 ; i < a . length ; i ++ ) { instances [ i ] = ( numOf1 [ b . length - a . length + i ] - numOf1 [ i - 1 ] ) == 0 ? 1 : ( numOf0 [ b . length - a . length + i ] - numOf0 [ i - 1 ] ) ; } System . out . println ( instances [ 0 ] [ 0 ] ) ; return instances ; }
public static void MAX_CHAR = 256 ; public static void printDistinct ( String Str ) { int n = Str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = Character . digit ( Str . charAt ( i ) , 16 ) ; count [ x ] ++ ; if ( ( count [ x ] == 1 && x != ' ▁ ' ) || ( count [ x ] == 2 ) ) index [ x ] = i ; if ( ( count [ x ] == 3 ) || ( count [ x ] == 4 ) ) index [ x ] = n ; } Arrays . sort ( index ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( index [ i ] == n ) break ; System . out . print ( Str . charAt ( index [ i ] ) + " ▁ " ) ; } Str = " GeeksforGeeks " ; printDistinct ( Str ) ; }
public static int calculate ( int x , int k , int m ) { double result = x ; ; k = k - 1 ; ; while ( ( k > 0 ) && ( result > m ) ) { result = Math . pow ( result , x ) ; ; if ( ( result > m ) && ( result > k ) ) { result = result % m ; ; } k = k - 1 ; ; } return ( int ) result ; }
public static void converthenumber ( int n ) { String s = Integer . toString ( n ) ; ; String res = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s . charAt ( i ) == '1' || s . charAt ( i ) == '3' || s . charAt ( i ) == '5' || s . charAt ( i ) == '7' || s . charAt ( i ) == '9' ) && res += s . charAt ( i ) ; if ( ( res . length ( ) == 2 ) && ( res . charAt ( 0 ) == ' - ' ) ) break ; } if ( ( res . length ( ) == 2 ) && ( res . charAt ( 0 ) == ' - ' ) ) System . out . println ( res ) ; else System . out . println ( " - 1" ) ; }
public static void solve ( ) { int n = Integer . parseInt ( System . in . readLine ( ) ) ; Scanner s = new Scanner ( System . in ) ; for ( int a = 0 ; a < 26 ; a ++ ) { char c = ( char ) ( a + Character . MIN_VALUE ) ; if ( c != ' a ' ) { System . out . println ( c ) ; return ; } } for ( int a = 0 ; a < 26 ; a ++ ) { char c1 = ( char ) ( a + Character . MIN_VALUE ) ; for ( int b = 0 ; b < 26 ; b ++ ) { char c2 = ( char ) ( b + Character . MIN_VALUE ) ; char c = c1 + c2 ; if ( c != ' a ' ) { System . out . println ( c ) ; return ; } } } for ( int a = 0 ; a < 26 ; a ++ ) { char c1 = ( char ) ( a + Character . MIN_VALUE ) ; for ( int b = 0 ; b < 26 ; b ++ ) { char c2 = ( char ) ( b + Character . MIN_VALUE ) ; char c4 = c1 + c2 ; for ( int d = 0 ; d < 26 ; d ++ ) { char c3 = ( char ) ( d + Character . MIN_VALUE ) ; char c = c4 + c3 ; if ( c != ' a ' ) { System . out . println ( c ) ; return ; } } } } int t = Integer . parseInt ( System . in . readLine ( ) ) ; while ( t != 0 ) { t -- ; solve ( ) ; } }
public static void main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ display " ) ) ; ; List < Integer > l = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ elements ▁ to ▁ display " ) . split ( " ▁ " ) ) ; Set < Integer > a = new HashSet < Integer > ( l ) ; int [ ] l1 = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { l1 [ i ] = Math . max ( i , a . size ( ) ) ; } System . out . println ( new String ( l1 ) ) ; } }
static int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; ; }
public static int h ( ) { int h = Integer . parseInt ( input . nextLine ( ) ) ; int w = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] s = new int [ h ] ; for ( ; h > 0 ; h -- ) { s [ h ] = Arrays . parseInt ( input . nextLine ( ) ) ; } int ans = 0 ; int [ ] ci = new int [ w ] ; for ( ; w > 0 ; w -- ) { for ( int i = h - 1 ; i >= 0 ; i -- ) { int co = 0 ; for ( int j = w - 1 ; j >= 0 ; j -- ) { if ( s [ i ] [ j ] == ' J ' ) { ans += co * ci [ j ] ; } else if ( s [ i ] [ j ] == ' O ' ) { co ++ ; } else if ( s [ i ] [ j ] == ' I ' ) { ci [ j ] ++ ; } } } } System . out . println ( ans ) ; return ans ; }
public static int countDivisors ( int n , int k ) { int count = 0 ; for ( int i = 1 ; i <= Integer . MAX_VALUE ; i ++ ) { if ( ( n % i == 0 ) && ( i % k == 0 ) ) { if ( ( n % i == k ) && ( ( n / i ) % k == 0 ) ) { count ++ ; } if ( ( ( n / i ) % k == 0 ) && ( ( n / i ) % k == 0 ) ) { count ++ ; } } } if ( ( ( i * i == n ) && ( i % k == 0 ) ) && ( ( n / i ) % k == 0 ) ) { count -- ; } return count ; }
public static int countDivisors ( int n , int k ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( n % i == 0 && i % k == 0 ) || ( n % i == 0 && i % k == 0 ) ) { count ++ ; } } return count ; }
public static int power ( int x , int y , int p ) { int res = 1 ; ; x = x % p ; ; while ( ( y > 0 ) && ( y > 1 ) ) { if ( ( y > 0 ) && ( y > 1 ) ) res = ( res * x ) % p ; y = y > > 1 ; ; x = ( x * x ) % p ; } ; return res ; }
public static int t ( ) { int t = Integer . parseInt ( input . nextLine ( ) ) ; for ( ; ; ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] p = Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] q = Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] evenP = new int [ p . length + m ] ; for ( int i = 0 ; i < p . length ; i ++ ) { evenP [ i ] = p [ i ] % 2 ; } int [ ] oddP = new int [ p . length + m ] ; for ( int i = 0 ; i < p . length ; i ++ ) { oddP [ i ] = p [ i ] % 2 ; } int [ ] evenQ = new int [ q . length + m ] ; for ( int i = 0 ; i < q . length ; i ++ ) { evenQ [ i ] = q [ i ] % 2 ; } int [ ] oddQ = new int [ q . length + m ] ; for ( int i = 0 ; i < q . length ; i ++ ) { oddQ [ i ] = q [ i ] % 2 ; } System . out . println ( evenQ . length * evenQ . length + oddQ . length * oddQ . length ) ; } }
public static int findMaxDiff ( int [ ] a , int n ) { if ( ( n < 2 ) || ( n > 4 ) ) { System . out . print ( " Invalid ▁ " ) ; return 0 ; } int min_val = Integer . MAX_VALUE ; int max_val = - Integer . MAX_VALUE - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( a [ i ] - i ) > max_val ) && ( ( a [ i ] - i ) < min_val ) ) { max_val = a [ i ] - i ; } if ( ( ( a [ i ] - i ) < min_val ) && ( ( a [ i ] - i ) > max_val ) ) { min_val = a [ i ] - i ; } } return ( max_val - min_val ) ; if ( Main . isWindows ) { int [ ] arr = { 9 , 15 , 4 , 12 , 13 } ; n = arr . length ; System . out . println ( findMaxDiff ( arr , n ) ) ; } else { int [ ] arr = { 9 , 15 , 4 , 12 , 13 } ; n = arr . length ; System . out . println ( findMaxDiff ( arr , n ) ) ; } return ( max_val - min_val ) ; }
public static int n ( ) { int n = Integer . parseInt ( System . in ) ; char h = ' # ' ; int [ ] [ ] f = new int [ n + 2 ] [ n + 2 ] ; int [ ] [ ] a = f . clone ( ) ; for ( ; n > 0 ; n -- ) { a [ n ] = f [ n ] ; } return n ; }
public static int numberOfPaths ( int m , int n ) { int [ ] [ ] count = new int [ m ] [ n ] ; for ( int y = 0 ; y < n ; y ++ ) { count [ y ] [ 0 ] = 0 ; } ; for ( int i = 0 ; i < m ; i ++ ) { count [ i ] [ 0 ] = 1 ; } ; for ( int j = 0 ; j < n ; j ++ ) { count [ 0 ] [ j ] = 1 ; } ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } } ; m = 3 ; n = 3 ; System . out . println ( numberOfPaths ( m , n ) ) ; }
public static void main ( String [ ] args ) { int m = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ question ▁ to ▁ solve " ) ) ; for ( int i = 0 ; i < m ; i ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ answer ▁ to ▁ solve " ) ) ; List < Integer > a = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ answer ▁ to ▁ solve " ) . split ( " ▁ " ) ) ; int s = sum ( a ) ; if ( ( s % n == 0 ) && ( s / n == 0 ) ) { if ( ( s / n == a . size ( ) ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } else { System . out . println ( " NO " ) ; } } }
public static boolean isKthBitSet ( int n , int k ) { if ( ( ( n > > > ( k - 1 ) ) & 1 ) != 0 ) return true ; return false ; } public static final void setKthBit ( int n , int k ) { ( ( 1 << ( k - 1 ) ) | n ) ; } public static final boolean allBitsAreSet ( int n ) { if ( ( ( ( n + 1 ) & n ) == 0 ) && ( ( n & 1 ) == 0 ) ) return true ; return false ; } public static boolean bitsAreInAltOrder ( int n ) { int num = n ^ ( n > > > 1 ) ; return allBitsAreSet ( num ) ; } public static boolean bitsAreInAltPatrnInGivenRange ( int n , int l , int r ) { if ( ( isKthBitSet ( n , r ) ) && ( ( n & 1 ) == 0 ) ) { num = n ; int leftShift = r ; if ( ( ( n & 1 ) == 0 ) && ( ( l & 1 ) == 0 ) ) { num = n ; leftShift = r + 1 ; } num = num & ( ( 1 << leftShift ) - 1 ) ; num = num > > > ( l - 1 ) ; return bitsAreInAltOrder ( num ) ; } public static boolean bitsAreInAltPatrnInGivenRange ( int n , int l , int r ) { if ( ( bitsAreInAltPatrnInGivenRange ( n , l , r ) ) && ( ( n & 1 ) == 0 ) && ( ( l & 1 ) == 0 ) ) { return true ; } return false ; } public static boolean bitsAreInAltPatrnInGivenRange ( int n , int l , int r ) { if ( ( bitsAreInAltPatrnInGivenRange ( n , l , r ) ) && ( ( n & 1 ) == 0 ) && ( ( l & 1 ) == 0 ) ) { return true ; } return false ; } public static boolean isKthBitSet ( int n , int k ) { if ( ( n & 1 ) == 0 ) { n = 18 ; l = 1 ; r = 3 ; } return ( n & 1 ) != 0 ; } public static boolean isKthBitSet ( int n , int k ) { return ( n & 1 ) != 0 ; } } </DOCUMENT>
public static int factorial ( int n ) { if ( ( n <= 1 ) && ( n > 0 ) ) return 1 ; ; return n * factorial ( n - 1 ) ; }
public static String commonPrefixUtil ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; String result = " " ; int j = 0 ; int i = 0 ; while ( ( i <= n1 - 1 && j <= n2 - 1 ) || ( i > 0 && j > 0 ) ) { if ( ( str1 . charAt ( i ) != str2 . charAt ( j ) ) || ( str1 . charAt ( i ) != str2 . charAt ( j ) ) ) { break ; } result += ( str1 . charAt ( i ) ) ; i ++ ; j ++ ; } return ( result ) ; } public static void commonPrefix ( String [ ] arr , int n ) { Arrays . sort ( arr , new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . length ( ) - o2 . length ( ) ; } } ) ; System . out . println ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { String [ ] arr = { " geeksforgeeks " , " geeks " , " geek " , " geezer " } ; int n = arr . length ; commonPrefix ( arr , n ) ; } }
public static void main ( String [ ] args ) { from Statistics . median = new Statistics . Median ( ) ; from fractions . gcd = new Statistics . GCD ( ) ; from Iterables . addAll ( from , new ArrayList < > ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values ( ) ) ; from . addAll ( from . values
public static int N ( ) { int N = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; A [ i ] = a ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 ) { now = 0 ; nex = A [ 0 ] ; count ++ ; } else { nex = A [ nex - 1 ] ; count ++ ; } if ( nex == 2 ) { System . out . println ( count ) ; exit ( ) ; } } System . out . println ( - 1 ) ; return count ; }
public static String compute ( ) { int a = 0 ; int b = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { a = b ; b = a + b ; } return String . valueOf ( a ) ; }
public static void findFrequencyUtil ( int [ ] arr , int low , int high , int [ ] freq ) { if ( ( arr [ low ] == arr [ high ] ) && ( freq [ arr [ low ] ] + high - low + 1 ) == 0 ) { freq [ arr [ low ] ] += high - low + 1 ; } else { int mid = ( int ) ( ( low + high ) / 2 ) ; findFrequencyUtil ( arr , low , mid , freq ) ; findFrequencyUtil ( arr , mid + 1 , high , freq ) ; } final int n = arr . length ; freq [ 0 ] = 0 ; findFrequencyUtil ( arr , 0 , n - 1 , freq ) ; for ( int i = 0 ; i <= arr . length - 1 ; i += 1 ) { if ( ( freq [ i ] != 0 ) && ( freq [ i + 1 ] != 0 ) ) { System . out . println ( " Element " + i + " ▁ occurs " + freq [ i ] + " ▁ times " ) ; } } if ( System . getProperty ( " os . arch " ) . equals ( " sparc " ) ) { arr = new int [ ] { 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 } ; n = arr . length ; findFrequency ( arr , n ) ; } }
public static final void main ( String [ ] args ) { List < Integer > totients = EulerLib . listTotients ( 10 * 7 - 1 ) ; int minnumer = 1 ; int mindenom = 0 ; for ( int i = 0 ; ( i < totients . size ( ) ) && ( i < totients . size ( ) ) ; i ++ ) { if ( i * mindenom < minnumer * totients . get ( i ) && Arrays . binarySearch ( totients . subList ( i , i + 1 ) , totients . get ( i ) ) == - 1 ) { minnumer = i ; mindenom = totients . get ( i ) ; } } System . out . println ( String . valueOf ( minnumer ) ) ; }
public static void intersection ( int [ ] a , int [ ] b , int n , int m ) { int i = 0 ; int j = 0 ; while ( ( i < n ) && ( j < m ) ) { if ( ( a [ i ] > b [ j ] ) && ( b [ j ] > a [ i ] ) ) { j ++ ; } else { if ( ( b [ j ] > a [ i ] ) && ( a [ i ] > b [ j ] ) ) { i ++ ; } else { System . out . print ( a [ i ] + " ▁ " ) ; i ++ ; j ++ ; } } } if ( Main . isWindows ( ) ) { a = new int [ ] { 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 } ; b = new int [ ] { 3 , 3 , 5 } ; n = a . length ; m = b . length ; intersection ( a , b , n , m ) ; } }
static final long findMin ( double [ ] a , int n ) { double _sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) _sum += Math . log ( a [ i ] ) ; double x = Math . exp ( _sum / n ) ; return ( long ) ( x + 1 ) ; }
public static final int lcmOfArray ( int [ ] arr , int n ) { if ( ( n < 1 ) || ( n > 2 ) ) return 0 ; int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i += 1 ) { lcm = ( int ) ( ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ) ; } return lcm ; } public static int minPerfectSquare ( int [ ] arr , int n ) { int lcm = lcmOfArray ( arr , n ) ; int minPerfectSq = Integer . MAX_VALUE ; int cnt = 0 ; while ( ( lcm > 1 ) && ( lcm % 2 == 0 ) ) { cnt ++ ; lcm /= 2 ; } if ( ( cnt % 2 != 0 ) && ( lcm % i == 0 ) ) minPerfectSq *= 2 ; int i = 3 ; while ( ( lcm > 1 ) && ( cnt > 0 ) ) { cnt = 0 ; ; while ( ( lcm % i == 0 ) && ( lcm % i == 0 ) ) { cnt ++ ; lcm /= i ; } if ( ( cnt % 2 != 0 ) && ( lcm % i != 0 ) ) minPerfectSq *= i ; i += 2 ; } return minPerfectSq ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 , 7 } ; int n = arr . length ; System . out . println ( minPerfectSquare ( arr , n ) ) ; } }
public static int subarrayCount ( int [ ] arr , int n ) { int result = 0 ; int fast = 0 , slow = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] == 1 ) && ( arr [ i ] - arr [ i - 1 ] == 2 ) ) { fast ++ ; } else { int length = fast - slow + 1 ; result += length * ( length - 1 ) / 2 ; ; fast = i ; slow = i ; } } if ( ( fast != slow ) && ( fast != 0 ) ) { int length = fast - slow + 1 ; result += length * ( length - 1 ) / 2 ; ; } return result ; }
public static int [ ] solve ( int n ) { int f = s = 0 ; boolean fs = true ; if ( n & 1 ) { n -- ; fs = false ; } while ( n > 0 ) { if ( n == 4 ) { f += 3 ; s ++ ; n = 0 ; } else if ( ( n / 2 ) & 1 ) { f += n / 2 ; s ++ ; n = ( n / 2 ) - 1 ; ; } else { f ++ ; s ++ ; n -= 2 ; } } ans . add ( new int [ ] { s + 1 , f } [ fs ] ) ; int [ ] coins = new int [ n ] ; for ( ; n > 0 ; n -- ) { coins [ n ] = Integer . parseInt ( JOptionPane . showInputDialog ( null , " Enter ▁ a ▁ number ▁ to ▁ solve " ) ) ; } for ( int i : coins ) { if ( i == 1 ) ans [ i ] = 1 ; else solve ( i ) ; } System . out . println ( Arrays . toString ( ans ) ) ; return ans ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] a = Arrays . copyOf ( input ( ) . toCharArray ( ) , n ) ; return Math . min ( a . length , n ) ; }
public static final String findSubString ( String strr ) { int n = strr . length ( ) ; if ( n <= 1 ) return strr ; int distCount = new HashSet < String > ( ) . size ( ) ; int currCount = new HashSet < String > ( ) . size ( ) ; int count = 0 ; int start = 0 ; int minLen = n ; for ( int j = 0 ; j < n ; j ++ ) { currCount . add ( strr . charAt ( j ) ) ; if ( currCount . contains ( strr . charAt ( j ) ) ) count ++ ; if ( count == distCount ) { while ( currCount . contains ( strr . charAt ( start ) ) ) { if ( currCount . contains ( strr . charAt ( start ) ) ) currCount . remove ( strr . charAt ( start ) ) ; start ++ ; } int lenWindow = j - start + 1 ; if ( minLen > lenWindow ) { minLen = lenWindow ; startIndex = start ; } } } return String . valueOf ( strr . substring ( startIndex , startIndex + minLen ) ) ; }
public static int concentration ( int water , int suger ) { return 100 * suger / ( water + suger ) ; int WATER_A = water , WATER_B = suger , SUGER_C = suger , SUGER_D = suger , MELT_PER_100 = 1000 , LIMIT = 1000 ; WATER_A *= 100 ; WATER_B *= 100 ; MELT_PERCENT_LIMIT = concentration ( 100 , MELT_PER_100 ) ; int wa = wb = sc = sd = 0 ; Set < Integer > waterSet = new HashSet < Integer > ( ) ; while ( wa * WATER_A <= LIMIT ) { while ( wb * WATER_B <= LIMIT ) { int water = wa * WATER_A + wb * WATER_B ; if ( water <= LIMIT ) waterSet . add ( water ) ; wb ++ ; } wb = 0 ; wa ++ ; } Set < Integer > sugerSet = new HashSet < Integer > ( ) ; while ( sc * SUGER_C <= LIMIT ) { while ( sd * SUGER_D <= LIMIT ) { int suger = sc * SUGER_C + sd * SUGER_D ; if ( suger <= LIMIT ) sugerSet . add ( suger ) ; sd ++ ; } sd = 0 ; sc ++ ; } int ansSugerWater = 0 ; int ansSuger = 0 ; int maxConcentration = 0 ; for ( int water : waterSet ) { for ( int suger : sugerSet ) { if ( ! ( 0 < water + suger <= LIMIT ) ) continue ; int sugerPrecent = concentration ( water , suger ) ; if ( maxConcentration <= sugerPrecent && sugerPrecent <= MELT_PERCENT_LIMIT ) { maxConcentration = sugerPrecent ; ansSugerWater = water + suger ; ansSuger = suger ; } } } System . out . println ( ansSugerWater + " ▁ " + ansSuger ) ; return ansSuger ; }
static int [ ] [ ] testLineNumbers ( ) { Scanner in = new Scanner ( System . in ) ; int [ ] [ ] lines = new int [ in . nextInt ( ) ] [ in . nextInt ( ) ] ; for ( int i = 1 ; i <= lines . length / 2 + 1 ; i ++ ) { for ( int j = 0 ; j < lines [ i ] . length ; j ++ ) { lines [ i ] [ j ] += Math . max ( lines [ i - 1 ] [ Math . max ( j - 1 , 0 ) , Math . min ( j + 1 , lines [ i - 1 ] . length ) ) ) ; } } for ( int i = lines . length / 2 + 1 ; i <= lines . length ; i ++ ) { for ( int j = 0 ; j < lines [ i ] . length ; j ++ ) { lines [ i ] [ j ] += Math . max ( lines [ i - 1 ] [ j ] , 0 ) ; } } System . out . println ( lines [ lines . length - 1 ] [ 0 ] ) ; return lines ; }
public static void countPairs ( int [ ] arr , int n ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 == 0 ) && ( arr [ i ] % 3 == 0 ) ) even ++ ; else odd ++ ; } int odd_pairs = odd * ( n - 1 ) ; int even_pairs = even * ( n - 1 ) ; System . out . println ( odd_pairs ) ; System . out . println ( even_pairs ) ; }
public static int h ( ) { int h = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) ; for ( int x = 0 ; x < h ; x ++ ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) , 0 ; int b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) , 0 ; int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) , 0 ; int m = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ print " ) ) ; int s = Math . min ( m , b ) ; m -= s ; b -= s ; while ( a % 10 == 0 ) { b ++ ; a = a / 10 ; } while ( n % 10 == 0 ) { m ++ ; n = n / 10 ; } h = Integer . toString ( a ) ; k = Integer . toString ( n ) ; if ( h + b > k + m ) { System . out . print ( ' > ' ) ; } else if ( h + b < k + m ) { System . out . print ( ' < ' ) ; } else { if ( h > k ) { System . out . print ( ' > ' ) ; } else if ( h < k ) { System . out . print ( ' < ' ) ; } else { System . out . print ( ' = ' ) ; } } } return h ; }
public static Map < String , Integer > findNumbers ( ) { List < Integer > numbers = Arrays . asList ( input . nextLine ( ) . split ( " ▁ " ) ) ; int columns = numbers . get ( 0 ) ; int rows = numbers . get ( 1 ) ; int counter = - 1 ; Map < String , Integer > data = new HashMap < > ( ) ; int stop = 0 ; for ( int i = 0 ; i <= columns ; i ++ ) { String x = input . nextLine ( ) ; char g = ' not ' ; char s = ' not ' ; int count = 0 ; for ( int j = 0 ; j <= rows ; j ++ ) { if ( x . charAt ( j ) == ' S ' ) { if ( g == ' found ' ) { counter = count + 1 ; ; if ( ! f . equals ( data . get ( f . substring ( counter ) ) ) ) { data . put ( f . substring ( counter ) , 1 ) ; } } else { stop = 1 ; } break ; } else if ( x . charAt ( j ) == ' G ' ) { g = ' found ' ; count = 0 ; } else { count ++ ; } } } System . out . println ( - 1 == data . size ( ) || stop == 1 ? data . size ( ) : stop ) ; return data ; }
public static boolean search ( int [ ] arr , int n , int x ) { int front = 0 ; int back = n - 1 ; while ( ( front <= back ) && ( arr [ front ] == x || arr [ back ] == x ) ) { return true ; } front ++ ; back -- ; return false ; }
public static void countFreq ( int [ ] arr , int n ) { int mp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) mp [ arr [ i ] ] = 0 ; mp [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( mp [ arr [ i ] ] != - 1 ) && ( mp [ arr [ i ] ] != 0 ) ) System . out . println ( arr [ i ] + " ▁ " + mp [ arr [ i ] ] ) ; mp [ arr [ i ] ] = - 1 ; } arr = new int [ n ] ; arr [ 10 ] = 20 ; arr [ 20 ] = 20 ; arr [ 10 ] = 10 ; arr [ 20 ] = 5 ; arr [ 5 ] = 20 ; n = arr . length ; countFreq ( arr , n ) ; }
public static int MinCostTree ( int [ ] arr , int n ) { int ans = 0 ; Stack < Integer > st = new Stack < Integer > ( 2 * 32 ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ( st . peek ( ) <= arr [ i ] ) && ( st . pop ( ) > arr [ i ] ) ) { int x = st . pop ( ) ; st . push ( x ) ; ans += x * Math . min ( st . pop ( ) , arr [ i ] ) ; } st . push ( arr [ i ] ) ; } for ( int i = 2 ; i < st . size ( ) ; i ++ ) { ans += st . pop ( ) * st . pop ( ) ; } return ans ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display " ) ) ; List < String > s = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ string ▁ to ▁ display " ) ) ; List < String > t = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ string ▁ to ▁ display " ) ) ; Map < Character , Integer > dicS = new HashMap < Character , Integer > ( ) ; Map < Character , Integer > dicT = new HashMap < Character , Integer > ( ) ; for ( int i = 97 ; i <= 97 + 26 ; i ++ ) { dicS . put ( ( char ) i , 0 ) ; dicT . put ( ( char ) i , 0 ) ; } for ( int i = 0 ; i < n ; i ++ ) { dicS . get ( s . get ( i ) ) ++ ; dicT . get ( t . get ( i ) ) ++ ; } if ( dicS . size ( ) != dicT . size ( ) ) System . out . println ( - 1 ) ; else { List < Integer > c = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( true ) { if ( s . get ( i ) . equals ( t . get ( i ) ) ) break ; int target = i + s . get ( i ) . indexOf ( t . get ( i ) ) ; c . add ( target - 1 ) ; s . set ( target - 1 , s . get ( target ) ) ; s . set ( target - 1 , s . get ( target ) ) ; } } c = new ArrayList < Integer > ( c ) ; System . out . println ( c . size ( ) ) ; for ( Integer el : c ) System . out . print ( el + " ▁ " ) ; } }
public static void findEquation ( int a , int b ) { int summ = ( a + b ) ; int product = ( a * b ) ; System . out . println ( " x ^ 2 ▁ - ▁ ( " + summ + " x ) ▁ + ▁ ( " + product + " ) ▁ = ▁ 0" ) ; }
public static void circleEquation ( double x1 , double y1 , double r ) { double a = - 2 * x1 ; ; double b = - 2 * y1 ; ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; ; System . out . print ( " x ^ 2 ▁ + ▁ ( " + a + " x ) ▁ + ▁ " ) ; ; System . out . print ( " y ^ 2 ▁ + ▁ ( " + b + " y ) ▁ = ▁ " ) ; System . out . print ( c + " . " ) ; ; }
public static void uniqueCombination ( int l , int sum , int K , List < Integer > local , List < Integer > A ) { if ( ( sum == K ) && ( local . size ( ) == K ) ) { System . out . print ( " { " ) ; for ( int i = 0 ; i < local . size ( ) ; i ++ ) { if ( ( i != 0 ) && ( local . get ( i ) == local . get ( i - 1 ) ) ) { System . out . print ( " ▁ " ) ; } System . out . print ( local . get ( i ) + " ▁ " ) ; if ( ( i != local . size ( ) - 1 ) && ( local . get ( i ) != local . get ( i - 1 ) ) ) { System . out . print ( " , ▁ " ) ; } } System . out . println ( " } " ) ; return ; } for ( int i = l ; i < A . size ( ) ; i += 1 ) { if ( ( sum + A . get ( i ) > K ) && ( local . get ( i ) == local . get ( i - 1 ) ) ) { continue ; } local . add ( A . get ( i ) ) ; uniqueCombination ( i + 1 , sum + A . get ( i ) , K , local , A ) ; local . remove ( local . size ( ) - 1 ) ; } }
public static final int [ ] getPrimes ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] prices = new int [ n ] ; Arrays . fill ( prices , Integer . MIN_VALUE ) ; for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { prices [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { System . out . println ( Arrays . binarySearch ( prices , Integer . MIN_VALUE , i ) ) ; } return prices ; }
z = " abcdefghijklmnopqrstuvwxyz " ; static final void f ( String x ) { for ( int i = 1 ; i <= 26 ; i += 2 ) { for ( int j = 0 ; j < 26 ; j ++ ) { String a = " " + z . charAt ( ( z . indexOf ( c ) * i + j ) % 26 ) ; if ( " that " . equals ( a ) || " this " . equals ( a ) ) return ; } } }
public static boolean findNature ( int a , int b , int n ) { if ( ( n == 0 ) && ( a & 1 ) != 0 ) return ( a & 1 ) ; ; if ( ( n == 1 ) && ( b & 1 ) != 0 ) return ( b & 1 ) ; if ( ( ( a & 1 ) == 0 ) && ( ( b & 1 ) == 0 ) ) { if ( ( ( b & 1 ) == 0 ) && ( ( n % 3 != 0 ) || ( ( n - 1 ) % 3 != 0 ) ) ) return false ; ; else return true ; } else { if ( ( ( b & 1 ) == 0 ) && ( ( n - 1 ) % 3 != 0 ) ) return true ; else return true ; } a = 2 ; b = 4 ; n = 3 ; if ( ( findNature ( a , b , n ) == true ) && ( ( n - 1 ) % 3 != 0 ) ) System . out . print ( " Odd " ) ; else System . out . print ( " Even " ) ; return ( n == 0 ) ; }
public static void main ( String [ ] args ) { while ( 1 ) { int d = Integer . parseInt ( System . in . readLine ( ) ) , e = Integer . parseInt ( System . in . readLine ( ) ) ; if ( d == 0 ) break ; ArrayList < Pair < Integer , Integer > > list = new ArrayList < Pair < Integer , Integer > > ( ) ; for ( int i = 0 ; i <= 101 ; i ++ ) { for ( int j = 0 ; j <= 101 ; j ++ ) { list . add ( new Pair < Integer , Integer > ( Math . abs ( ( ( i * i + j * j ) * 0.5 ) - e ) , i , j ) ) ; } } for ( Pair < Integer , Integer > p : Collections . list ( list ) ) { if ( p . second + p . second == d ) { System . out . println ( p . first ) ; break ; } } } }
public static int maxSum ( int [ ] a , int n ) { int [ ] dp = new int [ n ] ; ; if ( ( n == 1 ) && ( a [ 0 ] == 0 ) ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; ; } else if ( ( n == 2 ) && ( a [ 0 ] == 1 ) ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; ; dp [ 1 ] = Math . max ( a [ 1 ] , dp [ 0 ] ) ; ; } else if ( ( n >= 3 ) && ( a [ 0 ] == 2 ) ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; ; dp [ 1 ] = Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ; ; dp [ 2 ] = Math . max ( a [ 2 ] , Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ) ; ; int i = 3 ; ; while ( ( i < n ) && ( a [ i ] == 0 ) ) { dp [ i ] = Math . max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ; ; i ++ ; ; } } return dp [ n - 1 ] ; }
public static void main ( String [ ] args ) { String sentence = JOptionPane . showInputDialog ( " Enter ▁ the ▁ sentence " ) ; int start = - 1 , letter = String . valueOf ( - 1 ) ; while ( true ) { if ( ( sentence . charAt ( start ) != ' ▁ ' ) && ( sentence . charAt ( start ) != ' ? ' ) ) { letter = sentence . charAt ( start ) ; break ; } start -- ; } if ( letter . equalsIgnoreCase ( " a " ) || letter . equalsIgnoreCase ( " e " ) || letter . equalsIgnoreCase ( " i " ) || letter . equalsIgnoreCase ( " o " ) || letter . equalsIgnoreCase ( " u " ) || letter . equalsIgnoreCase ( " y " ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } }
public static int minimumX ( int n , int k ) { int mini = Integer . MAX_VALUE ; int i = 1 ; while ( i * i <= n ) { if ( ( n % i == 0 ) && ( i > 0 ) ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( ( res == n ) && ( i > 0 ) ) mini = Math . min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( ( res == n ) && ( i > 0 ) ) mini = Math . min ( num2 , mini ) ; } i ++ ; } return mini ; }
public static int findLongest ( int node ) { visited . set ( node ) ; if ( node != - 1 ) return 1 ; int maxChild = 0 ; for ( int i : graph ) { if ( visited . get ( i ) ) continue ; maxChild = Math . max ( maxChild , findLongest ( i ) ) ; } return maxChild + 1 ; } private static final int dfs ( int node ) { int [ ] vis = new int [ FF . length ] ; vis [ node ] = 1 ; int size = 1 ; int tmp = node ; while ( true ) { tmp = FF [ tmp ] ; if ( tmp == node ) return size ; if ( vis [ tmp ] == 1 ) return 0 ; vis [ tmp ] = 1 ; size ++ ; } }
public static double SellingPrice ( double CP , double PP ) { double Pdecimal = 1 + ( PP / 100 ) ; double res = Pdecimal * CP ; return res ; }
t ; for ( int c = 0 ; c < t ; c ++ ) { int n ; int [ ] seq = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) seq [ i ] = i ; int [ ] posis = new int [ n + 1 ] ; posis [ 0 ] = null ; for ( int u = 0 ; u <= n ; u ++ ) posis [ seq [ u ] ] = u ; System . out . print ( 1 + " ▁ " ) ; int l = posis [ 1 ] ; ; int r = posis [ 1 ] ; for ( int num = 2 ; num <= n ; num ++ ) { if ( ( posis [ num ] < l ) && ( posis [ num ] > r ) ) { l = posis [ num ] ; } if ( ( posis [ num ] > r ) && ( posis [ num ] < l ) && ( posis [ num ] > r ) ) { r = posis [ num ] ; } System . out . print ( 1 == num ? r - l + 1 : 0 + " ▁ " ) ; } System . out . println ( ) ; }
public static int f ( int b , int n ) throws Exception { if ( b > n ) return n ; return f ( b , n / b ) + ( n % b ) ; } public static int digit_sum ( int n , int s ) throws Exception { if ( n == s ) return n + 1 ; int sqrt = Math . sqrt ( n ) ; sqrt = Math . ceil ( sqrt ) ; for ( int b = 2 ; b <= sqrt ; b ++ ) { if ( f ( b , n ) == s ) return b ; } for ( int p = sqrt ; p > 0 ; p -- ) { if ( ( n - s ) % p ) continue ; b = ( n - s ) / p + 1 ; if ( b < 2 ) continue ; if ( f ( b , n ) == s ) return b ; } return - 1 ; } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " linux " ) ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ sum ▁ " + " to ▁ " + n + " ▁ and ▁ " + " s ▁ " + s ) ) ; int s = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ sum ▁ " + " to ▁ " + n + " ▁ and ▁ " + " s ▁ " + s ) ) ; int ans = digit_sum ( n , s ) ; System . out . println ( ans ) ; } return - 1 ; }
public static int m ( int b ) { int m = Integer . parseInt ( input ( ) . nextLine ( ) ) ; int maximum = 0 ; for ( int y = 0 ; y < b + 1 ; y ++ ) { int sum = ( m * ( b - y ) + y ) * ( m * ( b - y ) + 1 ) * ( y + 1 ) / 2 ; if ( maximum <= sum ) { maximum = sum ; } else { break ; } } ; System . out . println ( maximum ) ; return maximum ; }
public static void check ( int n , int m ) { if ( ( m % n == 0 ) && ( m % n == 0 ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
public static void main ( String [ ] args ) { for ( ; ; ) { int x = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ check " ) ) ; int [ ] a = Arrays . copyOf ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ string ▁ to ▁ check " ) , x ) ; int p = 0 ; for ( int i = 0 ; i < x - 2 ; i ++ ) { if ( a [ i ] == a [ i + 2 ] ) { p = 1 ; break ; } } System . out . println ( " YES " . equals ( p ) ? " NO " : " YES " ) ; } }
public static int a ( ) { int a = map . get ( ) , b = map . get ( ) ; if ( a < b ) { System . out . println ( b - a ) ; } else if ( a > b ) { System . out . println ( a - b ) ; } else { System . out . println ( 0 ) ; } return a ; }
n , m ) public static Map < Integer , Integer > map ( ) { String s = input . nextLine ( ) . substring ( 0 , n ) ; Map < Integer , Integer > ls = new HashMap < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) ls . put ( i , i ) ; return ls ; }
public static int findNthOccur ( String string , char ch , int N ) { int occur = 0 ; ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( ( string . charAt ( i ) == ch ) && ( occur == N ) ) { occur ++ ; } if ( ( occur == N ) && ( occur == 1 ) ) { return i ; } } return - 1 ; }
public static final int mostFrequent ( List < Integer > List ) { AtomicInteger occurenceCount = new AtomicInteger ( List ) ; return occurenceCount . get ( 1 ) . intValue ( ) ; List < Integer > list = Arrays . asList ( Integer . parseInt ( System . in ) , Integer . parseInt ( System . in ) ) ; int o = 0 ; int [ ] a1 = new int [ list . size ( ) ] ; int b = mostFrequent ( list ) ; for ( int num : list ) { if ( num == b ) { o = o + 1 ; } else { a1 [ o ++ ] = num ; } } if ( o == 6 ) { System . out . println ( " Elephant " ) ; } if ( o == 5 ) { System . out . println ( " Bear " ) ; } if ( o == 4 ) { if ( a1 [ 0 ] == a1 [ 1 ] ) { System . out . println ( " Elephant " ) ; } else { System . out . println ( " Bear " ) ; } } if ( 4 > o ) { System . out . println ( " Alien " ) ; } return o ; }
public static String compute ( ) { final int LIMIT = 10 * 15 ; final int MODULUS = 10 * 9 ; int splitcount = EulaLib . sqrt ( LIMIT ) ; int splitat = LIMIT / ( splitcount + 1 ) ; final int sumSquare = ( e * ( e + 1 ) * ( e * 2 + 1 ) - s * ( s + 1 ) * ( s * 2 + 1 ) ) / 6 ; int ans = sum ( ( i * i * ( LIMIT / i ) ) ) ; ans += sum ( ( sumSquare ( LIMIT / ( i + 1 ) , LIMIT / i ) * i ) ) ; return String . valueOf ( ans % MODULUS ) ; }
public static int main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ input ▁ characters . " ) ) ; int k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ be ▁ split . " ) ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ split . " ) ) ; } int ans = 0 ; int s = 0 ; int mx = 0 ; for ( int i = 0 ; i < k + 1 ; i ++ ) { if ( i < n - 1 ) mx = Math . max ( mx , a [ i ] + a [ i + 1 ] ) ; s += a [ i ] ; if ( i % 2 == k % 2 ) { int tmp = ( k - i ) / 2 ; if ( tmp <= z ) ans = Math . max ( ans , s + mx * tmp ) ; } } System . out . println ( ans ) ; } }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] arr = Arrays . copyOf ( input . nextLine ( ) . split ( " ▁ " ) , n ) ; int l = - 1 , r = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] != i + 1 ) { r = i ; break ; } } int s = r + 1 ; for ( int i = l ; i < s ; i ++ ) { if ( arr [ i ] == s ) { s -- ; continue ; } else { System . out . println ( 0 ) ; System . exit ( 0 ) ; } } System . out . println ( l + 1 + " ▁ " + r + " ▁ " + s ) ; return l + 1 ; }
public static int n ( String input ) { int n = Integer . parseInt ( input ) ; List < List < Integer > > lst = new ArrayList < List < Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) lst . add ( Arrays . asList ( Integer . parseInt ( input ) . split ( " ▁ " ) ) ) ; int [ ] aStart = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aStart [ i ] = x [ 0 ] * 60 + x [ 1 ] ; int [ ] aEnd = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aEnd [ i ] = x [ 2 ] * 60 + x [ 3 ] ; int [ ] hStart = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) hStart [ i ] = x [ 4 ] * 60 + x [ 5 ] ; int [ ] hEnd = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) hEnd [ i ] = x [ 6 ] * 60 + x [ 7 ] ; int [ ] bStart = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) bStart [ i ] = x [ 8 ] * 60 + x [ 9 ] ; int [ ] bEnd = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) bEnd [ i ] = x [ 10 ] * 60 + x [ 11 ] ; final List < Set < Integer > > aSets = makeSets ( aStart , aEnd ) ; final List < Set < Integer > > hSets = makeSets ( hStart , hEnd ) ; final List < Set < Integer > > bSets = makeSets ( bStart , bEnd ) ; int ans = 0 ; for ( Set < Integer > s1 : aSets ) { for ( Set < Integer > s2 : hSets ) { for ( Set < Integer > s3 : bSets ) { ans = Math . max ( ans , s1 . size ( ) & s2 . size ( ) & s3 . size ( ) ) ; } } } System . out . println ( ans ) ; return ans ; }
public static int [ ] getTwoInt ( ) { int [ ] twoInt = new int [ 2 ] ; Scanner scanner = new Scanner ( System . in ) ; for ( int i = 0 ; i < twoInt . length ; i ++ ) { twoInt [ i ] = Integer . parseInt ( scanner . nextLine ( ) ) ; } return twoInt ; } public static void distributeStone ( int candidateNum , int stoneNum ) { int bowLstone = stoneNum ; int [ ] candidateList = new int [ candidateNum ] ; int i = 0 ; while ( true ) { int order = i % candidateNum ; if ( bowLstone != 0 ) { candidateList [ order ] ++ ; bowLstone -- ; } else if ( bowLstone == 0 && candidateList [ order ] == stoneNum ) { return ; } else { bowLstone = candidateList [ order ] ; candidateList [ order ] = 0 ; } i ++ ; } } if ( System . getProperty ( " user . dir " ) . equals ( " / home / kpizen / Desktop / Desktop " ) ) { while ( true ) { int candidateNum = getTwoInt ( ) ; int stoneNum = getTwoInt ( ) ; if ( candidateNum == 0 ) break ; int order = distributeStone ( candidateNum , stoneNum ) ; System . out . println ( order ) ; } }
public static int countTwoIdx ( int [ ] A , int q ) { int ans = 0 ; int left = 0 ; int csum = 0 ; for ( int right = 0 ; right < N ; right ++ ) { csum += A [ right ] ; while ( csum > q ) { csum -= A [ left ] ; left ++ ; } ans += right - left + 1 ; } return ans ; }
public static int a ( ) { int a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) ; for ( int i = 0 ; i < a ; i ++ ) { int b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) ; int c = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ) ; int d = Math . abs ( b - c ) ; if ( d % 10 != 0 ) { System . out . println ( d / 10 + 1 ) ; } else { System . out . println ( d / 10 ) ; } } return a ; }
public static int maxSize = 100005 ; boolean [ ] isFib = new boolean [ maxSize ] ; int [ ] prefix = new int [ maxSize ] ; final int digitSum = 0 ; int s = 0 ; while ( ( num != 0 ) && ( num % 10 == 0 ) ) { s = s + num % 10 ; num = num / 10 ; } return s ; } void generateFibonacci ( ) { isFib = new boolean [ maxSize ] ; int prev = 0 ; int curr = 1 ; isFib [ prev ] = true ; isFib [ curr ] = true ; while ( ( curr < maxSize ) && ( prev < curr ) ) { int temp = curr + prev ; if ( temp < maxSize ) { isFib [ temp ] = true ; } prev = curr ; curr = temp ; } } void precompute ( int k ) { generateFibonacci ( ) ; prefix = new int [ maxSize ] ; for ( int i = 1 ; i < maxSize ; i ++ ) { int sum = digitSum ( i ) ; if ( ( isFib [ sum ] == true && sum % k == 0 ) || ( isFib [ sum ] == false && sum % k == 0 ) ) { prefix [ i ] ++ ; } } for ( int i = 1 ; i < maxSize ; i ++ ) { prefix [ i ] = prefix [ i ] + prefix [ i - 1 ] ; } } void performQueries ( int k , int q , int [ ] [ ] query ) { precompute ( k ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = query [ i ] [ 0 ] ; int r = query [ i ] [ 1 ] ; int cnt = prefix [ r ] - prefix [ l - 1 ] ; System . out . println ( cnt ) ; } } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " windows " ) ) { query [ 0 ] = new int [ ] { 1 , 11 } ; query [ 1 ] = new int [ ] { 5 , 15 } ; query [ 2 ] = new int [ ] { 2 , 24 } ; int k = 2 ; int q = query . length ; performQueries ( k , q , query ) ; } }
for ( ; ; ) { int x1 = map . get ( input . nextLine ( ) ) ; int y1 = map . get ( input . nextLine ( ) ) ; int x2 = map . get ( input . nextLine ( ) ) ; int y2 = map . get ( input . nextLine ( ) ) ; int x3 = map . get ( input . nextLine ( ) ) ; int y3 = map . get ( input . nextLine ( ) ) ; int alpha = 0 ; if ( y1 == y2 && y3 < y1 ) { alpha += Math . abs ( x1 - x2 ) ; } if ( y2 == y3 && y1 < y2 ) { alpha += Math . abs ( x2 - x3 ) ; } if ( y3 == y1 && y2 < y3 ) { alpha += Math . abs ( x3 - x1 ) ; } System . out . println ( alpha ) ; }
public static boolean isPalindrome ( String s ) { int l = s . length ( ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) { if ( ( s . charAt ( i ) != s . charAt ( l - 1 - i ) ) && ( s . charAt ( i ) != s . charAt ( l - 1 - i ) ) ) { return false ; } } return true ; } public static void createStringAndCheckPalindrome ( int N ) { String sub = " " + ( char ) N ; String resStr = " " ; int sum = 0 ; while ( ( N > 0 ) && ( ( N % 10 ) != 0 ) ) { int digit = N % 10 ; sum += digit ; N = N / 10 ; } while ( ( resStr . length ( ) < sum ) && ( ( resStr . length ( ) > sum ) || ( isPalindrome ( resStr ) ) ) ) { resStr += sub ; } if ( ( resStr . length ( ) > sum ) && ( ( resStr . length ( ) > sum ) || ( isPalindrome ( resStr ) ) ) ) { resStr = resStr . substring ( 0 , sum ) ; } if ( ( isPalindrome ( resStr ) ) && ( ( resStr . length ( ) > sum ) || ( isPalindrome ( resStr ) ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ soots ▁ to ▁ solve " ) ) ; String [ ] soots = { " S " , " H " , " C " , " D " } ; ArrayList < String > sootlist = new ArrayList < String > ( ) ; ArrayList < Integer > numlist = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String soot = JOptionPane . showInputDialog ( " Enter ▁ the ▁ soot ▁ to ▁ solve " ) ; int num = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ to ▁ solve " ) ; sootlist . add ( soot ) ; numlist . add ( Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ to ▁ solve " ) ) ) ; } ArrayList < String > ansootlist = new ArrayList < String > ( ) ; ArrayList < Integer > ansnumlist = new ArrayList < Integer > ( ) ; for ( String soot : soots ) { for ( Integer num = 1 ; num <= 14 ; num ++ ) { int flag = 0 ; for ( String s : sootlist ) { if ( soot . equals ( s ) && num . equals ( num ) ) { flag = 1 ; break ; } } if ( flag == 1 ) { continue ; } else { ansootlist . add ( soot ) ; ansnumlist . add ( num ) ; } } } for ( String soot : ansootlist ) { System . out . println ( soot + " ▁ " + num ) ; } }
public static int sumEvenAndEvenIndex ( int [ ] arr , int n ) { int i ; int sum = 0 ; for ( i = 0 ; i < n ; i += 2 ) { if ( ( arr [ i ] % 2 == 0 ) && ( arr [ i + 1 ] % 2 == 0 ) ) { sum += arr [ i ] ; } } return sum ; }
public static final void main ( String [ ] args ) { for ( ; ; ) { String ans = " YES " ; for ( Map . Entry < String , List < String > > e : new ArrayList < > ( ) ) { if ( Arrays . asList ( e . getValue ( ) ) . size ( ) == 1 ) { ans = " NO " ; break ; } } System . out . println ( ans ) ; } }
public static void printDuplicates ( int arr [ ] , int n ) { int fl = 0 ; ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ arr [ i ] % n ] >= n ) && ( arr [ arr [ i ] % n ] < 2 * n ) ) { System . out . print ( arr [ i ] % n + " ▁ " ) ; fl = 1 ; } ; } arr [ arr [ i ] % n ] += n ; ; }
public static void print ( int i ) { System . out . println ( sum ( 1 / ( i + 1 ) ) ) ; }
public static int Sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
public static int maxHandshake ( int n ) { return ( int ) ( ( n * ( n - 1 ) ) / 2 ) ; }
public static int grayCode ( int n ) { return n ^ ( n > > 1 ) ; }
public static int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; ; }
public static int possibleways ( int n ) { if ( ( n % 2 == 1 ) && ( n % 4 == 0 ) ) return 0 ; ; else if ( ( n % 3 == 0 ) && ( n % 4 == 1 ) ) return n / 4 - 1 ; else return n / 4 ; }
public static int CountSetBits ( int n ) { if ( ( n == 0 ) && ( ( n & 1 ) == 1 ) ) return 0 ; ; if ( ( ( n & 1 ) == 1 ) && ( ( n & 2 ) == 2 ) ) return 1 + CountSetBits ( n > > 1 ) ; ; else return CountSetBits ( n > > 1 ) ; }
static int summ ( int m , int n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; }
public static int SUM ( int n , int m ) { if ( ( m == 1 ) && ( n == 1 ) ) return ( n * ( n + 1 ) / 2 ) ; int sum = SUM ( n , m - 1 ) ; return ( int ) ( sum * ( sum + 1 ) / 2 ) ; }
public static int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; ; }
public static int findSum ( int n ) { return ( ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ) ; }
public static int cntWays ( int n ) { if ( n % 2 == 1 ) return 0 ; else return ( n - 2 ) / 4 ; }
public static void findCompositeNos ( int n ) { System . out . println ( 9 * n + 8 * n ) ; ; }
public static int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return n > 0 && 1 ? 6 : 0 ; }
public static int countMaxIntersect ( int n ) { return ( int ) ( n * ( n - 1 ) / 2 ) ; }
public static int sum ( int n ) { if ( ( n == 1 ) || ( n == 2 ) ) return 2 ; ; else return ( n * ( n + 1 ) + sum ( n - 1 ) ) ; }
public static int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
public static int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; }
public static String S ( ) { Scanner in = new Scanner ( System . in ) ; for ( int i = Character . MIN_VALUE ; i <= Character . MAX_VALUE ; i ++ ) { if ( Character . isLetter ( i ) ) { System . out . print ( Character . toString ( i ) ) ; System . exit ( 0 ) ; } } System . out . println ( " None " ) ; return null ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ be ▁ sorted " ) ) ; int [ ] array = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ be ▁ sorted " ) . toCharArray ( ) ; int a = 0 ; while ( a < n ) { array [ a ] = Integer . parseInt ( array [ a ] ) ; a ++ ; } int smallest = Math . min ( array ) ; Arrays . sort ( array ) ; int i = 1 ; boolean tOrF = true ; while ( i < n ) { if ( array [ i ] / smallest != Integer . parseInt ( array [ i ] / smallest ) ) { tOrF = false ; } i ++ ; } if ( tOrF == true ) { System . out . println ( smallest ) ; } else { System . out . println ( - 1 ) ; } return smallest ; }
print ( " ABC " . equals ( Integer . parseInt ( input . nextLine ( ) ) ) ) ? " ARC " : " " ) ; }
static final void skipSpaces ( ) { char c = ' ▁ ' ; while ( c == ' ▁ ' ) c = System . in . read ( ) ; skipNonSpaces ( ) ; c = ' _ ' ; while ( c != ' ▁ ' && ! c . equals ( ' ▁ ' ) ) c = System . in . read ( ) ; skipNonSpaces ( ) ; c = ' _ ' ; while ( c != ' ▁ ' && ! c . equals ( ' ▁ ' ) ) c = System . in . read ( ) ; skipNonSpaces ( ) ; c = ' _ ' ; while ( true ) { c = skipSpaces ( ) ; if ( c == ' ' ) break ; ++ c ; if ( skipNonSpaces ( ) == ' ' ) break ; } final List < String > dists = new ArrayList < String > ( ) ; boolean first = true ; int k = 0 ; for ( String z : readZeros ( ) ) { if ( z != null ) { if ( first ) { dists . add ( new String ( k , 0 , z . length ( ) , ' ▁ ' ) ) ; first = false ; } else { int h = k / 2 ; dists . add ( new String ( h + 1 , k , z . length ( ) , ' ▁ ' ) ) ; dists . add ( new String ( k - h - 1 , 0 , z . length ( ) , ' ▁ ' ) ) ; } k = 0 ; } ++ k ; } System . out . println ( " " + dists ) ; }
public static int smallest ( int x , int y , int z ) { int c = 0 ; while ( ( x > 0 && y > 0 ) || ( z > 0 && x > 0 ) ) { x = x - 1 ; y = y - 1 ; z = z - 1 ; c = c + 1 ; } return c ; }
public static int sum ( int a , int b , int c , int d , int e , int f ) { int sum = a + b * 5 + c * 10 + d * 50 + e * 100 + f * 500 ; return 1 == sum ? 0 : sum ; }
public static int main ( String [ ] args ) { int m = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ squares ▁ to ▁ solve " ) ) ; int r = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ square ▁ root ▁ to ▁ solve " ) ) ; int res = 0 , sq2 = ( 2 * .5 ) ; for ( int i = 1 ; i <= m ; i ++ ) res += 2 + sq2 + 2 * sq2 * ( i - 1 ) + ( i - 1 ) * i ; res = ( res + m ) * 2 * r ; System . out . println ( res / ( m * m ) ) ; }
public static final int countCubes ( double a , double b ) { return ( Math . floor ( b * ( 1. / 3. ) ) - Math . ceil ( a * ( 1. / 3. ) ) + 1 ) ; }
public static final void main ( String [ ] args ) { final int INF = 10 * 20 ; boolean visited = new boolean [ ] { false } ; visited [ ( int ) 0 ] = true ; int [ ] que = new int [ 101 ] ; heappush ( que , new int [ INF ] ) ; while ( que . length > 0 ) { int score = heappop ( que ) ; for ( int da = 0 , de = itemList [ e ] ; da < de ; da ++ , de ++ ) { int na = a + da ; if ( na >= d ) { System . out . println ( score + 1 ) ; return ; } int ne = e + de ; if ( ne > 100 ) ne = 100 ; if ( ( na < 0 ) || ( ne < 0 ) ) { visited [ ( int ) na ] = true ; heappush ( que , new int [ ] { score + 1 , na , ne } ) ; } } } System . out . println ( " NA " ) ; }
public static final EulaLib < Integer > TRIVIAL = new EulaLib < Integer > ( ) { @ Override public String compute ( ) { int triangle = 0 ; for ( int i = 1 ; i <= triangle ; i ++ ) { triangle += i ; if ( numDivisors ( triangle ) > 500 ) { return String . valueOf ( triangle ) ; } } final int n = Math . sqrt ( n ) ; final int end = EulaLib . sqrt ( n ) ; int result = sum ( 2 , n , end ) ; if ( end * end == n ) { result -- ; } return result ; } }
public static int findDelta ( int a , int b , int c , int d ) { return ( int ) ( ( b * c - a * d ) / ( d - c ) ) ; ; }
public static void SieveOfEratosthenes ( int n , boolean [ ] isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; int p = 2 ; while ( ( p * p <= n ) && ( isPrime [ p ] == true ) ) { if ( ( isPrime [ p ] == true ) || ( isPrime [ p ] == false ) ) { int i = p * p ; while ( ( i <= n ) && ( isPrime [ i ] == false ) ) { isPrime [ i ] = false ; i += p ; } } p ++ ; } }
public static int replaceDigit ( int x , int d1 , int d2 ) { int result = 0 ; ; int multiply = 1 ; while ( ( x % 10 > 0 ) && ( x % 10 == 0 ) ) { int remainder = x % 10 ; if ( ( remainder == d1 ) || ( remainder == d2 ) ) { result = ( result + d2 * multiply ) ; } else { result = ( result + remainder * multiply ) ; } multiply *= 10 ; x = ( int ) ( x / 10 ) ; } return result ; }
public static int printPattern ( int i , int j , int n ) { if ( ( j >= n ) && ( i >= n ) ) return 0 ; if ( ( i >= n ) && ( j == i ) ) return 1 ; if ( ( j == i || j == n - 1 - i ) && ( i == n - 1 - j ) ) { if ( ( i == n - 1 - j ) && ( j == i ) ) System . out . print ( " / " ) ; else System . out . print ( " \ \ " ) ; } else System . out . print ( " * " ) ; if ( ( printPattern ( i , j + 1 , n ) == 1 ) && ( j == i ) ) return 1 ; System . out . println ( ) ; return printPattern ( i + 1 , 0 , n ) ; }
public static int getPairsCount ( int arr [ ] , int n , int sum ) { int m [ ] = new int [ 1000 ] ; for ( int i = 0 ; i <= n ; i ++ ) { m [ arr [ i ] ] ++ ; m [ arr [ i ] ] ++ ; } int twiceCount = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { twiceCount += m [ sum - arr [ i ] ] ; if ( ( sum - arr [ i ] == arr [ i ] ) && ( sum - arr [ i ] == arr [ i ] ) ) { twiceCount -- ; } } return ( int ) ( twiceCount / 2 ) ; }
public static int Count_subarray ( int arr [ ] , int n ) { int subarraySum = 0 , remainingSum = 0 , count = 0 ; ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarraySum = 0 ; ; remainingSum = 0 ; ; for ( int k = i ; k <= j ; k ++ ) subarraySum += arr [ k ] ; ; for ( int l = 0 ; l < i ; l ++ ) remainingSum += arr [ l ] ; ; for ( int l = j + 1 ; l < n ; l ++ ) remainingSum += arr [ l ] ; ; if ( ( subarraySum > remainingSum ) && ( subarraySum < remainingSum ) ) count ++ ; ; } ; } return count ; }
public static void main ( String [ ] args ) { for ( int i = 0 ; i < Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ question ▁ to ▁ solve " ) ) ; i ++ ) { int n = JOptionPane . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ answer ▁ to ▁ solve " ) ) ; int x = JOptionPane . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ x ▁ to ▁ solve " ) ) ; int a = JOptionPane . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ a ▁ to ▁ solve " ) ) ; int b = JOptionPane . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ b ▁ to ▁ solve " ) ) ; int p = Math . abs ( a - b ) ; int q = p + x ; if ( q >= n - 1 ) { System . out . println ( n - 1 ) ; } else { System . out . println ( q ) ; } } }
public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . nextLine ( ) ) ; int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) s [ i ] = Integer . parseInt ( sc . nextLine ( ) ) ; Arrays . sort ( s ) ; int t = sum ( s ) ; if ( t % 10 != 0 ) { System . out . println ( t ) ; System . exit ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { t = sum ( s , 0 , i ) + sum ( s , i + 1 , n - i ) ; if ( t % 10 != 0 ) { System . out . println ( t ) ; System . exit ( ) ; } } System . out . println ( 0 ) ; }
public static final void main ( String [ ] args ) { final int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ cards ▁ to ▁ display " ) ) ; final int k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ cards ▁ to ▁ display " ) ) ; final int [ ] arr = Arrays . copyOf ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ cards ▁ to ▁ display " ) , n ) ; int res = Integer . MAX_VALUE ; for ( int color = 1 ; color <= 101 ; color ++ ) { int i = 0 ; int day = 0 ; while ( i < n ) { if ( i < n && arr [ i ] != color ) { i += k ; day ++ ; } else { i ++ ; } } res = Math . min ( res , day ) ; } System . out . println ( res ) ; }
public static final int findRepeatingNumber ( int arr [ ] , int n ) { double sq = Math . sqrt ( n ) ; int range__ = ( int ) ( ( n / sq ) + 1 ) ; int count [ ] = new int [ range__ ] ; for ( int i = 0 ; i < n ; i += 1 ) { count [ ( int ) ( ( arr [ i ] - 1 ) / sq ) ] ++ ; } int selected_block = range__ - 1 ; for ( int i = 0 ; i < range__ - 1 ; i += 1 ) { if ( ( count [ i ] > sq ) && ( count [ i ] < ( ( selected_block + 1 ) * sq ) ) ) { selected_block = i ; break ; } } int m [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { m [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) || ( ( ( selected_block + 1 ) < arr [ i ] ) && ( arr [ i ] >= ( ( selected_block + 1 ) * sq ) ) ) ) { m [ arr [ i ] ] ++ ; if ( ( m [ arr [ i ] ] > 1 ) && ( m [ arr [ i ] ] < ( ( selected_block + 1 ) * sq ) ) ) return arr [ i ] ; } } return - 1 ; }
public static int maxPrimeFactors ( int n ) { int maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n >>>= 1 ; } for ( int i = 3 ; i <= Integer . MAX_VALUE ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) { maxPrime = n ; } return ( int ) maxPrime ; }
public static int t ( ) { int t = Integer . parseInt ( input ( ) ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( input ( ) ) ; List < Integer > l = Arrays . asList ( Integer . parseInt ( input ( ) . split ( " ▁ " ) [ 0 ] ) ) ; int count = 0 ; for ( int i : l ) { count += i % 2 ; } System . out . println ( Math . min ( count , n - count ) ) ; } return n ; }
s ; int num_0 = 0 ; int num_1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '0' ) num_0 ++ ; else num_1 ++ ; } System . out . println ( Math . min ( num_0 , num_1 ) * 2 ) ; }
public static void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= Integer . MAX_VALUE ; i ++ ) { for ( int j = i + 1 ; j <= Integer . MAX_VALUE ; j ++ ) { int k = n - i - j ; if ( ( i * i + j * j == k * k ) && ( i * i + j * j == k * k ) ) { System . out . print ( i + " , ▁ " + j + " , ▁ " + k + " \n " ) ; return ; } } } System . out . println ( " No ▁ Triplet " ) ; n = 12 ; pythagoreanTriplet ( n ) ; }
static int countDigits ( int a , int b ) { if ( ( a == 0 || b == 0 ) && ( a == b ) ) return 1 ; return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }
public static int indexOfFirstOne ( int [ ] arr , int low , int high ) { while ( ( low <= high ) && ( arr [ low ] == 1 ) ) { int mid = ( low + high ) / 2 ; if ( ( arr [ mid ] == 1 ) && ( mid == 0 || arr [ mid - 1 ] == 0 ) ) break ; else if ( ( arr [ mid ] == 1 ) ) high = mid - 1 ; else low = mid + 1 ; } return mid ; }
public static int main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . nextLine ( ) ) ; if ( n % 3 == 0 ) { System . out . println ( n / 3 * 2 ) ; } else if ( n < 3 ) { System . out . println ( 1 ) ; } else { System . out . println ( n / 3 * 2 + 1 ) ; } return 0 ; }
public static void main ( String [ ] args ) { while ( true ) { double n = Double . parseDouble ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ number : ▁ " ) ) ; if ( n < 0 ) break ; if ( Integer . MAX_VALUE - n * 16 > 0 ) System . out . println ( " NA " ) ; ; continue ; else { String s = new BigInteger ( Integer . toString ( n * 16 ) ) . toString ( 16 ) . substring ( 2 ) ; System . out . println ( s . substring ( 0 , s . length ( ) - 4 ) + " . " + s . substring ( s . length ( ) - 4 ) ) ; } } }
public static int digSum ( int n ) { int sum = 0 ; ; int rem = 0 ; while ( ( n > 0 ) && ( sum < n ) ) { rem = n % 10 ; sum = sum + rem ; n = ( int ) ( n / 10 ) ; } return sum ; }
public static void main ( String [ ] args ) { int N = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ edit " ) ) ; int [ ] P = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { P [ i ] = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ edit " ) ) ; } editorial ( N , P ) ; }
public static int compareTo ( int a , int b ) { for ( ; ; ) { int a = Math . min ( a , b ) ; int b = Math . max ( b , a ) ; System . out . println ( a - b ) ; } }
public static void performQueries ( int [ ] A , int [ ] q ) { int n = A . length ; int prefXor [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { prefXor [ i ] = prefXor [ i - 1 ] ^ A [ i - 1 ] ; } for ( int i = 0 ; i < q . length ; i ++ ) { int L = q [ i ] ; int R = q [ i ] ; if ( ( L > R ) && ( prefXor [ R ] == prefXor [ L - 1 ] ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } int Arr [ ] = { 1 , 1 , 2 , 2 , 1 } ; q = new int [ ] { 1 , 5 } ; performQueries ( Arr , q ) ; ; }
public static void main ( String [ ] args ) { System . out . println ( " Enter ▁ a ▁ number ▁ to ▁ test " ) ; int i = 0 ; int n = 0 ; int [ ] l = new int [ n ] ; int f = 1 ; int c = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( l [ j ] > c ) { c ++ ; } } System . out . println ( c + 1 ) ; }
public static int RO ( ) { int RO = Collections . max ( Integer . parseInt ( input ( ) . split ( " ▁ " ) [ 1 ] ) ) - 1 ; int PO = Collections . max ( Integer . parseInt ( input ( ) . split ( " ▁ " ) [ 1 ] ) ) - 1 ; int PI = Collections . max ( Integer . parseInt ( input ( ) . split ( " ▁ " ) [ 1 ] ) ) - 1 ; int A = Collections . max ( Integer . parseInt ( input ( ) . split ( " ▁ " ) [ 1 ] ) ) , Integer . parseInt ( input ( ) . split ( " ▁ " ) [ 2 ] ) ) ; int B = Collections . max ( Integer . parseInt ( input ( ) . split ( " ▁ " ) [ 3 ] ) ) ; System . out . println ( Math . pow ( Math . pow ( RO , 2 ) / ( ( ( A * PI ) / ( B * PO ) ) + 1 ) , 0.5 ) ) ; return RO ; }
if static void main ( String [ ] args ) { int num = 3 ; int lterm = 1 ; int rterm = num * num + 1 ; for ( int i = num ; i >= 0 ; i -- ) { for ( int space = num ; space > i ; space -- ) System . out . print ( " ▁ " ) ; for ( int j = 1 ; j <= i ; j ++ ) { System . out . print ( String . format ( " % d * " , lterm ) ) ; lterm ++ ; } for ( int j = 1 ; j <= i ; j ++ ) { System . out . print ( rterm ) ; if ( j < i ) System . out . print ( " * " ) ; rterm ++ ; } rterm = rterm - ( i - 1 ) * 2 - 1 ; System . out . println ( ) ; } }
public static void findPerm ( int n , int [ ] differences ) { int [ ] ans = new int [ n ] ; ans [ 0 ] = 0 ; int x = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int diff = differences [ i ] ; x = x + diff ; ans [ i ] = x ; } int [ ] anss = ans ; Arrays . sort ( ans ) ; int flag = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { int res = ans [ i ] - ans [ i - 1 ] ; if ( ( res != 1 ) && ( res != 0 ) ) flag = 0 ; } if ( ( flag == 0 ) || ( flag == - 1 ) ) { System . out . println ( " - 1" ) ; return ; } else { Map < Integer , Integer > mpp = new HashMap < Integer , Integer > ( ) ; int j = 1 ; int [ ] valueAtIndex = new int [ ans . length ] ; for ( int i = 0 ; i < ans . length ; i ++ ) { mpp . put ( ans [ i ] , j ++ ) ; } for ( int i = 0 ; i < anss . length ; i ++ ) valueAtIndex [ i ] = mpp . get ( anss [ i ] ) ; for ( int i = 0 ; i < valueAtIndex . length ; i ++ ) System . out . print ( i + " ▁ " ) ; System . out . println ( ) ; } differences [ 0 ] = 2 ; differences [ 1 ] = - 3 ; differences [ 2 ] = 2 ; n = differences . length + 1 ; findPerm ( n , differences ) ; }
static int countPrimeFactors ( int n ) { int count = 0 ; ; while ( ( n % 2 == 0 ) && ( n % 3 == 0 ) ) { n = n / 2 ; count ++ ; } ; int i = 3 ; while ( ( i <= Math . sqrt ( n ) ) && ( n % i == 0 ) ) { n = n / i ; count ++ ; } ; i = i + 2 ; if ( ( n > 2 ) && ( n % 3 == 0 ) ) { count ++ ; } ; return ( count ) ; }
public static int solve ( int N , int K ) { int [ ] combo = new int [ N + 1 ] ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) combo [ j ] += combo [ j - i ] ; } } return combo [ N ] ; }
public static int main ( String [ ] args ) { while ( true ) { String X = JOptionPane . showInputDialog ( " Enter ▁ a ▁ number : ▁ " ) ; if ( X . equals ( "0" ) ) break ; String r = " " ; boolean minus = false ; if ( X . charAt ( 0 ) == ' - ' ) { minus = true ; X = X . substring ( 1 ) ; } int kuri = 0 ; int idx = X . length ( ) - 1 ; while ( idx >= 0 ) { int a = Integer . parseInt ( X . substring ( idx ) ) ; if ( minus ) { r = String . valueOf ( ( 10 - a - kuri ) % 10 ) + r ; kuri = 0 == kuri ? 1 : 0 ; } else { r = String . valueOf ( ( kuri + a ) % 10 ) + r ; kuri = ( kuri + a ) / 10 ; } minus = ! minus ; if ( idx == 0 && kuri > 0 ) X = "0" + X ; else idx -- ; } r = String . valueOf ( kuri ) + r ; System . out . println ( Integer . parseInt ( r ) ) ; } }
static final double normal ( double m , double n ) { double N = ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; ; return N ; }
n , h ) { ans = new int [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) ans [ i ] = h * ( ( i / n ) * 0.5 ) ; System . out . println ( * ans ) ; }
public static int countBits ( int n ) { int count = 0 ; while ( ( n > 0 ) && ( n & 1 ) != 0 ) { count ++ ; n >>>= 1 ; } return count ; }
public static int h ( int a , int b ) { int h = map . get ( a ) ; int w = map . get ( b ) ; return h * w - ( a * b * ( ( h / a ) * ( w / b ) ) ) ; }
public static int [ ] bisectLeft ( int n ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] tlst = new int [ n ] ; Arrays . fill ( tlst , n ) ; int max_t = tlst [ tlst . length - 1 ] ; int [ ] divisors = new int [ max_t + 1 ] ; for ( int i = 1 ; i <= max_t ; i ++ ) { divisors [ i ] = i ; } int ans = 0 ; for ( int t : tlst ) { int ind = bl ( divisors , t ) ; ans += divisors [ ind ] - t ; } System . out . println ( ans ) ; }
public static int LongestSubarray ( int [ ] arr , int n , int k ) { int [ ] arr2 = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr2 [ i ] = arr [ i ] % k ; int maxLength = 0 ; int i = 0 ; while ( i < n ) { int currentLength = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr2 [ j ] == arr2 [ i ] ) && ( arr2 [ j ] == arr [ j ] ) ) currentLength ++ ; else break ; } maxLength = Math . max ( maxLength , currentLength ) ; i = j ; i ++ ; } return maxLength ; }
n , m = map . get ( n ) ; System . out . println ( m - 1 == n - m + 1 && m != 1 ? m + 1 : 1 ) ; }
public static boolean isHeterogram ( String s , int n ) { int [ ] hash = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != ' ▁ ' ) { if ( hash [ Character . digit ( s . charAt ( i ) , 16 ) - Character . digit ( s . charAt ( i ) , 16 ) ] == 0 ) { hash [ Character . digit ( s . charAt ( i ) , 16 ) - Character . digit ( s . charAt ( i ) , 16 ) ] = 1 ; } else { return false ; } } } return true ; }
public static String compute ( ) { List < Integer > arr = Arrays . asList ( 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 200 , 300 , 400 , 500 , 600 , 700 , 800 , 900 , 1000 , 10000 , 100000 , 1000000 , 10000000 , 1000000000000 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 , 10000000000001 ,
public static boolean FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( ( x > x1 && x < x2 && y > y1 && y < y2 ) || ( x > x1 && x < x2 && y > y1 && y < y2 ) ) { return true ; } else { return false ; } }
public static final int countPoints ( int n , Point [ ] points ) throws Exception { final int MX = 2001 ; final int OFF = 1000 ; class point { public int x ( ) { return 0 ; } public int y ( ) { return 0 ; } } int countPoints ( int n , point [ ] points ) throws Exception { int [ ] minx = new int [ MX ] ; int [ ] miny = new int [ MX ] ; int [ ] maxx = new int [ MX ] ; int [ ] maxy = new int [ MX ] ; int x , y ; for ( int i = 0 ; i < n ; i ++ ) { points [ i ] . x += OFF ; points [ i ] . y += OFF ; x = points [ i ] . x ; y = points [ i ] . y ; minx [ y ] = Math . min ( minx [ y ] , x ) ; maxx [ y ] = Math . max ( maxx [ y ] , x ) ; miny [ x ] = Math . min ( miny [ x ] , y ) ; maxy [ x ] = Math . max ( maxy [ x ] , y ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = points [ i ] . x ; y = points [ i ] . y ; if ( ( x > minx [ y ] && x < maxx [ y ] ) || ( y > miny [ x ] && y < maxy [ x ] ) ) { count ++ ; } } return count ; } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " windows " ) ) { point [ ] points = new point [ n ] ; points [ 0 ] = point . x ; points [ 1 ] = point . y ; points [ 2 ] = point . x ; points [ 3 ] = point . y ; points [ 4 ] = point . x ; points [ 5 ] = point . y ; points [ 6 ] = point . x ; points [ 7 ] = point . y ; points [ 8 ] = point . x ; points [ 9 ] = point . y ; points [ 10 ] = point . x ; points [ 11 ] = point . y ; points [ 12 ] = point . x ; points [ 13 ] = point . y ; points [ 14 ] = point . x ; points [ 15 ] = point . y ; return count ; } return 0 ; }
public static int X_low ( ) { int value = X_low ; int cnt = 0 ; while ( ( value <= Y_up ) && ( value > 0 ) ) { cnt ++ ; value *= 2 ; } System . out . println ( cnt ) ; return cnt ; }
public static int countSticks ( String string , int n ) { int [ ] sticks = { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ; ; int cnt = 0 ; ; for ( int i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ ( int ) string . charAt ( i ) - ( int ) '0' ] ) ; } ; return cnt ; }
public static int T ( Scanner scanner ) { int T = Integer . parseInt ( scanner . nextLine ( ) ) ; for ( int t = 0 ; t <= T ; t ++ ) { int n = Integer . parseInt ( scanner . nextLine ( ) ) ; int [ ] a = Arrays . copyOf ( scanner . nextLine ( ) . split ( " ▁ " ) , n ) ; int ctr = 0 ; int maxi = Math . max ( a ) ; for ( int i = 2 ; i <= n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] && a [ i - 1 ] > a [ i - 2 ] ) { ctr ++ ; if ( i != n - 1 ) { a [ i ] = Math . max ( a [ i - 1 ] , a [ i + 1 ] ) ; } else { a [ i ] = a [ i - 1 ] ; } } } System . out . println ( ctr ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; } System . out . println ( ) ; } return T ; }
public static void command ( Brr brr , int a , int b ) { arr [ a ] ^= 1 ; arr [ b + 1 ] ^= 1 ; }
public static int mostFrequent ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int maxCount = 1 ; int res = arr [ 0 ] ; int currCount = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] == arr [ i - 1 ] ) && ( currCount > maxCount ) ) { currCount ++ ; } else { if ( ( currCount > maxCount ) && ( currCount < maxCount ) ) { maxCount = currCount ; res = arr [ i - 1 ] ; } currCount = 1 ; } } if ( ( currCount > maxCount ) && ( currCount < maxCount ) ) { maxCount = currCount ; res = arr [ n - 1 ] ; } return res ; }
public static int MAX = 26 ; ; int maxLength ( String str , int len ) { int res = 0 ; ; int [ ] lastPos = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) lastPos [ i ] = - 1 ; ; for ( int i = 0 ; i < len ; i ++ ) { int C = Character . digit ( str . charAt ( i ) , 10 ) - Character . digit ( str . charAt ( i + 1 ) , 10 ) ; ; if ( ( lastPos [ C ] != - 1 ) && ( lastPos [ C ] != - 1 ) ) res = Math . max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) ; ; lastPos [ C ] = i ; } ; return res ; }
public static int ksmallest ( int [ ] arr , int n , int k ) { int [ ] b = new int [ MAX ] ; ; for ( int i = 0 ; i < n ; i ++ ) b [ arr [ i ] ] = 1 ; ; for ( int j = 1 ; j < MAX ; j ++ ) { if ( ( b [ j ] != 1 ) && ( k != 1 ) ) k -- ; if ( ( k != 1 ) && ( j != 0 ) ) return j ; } k = 1 ; ; arr = new int [ 1 ] ; ; n = arr . length ; ; System . out . println ( ksmallest ( arr , n , k ) ) ; ; }
public static boolean isDivisible ( int n ) { while ( n / 100 > 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
public static boolean isDivisible ( int n ) { while ( n / 100 > 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
public static boolean isDivisible ( int n ) { while ( n / 100 > 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
public static boolean isDivisible ( int n ) { while ( n / 100 > 0 ) { int d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
public static int Odd_Sum ( int n ) { int total = ( n + 1 ) / 2 ; int odd = total * total ; return odd ; final int Even_Sum = n / 2 ; int even = total * ( total + 1 ) ; return even ; }
public static boolean isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( ( lowCost <= ans && ans <= upCost ) || ( lowCost > ans && ans > upCost ) ) { return true ; } } return false ; lowCost = 14 ; upCost = 30 ; lowQuant = 5 ; upQuant = 12 ; r = 9 ; if ( ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) && ( isRatioPossible ( lowCost , upCost , upQuant , r ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } return false ; }
static final public boolean Log2 ( int x ) { if ( x == 0 ) return false ; ; return ( Math . log10 ( x ) / Math . log10 ( 2 ) ) ; }
public static final String compute ( ) { final int LIMIT = 50000000 ; List < Integer > primes = EulerLib . listPrimes ( EulerLib . sqrt ( LIMIT ) ) ; Map < Integer , Set < Integer > > sums = new HashMap < Integer , Set < Integer > > ( ) ; for ( int i = 2 ; i <= 5 ; i ++ ) { Set < Integer > newsums = new HashSet < Integer > ( ) ; for ( Integer p : primes ) { int q = p * i ; if ( q > LIMIT ) break ; for ( Integer x : sums . get ( x ) ) { if ( x + q <= LIMIT ) newsums . add ( x + q ) ; } } sums = newsums ; } return String . valueOf ( sums . size ( ) ) ; }
public static final int longLenSub ( int arr [ ] , int n ) { Map < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len1 = 0 ; if ( ( arr [ i - 1 ] < um . get ( arr [ i ] ) ) && len1 < um . get ( arr [ i ] - 1 ) ) len1 = um . get ( arr [ i ] - 1 ) ; if ( ( arr [ i ] + 1 < um . get ( arr [ i ] ) ) && len1 < um . get ( arr [ i ] + 1 ) ) len1 = um . get ( arr [ i ] + 1 ) ; um . put ( arr [ i ] , len1 + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } arr = new int [ n ] ; arr [ 0 ] = 1 ; arr [ 1 ] = 2 ; arr [ 2 ] = 3 ; arr [ 3 ] = 4 ; arr [ 4 ] = 5 ; arr [ 5 ] = 3 ; arr [ 6 ] = 2 ; n = arr . length ; System . out . println ( " Longest ▁ length ▁ subsequence ▁ = " + longLenSub ( arr , n ) ) ; return longLen ; }
public static int main ( String [ ] args ) { for ( ; ; ) { int a = Integer . parseInt ( System . in . readLine ( ) ) , b = Integer . parseInt ( System . in . readLine ( ) ) ; System . out . println ( a + b ) ; } }
public static int calculateSum ( int n ) { int sum = 0 ; sum = 1 << n ; ; return ( sum - 1 ) ; }
public static int calculateSum ( int n ) { int sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
public static int maxDiff ( int [ ] arr , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int currSum = diff ; int maxSum = currSum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( ( currSum > 0 ) && ( currSum < maxSum ) ) { currSum += diff ; } else { currSum = diff ; } if ( ( currSum > maxSum ) && ( currSum < maxSum ) ) { maxSum = currSum ; } } return maxSum ; }
public static long f3 ( int n ) { long a = b = c = 0 ; for ( ; n > 0 ; n -- ) { a = ( a + b + c + 1 ) % 100000007 ; b = a ; c = b ; } return a ; }
public static int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int Max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( ( val == Max ) && ( ( val % num ) == 0 ) ) { count ++ ; } } } return count ; }
n = input . nextLine ( ) . trim ( ) ; int l = n . length ( ) ; int [ ] x = new int [ l ] ; for ( int i = 0 ; i < l - 1 ; i ++ ) { if ( i == 0 ) x [ i ] = 0 ; else x [ i ] = x [ i - 1 ] ; if ( n [ i ] == n [ i + 1 ] ) x [ i ] ++ ; ; } for ( int m = 0 ; m < Integer . MAX_VALUE ; m ++ ) { int y = map . get ( m ) ; int z = map . get ( m ) ; if ( y == 1 ) System . out . println ( x [ z - 2 ] ) ; else System . out . println ( x [ z - 2 ] - x [ y - 2 ] ) ; } }
public static void solve ( ) { final Scanner fI = new Scanner ( System . in ) ; final int n = fI . nextInt ( ) ; if ( n == 0 ) return ; final char tray = cups [ n - 1 ] ; if ( tray == ' A ' ) { return rec ( n - 1 ) ; } else if ( tray == ' B ' ) { return 2 * 3 * ( n - 1 ) - 1 - rec ( n - 1 ) ; } else { return rec ( n - 1 ) + 2 * 3 * ( n - 1 ) ; } }
public static void prints ( int [ ] g1 , int a , int [ ] g2 , int b ) { for ( int i = 0 ; i < a ; i ++ ) { System . out . print ( g1 [ i ] + " ▁ " ) ; } System . out . print ( " and ▁ " ) ; for ( int i = 0 ; i < b ; i ++ ) { System . out . print ( g2 [ i ] + " ▁ " ) ; } System . out . print ( " \n " ) ; } public static void checksum ( int [ ] g1 , int a , int [ ] g2 , int b ) { int x = 0 ; for ( int i = 0 ; i < a ; i += 1 ) { x += g1 [ i ] ; } for ( int i = 0 ; i < b ; i ++ ) { x -= g2 [ i ] ; } } public static void formgroups ( int [ ] arr , int x , int [ ] g1 , int a , int [ ] g2 , int b , int n ) { if ( ( x == n ) && ( ( x < a ) || ( x > b ) ) ) { if ( ( checksum ( g1 , a , g2 , b ) ) != 0 ) { prints ( g1 , a , g2 , b ) ; } return ; } g1 [ a ] = arr [ x ] ; formgroups ( arr , x + 1 , g1 , a + 1 , g2 , b , n ) ; g2 [ b ] = arr [ x ] ; formgroups ( arr , x + 1 , g1 , a , g2 , b + 1 , n ) ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { int [ ] arr = { 1 , 2 , 3 , 9 , 4 , 5 } ; int n = arr . length ; g1 = new int [ MAX ] ; g2 = new int [ MAX ] ; formgroups ( arr , 0 , g1 , 0 , g2 , 0 , n ) ; } } public static void main ( String [ ] args ) { if ( args . length == 0 ) { System . out . println ( " Usage : ▁ java ▁ " + Main . class . getName ( ) + " ▁ < input ▁ array > " ) ; } } }
public static void cutRibbon ( ) { int [ ] arr = new int [ 4 ] ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { arr [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } int length = arr [ 0 ] ; arr = Arrays . copyOf ( arr , 4 ) ; if ( ( length % arr [ 0 ] == 0 ) && ( length % arr [ 1 ] == 0 ) ) { System . out . println ( Integer . toString ( length / arr [ 0 ] ) ) ; return ; } int ans = 0 ; if ( ( arr [ 0 ] == arr [ 1 ] ) && ( length / arr [ 2 ] == 0 ) ) { int k = 0 ; for ( int i = 0 ; i < Integer . parseInt ( length / arr [ 2 ] ) + 1 ; i ++ ) { int check = length - i * arr [ 2 ] ; if ( ( check >= 0 && check % arr [ 0 ] == 0 ) && ( check % arr [ 0 ] == 0 ) ) { k = Integer . parseInt ( check / arr [ 0 ] ) ; ans = Math . max ( ans , k + i ) ; } } } else { int k = 0 ; for ( int i = 0 ; i < Integer . parseInt ( length / arr [ 2 ] ) + 1 ; i ++ ) { for ( int j = 0 ; j < Integer . parseInt ( length / arr [ 1 ] ) + 1 ; j ++ ) { int check = length - i * arr [ 2 ] - j * arr [ 1 ] ; if ( ( check >= 0 && check % arr [ 0 ] == 0 ) && ( check % arr [ 0 ] == 0 ) ) { k = Integer . parseInt ( check / arr [ 0 ] ) ; ans = Math . max ( ans , k + i + j ) ; } } } } System . out . println ( ans ) ; return ; }
public static int maxSubseq ( int [ ] vec , int n ) { int suffix = 0 ; int i = n - 1 ; while ( ( i >= 0 ) && ( vec [ i ] == 1 ) ) { if ( ( vec [ i ] == 0 ) || ( vec [ i ] == 1 ) ) { suffix ++ ; vec [ i ] = suffix ; } i -- ; } int res = 0 ; int zero = 0 ; for ( i = 0 ; i < n ; i += 1 ) { if ( ( vec [ i ] == 0 ) || ( vec [ i ] == 1 ) ) { zero ++ ; } if ( ( vec [ i ] > 0 ) || ( vec [ i ] == 1 ) ) { res = Math . max ( res , zero + vec [ i ] ) ; } } return Math . max ( res , zero ) ; } if ( Main . isWindows ) { int [ ] input = { 0 , 1 , 0 , 0 , 1 , 0 } ; int n = input . length ; System . out . println ( maxSubseq ( input , n ) ) ; } else { int [ ] input = { 0 , 1 , 0 , 0 , 1 , 0 } ; int n = input . length ; System . out . println ( maxSubseq ( input , n ) ) ; } return Math . max ( res , zero ) ; }
public static int countPaths ( int [ ] [ ] maze ) { if ( ( maze [ 0 ] [ 0 ] == - 1 ) && ( maze [ 0 ] [ 1 ] == - 1 ) ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( ( maze [ i ] [ 0 ] == 0 ) && ( maze [ i ] [ 1 ] == 0 ) ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i += 1 ) { if ( ( maze [ 0 ] [ i ] == 0 ) && ( maze [ 0 ] [ 1 ] == 0 ) ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i += 1 ) { for ( int j = 1 ; j < C ; j += 1 ) { if ( ( maze [ i ] [ j ] == - 1 ) && ( maze [ i ] [ j ] > 0 ) ) continue ; if ( ( maze [ i - 1 ] [ j ] > 0 ) && ( maze [ i ] [ j - 1 ] > 0 ) ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( ( maze [ i ] [ j - 1 ] > 0 ) && ( maze [ i ] [ j - 1 ] > 0 ) ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } if ( ( maze [ R - 1 ] [ C - 1 ] > 0 ) && ( maze [ R - 1 ] [ C - 1 ] > 0 ) ) return maze [ R - 1 ] [ C - 1 ] ; else return 0 ; }
public static void main ( String [ ] args ) { boolean isPrime = true ; ; int arr [ ] = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( ( N < 2 ) || ( N > 3 ) ) isPrime = false ; if ( ( N % 2 == 0 || N % 3 == 0 || N % 5 == 0 ) ) isPrime = false ; for ( int i = 0 ; i < Integer . MAX_VALUE ; i += 30 ) { for ( int c = arr [ i ] ; c < Integer . MAX_VALUE ; c ++ ) { if ( ( c > Integer . MAX_VALUE ) && ( N % ( c + i ) == 0 ) ) break ; else { if ( ( N % ( c + i ) == 0 ) && ( N % ( c + i ) == 0 ) ) { isPrime = false ; break ; } } if ( ( ! isPrime ) || ( N % ( c + i ) == 0 ) ) break ; } } if ( ( isPrime ) || ( N % ( 3 + i ) == 0 ) ) System . out . println ( " Prime ▁ Number " ) ; else System . out . println ( " Not ▁ a ▁ Prime ▁ Number " ) ; }
public static int compare ( int x1 , int y1 , int x2 , int y2 ) { int a = x2 - x1 ; int b = y2 - y1 ; return x2 - b + a ; }
public static int max ( int x , int y ) { if ( ( x > y ) && ( x < y ) ) return x ; return y ; } static final int lps ( int [ ] array , int i , int j ) { if ( ( i == j ) || ( i == 0 ) ) return 1 ; if ( ( array [ i ] == array [ j ] && i + 1 == j ) || ( array [ i ] == array [ j ] ) ) return 2 ; if ( ( array [ i ] == array [ j ] ) && ( i == j ) ) return lps ( array , i + 1 , j - 1 ) + 2 ; return Math . max ( lps ( array , i , j - 1 ) , lps ( array , i + 1 , j ) ) ; }
public static int findLength ( String st , int n ) { int [ ] total = new int [ n + 1 ] ; total [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) total [ i ] = ( total [ i - 1 ] + Integer . parseInt ( st . charAt ( i - 1 ) ) - Integer . parseInt ( "0" ) ) ; int ans = 0 ; int l = 2 ; while ( ( l <= n ) && ( total [ l ] == total [ i ] - total [ i + 1 ] ) ) { for ( int i = 0 ; i < n - l + 1 ; i ++ ) { int j = i + l - 1 ; if ( ( total [ i + Integer . parseInt ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + Integer . parseInt ( l / 2 ) ] ) ) ans = Math . max ( ans , l ) ; } l = l + 2 ; } return ans ; }
public static void prints ( char [ ] a , int n , int ind ) { int i = ind ; while ( i < n + ind ) { System . out . print ( a [ ( i % n ) ] + " ▁ " ) ; i = i + 1 ; } a [ 0 ] = ' A ' ; a [ 1 ] = ' B ' ; a [ 2 ] = ' C ' ; a [ 3 ] = ' D ' ; a [ 4 ] = ' E ' ; a [ 5 ] = ' F ' ; n = a . length ; ; prints ( a , n , 3 ) ; }
public static void prints ( String a [ ] , int n , int ind ) { char b [ ] = new char [ 2 * n ] ; int i = 0 ; while ( i < n ) { b [ i ] = b [ n + i ] = a [ i ] ; i = i + 1 ; } i = ind ; while ( i < n + ind ) { System . out . print ( b [ i ] + " ▁ " ) ; ; i = i + 1 ; } a = new String ( b ) ; n = a . length ; ; prints ( a , n , 3 ) ; ; }
public static int solve ( ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int a = input . nextInt ( ) ; int b = input . nextInt ( ) ; int e = 0 ; int o = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int l = input . nextInt ( ) ; e += l / 2 ; o += l % 2 ; } System . out . println ( Math . min ( o + e + Math . min ( e , a ) , b + a ) ) ; return b ; }
static void main ( String [ ] args ) { System . setSecurityManager ( new SecurityManager ( ) ) ; int n = Integer . parseInt ( System . getProperty ( " test . src " ) ) ; a = new int [ n ] ; b = new int [ n ] ; for ( ; ; ) { } }
public static int sum ( int v1 , int v2 ) { int t = Integer . MAX_VALUE , d = Integer . MIN_VALUE ; int sum = 0 ; for ( int i = 0 ; i < t ; i ++ ) { sum += Math . min ( v1 + d * i , v2 + d * ( t - i - 1 ) ) ; } System . out . println ( sum ) ; return sum ; }
public static int n ( ) { int n = Integer . parseInt ( input ( ) ) ; int [ ] Sherlock = Arrays . stream ( input ( ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] Moriarty = new int [ n ] ; Arrays . stream ( input ( ) ) . mapToInt ( digit -> digit ) . toArray ( ) ; int [ ] copySherlock = new int [ n ] ; Arrays . stream ( input ( ) ) . mapToInt ( digit -> digit ) . toArray ( ) ; int copyMoriarty = new int [ n ] ; Arrays . stream ( input ( ) ) . mapToInt ( digit -> digit ) . toArray ( ) ; int minHits = 0 ; int maxHits = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Moriarty [ j ] == - 1 ) continue ; if ( Moriarty [ j ] >= Sherlock [ i ] ) { Moriarty [ j ] = - 1 ; Sherlock [ i ] = - 1 ; break ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( Moriarty [ i ] != - 1 ) minHits ++ ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( copyMoriarty [ j ] == - 1 ) continue ; if ( copyMoriarty [ j ] > copySherlock [ i ] ) { maxHits ++ ; copyMoriarty [ j ] = - 1 ; break ; } } } System . out . println ( minHits ) ; System . out . println ( maxHits ) ; return minHits ; }
static public int [ ] test ( ) { int [ ] a = new int [ Integer . MAX_VALUE ] ; for ( int i = 0 ; i < a . length ; i ++ ) a [ i ] = Integer . MAX_VALUE ; int cnt2 = new int [ ] { ( int ) ( ( Integer ) ( Math . max ( a ) - i ) / 2 ) } ; int cnt1 = Math . max ( a ) - a . length - 2 * cnt2 ; System . out . println ( sum ( cnt2 ) + new int [ ] { 0 , 2 , 1 } [ sum ( cnt1 ) ] ) ; return a ; }
public static int t ( ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ test " ) ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ repeat ▁ the ▁ test " ) ) ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < j + 1 ; k ++ ) { if ( k == 0 || k == j ) { System . out . print ( 1 + " ▁ " ) ; } else { System . out . print ( 0 + " ▁ " ) ; } } System . out . println ( ) ; } } return t ; }
public static void bin ( int n ) { if ( ( n > 1 ) && ( n & 1 ) != 0 ) bin ( n > > 1 ) ; System . out . print ( n & 1 + " ▁ " ) ; }
public static String compute ( ) { int ans = sum ( x -> ( x % 3 == 0 || x % 5 == 0 ) ) ; return String . valueOf ( ans ) ; }
public static void main ( String [ ] args ) { Scanner S = new Scanner ( System . in ) ; int A = S . count ( ) ; System . out . println ( "1 ▁ " + A ( ' n ' ) + "0 ▁ " + A ( ' z ' ) ) ; }
public static int a ( ) { int a = Integer . parseInt ( input ( ) ) ; int b = Integer . parseInt ( input ( ) ) ; System . out . println ( b * 2 - a ) ; }
public static int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
public static int productDiagonals ( int [ ] [ ] arr , int n ) { int product = 1 ; ; for ( int i = 0 ; i < n ; i ++ ) { product = product * arr [ i ] [ i ] ; ; product = product * arr [ i ] [ n - i - 1 ] ; ; } if ( ( n % 2 == 1 ) ) { product = product / arr [ n / 2 ] [ n / 2 ] ; ; } return product ; }
public static int countCons ( ) { while ( true ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times " ) ) ; if ( n == 0 ) break ; int dic = new int [ n ] ; dic [ 0 ] = 0 ; dic [ 1 ] = 0 ; dic [ 2 ] = 0 ; dic [ 3 ] = 0 ; dic [ 4 ] = 0 ; dic [ 5 ] = 0 ; dic [ 6 ] = 0 ; dic [ 7 ] = 0 ; for ( ; n > 0 ; n -- ) { int c = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the ▁ number ▁ of ▁ times ▁ to ▁ count ▁ the
public static char getSecondMostFreq ( String str ) { final int NO_OF_CHARS = 256 ; int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ Character . codePointAt ( str , i ) ] ++ ; } int first = 0 , second = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) || ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) ) { second = i ; } } return ( char ) second ; } if ( Main . isWindows ) { String str = " geeksforgeeks " ; char res = getSecondMostFreq ( str ) ; if ( res != ' \ 0' ) { System . out . println ( " Second ▁ most ▁ frequent ▁ char ▁ is " + res ) ; } else { System . out . println ( " No ▁ second ▁ most ▁ frequent ▁ character " ) ; } } return ( char ) 0 ; }
public static int [ ] a ( ) { int [ ] a = new int [ 4001 ] ; for ( int i = 0 ; i < 2001 ; i ++ ) { a [ i ] = a [ 4000 - i ] = ( i + 3 ) * ( i + 2 ) * ( i + 1 ) / 6 - 4 * a [ i - 1001 ] * ( i > 999 ) ; } while ( 1 ) { try { System . out . println ( a [ ( int ) input . nextInt ( ) ] ) ; } catch ( Exception e ) { break ; } } return a ; }
public static int [ ] mySort ( int [ ] arr , int n ) { int [ ] arr1 = new int [ n / 2 ] ; int [ ] arr2 = new int [ n / 2 ] ; Arrays . sort ( arr1 , arr1 . length ) ; Arrays . sort ( arr2 , arr2 . length ) ; return arr1 ; }
public static int minflip ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] , int p , int q , int n ) { int flip = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr1 [ i ] ^ arr2 [ i ] != arr3 [ i ] ) ) { flip ++ ; } } return flip == ( flip <= p + q ) ? - 1 : flip ; }
public static double sum ( int n ) { int i ; double s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) { s = s + 1 / i ; ; } return s ; }
public static void bitonicGenerator ( int [ ] arr , int n ) { int [ ] evenArr = new int [ n ] ; int [ ] oddArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( ( i % 2 ) == 0 ) && ( ( arr [ i ] & 1 ) != 0 ) ) { evenArr [ i ] = arr [ i ] ; } else { oddArr [ i ] = arr [ i ] ; } } Arrays . sort ( evenArr ) ; Arrays . sort ( oddArr ) ; oddArr = oddArr [ 0 ] ; int i = 0 ; for ( int j = 0 ; j < evenArr . length ; j ++ ) { arr [ i ] = evenArr [ j ] ; i ++ ; } for ( int j = 0 ; j < oddArr . length ; j ++ ) { arr [ i ] = oddArr [ j ] ; i ++ ; } }
public static int countPairs ( int [ ] arr , int n ) { int count = 0 ; int right = 0 ; int left = 0 ; boolean [ ] visited = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { visited [ arr [ right ] ] = false ; visited [ arr [ left ] ] = true ; right ++ ; } while ( ( right < n ) && ( visited [ arr [ right ] ] == false ) ) { while ( ( right < n && visited [ arr [ right ] ] == true ) ) { count += ( right - left ) ; visited [ arr [ right ] ] = true ; right ++ ; } while ( ( left < right && ( right != n && visited [ arr [ right ] ] == true ) ) ) { visited [ arr [ left ] ] = false ; left ++ ; } } return count ; }
public static class TreeNode { public static final TreeNode < Integer > val = new TreeNode < Integer > ( ) { public Integer val ( Integer val ) { return val ; } public TreeNode < Integer > left ( TreeNode < Integer > t ) { return null ; } public TreeNode < Integer > right ( TreeNode < Integer > t ) { return null ; } } ; class Solution { public boolean isSubtree ( TreeNode < Integer > s , TreeNode < Integer > t ) { TreeNode < Integer > s_res = preorder ( s , true ) ; TreeNode < Integer > t_res = preorder ( t , true ) ; return t_res . equals ( s_res ) ; } public String preorder ( TreeNode < Integer > root , boolean isLeft ) { if ( root == null ) { if ( isLeft ) return " lnull " ; else return " rnull " ; } return " # " + root . val + " ▁ " + preorder ( root . left , true ) + " ▁ " + preorder ( root . right , false ) ; } } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " linux " ) ) { Solution sObj = new Solution ( ) ; TreeNode < Integer > root = new TreeNode < Integer > ( 3 ) ; root . left = new TreeNode < Integer > ( 4 ) ; root . right = new TreeNode < Integer > ( 5 ) ; root . left . left = new TreeNode < Integer > ( 1 ) ; root . left . right = new TreeNode < Integer > ( 2 ) ; TreeNode < Integer > subRoot = new TreeNode < Integer > ( 4 ) ; subRoot . left = new TreeNode < Integer > ( 1 ) ; subRoot . right = new TreeNode < Integer > ( 2 ) ; String out = sObj . isSubtree ( root , subRoot ) ; System . out . println ( out ) ; } return null ; }
public static int M = 1001 ; ; int MOD = 998244353 ; int [ ] [ ] dp = new int [ M ] [ M ] ; int [ ] [ ] [ ] solve ( int idx , int diff , int N , int M , int K ) { if ( ( idx > N ) && ( diff == K ) ) { if ( ( diff == K ) && ( N > M ) && ( M > K ) ) return 1 ; return 0 ; } if ( ( dp [ idx ] [ diff ] != - 1 ) && ( dp [ idx ] [ diff ] != - 1 ) ) return dp [ idx ] [ diff ] ; ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; ; dp [ idx ] [ diff ] = ans % MOD ; ; return dp [ idx ] [ diff ] ; }
public static final String compute ( ) { final int NUM_SPHERES = 21 ; double [ ] [ ] sphereRadii = new double [ NUM_SPHERES ] [ ] ; for ( int i = 0 ; i < NUM_SPHERES ; i ++ ) { sphereRadii [ i ] = ( i + 30 ) * 1000 ; } double [ ] [ ] minlength = new double [ 2 * NUM_SPHERES ] [ ] ; for ( int i = 0 ; i < NUM_SPHERES ; i ++ ) { minlength [ i ] = new double [ 2 * NUM_SPHERES ] ; } final int currentsphereIndex = sphereRadii . length ; final int setofspheres = minlength [ currentsphereIndex ] [ setofspheres ] ; if ( setofspheres & ( 1 << currentsphereIndex ) == 0 ) { throw new IllegalArgumentException ( ) ; } if ( minlength [ currentsphereIndex ] [ setofspheres ] == 0 ) { if ( EMF . popCount ( setofspheres ) == 1 ) { double result = sphereRadii [ currentsphereIndex ] ; if ( result == Double . POSITIVE_INFINITY ) { result = Double . POSITIVE_INFINITY ; } else { result = Double . MAX_VALUE ; int newsetofspheres = setofspheres ^ ( 1 << currentsphereIndex ) ; for ( int i = 0 ; i < NUM_SPHERES ; i ++ ) { if ( newsetofspheres & ( 1 << i ) == 0 ) continue ; double temp = Math . sqrt ( ( sphereRadii [ i ] + sphereRadii [ currentsphereIndex ] - 50000 ) * 200000 ) ; temp += findMinimumLength ( i , newsetofspheres ) ; result = Math . min ( temp , result ) ; } } minlength [ currentsphereIndex ] [ setofspheres ] = result ; } } double ans = Math . min ( ( findMinimumLength ( i , ( 1 << NUM_SPHERES ) - 1 ) + sphereRadii [ i ] ) , 0 ) ; return String . valueOf ( ( int ) Math . round ( ans ) ) ; }
public static void main ( String [ ] args ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ question ▁ to ▁ solve " ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] t = Arrays . stream ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ to ▁ solve " ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; Arrays . sort ( t ) ; int a = t [ 0 ] * t [ 1 ] + t [ 2 ] * t [ 3 ] ; int b = t [ 0 ] * t [ 1 ] + t [ 1 ] * t [ 2 ] ; if ( a == b ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public static int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { if ( ( N % 2 == 0 ) && ( N % 3 == 0 ) ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; }
public static int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( ( freq % 2 == 1 ) ) { res = res ^ arr [ i ] ; } } return res ; }
public static void main ( String [ ] args ) { int l = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ long ▁ integer " ) ) ; int p = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ long ▁ integer " ) ) ; int q = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ a ▁ long ▁ integer " ) ) ; int s = l / ( p + q ) ; long x = p * s ; System . out . println ( x ) ; }
public static int main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ compared " ) ) ; int [ ] l = new int [ Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ digits ▁ to ▁ be ▁ compared " ) ) ] ; Arrays . sort ( l ) ; System . out . println ( l [ n ] - l [ n - 1 ] ) ; } }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] t = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { t [ i ] = Integer . parseInt ( input . nextLine ( ) ) ; } int ans = 0 ; int [ ] freq = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( - t [ i ] < 0 ) { ans += freq [ - t [ i ] ] ; } if ( t [ i ] < freq [ i ] ) { freq [ t [ i ] ] ++ ; } else { freq [ t [ i ] ] = 1 ; } } System . out . println ( ans ) ; }
public static java . util . List < String > getAlarre ( ) { java . util . List < String > arre = new java . util . ArrayList < String > ( ) ; while ( java . util . Scanner . nextLine ( ) . toLowerCase ( ) . contains ( " ▁ " ) ) { java . util . Scanner . nextLine ( ) . toLowerCase ( ) ; arre . add ( java . util . Scanner . nextLine ( ) . toLowerCase ( ) ) ; } String oString = new java . util . Scanner ( System . in ) . nextLine ( ) ; String lowString = oString . toLowerCase ( ) ; String letter1 = System . in . nextLine ( ) . toLowerCase ( ) ; String letter2 = " a " . equals ( letter1 ) ? " b " : " c " ; int valid = new Integer ( oString . length ( ) ) ; Set < Integer > setcito = new HashSet < Integer > ( ) ; for ( String x : arre ) { if ( lowString . indexOf ( x ) >= 0 ) { int wat = 0 ; while ( true ) { int index = lowString . indexOf ( x , wat ) ; if ( index < 0 ) break ; for ( int i = index ; i < index + x . length ( ) ; i ++ ) setcito . add ( i ) ; wat = index + 1 ; } } } oString = Arrays . asList ( oString ) ; for ( int i = 0 ; i < setcito . size ( ) ; i ++ ) { String letter = letter1 . equals ( lowString ) ? letter2 : letter1 ; oString . set ( i , letter . equals ( letter2 ) ? letter . toUpperCase ( ) : letter . substring ( 1 ) ) ; } for ( String x : oString ) { System . out . print ( x + " ▁ " ) ; } System . out . println ( ) ; return arre ; }
public static int main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; String S = Arrays . stream ( sc . nextLine ( ) . trim ( ) . split ( " ▁ " ) ) . collect ( Collectors . toList ( ) ) ; int Wn = 0 ; int En = 0 ; int Wc = 0 ; int Ec = 0 ; for ( int i = 0 , n = S . length ( ) ; i < n ; i ++ ) { if ( S . charAt ( i ) == ' W ' ) Wc ++ ; else Ec ++ ; Wn ++ ; En ++ ; } int ans = 10 * 10 ; Wn = new int [ Wn ] ; En = new int [ En ] ; for ( int i = 0 , n = S . length ( ) ; i < n ; i ++ ) { if ( S . charAt ( i ) == ' W ' ) Wc ++ ; else Ec ++ ; Wn [ i ] = Wc ; En [ i ] = Ec ; } ans = 10 * 10 ; Wn = new int [ Wn ] ; En = new int [ En ] ; for ( int i = 0 , n = Wn . length ; i < n ; i ++ ) { ans = Math . min ( Wn [ i ] + En [ N ] - En [ i + 1 ] , ans ) ; } System . out . println ( ans ) ; }
public static int n ( String input ) { int chips [ ] = Arrays . stream ( input . split ( " ▁ " ) ) . toArray ( ) ; int odd = 0 ; int even = 0 ; for ( int num : chips ) { if ( num % 2 == 0 ) even ++ ; else odd ++ ; } System . out . println ( Math . min ( even , odd ) ) ; return chips [ 0 ] ; }
public static final boolean [ ] [ ] getQuadruplet ( ) { final int N = 10100000 ; boolean [ ] [ ] temp = new boolean [ N + 1 ] [ ] ; temp [ 0 ] = temp [ 1 ] = false ; for ( int i = 2 ; i <= ceil ( sqrt ( N + 1 ) ) ; i ++ ) { if ( temp [ i ] != false ) { temp [ i + i ] = new boolean [ temp [ i + i ] . length ] ; } } boolean quadruplet [ ] [ ] = { { true } , { false } , { true } , { false } , { false } , { true } , { false } , { true } , { true } } ; while ( true ) { try { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ n ▁ to ▁ test " ) ) ; if ( n == 0 ) break ; for ( int i = n ; i >= 9 ; i -- ) { if ( temp [ i ] != false && temp [ i - 8 ] == quadruplet [ i ] ) { System . out . println ( i ) ; break ; } } } catch ( Exception e ) { break ; } } return temp ; }
public static int n ( String input ) { int n = Integer . parseInt ( input ) ; int [ ] a = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] r = new int [ n ] ; int s = 0 ; int l = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] != 1 ) { s = s + a [ i ] ; int t = i + 1 - l ; int p = s - 1 * t ; if ( p % 2 == 0 ) { r [ i ] = 2 ; } else { r [ i ] = 1 ; } } else { l = l + 1 ; if ( r . length == 0 ) { r [ i ] = 2 ; } else { int q = r [ r . length - 1 ] ; r [ i ] = q ; } } } for ( int i = 0 ; i < r . length ; i ++ ) { System . out . println ( r [ i ] ) ; } return r . length ; }
public static boolean powerOfTwo ( int n ) { return ( ! ( n & n - 1 ) ) ; }
public static int minimumCostOfBreaking ( int [ ] X , int [ ] Y , int m , int n ) { int res = 0 ; Arrays . sort ( X , 0 , m ) ; Arrays . sort ( Y , 0 , n ) ; int hzntl = 1 ; int vert = 1 ; int i = 0 ; int j = 0 ; while ( ( i < m && j < n ) || ( i > n && j > m ) ) { if ( ( X [ i ] > Y [ j ] ) && ( X [ i ] < Y [ j ] ) ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( ( i < m ) || ( i < n ) ) { total += X [ i ] ; i ++ ; } res += total * vert ; total = 0 ; while ( ( j < n ) || ( j < m ) ) { total += Y [ j ] ; j ++ ; } res += total * hzntl ; return res ; }
public static final int gcd ( int a , int b ) { if ( ( a == 0 ) || ( b == 0 ) ) return b ; return gcd ( b % a , a ) ; } private static final int countPairs ( int G , int L ) { int count = 0 ; int p = G * L ; for ( int a = 1 ; a <= L ; a ++ ) { if ( ( ! ( p % a ) && gcd ( a , p / a ) == G ) || ( ! ( p % a ) && gcd ( a , p / a ) == G ) ) count ++ ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Total ▁ possible ▁ pair ▁ with ▁ GCD ▁ " + G + " ▁ & ▁ LCM ▁ " + L + " ▁ = ▁ " + countPairs ( G , L ) ) ; } return count ; }
public static int [ ] [ ] multiply ( int [ ] [ ] a , int [ ] [ ] b ) { int [ ] [ ] mul = new int [ 3 ] [ 3 ] ; for ( int y = 0 ; y < 3 ; y ++ ) mul [ y ] [ 0 ] = 0 ; ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) { mul [ i ] [ j ] = 0 ; ; for ( int k = 0 ; k < 3 ; k ++ ) mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; ; } ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) a [ i ] [ j ] = mul [ i ] [ j ] ; ; return a ; }
public static void MinimumValue ( int x , int y ) { if ( ( x > y ) && ( x < y ) ) { x = y ; y = x ; } int a = 1 ; int b = x - 1 ; int c = y - b ; System . out . println ( a + " ▁ " + b + " ▁ " + c ) ; }
public static class Solution { public static boolean checkPossibility ( final int [ ] nums ) { int brokenNum = 0 ; for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( ( nums [ i ] > nums [ i + 1 ] ) && ( nums [ i + 1 ] > nums [ i ] ) ) { brokenNum ++ ; if ( brokenNum >= 2 ) return false ; if ( ( i - 1 < 0 || nums [ i - 1 ] <= nums [ i + 1 ] ) && ( nums [ i ] > nums [ i + 1 ] ) ) nums [ i ] = nums [ i + 1 ] ; else nums [ i + 1 ] = nums [ i ] ; } } return true ; } if ( System . getProperty ( " user . dir " ) . equals ( " / home / user " ) ) { Solution sObj = new Solution ( ) ; int [ ] nums = { 4 , 2 , 3 } ; int out = sObj . checkPossibility ( nums ) ; System . out . println ( out ) ; } return false ; }
public static boolean check ( int mid , int [ ] array , int n , int K ) { int count = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( array [ i ] > mid ) && ( array [ i ] < sum ) ) { return false ; } sum += array [ i ] ; if ( ( sum > mid ) && ( array [ i ] < sum ) ) { count ++ ; sum = array [ i ] ; } } count ++ ; if ( ( count <= K ) && ( count > 0 ) ) { return true ; } return false ; } public static int solve ( int [ ] array , int n , int K ) { int start = 1 ; int end = 0 ; for ( int i = 0 ; i < n ; i ++ ) { end += array [ i ] ; } int answer = 0 ; while ( ( start <= end ) && ( start < end ) ) { int mid = ( start + end ) / 2 ; if ( ( check ( mid , array , n , K ) ) && ( answer > mid ) ) { answer = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } return answer ; } public static void main ( String [ ] args ) { if ( args . length == 0 ) { System . out . println ( " Usage : ▁ java ▁ - jar ▁ . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / . . / " )
public static final void main ( String [ ] args ) { int m = ( Integer . parseInt ( s ) ) ; int n = ( Integer . parseInt ( s ) ) ; if ( m == 0 ) break ; int [ ] objs = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) objs [ i ] = Integer . parseInt ( s , 2 ) ; int [ ] [ ] dp = new int [ 1 << m ] [ 1 << m ] ; int [ ] bits = new int [ 1 << m ] ; for ( int i = 0 ; i < m ; i ++ ) bits [ i ] = 1 << i ; for ( int mask = 0 ; mask < 1 << m ; mask ++ ) { Map < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( Integer obj : objs ) { s . put ( obj & mask , mask ) ; } for ( Map . Entry < Integer , Integer > masked : s . entrySet ( ) ) { if ( masked . getValue ( ) > 1 ) { dp [ mask ] [ masked . getKey ( ) ] = Math . min ( Math . max ( dp [ mask | b ] [ masked . getKey ( ) ] , dp [ mask | b ] [ masked . getValue ( ) | b ] ) + 1 , bits [ mask | b ] [ masked . getKey ( ) ] ) ; } } } System . out . println ( dp [ 0 ] [ 0 ] ) ; }
public static int test ( ) { int test = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ test ▁ cases " ) ) ; for ( int i = 0 ; i < test ; i ++ ) { int a = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ test ▁ cases ▁ to ▁ test " ) ; int b = JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ test ▁ cases ▁ to ▁ test " ) ; a = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ test ▁ cases ▁ to ▁ test " ) ) ; b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ test ▁ cases ▁ to ▁ test " ) ) ; int c = ( Math . min ( a , b ) * 2 ) * 2 ; int d = ( Math . max ( a , b ) * 2 ) ; System . out . println ( Math . max ( c , d ) ) ; } return test ; }
public static int t ( ) { int t = Integer . parseInt ( System . in ) ; while ( t > 0 ) { int n = Integer . parseInt ( System . in . readLine ( ) ) ; int [ ] a = Arrays . stream ( Integer . parseInt ( System . in . readLine ( ) ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int [ ] b = Arrays . stream ( Integer . parseInt ( System . in . readLine ( ) ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; String ans = " YES " ; int [ ] zero = new int [ n ] ; int temp = - 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( b [ i ] == 0 ) { zero [ i ] = a [ i ] ; continue ; } int x = a [ i ] - b [ i ] ; if ( temp == - 1 ) temp = x ; if ( x < 0 || x != temp ) { ans = " NO " ; break ; } } if ( n == zero . length ) temp = Math . max ( zero , zero [ 0 ] ) ; for ( int i : zero ) { if ( i <= temp ) continue ; else { ans = " NO " ; break ; } } System . out . println ( ans ) ; t -- ; } return t ; }
public static String evenOrOdd ( String N ) { int l = N . length ( ) ; ; if ( ( N . charAt ( l - 1 ) == '0' || N . charAt ( l - 1 ) == '2' || N . charAt ( l - 1 ) == '4' || N . charAt ( l - 1 ) == '6' ) ) return ( " Even " ) ; else return ( " Odd " ) ; }
public static List < String > getArrayList ( ) { int a [ ] = new int [ ] { Integer . parseInt ( input . nextLine ( ) ) } ; ArrayList < String > list = new ArrayList < String > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { list . add ( new Integer ( i ) ) ; } for ( int i = 0 ; i < a . length ; i ++ ) { int cmd [ ] = new int [ ] { Integer . parseInt ( input . nextLine ( ) ) } ; if ( cmd [ 0 ] == 0 ) { list . get ( cmd [ 1 ] ) . add ( cmd [ 2 ] ) ; } else if ( cmd [ 0 ] == 1 ) { String maped = map . get ( cmd [ 1 ] ) ; String output = " ▁ " + maped ; System . out . println ( output ) ; } else if ( cmd [ 0 ] == 2 ) { list . get ( cmd [ 1 ] ) . add ( cmd [ 2 ] ) ; } } return list ; }
n ; String [ ] num = new String [ n . length ( ) ] ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { num [ i ] = n . charAt ( i ) ; } int even = 0 ; for ( int i = 0 ; i < num . length ; i ++ ) { if ( Integer . parseInt ( num [ i ] ) % 2 == 0 ) { even ++ ; } } if ( even == 1 ) { for ( int i = 0 ; i < num . length ; i ++ ) { if ( Integer . parseInt ( num [ i ] ) % 2 == 0 ) { System . out . println ( num . length . toString ( ) + " ▁ " ) ; } } } else { for ( int i = 0 ; i < num . length ; i ++ ) { if ( Integer . parseInt ( num [ i ] ) % 2 == 1 ) { System . out . println ( num . length . toString ( ) + " ▁ " ) ; } } } return num ; }
public static int solve ( String X , String Y , int N , int K ) { int [ ] count = new int [ N + 1 ] ; ; int sol = 0 ; ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count [ i ] = ( count [ i - 1 ] + Math . abs ( ( char ) X . charAt ( i - 1 ) - ( char ) Y . charAt ( i - 1 ) ) ) ; ; } int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { while ( ( ( count [ i ] - count [ j ] ) > K ) && ( ( count [ i ] - count [ j ] ) > K ) ) j ++ ; sol = Math . max ( sol , i - j ) ; ; } return sol ; }
public static int n ( ) { int n = 0 , m = Integer . parseInt ( input . nextLine ( ) ) ; for ( ; m > 0 ; m -- ) { int a = Integer . parseInt ( input . nextLine ( ) ) ; while ( a > 0 ) { n ++ , a = a % a ; } } System . out . println ( new String [ ] { " No " , " Yes " } [ n == 1 ] ) ; return n ; }
public static boolean isPrime ( int n , int i ) { if ( ( n <= 2 ) && ( n == 2 ) ) return true ? ( n == 2 ) : false ; if ( ( n % i == 0 ) && ( i * i > n ) ) return false ; return isPrime ( n , i + 1 ) ; }
public static boolean isPrime ( int n ) { int i = 2 ; while ( ( i * i <= n ) && ( i % i == 0 ) ) { if ( ( n % i == 0 ) && ( i % i == 0 ) ) return false ; i ++ ; } return true ; }
public static final int isPrime ( int x ) { for ( int i = 2 ; i <= Integer . MAX_VALUE ; i ++ ) { if ( ( x % i == 0 ) && ( x % i == 1 ) ) return 0 ; } ; return 1 ; }
public static int snoob ( int x ) { int next = 0 ; if ( ( x > 0 ) && ( x < 1 ) ) { int rightOne = x & - ( x ) ; int nextHigherOneBit = x + Integer . MIN_VALUE ; int rightOnesPattern = x ^ Integer . MIN_VALUE ; rightOnesPattern = ( Integer . MIN_VALUE / rightOnesPattern ) ; rightOnesPattern = Integer . MAX_VALUE > > 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
public static int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j * j > i ) break ; if ( ( i % j == 0 ) && ( i / j == j ) ) { if ( ( i / j == j ) && ( j % i == 0 ) ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
static int getMinLength ( int arr [ ] , int n ) { int count = 0 ; ; int result = Integer . MAX_VALUE ; ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] == 1 ) && ( arr [ i + 1 ] == 1 ) ) { count ++ ; } else { if ( ( count != 0 ) && ( arr [ i + 1 ] == 1 ) ) { result = Math . min ( result , count ) ; } count = 0 ; } } return result ; }
INT_MAX = 99999999999 ; public static int getLevenstein ( String inpt ) { String revInput = inpt . substring ( 0 , inpt . length ( ) - 1 ) ; int n = inpt . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( inpt . charAt ( i - 1 ) == revInput . charAt ( j - 1 ) ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } int res = INT_MAX ; int i = n , j = 0 ; while ( i >= 0 ) { res = Math . min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = Math . min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = Math . min ( res , dp [ i - 1 ] [ j ] ) ; i -- ; j ++ ; } return res ; }
public static String compute ( ) { final int LIMIT = 12000 ; int [ ] minsumproduct = new int [ LIMIT + 1 ] ; minsumproduct [ 0 ] = 0 ; final int n = LIMIT ; final int remain = LIMIT ; final int maxfactor = LIMIT ; final int sum = 0 ; int terms = 0 ; if ( remain == 1 ) { if ( sum > n ) throw new AssertionError ( ) ; terms += n - sum ; if ( terms <= LIMIT && ( minsumproduct [ terms ] == 0 || n < minsumproduct [ terms ] ) ) minsumproduct [ terms ] = n ; } else { for ( int i = 2 ; i <= maxfactor ; i ++ ) { if ( remain % i == 0 ) { final int factor = i ; factorize ( n , remain / factor , Math . min ( factor , maxfactor ) , sum + factor , terms + 1 ) ; } } } for ( int i = 2 ; i <= LIMIT * 2 ; i ++ ) factorize ( i , i , i , 0 , 0 ) ; final int ans = sum + Arrays . hashCode ( minsumproduct , 2 ) ; return String . valueOf ( ans ) ; }
public static int N ( String input ) { int N = Integer . parseInt ( input ) ; int MOD = 10 * 9 + 7 ; int [ ] fact = new int [ N + 1 ] , factInv = new int [ N + 1 ] , inv = new int [ N + 1 ] ; int i ; int a [ ] = Arrays . copyOf ( input . split ( " ▁ " ) , N + 1 ) ; fact [ 0 ] = 1 ; for ( i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i % MOD ; factInv [ N ] = Math . pow ( fact [ N ] , MOD - 2 , MOD ) ; for ( i = N - 1 ; i > 0 ; i -- ) factInv [ i ] = factInv [ i + 1 ] * ( i + 1 ) % MOD ; for ( i = 1 ; i <= N ; i ++ ) inv [ i ] = factInv [ i ] * fact [ i - 1 ] % MOD ; int b [ ] = new int [ N ] , s [ ] = new int [ N + 1 ] ; for ( i = 1 ; i <= N ; i ++ ) s [ i ] = ( s [ i - 1 ] + inv [ i ] ) % MOD ; for ( i = 0 ; i < N ; i ++ ) b [ i ] = ( s [ i + 1 ] + s [ N - i ] - 1 ) % MOD ; int ans = 0 ; for ( i = 0 ; i < N ; i ++ ) ans = ( ans + a [ i ] * b [ i ] ) % MOD ; ans = ans * fact [ N ] % MOD ; System . out . println ( ans ) ; if ( Main . isWindows ) main ( ) ; return ans ; }
public static class Queue { public static final Runnable EMPTY = new Runnable ( ) { public void run ( ) { } public boolean isEmpty ( ) { return false ; } public void add ( Object o ) { } public void remove ( Object o ) { } public void front ( ) { } public void printQueue ( ) { for ( int i = 0 ; i < SIZE ; i ++ ) { System . out . print ( i + " ▁ " ) ; } System . out . println ( " " ) ; } } ; }
public static void main ( String [ ] args ) { MAX = 1000000 ; boolean [ ] prime = new boolean [ MAX + 1 ] ; prime [ 1 ] = false ; int p = 2 ; int c = 0 ; while ( ( p * p <= MAX ) && ( prime [ p ] == true ) ) { c ++ ; if ( ( prime [ p ] == true ) && ( prime [ p * 2 ] == true ) ) { for ( int i = p * 2 ; i < MAX + 1 ; i += p ) { prime [ i ] = false ; } } p ++ ; } final int [ ] arr = { 1 , 2 , 3 , 5 } ; int min = MAX + 2 ; int max = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( prime [ arr [ i ] ] == true ) && ( arr [ i ] > max ) ) { max = arr [ i ] ; } if ( ( arr [ i ] < min ) && ( arr [ i ] > max ) ) { min = arr [ i ] ; } } System . out . println ( " No ▁ prime ▁ numbers " ) ; SieveOfEratosthenes ( ) ; int n = 4 ; int [ ] arr = { 1 , 2 , 3 , 5 } ; int res = findDiff ( arr , n ) ; if ( ( res == - 1 ) && ( n == 0 ) ) { System . out . println ( " No ▁ prime ▁ numbers " ) ; } else { System . out . println ( " Difference ▁ is ▁ " + res ) ; } }
public static int find ( int x , int [ ] par_lst ) { if ( par_lst [ x ] == x ) return x ; int root = find ( par_lst [ x ] , par_lst ) ; par_lst [ x ] = root ; return root ; }
public static LinkedList < Integer > li = new LinkedList < Integer > ( ) { int ind = 0 ; for ( int i = 1 ; i <= 371 ; i ++ ) { LinkedList < Integer > temp ; int p = i , q = i ; int count = 0 ; while ( p != 0 ) { p /= 10 ; count ++ ; } if ( count == 1 ) li . add ( i ) ; if ( count == 2 ) { temp = new LinkedList < Integer > ( ) ; while ( q != 0 ) { int x = q % 10 ; q /= 10 ; temp . add ( x ) ; } li = li . concat ( temp ) ; } if ( count == 3 ) { temp = new LinkedList < Integer > ( ) ; while ( q != 0 ) { int x = q % 10 ; q /= 10 ; temp . add ( x ) ; } li = li . concat ( temp ) ; } } li . removeLast ( ) ; li . removeFirst ( ) ; int n = Integer . parseInt ( JOptionPane . showInputDialog ( null , " " ) ) ; System . out . println ( li . get ( n - 1 ) ) ; return li ; }
public static int distinctSubstring ( char [ ] P , int N ) { Map < String , Integer > S = Maps . newHashMap ( ) ; for ( int i = 0 ; i < N ; i ++ ) { boolean [ ] freq = new boolean [ 26 ] ; String s = " " ; for ( int j = i ; j < N ; j ++ ) { int pos = Character . digit ( P [ j ] , 16 ) - Character . digit ( ' a ' , 16 ) ; if ( ( freq [ pos ] == true ) && ( freq [ j ] == false ) ) break ; freq [ pos ] = true ; s += P [ j ] ; S . put ( s , 1 ) ; } } return S . size ( ) ; }
public static int n ( ) { int n , k ; int a [ ] = Arrays . copyOf ( input ( ) . toCharArray ( ) , input ( ) . length ) ; if ( ( ( n - k ) % ( k - 1 ) == 0 ) && ( ( n - k ) / ( k - 1 ) == 0 ) ) ans = ( n - k ) / ( k - 1 ) ; else ans = ( n - k ) / ( k - 1 ) + 1 ; System . out . println ( ans + 1 ) ; }
public static int minimumAdjacentDifference ( int [ ] a , int n , int k ) { int INT_MAX = Integer . MAX_VALUE ; ; int INT_MIN = - ( Integer . MAX_VALUE - 1 ) ; int minDiff = INT_MAX ; for ( int i = 0 ; i < 1 << n ; i ++ ) { int cnt = bin ( i ) . contains ( "1" ) ; ; if ( ( cnt == n - k ) && ( i & ( 1 << j ) ) != 0 ) { int [ ] temp = new int [ n ] ; ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i & ( 1 << j ) ) != 0 ) && ( j & ( 1 << k ) ) != 0 ) temp [ j ] = a [ j ] ; ; } int maxDiff = INT_MIN ; ; for ( int j = 0 ; j < temp . length - 1 ; j ++ ) maxDiff = Math . max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ; ; minDiff = Math . min ( minDiff , maxDiff ) ; ; } } return minDiff ; }
public static void difference ( int arr [ ] , int n ) { int largest = arr [ 0 ] ; ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( ( largest < arr [ i ] ) && ( arr [ i ] > arr [ i ] ) ) { largest = arr [ i ] ; } } for ( i = 0 ; i < n ; i ++ ) { arr [ i ] = largest - arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } ; }
public static int countKdivPairs ( int [ ] A , int n , int K ) { int [ ] freq = new int [ K ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ A [ i ] % K ] ++ ; int sum = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ; ; int i = 1 ; while ( ( i <= K / 2 && i != ( K - i ) ) || ( i == K ) ) { sum += freq [ i ] * freq [ K - i ] ; i ++ ; } if ( ( K % 2 == 0 ) || ( ( K % 2 ) == 1 ) ) sum += ( freq [ K / 2 ] * ( freq [ K / 2 ] - 1 ) / 2 ) ; ; return ( int ) sum ; }
public static String f ( String [ ] a ) { for ( int x = ' b ' ; x <= ' w ' ; x ++ ) { if ( a [ 0 ] . length ( ) == 3 || a [ 2 ] . length ( ) == 7 ) return x ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( a [ i * 3 ] . length ( ) == 3 || a [ i ] . length ( ) == 7 ) return x ; } } return " NA " ; }
public static int maxOnesIndex ( int [ ] arr , int n ) { int maxCount = 0 ; int maxIndex = 0 ; int prevZero = - 1 ; int prevPrevZero = - 1 ; for ( int curr = 0 ; curr < n ; curr ++ ) { if ( ( arr [ curr ] == 0 ) && ( arr [ curr ] != - 1 ) ) { if ( ( curr - prevPrevZero > maxCount ) && ( arr [ curr ] != - 1 ) ) { maxCount = curr - prevPrevZero ; maxIndex = prevZero ; } prevPrevZero = prevZero ; prevZero = curr ; } } if ( ( n - prevPrevZero > maxCount ) && ( arr [ n - prevZero ] != - 1 ) ) { maxIndex = prevZero ; } return maxIndex ; }
public static int minimumX ( int n , int k ) { int ans = 10 * 18 ; for ( int i = k - 1 ; i > 0 ; i -- ) { if ( n % i == 0 ) ans = Math . min ( ans , i + ( n / i ) * k ) ; } return ans ; }
public static int moduloMultiplication ( int a , int b , int mod ) { int res = 0 ; ; a = a % mod ; ; while ( ( b ) ) { if ( ( b & 1 ) != 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; ; b >>= 1 ; } ; return res ; }
public static int searchnode ( int i , int [ ] [ ] u , int [ ] [ ] path ) { int r = 1 ; u [ i ] = 1 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( path [ i ] [ j ] != null && ( ! u [ j ] ) ) { r += searchnode ( j , u , path ) ; } } return r ; } while ( ( true ) ) { int n = Integer . parseInt ( System . in . readLine ( ) ) ; if ( n == 0 ) break ; String [ ] strs = Arrays . stream ( new String [ n ] ) . map ( x -> new String ( x [ 0 ] , x [ n - 1 ] ) ) . collect ( Collectors . joining ( " , " ) ) ; int [ ] ss = new int [ 26 ] , ee = new int [ 26 ] ; path = new int [ 27 ] ; u [ 0 ] = 0 ; for ( int s = 0 , e = 0 ; s < n ; s ++ ) { ss [ ( int ) s - ' a ' ] ++ ; ee [ ( int ) e - ' a ' ] ++ ; path [ ( int ) s - ' a ' ] [ ( int ) e - ' a ' ] ++ ; } if ( new int [ 1 ] [ ss . length ] [ ee . length ] . length == 0 ) { System . out . println ( " NG " ) ; continue ; } System . out . println ( " OK " . equals ( new int [ 1 ] [ ss . length ] [ ee . length ] ) ? searchnode ( ( int ) ss [ 0 ] - ' a ' , u , path ) : " NG " ) ; } return 0 ; }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int [ ] a = Arrays . stream ( input . nextLine ( ) . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int ma = max ( a ) ; int mai = a . indexOf ( ma ) ; int mi = min ( a ) ; int mii = a . indexOf ( mi ) ; int [ ] ans = new int [ n ] ; if ( Math . abs ( ma ) >= Math . abs ( mi ) ) { for ( int i = 0 ; i < n ; i ++ ) { a [ i ] += ma ; ans [ mai ++ ] = ( mai + 1 ) ; } for ( int i = 1 ; i < n ; i ++ ) { a [ i ] += a [ i - 1 ] ; ans [ mii ++ ] = ( mii + 1 ) ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { a [ i ] += a [ i + 1 ] ; ans [ i + 2 ] = ( i + 2 ) ; } } System . out . println ( ans . length ) ; for ( int i : ans ) { System . out . println ( * i ) ; } return ans . length ; }
public static boolean checkPalindrome ( String string ) { int length = string . length ( ) ; length -- ; for ( int i = 0 ; i < length ; i ++ ) { if ( string . charAt ( i ) != string . charAt ( length ) ) { return false ; } length -- ; } return true ; } public static void printSolution ( int [ ] [ ] partitions ) { for ( int i = 0 ; i < partitions . length ; i ++ ) { for ( int j = 0 ; j < partitions [ i ] . length ; j ++ ) { System . out . print ( partitions [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } public static void addStrings ( Vector < String > v , String s , Vector < String > temp , int index ) { int length = s . length ( ) ; String string = " " ; Vector < String > current = temp . clone ( ) ; if ( index == 0 ) { temp . clear ( ) ; } for ( int i = index ; i < length ; i ++ ) { string += s . charAt ( i ) ; if ( checkPalindrome ( string ) ) { temp . addElement ( string ) ; if ( i + 1 < length ) { addStrings ( v , s , temp . clone ( ) , i + 1 ) ; } else { v . addElement ( temp ) ; } temp = current ; } } } public static void partition ( String s , Vector < String > v ) { Vector < String > temp = new Vector < String > ( ) ; addStrings ( v , s , temp . clone ( ) , 0 ) ; printSolution ( v ) ; } public static void main ( String [ ] args ) { String s = " geeks " ; int [ ] partitions = new int [ length ] ; partition ( s , partitions ) ; } } </DOCUMENT>
public static int dp ( int n , int k ) { if ( tbl [ n ] [ k ] != null ) return tbl [ n ] [ k ] ; if ( ( k << 1 ) > n ) { k = n - k ; } if ( k == 0 ) ans = 1 ; else if ( k == 1 ) ans = n ; else ans = dp ( n - 1 , k ) + dp ( n - 1 , k - 1 ) ; tbl [ n ] [ k ] = ans % MOD ; return tbl [ n ] [ k ] ; tbl = new int [ 1001 ] ; int k = 0 ; int r , c , a1 , a2 , b1 , b2 ; r = Math . abs ( n - 1 ) ; a1 = n ; a2 = n ; b1 = n ; b2 = n ; r = Math . abs ( n - 1 ) ; c = n ; a1 = Math . abs ( n - 1 ) ; a2 = Math . abs ( n - 1 ) ; b1 = Math . abs ( n - 1 ) ; b2 = Math . abs ( n - 1 ) ; dr = Math . abs ( a1 - b1 ) ; if ( dr > r - dr ) { dr = r - dr ; } if ( ( dr << 1 ) == r ) { k ++ ; } dc = Math . abs ( a2 - b2 ) ; if ( dc > c - dc ) { dc = c - dc ; } if ( ( dc << 1 ) == c ) { k ++ ; } System . out . println ( ( dp ( dr + dc , Math . min ( dr , dc ) ) << k ) % MOD ) ; }
public static final void findSubsequence ( int [ ] arr , int n , int k ) { int [ ] M = new int [ n ] ; for ( int i = 0 ; i <= n ; i ++ ) M [ arr [ i ] ] ++ ; int [ ] numCount = new int [ k + 1 ] ; for ( int p = 0 ; p <= k ; p ++ ) { if ( p <= k ) { int i = 1 ; while ( p * i <= k ) { numCount [ p * i ] += M [ p ] ; i ++ ; } } else break ; } int lcm = 0 , length = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { if ( numCount [ i ] > length ) { length = numCount [ i ] ; lcm = i ; } } if ( lcm == 0 ) System . out . println ( - 1 ) ; else { System . out . print ( " LCM ▁ = ▁ { 0 } , ▁ Length ▁ = ▁ { 1 } " ) ; System . out . print ( lcm ) ; System . out . print ( " ▁ Indexes ▁ = ▁ " ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( lcm % arr [ i ] == 0 ) System . out . print ( i + " ▁ " ) ; } } if ( System . getProperty ( " os . name " ) . toLowerCase ( ) . contains ( " windows " ) ) { k = 14 ; arr = new int [ ] { 2 , 3 , 4 , 5 } ; n = arr . length ; findSubsequence ( arr , n , k ) ; } }
public static int countPairs ( int [ ] a , int [ ] b , int n , int m ) { int odd1 = 0 ; int even1 = 0 ; int odd2 = 0 ; int even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] % 2 == 1 ) && ( a [ i ] % 2 == 0 ) ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( ( b [ i ] % 2 == 1 ) && ( b [ i ] % 2 == 0 ) ) odd2 ++ ; else even2 ++ ; } int pairs = Math . min ( odd1 , odd2 ) + Math . min ( even1 , even2 ) ; return pairs ; }
public static int countPairs ( int [ ] a , int [ ] b , int n , int m ) { int odd1 = 0 ; int even1 = 0 ; int odd2 = 0 ; int even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] % 2 ) != 0 ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( ( b [ i ] % 2 ) != 0 ) odd2 ++ ; else even2 ++ ; } int pairs = ( Math . min ( odd1 , even2 ) + Math . min ( odd2 , even1 ) ) ; return pairs ; }
public static int maxDiff ( int arr [ ] , int arrSize ) { int maxDiff = arr [ 1 ] - arr [ 0 ] ; int minElement = arr [ 0 ] ; for ( int i = 1 ; i < arrSize ; i ++ ) { if ( ( arr [ i ] - minElement > maxDiff ) && ( arr [ i ] < minElement ) ) { maxDiff = arr [ i ] - minElement ; } if ( ( arr [ i ] < minElement ) && ( arr [ i ] > maxDiff ) ) { minElement = arr [ i ] ; } } return maxDiff ; }
public static int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ k + 1 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { C [ i ] [ i ] = 0 ; } for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < Math . min ( i , k ) + 1 ; j ++ ) { if ( ( j == 0 || j == i ) && ( C [ i ] [ j ] == 0 ) ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } } return C [ n ] [ k ] ; }
public static int MAX = 26 ; public static int minimumAddition ( String str1 , int Len ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < Len ; i ++ ) freq [ ( char ) str1 . charAt ( i ) - ' a ' ] ++ ; int maxFreq = Math . max ( freq ) ; int minAddition = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) if ( ( freq [ i ] > 0 ) && ( freq [ i ] < maxFreq ) ) minAddition += Math . abs ( maxFreq - freq [ i ] ) ; return minAddition ; }
public static int n ( ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; String a = input . nextLine ( ) ; String b = input . nextLine ( ) ; int ans = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { ans = ans + Math . min ( 10 - Math . abs ( Integer . parseInt ( a ) - Integer . parseInt ( b ) ) , Math . abs ( Integer . parseInt ( a ) - Integer . parseInt ( b ) ) ) ; } System . out . println ( ans ) ; }
public static void main ( String [ ] args ) { MAX = 32 ; int [ ] pow2 = new int [ MAX ] ; boolean [ ] visited = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { visited [ i ] = false ; } int [ ] ans = new int [ MAX ] ; final int power_2 = power_2 ; int an = 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { pow2 [ i ] = an ; an *= 2 ; } final int countSetBits = power_2 ; int setBits = 0 ; while ( ( x != 0 ) && ( x != power_2 ) ) { x = x & ( x - 1 ) ; setBits ++ ; } final int add = setBits ; int point = 0 ; int value = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( ( visited [ i ] ) ) { continue ; } else { if ( ( num & 1 ) != 0 ) { value += ( 1 << i ) ; } num = num / 2 ; } } ans [ point ] = value ; final int solve = pow ( pow2 , k ) ; ans [ point ] = k ; int countk = countSetBits ( k ) ; if ( ( pow2 [ countk ] < n ) && ( pow2 [ countk ] > n ) ) { System . out . println ( - 1 ) ; return ; } int count = 0 ; for ( int i = 0 ; i < pow2 [ countk ] - 1 ; i ++ ) { add ( pow2 [ countk ] ) ; count ++ ; if ( ( count == n ) && ( pow2 [ countk ] > n ) ) { break ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } }
public static final EulaLib < Integer > primes = new EulaLib < Integer > ( ) { public Integer compute ( ) { Integer ans = max ( ( ( a ) -> a ) , ( ( b ) -> b ) , ( a , b ) -> a * b ) ; return String . valueOf ( ans . intValue ( ) * ans . intValue ( ) ) ; } public void countConsecutivePrimes ( Integer ab ) { int a = ab . intValue ( ) ; int b = ab . intValue ( ) ; for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { int n = i * i + i * a + b ; if ( ! isPrime ( n ) ) { return i ; } } } }
public static int pratyush ( ) { for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { int n = Integer . parseInt ( input . nextLine ( ) ) ; int r = Integer . parseInt ( input . nextLine ( ) ) ; int a = Math . min ( r , n - 1 ) ; int ans = ( int ) ( ( a * ( a + 1 ) ) / 2 ) ; if ( a != r ) { ans ++ ; } System . out . println ( ans ) ; } return ans ; }
static final public int [ ] findSubset ( int [ ] a , int n ) { final int MAX = 100001 ; int [ ] isPrime = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) isPrime [ i ] = 0 ; final int [ ] sieve = new int [ MAX ] ; for ( int p = 2 ; p <= mt . ceil ( mt . sqrt ( MAX ) ) ; p ++ ) if ( ( isPrime [ p ] == 0 ) && ( i < 2 ) ) for ( int i = 2 * p ; i < MAX ; i += p ) isPrime [ i ] = 1 ; final int [ ] findSubset ( int [ ] a , int n ) { int cnt1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( a [ i ] == 1 ) && ( isPrime [ a [ i ] + 1 ] == 0 ) ) cnt1 ++ ; if ( ( cnt1 > 0 ) && ( n > 0 ) ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( ( a [ i ] != 1 ) && ( isPrime [ a [ i ] + 1 ] == 0 ) ) && ( a [ i ] != 1 ) ) { System . out . print ( cnt1 + 1 ) ; for ( int j = 0 ; j < cnt1 ; j ++ ) System . out . print ( "1" + " ▁ " ) ; System . out . print ( a [ i ] ) ; return null ; } } if ( ( cnt1 >= 2 ) && ( n > 0 ) ) { System . out . print ( cnt1 ) ; for ( int i = 0 ; i < cnt1 ; i ++ ) System . out . print ( "1" + " ▁ " ) ; System . out . print ( " \n " ) ; return null ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( ( isPrime [ a [ i ] + a [ j ] ] == 0 ) ) { System . out . print ( 2 ) ; System . out . print ( a [ i ] + " ▁ " + a [ j ] ) ; } System . out . println ( - 1 ) ; } sieve = sieve ; int [ ] A = { 2 , 1 , 1 }
public static int n ( int r , int t ) { int n = map . get ( input ) ; int [ ] speed = new int [ n ] ; for ( ; n > 0 ; n -- ) speed [ n - 1 ] = Integer . parseInt ( input . readLine ( ) ) ; int [ ] point = new int [ n ] ; int [ ] bottle = new int [ r ] ; for ( int i = 0 ; i < n ; i ++ ) { point [ i ] = ( point [ i ] + speed [ i ] ) % r ; bottle [ point [ i ] ] ++ ; } for ( ; t - 1 > 0 ; t -- ) { int [ ] nums = new int [ r ] ; for ( int i = 0 ; i < n ; i ++ ) { bottle [ point [ i ] ] -- ; point [ i ] = ( point [ i ] + speed [ i ] ) % r ; nums [ point [ i ] ] ++ ; } for ( int i = 0 ; i < r ; i ++ ) { if ( bottle [ i ] < nums [ i ] ) bottle [ i ] = nums [ i ] ; bottle [ i ] += nums [ i ] ; } } System . out . println ( Arrays . toString ( bottle ) ) ; return n ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Hoshino " ) ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( JOptionPane . showInputDialog ( " Hoshina " ) . replace ( " Hoshino " , " Hoshina " ) ) ; } return n ; }
public static int countRotations ( int [ ] arr , int low , int high ) { if ( ( high < low ) && ( high == low ) ) return 0 ; if ( ( high == low ) || ( high == 0 ) ) return low ; long mid = low + ( high - low ) / 2 ; ; mid = ( int ) mid ; if ( ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) ) return ( mid + 1 ) ; if ( ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) ) return mid ; if ( ( arr [ high ] > arr [ mid ] ) ) return countRotations ( arr , low , mid - 1 ) ; ; return countRotations ( arr , mid + 1 , high ) ; }
public static int main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = Integer . parseInt ( input . nextLine ( ) ) ; int m = Integer . parseInt ( input . nextLine ( ) ) ; int i = 0 ; while ( true ) { if ( i + 1 > m ) { ans = m ; break ; } m -= i + 1 ; i ++ ; i %= n ; } System . out . println ( ans ) ; }
public static boolean modularSum ( int [ ] arr , int n , int m ) { if ( ( n > m ) && ( n < m ) ) return true ; boolean [ ] DP = new boolean [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( ( DP [ 0 ] ) ) return true ; boolean [ ] temp = new boolean [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( ( DP [ i ] == true ) && ( DP [ ( j + arr [ i ] ) % m ] == false ) ) temp [ ( j + arr [ i ] ) % m ] = true ; } for ( int j = 0 ; j < m ; j ++ ) { if ( ( temp [ j ] ) ) DP [ j ] = true ; } DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
public static int n ( ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ read " ) ) ; List < Integer > a = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ input ▁ string ▁ to ▁ read " ) . split ( " ▁ " ) ) ; int q = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ read " ) ) ; for ( int i = 0 ; i < q ; i ++ ) { int b = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ read " ) ) , e = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ read " ) ) , k = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ read " ) ) ; System . out . println ( a . subList ( b , e ) . stream ( ) . filter ( k -> k . equals ( n ) ) . count ( ) ) ; } return n ; }
N , x ) STRNEWLINE ▁ */ public static int min ( int [ ] [ ] input , int [ ] [ ] A ) { int N = map ( input ) . length ; int [ ] [ ] INF = new int [ ( 1 << 42 ) - 1 ] [ N ] ; int [ ] [ ] cum = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j ++ ) { cum [ i ] [ j ] = Math . min ( cum [ i ] [ j - 1 ] , A [ j ] ) ; } } int ans = INF [ 0 ] ; for ( int k = 0 ; k < N ; k ++ ) { int score = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( j - k >= 0 ) { score += cum [ j - k ] [ j ] ; } else { score += Math . min ( cum [ 0 ] [ j ] , cum [ ( j - k ) % N ] [ - 1 ] ) ; } } ans = Math . min ( ans , k * x + score ) ; } System . out . println ( ans ) ; return ans ; }
public static int main ( String [ ] args ) { int d = Integer . parseInt ( System . getProperty ( " user . dir " ) ) , w = Integer . parseInt ( System . getProperty ( " user . dir " ) ) ; if ( d + w == 0 ) break ; int [ ] [ ] pond = new int [ d ] [ w ] ; for ( int i = 0 ; i < d ; i ++ ) pond [ i ] = Arrays . copyOf ( System . getProperty ( " user . dir " ) , d ) ; int ans = 0 ; for ( int left = 0 ; left < w - 1 ; left ++ ) { for ( int right = w - 1 ; right >= left ; right -- ) { for ( int top = 0 ; top < d - 1 ; top ++ ) { for ( int under = d - 1 ; under >= top ; under -- ) { int outh = 10 ; outh = Math . min ( outh , Math . min ( pond [ top ] [ left ] , right + 1 ) ) ; outh = Math . min ( outh , Math . min ( pond [ under ] [ left ] , right + 1 ) ) ; int [ ] zpond = Arrays . copyOf ( pond [ top ] , under ) ; outh = Math . min ( outh , Math . min ( zpond [ left ] [ top ] , under ) ) ; outh = Math . min ( outh , Math . min ( zpond [ right ] [ top ] , under ) ) ; int pondh = 0 ; for ( int i = top + 1 ; i < under ; i ++ ) pondh = Math . max ( pondh , Math . max ( pond [ i ] [ left ] , right ) ) ; if ( pondh < outh ) { int cap = outh * ( under - top - 1 ) * ( right - left - 1 ) - Math . min ( Math . abs ( pond [ i ] [ left ] - pondh ) , Math . abs ( pond [ i ] [ right ] - pondh ) ) ; ans = Math . max ( cap , ans ) ; } } } } } System . out . println ( ans ) ; return ans ; }
public static int num ( ) { int [ ] arr = new int [ ] { Integer . MIN_VALUE } ; int k = new Integer ( input . nextLine ( ) ) . intValue ( ) ; Set < Integer > different = new HashSet < Integer > ( ) ; int temp = 0 ; Arrays . sort ( arr ) ; for ( int x : arr ) { if ( ( x % k != 0 || ! x / k ) . contains ( x ) ) different . add ( x ) ; temp = Math . max ( different . size ( ) , temp ) ; } System . out . println ( temp ) ; }
public static int sum ( int k , int n ) { int sum = ( Math . pow ( k , n + 1 ) - Math . pow ( k - 1 , n + 1 ) ) ; ; return sum ; }
public static int solve ( int i , boolean tight , int sumSoFar , int Sum , String number , int length ) { if ( i == length ) { if ( sumSoFar == Sum ) { return 1 ; } else { return 0 ; } } int ans = dp [ i ] [ tight ] [ sumSoFar ] ; if ( ans != - 1 ) { return ans ; } ans = 0 ; for ( int currdigit = 0 ; ; ) { String currdigitStr = Integer . toString ( currdigit ) ; if ( ! tight && currdigitStr . compareTo ( number ) > 0 ) { break ; } boolean ntight = tight || currdigitStr . compareTo ( number ) < 0 ; int nSumSoFar = sumSoFar + currdigit ; ans += solve ( i + 1 , ntight , nSumSoFar , Sum , number , length ) ; } return ans ; }
public static int total ( ) { int numCases = Integer . parseInt ( System . in ) ; for ( int i = 0 ; i < numCases ; i ++ ) { String line = System . in . readLine ( ) ; if ( Integer . parseInt ( line ) >= 2 ) { total ++ ; } } System . out . println ( total ) ; return total ; }
public static class newNode { public static final Node < Integer > data = new Node < Integer > ( ) { public Integer data ( Integer key ) { return key ; } public Node < Integer > left ( ) { return null ; } public Node < Integer > right ( ) { return null ; } } ; }
public static int countSubarrays ( int [ ] a , int n , int x ) { int count = 0 ; int number = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] > x ) && ( a [ i ] > x ) ) { count ++ ; } else { number += ( count ) * ( count + 1 ) / 2 ; count = 0 ; } } if ( ( count ) > 0 ) { number += ( count ) * ( count + 1 ) / 2 ; } return ( int ) number ; }
public static int minCost ( int [ ] arr , int n ) { int countEven = 0 ; int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % 2 == 0 ) && ( arr [ i ] % 3 == 0 ) ) { countEven ++ ; } else { countOdd ++ ; } } return Math . min ( countEven , countOdd ) ; }
public static void printLastOccurrence ( int [ ] a , int n ) { int [ ] mp = new int [ 7 ] ; for ( int i = 0 ; i < n ; i ++ ) { mp [ a [ i ] ] = i ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( mp [ a [ i ] ] == i ) && ( a [ i ] != 0 ) ) { System . out . print ( a [ i ] + " ▁ " ) ; } } if ( Main . isWindows ) { int [ ] a = { 1 , 5 , 5 , 1 , 6 , 1 } ; n = a . length ; printLastOccurrence ( a , n ) ; } }
public static void main ( String [ ] args ) { while ( true ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display : ▁ " ) ) ; if ( n == 0 ) break ; List < Integer > s = Arrays . asList ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ characters ▁ to ▁ display : ▁ " ) ) ; if ( Math . max ( s . size ( ) , 2 ) < 0 ) System . out . println ( " NA " ) ; else { int t = s . indexOf ( 0 ) ; System . out . println ( n - t + 1 ) ; } } }
public static int countPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return ( countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ) ; }
static int sumOfAP ( int a , int d , int n ) { int sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
public static final int countPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] * arr [ j ] > arr [ i ] + arr [ j ] ) { count ++ ; } } } return count ; }
public static int coordinateCompression ( int arr [ ] , int n ) { Map < Integer , Integer > s = Maps . newHashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . put ( arr [ i ] , 1 ) ; int index = 0 ; Map < Integer , Integer > mp = Maps . newHashMap ( ) ; for ( Iterator itr = s . keySet ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { index ++ ; mp . put ( itr . next ( ) , index ) ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = mp . get ( arr [ i ] ) ; final int query = 6 ; int ans = 0 ; while ( ( index > 0 ) && ( ans > BIT [ index ] ) ) { ans = Math . max ( ans , BIT [ index ] ) ; index -= index & ( - index ) ; } return ans ; }
public static void main ( String [ ] args ) { int t = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ run " ) ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ run " ) ) ; int [ ] [ ] a = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { a [ j ] = Arrays . copyOf ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ times ▁ to ▁ run " ) , n ) ; } boolean ans = false ; for ( int j = 0 ; j < 5 ; j ++ ) { for ( int k = 0 ; k < 5 ; k ++ ) { if ( k != j ) { int cnt1 = 0 ; int cnt2 = 0 ; int cntno = 0 ; for ( int z = 0 ; z < n ; z ++ ) { if ( a [ z ] [ j ] == 1 ) cnt1 ++ ; if ( a [ z ] [ k ] == 1 ) cnt2 ++ ; if ( a [ z ] [ j ] == 0 && a [ z ] [ k ] == 0 ) cntno ++ ; } if ( cnt1 >= n / 2 && cnt2 >= n / 2 && cntno == 0 ) ans = true ; } } } if ( ans ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public static String compute ( ) { final int BASE = 10 ; final int DIGITS = 20 ; final int CONSECUTIVE = 3 ; final int MAX_SUM = 9 ; int innerlen = BASE * CONSECUTIVE ; int [ ] [ ] ways = new int [ innerlen - 1 ] [ ] ; for ( int digits = 1 ; digits <= DIGITS + CONSECUTIVE ; digits ++ ) { int [ ] newrow = new int [ DIGITS ] ; for ( int prefix = 0 ; prefix < innerlen ; prefix ++ ) { int sum = 0 ; if ( digit_sum ( prefix ) <= MAX_SUM ) { for ( int nextdigit = 0 ; nextdigit < BASE ; nextdigit ++ ) { sum += ways [ digits - 1 ] [ prefix % ( BASE * ( CONSECUTIVE - 1 ) ) ] [ BASE + nextdigit ] ; } } newrow [ digits - 1 ] = sum ; } ways [ digits - 1 ] = newrow ; } int ans = ways [ digits - 2 ] [ 0 ] - ways [ digits - 1 ] [ 0 ] ; return String . valueOf ( ans ) ; } private static int digit_sum ( int n ) { return Math . abs ( n ) ; } }
arr [ ] = new int [ ] { input . nextInt ( ) , input . nextInt ( ) , input . nextInt ( ) , input . nextInt ( ) } ; boolean exit = false ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( exit ) break ; for ( int j = 0 ; j < 3 ; j ++ ) { int countw = 0 ; int countb = 0 ; if ( arr [ i ] [ j ] == ' # ' ) countb ++ ; else countw ++ ; if ( arr [ i + 1 ] [ j ] == ' # ' ) countb ++ ; else countw ++ ; if ( arr [ i ] [ j + 1 ] == ' # ' ) countb ++ ; else countw ++ ; if ( arr [ i + 1 ] [ j + 1 ] == ' # ' ) countb ++ ; else countw ++ ; if ( countw >= 3 || countb >= 3 ) { System . out . println ( " YES " ) ; exit = true ; break ; } } } if ( ! exit ) System . out . println ( " NO " ) ; }
public static class Solution { public static boolean isToeplitzMatrix ( final int [ ] [ ] matrix ) { for ( int r = 0 ; r < matrix . length - 1 ; r ++ ) { for ( int c = 0 ; c < matrix [ 0 ] . length - 1 ; c ++ ) { if ( matrix [ r ] [ c ] != matrix [ r + 1 ] [ c + 1 ] ) { return false ; } } } return true ; } }
public static String compute ( ) { final int LIMIT = 10 * 9 ; int ans = 0 ; for ( int s = 1 ; s <= 2 ; s ++ ) { if ( s * s > ( LIMIT + 1 ) / 3 ) break ; for ( int t = s - 2 ; t > 0 ; t -- ) { if ( fractions . gcd ( s , t ) == 1 ) { int a = s * t ; int b = ( s * s - t * t ) / 2 ; int c = ( s * s + t * t ) / 2 ; if ( a * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) ans += p ; } if ( a * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) ans += p ; } if ( b * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) ans += p ; } if ( b * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) ans += p ; } } } } return String . valueOf ( ans ) ; }
public static void main ( String [ ] args ) { int n , t , L , b ; n = ( Integer . parseInt ( args [ 0 ] ) ) ; t = ( Integer . parseInt ( args [ 1 ] ) ) ; L = ( Integer . parseInt ( args [ 2 ] ) ) ; b = ( Integer . parseInt ( args [ 3 ] ) ) ; if ( ( n = Integer . parseInt ( args [ 4 ] ) ) == 0 ) break ; loses = new int [ L ] ; backs = new int [ b ] ; dp = new double [ n + 1 ] ; for ( int i = 0 ; i < 3 ; i ++ ) dp [ i ] = 0. ; for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = 1. ; stops = Arrays . stream ( stops ) . skip ( n + 1 ) . filter ( d -> d >= 0 ) . map ( d -> d < n ) . collect ( Collectors . toList ( ) ) ; for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i % 3 ] [ j ] = sum ( dp [ ( i + 2 ) % 3 ] [ d ] == loses ? dp [ ( i + 1 ) % 3 ] [ 0 ] : dp [ ( i + 1 ) % 3 ] [ d ] ) / 6 ) ; } } System . out . printf ( " { : . 6f } \n " , dp [ 0 ] [ 0 ] ) ; }
public static void main ( String [ ] args ) { for ( ; ; ) { int n = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ number ▁ of ▁ elements ▁ to ▁ print " ) ) ; int [ ] arr = ArrayUtils . toPrimitive ( JOptionPane . showInputDialog ( " Enter ▁ the ▁ elements ▁ to ▁ print " ) ) ; int oddCount = 0 , evenCount = 0 , oddSum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] & 1 ) { oddSum += arr [ i ] ; oddCount ++ ; } else { evenCount ++ ; } } if ( oddSum % 2 > 0 ) { System . out . println ( " YES " ) ; } else if ( oddCount > 0 && evenCount > 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
static int minInsertions ( int [ ] H , int n , int K ) { int inser = 0 ; ; for ( int i = 1 ; i < n ; i ++ ) { int diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; ; if ( ( diff <= K ) && ( diff > K ) ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; ; } return inser ; }
public static int countWords ( String str , int l ) { int count = 1 ; ; if ( ( l == 1 ) || ( l == 2 ) ) return count ; if ( ( str . charAt ( 0 ) == str . charAt ( 1 ) ) && ( str . charAt ( 0 ) == str . charAt ( 1 ) ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j <= l - 1 ; j ++ ) { if ( ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) || ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) ) count *= 1 ; else if ( ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) ) count *= 2 ; else count *= 3 ; } if ( ( str . charAt ( l - 1 ) == str . charAt ( l - 2 ) ) && ( str . charAt ( l - 1 ) == str . charAt ( l - 2 ) ) ) count *= 1 ; else count *= 2 ; return count ; }
t = Integer . parseInt ( input . nextLine ( ) ) ; List < Integer > l = Collections . unmodifiableList ( Arrays . asList ( input . nextLine ( ) . split ( " ▁ " ) ) ) ; int s = sum ( l ) ; if ( s % 2 == 0 ) { System . out . println ( s ) ; } else { for ( int i : l ) { if ( i % 2 != 0 ) { System . out . println ( s - i ) ; break ; } } } return s ; }
public static int getPerfectSquares ( int n ) { int perfectSquares [ ] = new int [ n ] ; ; int current = 1 ; int i = 1 ; ; while ( ( current <= n ) && ( current < n ) ) { perfectSquares [ i ] = current ; i ++ ; current = ( int ) Math . pow ( i , 2 ) ; } ; return perfectSquares ; }
public static double findHypotenuse ( double side1 , double side2 ) { double h = ( ( ( side1 * side1 ) + ( side2 * side2 ) ) * ( 1 / 2 ) ) ; ; return h ; }
public static void printTwoOdd ( int [ ] arr , int size ) { int xor2 = arr [ 0 ] ; int setBitNo ; int n = size - 2 ; int x = 0 , y = 0 ; for ( int i = 1 ; i < size ; i ++ ) { xor2 = xor2 ^ arr [ i ] ; } setBitNo = xor2 & ~ ( xor2 - 1 ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & setBitNo ) != 0 ) { x = x ^ arr [ i ] ; } else { y = y ^ arr [ i ] ; } } System . out . println ( " The ▁ two ▁ ODD ▁ elements ▁ are " + x + " & " + y ) ; arr = new int [ ] { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arrSize = arr . length ; printTwoOdd ( arr , arrSize ) ; }
public static int solve ( int n , List < Integer > nums ) { int maxIndex = nums . indexOf ( max ( nums ) ) ; int minIndex = nums . indexOf ( min ( nums ) ) ; int ans = Integer . MAX_VALUE ; ans = Math . min ( ans , Math . max ( maxIndex , minIndex ) + 1 ) ; ans = Math . min ( ans , n - Math . min ( maxIndex , minIndex ) ) ; ans = Math . min ( ans , maxIndex + 1 + n - minIndex ) ; ans = Math . min ( ans , minIndex + 1 + n - maxIndex ) ; return ans ; }
static void main ( String [ ] args ) { final Scanner sc = new Scanner ( System . in ) ; final StringTokenizer st = new StringTokenizer ( " ▁ " ) ; final int [ ] I = new int [ ] { Integer . MIN_VALUE , Integer . MAX_VALUE } ; final InputFunction IS = new InputFunction < Integer > ( ) { public Integer apply ( Integer i ) { return new Integer ( i ) ; } } ; final InputFunction < Integer > IN = new InputFunction < Integer > ( ) { public Integer apply ( Integer i ) { return Integer . parseInt ( i ) ; } } ; final InputFunction < Double > IF = new InputFunction < Double > ( ) { public Double apply ( Double i ) { return Double . parseDouble ( i ) ; } } ; final int [ ] days = { 28 , 30 , 31 } ; final String [ ] week = { " monday " , " tuesday " , " wednesday " , " thursday " , " friday " , " saturday " , " sunday " } ; final String a = IS . next ( ) ; final String b = IS . next ( ) ; for ( int index = 0 ; index < week . length ; index ++ ) { if ( week [ ( ind + mo ) % 7 ] == b ) { ind = index ; } } boolean flag = false ; for ( int mo = 0 ; mo < days . length ; mo ++ ) { if ( week [ ( ind + mo ) % 7 ] == b ) { flag = true ; } } if ( flag ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } }
public static int kolvomest ( int kolvomest ) { int k = 0 ; int [ ] spisok = new int [ kolvomest ] ; for ( int stroka = 0 ; stroka < kolvomest ; stroka ++ ) { String ryad = JOptionPane . showInputDialog ( " Enter ▁ a ▁ string ▁ to ▁ print " ) ; if ( " OO " . equals ( ryad ) && k == 0 ) { k = 1 ; ryad = ryad . replaceAll ( " OO " , " + + " , 1 ) ; } spisok [ stroka ] = ryad ; } if ( k == 1 ) { System . out . println ( " YES " ) ; for ( int stroka = 0 ; stroka < kolvomest ; stroka ++ ) { System . out . println ( spisok [ stroka ] ) ; } } else { System . out . println ( " NO " ) ; } return k ; }
public static final void main ( String [ ] args ) { final Node head = new Node ( ) ; head . data = data ; head . next = null ; } public void prList ( Node head ) { if ( ( head == null ) || ( head . next == null ) ) return ; Node temp = head ; System . out . print ( temp . data + " - > " ) ; temp = temp . next ; while ( ( temp != head ) && ( temp . next != null ) ) { System . out . print ( temp . data + " - > " ) ; temp = temp . next ; } System . out . println ( head . data ) ; } public void deleteK ( Node headRef , int k ) { head = headRef ; if ( ( head == null ) || ( head . next == null ) ) return ; Node curr = head ; Node prev = null ; while ( true ) { if ( ( curr . next == head ) && curr == head ) break ; prList ( head ) ; for ( int i = 0 ; i < k ; i ++ ) { prev = curr ; curr = curr . next ; } if ( ( curr == head ) && ( prev . next != head ) ) { prev = head ; while ( ( prev . next != head ) && ( prev . next != null ) ) prev = prev . next ; head = curr . next ; prev . next = head ; headRef = head ; } else if ( ( curr . next == head ) && ( prev . next == head ) ) { prev . next = head ; } else { prev . next = curr . next ; } } } public void insertNode ( Node headRef , int x ) { head = headRef ; Node temp = new Node ( x ) ; if ( ( head == null ) || ( head . next == null ) ) { temp . next = temp ; headRef = temp ; return ; } else { Node temp1 = head ; while ( ( temp1 . next != head ) && ( temp1 . next != null ) ) temp1 = temp1 . next ; temp1 . next = temp ; temp . next = head ; } } }
public static long steps ( long cur , long x , long n ) { if ( x == 0 ) { return Long . MAX_VALUE ; } else if ( x > 0 ) { return Math . abs ( ( n - cur ) / x ) ; } else { return Math . abs ( ( long ) ( ( cur - 1 ) / x ) ) ; } } public static long countSteps ( long curx , long cury , long n , long m , int [ ] [ ] moves ) { long count = 0 ; int k = moves . length ; for ( int i = 0 ; i <= k ; i ++ ) { long x = moves [ i ] [ 0 ] ; long y = moves [ i ] [ 1 ] ; long stepct = Math . min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; count += stepct ; curx += stepct * x ; cury += stepct * y ; } return count ; } if ( GWT . isProdMode ( ) ) { int n = 4 ; int m = 5 ; int x = 1 , y = 1 ; int [ ] [ ] moves = { { 1 , 1 } , { 1 , 1 } , { 0 , - 2 } } ; System . out . println ( countSteps ( x , y , n , m , moves ) ) ; } return count ; }
n = input . nextLine ( ) ) { n . setCharAt ( 0 , Character . toUpperCase ( n . charAt ( 0 ) ) ) ; }
public static final int cntSubArr ( int arr [ ] , int n ) { int ans = 0 ; ; for ( int i = 0 ; i < n ; i ++ ) { int currGcd = 0 ; ; for ( int j = i ; j < n ; j ++ ) { currGcd = gcd ( currGcd , arr [ j ] ) ; ; ans += ( currGcd == 1 ) ; ; } ; } ; return ans ; }
public static boolean isVowel ( char c ) { if ( ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) && ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ) return true ; return false ; } public static final boolean isVowelPrime ( String Str , int n ) { boolean prime [ ] = new boolean [ n ] ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p < n ; p ++ ) { if ( p * p > n ) break ; if ( ( prime [ p ] == true ) && ( prime [ p ] == false ) ) { for ( int i = 2 * p ; i < n ; i += p ) prime [ i ] = false ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( isVowel ( Str . charAt ( i ) ) && prime [ i ] == false ) && ( prime [ i ] == true ) ) return false ; } return true ; } public static String getStr ( int i ) { return " geeksforgeeks " ; } public int getLen ( int i ) { return Str . length ( ) ; } public static int getLen ( String str ) { return str . length ( ) ; } public static int getLen ( String str ) { return str . length ( ) ; } public static int getLen ( String str ) { return str . length ( ) ; } public static int getLen ( String str ) { return str . length ( ) ; } public static int getLen ( String str ) { return str . length ( ) ; } public static int getLen ( String str ) { return str . length ( ) ; } public static int getLen ( String str ) { return str . length ( ) ; } public static int getLen ( String str ) { return str . length ( ) ; } public static int getLen ( String str ) { return str . length ( ) ; } public static int getLen ( String str ) { return str . length ( ) ; } public static int getLen ( String str ) { return str . length ( ) ; } public static int getLen ( String str ) { return str . length ( ) ; } }
public static int minStepToDeleteString ( String str ) { int N = str . length ( ) ; int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; for ( int l = 1 ; l <= N ; l ++ ) { int i = 0 ; int j = l - 1 ; while ( j < N ) { if ( ( l == 1 ) && ( str . charAt ( i ) == str . charAt ( i + 1 ) ) ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( ( str . charAt ( i ) == str . charAt ( i + 1 ) ) && ( str . charAt ( i + 2 ) == str . charAt ( i + 1 ) ) ) { dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; } for ( int K = i + 2 ; K <= j ; K ++ ) { if ( ( str . charAt ( i ) == str . charAt ( K ) ) && ( str . charAt ( K + 1 ) == str . charAt ( K + 2 ) ) ) { dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } i ++ ; j ++ ; } } return dp [ 0 ] [ N - 1 ] ; }
public static void main ( String [ ] args ) { int limit = 1000000 ; int [ ] position = new int [ limit + 1 ] ; for ( int i = 0 ; i < limit ; i ++ ) { position [ i ] = - 1 ; position [ i + 1 ] = - 1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( ( position [ i ] == 0 ) && ( position [ i + 1 ] == 0 ) ) { pos ++ ; position [ i ] = pos ; for ( int j = i * 2 ; j <= limit ; j += i ) { position [ j ] = - 1 ; } } } } if ( args . length == 0 ) { sieve ( position ) ; int n = 11 ; System . out . println ( position [ n ] ) ; } }
public static int getNumMonotone ( int ln ) { int [ ] [ ] DP = new int [ ln ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; i ++ ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 0 ; i < ln ; i ++ ) DP [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < ln ; i ++ ) for ( int j = 1 ; j < DP_s ; j ++ ) DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; return DP [ ln - 1 ] [ DP_s - 1 ] ; }
public static int getNumMonotone ( int ln ) { int [ ] [ ] DP = new int [ ln ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; i ++ ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 0 ; i < ln ; i ++ ) DP [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < ln ; i ++ ) for ( int j = 1 ; j < DP_s ; j ++ ) DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; return DP [ ln - 1 ] [ DP_s - 1 ] ; }
public static int maxCost ( int [ ] a , int n , int l , int r ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mx = Math . max ( mx , a [ i ] ) ; } int [ ] count = new int [ mx + 1 ] ; count [ a [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { count [ a [ i ] ] ++ ; } int [ ] res = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { int k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
public static boolean test ( ) { int nrow = map . get ( " R " ) . length ; int ncol = map . get ( " C " ) . length ; int [ ] [ ] arr = new int [ nrow ] [ ncol ] ; long val = 100000000000 ; int lr = 0 , lc = 0 ; for ( int rowId = 0 ; rowId < nrow ; rowId ++ ) { String [ ] temp = Arrays . copyOf ( map . get ( " R " ) , ncol ) ; arr [ rowId ] = new int [ ncol ] ; for ( int colId = 0 ; colId < ncol ; colId ++ ) { if ( temp [ colId ] . equals ( " R " ) ) { int temp2 = rowId + colId ; arr [ rowId ] [ colId ] = temp2 ; if ( temp2 < val ) { val = temp2 ; lr = rowId ; lc = colId ; } } else { arr [ rowId ] [ colId ] = 0 ; } } } for ( int i = 0 ; i < lr ; i ++ ) { int [ ] temp = arr [ i ] ; if ( Math . max ( temp [ 0 ] , temp [ 1 ] ) > 0 ) return false ; } for ( int i = 0 ; i < nrow ; i ++ ) { for ( int j = 0 ; j < lc ; j ++ ) { if ( arr [ i ] [ j ] > 0 ) return false ; } } return true ; }
public static double findArea ( double r ) { final double PI = 3.142 ; return PI * ( r * r ) ; ; }
public static void main ( String [ ] args ) { int n = map . get ( args [ 0 ] ) ; int [ ] s = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) s [ i - 1 ] = 1 ; int [ ] [ ] e = new int [ n ] [ n ] ; for ( ; n > 0 ; n -- ) { ( new Integer ( s [ 0 ] ) ) . intValue ( ) ; } e [ 0 ] = new int [ n ] ; for ( ; n > 0 ; n -- ) { ( new Integer ( s [ 0 ] ) ) . intValue ( ) ; e [ 0 ] [ 0 ] = n ; e [ 0 ] [ 1 ] = n ; } int [ ] q = new int [ n ] ; int [ ] fa = new int [ n ] ; fa [ 0 ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int x = q [ i ] ; for ( int y = e [ x ] . length ; y > 0 ; y -- ) { if ( fa [ y ] == - 1 ) { fa [ y ] = x ; q [ y ] = y ; } } } int [ ] dp = new int [ n ] ; int k2 = k * 2 ; for ( int x = 0 ; x < q . length ; x ++ ) { for ( int y = 0 ; y < e [ x ] . length ; y ++ ) { if ( fa [ y ] == x ) { int i = s [ y ] ; s [ x ] += i ; dp [ x ] += dp [ y ] + ( k2 - i > k ? i : k ) ; } } } System . out . println ( dp [ 0 ] ) ; }
public static int nthTerm ( int N ) { return ( Math . abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) ) ; }
public static int getHeight ( int X ) { return ( 2 * X ) ; }
public static int V = 4 ; public static int countwalks ( int [ ] [ ] graph , int u , int v , int k ) { if ( ( k == 0 && u == v ) || ( k == 1 && graph [ u ] [ v ] ) ) return 1 ; if ( ( k <= 0 ) && ( graph [ u ] [ v ] == 1 ) ) return 1 ; if ( ( k <= 0 ) && ( graph [ u ] [ v ] == 0 ) ) return 0 ; int count = 0 ; for ( int i = 0 ; i <= V ; i ++ ) { if ( ( graph [ u ] [ i ] == 1 ) && ( graph [ u ] [ i ] == 0 ) ) count += countwalks ( graph , i , v , k - 1 ) ; } return count ; }
public static final int findDigits ( int n , double b ) { if ( ( n < 0 ) || ( n > n ) ) return 0 ; final double M_PI = 3.141592 ; final double M_E = 2.7182 ; if ( ( n <= 1 ) || ( n > n ) ) return 1 ; double x = ( ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * Math . PI * n ) / 2.0 ) ) / ( Math . log10 ( b ) ) ; return Math . floor ( x ) + 1 ; if ( System . getProperty ( " os . arch " ) . contains ( " x86" ) ) { System . out . println ( findDigits ( 4 , 16 ) ) ; System . out . println ( findDigits ( 5 , 8 ) ) ; System . out . println ( findDigits ( 12 , 16 ) ) ; System . out . println ( findDigits ( 19 , 13 ) ) ; } return 0 ; }
public static class Bit extends Object { public static final int N = N ; public int [ ] bit ( int N ) { int [ ] bit = new int [ N + 1 ] ; bit [ 0 ] = 0 ; } public void add ( int a , int w ) { int x = a ; while ( x <= N ) { bit [ x ] += w ; x += x & - x ; } } public void sum ( int a ) { int ret = 0 ; int x = a ; while ( x > 0 ) { ret += bit [ x ] ; x -= x & - x ; } } public void rangeSum ( int x , int y ) { int ret1 = sum ( y ) ; int ret2 = sum ( x - 1 ) ; } }
public static int mod = 10 * 9 + 7 ; int n = Integer . parseInt ( System . in ) ; final int nthBit = ( n > > > d ) & 1 ; int [ ] [ ] dp = new int [ 61 ] [ 61 ] ; dp [ - 1 ] [ 0 ] = 1 ; for ( int d = 59 ; d >= 0 ; d -- ) { for ( int s = 0 ; s < 3 ; s ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { int s2 = Math . min ( 2 , 2 * s + nthBit - d ) ; if ( s2 >= 0 ) { dp [ d ] [ s2 ] += dp [ d + 1 ] [ s ] ; } } } } int ans = sum ( dp [ 0 ] ) % mod ; System . out . println ( ans ) ; return ans ; }
public static final Comparator < Integer > COMPARATOR = new Comparator < Integer > ( ) { @ Override public int compare ( Integer p , Integer q , Integer a , Integer n ) { final int num = a - p ; final int dem = n - a ; final int d = m - n ; final int s = s - dem ; if ( num == 0 ) return 1 ; if ( d == 0 ) return 0 ; if ( num * a / m < dem ) return 0 ; return sum ( ( int ) ( num * i - dem ) , ( int ) ( dem * i ) , d - 1 , m * i , i ) ; } }
public static String binaryConversion ( String s , int m ) { while ( ( m > 0 ) && ( s != null ) ) { int temp = m % 2 ; s += Integer . toString ( temp ) ; m = m / 2 ; } return s . substring ( 0 , s . length ( ) - 1 ) ; }
public static int countSubSets ( int [ ] arr , int n ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; int evenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { us . add ( arr [ i ] ) ; } } evenCount = us . size ( ) ; return Math . pow ( 2 , evenCount ) - 1 ; }
public static int MAX = 1000 ; int [ ] f = new int [ MAX ] ; f [ 0 ] = 0 ; f [ 1 ] = 0 ; f [ 2 ] = 0 ; f [ 3 ] = 0 ; f [ 4 ] = 0 ; f [ 5 ] = 0 ; f [ 6 ] = 0 ; f [ 7 ] = 0 ; f [ 8 ] = 0 ; f [ 9 ] = 0 ; f [ 10 ] = 0 ; f [ 11 ] = 0 ; f [ 12 ] = 0 ; f [ 13 ] = 0 ; f [ 14 ] = 0 ; f [ 15 ] = 0 ; f [ 16 ] = 0 ; f [ 17 ] = 0 ; f [ 18 ] = 0 ; f [ 19 ] = 0 ; f [ 20 ] = 0 ; f [ 21 ] = 0 ; f [ 22 ] = 0 ; f [ 23 ] = 0 ; f [ 24 ] = 0 ; f [ 25 ] = 0 ; f [ 26 ] = 0 ; f [ 27 ] = 0 ; f [ 28 ] = 0 ; f [ 29 ] = 0 ; f [ 30 ] = 0 ; f [ 31 ] = 0 ; f [ 32 ] = 0 ; f [ 33 ] = 0 ; f [ 34 ] = 0 ; f [ 35 ] = 0 ; f [ 36 ] = 0 ; f [ 37 ] = 0 ; f [ 38 ] = 0 ; f [ 39 ] = 0 ; f [ 40 ] = 0 ; f [ 41 ] = 0 ; f [ 42 ] = 0 ; f [ 43 ] = 0 ; f [ 44 ] = 0 ; f [ 45 ] = 0 ; f [ 51 ] = 0 ; f [ 52 ] = 0 ; f [ 53 ] = 0 ; f [ 54 ] = 0 ; f [ 55 ] = 0 ; f [ 56 ] = 0 ; f [ 57 ] = 0 ; f [ 58 ] = 0 ; f [ 59 ] = 0 ; f [ 60 ] = 0 ; f [ 61 ] = 0 ; f [ 62 ] = 0 ; f [ 63 ] = 0 ; f [ 64 ] = 0 ; f [ 65 ] = 0 ; f [ 66 ] = 0 ; f [ 67 ] = 0 ; f [ 68 ] = 0 ; f [ 69 ] = 0 ; f [ 70 ] = 0 ; f [ 71 ] = 0 ; f [ 72 ] = 0 ; f [ 73 ] = 0 ; f [ 74 ] = 0 ; f [
public static int findNumbers ( int n , int w ) { int x ; ; int sum ; if ( ( w >= 0 && w <= 8 ) || ( w >= - 9 && w <= - 1 ) ) x = 9 - w ; else if ( ( w >= 0 && w <= - 2 ) || ( w >= - 3 && w <= - 4 ) ) x = 10 + w ; sum = Math . pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; }
public static String findKthChar ( String s , int k ) { int len1 = s . length ( ) ; int i = 0 ; int totalLen = 0 ; while ( ( i < len1 ) && ( s . charAt ( i ) == ' ▁ ' ) ) { if ( ( s . charAt ( i ) == ' ▁ ' ) || ( s . charAt ( i ) == ' \t ' ) ) { totalLen ++ ; if ( ( totalLen == k ) && ( s . charAt ( i ) == ' \n ' ) ) { return s . substring ( i ) ; } i ++ ; } else { int n = 0 ; while ( ( i < len1 ) && ( s . charAt ( i ) == ' ▁ ' ) == false ) { n = n * 10 + ( ( char ) s . charAt ( i ) - '0' ) ; i ++ ; } int nextTotalLen = totalLen * n ; if ( ( k <= nextTotalLen ) && ( k > 0 ) ) { int pos = k % totalLen ; if ( ( pos == 0 ) || ( pos == k ) ) { pos = totalLen ; } return findKthChar ( s , pos ) ; } else { totalLen = nextTotalLen ; } } } return null ; } if ( Main . isWindows ) { s = " ab2c3" ; k = 5 ; System . out . println ( findKthChar ( s , k ) ) ; } return null ; }
public static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; ; return ( int ) ( n * ( n + 1 ) / 2 ) ; }
